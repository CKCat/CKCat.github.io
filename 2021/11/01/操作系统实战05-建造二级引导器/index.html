<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ckcat.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="二级引导器作为操作系统的先驱，它需要收集机器信息，确定这个计算机能不能运行我们的操作系统，对 CPU、内存、显卡进行一些初级的配置，放置好内核相关的文件。 二级引导器我们的二级引导器不是执行具体的加载任务，而是解析内核文件、收集机器环境信息。 二级引导器作为操作系统的先驱，它需要收集机器信息，确定这个计算机能不能运行我们的操作系统，对 CPU、内存、显卡进行一些初级的配置，放置好内核相关的文件。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统实战05-建造二级引导器">
<meta property="og:url" content="https://ckcat.github.io/2021/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9805-%E5%BB%BA%E9%80%A0%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8/index.html">
<meta property="og:site_name" content="CKCat的博客">
<meta property="og:description" content="二级引导器作为操作系统的先驱，它需要收集机器信息，确定这个计算机能不能运行我们的操作系统，对 CPU、内存、显卡进行一些初级的配置，放置好内核相关的文件。 二级引导器我们的二级引导器不是执行具体的加载任务，而是解析内核文件、收集机器环境信息。 二级引导器作为操作系统的先驱，它需要收集机器信息，确定这个计算机能不能运行我们的操作系统，对 CPU、内存、显卡进行一些初级的配置，放置好内核相关的文件。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ckcat.github.io/2021/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9805-%E5%BB%BA%E9%80%A0%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8/%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="article:published_time" content="2021-11-01T16:19:00.000Z">
<meta property="article:modified_time" content="2023-10-12T11:47:50.111Z">
<meta property="article:author" content="CKCat">
<meta property="article:tag" content="操作系统实战">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ckcat.github.io/2021/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9805-%E5%BB%BA%E9%80%A0%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8/%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png">


<link rel="canonical" href="https://ckcat.github.io/2021/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9805-%E5%BB%BA%E9%80%A0%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ckcat.github.io/2021/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9805-%E5%BB%BA%E9%80%A0%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8/","path":"2021/11/01/操作系统实战05-建造二级引导器/","title":"操作系统实战05-建造二级引导器"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>操作系统实战05-建造二级引导器 | CKCat的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">CKCat的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">二级引导器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%9C%BA%E5%99%A8%E4%BF%A1%E6%81%AF%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">设计机器信息结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%84%E5%88%92%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8"><span class="nav-number">1.2.</span> <span class="nav-text">规划二级引导器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-GRUB-%E5%A4%B4"><span class="nav-number">1.3.</span> <span class="nav-text">实现 GRUB 头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8"><span class="nav-number">1.4.</span> <span class="nav-text">进入二级引导器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A7%E5%A6%99%E8%B0%83%E7%94%A8-BIOS-%E4%B8%AD%E6%96%AD"><span class="nav-number">1.5.</span> <span class="nav-text">巧妙调用 BIOS 中断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">二级引导器主函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E4%B8%8E%E6%94%B6%E9%9B%86%E6%9C%BA%E5%99%A8%E4%BF%A1%E6%81%AF"><span class="nav-number">2.0.1.</span> <span class="nav-text">检查与收集机器信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5CPU"><span class="nav-number">2.1.</span> <span class="nav-text">检查CPU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">2.2.</span> <span class="nav-text">获取内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E6%A0%B8%E6%A0%88"><span class="nav-number">2.3.</span> <span class="nav-text">初始化内核栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%BE%E7%BD%AE%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E4%B8%8E%E5%AD%97%E5%BA%93%E6%96%87%E4%BB%B6"><span class="nav-number">2.4.</span> <span class="nav-text">放置内核文件与字库文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B-MMU-%E9%A1%B5%E8%A1%A8%E6%95%B0%E6%8D%AE"><span class="nav-number">2.5.</span> <span class="nav-text">建立 MMU 页表数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%9B%BE%E5%BD%A2%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.6.</span> <span class="nav-text">设置图形模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA-Logo"><span class="nav-number">2.7.</span> <span class="nav-text">显示 Logo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5-Cosmos"><span class="nav-number">2.8.</span> <span class="nav-text">进入 Cosmos</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A0%E8%BD%BD%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8%E3%80%82"><span class="nav-number">2.9.</span> <span class="nav-text">使用虚拟机加载二级引导器。</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CKCat</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">119</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/CKCat" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;CKCat" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ckcatck@qq.com" title="E-Mail → mailto:ckcatck@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ckcat.github.io/2021/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9805-%E5%BB%BA%E9%80%A0%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CKCat">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CKCat的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="操作系统实战05-建造二级引导器 | CKCat的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统实战05-建造二级引导器
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-01 16:19:00" itemprop="dateCreated datePublished" datetime="2021-11-01T16:19:00+00:00">2021-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-12 11:47:50" itemprop="dateModified" datetime="2023-10-12T11:47:50+00:00">2023-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">操作系统实战</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>二级引导器作为操作系统的先驱，它需要收集机器信息，确定这个计算机能不能运行我们的操作系统，对 CPU、内存、显卡进行一些初级的配置，放置好内核相关的文件。</p>
<h1 id="二级引导器"><a href="#二级引导器" class="headerlink" title="二级引导器"></a>二级引导器</h1><p>我们的二级引导器不是执行具体的加载任务，而是解析内核文件、收集机器环境信息。</p>
<p>二级引导器作为操作系统的先驱，它需要收集机器信息，确定这个计算机能不能运行我们的操作系统，对 CPU、内存、显卡进行一些初级的配置，放置好内核相关的文件。</p>
<h2 id="设计机器信息结构"><a href="#设计机器信息结构" class="headerlink" title="设计机器信息结构"></a>设计机器信息结构</h2><p>二级引导器的功能是收集信息，这里就需要设计一个数据结构存放相应的信息。我们将这个结构放在内存 1MB 的地方，方便以后传给我们的操作系统。</p>
<p>这个数据结构的关键代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cosmos/initldr/include/ldrtype.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_MACHBSTART</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">u64_t</span>    mb_krlinitstack;    <span class="comment">// 内核栈地址</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_krlitstacksz;    <span class="comment">// 内核栈大小</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_imgpadr;         <span class="comment">// 操作系统映像</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_imgsz;           <span class="comment">// 操作系统映像大小</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_bfontpadr;       <span class="comment">// 操作系统字体地址</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_bfontsz;         <span class="comment">// 操作系统字体大小</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_fvrmphyadr;      <span class="comment">// 机器显存地址</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_fvrmsz;          <span class="comment">// 机器显存大小</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_cpumode;         <span class="comment">// 机器CPU工作模式</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_memsz;           <span class="comment">// 机器内存大小</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_e820padr;        <span class="comment">// 机器e820数组地址</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_e820nr;          <span class="comment">// 机器e820数组元素个数</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_e820sz;          <span class="comment">// 机器e820数组大小</span></span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_pml4padr;        <span class="comment">// 机器页表数据地址</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_subpageslen;     <span class="comment">// 机器页表个数</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_kpmapphymemsz;   <span class="comment">// 操作系统映射空间大小</span></span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    <span class="type">graph_t</span> mb_ghparm;           <span class="comment">// 图形信息</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">machbstart_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="规划二级引导器"><a href="#规划二级引导器" class="headerlink" title="规划二级引导器"></a>规划二级引导器</h2><p>首先整体划分一下二级引导器的功能模块，从全局了解下功能应该怎么划分，如下表所示。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>imginithead.asm</td>
<td>GRUB 头的汇编部分</td>
</tr>
<tr>
<td>inithead.c</td>
<td>GRUB 头的 C 语言部分，用于放置二级引导器到指定的内存中</td>
</tr>
<tr>
<td>realintsve.asm</td>
<td>实现调用 BIOS 中断功能</td>
</tr>
<tr>
<td>ldrkrl32.asm</td>
<td>二级引导器核心入口汇编部分</td>
</tr>
<tr>
<td>ldrkrlentry.c</td>
<td>二级引导器核心入口</td>
</tr>
<tr>
<td>bstartparm.c</td>
<td>实现收集机器信息建立页面数据</td>
</tr>
<tr>
<td>chkcpmm.c</td>
<td>实现检查 CPU 工作模式和内存视图</td>
</tr>
<tr>
<td>fs.c</td>
<td>实现解析映像文件的功能</td>
</tr>
<tr>
<td>graph.c</td>
<td>实现切换显卡图形模式</td>
</tr>
<tr>
<td>vgastr.c</td>
<td>实现字符串输出</td>
</tr>
</tbody></table>
<p>它们在编译之后会形成三个文件，编译脚本我已经写好了，下面我们用一幅图来展示这个编译过程。</p>
<img src="/2021/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9805-%E5%BB%BA%E9%80%A0%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8/%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="">

<p>下面为二级引导器的整个执行时序图。</p>
<img  src=http://www.plantuml.com/plantuml/svg/hLHTRz9W5BxdLxoNCz45cHV62xCeYLaCYHVRTLEWGAKjf2r-t842snoJHJxSHbHmcs0CCBFC4Jx6Zx7dRRdoB_YsfUEZpEx2tlGzf-TvdlEUZwvACYtA2PvpiNoO5LWvmj31PLhYqPs7QDxr056C88kl4MJEb4uJbvj_-ZbuLzK60_J4kuvkoB7YyREoHF6n88DWwnFKTo1NngrpQAUXkGy73VYG6oKFrMBZolCxcSBLhIjpeP1b1uY6PLZvMYgkgQXvp4kHbHbAP6YE5MJf1HDYEPBVQTQ8ue8YSItxMG7XygRI-mNP0yYSgDlVrRqiP3CaB-H-TTVjTY_TU_he5eBZjBCM8OsAtBmESJdfUDpwi-JnMKhsSfX4AvvnqP_pSJiERzUrMawjTA1RL0_JIkz8hQPSCqWxqxKZG2RWjdbQywvVms9WZGhyZocOvLmWOjhZZBLXXLHIwURKRXtw9MZt5tBuZOs8qo9_DKdKnAUNJUz4Fwadd7-3IwUk6OITWQS34TD5oPHEDxdkp3UazWhuSreP56oCWKWq4EUd4Z8S2OIFalZB2NhyRCCr2PcB9sUAnB918djC-eNtsx3t3HVRE9VIaMjUHop5nOImqIXJaA2cMKQb8MxKe9ztpfjdUAIzlu1ysPnbwBo5dqbbMCEfjZEQD4f_ax10T594meIh7J8ODeAGD8Cr5WqNBzL1QumnDkoVi20JIiYXc21RmEP7w1PC8BhHVPdx7ZVIBiwquQQfEfsulixEB5P0c94GzBhgZntayssWKUrSgpN81EBTbfqbBDBno8J3C97MCYvHkOJ1rt7FLXaXIFx_Vm40>
<p>下面开始细节的讲解。</p>
<h2 id="实现-GRUB-头"><a href="#实现-GRUB-头" class="headerlink" title="实现 GRUB 头"></a>实现 GRUB 头</h2><p>我们的 GRUB 头有两个文件组成，一个 <code>imginithead.asm</code> 汇编文件，它主要工作是初始化 CPU 的寄存器，加载 GDT，切换到 CPU 的保护模式；第二就是 <code>inithead.c</code> 文件，它的主要功能是查找二级引导器的核心文件 <code>initldrkrl.bin</code> ，然后把它放置到特定的内存地址上。</p>
<p>首先需要 GRUB1 和 GRUB2 两个头结构，这里不用去深究，按规范定义即可，代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MBT_HDR_FLAGS  EQU 0x00010003</span><br><span class="line">MBT_HDR_MAGIC  EQU 0x1BADB002</span><br><span class="line">MBT2_MAGIC  EQU 0xe85250d6</span><br><span class="line">global _start</span><br><span class="line">extern inithead_entry</span><br><span class="line">[section .text]</span><br><span class="line">[bits 32]</span><br><span class="line">_start:</span><br><span class="line">  jmp _entry</span><br><span class="line">align 4</span><br><span class="line">mbt_hdr:</span><br><span class="line">  dd MBT_HDR_MAGIC</span><br><span class="line">  dd MBT_HDR_FLAGS</span><br><span class="line">  dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS)</span><br><span class="line">  dd mbt_hdr</span><br><span class="line">  dd _start</span><br><span class="line">  dd 0</span><br><span class="line">  dd 0</span><br><span class="line">  dd _entry</span><br><span class="line">ALIGN 8</span><br><span class="line">mbhdr:</span><br><span class="line">  DD  0xE85250D6</span><br><span class="line">  DD  0</span><br><span class="line">  DD  mhdrend - mbhdr</span><br><span class="line">  DD  -(0xE85250D6 + 0 + (mhdrend - mbhdr))</span><br><span class="line">  DW  2, 0</span><br><span class="line">  DD  24</span><br><span class="line">  DD  mbhdr</span><br><span class="line">  DD  _start</span><br><span class="line">  DD  0</span><br><span class="line">  DD  0</span><br><span class="line">  DW  3, 0</span><br><span class="line">  DD  12</span><br><span class="line">  DD  _entry </span><br><span class="line">  DD  0  </span><br><span class="line">  DW  0, 0</span><br><span class="line">  DD  8</span><br><span class="line">mhdrend:</span><br></pre></td></tr></table></figure>

<p>然后是关中断并加载 GDT ，代码如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">_entry:</span><br><span class="line">    cli                            ; 关中断.</span><br><span class="line"></span><br><span class="line">    in al, 0x70                    </span><br><span class="line">    or al, 0x80    </span><br><span class="line">    out 0x70,al                    ; 读取 CMOS/RTC 地址，设置最高位为 1 ，写入 0x70 端口，关闭不可屏蔽中断.</span><br><span class="line"></span><br><span class="line">    lgdt [GDT_PTR]                 ; 加载 GDT 地址到 GDTR 寄存器</span><br><span class="line">    jmp dword 0x8 :_32bits_mode    ; 长跳转刷新 CS 影子寄存器</span><br><span class="line"></span><br><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0                    ; 第一个段描述符CPU硬件规定必须为0</span><br><span class="line">kcode_dsc: dq 0x00cf9e000000ffff</span><br><span class="line">; [0000 0000]: 段基址:24~31</span><br><span class="line">; [1 1 0 0]: G:段长度的颗粒 1=4k,0=1b，D/B:操作数是否为32位，L:段是否64位模式，AVL: 系统待用</span><br><span class="line">; [1111]:段长度:16~19</span><br><span class="line">; [1 00 1 1 1 1 0] P:段是否在内存中，DPL:段描述符权限级别，S:段是系统段还是代码段和数据段，</span><br><span class="line">; T:代码段或数据段，C: 段是否可执行，R:段是否可读，A:段是否已经访问，由CPU自动设置</span><br><span class="line">; [0000 0000 0000 0000 0000 0000]:段基址0~23 </span><br><span class="line">; [1111 1111 1111 1111]:段长度:0~15</span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff</span><br><span class="line">k16cd_dsc: dq 0x00009e000000ffff	; 16位代码段描述符</span><br><span class="line">k16da_dsc: dq 0x000092000000ffff	; 16位数据段描述符</span><br><span class="line">GDT_END:</span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN	dw GDT_END-GDT_START-1	;GDT界限</span><br><span class="line">GDTBASE	dd GDT_START</span><br></pre></td></tr></table></figure>

<p>最后是初始化段寄存器和通用寄存器、栈寄存器，这是为了给调用 inithead_entry 这个 C 函数做准备，代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; 初始化段寄存器和通用寄存器、栈寄存器，调用 C 函数。</span><br><span class="line">_32bits_mode:</span><br><span class="line">	mov ax, 0x10</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov ss, ax</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov fs, ax</span><br><span class="line">	mov gs, ax</span><br><span class="line">	xor eax,eax</span><br><span class="line">	xor ebx,ebx</span><br><span class="line">	xor ecx,ecx</span><br><span class="line">	xor edx,edx</span><br><span class="line">	xor edi,edi</span><br><span class="line">	xor esi,esi</span><br><span class="line">	xor ebp,ebp</span><br><span class="line">	xor esp,esp</span><br><span class="line">	mov esp,0x7c00				; 设置栈顶为 0x7c00</span><br><span class="line">	call inithead_entry			; 调用 inithead_entry 函数在 inithead.c 中实现</span><br><span class="line">	jmp 0x200000				; 跳转到 0x200000(2M) 地址，该地址放置的 initldrkrl.bin 文件</span><br></pre></td></tr></table></figure>

<p>下面我们接着看 C 函 inithead_entry 的功能，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MDC_ENDGIC 0xaaffaaffaaffaaff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MDC_RVGIC 0xffaaffaaffaaffaa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REALDRV_PHYADR 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMGFILE_PHYADR 0x4000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMGKRNL_PHYADR 0x2000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDRFILEADR IMGFILE_PHYADR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOSDSC_OFF (0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MRDDSC_ADR (mlosrddsc_t*)(LDRFILEADR+0x1000)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inithead_entry</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">write_realintsvefile</span>();</span><br><span class="line">    <span class="built_in">write_ldrkrlfile</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写initldrsve.bin文件到特定的内存中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_realintsvefile</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">fhdsc_t</span> *fhdscstart = <span class="built_in">find_file</span>(<span class="string">&quot;initldrsve.bin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fhdscstart == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;not file initldrsve.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">m2mcopy</span>((<span class="type">void</span> *)((<span class="type">u32_t</span>)(fhdscstart-&gt;fhd_intsfsoff) + LDRFILEADR),</span><br><span class="line">            (<span class="type">void</span> *)REALDRV_PHYADR, (<span class="type">sint_t</span>)fhdscstart-&gt;fhd_frealsz);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写initldrkrl.bin文件到特定的内存中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_ldrkrlfile</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">fhdsc_t</span> *fhdscstart = <span class="built_in">find_file</span>(<span class="string">&quot;initldrkrl.bin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fhdscstart == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;not file initldrkrl.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">m2mcopy</span>((<span class="type">void</span> *)((<span class="type">u32_t</span>)(fhdscstart-&gt;fhd_intsfsoff) + LDRFILEADR),</span><br><span class="line">            (<span class="type">void</span> *)ILDRKRL_PHYADR, (<span class="type">sint_t</span>)fhdscstart-&gt;fhd_frealsz);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在映像文件中查找对应的文件</span></span><br><span class="line"><span class="function"><span class="type">fhdsc_t</span> *<span class="title">find_file</span><span class="params">(<span class="type">char_t</span> *fname)</span></span>&#123;</span><br><span class="line">    <span class="type">mlosrddsc_t</span> *mrddadrs = MRDDSC_ADR;</span><br><span class="line">    <span class="keyword">if</span> (mrddadrs-&gt;mdc_endgic != MDC_ENDGIC ||</span><br><span class="line">        mrddadrs-&gt;mdc_rv != MDC_RVGIC ||</span><br><span class="line">        mrddadrs-&gt;mdc_fhdnr &lt; <span class="number">2</span> ||</span><br><span class="line">        mrddadrs-&gt;mdc_filnr &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;no mrddsc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">s64_t</span> rethn = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">fhdsc_t</span> *fhdscstart = (<span class="type">fhdsc_t</span> *)((<span class="type">u32_t</span>)(mrddadrs-&gt;mdc_fhdbk_s) + LDRFILEADR);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">u64_t</span> i = <span class="number">0</span>; i &lt; mrddadrs-&gt;mdc_fhdnr; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmpl</span>(fname, fhdscstart[i].fhd_name) == <span class="number">0</span>)&#123;</span><br><span class="line">            rethn = (<span class="type">s64_t</span>)i;</span><br><span class="line">            <span class="keyword">goto</span> ok_l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rethn = <span class="number">-1</span>;</span><br><span class="line">ok_l:</span><br><span class="line">    <span class="keyword">if</span> (rethn &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;not find file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;fhdscstart[rethn];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进入二级引导器"><a href="#进入二级引导器" class="headerlink" title="进入二级引导器"></a>进入二级引导器</h2><p>在 <code>imginithead.asm</code> 的汇编文件中，最后一条指令 <code>jmp 0x200000</code> 将跳转到  <code>initldrkrl.bin</code> 存放的位置。</p>
<p>由于模块的改变，我们还需要写一小段汇编代码，建立下面这个 <code>ldrkrl32.asm</code> 文件，并写上如下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">; 二级引导器核心入口汇编部分</span><br><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">; 通过 imginithead.asm 中 jmp 0x200000 跳转过来。</span><br><span class="line">_start:</span><br><span class="line">_entry:</span><br><span class="line">	cli</span><br><span class="line">	lgdt [GDT_PTR]				; 加载 GDT 地址到 GDTR 寄存器  </span><br><span class="line">	lidt [IDT_PTR]				; 加载 IDT 地址到 IDTR 寄存器  </span><br><span class="line">	jmp dword 0x8 :_32bits_mode ; 长跳转刷新 CS 影子寄存器</span><br><span class="line"></span><br><span class="line">_32bits_mode:</span><br><span class="line">	mov ax, 0x10				; 数据段选择子(目的)</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov ss, ax</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov fs, ax</span><br><span class="line">	mov gs, ax</span><br><span class="line">	xor eax,eax</span><br><span class="line">	xor ebx,ebx</span><br><span class="line">	xor ecx,ecx</span><br><span class="line">	xor edx,edx</span><br><span class="line">	xor edi,edi</span><br><span class="line">	xor esi,esi</span><br><span class="line">	xor ebp,ebp</span><br><span class="line">	xor esp,esp</span><br><span class="line">	mov esp,0x90000				; 使得栈底指向了 0x90000</span><br><span class="line">	call ldrkrl_entry			; 调用 ldrkrl_entry 函数</span><br><span class="line">	xor ebx,ebx</span><br><span class="line">	jmp 0x2000000				; 跳转到 0x2000000 的内存地址，这里存放着 kernel.bin</span><br><span class="line">	jmp $</span><br><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0</span><br><span class="line">kcode_dsc: dq 0x00cf9a000000ffff </span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff</span><br><span class="line">k16cd_dsc: dq 0x00009a000000ffff ; 16位代码段描述符</span><br><span class="line">; [0000 0000]: 段基址:24~31</span><br><span class="line">; [0000] G:段长度的颗粒 1=4k,0=1b，D/B:操作数是否为32位，L:段是否64位模式，AVL: 系统待用</span><br><span class="line">; [0000] 段长度:16~19</span><br><span class="line">; [1 00 1 1110] P:段是否在内存中，DPL:段描述符权限级别，S:段是系统段还是代码段和数据段，</span><br><span class="line">; T:代码段或数据段，C: 段是否可执行，R:段是否可读，A:段是否已经访问，又CPU自动设置</span><br><span class="line">; [000000000000000000000000] 段基址0~23 </span><br><span class="line">; [1111111111111111] 段长度:0~15</span><br><span class="line">k16da_dsc: dq 0x000092000000ffff ; 16位数据段描述符</span><br><span class="line">GDT_END:</span><br><span class="line"></span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN	dw GDT_END-GDT_START-1	;GDT界限</span><br><span class="line">GDTBASE	dd GDT_START</span><br><span class="line"></span><br><span class="line">IDT_PTR:</span><br><span class="line">IDTLEN	dw 0x3ff	; BIOS 中断表的长度</span><br><span class="line">IDTBAS	dd 0		; BIOS 中断表的地址</span><br></pre></td></tr></table></figure>
<p>加载 GDT 和 IDT 之后，最后将会调用 C 函数 ldrkrl_entry 函数。</p>
<h2 id="巧妙调用-BIOS-中断"><a href="#巧妙调用-BIOS-中断" class="headerlink" title="巧妙调用 BIOS 中断"></a>巧妙调用 BIOS 中断</h2><p>C 语言环境下调用 BIOS 中断，需要处理的问题如下：</p>
<ol>
<li>保存 C 语言环境下的 CPU 上下文 ，即保护模式下的所有通用寄存器、段寄存器、程序指针寄存器，栈寄存器，把它们都保存在内存中。</li>
<li>切换回实模式，调用 BIOS 中断，把 BIOS 中断返回的相关结果，保存在内存中。</li>
<li>切换回保护模式，重新加载第 1 步中保存的寄存器。这样 C 语言代码才能重新恢复执行。</li>
</ol>
<p>相关代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">realadr_call_entry:</span><br><span class="line">	pushad						; 保存通用寄存器</span><br><span class="line">	push    ds</span><br><span class="line">	push    es</span><br><span class="line">	push    fs</span><br><span class="line">	push    gs					; 保存4个段寄存器</span><br><span class="line">	call save_eip_jmp			; 调用save_eip_jmp</span><br><span class="line">	pop	gs</span><br><span class="line">	pop	fs</span><br><span class="line">	pop	es</span><br><span class="line">	pop	ds						; 恢复4个段寄存器</span><br><span class="line">	popad						; 恢复通用寄存器</span><br><span class="line">	ret</span><br><span class="line">save_eip_jmp:</span><br><span class="line">	pop esi						; 弹出 call save_eip_jmp 时保存的 eip 到 esi 寄存器中</span><br><span class="line">	mov [PM32_EIP_OFF],esi		; 把 eip 保存到特定的内存空间中</span><br><span class="line">	mov [PM32_ESP_OFF],esp		; 把 esp 保存到特定的内存空间中</span><br><span class="line">	jmp dword far [cpmty_mode]	; 长跳转这里表示把 cpmty_mode 处的第一个 4 字节装入 eip ，把其后的 2 字节装入 cs </span><br><span class="line">cpmty_mode:</span><br><span class="line">	dd 0x1000					; 内存中 0x1000 存放着 initldrsve.bin 文件</span><br><span class="line">	dw 0x18</span><br><span class="line">	jmp $</span><br></pre></td></tr></table></figure>
<p>这里需要解释一下 <code>jmp dword far [cpmty_mode]</code>，表示把 <code>[cpmty_mode]</code> 处的数据装入 <code>CS：EIP</code>，也就是把 <code>0x18：0x1000</code> 装入到 <code>CS：EIP</code> 中，这个 0x18 就是段描述索引，它正是指向 GDT 中的 16 位代码段描述符。</p>
<p>因为跳转到 16 位代码处执行，这里需要新建一个 16 位汇编文件 <code>realintsve.asm</code>，内容如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[bits 16]</span><br><span class="line">_start:</span><br><span class="line">_16_mode:</span><br><span class="line">	mov	bp,0x20					; 0x20 是指向 GDT 中的 16 位数据段描述符 </span><br><span class="line">	mov	ds, bp</span><br><span class="line">	mov	es, bp</span><br><span class="line">	mov	ss, bp</span><br><span class="line">	mov	ebp, cr0				</span><br><span class="line">	and	ebp, 0xfffffffe</span><br><span class="line">	mov	cr0, ebp				; CR0.P=0 关闭保护模式</span><br><span class="line">	jmp	0:real_entry			; 刷新CS影子寄存器，真正进入实模式</span><br><span class="line">real_entry:</span><br><span class="line">	mov bp, cs</span><br><span class="line">	mov ds, bp</span><br><span class="line">	mov es, bp</span><br><span class="line">	mov ss, bp					; 重新设置实模式下的段寄存器 都是 CS 中值，即为0 </span><br><span class="line">	mov sp, 08000h				; 设置栈</span><br><span class="line">	mov bp,func_table</span><br><span class="line">	add bp,ax					; 调用函数表中的汇编函数，ax 是 C 函数中传递进来的</span><br><span class="line">	call [bp]</span><br><span class="line">	cli</span><br><span class="line">	call disable_nmi</span><br><span class="line">	mov	ebp, cr0</span><br><span class="line">	or	ebp, 1</span><br><span class="line">	mov	cr0, ebp				; CR0.P=1 开启保护模式</span><br><span class="line">	jmp dword 0x8 :_32bits_mode</span><br><span class="line">[BITS 32]</span><br><span class="line">_32bits_mode:</span><br><span class="line">	mov bp, 0x10</span><br><span class="line">	mov ds, bp</span><br><span class="line">	mov ss, bp					; 重新设置保护模式下的段寄存器 0x10 是 32 位数据段描述符的索引</span><br><span class="line">	mov esi,[PM32_EIP_OFF]		; 加载先前保存的 EIP</span><br><span class="line">	mov esp,[PM32_ESP_OFF]		; 加载先前保存的 ESP</span><br><span class="line">	jmp esi						; 回到了 realadr_call_entry 函数中</span><br></pre></td></tr></table></figure>
<p>上述的代码的流程是这样的：首先从 _16_mode: 标号处进入实模式，然后根据传递进来（由 ax 寄存器传入）的函数号，到函数表中调用对应的函数，里面的函数执行完成后，再次进入保护模式，加载 EIP 和 ESP 寄存器从而回到 realadr_call_entry 函数中。GDT 还是 imginithead.asm 汇编代码文件中的 GDT，这没有变，因为它是由 GDTR 寄存器指向的。</p>
<h1 id="二级引导器主函数"><a href="#二级引导器主函数" class="headerlink" title="二级引导器主函数"></a>二级引导器主函数</h1><p>下面我们将进入二级引导器的主函数 ldrkrl_entry ，建立一个 C 文件 <code>ldrkrlentry.c</code>，在其中写上一个主函数，代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ldrkrl_entry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 屏幕显示</span></span><br><span class="line">    <span class="built_in">init_curs</span>();</span><br><span class="line">    <span class="built_in">close_curs</span>();</span><br><span class="line">    <span class="built_in">clear_screen</span>(VGADP_DFVL);</span><br><span class="line">    <span class="comment">// 初始化参数</span></span><br><span class="line">    <span class="built_in">init_bstartparm</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最关键的函数就是 init_bstartparm，该函数功能为收集机器环境信息。</p>
<h3 id="检查与收集机器信息"><a href="#检查与收集机器信息" class="headerlink" title="检查与收集机器信息"></a>检查与收集机器信息</h3><p> init_bstartparm 函数负责管理检查 CPU 模式、收集内存信息，设置内核栈，设置内核字体、建立内核 MMU 页表数据。代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void init_bstartparm()</span><br><span class="line">&#123;</span><br><span class="line">    machbstart_t *mbsp = MBSPADR; // 1MB的内存地址</span><br><span class="line">    // 初始化 machbstart_t 结构体，清0,并设置一个标志</span><br><span class="line">    machbstart_t_init(mbsp);</span><br><span class="line">    // 检查 CPU</span><br><span class="line">    init_chkcpu(mbsp);</span><br><span class="line">    // 获取内存布局</span><br><span class="line">    init_mem(mbsp);</span><br><span class="line">    if (0 == get_wt_imgfilesz(mbsp))</span><br><span class="line">    &#123;</span><br><span class="line">        kerror(&quot;imgfilesz 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化内核栈</span><br><span class="line">    init_krlinitstack(mbsp);</span><br><span class="line">    // 放置内核文件</span><br><span class="line">    init_krlfile(mbsp);</span><br><span class="line">    // 放置字体文件</span><br><span class="line">    init_defutfont(mbsp);</span><br><span class="line">    init_meme820(mbsp);</span><br><span class="line">    // 建立 MMU 页表数据</span><br><span class="line">    init_bstartpages(mbsp);</span><br><span class="line">    // 设置图形模式</span><br><span class="line">    init_graph(mbsp);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="检查CPU"><a href="#检查CPU" class="headerlink" title="检查CPU"></a>检查CPU</h2><p>首先要检查我们的 CPU，因为它是执行程序的关键。这里用两个函数 chk_cpuid、chk_cpu_longmode 来干两件事，一个是检查 CPU 否支持 CPUID 指令，然后另一个用 CPUID 指令检查 CPU 支持 64 位长模式。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过改写 eflags 寄存器的第 21 位，观察其位的变化判断是否支持 CPUID</span></span><br><span class="line"><span class="symbol">int</span> chk_cpuid() &#123;</span><br><span class="line">  int rets = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">      <span class="string">&quot;pushfl \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;popl %%eax \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;movl %%eax,%%ebx \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;xorl $0x0200000,%%eax \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;pushl %%eax \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;popfl \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;pushfl \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;popl %%eax \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;xorl %%ebx,%%eax \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;jz 1f \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;movl $1,%0 \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;jmp 2f \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;1: movl $0,%0 \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;2: \n\t&quot;</span></span><br><span class="line">      : <span class="string">&quot;=c&quot;</span>(rets)</span><br><span class="line">      :</span><br><span class="line">      :)<span class="comment">;</span></span><br><span class="line">  return rets<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查CPU是否支持长模式</span></span><br><span class="line"><span class="symbol">int</span> chk_cpu_longmode() &#123;</span><br><span class="line">  int rets = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">      <span class="string">&quot;movl $0x80000000,%%eax \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;cpuid \n\t&quot;</span>                      <span class="comment">// 把 eax 中放入 0x80000000 调用 CPUID 指令</span></span><br><span class="line">      <span class="string">&quot;cmpl $0x80000001,%%eax \n\t&quot;</span>     <span class="comment">// 看eax中返回结果</span></span><br><span class="line">      <span class="string">&quot;setnb %%al \n\t&quot;</span>                 <span class="comment">// 不为0x80000001,则不支持0x80000001号功能</span></span><br><span class="line">      <span class="string">&quot;jb 1f \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;movl $0x80000001,%%eax \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;cpuid \n\t&quot;</span>                      <span class="comment">// 把eax中放入0x800000001调用CPUID指令，检查edx中的返回数据</span></span><br><span class="line">      <span class="string">&quot;bt $29,%%edx  \n\t&quot;</span>              <span class="comment">// 长模式 支持位 是否为1</span></span><br><span class="line">      <span class="string">&quot;setcb %%al \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;1: \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;movzx %%al,%%eax \n\t&quot;</span></span><br><span class="line">      : <span class="string">&quot;=a&quot;</span>(rets)</span><br><span class="line">      :</span><br><span class="line">      :)<span class="comment">;</span></span><br><span class="line">  return rets<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查CPU主函数</span></span><br><span class="line"><span class="symbol">void</span> init_chkcpu(machbstart_t *mbsp) &#123;</span><br><span class="line">  <span class="meta">if</span> (!chk_cpuid()) &#123;</span><br><span class="line">    kerror(<span class="string">&quot;Your CPU is not support CPUID sys is die!&quot;</span>)<span class="comment">;</span></span><br><span class="line">    CLI_HALT()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">if</span> (!chk_cpu_longmode()) &#123;</span><br><span class="line">    kerror(<span class="string">&quot;Your CPU is not support 64bits mode sys is die!&quot;</span>)<span class="comment">;</span></span><br><span class="line">    CLI_HALT()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  mbsp-&gt;mb_cpumode = <span class="number">0x40</span><span class="comment">;  // 如果成功则设置机器信息结构的cpu模式为64位</span></span><br><span class="line">  return<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要你留意的是，最后设置机器信息结构中的 <code>mb_cpumode</code> 字段为 64, <code>mbsp</code> 正是传递进来的机器信息 <code>machbstart_t</code> 结构体的指针。</p>
<h2 id="获取内存布局"><a href="#获取内存布局" class="headerlink" title="获取内存布局"></a>获取内存布局</h2><p>物理内存在物理地址空间中是一段一段的，描述一段内存有一个数据结构，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_USABLE  1 <span class="comment">// 可用内存</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_RESERV  2 <span class="comment">// 保留内存不可使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_ACPIREC 3 <span class="comment">// ACPI表相关的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_ACPINVS 4 <span class="comment">// ACPI NVS空间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_AREACON 5 <span class="comment">// 包含坏内存</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_e820</span>&#123;</span><br><span class="line">    <span class="type">u64_t</span> saddr;    <span class="comment">// 内存开始地址</span></span><br><span class="line">    <span class="type">u64_t</span> lsize;    <span class="comment">// 内存大小</span></span><br><span class="line">    <span class="type">u32_t</span> type;     <span class="comment">// 内存类型</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">e820map_t</span>;</span><br></pre></td></tr></table></figure>
<p>获取内存布局信息就是获取这个结构体的数组，下面我们需要获取上述结构体数组，并检查内存大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ETYBAK_ADR 0x2000            <span class="comment">// 8KB</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PM32_EIP_OFF (ETYBAK_ADR)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PM32_ESP_OFF (ETYBAK_ADR+4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E80MAP_NR (ETYBAK_ADR+64)     <span class="comment">// 保存e820map_t结构数组元素个数的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E80MAP_ADRADR (ETYBAK_ADR+68) <span class="comment">// 保存e820map_t结构数组的开始地址</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_mem</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// e820map 结构数组首地址</span></span><br><span class="line">  <span class="type">e820map_t</span> *retemp;</span><br><span class="line">  <span class="comment">// 个数</span></span><br><span class="line">  <span class="type">u32_t</span> retemnr = <span class="number">0</span>;</span><br><span class="line">  mbsp-&gt;mb_ebdaphyadr = <span class="built_in">acpi_get_bios_ebda</span>();</span><br><span class="line">  <span class="built_in">mmap</span>(&amp;retemp, &amp;retemnr);</span><br><span class="line">  <span class="keyword">if</span> (retemnr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">kerror</span>(<span class="string">&quot;no e820map\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// //根据 e820map_t 结构数据检查内存大小</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">chk_memsize</span>(retemp, retemnr, <span class="number">0x100000</span>, <span class="number">0x8000000</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">kerror</span>(</span><br><span class="line">        <span class="string">&quot;Your computer is low on memory, the memory cannot be less than &quot;</span></span><br><span class="line">        <span class="string">&quot;128MB!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把e820map_t结构数组的首地址传给mbsp-&gt;mb_e820padr</span></span><br><span class="line">  mbsp-&gt;mb_e820padr = (<span class="type">u64_t</span>)((<span class="type">u32_t</span>)(retemp));</span><br><span class="line">  <span class="comment">// 把e820map_t结构数组元素个数传给mbsp-&gt;mb_e820nr</span></span><br><span class="line">  mbsp-&gt;mb_e820nr = (<span class="type">u64_t</span>)retemnr;</span><br><span class="line">  <span class="comment">// 把e820map_t结构数组大小传给mbsp-&gt;mb_e820sz</span></span><br><span class="line">  mbsp-&gt;mb_e820sz = retemnr * (<span class="built_in">sizeof</span>(<span class="type">e820map_t</span>));</span><br><span class="line">  <span class="comment">// 根据e820map_t结构数据计算内存大小</span></span><br><span class="line">  mbsp-&gt;mb_memsz = <span class="built_in">get_memsize</span>(retemp, retemnr);</span><br><span class="line">  <span class="built_in">init_acpi</span>(mbsp);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mmap 通过调用 BIOS 中断，获取 e820map 结构数组 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mmap</span><span class="params">(<span class="type">e820map_t</span> **retemp, <span class="type">u32_t</span> *retemnr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">realadr_call_entry</span>(<span class="built_in">RLINTNR</span>(<span class="number">0</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    *retemnr = *((<span class="type">u32_t</span> *)(E80MAP_NR));</span><br><span class="line">    *retemp = (<span class="type">e820map_t</span> *)(*((<span class="type">u32_t</span> *)(E80MAP_ADRADR)));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>realadr_call_entry 的实现位于 <code>ldrkrl32.asm</code> 中， 该函数的功能是在 C 中语言调用实模式，这里就是调用实模式的 <code>_getmmap</code> 函数，_getmmap 函数调用 BIOS 中断获取 e820map 结构数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">_getmmap:</span><br><span class="line">	push ds</span><br><span class="line">	push es</span><br><span class="line">	push ss</span><br><span class="line">	mov esi,0</span><br><span class="line">	mov dword[E80MAP_NR],esi				; E80MAP_NR (ETYBAK_ADR+64) 8KB + 64B</span><br><span class="line">	mov dword[E80MAP_ADRADR],E80MAP_ADR		; e820map 结构体开始地址 E80MAP_ADR (0x5000)  14 KB </span><br><span class="line">											; E80MAP_ADRADR (ETYBAK_ADR+68) 8KB + 68B</span><br><span class="line">	xor ebx,ebx</span><br><span class="line">	mov edi,E80MAP_ADR						; edi 设为存放输出结果的 1MB 内的物理内存地址</span><br><span class="line">loop:</span><br><span class="line">	mov eax,0e820h							; 获取 e820map 结构参数</span><br><span class="line">	mov ecx,20								; e820map 结构大小,输出结果数据项的大小为20字节：8字节内存基地址，8字节内存长度，4字节内存类型</span><br><span class="line">	mov edx,0534d4150h						; 获取 e820map 结构参数必须是这个数据</span><br><span class="line">	int 15h									; BIOS 的 15h 中断</span><br><span class="line">	jc .1</span><br><span class="line"></span><br><span class="line">	add edi,20</span><br><span class="line">	cmp edi,E80MAP_ADR+0x1000</span><br><span class="line">	jg .1</span><br><span class="line"></span><br><span class="line">	inc esi</span><br><span class="line"></span><br><span class="line">	cmp ebx,0</span><br><span class="line">	jne loop								; 循环获取 e820map 结构</span><br><span class="line"></span><br><span class="line">	jmp .2</span><br><span class="line"></span><br><span class="line">.1:</span><br><span class="line">	mov esi,0								; 出错处理，e820map 结构数组元素个数为 0</span><br><span class="line"></span><br><span class="line">.2:</span><br><span class="line">	mov dword[E80MAP_NR],esi				; e820map 结构数组元素个数</span><br><span class="line">	pop ss</span><br><span class="line">	pop es</span><br><span class="line">	pop ds</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>init_mem 函数在调用 mmap 函数后，就会得到 e820map 结构数组，其首地址和数组元素个数由 retemp、retemnr 两个变量分别提供。</p>
<h2 id="初始化内核栈"><a href="#初始化内核栈" class="headerlink" title="初始化内核栈"></a>初始化内核栈</h2><p>因为我们的操作系统是 C 语言写的，所以需要有栈，下面我们就来给即将运行的内核初始化一个栈。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IKSTACK_PHYADR (0x90000-0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IKSTACK_SIZE 0x1000</span></span><br><span class="line"><span class="comment">// 初始化内核栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_krlinitstack</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> &gt; <span class="built_in">move_krlimg</span>(mbsp, (<span class="type">u64_t</span>)(<span class="number">0x8f000</span>), <span class="number">0x1001</span>)) &#123;</span><br><span class="line">    <span class="built_in">kerror</span>(<span class="string">&quot;iks_moveimg err&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mbsp-&gt;mb_krlinitstack = IKSTACK_PHYADR;  <span class="comment">// 栈顶 0x90000-0x10 = 0x8FFF0</span></span><br><span class="line">  mbsp-&gt;mb_krlitstacksz = IKSTACK_SIZE;    <span class="comment">// 栈大小 0x1000 4K</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断一个地址空间是否和内存中存放的内容有冲突</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">move_krlimg</span><span class="params">(<span class="type">machbstart_t</span> *mbsp, <span class="type">u64_t</span> cpyadr, <span class="type">u64_t</span> cpysz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0xffffffff</span> &lt;= (cpyadr + cpysz) || <span class="number">1</span> &gt; cpysz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> *toadr = (<span class="type">void</span> *)((<span class="type">u32_t</span>)(<span class="built_in">P4K_ALIGN</span>(cpyadr + cpysz)));</span><br><span class="line">    <span class="type">sint_t</span> tosz = (<span class="type">sint_t</span>)mbsp-&gt;mb_imgsz;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">adrzone_is_ok</span>(mbsp-&gt;mb_imgpadr, mbsp-&gt;mb_imgsz, cpyadr, cpysz))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">chk_memsize</span>((<span class="type">e820map_t</span> *)((<span class="type">u32_t</span>)(mbsp-&gt;mb_e820padr)), (<span class="type">u32_t</span>)mbsp-&gt;mb_e820nr, (<span class="type">u64_t</span>)((<span class="type">u32_t</span>)toadr), (<span class="type">u64_t</span>)tosz))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">m2mcopy</span>((<span class="type">void</span> *)((<span class="type">u32_t</span>)mbsp-&gt;mb_imgpadr), toadr, tosz);</span><br><span class="line">        mbsp-&gt;mb_imgpadr = (<span class="type">u64_t</span>)((<span class="type">u32_t</span>)toadr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0x8f000～（0x8f000+0x1001），正是我们的内核栈空间，我们需要检测它是否和其它空间有冲突。</p>
<h2 id="放置内核文件与字库文件"><a href="#放置内核文件与字库文件" class="headerlink" title="放置内核文件与字库文件"></a>放置内核文件与字库文件</h2><p>因为我们的内核已经编译成了一个独立的二进制程序，和其它文件一起被打包到映像文件中了。所以我们必须要从映像中把它解包出来，将其放在特定的物理内存空间中才可以，放置字库文件和放置内核文件的原理一样，所以我们来一起实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_krlfile</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">u64_t</span> sz = <span class="built_in">r_file_to_padr</span>(mbsp, IMGKRNL_PHYADR, <span class="string">&quot;Cosmos.bin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">kerror</span>(<span class="string">&quot;r_file_to_padr err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放置完成后更新机器信息结构中的数据</span></span><br><span class="line">    mbsp-&gt;mb_krlimgpadr = IMGKRNL_PHYADR;</span><br><span class="line">    mbsp-&gt;mb_krlsz = sz;</span><br><span class="line">    <span class="comment">// mbsp-&gt;mb_nextwtpadr始终要保持指向下一段空闲内存的首地址 </span></span><br><span class="line">    mbsp-&gt;mb_nextwtpadr = <span class="built_in">P4K_ALIGN</span>(mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz);</span><br><span class="line">    mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 放置字库文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_defutfont</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">u64_t</span> sz = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取下一段空闲内存空间的首地址 </span></span><br><span class="line">    <span class="type">u32_t</span> dfadr = (<span class="type">u32_t</span>)mbsp-&gt;mb_nextwtpadr;</span><br><span class="line">    <span class="comment">// 在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找font.fnt文件</span></span><br><span class="line">    sz = <span class="built_in">r_file_to_padr</span>(mbsp, dfadr, <span class="string">&quot;font.fnt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">kerror</span>(<span class="string">&quot;r_file_to_padr err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放置完成后更新机器信息结构中的数据</span></span><br><span class="line">    mbsp-&gt;mb_bfontpadr = (<span class="type">u64_t</span>)(dfadr);</span><br><span class="line">    mbsp-&gt;mb_bfontsz = sz;</span><br><span class="line">    <span class="comment">// 更新机器信息结构中下一段空闲内存的首地址</span></span><br><span class="line">    mbsp-&gt;mb_nextwtpadr = <span class="built_in">P4K_ALIGN</span>((<span class="type">u32_t</span>)(dfadr) + sz);</span><br><span class="line">    mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_bfontpadr + mbsp-&gt;mb_bfontsz;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放置内核文件与字库文件都是调用 r_file_to_padr 函数在映像中查找 <code>Cosmos.bin</code> 和 <code>font.fnt</code> 文件，并复制到对应的空闲内存空间中。</p>
<h2 id="建立-MMU-页表数据"><a href="#建立-MMU-页表数据" class="headerlink" title="建立 MMU 页表数据"></a>建立 MMU 页表数据</h2><p>我们在二级引导器中建立 MMU 页表数据，目的就是要在内核加载运行之初开启长模式时，MMU 需要的页表数据已经准备好了。</p>
<p>由于我们的内核虚拟地址空间从 0xffff800000000000 开始，所以我们这个虚拟地址映射到从物理地址 0 开始，大小都是 0x400000000 即 16GB，也就是说我们要虚拟地址空间：0xffff800000000000～0xffff800400000000 映射到物理地址空间 0～0x400000000。</p>
<p>我们为了简化编程，使用长模式下的 2MB 分页方式，下面我们用代码实现它，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_bstartpages</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 顶级页目录</span></span><br><span class="line">  <span class="type">u64_t</span> *p = (<span class="type">u64_t</span> *)(KINITPAGE_PHYADR);   <span class="comment">// 16MB</span></span><br><span class="line">  <span class="comment">// 页目录指针</span></span><br><span class="line">  <span class="type">u64_t</span> *pdpte = (<span class="type">u64_t</span> *)(KINITPAGE_PHYADR + <span class="number">0x1000</span>); <span class="comment">// 16MB + 4KB</span></span><br><span class="line">  <span class="comment">// 页目录</span></span><br><span class="line">  <span class="type">u64_t</span> *pde = (<span class="type">u64_t</span> *)(KINITPAGE_PHYADR + <span class="number">0x2000</span>);    <span class="comment">// 16MB + 8KB</span></span><br><span class="line">  <span class="comment">// 物理地址从0开始</span></span><br><span class="line">  <span class="type">u64_t</span> adr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> &gt;</span><br><span class="line">      <span class="built_in">move_krlimg</span>(mbsp, (<span class="type">u64_t</span>)(KINITPAGE_PHYADR), (<span class="number">0x1000</span> * <span class="number">16</span> + <span class="number">0x2000</span>))) &#123;</span><br><span class="line">    <span class="built_in">kerror</span>(<span class="string">&quot;move_krlimg err&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将顶级页目录、页目录指针的空间清0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint_t</span> mi = <span class="number">0</span>; mi &lt; PGENTY_SIZE; mi++) &#123;</span><br><span class="line">    p[mi] = <span class="number">0</span>;</span><br><span class="line">    pdpte[mi] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 映射 16G 物理内存</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint_t</span> pdei = <span class="number">0</span>; pdei &lt; <span class="number">16</span>; pdei++) &#123;</span><br><span class="line">    pdpte[pdei] = (<span class="type">u64_t</span>)((<span class="type">u32_t</span>)pde | KPDPTE_RW | KPDPTE_P);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint_t</span> pdeii = <span class="number">0</span>; pdeii &lt; PGENTY_SIZE;</span><br><span class="line">         pdeii++) &#123;  <span class="comment">// 大页KPDE_PS 2MB，可读写KPDE_RW，存在KPDE_P</span></span><br><span class="line">      pde[pdeii] = <span class="number">0</span> | adr | KPDE_PS | KPDE_RW | KPDE_P;</span><br><span class="line">      adr += <span class="number">0x200000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pde = (<span class="type">u64_t</span> *)((<span class="type">u32_t</span>)pde + <span class="number">0x1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 让顶级页目录中第 0 项和第 ((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff 项，指向同一个页目录指针页</span></span><br><span class="line">  p[((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; <span class="number">0x1ff</span>] =</span><br><span class="line">      (<span class="type">u64_t</span>)((<span class="type">u32_t</span>)pdpte | KPML4_RW | KPML4_P);</span><br><span class="line">  p[<span class="number">0</span>] = (<span class="type">u64_t</span>)((<span class="type">u32_t</span>)pdpte | KPML4_RW | KPML4_P);</span><br><span class="line">  <span class="comment">// 把页表首地址保存在机器信息结构中</span></span><br><span class="line">  mbsp-&gt;mb_pml4padr = (<span class="type">u64_t</span>)(KINITPAGE_PHYADR);</span><br><span class="line">  mbsp-&gt;mb_subpageslen = (<span class="type">u64_t</span>)(<span class="number">0x1000</span> * <span class="number">16</span> + <span class="number">0x2000</span>); <span class="comment">// 页目录大小为 0x1000 * 16 ，顶级页目录 + 页目录指针 = 8KB</span></span><br><span class="line">  mbsp-&gt;mb_kpmapphymemsz = (<span class="type">u64_t</span>)(<span class="number">0x400000000</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顶级页目录中第 0 项和第 ((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff 项，指向同一个页目录指针页，这样的话就能让虚拟地址：0xffff800000000000～0xffff800400000000 和虚拟地址：0～0x400000000，访问到同一个物理地址空间 0～0x400000000，这样做是有目的，内核在启动初期，虚拟地址和物理地址要保持相同。</p>
<h2 id="设置图形模式"><a href="#设置图形模式" class="headerlink" title="设置图形模式"></a>设置图形模式</h2><p>切换显卡模式依然要用 BIOS 中断，相关代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_graph</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化图形数据结构</span></span><br><span class="line">    <span class="built_in">graph_t_init</span>(&amp;mbsp-&gt;mb_ghparm);</span><br><span class="line">    <span class="built_in">init_bgadevice</span>(mbsp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mbsp-&gt;mb_ghparm.gh_mode != BGAMODE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取VBE模式，通过BIOS中断</span></span><br><span class="line">        <span class="built_in">get_vbemode</span>(mbsp);</span><br><span class="line">        <span class="comment">// 获取一个具体VBE模式的信息，通过BIOS中断</span></span><br><span class="line">        <span class="built_in">get_vbemodeinfo</span>(mbsp);</span><br><span class="line">        <span class="comment">// 设置VBE模式，通过BIOS中断</span></span><br><span class="line">        <span class="built_in">set_vbemodeinfo</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init_kinitfvram</span>(mbsp);</span><br><span class="line">    <span class="comment">// 显示 logo</span></span><br><span class="line">    <span class="built_in">logo</span>(mbsp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="显示-Logo"><a href="#显示-Logo" class="headerlink" title="显示 Logo"></a>显示 Logo</h2><p>前面我们已经设置了图形模式，下面就可以显示 logo 图片了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">logo</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">u32_t</span> retadr = <span class="number">0</span>, sz = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 在映像文件中获取logo.bmp文件</span></span><br><span class="line">    <span class="built_in">get_file_rpadrandsz</span>(<span class="string">&quot;logo.bmp&quot;</span>, mbsp, &amp;retadr, &amp;sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == retadr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">kerror</span>(<span class="string">&quot;logo getfilerpadrsz err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 显示logo文件中的图像数据</span></span><br><span class="line">    <span class="built_in">bmp_print</span>((<span class="type">void</span> *)retadr, mbsp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进入-Cosmos"><a href="#进入-Cosmos" class="headerlink" title="进入 Cosmos"></a>进入 Cosmos</h2><p>因为 CPU 进入了长模式，寄存器的位宽都变了，所以需要重新初始化。在 <code>Cosmos/hal/x86/</code> 下建立一个 <code>init_entry.asm</code> 文件，写上后面这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">[section .start.text]</span><br><span class="line">[BITS 32]</span><br><span class="line">_start:</span><br><span class="line">    cli</span><br><span class="line">    mov ax,0x10</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov fs,ax</span><br><span class="line">    mov gs,ax</span><br><span class="line">    lgdt [eGdtPtr]        </span><br><span class="line">    ;开启 PAE</span><br><span class="line">    mov eax, cr4</span><br><span class="line">    bts eax, 5                      ; CR4.PAE = 1</span><br><span class="line">    mov cr4, eax</span><br><span class="line">    mov eax, PML4T_BADR             ;加载MMU顶级页目录</span><br><span class="line">    mov cr3, eax  </span><br><span class="line">    ;开启 64bits long-mode</span><br><span class="line">    mov ecx, IA32_EFER</span><br><span class="line">    rdmsr</span><br><span class="line">    bts eax, 8                      ; IA32_EFER.LME =1</span><br><span class="line">    wrmsr</span><br><span class="line">    ;开启 PE 和 paging</span><br><span class="line">    mov eax, cr0</span><br><span class="line">    bts eax, 0                      ; CR0.PE =1</span><br><span class="line">    bts eax, 31</span><br><span class="line">    ;开启 CACHE       </span><br><span class="line">    btr eax,29                    ; CR0.NW=0</span><br><span class="line">    btr eax,30                    ; CR0.CD=0  CACHE</span><br><span class="line">    mov cr0, eax                    ; IA32_EFER.LMA = 1</span><br><span class="line">    jmp 08:entry64</span><br><span class="line">[BITS 64]</span><br><span class="line">entry64:</span><br><span class="line">    mov ax,0x10</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov fs,ax</span><br><span class="line">    mov gs,ax</span><br><span class="line">    xor rax,rax</span><br><span class="line">    xor rbx,rbx</span><br><span class="line">    xor rbp,rbp</span><br><span class="line">    xor rcx,rcx</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    xor rdi,rdi</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor r8,r8</span><br><span class="line">    xor r9,r9</span><br><span class="line">    xor r10,r10</span><br><span class="line">    xor r11,r11</span><br><span class="line">    xor r12,r12</span><br><span class="line">    xor r13,r13</span><br><span class="line">    xor r14,r14</span><br><span class="line">    xor r15,r15</span><br><span class="line">    mov rbx,MBSP_ADR</span><br><span class="line">    mov rax,KRLVIRADR</span><br><span class="line">    mov rcx,[rbx+KINITSTACK_OFF]</span><br><span class="line">    add rax,rcx</span><br><span class="line">    xor rcx,rcx</span><br><span class="line">    xor rbx,rbx</span><br><span class="line">    mov rsp,rax</span><br><span class="line">    push 0</span><br><span class="line">    push 0x8</span><br><span class="line">    mov rax,hal_start                 ;调用内核主函数</span><br><span class="line">    push rax</span><br><span class="line">    dw 0xcb48</span><br><span class="line">    jmp $</span><br><span class="line">[section .start.data]</span><br><span class="line">[BITS 32]</span><br><span class="line">x64_GDT:</span><br><span class="line">enull_x64_dsc:  dq 0  </span><br><span class="line">ekrnl_c64_dsc:  dq 0x0020980000000000   ; 64-bit 内核代码段</span><br><span class="line">ekrnl_d64_dsc:  dq 0x0000920000000000   ; 64-bit 内核数据段</span><br><span class="line">euser_c64_dsc:  dq 0x0020f80000000000   ; 64-bit 用户代码段</span><br><span class="line">euser_d64_dsc:  dq 0x0000f20000000000   ; 64-bit 用户数据段</span><br><span class="line">eGdtLen      equ  $ - enull_x64_dsc   ; GDT长度</span><br><span class="line">eGdtPtr:    dw eGdtLen - 1      ; GDT界限</span><br><span class="line">        dq ex64_GDT</span><br></pre></td></tr></table></figure>
<h2 id="使用虚拟机加载二级引导器。"><a href="#使用虚拟机加载二级引导器。" class="headerlink" title="使用虚拟机加载二级引导器。"></a>使用虚拟机加载二级引导器。</h2><p>在源码目录运行 <code>make release</code> 命令，将会产生下面文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  release tree</span><br><span class="line">.</span><br><span class="line">├── background.bmp</span><br><span class="line">├── Cosmos.bin</span><br><span class="line">├── Cosmos.eki</span><br><span class="line">├── font.fnt</span><br><span class="line">├── initldrimh.bin</span><br><span class="line">├── initldrkrl.bin</span><br><span class="line">├── initldrsve.bin</span><br><span class="line">├── lmoskrlimg</span><br><span class="line">└── logo.bmp</span><br></pre></td></tr></table></figure>
<p>挂载 <code>hd.img</code> 至 hdisk 目录，并将 <code>Cosmos.eki</code> 复制到 <code>hdisk/boot</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o loop hd.img hdisk/</span><br><span class="line">sudo <span class="built_in">cp</span> release/Cosmos.eki hdisk/boot/HelloOS.eki</span><br><span class="line">sudo umount hdisk/</span><br></pre></td></tr></table></figure>
<p>修改 <code>grub.cfg</code> 文件，将 <code>set root=&#39;hd0,msdos1&#39;</code> 改为 <code>set root=&#39;hd0&#39;</code>，并执行 <code>sudo umount hdisk</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">menuentry <span class="string">&#x27;HelloOS&#x27;</span> &#123;</span><br><span class="line">insmod part_msdos</span><br><span class="line">insmod ext2</span><br><span class="line"><span class="built_in">set</span> root=<span class="string">&#x27;hd0&#x27;</span>         <span class="comment">#我们的硬盘只有一个分区所以是&#x27;hd0&#x27;</span></span><br><span class="line">multiboot2 /boot/HelloOS.eki  <span class="comment">#加载boot目录下的HelloOS.eki文件</span></span><br><span class="line">boot                          <span class="comment">#引导启动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span> timeout_style=menu</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;timeout&#125;</span>&quot;</span> = 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">set</span> <span class="built_in">timeout</span>=10              <span class="comment">#等待10秒钟自动启动</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>然后运行下列命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转换格式</span></span><br><span class="line">VBoxManage convertfromraw hd.img --format VDI hd.vdi</span><br><span class="line"><span class="comment"># 移除之前添加的硬盘控制器</span></span><br><span class="line">VBoxManage storagectl HelloOS --name <span class="string">&quot;IDE&quot;</span> --remove </span><br><span class="line"><span class="comment"># 添加新的硬盘控制器</span></span><br><span class="line">VBoxManage storagectl HelloOS --name <span class="string">&quot;IDE&quot;</span> --add ide --controller PIIX4</span><br><span class="line"><span class="comment"># 删除虚拟硬盘UUID并重新分配</span></span><br><span class="line">VBoxManage closemedium disk hd.vdi</span><br><span class="line"><span class="comment"># 将虚拟硬盘挂到虚拟机的硬盘控制器</span></span><br><span class="line">VBoxManage storageattach HelloOS --storagectl <span class="string">&quot;IDE&quot;</span> --port 0 --device 0 --<span class="built_in">type</span> hdd --medium hd.vdi</span><br><span class="line"><span class="comment"># 启动虚拟机</span></span><br><span class="line">VBoxManage startvm HelloOS</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/" rel="tag"># 操作系统实战</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9802-%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%8E%AF%E5%A2%83/" rel="prev" title="操作系统实战02-设置工作模式与环境">
                  <i class="fa fa-chevron-left"></i> 操作系统实战02-设置工作模式与环境
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9803-CPU%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/" rel="next" title="操作系统实战03-CPU工作模式">
                  操作系统实战03-CPU工作模式 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CKCat</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/CKCat" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
