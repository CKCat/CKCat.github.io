<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ART的函数运行机制</title>
    <url>/2020/06/03/ART%E7%9A%84%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="ART的函数运行机制"><a href="#ART的函数运行机制" class="headerlink" title="ART的函数运行机制"></a>ART的函数运行机制</h1><h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><p><code>dalvik</code> 的类加载的主要过程如下：</p>
<ol>
<li><p><code>app_process</code> 作为 <code>zygote server</code> 通过 <code>local socket</code> 处理进程创建请求，<code>zygote server</code> 是在 <code>ZygoteInit.main</code> 函数里调用 <code>ZygoteInit.runSelectLoop</code> 监听。</p>
</li>
<li><p>接收到 <code>zygote client</code> 的 <code>fork</code> 请求之后，调用 <code>ZygoteConnection.runOnce</code> ，调用 <code>Zygote.forkAndSpecialize</code> 创建新进程</p>
</li>
<li><p>进程创建之后，由 <code>ZygoteConnection.handleParentProc</code> 来初始化进程，最终会调用 <code>ActivityThread.main</code> 函数</p>
</li>
<li><p><code>ActivityThread.main -&gt; ActivityThread.attach -&gt;  ActivityThread.bindApplication -&gt; Activity.handleBindApplication，handleBindApplication</code> 会初始化 <code>BaseDexClassLoader</code> 。</p>
</li>
<li><p>类的加载经过了 <code>ClassLoader.loadClass-&gt;BaseDexClassLoader.findClass-&gt;DexPathList.findClass-&gt;DexFile.loadClassBinaryName-&gt;DexFile.defineClassNative-&gt;DexFile_defineClassNative</code> (<code>runtime/native/dalvik_system_DexFile.cc</code>) 。</p>
</li>
</ol>
<p>这个初始化过程， <code>art</code> 和 <code>dalvik</code> 都是一样的。 <code>art</code> 的 <code>DexFile_defineClassNative</code> 由 <code>ClassLinker</code> 的 <code>DefineClass</code> 来加载类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jclass <span class="title">DexFile_defineClassNative</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        jclass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        jstring javaName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        jobject javaLoader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        jobject cookie,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        jobject dexFile)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">const</span> DexFile*&gt; dex_files;</span><br><span class="line">  <span class="type">const</span> OatFile* oat_file;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ConvertJavaArrayToDexFiles</span>(env, cookie, <span class="comment">/*out*/</span> dex_files, <span class="comment">/*out*/</span> oat_file)) &#123;</span><br><span class="line">    <span class="built_in">VLOG</span>(class_linker) &lt;&lt; <span class="string">&quot;Failed to find dex_file&quot;</span>;</span><br><span class="line">    <span class="built_in">DCHECK</span>(env-&gt;<span class="built_in">ExceptionCheck</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ScopedUtfChars <span class="title">class_name</span><span class="params">(env, javaName)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (class_name.<span class="built_in">c_str</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">VLOG</span>(class_linker) &lt;&lt; <span class="string">&quot;Failed to find class_name&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::string <span class="title">descriptor</span><span class="params">(DotToDescriptor(class_name.c_str()))</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">size_t</span> <span class="title">hash</span><span class="params">(ComputeModifiedUtf8Hash(descriptor.c_str()))</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dex_file : dex_files) &#123;</span><br><span class="line">    <span class="type">const</span> DexFile::ClassDef* dex_class_def =</span><br><span class="line">        OatDexFile::<span class="built_in">FindClassDef</span>(*dex_file, descriptor.<span class="built_in">c_str</span>(), hash);</span><br><span class="line">    <span class="keyword">if</span> (dex_class_def != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">      ClassLinker* class_linker = Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetClassLinker</span>();</span><br><span class="line">      <span class="function">StackHandleScope&lt;1&gt; <span class="title">hs</span><span class="params">(soa.Self())</span></span>;</span><br><span class="line">      <span class="function">Handle&lt;mirror::ClassLoader&gt; <span class="title">class_loader</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          hs.NewHandle(soa.Decode&lt;mirror::ClassLoader&gt;(javaLoader)))</span></span>;</span><br><span class="line">      ObjPtr&lt;mirror::DexCache&gt; dex_cache =</span><br><span class="line">          class_linker-&gt;<span class="built_in">RegisterDexFile</span>(*dex_file, class_loader.<span class="built_in">Get</span>());</span><br><span class="line">      <span class="keyword">if</span> (dex_cache == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// OOME or InternalError (dexFile already registered with a different class loader).</span></span><br><span class="line">        soa.<span class="built_in">Self</span>()-&gt;<span class="built_in">AssertPendingException</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ObjPtr&lt;mirror::Class&gt; result = class_linker-&gt;<span class="built_in">DefineClass</span>(soa.<span class="built_in">Self</span>(),</span><br><span class="line">                                                               descriptor.<span class="built_in">c_str</span>(),</span><br><span class="line">                                                               hash,</span><br><span class="line">                                                               class_loader,</span><br><span class="line">                                                               *dex_file,</span><br><span class="line">                                                               *dex_class_def);</span><br><span class="line">      <span class="comment">// Add the used dex file. This only required for the DexFile.loadClass API since normal</span></span><br><span class="line">      <span class="comment">// class loaders already keep their dex files live.</span></span><br><span class="line">      class_linker-&gt;<span class="built_in">InsertDexFileInToClassLoader</span>(soa.<span class="built_in">Decode</span>&lt;mirror::Object&gt;(dexFile),</span><br><span class="line">                                                 class_loader.<span class="built_in">Get</span>());</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">VLOG</span>(class_linker) &lt;&lt; <span class="string">&quot;DexFile_defineClassNative returning &quot;</span> &lt;&lt; result</span><br><span class="line">                           &lt;&lt; <span class="string">&quot; for &quot;</span> &lt;&lt; class_name.<span class="built_in">c_str</span>();</span><br><span class="line">        <span class="keyword">return</span> soa.<span class="built_in">AddLocalReference</span>&lt;jclass&gt;(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">VLOG</span>(class_linker) &lt;&lt; <span class="string">&quot;Failed to find dex_class_def &quot;</span> &lt;&lt; class_name.<span class="built_in">c_str</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的加载除了创建 <code>Class</code> 只外，还有加载类的字段和方法，这个由 <code>ClassLinker::LoadClass</code> 来完成。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassLinker::LoadClass</span><span class="params">(Thread* self,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> DexFile&amp; dex_file,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> DexFile::ClassDef&amp; dex_class_def,</span></span></span><br><span class="line"><span class="params"><span class="function">                            Handle&lt;mirror::Class&gt; klass)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span>* class_data = dex_file.<span class="built_in">GetClassData</span>(dex_class_def);</span><br><span class="line">  <span class="keyword">if</span> (class_data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// no fields or methods - for example a marker interface</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">LoadClassMembers</span>(self, dex_file, class_data, klass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数的执行"><a href="#函数的执行" class="headerlink" title="函数的执行"></a>函数的执行</h2><p>一旦类的加载完成，那么就可以调用类的成员函数了，之前的解释器运行机制那篇文章介绍过， <code>Java</code> 的执行是以 <code>Method</code> 为执行单元的，所以我们分析 <code>art</code> 的运行机制，其实就是分析 <code>Method</code> 的运行机制。</p>
<p><code>ActivityThread</code> 是进程在启动的时候传类名，在进程启动之后，由 <code>handleParentProc</code> 执行 <code>main</code> 函数，因此第一个被执行的 <code>java</code> 函数是 <code>ActivityThread.main</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Process.<span class="type">ProcessStartResult</span> <span class="variable">startResult</span> <span class="operator">=</span> Process.start(<span class="string">&quot;android.app.ActivityThread&quot;</span>,</span><br><span class="line">                    app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                    app.info.targetSdkVersion, app.info.seinfo, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><code>ActivityThread.main</code> 是最终由 <code>AndroidRuntime::callMain</code> 执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">AndroidRuntime::callMain</span><span class="params">(<span class="type">const</span> String8&amp; className, jclass clazz,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Vector&lt;String8&gt;&amp; args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    jmethodID methodId;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ALOGD</span>(<span class="string">&quot;Calling main entry %s&quot;</span>, className.<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line">    env = <span class="built_in">getJNIEnv</span>();</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">NULL</span> || env == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    methodId = env-&gt;<span class="built_in">GetStaticMethodID</span>(clazz, <span class="string">&quot;main&quot;</span>, <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (methodId == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;ERROR: could not find method %s.main(String[])\n&quot;</span>, className.<span class="built_in">string</span>());</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We want to call main() with a String array with our arguments in it.</span></span><br><span class="line"><span class="comment">     * Create an array and populate it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> numArgs = args.<span class="built_in">size</span>();</span><br><span class="line">    stringClass = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;java/lang/String&quot;</span>);</span><br><span class="line">    strArray = env-&gt;<span class="built_in">NewObjectArray</span>(numArgs, stringClass, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numArgs; i++) &#123;</span><br><span class="line">        jstring argStr = env-&gt;<span class="built_in">NewStringUTF</span>(args[i].<span class="built_in">string</span>());</span><br><span class="line">        env-&gt;<span class="built_in">SetObjectArrayElement</span>(strArray, i, argStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    关键函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    env-&gt;<span class="built_in">CallStaticVoidMethod</span>(clazz, methodId, strArray);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际会调用 <code>JNINativeInterface</code> 的 <code>CallStaticVoidMethod</code> ，上面已经介绍过，该函数的定义在 <code>runtime/jni_internal.cc</code> 里。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">CallStaticVoidMethod</span><span class="params">(JNIEnv* env, jclass, jmethodID mid, ...)</span> </span>&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="built_in">va_start</span>(ap, mid);</span><br><span class="line">  <span class="function">ScopedVAArgs <span class="title">free_args_later</span><span class="params">(&amp;ap)</span></span>;</span><br><span class="line">  <span class="built_in">CHECK_NON_NULL_ARGUMENT_RETURN_VOID</span>(mid);</span><br><span class="line">  <span class="function">ScopedObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  关键函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">InvokeWithVarArgs</span>(soa, <span class="literal">nullptr</span>, mid, ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InvokeWithVarArgs</code> 是执行函数的入口，定义在 <code>runtime/reflection.cc</code> ，最终是调用了 <code>ArtMethod::Invoke</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">JValue <span class="title">InvokeWithVarArgs</span><span class="params">(<span class="type">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa, jobject obj, jmethodID mid,</span></span></span><br><span class="line"><span class="params"><span class="function">                         va_list args)</span></span></span><br><span class="line"><span class="function">    <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We want to make sure that the stack is not within a small distance from the</span></span><br><span class="line">  <span class="comment">// protected region in case we are calling into a leaf function whose stack</span></span><br><span class="line">  <span class="comment">// check has been elided.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(__builtin_frame_address(<span class="number">0</span>) &lt; soa.<span class="built_in">Self</span>()-&gt;<span class="built_in">GetStackEnd</span>())) &#123;</span><br><span class="line">    <span class="built_in">ThrowStackOverflowError</span>(soa.<span class="built_in">Self</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JValue</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ArtMethod* method = jni::<span class="built_in">DecodeArtMethod</span>(mid);</span><br><span class="line">  <span class="type">bool</span> is_string_init = method-&gt;<span class="built_in">GetDeclaringClass</span>()-&gt;<span class="built_in">IsStringClass</span>() &amp;&amp; method-&gt;<span class="built_in">IsConstructor</span>();</span><br><span class="line">  <span class="keyword">if</span> (is_string_init) &#123;</span><br><span class="line">    <span class="comment">// Replace calls to String.&lt;init&gt; with equivalent StringFactory call.</span></span><br><span class="line">    method = WellKnownClasses::<span class="built_in">StringInitToStringFactory</span>(method);</span><br><span class="line">  &#125;</span><br><span class="line">  ObjPtr&lt;mirror::Object&gt; receiver = method-&gt;<span class="built_in">IsStatic</span>() ? <span class="literal">nullptr</span> : soa.<span class="built_in">Decode</span>&lt;mirror::Object&gt;(obj);</span><br><span class="line">  <span class="type">uint32_t</span> shorty_len = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* shorty =</span><br><span class="line">      method-&gt;<span class="built_in">GetInterfaceMethodIfProxy</span>(kRuntimePointerSize)-&gt;<span class="built_in">GetShorty</span>(&amp;shorty_len);</span><br><span class="line">  JValue result;</span><br><span class="line">  <span class="function">ArgArray <span class="title">arg_array</span><span class="params">(shorty, shorty_len)</span></span>;</span><br><span class="line">  arg_array.<span class="built_in">BuildArgArrayFromVarArgs</span>(soa, receiver, args);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  关键函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">InvokeWithArgArray</span>(soa, method, &amp;arg_array, &amp;result, shorty);</span><br><span class="line">  <span class="keyword">if</span> (is_string_init) &#123;</span><br><span class="line">    <span class="comment">// For string init, remap original receiver to StringFactory result.</span></span><br><span class="line">    <span class="built_in">UpdateReference</span>(soa.<span class="built_in">Self</span>(), obj, result.<span class="built_in">GetL</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InvokeWithArgArray</span><span class="params">(<span class="type">const</span> ScopedObjectAccessAlreadyRunnable&amp; soa,</span></span></span><br><span class="line"><span class="params"><span class="function">                               ArtMethod* method, ArgArray* arg_array, JValue* result,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> <span class="type">char</span>* shorty)</span></span></span><br><span class="line"><span class="function">    <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span>* args = arg_array-&gt;<span class="built_in">GetArray</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(soa.<span class="built_in">Env</span>()-&gt;<span class="built_in">IsCheckJniEnabled</span>())) &#123;</span><br><span class="line">    <span class="built_in">CheckMethodArguments</span>(soa.<span class="built_in">Vm</span>(), method-&gt;<span class="built_in">GetInterfaceMethodIfProxy</span>(kRuntimePointerSize), args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  关键函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  method-&gt;<span class="built_in">Invoke</span>(soa.<span class="built_in">Self</span>(), args, arg_array-&gt;<span class="built_in">GetNumBytes</span>(), result, shorty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道 <code>ART</code> 的运行模式是 <code>AOT</code> 的，在 <code>apk</code> 安装的时候，每个 <code>DexMethod</code> 都会由 <code>dex2oat</code> 编译成目标代码，而不再是虚拟机执行的字节码，但同时 <code>Dex</code> 字节码仍然还在 <code>OAT</code> 里存在，所以 <code>ART</code> 的代码执行既支持 <code>QuickCompiledCode</code> 模式，也同时支持解释器模式以及 <code>JIT</code> 执行模式。看 <code>ArtMethod::Invoke</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ArtMethod::Invoke</span><span class="params">(Thread* self, <span class="type">uint32_t</span>* args, <span class="type">uint32_t</span> args_size, JValue* result,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> <span class="type">char</span>* shorty)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(__builtin_frame_address(<span class="number">0</span>) &lt; self-&gt;<span class="built_in">GetStackEnd</span>())) &#123;</span><br><span class="line">    <span class="built_in">ThrowStackOverflowError</span>(self);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (kIsDebugBuild) &#123;</span><br><span class="line">    self-&gt;<span class="built_in">AssertThreadSuspensionIsAllowable</span>();</span><br><span class="line">    <span class="built_in">CHECK_EQ</span>(kRunnable, self-&gt;<span class="built_in">GetState</span>());</span><br><span class="line">    <span class="built_in">CHECK_STREQ</span>(<span class="built_in">GetInterfaceMethodIfProxy</span>(kRuntimePointerSize)-&gt;<span class="built_in">GetShorty</span>(), shorty);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Push a transition back into managed code onto the linked list in thread.</span></span><br><span class="line">  ManagedStack fragment;</span><br><span class="line">  self-&gt;<span class="built_in">PushManagedStackFragment</span>(&amp;fragment);</span><br><span class="line"></span><br><span class="line">  Runtime* runtime = Runtime::<span class="built_in">Current</span>();</span><br><span class="line">  <span class="comment">// Call the invoke stub, passing everything as arguments.</span></span><br><span class="line">  <span class="comment">// If the runtime is not yet started or it is required by the debugger, then perform the</span></span><br><span class="line">  <span class="comment">// Invocation by the interpreter, explicitly forcing interpretation over JIT to prevent</span></span><br><span class="line">  <span class="comment">// cycling around the various JIT/Interpreter methods that handle method invocation.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(!runtime-&gt;<span class="built_in">IsStarted</span>() || Dbg::<span class="built_in">IsForcedInterpreterNeededForCalling</span>(self, <span class="keyword">this</span>))) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Interpreter 模式</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsStatic</span>()) &#123;</span><br><span class="line">      art::interpreter::<span class="built_in">EnterInterpreterFromInvoke</span>(</span><br><span class="line">          self, <span class="keyword">this</span>, <span class="literal">nullptr</span>, args, result, <span class="comment">/*stay_in_interpreter*/</span> <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mirror::Object* receiver =</span><br><span class="line">          <span class="keyword">reinterpret_cast</span>&lt;StackReference&lt;mirror::Object&gt;*&gt;(&amp;args[<span class="number">0</span>])-&gt;<span class="built_in">AsMirrorPtr</span>();</span><br><span class="line">      art::interpreter::<span class="built_in">EnterInterpreterFromInvoke</span>(</span><br><span class="line">          self, <span class="keyword">this</span>, receiver, args + <span class="number">1</span>, result, <span class="comment">/*stay_in_interpreter*/</span> <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">DCHECK_EQ</span>(runtime-&gt;<span class="built_in">GetClassLinker</span>()-&gt;<span class="built_in">GetImagePointerSize</span>(), kRuntimePointerSize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">bool</span> kLogInvocationStartAndReturn = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">bool</span> have_quick_code = <span class="built_in">GetEntryPointFromQuickCompiledCode</span>() != <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">LIKELY</span>(have_quick_code)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (kLogInvocationStartAndReturn) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="built_in">StringPrintf</span>(</span><br><span class="line">            <span class="string">&quot;Invoking &#x27;%s&#x27; quick code=%p static=%d&quot;</span>, <span class="built_in">PrettyMethod</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">            <span class="built_in">GetEntryPointFromQuickCompiledCode</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">IsStatic</span>() ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Ensure that we won&#x27;t be accidentally calling quick compiled code when -Xint.</span></span><br><span class="line">      <span class="keyword">if</span> (kIsDebugBuild &amp;&amp; runtime-&gt;<span class="built_in">GetInstrumentation</span>()-&gt;<span class="built_in">IsForcedInterpretOnly</span>()) &#123;</span><br><span class="line">        <span class="built_in">CHECK</span>(!runtime-&gt;<span class="built_in">UseJitCompilation</span>());</span><br><span class="line">        <span class="type">const</span> <span class="type">void</span>* oat_quick_code =</span><br><span class="line">            (<span class="built_in">IsNative</span>() || !<span class="built_in">IsInvokable</span>() || <span class="built_in">IsProxyMethod</span>() || <span class="built_in">IsObsolete</span>())</span><br><span class="line">            ? <span class="literal">nullptr</span></span><br><span class="line">            : <span class="built_in">GetOatMethodQuickCode</span>(runtime-&gt;<span class="built_in">GetClassLinker</span>()-&gt;<span class="built_in">GetImagePointerSize</span>());</span><br><span class="line">        <span class="built_in">CHECK</span>(oat_quick_code == <span class="literal">nullptr</span> || oat_quick_code != <span class="built_in">GetEntryPointFromQuickCompiledCode</span>())</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Don&#x27;t call compiled code when -Xint &quot;</span> &lt;&lt; <span class="built_in">PrettyMethod</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        OAT 模式</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">IsStatic</span>()) &#123;</span><br><span class="line">        (*art_quick_invoke_stub)(<span class="keyword">this</span>, args, args_size, self, result, shorty);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (*art_quick_invoke_static_stub)(<span class="keyword">this</span>, args, args_size, self, result, shorty);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(self-&gt;<span class="built_in">GetException</span>() == Thread::<span class="built_in">GetDeoptimizationException</span>())) &#123;</span><br><span class="line">        <span class="comment">// Unusual case where we were running generated code and an</span></span><br><span class="line">        <span class="comment">// exception was thrown to force the activations to be removed from the</span></span><br><span class="line">        <span class="comment">// stack. Continue execution in the interpreter.</span></span><br><span class="line">        self-&gt;<span class="built_in">DeoptimizeWithDeoptimizationException</span>(result);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (kLogInvocationStartAndReturn) &#123;</span><br><span class="line">        <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="built_in">StringPrintf</span>(<span class="string">&quot;Returned &#x27;%s&#x27; quick code=%p&quot;</span>, <span class="built_in">PrettyMethod</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">                                  <span class="built_in">GetEntryPointFromQuickCompiledCode</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">&quot;Not invoking &#x27;&quot;</span> &lt;&lt; <span class="built_in">PrettyMethod</span>() &lt;&lt; <span class="string">&quot;&#x27; code=null&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        result-&gt;<span class="built_in">SetJ</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pop transition.</span></span><br><span class="line">  self-&gt;<span class="built_in">PopManagedStackFragment</span>(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Invoke</code> 可以进入 <code>OAT</code> ，<code>Interpreter</code> 模式执行 <code>Method</code> 。如果当前是 <code>Interpreter</code> 模式，就调用 <code>art::interpreter::EnterInterpreterFromInvoke</code> ，如果是 <code>OAT</code> 模式，就调用 <code>art_quick_invoke_stub/art_quick_invoke_static_stub</code> 。<br><code>EnterInterpreterFromInvoke</code> 函数里会判断是 <code>native</code> 还是解释器执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnterInterpreterFromInvoke</span><span class="params">(Thread* self, ArtMethod* method, Object* receiver,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">uint32_t</span>* args, JValue* result)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK_EQ</span>(self, Thread::<span class="built_in">Current</span>());</span><br><span class="line">  <span class="type">bool</span> implicit_check = !Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">ExplicitStackOverflowChecks</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(__builtin_frame_address(<span class="number">0</span>) &lt; self-&gt;<span class="built_in">GetStackEndForInterpreter</span>(implicit_check))) &#123;</span><br><span class="line">    <span class="built_in">ThrowStackOverflowError</span>(self);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* old_cause = self-&gt;<span class="built_in">StartAssertNoThreadSuspension</span>(<span class="string">&quot;EnterInterpreterFromInvoke&quot;</span>);</span><br><span class="line">  <span class="type">const</span> DexFile::CodeItem* code_item = method-&gt;<span class="built_in">GetCodeItem</span>();</span><br><span class="line">  <span class="type">uint16_t</span> num_regs;</span><br><span class="line">  <span class="type">uint16_t</span> num_ins;</span><br><span class="line">  <span class="keyword">if</span> (code_item != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    num_regs =  code_item-&gt;registers_size_;</span><br><span class="line">    num_ins = code_item-&gt;ins_size_;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method-&gt;<span class="built_in">IsAbstract</span>()) &#123;</span><br><span class="line">    self-&gt;<span class="built_in">EndAssertNoThreadSuspension</span>(old_cause);</span><br><span class="line">    <span class="built_in">ThrowAbstractMethodError</span>(method);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(method-&gt;<span class="built_in">IsNative</span>());</span><br><span class="line">    num_regs = num_ins = ArtMethod::<span class="built_in">NumArgRegisters</span>(method-&gt;<span class="built_in">GetShorty</span>());</span><br><span class="line">    <span class="keyword">if</span> (!method-&gt;<span class="built_in">IsStatic</span>()) &#123;</span><br><span class="line">      num_regs++;</span><br><span class="line">      num_ins++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Set up shadow frame with matching number of reference slots to vregs.</span></span><br><span class="line">  ShadowFrame* last_shadow_frame = self-&gt;<span class="built_in">GetManagedStack</span>()-&gt;<span class="built_in">GetTopShadowFrame</span>();</span><br><span class="line">  <span class="type">void</span>* memory = <span class="built_in">alloca</span>(ShadowFrame::<span class="built_in">ComputeSize</span>(num_regs));</span><br><span class="line">  <span class="function">ShadowFrame* <span class="title">shadow_frame</span><span class="params">(ShadowFrame::Create(num_regs, last_shadow_frame, method, <span class="number">0</span>, memory))</span></span>;</span><br><span class="line">  self-&gt;<span class="built_in">PushShadowFrame</span>(shadow_frame);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> cur_reg = num_regs - num_ins;</span><br><span class="line">  <span class="keyword">if</span> (!method-&gt;<span class="built_in">IsStatic</span>()) &#123;</span><br><span class="line">    <span class="built_in">CHECK</span>(receiver != <span class="literal">nullptr</span>);</span><br><span class="line">    shadow_frame-&gt;<span class="built_in">SetVRegReference</span>(cur_reg, receiver);</span><br><span class="line">    ++cur_reg;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint32_t</span> shorty_len = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* shorty = method-&gt;<span class="built_in">GetShorty</span>(&amp;shorty_len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> shorty_pos = <span class="number">0</span>, arg_pos = <span class="number">0</span>; cur_reg &lt; num_regs; ++shorty_pos, ++arg_pos, cur_reg++) &#123;</span><br><span class="line">    <span class="built_in">DCHECK_LT</span>(shorty_pos + <span class="number">1</span>, shorty_len);</span><br><span class="line">    <span class="keyword">switch</span> (shorty[shorty_pos + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>: &#123;</span><br><span class="line">        Object* o = <span class="keyword">reinterpret_cast</span>&lt;StackReference&lt;Object&gt;*&gt;(&amp;args[arg_pos])-&gt;<span class="built_in">AsMirrorPtr</span>();</span><br><span class="line">        shadow_frame-&gt;<span class="built_in">SetVRegReference</span>(cur_reg, o);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: &#123;</span><br><span class="line">        <span class="type">uint64_t</span> wide_value = (<span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(args[arg_pos + <span class="number">1</span>]) &lt;&lt; <span class="number">32</span>) | args[arg_pos];</span><br><span class="line">        shadow_frame-&gt;<span class="built_in">SetVRegLong</span>(cur_reg, wide_value);</span><br><span class="line">        cur_reg++;</span><br><span class="line">        arg_pos++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        shadow_frame-&gt;<span class="built_in">SetVReg</span>(cur_reg, args[arg_pos]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  self-&gt;<span class="built_in">EndAssertNoThreadSuspension</span>(old_cause);</span><br><span class="line">  <span class="comment">// Do this after populating the shadow frame in case EnsureInitialized causes a GC.</span></span><br><span class="line">  <span class="keyword">if</span> (method-&gt;<span class="built_in">IsStatic</span>() &amp;&amp; <span class="built_in">UNLIKELY</span>(!method-&gt;<span class="built_in">GetDeclaringClass</span>()-&gt;<span class="built_in">IsInitialized</span>())) &#123;</span><br><span class="line">    ClassLinker* class_linker = Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">GetClassLinker</span>();</span><br><span class="line">    <span class="function">StackHandleScope&lt;1&gt; <span class="title">hs</span><span class="params">(self)</span></span>;</span><br><span class="line">    <span class="function">Handle&lt;mirror::Class&gt; <span class="title">h_class</span><span class="params">(hs.NewHandle(method-&gt;GetDeclaringClass()))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(!class_linker-&gt;<span class="built_in">EnsureInitialized</span>(self, h_class, <span class="literal">true</span>, <span class="literal">true</span>))) &#123;</span><br><span class="line">      <span class="built_in">CHECK</span>(self-&gt;<span class="built_in">IsExceptionPending</span>());</span><br><span class="line">      self-&gt;<span class="built_in">PopShadowFrame</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">LIKELY</span>(!method-&gt;<span class="built_in">IsNative</span>())) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      非 native 方法则调用下列函数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    JValue r = <span class="built_in">Execute</span>(self, code_item, *shadow_frame, <span class="built_in">JValue</span>());</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      *result = r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// We don&#x27;t expect to be asked to interpret native code (which is entered via a JNI compiler</span></span><br><span class="line">    <span class="comment">// generated stub) except during testing and image writing.</span></span><br><span class="line">    <span class="comment">// Update args to be the args in the shadow frame since the input ones could hold stale</span></span><br><span class="line">    <span class="comment">// references pointers due to moving GC.</span></span><br><span class="line">    args = shadow_frame-&gt;<span class="built_in">GetVRegArgs</span>(method-&gt;<span class="built_in">IsStatic</span>() ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">IsStarted</span>()) &#123;</span><br><span class="line">      UnstartedRuntime::<span class="built_in">Jni</span>(self, method, receiver, args, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">InterpreterJni</span>(self, method, shorty, receiver, args, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  self-&gt;<span class="built_in">PopShadowFrame</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数前面部分都在做参数压栈操作，最后几行进入主题，如果不是 <code>Native</code> ，那么调用 <code>Execute</code> 执行； <code>Native</code> 函数则调用 <code>InterpreterJni</code> 。 <code>Execute</code> 就是 <code>art</code> 的解释器代码， <code>Dex</code> 的字节码是通过 <code>ArtMethod::GetCodeItem</code> 函数获得，由 <code>Execute</code> 逐条执行。 <code>InterpreterJni</code> 通过 <code>GetEntryPointFromJni</code> 来获得 <code>native</code> 的函数，并执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">LIKELY</span>(!method-&gt;<span class="built_in">IsNative</span>())) &#123;</span><br><span class="line">    JValue r = <span class="built_in">Execute</span>(self, code_item, *shadow_frame, <span class="built_in">JValue</span>());</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      *result = r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// We don&#x27;t expect to be asked to interpret native code (which is entered via a JNI compiler</span></span><br><span class="line">    <span class="comment">// generated stub) except during testing and image writing.</span></span><br><span class="line">    <span class="comment">// Update args to be the args in the shadow frame since the input ones could hold stale</span></span><br><span class="line">    <span class="comment">// references pointers due to moving GC.</span></span><br><span class="line">    args = shadow_frame-&gt;<span class="built_in">GetVRegArgs</span>(method-&gt;<span class="built_in">IsStatic</span>() ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Runtime::<span class="built_in">Current</span>()-&gt;<span class="built_in">IsStarted</span>()) &#123;</span><br><span class="line">      UnstartedRuntime::<span class="built_in">Jni</span>(self, method, receiver, args, result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">InterpreterJni</span>(self, method, shorty, receiver, args, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>再回调 <code>OAT</code> 的模式， <code>art_quick_invoke_stub/art_quick_invoke_static_stub</code> 最终会调用到 <code>art_quick_invoke_stub_internal</code> (<code>arch/arm/quick_entrypoints_arm.S</code> )。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ENTRY</span> art_quick_invoke_stub_internal</span><br><span class="line">    <span class="keyword">push</span>   &#123;<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">r8</span>, <span class="built_in">r9</span>, <span class="built_in">r10</span>, <span class="built_in">r11</span>, <span class="built_in">lr</span>&#125;               <span class="comment">@ spill regs</span></span><br><span class="line">    .cfi_adjust_cfa_offset <span class="number">16</span></span><br><span class="line">    .cfi_rel_offset <span class="built_in">r4</span>, <span class="number">0</span></span><br><span class="line">    .cfi_rel_offset <span class="built_in">r5</span>, <span class="number">4</span></span><br><span class="line">    .cfi_rel_offset <span class="built_in">r6</span>, <span class="number">8</span></span><br><span class="line">    .cfi_rel_offset <span class="built_in">r7</span>, <span class="number">12</span></span><br><span class="line">    .cfi_rel_offset <span class="built_in">r8</span>, <span class="number">16</span></span><br><span class="line">    .cfi_rel_offset <span class="built_in">r9</span>, <span class="number">20</span></span><br><span class="line">    .cfi_rel_offset <span class="built_in">r10</span>, <span class="number">24</span></span><br><span class="line">    .cfi_rel_offset <span class="built_in">r11</span>, <span class="number">28</span></span><br><span class="line">    .cfi_rel_offset <span class="built_in">lr</span>, <span class="number">32</span></span><br><span class="line">    <span class="keyword">mov</span>    <span class="built_in">r11</span>, <span class="built_in">sp</span>                         <span class="comment">@ save the stack pointer</span></span><br><span class="line">    .cfi_def_cfa_register <span class="built_in">r11</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>    <span class="built_in">r9</span>, <span class="built_in">r3</span>                          <span class="comment">@ move managed thread pointer into r9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">add</span>    <span class="built_in">r4</span>, <span class="built_in">r2</span>, <span class="number">#4</span>                      <span class="comment">@ create space for method pointer in frame</span></span><br><span class="line">    <span class="keyword">sub</span>    <span class="built_in">r4</span>, <span class="built_in">sp</span>, <span class="built_in">r4</span>                      <span class="comment">@ reserve &amp; align *stack* to 16 bytes: native calling</span></span><br><span class="line">    <span class="keyword">and</span>    <span class="built_in">r4</span>, <span class="number">#0xFFFFFFF0</span>                 <span class="comment">@ convention only aligns to 8B, so we have to ensure ART</span></span><br><span class="line">    <span class="keyword">mov</span>    <span class="built_in">sp</span>, <span class="built_in">r4</span>                          <span class="comment">@ 16B alignment ourselves.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>    <span class="built_in">r4</span>, <span class="built_in">r0</span>                          <span class="comment">@ save method*</span></span><br><span class="line">    <span class="keyword">add</span>    <span class="built_in">r0</span>, <span class="built_in">sp</span>, <span class="number">#4</span>                      <span class="comment">@ pass stack pointer + method ptr as dest for memcpy</span></span><br><span class="line">    <span class="keyword">bl</span>     memcpy                          <span class="comment">@ memcpy (dest, src, bytes)</span></span><br><span class="line">    <span class="keyword">mov</span>    <span class="built_in">ip</span>, <span class="number">#0</span>                          <span class="comment">@ set ip to 0</span></span><br><span class="line">    <span class="keyword">str</span>    <span class="built_in">ip</span>, [<span class="built_in">sp</span>]                        <span class="comment">@ store null for method* at bottom of frame</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ldr</span>    <span class="built_in">ip</span>, [<span class="built_in">r11</span>, <span class="number">#48</span>]                  <span class="comment">@ load fp register argument array pointer</span></span><br><span class="line">    vldm   <span class="built_in">ip</span>, &#123;<span class="built_in">s0</span>-<span class="built_in">s15</span>&#125;                    <span class="comment">@ copy s0 - s15</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ldr</span>    <span class="built_in">ip</span>, [<span class="built_in">r11</span>, <span class="number">#44</span>]                  <span class="comment">@ load core register argument array pointer</span></span><br><span class="line">    <span class="keyword">mov</span>    <span class="built_in">r0</span>, <span class="built_in">r4</span>                          <span class="comment">@ restore method*</span></span><br><span class="line">    <span class="keyword">add</span>    <span class="built_in">ip</span>, <span class="built_in">ip</span>, <span class="number">#4</span>                      <span class="comment">@ skip r0</span></span><br><span class="line">    <span class="keyword">ldm</span>    <span class="built_in">ip</span>, &#123;<span class="built_in">r1</span>-<span class="built_in">r3</span>&#125;                     <span class="comment">@ copy r1 - r3</span></span><br><span class="line"><span class="comment">#ifdef ARM_R4_SUSPEND_FLAG</span></span><br><span class="line">    <span class="keyword">mov</span>    <span class="built_in">r4</span>, <span class="symbol">#SUSPEND_CHECK_INTERVAL</span>     <span class="comment">@ reset r4 to suspend check interval</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ldr</span>    <span class="built_in">ip</span>, [<span class="built_in">r0</span>, <span class="symbol">#ART_METHOD_QUICK_CODE_OFFSET_32</span>]  <span class="comment">@ get pointer to the code</span></span><br><span class="line">    <span class="keyword">blx</span>    <span class="built_in">ip</span>                              <span class="comment">@ call the method</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span>    <span class="built_in">sp</span>, <span class="built_in">r11</span>                         <span class="comment">@ restore the stack pointer</span></span><br><span class="line">    .cfi_def_cfa_register <span class="built_in">sp</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">ldr</span>    <span class="built_in">r4</span>, [<span class="built_in">sp</span>, <span class="number">#40</span>]                   <span class="comment">@ load result_is_float</span></span><br><span class="line">    <span class="keyword">ldr</span>    <span class="built_in">r9</span>, [<span class="built_in">sp</span>, <span class="number">#36</span>]                   <span class="comment">@ load the result pointer</span></span><br><span class="line">    <span class="keyword">cmp</span>    <span class="built_in">r4</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">ite</span>    eq</span><br><span class="line">    <span class="keyword">strdeq</span> <span class="built_in">r0</span>, [<span class="built_in">r9</span>]                        <span class="comment">@ store r0/r1 into result pointer</span></span><br><span class="line">    vstrne <span class="built_in">d0</span>, [<span class="built_in">r9</span>]                        <span class="comment">@ store s0-s1/d0 into result pointer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pop</span>    &#123;<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">r6</span>, <span class="built_in">r7</span>, <span class="built_in">r8</span>, <span class="built_in">r9</span>, <span class="built_in">r10</span>, <span class="built_in">r11</span>, <span class="built_in">pc</span>&#125;               <span class="comment">@ restore spill regs</span></span><br><span class="line"><span class="symbol">END</span> art_quick_invoke_stub_internal</span><br></pre></td></tr></table></figure>

<p>找到 <code>ArtMethod</code> 的 <code>entry_point_from_quick_compiled_code_</code> 字段，这个就是 <code>EntryPointFromQuickCompiledCode</code> ，从而进入 OAT 函数执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ART_METHOD_QUICK_CODE_OFFSET_32 36</span></span><br><span class="line"><span class="built_in">ADD_TEST_EQ</span>(ART_METHOD_QUICK_CODE_OFFSET_32,</span><br><span class="line">            art::ArtMethod::<span class="built_in">EntryPointFromQuickCompiledCodeOffset</span>(<span class="number">4</span>).<span class="built_in">Int32Value</span>())</span><br></pre></td></tr></table></figure>

<p><code>EntryPointFromQuickCompiledCode</code> 的初始化在 <code>class_linker</code> 的 <code>LoadClassMembers</code> 时调用的 <code>LinkCode</code> ，有下面几种类型</p>
<ol>
<li><p>SetEntryPointFromQuickCompiledCode(GetQuickCode());   &#x2F;&#x2F; 这个是执行 OatMethod</p>
</li>
<li><p>SetEntryPointFromQuickCompiledCode(GetQuickToInterpreterBridge());  &#x2F;&#x2F;  Dex Method</p>
</li>
<li><p>SetEntryPointFromQuickCompiledCode(GetQuickGenericJniStub())；  &#x2F;&#x2F; Native Method</p>
</li>
<li><p>SetEntryPointFromQuickCompiledCode(GetQuickResolutionStub());   &#x2F;&#x2F; method-&gt;IsStatic() &amp;&amp; !method-&gt;IsConstructor()</p>
</li>
</ol>
<p>如果是强制使用了解释器模式，那么执行的是代码 <code>GetQuickToInterpreterBridge(non-static, non-native)</code> 或 <code>GetQuickGenericJniStub(non-static, native)</code> 或 <code>GetQuickResolutionStub(static)</code> ，这几个 <code>EntryPoint</code> 对应的实际执行函数如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetQuickGenericJniStub —  artQuickGenericJniTrampoline</span><br><span class="line"></span><br><span class="line">GetQuickResolutionStub —  artQuickResolutionTrampoline</span><br><span class="line"></span><br><span class="line">GetQuickToInterpreterBridge —  artQuickToInterpreterBridge</span><br></pre></td></tr></table></figure>

<p><code>ArtMthod</code> 被 <code>Resolve</code> 之后，如果是走 <code>Oat</code> 模式就会执行 <code>GetQuickCode</code> 。</p>
<p>以上是 <code>EntryPointFromQuickCompiledCode</code> 的情况。</p>
<p>不同的执行模式有不同的 <code>EntryPoint</code> 。</p>
<ol>
<li><p>解释器 - <code>EntryPointFromInterpreter</code></p>
<p>在 <code>interpreter/interpreter_common.cc</code> 里会在执行解释器函数时，会获得 <code>ArtMethod</code> 的 <code>Interpret EntryPoint</code> 执行</p>
</li>
<li><p>Jni - <code> EntryPointFromJni</code></p>
<p><code>interpreter/interpreter.cc</code>， <code>InterpreterJni</code> 函数会获得 <code>ArtMethod的Jni EntryPoint</code> 执行</p>
</li>
<li><p>Oat - <code>EntryPointFromQuickCompiledCode</code></p>
<p><code>DexCache</code> 在 <code>Init</code> 的时候会将 <code>Method</code> 都初始化为 <code>ResolutionMethod</code> ，这个 <code>Resolution Method</code> 是没有 <code>dex method id</code> 的，是个 <code>RuntimeMethod</code> ，这是 <code>lazy load method</code> ，运行时 <code>resolve</code> 之后才会替换成实际的 <code>ArtMethod</code> 。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void DexCache::Init(const DexFile* dex_file, String* location, ObjectArray&lt;String&gt;* strings,</span><br><span class="line">                    ObjectArray&lt;Class&gt;* resolved_types, PointerArray* resolved_methods,</span><br><span class="line">                    PointerArray* resolved_fields, size_t pointer_size) &#123;</span><br><span class="line">  CHECK(dex_file != nullptr);</span><br><span class="line">  CHECK(location != nullptr);</span><br><span class="line">  CHECK(strings != nullptr);</span><br><span class="line">  CHECK(resolved_types != nullptr);</span><br><span class="line">  CHECK(resolved_methods != nullptr);</span><br><span class="line">  CHECK(resolved_fields != nullptr);</span><br><span class="line"></span><br><span class="line">  SetDexFile(dex_file);</span><br><span class="line">  SetFieldObject&lt;false&gt;(OFFSET_OF_OBJECT_MEMBER(DexCache, location_), location);</span><br><span class="line">  SetFieldObject&lt;false&gt;(StringsOffset(), strings);</span><br><span class="line">  SetFieldObject&lt;false&gt;(ResolvedFieldsOffset(), resolved_fields);</span><br><span class="line">  SetFieldObject&lt;false&gt;(OFFSET_OF_OBJECT_MEMBER(DexCache, resolved_types_), resolved_types);</span><br><span class="line">  SetFieldObject&lt;false&gt;(ResolvedMethodsOffset(), resolved_methods);</span><br><span class="line"></span><br><span class="line">  Runtime* const runtime = Runtime::Current();</span><br><span class="line">  if (runtime-&gt;HasResolutionMethod()) &#123;</span><br><span class="line">    // Initialize the resolve methods array to contain trampolines for resolution.</span><br><span class="line">    Fixup(runtime-&gt;GetResolutionMethod(), pointer_size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DexCache::Fixup(ArtMethod* trampoline, size_t pointer_size) &#123;</span><br><span class="line">  // Fixup the resolve methods array to contain trampoline for resolution.</span><br><span class="line">  CHECK(trampoline != nullptr);</span><br><span class="line">  CHECK(trampoline-&gt;IsRuntimeMethod());</span><br><span class="line">  auto* resolved_methods = GetResolvedMethods();</span><br><span class="line">  for (size_t i = 0, length = resolved_methods-&gt;GetLength(); i &lt; length; i++) &#123;</span><br><span class="line">    if (resolved_methods-&gt;GetElementPtrSize&lt;ArtMethod*&gt;(i, pointer_size) == nullptr) &#123;</span><br><span class="line">      resolved_methods-&gt;SetElementPtrSize(i, trampoline, pointer_size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>resolution method</code> 的 <code>EntryPointFromQuickCompiledCode</code> 指向 <code>GetQuickResolutionStub</code> ，意思就是一开始，这些函数的执行点都是从 <code>artQuickResolutionTrampoline</code> 开始。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Lazily resolve a method for quick. Called by stub code.</span><br><span class="line">extern &quot;C&quot; const void* artQuickResolutionTrampoline(</span><br><span class="line">    ArtMethod* called, mirror::Object* receiver, Thread* self, ArtMethod** sp)</span><br><span class="line">    SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) &#123;</span><br><span class="line">  ScopedQuickEntrypointChecks sqec(self);</span><br><span class="line">  // Start new JNI local reference state</span><br><span class="line">  JNIEnvExt* env = self-&gt;GetJniEnv();</span><br><span class="line">  ScopedObjectAccessUnchecked soa(env);</span><br><span class="line">  ScopedJniEnvLocalRefState env_state(env);</span><br><span class="line">  const char* old_cause = self-&gt;StartAssertNoThreadSuspension(&quot;Quick method resolution set up&quot;);</span><br><span class="line"></span><br><span class="line">  // Compute details about the called method (avoid GCs)</span><br><span class="line">  ClassLinker* linker = Runtime::Current()-&gt;GetClassLinker();</span><br><span class="line">  ArtMethod* caller = QuickArgumentVisitor::GetCallingMethod(sp);</span><br><span class="line">  InvokeType invoke_type;</span><br><span class="line">  MethodReference called_method(nullptr, 0);</span><br><span class="line">  const bool called_method_known_on_entry = !called-&gt;IsRuntimeMethod();</span><br><span class="line">  if (!called_method_known_on_entry) &#123;</span><br><span class="line">    uint32_t dex_pc = caller-&gt;ToDexPc(QuickArgumentVisitor::GetCallingPc(sp));</span><br><span class="line">    const DexFile::CodeItem* code;</span><br><span class="line">    called_method.dex_file = caller-&gt;GetDexFile();</span><br><span class="line">    code = caller-&gt;GetCodeItem();</span><br><span class="line">    CHECK_LT(dex_pc, code-&gt;insns_size_in_code_units_);</span><br><span class="line">    const Instruction* instr = Instruction::At(&amp;code-&gt;insns_[dex_pc]);</span><br><span class="line">    Instruction::Code instr_code = instr-&gt;Opcode();</span><br><span class="line">    bool is_range;</span><br><span class="line">    switch (instr_code) &#123;</span><br><span class="line">      case Instruction::INVOKE_DIRECT:</span><br><span class="line">        invoke_type = kDirect;</span><br><span class="line">        is_range = false;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_DIRECT_RANGE:</span><br><span class="line">        invoke_type = kDirect;</span><br><span class="line">        is_range = true;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_STATIC:</span><br><span class="line">        invoke_type = kStatic;</span><br><span class="line">        is_range = false;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_STATIC_RANGE:</span><br><span class="line">        invoke_type = kStatic;</span><br><span class="line">        is_range = true;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_SUPER:</span><br><span class="line">        invoke_type = kSuper;</span><br><span class="line">        is_range = false;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_SUPER_RANGE:</span><br><span class="line">        invoke_type = kSuper;</span><br><span class="line">        is_range = true;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_VIRTUAL:</span><br><span class="line">        invoke_type = kVirtual;</span><br><span class="line">        is_range = false;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_VIRTUAL_RANGE:</span><br><span class="line">        invoke_type = kVirtual;</span><br><span class="line">        is_range = true;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_INTERFACE:</span><br><span class="line">        invoke_type = kInterface;</span><br><span class="line">        is_range = false;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_INTERFACE_RANGE:</span><br><span class="line">        invoke_type = kInterface;</span><br><span class="line">        is_range = true;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        LOG(FATAL) &lt;&lt; &quot;Unexpected call into trampoline: &quot; &lt;&lt; instr-&gt;DumpString(nullptr);</span><br><span class="line">        UNREACHABLE();</span><br><span class="line">    &#125;</span><br><span class="line">    called_method.dex_method_index = (is_range) ? instr-&gt;VRegB_3rc() : instr-&gt;VRegB_35c();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    invoke_type = kStatic;</span><br><span class="line">    called_method.dex_file = called-&gt;GetDexFile();</span><br><span class="line">    called_method.dex_method_index = called-&gt;GetDexMethodIndex();</span><br><span class="line">  &#125;</span><br><span class="line">  uint32_t shorty_len;</span><br><span class="line">  const char* shorty =</span><br><span class="line">      called_method.dex_file-&gt;GetMethodShorty(</span><br><span class="line">          called_method.dex_file-&gt;GetMethodId(called_method.dex_method_index), &amp;shorty_len);</span><br><span class="line">  RememberForGcArgumentVisitor visitor(sp, invoke_type == kStatic, shorty, shorty_len, &amp;soa);</span><br><span class="line">  visitor.VisitArguments();</span><br><span class="line">  self-&gt;EndAssertNoThreadSuspension(old_cause);</span><br><span class="line">  const bool virtual_or_interface = invoke_type == kVirtual || invoke_type == kInterface;</span><br><span class="line">  // Resolve method filling in dex cache.</span><br><span class="line">  if (!called_method_known_on_entry) &#123;</span><br><span class="line">    StackHandleScope&lt;1&gt; hs(self);</span><br><span class="line">    mirror::Object* dummy = nullptr;</span><br><span class="line">    HandleWrapper&lt;mirror::Object&gt; h_receiver(</span><br><span class="line">        hs.NewHandleWrapper(virtual_or_interface ? &amp;receiver : &amp;dummy));</span><br><span class="line">    DCHECK_EQ(caller-&gt;GetDexFile(), called_method.dex_file);</span><br><span class="line">    called = linker-&gt;ResolveMethod(self, called_method.dex_method_index, caller, invoke_type);</span><br><span class="line">  &#125;</span><br><span class="line">  const void* code = nullptr;</span><br><span class="line">  if (LIKELY(!self-&gt;IsExceptionPending())) &#123;</span><br><span class="line">    // Incompatible class change should have been handled in resolve method.</span><br><span class="line">    CHECK(!called-&gt;CheckIncompatibleClassChange(invoke_type))</span><br><span class="line">        &lt;&lt; PrettyMethod(called) &lt;&lt; &quot; &quot; &lt;&lt; invoke_type;</span><br><span class="line">    if (virtual_or_interface) &#123;</span><br><span class="line">      // Refine called method based on receiver.</span><br><span class="line">      CHECK(receiver != nullptr) &lt;&lt; invoke_type;</span><br><span class="line"></span><br><span class="line">      ArtMethod* orig_called = called;</span><br><span class="line">      if (invoke_type == kVirtual) &#123;</span><br><span class="line">        called = receiver-&gt;GetClass()-&gt;FindVirtualMethodForVirtual(called, sizeof(void*));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        called = receiver-&gt;GetClass()-&gt;FindVirtualMethodForInterface(called, sizeof(void*));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      CHECK(called != nullptr) &lt;&lt; PrettyMethod(orig_called) &lt;&lt; &quot; &quot;</span><br><span class="line">                               &lt;&lt; PrettyTypeOf(receiver) &lt;&lt; &quot; &quot;</span><br><span class="line">                               &lt;&lt; invoke_type &lt;&lt; &quot; &quot; &lt;&lt; orig_called-&gt;GetVtableIndex();</span><br><span class="line"></span><br><span class="line">      // We came here because of sharpening. Ensure the dex cache is up-to-date on the method index</span><br><span class="line">      // of the sharpened method avoiding dirtying the dex cache if possible.</span><br><span class="line">      // Note, called_method.dex_method_index references the dex method before the</span><br><span class="line">      // FindVirtualMethodFor... This is ok for FindDexMethodIndexInOtherDexFile that only cares</span><br><span class="line">      // about the name and signature.</span><br><span class="line">      uint32_t update_dex_cache_method_index = called-&gt;GetDexMethodIndex();</span><br><span class="line">      if (!called-&gt;HasSameDexCacheResolvedMethods(caller)) &#123;</span><br><span class="line">        // Calling from one dex file to another, need to compute the method index appropriate to</span><br><span class="line">        // the caller&#x27;s dex file. Since we get here only if the original called was a runtime</span><br><span class="line">        // method, we&#x27;ve got the correct dex_file and a dex_method_idx from above.</span><br><span class="line">        DCHECK(!called_method_known_on_entry);</span><br><span class="line">        DCHECK_EQ(caller-&gt;GetDexFile(), called_method.dex_file);</span><br><span class="line">        const DexFile* caller_dex_file = called_method.dex_file;</span><br><span class="line">        uint32_t caller_method_name_and_sig_index = called_method.dex_method_index;</span><br><span class="line">        update_dex_cache_method_index =</span><br><span class="line">            called-&gt;FindDexMethodIndexInOtherDexFile(*caller_dex_file,</span><br><span class="line">                                                     caller_method_name_and_sig_index);</span><br><span class="line">      &#125;</span><br><span class="line">      if ((update_dex_cache_method_index != DexFile::kDexNoIndex) &amp;&amp;</span><br><span class="line">          (caller-&gt;GetDexCacheResolvedMethod(</span><br><span class="line">              update_dex_cache_method_index, sizeof(void*)) != called)) &#123;</span><br><span class="line">        caller-&gt;SetDexCacheResolvedMethod(update_dex_cache_method_index, called, sizeof(void*));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (invoke_type == kStatic) &#123;</span><br><span class="line">      const auto called_dex_method_idx = called-&gt;GetDexMethodIndex();</span><br><span class="line">      // For static invokes, we may dispatch to the static method in the superclass but resolve</span><br><span class="line">      // using the subclass. To prevent getting slow paths on each invoke, we force set the</span><br><span class="line">      // resolved method for the super class dex method index if we are in the same dex file.</span><br><span class="line">      // b/19175856</span><br><span class="line">      if (called-&gt;GetDexFile() == called_method.dex_file &amp;&amp;</span><br><span class="line">          called_method.dex_method_index != called_dex_method_idx) &#123;</span><br><span class="line">        called-&gt;GetDexCache()-&gt;SetResolvedMethod(called_dex_method_idx, called, sizeof(void*));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Ensure that the called method&#x27;s class is initialized.</span><br><span class="line">    StackHandleScope&lt;1&gt; hs(soa.Self());</span><br><span class="line">    Handle&lt;mirror::Class&gt; called_class(hs.NewHandle(called-&gt;GetDeclaringClass()));</span><br><span class="line">    linker-&gt;EnsureInitialized(soa.Self(), called_class, true, true);</span><br><span class="line">    if (LIKELY(called_class-&gt;IsInitialized())) &#123;</span><br><span class="line">      if (UNLIKELY(Dbg::IsForcedInterpreterNeededForResolution(self, called))) &#123;</span><br><span class="line">        // If we are single-stepping or the called method is deoptimized (by a</span><br><span class="line">        // breakpoint, for example), then we have to execute the called method</span><br><span class="line">        // with the interpreter.</span><br><span class="line">        code = GetQuickToInterpreterBridge();</span><br><span class="line">      &#125; else if (UNLIKELY(Dbg::IsForcedInstrumentationNeededForResolution(self, caller))) &#123;</span><br><span class="line">        // If the caller is deoptimized (by a breakpoint, for example), we have to</span><br><span class="line">        // continue its execution with interpreter when returning from the called</span><br><span class="line">        // method. Because we do not want to execute the called method with the</span><br><span class="line">        // interpreter, we wrap its execution into the instrumentation stubs.</span><br><span class="line">        // When the called method returns, it will execute the instrumentation</span><br><span class="line">        // exit hook that will determine the need of the interpreter with a call</span><br><span class="line">        // to Dbg::IsForcedInterpreterNeededForUpcall and deoptimize the stack if</span><br><span class="line">        // it is needed.</span><br><span class="line">        code = GetQuickInstrumentationEntryPoint();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        code = called-&gt;GetEntryPointFromQuickCompiledCode();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (called_class-&gt;IsInitializing()) &#123;</span><br><span class="line">      if (UNLIKELY(Dbg::IsForcedInterpreterNeededForResolution(self, called))) &#123;</span><br><span class="line">        // If we are single-stepping or the called method is deoptimized (by a</span><br><span class="line">        // breakpoint, for example), then we have to execute the called method</span><br><span class="line">        // with the interpreter.</span><br><span class="line">        code = GetQuickToInterpreterBridge();</span><br><span class="line">      &#125; else if (invoke_type == kStatic) &#123;</span><br><span class="line">        // Class is still initializing, go to oat and grab code (trampoline must be left in place</span><br><span class="line">        // until class is initialized to stop races between threads).</span><br><span class="line">        code = linker-&gt;GetQuickOatCodeFor(called);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // No trampoline for non-static methods.</span><br><span class="line">        code = called-&gt;GetEntryPointFromQuickCompiledCode();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      DCHECK(called_class-&gt;IsErroneous());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  CHECK_EQ(code == nullptr, self-&gt;IsExceptionPending());</span><br><span class="line">  // Fixup any locally saved objects may have moved during a GC.</span><br><span class="line">  visitor.FixupReferences();</span><br><span class="line">  // Place called method in callee-save frame to be placed as first argument to quick method.</span><br><span class="line">  *sp = called;</span><br><span class="line"></span><br><span class="line">  return code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码可知，找到当前 <code>ArtMethod</code> 的流程大致的逻辑就是，根据 <code>caller</code> 函数 <code>ArtMethod</code> 的 <code>dex</code> 代码，可以找到这个 <code>ArtMethod</code> 的函数调用类型（<code>INVOKE_DIRECT, INVOKE_STATIC, INVOKE_SUPER, INVOKE_VIRTUAL etc</code>.），不同的类型查找的方式不一样，比如 <code>Virtual Method</code> 要从虚表里找，<code>Super Method</code> 要从父类的 <code>Method</code> 里去找，找到之后调用 <code>ClassLinker</code> 的 <code>ResolveMethod</code> 来解析，解析出来的 <code>ArtMethod</code> 的就是上面 <code>LinkCode</code> 过的 <code>ArtMethod</code> 。<br>下面就是 <code>ResolveMethod</code> 函数的实现， <code>Calss</code> 查找到 <code>Method</code> ，之后在赋值到 <code>DexCache</code> 里，这样下次再执行就能直接找到 <code>Resolved Method</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArtMethod* ClassLinker::ResolveMethod(const DexFile&amp; dex_file, uint32_t method_idx,</span><br><span class="line">                                      Handle&lt;mirror::DexCache&gt; dex_cache,</span><br><span class="line">                                      Handle&lt;mirror::ClassLoader&gt; class_loader,</span><br><span class="line">                                      ArtMethod* referrer, InvokeType type) &#123;</span><br><span class="line">  DCHECK(dex_cache.Get() != nullptr);</span><br><span class="line">  // Check for hit in the dex cache.</span><br><span class="line">  ArtMethod* resolved = dex_cache-&gt;GetResolvedMethod(method_idx, image_pointer_size_);</span><br><span class="line">  if (resolved != nullptr &amp;&amp; !resolved-&gt;IsRuntimeMethod()) &#123;</span><br><span class="line">    DCHECK(resolved-&gt;GetDeclaringClassUnchecked() != nullptr) &lt;&lt; resolved-&gt;GetDexMethodIndex();</span><br><span class="line">    return resolved;</span><br><span class="line">  &#125;</span><br><span class="line">  // Fail, get the declaring class.</span><br><span class="line">  const DexFile::MethodId&amp; method_id = dex_file.GetMethodId(method_idx);</span><br><span class="line">  mirror::Class* klass = ResolveType(dex_file, method_id.class_idx_, dex_cache, class_loader);</span><br><span class="line">  if (klass == nullptr) &#123;</span><br><span class="line">    DCHECK(Thread::Current()-&gt;IsExceptionPending());</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  // Scan using method_idx, this saves string compares but will only hit for matching dex</span><br><span class="line">  // caches/files.</span><br><span class="line">  switch (type) &#123;</span><br><span class="line">    case kDirect:  // Fall-through.</span><br><span class="line">    case kStatic:</span><br><span class="line">      resolved = klass-&gt;FindDirectMethod(dex_cache.Get(), method_idx, image_pointer_size_);</span><br><span class="line">      DCHECK(resolved == nullptr || resolved-&gt;GetDeclaringClassUnchecked() != nullptr);</span><br><span class="line">      break;</span><br><span class="line">    case kInterface:</span><br><span class="line">      resolved = klass-&gt;FindInterfaceMethod(dex_cache.Get(), method_idx, image_pointer_size_);</span><br><span class="line">      DCHECK(resolved == nullptr || resolved-&gt;GetDeclaringClass()-&gt;IsInterface());</span><br><span class="line">      break;</span><br><span class="line">    case kSuper:  // Fall-through.</span><br><span class="line">    case kVirtual:</span><br><span class="line">      resolved = klass-&gt;FindVirtualMethod(dex_cache.Get(), method_idx, image_pointer_size_);</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      LOG(FATAL) &lt;&lt; &quot;Unreachable - invocation type: &quot; &lt;&lt; type;</span><br><span class="line">      UNREACHABLE();</span><br><span class="line">  &#125;</span><br><span class="line">  if (resolved == nullptr) &#123;</span><br><span class="line">    // Search by name, which works across dex files.</span><br><span class="line">    const char* name = dex_file.StringDataByIdx(method_id.name_idx_);</span><br><span class="line">    const Signature signature = dex_file.GetMethodSignature(method_id);</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">      case kDirect:  // Fall-through.</span><br><span class="line">      case kStatic:</span><br><span class="line">        resolved = klass-&gt;FindDirectMethod(name, signature, image_pointer_size_);</span><br><span class="line">        DCHECK(resolved == nullptr || resolved-&gt;GetDeclaringClassUnchecked() != nullptr);</span><br><span class="line">        break;</span><br><span class="line">      case kInterface:</span><br><span class="line">        resolved = klass-&gt;FindInterfaceMethod(name, signature, image_pointer_size_);</span><br><span class="line">        DCHECK(resolved == nullptr || resolved-&gt;GetDeclaringClass()-&gt;IsInterface());</span><br><span class="line">        break;</span><br><span class="line">      case kSuper:  // Fall-through.</span><br><span class="line">      case kVirtual:</span><br><span class="line">        resolved = klass-&gt;FindVirtualMethod(name, signature, image_pointer_size_);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // If we found a method, check for incompatible class changes.</span><br><span class="line">  if (LIKELY(resolved != nullptr &amp;&amp; !resolved-&gt;CheckIncompatibleClassChange(type))) &#123;</span><br><span class="line">    // Be a good citizen and update the dex cache to speed subsequent calls.</span><br><span class="line">    dex_cache-&gt;SetResolvedMethod(method_idx, resolved, image_pointer_size_);</span><br><span class="line">    return resolved;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // If we had a method, it&#x27;s an incompatible-class-change error.</span><br><span class="line">    if (resolved != nullptr) &#123;</span><br><span class="line">      ThrowIncompatibleClassChangeError(type, resolved-&gt;GetInvokeType(), resolved, referrer);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // We failed to find the method which means either an access error, an incompatible class</span><br><span class="line">      // change, or no such method. First try to find the method among direct and virtual methods.</span><br><span class="line">      const char* name = dex_file.StringDataByIdx(method_id.name_idx_);</span><br><span class="line">      const Signature signature = dex_file.GetMethodSignature(method_id);</span><br><span class="line">      switch (type) &#123;</span><br><span class="line">        case kDirect:</span><br><span class="line">        case kStatic:</span><br><span class="line">          resolved = klass-&gt;FindVirtualMethod(name, signature, image_pointer_size_);</span><br><span class="line">          // Note: kDirect and kStatic are also mutually exclusive, but in that case we would</span><br><span class="line">          //       have had a resolved method before, which triggers the &quot;true&quot; branch above.</span><br><span class="line">          break;</span><br><span class="line">        case kInterface:</span><br><span class="line">        case kVirtual:</span><br><span class="line">        case kSuper:</span><br><span class="line">          resolved = klass-&gt;FindDirectMethod(name, signature, image_pointer_size_);</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // If we found something, check that it can be accessed by the referrer.</span><br><span class="line">      bool exception_generated = false;</span><br><span class="line">      if (resolved != nullptr &amp;&amp; referrer != nullptr) &#123;</span><br><span class="line">        mirror::Class* methods_class = resolved-&gt;GetDeclaringClass();</span><br><span class="line">        mirror::Class* referring_class = referrer-&gt;GetDeclaringClass();</span><br><span class="line">        if (!referring_class-&gt;CanAccess(methods_class)) &#123;</span><br><span class="line">          ThrowIllegalAccessErrorClassForMethodDispatch(referring_class, methods_class, resolved,</span><br><span class="line">                                                        type);</span><br><span class="line">          exception_generated = true;</span><br><span class="line">        &#125; else if (!referring_class-&gt;CanAccessMember(methods_class, resolved-&gt;GetAccessFlags())) &#123;</span><br><span class="line">          ThrowIllegalAccessErrorMethod(referring_class, resolved);</span><br><span class="line">          exception_generated = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (!exception_generated) &#123;</span><br><span class="line">        // Otherwise, throw an IncompatibleClassChangeError if we found something, and check</span><br><span class="line">        // interface methods and throw if we find the method there. If we find nothing, throw a</span><br><span class="line">        // NoSuchMethodError.</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">          case kDirect:</span><br><span class="line">          case kStatic:</span><br><span class="line">            if (resolved != nullptr) &#123;</span><br><span class="line">              ThrowIncompatibleClassChangeError(type, kVirtual, resolved, referrer);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              resolved = klass-&gt;FindInterfaceMethod(name, signature, image_pointer_size_);</span><br><span class="line">              if (resolved != nullptr) &#123;</span><br><span class="line">                ThrowIncompatibleClassChangeError(type, kInterface, resolved, referrer);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                ThrowNoSuchMethodError(type, klass, name, signature);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">          case kInterface:</span><br><span class="line">            if (resolved != nullptr) &#123;</span><br><span class="line">              ThrowIncompatibleClassChangeError(type, kDirect, resolved, referrer);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              resolved = klass-&gt;FindVirtualMethod(name, signature, image_pointer_size_);</span><br><span class="line">              if (resolved != nullptr) &#123;</span><br><span class="line">                ThrowIncompatibleClassChangeError(type, kVirtual, resolved, referrer);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                ThrowNoSuchMethodError(type, klass, name, signature);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">          case kSuper:</span><br><span class="line">            if (resolved != nullptr) &#123;</span><br><span class="line">              ThrowIncompatibleClassChangeError(type, kDirect, resolved, referrer);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              ThrowNoSuchMethodError(type, klass, name, signature);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">          case kVirtual:</span><br><span class="line">            if (resolved != nullptr) &#123;</span><br><span class="line">              ThrowIncompatibleClassChangeError(type, kDirect, resolved, referrer);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              resolved = klass-&gt;FindInterfaceMethod(name, signature, image_pointer_size_);</span><br><span class="line">              if (resolved != nullptr) &#123;</span><br><span class="line">                ThrowIncompatibleClassChangeError(type, kInterface, resolved, referrer);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                ThrowNoSuchMethodError(type, klass, name, signature);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread::Current()-&gt;AssertPendingException();</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Art Method 的执行机制就算介绍完了，我们对整个函数执行机制都有个全局的概念了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/threepigs/article/details/52884904">https://blog.csdn.net/threepigs/article/details/52884904</a></p>
<p><a href="https://www.jianshu.com/p/2ff1b63f686b">https://www.jianshu.com/p/2ff1b63f686b</a></p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 双开沙箱 VirtualApp 源码分析（一）</title>
    <url>/2020/08/03/Android-%E5%8F%8C%E5%BC%80%E6%B2%99%E7%AE%B1-VirtualApp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>转载 : <a href="https://blog.csdn.net/ganyao939543405/article/details/76146760">https://blog.csdn.net/ganyao939543405/article/details/76146760</a></p>
</blockquote>
<p>最近发现了一个非常好的开源项目，基本实现了一个 Android 上的沙箱环境，不过应用场景最多的还是应用双开。</p>
<ul>
<li>VA github: <a href="https://github.com/asLody/VirtualApp">https://github.com/asLody/VirtualApp</a> </li>
<li>VA 的源码注释: <a href="https://github.com/ganyao114/VA_Doc">https://github.com/ganyao114/VA_Doc</a></li>
</ul>
<p>本文主要是分析一下项目的整体结构。</p>
<h1 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h1><img src="/2020/08/03/Android-%E5%8F%8C%E5%BC%80%E6%B2%99%E7%AE%B1-VirtualApp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/2020-08-03-17-09-11.png" class="">

<h2 id="android-content"><a href="#android-content" class="headerlink" title="android.content"></a>android.content</h2><p>主要是 <code>PackageParser</code>,该类型覆盖了系统的隐藏类 <code>android.content.pm.PackageParser</code></p>
<h2 id="com-lody-virtual"><a href="#com-lody-virtual" class="headerlink" title="com.lody.virtual"></a>com.lody.virtual</h2><p>这里就是框架的主体代码了</p>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p>运行在客户端的代码，指加载到 <code>VA</code> 中的子程序在被 <code>VA</code> 代理(hook)之后,所运行的代码</p>
<h3 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h3><p>hook java 层函数的一些代码</p>
<h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><p>伪造的一些 <code>framework</code> 层的 <code>IPC</code> 服务类，诸如 <code>ActivityManager</code>, <code>ServiceManager</code> 等等，使用 <code>VXXXXX</code> 命名。<code>hook</code> 之后，子程序就会运行到这里而不是原来真正的系统 <code>framework</code> 代码。</p>
<h3 id="Stub"><a href="#Stub" class="headerlink" title="Stub"></a>Stub</h3><p>系统四大组件的插桩，如提前注册在 <code>Menifest</code> 里的几十个 <code>StubActivity</code> 。</p>
<h3 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h3><p>一些可序列化 <code>Model</code> ，继承于 <code>Parcelable</code> 。  </p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p><code>server</code> 端代码， <code>VA</code> 伪造了一套 <code>framework</code> 层系统 <code>service</code> 的代码，他在一个独立的服务中记录管理组件的各种 <code>Recorder</code> ，其逻辑其实与系统原生的相近，通过 <code>Binder</code> 与 <code>client</code> 端的 <code>ipc</code> 包中的 <code>VXXXXManager</code> 通讯。诸如 <code>AMS(VAMS)</code> 、 <code>PMS(VPMS)</code>。</p>
<h2 id="mirror"><a href="#mirror" class="headerlink" title="mirror"></a>mirror</h2><p>系统 <code>framework</code> 的镜像，实现了与 <code>framework</code> 层相对应的结构，封装了反射获取系统隐藏字段和方法的，便于直接调用获取或者赋值以及调用方法。</p>
<h1 id="一些基础措施的封装"><a href="#一些基础措施的封装" class="headerlink" title="一些基础措施的封装"></a>一些基础措施的封装</h1><h2 id="Mirror-framework-层镜像"><a href="#Mirror-framework-层镜像" class="headerlink" title="Mirror framework 层镜像"></a>Mirror framework 层镜像</h2><h3 id="成员变量-Field-映射"><a href="#成员变量-Field-映射" class="headerlink" title="成员变量 Field 映射"></a>成员变量 Field 映射</h3><p>根据成员变量类型，映射类型分为几个基本数据类型和对象引用类型。下面就以对象引用类型为例，其他类型类似。</p>
<p>类型 <code>RefObject</code> 代表映射 <code>framework</code> 层同名的泛型类型成员变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Field 映射</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public class RefObject&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // framework 层对应的 Field</span><br><span class="line">    private Field field;</span><br><span class="line"></span><br><span class="line">    public RefObject(Class&lt;?&gt; cls, Field field) throws NoSuchFieldException &#123;</span><br><span class="line">        // 获取 framework 中同名字段的 field</span><br><span class="line">        this.field = cls.getDeclaredField(field.getName());</span><br><span class="line">        this.field.setAccessible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取变量值</span><br><span class="line">    public T get(Object object) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (T) this.field.get(object);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 赋值</span><br><span class="line">    public void set(Object obj, T value) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.field.set(obj, value);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            //Ignore</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>framework</code> 层中隐藏类 <code>LoadedApk</code> 来说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LoadedApk &#123;</span><br><span class="line">    public static Class Class = RefClass.load(LoadedApk.class, &quot;android.app.LoadedApk&quot;);</span><br><span class="line">    public static RefObject&lt;ApplicationInfo&gt; mApplicationInfo;</span><br><span class="line">    @MethodParams(&#123;boolean.class, Instrumentation.class&#125;)</span><br><span class="line">    public static RefMethod&lt;Application&gt; makeApplication;</span><br></pre></td></tr></table></figure>

<p><code>mApplicationInfo</code> 就是 <code>LoadedApk</code> 中私有字段 <code>ApplicationInfo</code> 类型的同名映射。</p>
<p>当你引用 <code>LoadedApk Mirror</code> 类时，类加载器加载该类并执行静态成员的初始化 <code>RefClass.load(LoadedApk.class, “android.app.LoadedApk”)</code> ， <code>LoadedApk Mirror</code> 类中的同名字段将被反射赋值。</p>
<p>下面看一下 <code>RefClass.load()</code> 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Class load(Class mappingClass, Class&lt;?&gt; realClass) &#123;</span><br><span class="line">    // 获取 Mirror 类的所有字段</span><br><span class="line">    Field[] fields = mappingClass.getDeclaredFields();</span><br><span class="line">    for (Field field : fields) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 必须是 static 变量</span><br><span class="line">            if (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">                // 从预设的 Map 中找到 RefXXXX 的构造器</span><br><span class="line">                Constructor&lt;?&gt; constructor = REF_TYPES.get(field.getType());</span><br><span class="line">                if (constructor != null) &#123;</span><br><span class="line">                    // 这里首先利用构造函数获取framework层真正的字段，然后赋值 LoadedApk 的静态字段，一遍后续调用 get 和 set</span><br><span class="line">                    field.set(null, constructor.newInstance(realClass, field));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            // Ignore</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return realClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续再进行调用的话，使用 <code>LoadedApk.mApplicationInfo.get(instance)</code> 、 <code>LoadedApk.mApplicationInfo.set(instance)</code> 就相当于直接调用 <code>framework</code> 层的 <code>LoadedApk.mApplicationInfo</code> 字段了。</p>
<h3 id="Method-映射"><a href="#Method-映射" class="headerlink" title="Method 映射"></a>Method 映射</h3><p>其实与 <code>Field</code> 类似，只是 <code>Field</code> 主要是一个 <code>call</code> 即调用方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@MethodParams(&#123;File.class, int.class&#125;)</span><br><span class="line">public static RefMethod&lt;PackageParser.Package&gt; parsePackage;</span><br></pre></td></tr></table></figure>

<p>表现在 <code>Mirror</code> 类型中也是一个字段，不过要在字段上边加上注解以标注参数类型。</p>
<p>当然还有一种情况，参数类型也是隐藏的，则要使用全限定名表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@MethodReflectParams(&#123;&quot;android.content.pm.PackageParser$Package&quot;, &quot;int&quot;&#125;)</span><br><span class="line">public static RefMethod&lt;Void&gt; collectCertificates;</span><br></pre></td></tr></table></figure>

<h2 id="Java-层-Hook"><a href="#Java-层-Hook" class="headerlink" title="Java 层 Hook"></a>Java 层 Hook</h2><p>位于 <code>com.lody.virtual.client.hook</code></p>
<p><code>Java</code> 层使用了 <code>Java</code> 自带的动态代理</p>
<h3 id="MethodProxy"><a href="#MethodProxy" class="headerlink" title="MethodProxy"></a>MethodProxy</h3><p><code>Hook</code> 点的代理接口，动态代理中的 <code>call</code> 。</p>
<p>重要的是这三个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean beforeCall(Object who, Method method, Object... args) &#123;</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object call(Object who, Method method, Object... args) throws Throwable &#123;</span><br><span class="line">    return method.invoke(who, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object afterCall(Object who, Method method, Object[] args, Object result) throws Throwable &#123;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>hook getServices</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class GetServices extends MethodProxy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getMethodName() &#123;</span><br><span class="line">        return &quot;getServices&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object call(Object who, Method method, Object... args) throws Throwable &#123;</span><br><span class="line">        int maxNum = (int) args[0];</span><br><span class="line">        int flags = (int) args[1];</span><br><span class="line">        return VActivityManager.get().getServices(maxNum, flags).getList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEnable() &#123;</span><br><span class="line">        return isAppProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>getMethodName</code> 是要 <code>Hook</code> 的方法名 </li>
<li><code>Hook getServices</code> 之后发现，真正返回服务的方法变成了仿造的 <code>VActivityManager</code> 对象。而在后面我们会知道这些服务最后都会从 <code>VAMS</code> 中获取，而不是原来的 <code>AMS</code> 。</li>
<li>实现了 <code>isEnable</code> 方法，这是 <code>Hook</code> 开关，如果返回 <code>false</code> 则不 <code>Hook</code> 该方法，而在这里的条件是，只有在子程序环境中 <code>Hook</code> ，而宿主即框架是不需要 <code>Hook</code> 的，框架仍然需要连接真正的 <code>AMS</code> 以获取在系统 <code>AMS</code> 中注册的“外部” <code>service</code> 。</li>
</ul>
<p>那么上面这个 <code>call</code> 在哪里被调用呢？ </p>
<p><strong><code>MethodInvocationStub</code></strong> ，这个桩对应一个需要 <code>Hook</code> 的类，各种 <code>Method</code> 可以在内部添加。</p>
<p>我们需要专注这个方法 <code>addMethodProxy</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* Add a method proxy.</span><br><span class="line">*</span><br><span class="line">* @param methodProxy proxy</span><br><span class="line">*/</span><br><span class="line">public MethodProxy addMethodProxy(MethodProxy methodProxy) &#123;</span><br><span class="line">    if (methodProxy != null &amp;&amp; !TextUtils.isEmpty(methodProxy.getMethodName())) &#123;</span><br><span class="line">        if (mInternalMethodProxies.containsKey(methodProxy.getMethodName())) &#123;</span><br><span class="line">            VLog.w(TAG, &quot;The Hook(%s, %s) you added has been in existence.&quot;, methodProxy.getMethodName(),</span><br><span class="line">                    methodProxy.getClass().getName());</span><br><span class="line">            return methodProxy;</span><br><span class="line">        &#125;</span><br><span class="line">        mInternalMethodProxies.put(methodProxy.getMethodName(), methodProxy);</span><br><span class="line">    &#125;</span><br><span class="line">    return methodProxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个也是关于动态代理的知识，这里的区别其实就是 <code>Lody</code> 对他做了一些接口的抽象，和一些诸如 <code>Log</code> 的封装。</p>
<p>添加 <code>Hook Method</code> 的方式有两个：</p>
<ul>
<li>一是调用 <code>addMethodProxy</code> ，</li>
<li>二是在 <code>Stub</code> 上添加 <code>@Inject</code> 注解。</li>
</ul>
<p>具体见下一段。</p>
<h3 id="MethodProxies"><a href="#MethodProxies" class="headerlink" title="MethodProxies"></a>MethodProxies</h3><p>叫这个名字的类很多，每一个 <code>MethodProxies</code> 对应一个需要 <code>Hook</code> 的 <code>framework</code> 类型，需要 <code>Hook</code> 的方法以内部类(MethodProxy)的形式罗列在内部。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Inject(MethodProxies.class)</span><br><span class="line">public class LibCoreStub extends MethodInvocationProxy&lt;MethodInvocationStub&lt;Object&gt;&gt; &#123;</span><br></pre></td></tr></table></figure>
<p>将要 <code>Hook</code> 的方法集合 <code>MethodProxies</code> 绑定到 <code>Stub</code> 上。然后就是 <code>Stub</code> 对自己头上注解的解析，最终还是会调用到内部的 <code>addMethodProxy</code> 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void onBindMethods() &#123;</span><br><span class="line"></span><br><span class="line">    if (mInvocationStub == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;? extends MethodInvocationProxy&gt; clazz = getClass();</span><br><span class="line">    Inject inject = clazz.getAnnotation(Inject.class);</span><br><span class="line">    if (inject != null) &#123;</span><br><span class="line">        Class&lt;?&gt; proxiesClass = inject.value();</span><br><span class="line">        Class&lt;?&gt;[] innerClasses = proxiesClass.getDeclaredClasses();</span><br><span class="line">        // 遍历内部类</span><br><span class="line">        for (Class&lt;?&gt; innerClass : innerClasses) &#123;</span><br><span class="line">            if (!Modifier.isAbstract(innerClass.getModifiers())</span><br><span class="line">                    &amp;&amp; MethodProxy.class.isAssignableFrom(innerClass)</span><br><span class="line">                    &amp;&amp; innerClass.getAnnotation(SkipInject.class) == null) &#123;</span><br><span class="line">                addMethodProxy(innerClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="运行时结构"><a href="#运行时结构" class="headerlink" title="运行时结构"></a>运行时结构</h1><p>这点很重要， <code>VA</code> 在运行时并不是一个简单的单进程的库，其需要在系统调用到其预先注册的 <code>Stub</code> 组件之后接手系统代理 <code>Client App</code> 的 四大组件，包括生命周期等一切事物。</p>
<p><code>VA</code> 参照原生系统 <code>framework</code> 仿造了一套 <code>framework service</code>，还有配套在 <code>client</code> 端的 <code>framework</code> 库。</p>
<h2 id="系统原生的-framework-运作方式"><a href="#系统原生的-framework-运作方式" class="headerlink" title="系统原生的 framework 运作方式"></a>系统原生的 framework 运作方式</h2><p>简单来说，我们平时所用到的 <code>app</code> 运行空间中的 <code>framework api</code> 最终会通过 <code>Binder</code> 远程调用到 <code>framework service</code> 空间的远程服务。</p>
<p>而远程服务类似 <code>AMS</code> 中的 <code>Recoder</code> 中会持有 <code>app</code> 空间的 <code>Ibinder token</code> 句柄，通过 <code>token</code> 也可以让 <code>framework service</code> 远程调用到 <code>app</code> 空间。</p>
<img src="/2020/08/03/Android-%E5%8F%8C%E5%BC%80%E6%B2%99%E7%AE%B1-VirtualApp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/2020-08-03-20-12-02.png" class="">


<h2 id="VA-环境下-framework-运作方式"><a href="#VA-环境下-framework-运作方式" class="headerlink" title="VA 环境下 framework 运作方式"></a>VA 环境下 framework 运作方式</h2><p>而在 <code>VA</code> 环境下，情况其实也是类似，只不过在 <code>framework service</code> 和 <code>client app</code> 之间还有另外一个 <code>VA</code> 实现的 <code>VAService</code> ， <code>VAService</code> 仿造了 <code>framework service</code> 的一些功能。</p>
<p>因为在 <code>VA</code> 中运行的 <code>Client App</code> 都是没有(也不能注册)在 <code>framework service </code>的，注册的只有 <code>VA</code> 预先注册在 <code>Menifest</code> 中的 <code>Stub</code> 而已。所以 <code>frameservice</code> 是无法像普通 <code>App</code> 一样管理 <code>VA Client App</code> 的会话的。</p>
<p>这就要依靠 <code>VA</code> 仿造的另外一套 <code>VAService</code> 完成对 <code>VA</code> 中 <code>Client App</code> 的会话管理了。</p>
<img src="/2020/08/03/Android-%E5%8F%8C%E5%BC%80%E6%B2%99%E7%AE%B1-VirtualApp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/2020-08-03-20-48-38.png" class="">

<p>需要注意的是 <code>VA Client</code> 获取 <code>VA Service</code> 的 <code>IBinder</code> 句柄是统一通过 <code>IServiceFetcher</code> 这个句柄，这个看上去有些奇怪。而获得 <code>IServiceFetcher</code> 本身的方式是通过 <code>ContentProvider</code> ，选择 <code>ContentProvider</code> 原因是 <code>ContentProvider</code> 是同步的，如果使用 <code>Servicec</code> ，<code>Service</code> 的连接是异步的。</p>
<blockquote>
<p>使用contentprovider比service实现同步轻松得多。前不久我还在想怎么同步调用service中的方法，最终选择了aidl。但是aidl需要绑定服务才能使用，而使用contentprovider调用同app不同进程的方法一个字符串就可以了，也不要求进程必须在。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>VirtualApp</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 双开沙箱 VirtualApp 源码分析（三）App 启动</title>
    <url>/2020/08/08/Android-%E5%8F%8C%E5%BC%80%E6%B2%99%E7%AE%B1-VirtualApp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89App-%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<blockquote>
<p>转载 : <a href="https://blog.csdn.net/ganyao939543405/article/details/76177392">https://blog.csdn.net/ganyao939543405/article/details/76177392</a></p>
</blockquote>
<p>在这之前，我们还是要先了解一下 VA Client Framework 和 VAService 之间的通讯方式</p>
<h1 id="VAService-与通讯"><a href="#VAService-与通讯" class="headerlink" title="VAService 与通讯"></a>VAService 与通讯</h1><h2 id="VAService"><a href="#VAService" class="headerlink" title="VAService"></a>VAService</h2><p>首先 <code>VAService</code> 是指 <code>VA</code> 仿造 <code>Android</code> 原生 <code>framework</code> 层 <code>Service</code> 实现的一套副本，举例有 <code>VActivityManagerService</code> ，它和系统 <code>AMS</code> 一样，只不过他管理的是 <code>VA</code> 内部 <code>Client App</code> 的组件会话。</p>
<img src="/2020/08/08/Android-%E5%8F%8C%E5%BC%80%E6%B2%99%E7%AE%B1-VirtualApp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89App-%E5%90%AF%E5%8A%A8/2020-08-08-17-25-02.png" class="">

<h1 id="VAService-统一管理"><a href="#VAService-统一管理" class="headerlink" title="VAService 统一管理"></a>VAService 统一管理</h1><p>首先所有 <code>VAService</code> 直接继承与 <code>XXX.Stub</code>，也就是 <code>Binder</code> ，并且直接使用了一个 <code>Map</code> 储存在 <code>VAService</code> 进程空间中，并没有注册到系统 <code>AMS</code> 中，事实上在 <code>VAService</code> 进程中，每个 <code>Service</code> 都被当作一个普通对象 <code>new</code> 和初始化。</p>
<p>最终，他们被添加到了 <code>ServiceCache</code> 中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ServiceCache &#123;</span><br><span class="line"></span><br><span class="line">	private static final Map&lt;String, IBinder&gt; sCache = new ArrayMap&lt;&gt;(5);</span><br><span class="line"></span><br><span class="line">	public static void addService(String name, IBinder service) &#123;</span><br><span class="line">		sCache.put(name, service);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static IBinder removeService(String name) &#123;</span><br><span class="line">		return sCache.remove(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static IBinder getService(String name) &#123;</span><br><span class="line">		return sCache.get(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>cache</code> 很简单，就是一个 <code>Map</code> 。</p>
<p>而被添加的时机则在 <code>BinderProvider</code> 的 <code>onCreate()</code> 回调中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onCreate() &#123;</span><br><span class="line">    Context context = getContext();</span><br><span class="line">    // 这是一个空前台服务，目的是为了保活 VAService 进程，即 :x 进程</span><br><span class="line">    DaemonService.startup(context);</span><br><span class="line">    if (!VirtualCore.get().isStartup()) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    VPackageManagerService.systemReady();</span><br><span class="line">    addService(ServiceManagerNative.PACKAGE, VPackageManagerService.get());</span><br><span class="line">    VActivityManagerService.systemReady(context);</span><br><span class="line">    addService(ServiceManagerNative.ACTIVITY, VActivityManagerService.get());</span><br><span class="line">    addService(ServiceManagerNative.USER, VUserManagerService.get());</span><br><span class="line">    VAppManagerService.systemReady();</span><br><span class="line">    addService(ServiceManagerNative.APP, VAppManagerService.get());</span><br><span class="line">    BroadcastSystem.attach(VActivityManagerService.get(), VAppManagerService.get());</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        addService(ServiceManagerNative.JOB, VJobSchedulerService.get());</span><br><span class="line">    &#125;</span><br><span class="line">    VNotificationManagerService.systemReady(context);</span><br><span class="line">    addService(ServiceManagerNative.NOTIFICATION, VNotificationManagerService.get());</span><br><span class="line">    VAppManagerService.get().scanApps();</span><br><span class="line">    VAccountManagerService.systemReady();</span><br><span class="line">    addService(ServiceManagerNative.ACCOUNT, VAccountManagerService.get());</span><br><span class="line">    addService(ServiceManagerNative.VS, VirtualStorageService.get());</span><br><span class="line">    addService(ServiceManagerNative.DEVICE, VDeviceManagerService.get());</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是 <code>DeamonService</code> 是一个空前台服务，目的是为了保活 <code>VAService</code> 进程，即 <code>:x</code> 进程，因为现在后台服务很容易被杀，在 Android 8.0 以后后台服务只能在后台存活 <code>5S</code> ，而前台服务则不受影响。</p>
<h2 id="ServiceFetcher"><a href="#ServiceFetcher" class="headerlink" title="ServiceFetcher"></a>ServiceFetcher</h2><p><code>VA</code> 设计了一个单独的 <code>ServiceFetcher</code> 服务用于向外部暴露 <code>VAService</code> 中的所有服务的 <code>IBinder</code> 句柄，而 <code>ServiceFetcher</code> 本身也是 <code>Binder</code> 服务，也就是说， <code>ServiceFetcher</code> 的 <code>Ibinder</code> 句柄是拿到其他 <code>VAService IBinder</code> 的钥匙。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ServiceFetcher 实现类 远程调用类</span><br><span class="line">private class ServiceFetcher extends IServiceFetcher.Stub &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder getService(String name) throws RemoteException &#123;</span><br><span class="line">        if (name != null) &#123;</span><br><span class="line">            return ServiceCache.getService(name);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addService(String name, IBinder service) throws RemoteException &#123;</span><br><span class="line">        if (name != null &amp;&amp; service != null) &#123;</span><br><span class="line">            ServiceCache.addService(name, service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void removeService(String name) throws RemoteException &#123;</span><br><span class="line">        if (name != null) &#123;</span><br><span class="line">            ServiceCache.removeService(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServicecFetcher</code> 自身的 <code>IBnder</code> 则通过 <code>BinderProvicer</code> <code>这个ContentProvider</code> 暴露给其他进程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Bundle call(String method, String arg, Bundle extras) &#123;</span><br><span class="line">    if (&quot;@&quot;.equals(method)) &#123;</span><br><span class="line">        Bundle bundle = new Bundle();</span><br><span class="line">        BundleCompat.putBinder(bundle, &quot;_VA_|_binder_&quot;, mServiceFetcher);</span><br><span class="line">        return bundle;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在 <code>Client App</code> 中<code> VA Client</code> 就可以通过 <code>IServiceFetcher</code> 这个 <code>IBinder</code> 拿到其他服务的 <code>IBinder</code> 了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过 ContentProvider 传递一个</span><br><span class="line">private static IServiceFetcher sFetcher;</span><br><span class="line"></span><br><span class="line">private static IServiceFetcher getServiceFetcher() &#123;</span><br><span class="line">    if (sFetcher == null || !sFetcher.asBinder().isBinderAlive()) &#123;</span><br><span class="line">        synchronized (ServiceManagerNative.class) &#123;</span><br><span class="line">            Context context = VirtualCore.get().getContext();</span><br><span class="line">            Bundle response = new ProviderCall.Builder(context, SERVICE_CP_AUTH).methodName(&quot;@&quot;).call();</span><br><span class="line">            /* SERVICE_CP_AUTH 对应着下面的 Provider</span><br><span class="line">                &lt;provider</span><br><span class="line">                    android:name=&quot;com.lody.virtual.server.BinderProvider&quot;</span><br><span class="line">                    android:authorities=&quot;$&#123;applicationId&#125;.virtual.service.BinderProvider&quot;</span><br><span class="line">                    android:exported=&quot;false&quot;</span><br><span class="line">                    android:process=&quot;@string/engine_process_name&quot; /&gt;</span><br><span class="line">            */</span><br><span class="line">            if (response != null) &#123;</span><br><span class="line">                IBinder binder = BundleCompat.getBinder(response, &quot;_VA_|_binder_&quot;);</span><br><span class="line">                linkBinderDied(binder);</span><br><span class="line">                sFetcher = IServiceFetcher.Stub.asInterface(binder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sFetcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回服务的 IBinder 句柄</span><br><span class="line">public static IBinder getService(String name) &#123;</span><br><span class="line">    // 如果是本地服务，直接本地返回</span><br><span class="line">    if (VirtualCore.get().isServerProcess()) &#123;</span><br><span class="line">        return ServiceCache.getService(name);</span><br><span class="line">    &#125;</span><br><span class="line">    // 通过 ServiceFetcher 的句柄找到远程 Service 的句柄</span><br><span class="line">    IServiceFetcher fetcher = getServiceFetcher();</span><br><span class="line">    if (fetcher != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return fetcher.getService(name);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    VLog.e(TAG, &quot;GetService(%s) return null.&quot;, name);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="启动-App"><a href="#启动-App" class="headerlink" title="启动 App"></a>启动 App</h1><p>首先要了解的是 <code>Android App</code> 是组件化的， <code>Apk</code> 其实是 N 多个组件的集合，以及一些资源文件和 <code>Assert</code> ， <code>App</code> 的启动有多种情况，只要在一个新的进程中调起了 <code>apk</code> 中任何一个组件， <code>App</code> 将被初始化， <code>Application</code> 将被初始化。</p>
<h2 id="启动-Activity"><a href="#启动-Activity" class="headerlink" title="启动 Activity"></a>启动 Activity</h2><p>我们先看启动 <code>Activity</code> 的情况:</p>
<h3 id="Hook-startActivity-重定位-Intent-到-StubActivity"><a href="#Hook-startActivity-重定位-Intent-到-StubActivity" class="headerlink" title="Hook startActivity(重定位 Intent 到 StubActivity)"></a>Hook startActivity(重定位 Intent 到 StubActivity)</h3><p>首先在 <code>Client App</code> 中， <code>startActivity</code> 方法必须被 <code>Hook</code> 掉，不然 <code>Client App</code> 调用 <code>startActivity</code> 就直指外部 <code>Activity</code> 去了。</p>
<p>这部分的原理其实与 <code>DroidPlugin</code> 大同小异，由于插件(<code>Client App</code>)中的 <code>Activity</code> 是没有在 <code>AMS</code> 中注册的， <code>AMS</code> 自然无法找到我们的插件 <code>Activity</code> 。</p>
<p><code>Hook</code> 的目的是我们拿到用户的 <code>Intent</code> ，把他替换成指向 <code>VA</code> 在 <code>Menifest</code> 中站好坑的 <code>StubActivity</code> 的 <code>Intent</code> ，然后将原 <code>Intent</code> 当作 <code>data</code> 打包进新 <code>Intent</code> 以便日后流程再次进入 <code>VA</code> 时恢复。</p>
<p><code>Hook</code> 的方法就是用我们动态代理生成的代理类对象替换系统原来的 <code>ActiityManagerNative.geDefault</code> 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ActivityManagerStub.java</span><br><span class="line">@Override</span><br><span class="line">public void inject() throws Throwable &#123;</span><br><span class="line">    if (BuildCompat.isOreo()) &#123;</span><br><span class="line">        //Android Oreo(8.X)</span><br><span class="line">        Object singleton = ActivityManagerOreo.IActivityManagerSingleton.get();</span><br><span class="line">        Singleton.mInstance.set(singleton, getInvocationStub().getProxyInterface());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (ActivityManagerNative.gDefault.type() == IActivityManager.TYPE) &#123;</span><br><span class="line">            ActivityManagerNative.gDefault.set(getInvocationStub().getProxyInterface());</span><br><span class="line">        &#125; else if (ActivityManagerNative.gDefault.type() == Singleton.TYPE) &#123;</span><br><span class="line">            Object gDefault = ActivityManagerNative.gDefault.get();</span><br><span class="line">            Singleton.mInstance.set(gDefault, getInvocationStub().getProxyInterface());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BinderInvocationStub hookAMBinder = new BinderInvocationStub(getInvocationStub().getBaseInterface());</span><br><span class="line">    hookAMBinder.copyMethodProxies(getInvocationStub());</span><br><span class="line">    ServiceManager.sCache.get().put(Context.ACTIVITY_SERVICE, hookAMBinder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，下面只要调用到 <code>startActivity</code> 就会被 <code>Hook</code> 到 <code>call</code> 。</p>
<p>这个函数需要注意以下几点：</p>
<ol>
<li><code>VA</code> 有意将安装和卸载 <code>APP</code> 的请求重定向到了卸载 <code>VA</code> 内部 <code>APK</code> 的逻辑。</li>
<li><code>resolveActivityInfo</code> 调用到了 <code>VPM</code> 的 <code>resolveIntent</code> ，最终会远程调用到 <code>VPMS</code> 的 <code>resolveIntent</code> ，然后 <code>VPMS</code> 就会去查询 <code>VPackage</code> 找到目标 <code>Activity</code> 并将信息附加在 <code>ResolveInfo</code> 中返回 <code>VPM</code> 。</li>
<li>最后也是最重要的一点， <code>startActivity</code> 会调用到<code> VAM.startActivity</code> ，同样最终会远程调用到 <code>VAMS</code> 的 <code>startActivity</code> 。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Hook startActivity</span><br><span class="line">static class StartActivity extends MethodProxy &#123;</span><br><span class="line"></span><br><span class="line">    private static final String SCHEME_FILE = &quot;file&quot;;</span><br><span class="line">    private static final String SCHEME_PACKAGE = &quot;package&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getMethodName() &#123;</span><br><span class="line">        return &quot;startActivity&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object call(Object who, Method method, Object... args) throws Throwable &#123;</span><br><span class="line">        int intentIndex = ArrayUtils.indexOfObject(args, Intent.class, 1);</span><br><span class="line">        if (intentIndex &lt; 0) &#123;</span><br><span class="line">            return ActivityManagerCompat.START_INTENT_NOT_RESOLVED;</span><br><span class="line">        &#125;</span><br><span class="line">        int resultToIndex = ArrayUtils.indexOfObject(args, IBinder.class, 2);</span><br><span class="line">        String resolvedType = (String) args[intentIndex + 1];</span><br><span class="line">        Intent intent = (Intent) args[intentIndex];</span><br><span class="line">        intent.setDataAndType(intent.getData(), resolvedType);</span><br><span class="line">        IBinder resultTo = resultToIndex &gt;= 0 ? (IBinder) args[resultToIndex] : null;</span><br><span class="line">        int userId = VUserHandle.myUserId();</span><br><span class="line"></span><br><span class="line">        if (ComponentUtils.isStubComponent(intent)) &#123;</span><br><span class="line">            return method.invoke(who, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 请求安装和卸载界面</span><br><span class="line">        if (Intent.ACTION_INSTALL_PACKAGE.equals(intent.getAction())</span><br><span class="line">                || (Intent.ACTION_VIEW.equals(intent.getAction())</span><br><span class="line">                &amp;&amp; &quot;application/vnd.android.package-archive&quot;.equals(intent.getType()))) &#123;</span><br><span class="line">            if (handleInstallRequest(intent)) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ((Intent.ACTION_UNINSTALL_PACKAGE.equals(intent.getAction())</span><br><span class="line">                || Intent.ACTION_DELETE.equals(intent.getAction()))</span><br><span class="line">                &amp;&amp; &quot;package&quot;.equals(intent.getScheme())) &#123;</span><br><span class="line"></span><br><span class="line">            if (handleUninstallRequest(intent)) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String resultWho = null;</span><br><span class="line">        int requestCode = 0;</span><br><span class="line">        Bundle options = ArrayUtils.getFirst(args, Bundle.class);</span><br><span class="line">        if (resultTo != null) &#123;</span><br><span class="line">            resultWho = (String) args[resultToIndex + 1];</span><br><span class="line">            requestCode = (int) args[resultToIndex + 2];</span><br><span class="line">        &#125;</span><br><span class="line">        // chooser 调用选择界面</span><br><span class="line">        if (ChooserActivity.check(intent)) &#123;</span><br><span class="line">            intent.setComponent(new ComponentName(getHostContext(), ChooserActivity.class));</span><br><span class="line">            intent.putExtra(Constants.EXTRA_USER_HANDLE, userId);</span><br><span class="line">            intent.putExtra(ChooserActivity.EXTRA_DATA, options);</span><br><span class="line">            intent.putExtra(ChooserActivity.EXTRA_WHO, resultWho);</span><br><span class="line">            intent.putExtra(ChooserActivity.EXTRA_REQUEST_CODE, requestCode);</span><br><span class="line">            return method.invoke(who, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR2) &#123;</span><br><span class="line">            args[intentIndex - 1] = getHostPkg();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //解析 ActivityInfo</span><br><span class="line">        ActivityInfo activityInfo = VirtualCore.get().resolveActivityInfo(intent, userId);</span><br><span class="line">        if (activityInfo == null) &#123;</span><br><span class="line">            VLog.e(&quot;VActivityManager&quot;, &quot;Unable to resolve activityInfo : &quot; + intent);</span><br><span class="line">            if (intent.getPackage() != null &amp;&amp; isAppPkg(intent.getPackage())) &#123;</span><br><span class="line">                return ActivityManagerCompat.START_INTENT_NOT_RESOLVED;</span><br><span class="line">            &#125;</span><br><span class="line">            return method.invoke(who, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 调用远程 VAMS.startActivity</span><br><span class="line">        int res = VActivityManager.get().startActivity(intent, activityInfo, resultTo, options, resultWho, requestCode, VUserHandle.myUserId());</span><br><span class="line">        if (res != 0 &amp;&amp; resultTo != null &amp;&amp; requestCode &gt; 0) &#123;</span><br><span class="line">            VActivityManager.get().sendActivityResult(resultTo, resultWho, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 处理 Activity 切换动画，因为此时动画还是 Host 的 Stub Activity 默认动画，需要覆盖成子程序包的动画</span><br><span class="line">        if (resultTo != null) &#123;</span><br><span class="line">            ActivityClientRecord r = VActivityManager.get().getActivityRecord(resultTo);</span><br><span class="line">            if (r != null &amp;&amp; r.activity != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TypedValue out = new TypedValue();</span><br><span class="line">                    Resources.Theme theme = r.activity.getResources().newTheme();</span><br><span class="line">                    theme.applyStyle(activityInfo.getThemeResource(), true);</span><br><span class="line">                    if (theme.resolveAttribute(android.R.attr.windowAnimationStyle, out, true)) &#123;</span><br><span class="line"></span><br><span class="line">                        TypedArray array = theme.obtainStyledAttributes(out.data,</span><br><span class="line">                                new int[]&#123;</span><br><span class="line">                                        android.R.attr.activityOpenEnterAnimation,</span><br><span class="line">                                        android.R.attr.activityOpenExitAnimation</span><br><span class="line">                                &#125;);</span><br><span class="line"></span><br><span class="line">                        r.activity.overridePendingTransition(array.getResourceId(0, 0), array.getResourceId(1, 0));</span><br><span class="line">                        array.recycle();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    // Ignore</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private boolean handleInstallRequest(Intent intent) &#123;</span><br><span class="line">        IAppRequestListener listener = VirtualCore.get().getAppRequestListener();</span><br><span class="line">        if (listener != null) &#123;</span><br><span class="line">            Uri packageUri = intent.getData();</span><br><span class="line">            if (SCHEME_FILE.equals(packageUri.getScheme())) &#123;</span><br><span class="line">                File sourceFile = new File(packageUri.getPath());</span><br><span class="line">                try &#123;</span><br><span class="line">                    listener.onRequestInstall(sourceFile.getPath());</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean handleUninstallRequest(Intent intent) &#123;</span><br><span class="line">        IAppRequestListener listener = VirtualCore.get().getAppRequestListener();</span><br><span class="line">        if (listener != null) &#123;</span><br><span class="line">            Uri packageUri = intent.getData();</span><br><span class="line">            if (SCHEME_PACKAGE.equals(packageUri.getScheme())) &#123;</span><br><span class="line">                String pkg = packageUri.getSchemeSpecificPart();</span><br><span class="line">                try &#123;</span><br><span class="line">                    listener.onRequestUninstall(pkg);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑最终走到 <code>VAMS</code> <code>后，VAMS</code> 调用 <code>ActivityStack</code>.<code>startActivityLocked</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 参考 framework 的实现</span><br><span class="line">int startActivityLocked(int userId, Intent intent, ActivityInfo info, IBinder resultTo, Bundle options,</span><br><span class="line">                        String resultWho, int requestCode) &#123;</span><br><span class="line">    optimizeTasksLocked();</span><br><span class="line"></span><br><span class="line">    Intent destIntent;</span><br><span class="line">    ActivityRecord sourceRecord = findActivityByToken(userId, resultTo);</span><br><span class="line">    TaskRecord sourceTask = sourceRecord != null ? sourceRecord.task : null;</span><br><span class="line"></span><br><span class="line">    ReuseTarget reuseTarget = ReuseTarget.CURRENT;</span><br><span class="line">    ClearTarget clearTarget = ClearTarget.NOTHING;</span><br><span class="line">    boolean clearTop = containFlags(intent, Intent.FLAG_ACTIVITY_CLEAR_TOP);</span><br><span class="line">    boolean clearTask = containFlags(intent, Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line"></span><br><span class="line">    if (intent.getComponent() == null) &#123;</span><br><span class="line">        intent.setComponent(new ComponentName(info.packageName, info.name));</span><br><span class="line">    &#125;</span><br><span class="line">    if (sourceRecord != null &amp;&amp; sourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    &#125;</span><br><span class="line">    if (clearTop) &#123;</span><br><span class="line">        removeFlags(intent, Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);</span><br><span class="line">        clearTarget = ClearTarget.TOP;</span><br><span class="line">    &#125;</span><br><span class="line">    if (clearTask) &#123;</span><br><span class="line">        if (containFlags(intent, Intent.FLAG_ACTIVITY_NEW_TASK)) &#123;</span><br><span class="line">            clearTarget = ClearTarget.TASK;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            removeFlags(intent, Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        switch (info.documentLaunchMode) &#123;</span><br><span class="line">            case ActivityInfo.DOCUMENT_LAUNCH_INTO_EXISTING:</span><br><span class="line">                clearTarget = ClearTarget.TASK;</span><br><span class="line">                reuseTarget = ReuseTarget.DOCUMENT;</span><br><span class="line">                break;</span><br><span class="line">            case ActivityInfo.DOCUMENT_LAUNCH_ALWAYS:</span><br><span class="line">                reuseTarget = ReuseTarget.MULTIPLE;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean singleTop = false;</span><br><span class="line"></span><br><span class="line">    switch (info.launchMode) &#123;</span><br><span class="line">        case LAUNCH_SINGLE_TOP: &#123;</span><br><span class="line">            singleTop = true;</span><br><span class="line">            if (containFlags(intent, Intent.FLAG_ACTIVITY_NEW_TASK)) &#123;</span><br><span class="line">                reuseTarget = containFlags(intent, Intent.FLAG_ACTIVITY_MULTIPLE_TASK)</span><br><span class="line">                        ? ReuseTarget.MULTIPLE</span><br><span class="line">                        : ReuseTarget.AFFINITY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">        case LAUNCH_SINGLE_TASK: &#123;</span><br><span class="line">            clearTop = false;</span><br><span class="line">            clearTarget = ClearTarget.TOP;</span><br><span class="line">            reuseTarget = containFlags(intent, Intent.FLAG_ACTIVITY_MULTIPLE_TASK)</span><br><span class="line">                    ? ReuseTarget.MULTIPLE</span><br><span class="line">                    : ReuseTarget.AFFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">        case LAUNCH_SINGLE_INSTANCE: &#123;</span><br><span class="line">            clearTop = false;</span><br><span class="line">            clearTarget = ClearTarget.TOP;</span><br><span class="line">            reuseTarget = ReuseTarget.AFFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">        default: &#123;</span><br><span class="line">            if (containFlags(intent, Intent.FLAG_ACTIVITY_SINGLE_TOP)) &#123;</span><br><span class="line">                singleTop = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (clearTarget == ClearTarget.NOTHING) &#123;</span><br><span class="line">        if (containFlags(intent, Intent.FLAG_ACTIVITY_REORDER_TO_FRONT)) &#123;</span><br><span class="line">            clearTarget = ClearTarget.SPEC_ACTIVITY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sourceTask == null &amp;&amp; reuseTarget == ReuseTarget.CURRENT) &#123;</span><br><span class="line">        reuseTarget = ReuseTarget.AFFINITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String affinity = ComponentUtils.getTaskAffinity(info);</span><br><span class="line"></span><br><span class="line">    // 根据 Flag 寻找合适的 Task</span><br><span class="line">    TaskRecord reuseTask = null;</span><br><span class="line">    switch (reuseTarget) &#123;</span><br><span class="line">        case AFFINITY:</span><br><span class="line">            reuseTask = findTaskByAffinityLocked(userId, affinity);</span><br><span class="line">            break;</span><br><span class="line">        case DOCUMENT:</span><br><span class="line">            reuseTask = findTaskByIntentLocked(userId, intent);</span><br><span class="line">            break;</span><br><span class="line">        case CURRENT:</span><br><span class="line">            reuseTask = sourceTask;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean taskMarked = false;</span><br><span class="line">    if (reuseTask == null) &#123;</span><br><span class="line">        startActivityInNewTaskLocked(userId, intent, info, options);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        boolean delivered = false;</span><br><span class="line">        mAM.moveTaskToFront(reuseTask.taskId, 0);</span><br><span class="line">        boolean startTaskToFront = !clearTask &amp;&amp; !clearTop &amp;&amp; ComponentUtils.isSameIntent(intent, reuseTask.taskRoot);</span><br><span class="line"></span><br><span class="line">        if (clearTarget.deliverIntent || singleTop) &#123;</span><br><span class="line">            taskMarked = markTaskByClearTarget(reuseTask, clearTarget, intent.getComponent());</span><br><span class="line">            ActivityRecord topRecord = topActivityInTask(reuseTask);</span><br><span class="line">            if (clearTop &amp;&amp; !singleTop &amp;&amp; topRecord != null &amp;&amp; taskMarked) &#123;</span><br><span class="line">                topRecord.marked = true;</span><br><span class="line">            &#125;</span><br><span class="line">            // Target activity is on top</span><br><span class="line">            if (topRecord != null &amp;&amp; !topRecord.marked &amp;&amp; topRecord.component.equals(intent.getComponent())) &#123;</span><br><span class="line">                deliverNewIntentLocked(sourceRecord, topRecord, intent);</span><br><span class="line">                delivered = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (taskMarked) &#123;</span><br><span class="line">            synchronized (mHistory) &#123;</span><br><span class="line">                scheduleFinishMarkedActivityLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!startTaskToFront) &#123;</span><br><span class="line">            if (!delivered) &#123;</span><br><span class="line">                destIntent = startActivityProcess(userId, sourceRecord, intent, info);</span><br><span class="line">                if (destIntent != null) &#123;</span><br><span class="line">                    startActivityFromSourceTask(reuseTask, destIntent, info, resultWho, requestCode, options);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 <code>call</code> 到了 <code>startActivityProcess</code> ，这就是真正替换 <code>Intent</code> 的地方。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用 Host Stub Activity 的 Intent 包装原 Intent 瞒天过海</span><br><span class="line">private Intent startActivityProcess(int userId, ActivityRecord sourceRecord, Intent intent, ActivityInfo info) &#123;</span><br><span class="line">    intent = new Intent(intent);</span><br><span class="line">    // 获得 Activity 对应的 ProcessRecorder，如果没有则表示这是 Process 第一个打开的组件，需要初始化 Application</span><br><span class="line">    ProcessRecord targetApp = mService.startProcessIfNeedLocked(info.processName, userId, info.packageName);</span><br><span class="line">    if (targetApp == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Intent targetIntent = new Intent();</span><br><span class="line"></span><br><span class="line">    // 根据 Client App 的 PID 获取 StubActivity</span><br><span class="line">    String stubActivityPath = fetchStubActivity(targetApp.vpid, info);</span><br><span class="line"></span><br><span class="line">    Log.e(&quot;gy&quot;, &quot;map activity:&quot; + intent.getComponent().getClassName() + &quot; -&gt; &quot; + stubActivityPath);</span><br><span class="line"></span><br><span class="line">    targetIntent.setClassName(VirtualCore.get().getHostPkg(), stubActivityPath);</span><br><span class="line">    ComponentName component = intent.getComponent();</span><br><span class="line">    if (component == null) &#123;</span><br><span class="line">        component = ComponentUtils.toComponentName(info);</span><br><span class="line">    &#125;</span><br><span class="line">    targetIntent.setType(component.flattenToString());</span><br><span class="line">    StubActivityRecord saveInstance = new StubActivityRecord(intent, info,</span><br><span class="line">            sourceRecord != null ? sourceRecord.component : null, userId);</span><br><span class="line">    saveInstance.saveToIntent(targetIntent);</span><br><span class="line">    return targetIntent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fetchStubActivity</code> 会根据相同的进程 <code>id</code> 在 <code>VA</code> 的 <code>Menifest</code> 中找到那个提前占坑的 <code>StubActivity</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取合适的 StubActivity，返回 StubActivity 全限定名</span><br><span class="line">private String fetchStubActivity(int vpid, ActivityInfo targetInfo) &#123;</span><br><span class="line"></span><br><span class="line">    boolean isFloating = false;</span><br><span class="line">    boolean isTranslucent = false;</span><br><span class="line">    boolean showWallpaper = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        int[] R_Styleable_Window = R_Hide.styleable.Window.get();</span><br><span class="line">        int R_Styleable_Window_windowIsTranslucent = R_Hide.styleable.Window_windowIsTranslucent.get();</span><br><span class="line">        int R_Styleable_Window_windowIsFloating = R_Hide.styleable.Window_windowIsFloating.get();</span><br><span class="line">        int R_Styleable_Window_windowShowWallpaper = R_Hide.styleable.Window_windowShowWallpaper.get();</span><br><span class="line"></span><br><span class="line">        AttributeCache.Entry ent = AttributeCache.instance().get(targetInfo.packageName, targetInfo.theme,</span><br><span class="line">                R_Styleable_Window);</span><br><span class="line">        if (ent != null &amp;&amp; ent.array != null) &#123;</span><br><span class="line">            showWallpaper = ent.array.getBoolean(R_Styleable_Window_windowShowWallpaper, false);</span><br><span class="line">            isTranslucent = ent.array.getBoolean(R_Styleable_Window_windowIsTranslucent, false);</span><br><span class="line">            isFloating = ent.array.getBoolean(R_Styleable_Window_windowIsFloating, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean isDialogStyle = isFloating || isTranslucent || showWallpaper;</span><br><span class="line"></span><br><span class="line">    // 根据在 Menifest 中注册的 pid</span><br><span class="line">    if (isDialogStyle) &#123;</span><br><span class="line">        return VASettings.getStubDialogName(vpid);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return VASettings.getStubActivityName(vpid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要特别注意， <code>VA</code> 占坑的方式和 <code>DroidPlugin</code> <code>有些小不同，VA</code> 没有为每个 <code>Process</code> 注册多个 <code>Activity</code> ，也没有为不同的启动方式注册多个 <code>Activity</code> ，这里确实是有改进的。</p>
<p>这里根本原因是因为 <code>VA</code> 对 <code>VAMS</code> 实现的更为完整，实现了原版 <code>AMS</code> 的基本功能，包括完整的 <code>Recorder</code> 管理，<code>Task Stack</code> 管理等，这样的话 <code>StubActivity</code> 的唯一作用便是携带 <code>Client App</code> 真正的 <code>Intent</code> 交给 <code>VAMS</code> 处理。这套机制衍生到其他的组件也是一样的。</p>
<p>可以简单看一下 <code>ActivityStack，</code> 、 <code>ActivityRecorder</code> 、 <code>ActivityRecord</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* package */ class ActivityStack &#123;</span><br><span class="line"></span><br><span class="line">    private final ActivityManager mAM;</span><br><span class="line">    private final VActivityManagerService mService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * [Key] = TaskId [Value] = TaskRecord</span><br><span class="line">     */</span><br><span class="line">    private final SparseArray&lt;TaskRecord&gt; mHistory = new SparseArray&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TaskRecord &#123;</span><br><span class="line">    public final List&lt;ActivityRecord&gt; activities = Collections.synchronizedList(new ArrayList&lt;ActivityRecord&gt;());</span><br><span class="line">    public int taskId;</span><br><span class="line">    public int userId;</span><br><span class="line">    public String affinity;</span><br><span class="line">    public Intent taskRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* package */ class ActivityRecord &#123;</span><br><span class="line">    public TaskRecord task;</span><br><span class="line">    public ComponentName component;</span><br><span class="line">    public ComponentName caller;</span><br><span class="line">    // Client App 中 Activity 的句柄</span><br><span class="line">    public IBinder token;</span><br><span class="line">    public int userId;</span><br><span class="line">    public ProcessRecord process;</span><br><span class="line">    public int launchMode;</span><br><span class="line">    public int flags;</span><br><span class="line">    public boolean marked;</span><br><span class="line">    public String affinity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StubActivityRecorder</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StubActivityRecord  &#123;</span><br><span class="line">        public Intent intent;</span><br><span class="line">        public ActivityInfo info;</span><br><span class="line">        public ComponentName caller;</span><br><span class="line">        public int userId;</span><br><span class="line"></span><br><span class="line">        public StubActivityRecord(Intent intent, ActivityInfo info, ComponentName caller, int userId) &#123;</span><br><span class="line">            this.intent = intent;</span><br><span class="line">            this.info = info;</span><br><span class="line">            this.caller = caller;</span><br><span class="line">            this.userId = userId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取原版 Intent 和一些其他信息</span><br><span class="line">        public StubActivityRecord(Intent stub) &#123;</span><br><span class="line">            this.intent = stub.getParcelableExtra(&quot;_VA_|_intent_&quot;);</span><br><span class="line">            this.info = stub.getParcelableExtra(&quot;_VA_|_info_&quot;);</span><br><span class="line">            this.caller = stub.getParcelableExtra(&quot;_VA_|_caller_&quot;);</span><br><span class="line">            this.userId = stub.getIntExtra(&quot;_VA_|_user_id_&quot;, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    // 将原版 Intent 塞到 Stub Intent</span><br><span class="line">    public void saveToIntent(Intent stub) &#123;</span><br><span class="line">        stub.putExtra(&quot;_VA_|_intent_&quot;, intent);</span><br><span class="line">        stub.putExtra(&quot;_VA_|_info_&quot;, info);</span><br><span class="line">        stub.putExtra(&quot;_VA_|_caller_&quot;, caller);</span><br><span class="line">        stub.putExtra(&quot;_VA_|_user_id_&quot;, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化-Application"><a href="#初始化-Application" class="headerlink" title="初始化 Application"></a>初始化 Application</h2><p>还有一个非常重要的事情，注意到这一行 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获得 Activity 对应的 ProcessRecorder，如果没有则表示这是 Process 第一个打开的组件，需要初始化 Application</span><br><span class="line">ProcessRecord targetApp = mService.startProcessIfNeedLocked(info.processName, userId, info.packageName);</span><br></pre></td></tr></table></figure>
<p>这里会先去找对应 <code>Client App</code> 进程的 <code>ProcessRecorder</code> , 找不到代表 <code>Application</code> 刚启动尚未初始化:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private ProcessRecord performStartProcessLocked(int vuid, int vpid, ApplicationInfo info, String processName) &#123;</span><br><span class="line">    ProcessRecord app = new ProcessRecord(info, processName, vuid, vpid);</span><br><span class="line">    Bundle extras = new Bundle();</span><br><span class="line">    BundleCompat.putBinder(extras, &quot;_VA_|_binder_&quot;, app);</span><br><span class="line">    extras.putInt(&quot;_VA_|_vuid_&quot;, vuid);</span><br><span class="line">    extras.putString(&quot;_VA_|_process_&quot;, processName);</span><br><span class="line">    extras.putString(&quot;_VA_|_pkg_&quot;, info.packageName);</span><br><span class="line"></span><br><span class="line">    // 调用子程序包的 init_process 方法，并且得到子程序包 IBinder 句柄</span><br><span class="line">    Bundle res = ProviderCall.call(VASettings.getStubAuthority(vpid), &quot;_VA_|_init_process_&quot;, null, extras);</span><br><span class="line">    if (res == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int pid = res.getInt(&quot;_VA_|_pid_&quot;);</span><br><span class="line">    IBinder clientBinder = BundleCompat.getBinder(res, &quot;_VA_|_client_&quot;);</span><br><span class="line">    // attach 到 Client 的 VAM</span><br><span class="line">    attachClient(pid, clientBinder);</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ProviderCall.call</code> 向 <code>Client App</code> 的 <code>StubContentProvider</code> 发起远程调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Bundle call(String method, String arg, Bundle extras) &#123;</span><br><span class="line">    if (&quot;_VA_|_init_process_&quot;.equals(method)) &#123;</span><br><span class="line">        return initProcess(extras);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Bundle initProcess(Bundle extras) &#123;</span><br><span class="line">    ConditionVariable lock = VirtualCore.get().getInitLock();</span><br><span class="line">    if (lock != null) &#123;</span><br><span class="line">        lock.block();</span><br><span class="line">    &#125;</span><br><span class="line">    IBinder token = BundleCompat.getBinder(extras,&quot;_VA_|_binder_&quot;);</span><br><span class="line">    int vuid = extras.getInt(&quot;_VA_|_vuid_&quot;);</span><br><span class="line">    VClientImpl client = VClientImpl.get();</span><br><span class="line">    client.initProcess(token, vuid);</span><br><span class="line">    Bundle res = new Bundle();</span><br><span class="line">    BundleCompat.putBinder(res, &quot;_VA_|_client_&quot;, client.asBinder());</span><br><span class="line">    res.putInt(&quot;_VA_|_pid_&quot;, Process.myPid());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Client App</code> 的 <code>IBinder</code> 句柄(<code>VClientImpl.asBinder</code>) 被打包在了 <code>Bundle</code> 中返回给 <code>VAMS</code> 。</p>
<p>最终 <code>VAMS</code> 调用原生 <code>AM</code> 的 <code>startActivity</code> 向真正的 <code>AMS</code> 发送替换成 <code>StubActivity</code> 的伪造 <code>Intent</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mirror.android.app.IActivityManager.startActivity.call(ActivityManagerNative.getDefault.call(), (Object[]) args);</span><br></pre></td></tr></table></figure>

<h2 id="恢复原-Intent-重定向到原-Activity"><a href="#恢复原-Intent-重定向到原-Activity" class="headerlink" title="恢复原 Intent 重定向到原 Activity"></a>恢复原 Intent 重定向到原 Activity</h2><p>当 <code>AMS</code> 收到伪装的 <code>Intent</code> 后，就会找到 <code>StubActivity</code> ，这时流程回到 <code>VA</code> 里的主线程中的消息队列中。</p>
<p><code>Hook</code> 过程就是用我们自己的 <code>Handler</code> 替换 <code>android.os.Handler.mCallback</code> 因为主线程在这里分发一些操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void inject() throws Throwable &#123;</span><br><span class="line">    otherCallback = getHCallback();</span><br><span class="line">    mirror.android.os.Handler.mCallback.set(getH(), this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>handlerMessage</code> 判断是 <code>LAUNCH_ACTIVITY Action</code> 后直接调用了 <code>handlerLaunchActivity</code> 方法，和原版其实很像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private boolean handleLaunchActivity(Message msg) &#123;</span><br><span class="line">    Object r = msg.obj;</span><br><span class="line">    Intent stubIntent = ActivityThread.ActivityClientRecord.intent.get(r);</span><br><span class="line">    // 获取原版 Intent 信息</span><br><span class="line">    StubActivityRecord saveInstance = new StubActivityRecord(stubIntent);</span><br><span class="line">    if (saveInstance.intent == null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 原版 Intent</span><br><span class="line">    Intent intent = saveInstance.intent;</span><br><span class="line">    ComponentName caller = saveInstance.caller;</span><br><span class="line">    IBinder token = ActivityThread.ActivityClientRecord.token.get(r);</span><br><span class="line">    ActivityInfo info = saveInstance.info;</span><br><span class="line"></span><br><span class="line">    // 如果 token 还没初始化，代表 App 刚刚启动第一个组件</span><br><span class="line">    if (VClientImpl.get().getToken() == null) &#123;</span><br><span class="line">        VActivityManager.get().processRestarted(info.packageName, info.processName, saveInstance.userId);</span><br><span class="line">        getH().sendMessageAtFrontOfQueue(Message.obtain(msg));</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // AppBindData 为空，则 App 信息不明</span><br><span class="line">    if (!VClientImpl.get().isBound()) &#123;</span><br><span class="line">        // 初始化并绑定 Application</span><br><span class="line">        VClientImpl.get().bindApplication(info.packageName, info.processName);</span><br><span class="line">        getH().sendMessageAtFrontOfQueue(Message.obtain(msg));</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取 TaskId</span><br><span class="line">    int taskId = IActivityManager.getTaskForActivity.call(</span><br><span class="line">            ActivityManagerNative.getDefault.call(),</span><br><span class="line">            token,</span><br><span class="line">            false</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 1.将 ActivityRecorder 加入 mActivities 2.通知服务端 VAMS Activity 创建完成</span><br><span class="line">    VActivityManager.get().onActivityCreate(ComponentUtils.toComponentName(info), caller, token, info, intent, ComponentUtils.getTaskAffinity(info), taskId, info.launchMode, info.flags);</span><br><span class="line">    ClassLoader appClassLoader = VClientImpl.get().getClassLoader(info.applicationInfo);</span><br><span class="line">    intent.setExtrasClassLoader(appClassLoader);</span><br><span class="line">    // 将 Host Stub Activity Intent 替换为原版 Intent</span><br><span class="line">    ActivityThread.ActivityClientRecord.intent.set(r, intent);</span><br><span class="line">    // 同上</span><br><span class="line">    ActivityThread.ActivityClientRecord.activityInfo.set(r, info);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果这个 <code>Activity</code> 是这个 <code>Apk</code> 启动的第一个组件，则需要 <code>bindApplication</code> 初始化 <code>Application</code> 操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void bindApplicationNoCheck(String packageName, String processName, ConditionVariable lock) &#123;</span><br><span class="line">    mTempLock = lock;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 设置未捕获异常的 Callback</span><br><span class="line">        setupUncaughtHandler();</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 修复 Provider 信息</span><br><span class="line">        fixInstalledProviders();</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    mirror.android.os.Build.SERIAL.set(deviceInfo.serial);</span><br><span class="line">    mirror.android.os.Build.DEVICE.set(Build.DEVICE.replace(&quot; &quot;, &quot;_&quot;));</span><br><span class="line">    ActivityThread.mInitialApplication.set(</span><br><span class="line">            VirtualCore.mainThread(),</span><br><span class="line">            null</span><br><span class="line">    );</span><br><span class="line">    // 从 VPMS 获取 apk 信息</span><br><span class="line">    AppBindData data = new AppBindData();</span><br><span class="line">    InstalledAppInfo info = VirtualCore.get().getInstalledAppInfo(packageName, 0);</span><br><span class="line">    if (info == null) &#123;</span><br><span class="line">        new Exception(&quot;App not exist!&quot;).printStackTrace();</span><br><span class="line">        Process.killProcess(0);</span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    // dex 优化的开关，dalvik 和 art 处理不同</span><br><span class="line">    if (!info.dependSystem &amp;&amp; info.skipDexOpt) &#123;</span><br><span class="line">        VLog.d(TAG, &quot;Dex opt skipped.&quot;);</span><br><span class="line">        if (VirtualRuntime.isArt()) &#123;</span><br><span class="line">            ARTUtils.init(VirtualCore.get().getContext());</span><br><span class="line">            ARTUtils.setIsDex2oatEnabled(false);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            DalvikUtils.init();</span><br><span class="line">            DalvikUtils.setDexOptMode(DalvikUtils.OPTIMIZE_MODE_NONE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    data.appInfo = VPackageManager.get().getApplicationInfo(packageName, 0, getUserId(vuid));</span><br><span class="line">    data.processName = processName;</span><br><span class="line">    data.providers = VPackageManager.get().queryContentProviders(processName, getVUid(), PackageManager.GET_META_DATA);</span><br><span class="line">    Log.i(TAG, &quot;Binding application &quot; + data.appInfo.packageName + &quot; (&quot; + data.processName + &quot;)&quot;);</span><br><span class="line">    mBoundApplication = data;</span><br><span class="line">    // 主要设置进程的名字</span><br><span class="line">    VirtualRuntime.setupRuntime(data.processName, data.appInfo);</span><br><span class="line">    int targetSdkVersion = data.appInfo.targetSdkVersion;</span><br><span class="line">    if (targetSdkVersion &lt; Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">        StrictMode.ThreadPolicy newPolicy = new StrictMode.ThreadPolicy.Builder(StrictMode.getThreadPolicy()).permitNetwork().build();</span><br><span class="line">        StrictMode.setThreadPolicy(newPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        if (mirror.android.os.StrictMode.sVmPolicyMask != null) &#123;</span><br><span class="line">            mirror.android.os.StrictMode.sVmPolicyMask.set(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP &amp;&amp; targetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        mirror.android.os.Message.updateCheckRecycle.call(targetSdkVersion);</span><br><span class="line">    &#125;</span><br><span class="line">    if (VASettings.ENABLE_IO_REDIRECT) &#123;</span><br><span class="line">        // IO 重定向</span><br><span class="line">        startIOUniformer();</span><br><span class="line">    &#125;</span><br><span class="line">    // hook native 函数</span><br><span class="line">    NativeEngine.hookNative();</span><br><span class="line">    Object mainThread = VirtualCore.mainThread();</span><br><span class="line">    // 准备 dex 列表</span><br><span class="line">    NativeEngine.startDexOverride();</span><br><span class="line">    // 获得子 pkg 的 Context 前提是必须在系统中安装的（疑问？）</span><br><span class="line">    Context context = createPackageContext(data.appInfo.packageName);</span><br><span class="line">    // 设置虚拟机系统环境 临时文件夹 codeCacheDir</span><br><span class="line">    System.setProperty(&quot;java.io.tmpdir&quot;, context.getCacheDir().getAbsolutePath());</span><br><span class="line">    // oat 的 cache 目录</span><br><span class="line">    File codeCacheDir;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">        codeCacheDir = context.getCodeCacheDir();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        codeCacheDir = context.getCacheDir();</span><br><span class="line">    &#125;</span><br><span class="line">    // 硬件加速的 cache 目录</span><br><span class="line">    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.N) &#123;</span><br><span class="line">        if (HardwareRenderer.setupDiskCache != null) &#123;</span><br><span class="line">            HardwareRenderer.setupDiskCache.call(codeCacheDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (ThreadedRenderer.setupDiskCache != null) &#123;</span><br><span class="line">            ThreadedRenderer.setupDiskCache.call(codeCacheDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">        if (RenderScriptCacheDir.setupDiskCache != null) &#123;</span><br><span class="line">            RenderScriptCacheDir.setupDiskCache.call(codeCacheDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;</span><br><span class="line">        if (RenderScript.setupDiskCache != null) &#123;</span><br><span class="line">            RenderScript.setupDiskCache.call(codeCacheDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修复子 App 中 ActivityThread.AppBinderData 的参数，因为之前用的是在 Host 程序中注册的 Stub 的信息</span><br><span class="line">    Object boundApp = fixBoundApp(mBoundApplication);</span><br><span class="line">    mBoundApplication.info = ContextImpl.mPackageInfo.get(context);</span><br><span class="line">    mirror.android.app.ActivityThread.AppBindData.info.set(boundApp, data.info);</span><br><span class="line"></span><br><span class="line">    // 同样修复 targetSdkVersion 原来也是可 Host 程序一样的</span><br><span class="line">    VMRuntime.setTargetSdkVersion.call(VMRuntime.getRuntime.call(), data.appInfo.targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    boolean conflict = SpecialComponentList.isConflictingInstrumentation(packageName);</span><br><span class="line">    if (!conflict) &#123;</span><br><span class="line">        InvocationStubManager.getInstance().checkEnv(AppInstrumentation.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 开始构建子程序包的 Application 对象，并且替换原来通过 Host Stub 生成的 mInitialApplication</span><br><span class="line">    mInitialApplication = LoadedApk.makeApplication.call(data.info, false, null);</span><br><span class="line">    mirror.android.app.ActivityThread.mInitialApplication.set(mainThread, mInitialApplication);</span><br><span class="line">    ContextFixer.fixContext(mInitialApplication);</span><br><span class="line">    if (data.providers != null) &#123;</span><br><span class="line">        // 注册 Providers</span><br><span class="line">        installContentProviders(mInitialApplication, data.providers);</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化锁开，异步调用的初始化函数可以返回了</span><br><span class="line">    if (lock != null) &#123;</span><br><span class="line">        lock.open();</span><br><span class="line">        mTempLock = null;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 调用 Application.onCreate</span><br><span class="line">        mInstrumentation.callApplicationOnCreate(mInitialApplication);</span><br><span class="line">        InvocationStubManager.getInstance().checkEnv(HCallbackStub.class);</span><br><span class="line">        if (conflict) &#123;</span><br><span class="line">            InvocationStubManager.getInstance().checkEnv(AppInstrumentation.class);</span><br><span class="line">        &#125;</span><br><span class="line">        Application createdApp = ActivityThread.mInitialApplication.get(mainThread);</span><br><span class="line">        if (createdApp != null) &#123;</span><br><span class="line">            mInitialApplication = createdApp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(mInitialApplication, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to create application &quot; + mInitialApplication.getClass().getName()</span><br><span class="line">                            + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    VActivityManager.get().appDoneExecuting();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setupUncaughtHandler() &#123;</span><br><span class="line">    ThreadGroup root = Thread.currentThread().getThreadGroup();</span><br><span class="line">    while (root.getParent() != null) &#123;</span><br><span class="line">        root = root.getParent();</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadGroup newRoot = new RootThreadGroup(root);</span><br><span class="line">    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.N) &#123;</span><br><span class="line">        final List&lt;ThreadGroup&gt; groups = mirror.java.lang.ThreadGroup.groups.get(root);</span><br><span class="line">        //noinspection SynchronizationOnLocalVariableOrMethodParameter</span><br><span class="line">        synchronized (groups) &#123;</span><br><span class="line">            List&lt;ThreadGroup&gt; newGroups = new ArrayList&lt;&gt;(groups);</span><br><span class="line">            newGroups.remove(newRoot);</span><br><span class="line">            mirror.java.lang.ThreadGroup.groups.set(newRoot, newGroups);</span><br><span class="line">            groups.clear();</span><br><span class="line">            groups.add(newRoot);</span><br><span class="line">            mirror.java.lang.ThreadGroup.groups.set(root, groups);</span><br><span class="line">            for (ThreadGroup group : newGroups) &#123;</span><br><span class="line">                mirror.java.lang.ThreadGroup.parent.set(group, newRoot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final ThreadGroup[] groups = ThreadGroupN.groups.get(root);</span><br><span class="line">        //noinspection SynchronizationOnLocalVariableOrMethodParameter</span><br><span class="line">        synchronized (groups) &#123;</span><br><span class="line">            ThreadGroup[] newGroups = groups.clone();</span><br><span class="line">            ThreadGroupN.groups.set(newRoot, newGroups);</span><br><span class="line">            ThreadGroupN.groups.set(root, new ThreadGroup[]&#123;newRoot&#125;);</span><br><span class="line">            for (Object group : newGroups) &#123;</span><br><span class="line">                ThreadGroupN.parent.set(group, newRoot);</span><br><span class="line">            &#125;</span><br><span class="line">            ThreadGroupN.ngroups.set(root, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bindApplication</code> 主要做了以下几个事情：</p>
<ol>
<li>从 <code>VPMS</code> 获取 <code>APK</code> 的信息，根据设置控制 <code>Dex</code> 优化的开关。</li>
<li>调用 <code>mirror.android.os.Process.setArgV0.call(processName);</code> 设置进程的名称，如果不设置则还是 <code>p0 p1</code> 这样。</li>
<li>做 <code>nativeHook</code> 主要 <code>Hook</code> 一些 <code>native</code> 的函数，主要是一些 <code>IO</code> 函数，包括文件访问重定向等等。</li>
<li>准备一些 <code>cache</code> 临时文件夹。</li>
<li>设置 <code>AppBinderData</code> ， <code>AppBinderData</code> 内部包含了 <code>ApplicationInfo</code> 和 <code>provider</code> 信息等重要的 <code>apk</code> 信息。可以理解为 <code>framework</code> 所需要的关键数据结构。</li>
<li>安装 <code>ContentProvider</code> 。</li>
<li>初始化用户的 <code>Application</code> 对象，并通过 <code>Instrumentation</code> 调用其 <code>onCreate</code> ，代表着 <code>Client App</code> 的生命周期正式开始。</li>
</ol>
<p>最后成功从 <code>StubActivity Intent</code> 还原出来的原版 <code>Intent</code> 被继续交给原生的 <code>AM</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将 Host Stub Activity Intent 替换为原版 Intent</span><br><span class="line">ActivityThread.ActivityClientRecord.intent.set(r, intent);</span><br><span class="line">// 同上</span><br><span class="line">ActivityThread.ActivityClientRecord.activityInfo.set(r, info);</span><br></pre></td></tr></table></figure>

<p>最后，最后一个 <code>Hook</code> 点在 <code>Instrumentation.callActivityOnCreate</code> 。</p>
<p>因为 <code>AMS</code> 实际上启动的是 <code>StubActivity</code> 的关系，真正的 <code>Activity</code> 的一些信息还不是其真正的信息，比如主题之类的，所以需要在这个时机修复一下，选择这个时间修复的原因也是因为 <code>Activity</code> 已经被 <code>new</code> 出来了，而且资源已经准备完毕。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;</span><br><span class="line">    VirtualCore.get().getComponentDelegate().beforeActivityCreate(activity);</span><br><span class="line">    IBinder token = mirror.android.app.Activity.mToken.get(activity);</span><br><span class="line">    ActivityClientRecord r = VActivityManager.get().getActivityRecord(token);</span><br><span class="line">    // 替换 Activity 对象</span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        r.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    ContextFixer.fixContext(activity);</span><br><span class="line">    ActivityFixer.fixActivity(activity);</span><br><span class="line">    ActivityInfo info = null;</span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        info = r.info;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置主题和屏幕纵横控制</span><br><span class="line">    if (info != null) &#123;</span><br><span class="line">        if (info.theme != 0) &#123;</span><br><span class="line">            activity.setTheme(info.theme);</span><br><span class="line">        &#125;</span><br><span class="line">        if (activity.getRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED</span><br><span class="line">                &amp;&amp; info.screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) &#123;</span><br><span class="line">            activity.setRequestedOrientation(info.screenOrientation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    super.callActivityOnCreate(activity, icicle);</span><br><span class="line">    VirtualCore.get().getComponentDelegate().afterActivityCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一章介绍 <code>Service</code> 的代理。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>VirtualApp</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 双开沙箱 VirtualApp 源码分析（二）</title>
    <url>/2020/08/08/Android-%E5%8F%8C%E5%BC%80%E6%B2%99%E7%AE%B1-VirtualApp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>转载 : <a href="https://blog.csdn.net/ganyao939543405/article/details/76150725">https://blog.csdn.net/ganyao939543405/article/details/76150725</a></p>
</blockquote>
<h1 id="VA-初始化"><a href="#VA-初始化" class="headerlink" title="VA 初始化"></a>VA 初始化</h1><h2 id="VirtualCore-startup"><a href="#VirtualCore-startup" class="headerlink" title="VirtualCore.startup"></a>VirtualCore.startup</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void startup(Context context) throws Throwable &#123;</span><br><span class="line">    if (!isStartUp) &#123;</span><br><span class="line">        // 确保 MainThread</span><br><span class="line">        if (Looper.myLooper() != Looper.getMainLooper()) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;VirtualCore.startup() must called in main thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        VASettings.STUB_CP_AUTHORITY = context.getPackageName() + &quot;.&quot; + VASettings.STUB_DEF_AUTHORITY;</span><br><span class="line">        ServiceManagerNative.SERVICE_CP_AUTH = context.getPackageName() + &quot;.&quot; + ServiceManagerNative.SERVICE_DEF_AUTH;</span><br><span class="line">        this.context = context;</span><br><span class="line">        // 获取 ActivityThread 实例</span><br><span class="line">        mainThread = ActivityThread.currentActivityThread.call();</span><br><span class="line">        unHookPackageManager = context.getPackageManager();</span><br><span class="line">        hostPkgInfo = unHookPackageManager.getPackageInfo(context.getPackageName(), PackageManager.GET_PROVIDERS);</span><br><span class="line">        detectProcessType();</span><br><span class="line">        // hook 系统类</span><br><span class="line">        InvocationStubManager invocationStubManager = InvocationStubManager.getInstance();</span><br><span class="line">        invocationStubManager.init();</span><br><span class="line">        invocationStubManager.injectAll();</span><br><span class="line">        // 修复权限管理</span><br><span class="line">        ContextFixer.fixContext(context);</span><br><span class="line">        isStartUp = true;</span><br><span class="line">        if (initLock != null) &#123;</span><br><span class="line">            initLock.open();</span><br><span class="line">            initLock = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个 <code>VA</code> 会运行在四种进程, 分别是前面提到的 <code>VAService</code> 进程、<code>Client App</code> 进程、 <code>VA</code> 自身的 App 主进程、子进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Process type</span><br><span class="line">    */</span><br><span class="line">private enum ProcessType &#123;</span><br><span class="line">    /**</span><br><span class="line">        * Server process</span><br><span class="line">        */</span><br><span class="line">    Server,</span><br><span class="line">    /**</span><br><span class="line">        * Virtual app process</span><br><span class="line">        */</span><br><span class="line">    VAppClient,</span><br><span class="line">    /**</span><br><span class="line">        * Main process</span><br><span class="line">        */</span><br><span class="line">    Main,</span><br><span class="line">    /**</span><br><span class="line">        * Child process</span><br><span class="line">        */</span><br><span class="line">    CHILD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话， <code>Application</code> 就会被初始化多次，所以要在初始化的时候根据进程类型有选择的做对应的初始化工作。</p>
<h2 id="InvocationStubManager-injectInternal"><a href="#InvocationStubManager-injectInternal" class="headerlink" title="InvocationStubManager.injectInternal"></a>InvocationStubManager.injectInternal</h2><p>主要完成对 <code>Java</code> 层 <code>framework</code> 的 <code>Hook</code> ，将其定位到 <code>VA</code> 伪造 <code>VA framework</code> 上去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void injectInternal() throws Throwable &#123;</span><br><span class="line">    // VA 自身的 App 进程不需要 Hook</span><br><span class="line">    if (VirtualCore.get().isMainProcess()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // VAService 需要 Hook AMS 和 PMS</span><br><span class="line">    if (VirtualCore.get().isServerProcess()) &#123;</span><br><span class="line">        addInjector(new ActivityManagerStub());</span><br><span class="line">        addInjector(new PackageManagerStub());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // Client APP 需要 Hook 整个 framework，来使其调用到 VA framework</span><br><span class="line">    if (VirtualCore.get().isVAppProcess()) &#123;</span><br><span class="line">        addInjector(new LibCoreStub());</span><br><span class="line">        addInjector(new ActivityManagerStub());</span><br><span class="line">        addInjector(new PackageManagerStub());</span><br><span class="line">        addInjector(HCallbackStub.getDefault());</span><br><span class="line">        addInjector(new ISmsStub());</span><br><span class="line">        addInjector(new ISubStub());</span><br><span class="line">        addInjector(new DropBoxManagerStub());</span><br><span class="line">        addInjector(new NotificationManagerStub());</span><br><span class="line">        addInjector(new LocationManagerStub());</span><br><span class="line">        addInjector(new WindowManagerStub());</span><br><span class="line">        addInjector(new ClipBoardStub());</span><br><span class="line">        addInjector(new MountServiceStub());</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p><code>VA</code> 初始化主要就是这些。</p>
<h1 id="Client-App-的安装"><a href="#Client-App-的安装" class="headerlink" title="Client App 的安装"></a>Client App 的安装</h1><h2 id="VirtualCore-installPackage"><a href="#VirtualCore-installPackage" class="headerlink" title="VirtualCore.installPackage"></a>VirtualCore.installPackage</h2><p>首先调用远程 <code>VAService</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public InstallResult installPackage(String apkPath, int flags) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 调用远程 VAService</span><br><span class="line">        return getService().installPackage(apkPath, flags);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        return VirtualRuntime.crash(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用 <code>VAServcie</code> 中的 <code>VAppManagerService.installPackage()</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 安装 apk 先于 installPackageAsUser，主要目的是生成 VPackage 结构</span><br><span class="line">public synchronized InstallResult installPackage(String path, int flags, boolean notify) &#123;</span><br><span class="line">    long installTime = System.currentTimeMillis();</span><br><span class="line">    if (path == null) &#123;</span><br><span class="line">        return InstallResult.makeFailure(&quot;path = NULL&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否 OPT 优化(dex -&gt; binary)</span><br><span class="line">    boolean skipDexOpt = (flags &amp; InstallStrategy.SKIP_DEX_OPT) != 0;</span><br><span class="line">    // apk path</span><br><span class="line">    File packageFile = new File(path);</span><br><span class="line">    if (!packageFile.exists() || !packageFile.isFile()) &#123;</span><br><span class="line">        return InstallResult.makeFailure(&quot;Package File is not exist.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    VPackage pkg = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 进入解析包结构，该结构是可序列化的，为了持久化在磁盘上</span><br><span class="line">        pkg = PackageParserEx.parsePackage(packageFile);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    if (pkg == null || pkg.packageName == null) &#123;</span><br><span class="line">        return InstallResult.makeFailure(&quot;Unable to parse the package.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    InstallResult res = new InstallResult();</span><br><span class="line">    res.packageName = pkg.packageName;</span><br><span class="line">    // PackageCache holds all packages, try to check if we need to update.</span><br><span class="line">    VPackage existOne = PackageCacheManager.get(pkg.packageName);</span><br><span class="line">    PackageSetting existSetting = existOne != null ? (PackageSetting) existOne.mExtras : null;</span><br><span class="line">    if (existOne != null) &#123;</span><br><span class="line">        if ((flags &amp; InstallStrategy.IGNORE_NEW_VERSION) != 0) &#123;</span><br><span class="line">            res.isUpdate = true;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!canUpdate(existOne, pkg, flags)) &#123;</span><br><span class="line">            return InstallResult.makeFailure(&quot;Not allowed to update the package.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.isUpdate = true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获得 app 安装文件夹</span><br><span class="line">    File appDir = VEnvironment.getDataAppPackageDirectory(pkg.packageName);</span><br><span class="line">    // so 文件夹</span><br><span class="line">    File libDir = new File(appDir, &quot;lib&quot;);</span><br><span class="line">    if (res.isUpdate) &#123;</span><br><span class="line">        FileUtils.deleteDir(libDir);</span><br><span class="line">        VEnvironment.getOdexFile(pkg.packageName).delete();</span><br><span class="line">        VActivityManagerService.get().killAppByPkg(pkg.packageName, VUserHandle.USER_ALL);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!libDir.exists() &amp;&amp; !libDir.mkdirs()) &#123;</span><br><span class="line">        return InstallResult.makeFailure(&quot;Unable to create lib dir.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 是否基于系统的 apk 加载，前提是安装过的 apk 并且 dependSystem 开关打开</span><br><span class="line">    boolean dependSystem = (flags &amp; InstallStrategy.DEPEND_SYSTEM_IF_EXIST) != 0</span><br><span class="line">            &amp;&amp; VirtualCore.get().isOutsideInstalled(pkg.packageName);</span><br><span class="line"></span><br><span class="line">    if (existSetting != null &amp;&amp; existSetting.dependSystem) &#123;</span><br><span class="line">        dependSystem = false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 复制 so 到 sandbox lib</span><br><span class="line">    NativeLibraryHelperCompat.copyNativeBinaries(new File(path), libDir);</span><br><span class="line"></span><br><span class="line">    // 如果不基于系统，一些必要的拷贝工作</span><br><span class="line">    if (!dependSystem) &#123;</span><br><span class="line">        File privatePackageFile = new File(appDir, &quot;base.apk&quot;);</span><br><span class="line">        File parentFolder = privatePackageFile.getParentFile();</span><br><span class="line">        if (!parentFolder.exists() &amp;&amp; !parentFolder.mkdirs()) &#123;</span><br><span class="line">            VLog.w(TAG, &quot;Warning: unable to create folder : &quot; + privatePackageFile.getPath());</span><br><span class="line">        &#125; else if (privatePackageFile.exists() &amp;&amp; !privatePackageFile.delete()) &#123;</span><br><span class="line">            VLog.w(TAG, &quot;Warning: unable to delete file : &quot; + privatePackageFile.getPath());</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            FileUtils.copyFile(packageFile, privatePackageFile);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            privatePackageFile.delete();</span><br><span class="line">            return InstallResult.makeFailure(&quot;Unable to copy the package file.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        packageFile = privatePackageFile;</span><br><span class="line">    &#125;</span><br><span class="line">    if (existOne != null) &#123;</span><br><span class="line">        PackageCacheManager.remove(pkg.packageName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 给上可执行权限，5.0 之后在 SD 卡上执行 bin 需要可执行权限</span><br><span class="line">    chmodPackageDictionary(packageFile);</span><br><span class="line"></span><br><span class="line">    // PackageSetting 的一些配置，后面会序列化在磁盘上</span><br><span class="line">    PackageSetting ps;</span><br><span class="line">    if (existSetting != null) &#123;</span><br><span class="line">        ps = existSetting;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ps = new PackageSetting();</span><br><span class="line">    &#125;</span><br><span class="line">    ps.skipDexOpt = skipDexOpt;</span><br><span class="line">    ps.dependSystem = dependSystem;</span><br><span class="line">    ps.apkPath = packageFile.getPath();</span><br><span class="line">    ps.libPath = libDir.getPath();</span><br><span class="line">    ps.packageName = pkg.packageName;</span><br><span class="line">    ps.appId = VUserHandle.getAppId(mUidSystem.getOrCreateUid(pkg));</span><br><span class="line">    if (res.isUpdate) &#123;</span><br><span class="line">        ps.lastUpdateTime = installTime;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ps.firstInstallTime = installTime;</span><br><span class="line">        ps.lastUpdateTime = installTime;</span><br><span class="line">        for (int userId : VUserManagerService.get().getUserIds()) &#123;</span><br><span class="line">            boolean installed = userId == 0;</span><br><span class="line">            ps.setUserState(userId, false/*launched*/, false/*hidden*/, installed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //保存 VPackage Cache 到 Disk</span><br><span class="line">    PackageParserEx.savePackageCache(pkg);</span><br><span class="line">    //保存到 RamCache</span><br><span class="line">    PackageCacheManager.put(pkg, ps);</span><br><span class="line">    mPersistenceLayer.save();</span><br><span class="line">    BroadcastSystem.get().startApp(pkg);</span><br><span class="line">    //发送通知 安装完成</span><br><span class="line">    if (notify) &#123;</span><br><span class="line">        notifyAppInstalled(ps, -1);</span><br><span class="line">    &#125;</span><br><span class="line">    res.isSuccess = true;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>APK 的安装主要完成以下几件事情:</p>
<ol>
<li>解析 <code>menifest</code> 拿到 <code>apk</code> 内部信息，包括组件信息，权限信息等。并将这些信息序列化到磁盘和内存中，以备打开时调用。</li>
<li>准备 <code>App</code> 在 <code>VA</code> 沙箱环境中的私有空间，并且复制一些必要的 <code>apk</code> 和 <code>so libs</code>。</li>
<li>最后通知前台安装完成。</li>
</ol>
<h2 id="PackageParserEx-parsePackage"><a href="#PackageParserEx-parsePackage" class="headerlink" title="PackageParserEx.parsePackage"></a>PackageParserEx.parsePackage</h2><p>解析 <code>apk menifest</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 解析包结构</span><br><span class="line">public static VPackage parsePackage(File packageFile) throws Throwable &#123;</span><br><span class="line">    PackageParser parser = PackageParserCompat.createParser(packageFile);</span><br><span class="line">    // 调用对应系统版本的 parsePackage 方法</span><br><span class="line">    PackageParser.Package p = PackageParserCompat.parsePackage(parser, packageFile, 0);</span><br><span class="line">    // 包含此信息代表其是 debug 签名或者其他签名</span><br><span class="line">    if (p.requestedPermissions.contains(&quot;android.permission.FAKE_PACKAGE_SIGNATURE&quot;)</span><br><span class="line">            &amp;&amp; p.mAppMetaData != null</span><br><span class="line">            &amp;&amp; p.mAppMetaData.containsKey(&quot;fake-signature&quot;)) &#123;</span><br><span class="line">        String sig = p.mAppMetaData.getString(&quot;fake-signature&quot;);</span><br><span class="line">        p.mSignatures = new Signature[]&#123;new Signature(sig)&#125;;</span><br><span class="line">        VLog.d(TAG, &quot;Using fake-signature feature on : &quot; + p.packageName);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 验证签名</span><br><span class="line">        PackageParserCompat.collectCertificates(parser, p, PackageParser.PARSE_IS_SYSTEM);</span><br><span class="line">    &#125;</span><br><span class="line">    // 转换成可以序列化在磁盘上的 Cache</span><br><span class="line">    return buildPackageCache(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里解析 <code>Menifest</code> 的方法其实是调用了 <code>framework</code> 隐藏方法 <code>android.content.pm.PackageParser.parsePackage</code> 来实现的，这个方法返回 <code>android.content.pm.Package</code> 结构，这个类型也是隐藏的，怎么办？可以从 <code>sdk</code> 中复制这个类到自己的项目中欺骗编译器。这就是上一章一开始提到的。</p>
<p>这里还有一个问题，就是 <code>Package</code> 类是不可序列化的，换句话说就是不能直接保存在磁盘上，我们需要将其转换成可以序列化的 <code>VPackage</code> 类型，这就是 <code>buildPackageCache()</code> 的作用。</p>
<h2 id="VPackage"><a href="#VPackage" class="headerlink" title="VPackage"></a>VPackage</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class VPackage implements Parcelable &#123;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;VPackage&gt; CREATOR = new Creator&lt;VPackage&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public VPackage createFromParcel(Parcel source) &#123;</span><br><span class="line">            return new VPackage(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public VPackage[] newArray(int size) &#123;</span><br><span class="line">            return new VPackage[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    public ArrayList&lt;ActivityComponent&gt; activities;</span><br><span class="line">    public ArrayList&lt;ActivityComponent&gt; receivers;</span><br><span class="line">    public ArrayList&lt;ProviderComponent&gt; providers;</span><br><span class="line">    public ArrayList&lt;ServiceComponent&gt; services;</span><br><span class="line">    public ArrayList&lt;InstrumentationComponent&gt; instrumentation;</span><br><span class="line">    public ArrayList&lt;PermissionComponent&gt; permissions;</span><br><span class="line">    public ArrayList&lt;PermissionGroupComponent&gt; permissionGroups;</span><br><span class="line">    public ArrayList&lt;String&gt; requestedPermissions;</span><br><span class="line">    public ArrayList&lt;String&gt; protectedBroadcasts;</span><br><span class="line">    public ApplicationInfo applicationInfo;</span><br><span class="line">    public Signature[] mSignatures;</span><br><span class="line">    public Bundle mAppMetaData;</span><br><span class="line">    public String packageName;</span><br><span class="line">    public int mPreferredOrder;</span><br><span class="line">    public String mVersionName;</span><br><span class="line">    public String mSharedUserId;</span><br><span class="line">    public ArrayList&lt;String&gt; usesLibraries;</span><br><span class="line">    public int mVersionCode;</span><br><span class="line">    public int mSharedUserLabel;</span><br><span class="line">    // Applications hardware preferences</span><br><span class="line">    public ArrayList&lt;ConfigurationInfo&gt; configPreferences = null;</span><br><span class="line">    // Applications requested features</span><br><span class="line">    public ArrayList&lt;FeatureInfo&gt; reqFeatures = null;</span><br><span class="line">    public Object mExtras;</span><br><span class="line"></span><br><span class="line">    public VPackage() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>VPackage</code> 几乎保存了 <code>apk</code> 中所有的关键信息，尤其是组件的数据结构会在 <code>app</code> 在 <code>VA</code> 中运行的时候给 <code>VAMS</code> 、 <code>VPMS</code> 这些 <code>VAService</code> 提供 <code>apk</code> 的组件信息。</p>
<p>关于是否 <code>dependSystem</code> 和 <code>isInstallOutside</code> ，这个有关 <code>apk</code> 的动态加载，如果 <code>dependSysytem</code> 并且 <code>apk</code> 已经在外部环境安装了，那么 <code>VA</code> 会调用系统提供的 <code>API</code> 就可以动态加载 <code>APK</code> 。反之 <code>VA</code> 需要做一些必要的复制工作然后再费劲的去加载 <code>APK</code> 。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>VirtualApp</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidStudio环境配置</title>
    <url>/2022/05/30/AndroidStudio%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Android-Studio-修改-android-gradle-AndroidStudio-文件夹位置"><a href="#Android-Studio-修改-android-gradle-AndroidStudio-文件夹位置" class="headerlink" title="Android Studio 修改 .android .gradle .AndroidStudio 文件夹位置"></a>Android Studio 修改 <code>.android</code> <code>.gradle</code> <code>.AndroidStudio</code> 文件夹位置</h1><h2 id="android-文件夹的修改"><a href="#android-文件夹的修改" class="headerlink" title=".android 文件夹的修改"></a><code>.android</code> 文件夹的修改</h2><p>首先，需要添加一个系统的环境变量 <code>ANDROID_SDK_HOME</code> 模拟器环境变量</p>
<p>默认情况下，模拟器会将配置文件存储在 <code>$HOME/.android/</code> 下，将 AVD 数据存储在 <code>$HOME/.android/avd/</code> 下。您可以通过设置以下环境变量来替换默认设置。</p>
<table>
<thead>
<tr>
<th>ANDROID_EMULATOR_HOME</th>
<th>设置特定于用户的模拟器配置目录的路径。默认位置是 <code>$ANDROID_SDK_HOME/.android/</code>。</th>
</tr>
</thead>
<tbody><tr>
<td>ANDROID_AVD_HOME</td>
<td>设置包含所有 AVD 特定文件的目录的路径，这些文件大多由非常大的磁盘映像组成。默认位置是 <code>$ANDROID_EMULATOR_HOME/avd/</code>。如果默认位置的磁盘空间不足，您可能需要指定新位置。</td>
</tr>
</tbody></table>
<h2 id="Gradle-文件夹的修改"><a href="#Gradle-文件夹的修改" class="headerlink" title=".Gradle 文件夹的修改"></a><code>.Gradle</code> 文件夹的修改</h2><p>首先，需要添加一个系统的环境变量 <code>GRADLE_USER_HOME</code> ，然后进入 <code>Android Studio -&gt; File -&gt; Settings -&gt; Gradle</code> 设置好路径即可。</p>
<h2 id="AndroidStudio文件夹的修改"><a href="#AndroidStudio文件夹的修改" class="headerlink" title=".AndroidStudio文件夹的修改"></a><code>.AndroidStudio</code>文件夹的修改</h2><p>进入 Android Studio 的安装目录，进入 bin 文件夹，用文本编辑软件打开 <code>idea.properties</code>，去掉以下两项的注释符号 #，修改对应的路径为新路径即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># idea.config.path=$&#123;user.home&#125;/.AndroidStudio/config</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># idea.system.path=$&#123;user.home&#125;/.AndroidStudio/system</span></span><br></pre></td></tr></table></figure>

<p>参考：<br><a href="https://juejin.cn/post/6967215049446260772">https://juejin.cn/post/6967215049446260772</a></p>
<p><a href="https://developer.android.com/studio/command-line/variables?hl=zh-cn">https://developer.android.com/studio/command-line/variables?hl=zh-cn</a></p>
<p><a href="https://docs.gradle.org/current/userguide/build_environment.html">https://docs.gradle.org/current/userguide/build_environment.html</a></p>
<h1 id="Android-Studio-Build-Output-控制台输出乱码解决"><a href="#Android-Studio-Build-Output-控制台输出乱码解决" class="headerlink" title="Android Studio Build Output 控制台输出乱码解决"></a>Android Studio Build Output 控制台输出乱码解决</h1><p>点击 Android Studio 菜单栏 Help 下拉菜单找到 <code>Edit Custom VM Options...</code>选项。</p>
<p>打开 <code>studio64.exe.vmoptions </code>文件，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure>
<p>关闭 studio，重新打开即可。</p>
<h1 id="设置-Terminal-为cmder"><a href="#设置-Terminal-为cmder" class="headerlink" title="设置 Terminal 为cmder"></a>设置 Terminal 为cmder</h1><p>打开 android studio 的设置，找到 Tools 下的 terminal 修改 Shell path 为 <code>&quot;cmd&quot; /k &quot;&quot;%CMDER_ROOT%\vendor\init.bat&quot;&quot;</code> 。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title>Android对抗手法收集</title>
    <url>/2020/08/24/Android%E5%AF%B9%E6%8A%97%E6%89%8B%E6%B3%95%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="检测ROOT"><a href="#检测ROOT" class="headerlink" title="检测ROOT"></a>检测ROOT</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sbin/su</span><br><span class="line">/system/bin/su</span><br><span class="line">/system/xbin/su</span><br><span class="line">/data/local/xbin/su</span><br><span class="line">/data/local/bin/su</span><br><span class="line">/system/sd/xbin/su</span><br><span class="line">/system/bin/failsafe/su</span><br><span class="line">/data/local/su</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/lamster2018/EasyProtector">https://github.com/lamster2018/EasyProtector</a><br><a href="https://www.coolapk.com/apk/io.github.vvb2060.mahoshojo">https://www.coolapk.com/apk/io.github.vvb2060.mahoshojo</a></p>
<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.net.NetworkInterface.getName()</span><br></pre></td></tr></table></figure>

<h1 id="Xposed"><a href="#Xposed" class="headerlink" title="Xposed"></a>Xposed</h1><p><a href="https://github.com/w568w/XposedDetectLib">https://github.com/w568w/XposedDetectLib</a></p>
<p><a href="https://github.com/KagurazakaHanabi/XposedHider">https://github.com/KagurazakaHanabi/XposedHider</a></p>
<p><a href="https://github.com/vvb2060/XposedDetector">https://github.com/vvb2060/XposedDetector</a></p>
<h1 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h1><p><a href="https://github.com/darvincisec/DetectFrida">https://github.com/darvincisec/DetectFrida</a></p>
<h1 id="Magisk"><a href="#Magisk" class="headerlink" title="Magisk"></a>Magisk</h1><p><a href="https://github.com/vvb2060/MagiskDetector">https://github.com/vvb2060/MagiskDetector</a></p>
<p><a href="https://github.com/darvincisec/DetectMagiskHide">https://github.com/darvincisec/DetectMagiskHide</a></p>
<h1 id="HideRoot"><a href="#HideRoot" class="headerlink" title="HideRoot"></a>HideRoot</h1><p><a href="https://github.com/rmnscnce/hsu">https://github.com/rmnscnce/hsu</a></p>
<h1 id="Anti-VM"><a href="#Anti-VM" class="headerlink" title="Anti VM"></a>Anti VM</h1><p><a href="https://github.com/samohyes/Anti-vm-in-android">https://github.com/samohyes/Anti-vm-in-android</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>Android抓包</title>
    <url>/2020/12/30/Android%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="Android-抓包"><a href="#Android-抓包" class="headerlink" title="Android 抓包"></a>Android 抓包</h1><h2 id="使用-Charles-抓包"><a href="#使用-Charles-抓包" class="headerlink" title="使用 Charles 抓包"></a>使用 Charles 抓包</h2><ol>
<li>PC 端共享无线网络，使用 <code>ipconfig</code> 命令查看 ip 地址：</li>
</ol>
<img src="/2020/12/30/Android%E6%8A%93%E5%8C%85/2020-12-30-16-09-26.png" class="">

<ol start="2">
<li>手机端设置代理</li>
</ol>
<img src="/2020/12/30/Android%E6%8A%93%E5%8C%85/2020-12-30-16-10-42.png" class="">

<ol start="3">
<li>抓包工具设置代理</li>
</ol>
<img src="/2020/12/30/Android%E6%8A%93%E5%8C%85/2020-12-30-16-12-38.png" class="">

<img src="/2020/12/30/Android%E6%8A%93%E5%8C%85/2024-02-27-11-34-07.png" class="">

<ol start="4">
<li>安装证书</li>
</ol>
<p>手机端访问 <code>chls.pro/ssl</code> 下载证书并安装。其中可以通过 Magisk 插件 <a href="https://github.com/ys1231/MoveCertificate">MoveCertificate</a> 将证书从用户证书移动到系统证书。后续即可进行抓包了。 <strong>如果无法进行抓包，尝试一下关闭 Windows 防火墙。</strong></p>
<p>brup 配置好代理后，下载证书地址 <a href="http://burp/">http://burp</a> 。</p>
<p>brup 通过 <code>Proxy Setttings -&gt; Import /export CA certificate</code> 导出 <code>Certificate in DER format</code> 的证书，然后再通过手机安装该证书后却无法抓 https 数据包，提示你的连接不是私密连接 <code>NET::ERR_CERT_AUTHORITY_INVALID</code> 。</p>
<p>如果系统为 Android 7 以下的版本，可以手动将用户证书移动到系统证书。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载根目录，正常情况下，使其可读写</span></span><br><span class="line">mount -o rw,remount /</span><br><span class="line"><span class="comment"># 将用户证书移入系统证书目录</span></span><br><span class="line"><span class="built_in">mv</span> -f /data/misc/user/0/cacerts-added/123abc456.0 /system/etc/security/cacerts</span><br><span class="line"><span class="comment"># 重新挂载根目录，使其为只读</span></span><br><span class="line">mount -o ro,remount /</span><br></pre></td></tr></table></figure>

<p>Android 7 以上的版本，可以使用下列脚本临时移动证书到系统证书。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -e <span class="comment"># Fail on error</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a separate temp directory, to hold the current certificates</span></span><br><span class="line"><span class="comment"># Without this, when we add the mount we can&#x27;t read the current certs anymore.</span></span><br><span class="line"><span class="built_in">mkdir</span> -p -m 700 /data/local/tmp/htk-ca-copy</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy out the existing certificates</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">&quot;/apex/com.android.conscrypt/cacerts&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">cp</span> /apex/com.android.conscrypt/cacerts/* /data/local/tmp/htk-ca-copy/</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">      <span class="built_in">cp</span> /system/etc/security/cacerts/* /data/local/tmp/htk-ca-copy/</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the in-memory mount on top of the system certs folder</span></span><br><span class="line">mount -t tmpfs tmpfs /system/etc/security/cacerts</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy the existing certs back into the tmpfs mount, so we keep trusting them</span></span><br><span class="line"><span class="built_in">mv</span> /data/local/tmp/htk-ca-copy/* /system/etc/security/cacerts/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy our new cert in, so we trust that too</span></span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$&#123;certificatePath&#125;</span> /system/etc/security/cacerts/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Update the perms &amp; selinux context labels, so everything is as readable as before</span></span><br><span class="line"><span class="built_in">chown</span> root:root /system/etc/security/cacerts/*</span><br><span class="line"><span class="built_in">chmod</span> 644 /system/etc/security/cacerts/*</span><br><span class="line"><span class="built_in">chcon</span> u:object_r:system_file:s0 /system/etc/security/cacerts/*</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;System cacerts setup completed&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deal with the APEX overrides in Android 14+, which need injecting into each namespace:</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">&quot;/apex/com.android.conscrypt/cacerts&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&#x27;Injecting certificates into APEX cacerts&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># When the APEX manages cacerts, we need to mount them at that path too. We can&#x27;t do</span></span><br><span class="line">      <span class="comment"># this globally as APEX mounts are namespaced per process, so we need to inject a</span></span><br><span class="line">      <span class="comment"># bind mount for this directory into every mount namespace.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># First we get the Zygote process(es), which launch each app</span></span><br><span class="line">      ZYGOTE_PID=$(pidof zygote || <span class="literal">true</span>)</span><br><span class="line">      ZYGOTE64_PID=$(pidof zygote64 || <span class="literal">true</span>)</span><br><span class="line">      Z_PIDS=<span class="string">&quot;<span class="variable">$ZYGOTE_PID</span> <span class="variable">$ZYGOTE64_PID</span>&quot;</span></span><br><span class="line">      <span class="comment"># N.b. some devices appear to have both, some have &gt;1 of each (!)</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Apps inherit the Zygote&#x27;s mounts at startup, so we inject here to ensure all newly</span></span><br><span class="line">      <span class="comment"># started apps will see these certs straight away:</span></span><br><span class="line">      <span class="keyword">for</span> Z_PID <span class="keyword">in</span> <span class="variable">$Z_PIDS</span>; <span class="keyword">do</span></span><br><span class="line">         <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$Z_PID</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">            nsenter --mount=/proc/<span class="variable">$Z_PID</span>/ns/mnt -- \</span><br><span class="line">                  /bin/mount --<span class="built_in">bind</span> /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts</span><br><span class="line">         <span class="keyword">fi</span></span><br><span class="line">      <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&#x27;Zygote APEX certificates remounted&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Then we inject the mount into all already running apps, so they see these certs immediately.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># Get the PID of every process whose parent is one of the Zygotes:</span></span><br><span class="line">      APP_PIDS=$(</span><br><span class="line">         <span class="built_in">echo</span> <span class="variable">$Z_PIDS</span> | \</span><br><span class="line">         xargs -n1 ps -o <span class="string">&#x27;PID&#x27;</span> -P | \</span><br><span class="line">         grep -v PID</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="comment"># Inject into the mount namespace of each of those apps:</span></span><br><span class="line">      <span class="keyword">for</span> PID <span class="keyword">in</span> <span class="variable">$APP_PIDS</span>; <span class="keyword">do</span></span><br><span class="line">         nsenter --mount=/proc/<span class="variable">$PID</span>/ns/mnt -- \</span><br><span class="line">            /bin/mount --<span class="built_in">bind</span> /system/etc/security/cacerts /apex/com.android.conscrypt/cacerts &amp;</span><br><span class="line">      <span class="keyword">done</span></span><br><span class="line">      <span class="built_in">wait</span> <span class="comment"># Launched in parallel - wait for completion here</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;APEX certificates remounted for <span class="subst">$(echo $APP_PIDS | wc -w)</span> apps&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete the temp cert directory &amp; this script itself</span></span><br><span class="line"><span class="built_in">rm</span> -r /data/local/tmp/htk-ca-copy</span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$&#123;injectionScriptPath&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;System cert successfully injected&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面的脚本来自 <a href="https://github.com/httptoolkit/httptoolkit-server/blob/main/src/interceptors/android/adb-commands.ts#L256">httptoolkit</a> 。</p>
<h2 id="VPN-配合-Charles-抓包"><a href="#VPN-配合-Charles-抓包" class="headerlink" title="VPN 配合 Charles 抓包"></a>VPN 配合 Charles 抓包</h2><h2 id="Charles-设置"><a href="#Charles-设置" class="headerlink" title="Charles 设置"></a>Charles 设置</h2><p>首先要把 Charles 当做一个 SOCKS5 的代理服务器，所以要先设置 SOCKS5 代理服务器。打开 Proxy 设置选项，开启 SOCKS 服务器，我这里开启的端口为 8889 ，也可以随意填写。</p>
<img src="/2020/12/30/Android%E6%8A%93%E5%8C%85/2020-12-30-16-52-51.png" class="">

<p>下面介绍 3 款手机端的 VPN 应用。</p>
<p><a href="https://github.com/SagerNet/SagerNet">SagerNet</a></p>
<p><a href="https://github.com/bndeff/socksdroid">SocksDroid</a></p>
<h3 id="SocksDroid-设置"><a href="#SocksDroid-设置" class="headerlink" title="SocksDroid 设置"></a>SocksDroid 设置</h3><p>这里还有另一款 VPN 工具 <a href="Android%E6%8A%93%E5%8C%85/SocksDroid.apk">SocksDroid</a> 可以使用，这里也顺便说一下其配置方法，除了设置服务器 IP 和端口外，还需要设置一下 DNS 服务器，以适应国内网络环境。</p>
<img src="/2020/12/30/Android%E6%8A%93%E5%8C%85/2020-12-30-17-01-17.png" class="">
<img src="/2020/12/30/Android%E6%8A%93%E5%8C%85/2020-12-30-17-01-48.png" class="">

<h3 id="HTTP-x2F-HTTPS-转发到-Burp-Suite"><a href="#HTTP-x2F-HTTPS-转发到-Burp-Suite" class="headerlink" title="HTTP&#x2F;HTTPS 转发到 Burp Suite"></a>HTTP&#x2F;HTTPS 转发到 Burp Suite</h3><p>在 Charles 中，打开 External Proxy Settings 选项卡，选择把数据转到 Burp Suite 的代理服务器中。</p>
<img src="/2020/12/30/Android%E6%8A%93%E5%8C%85/2020-12-30-17-21-25.png" class="">

<h1 id="Windows-虚拟机抓包"><a href="#Windows-虚拟机抓包" class="headerlink" title="Windows 虚拟机抓包"></a>Windows 虚拟机抓包</h1><p>Charles 安装在物理机上。</p>
<ol>
<li>首先保存证书<br>在 Charles 菜单栏选择 <code>Help -&gt; SSL proxying -&gt; Save Charles Root Certificate</code> 保存证书，其中证书格式为 <code>.cer</code>。</li>
</ol>
<p>然后将证书拖入虚拟中，直接双击安装，将证书存储改为：受信任的根证书颁发机构。</p>
<ol start="2">
<li><p>设置代理<br>将虚拟机的代理设置为物理机的 IP，并且将代理端口设置为 Charles 的代理端口。其中设置代理的位置在：所有设置 -&gt; 网络和 Internet -&gt; 代理 -&gt; 手动设置代理。</p>
</li>
<li><p>设置 Charles<br>在 Charles 菜单栏选择 <code>Proxy -&gt; SSL Proxying Settings -&gt; SSL Proxying</code> ，选中 Enable SSL Proxying，并且在 Include 选项添加 Location，Host 和 Port 都设置为 <code>*</code>。</p>
</li>
</ol>
<h1 id="微信抓包"><a href="#微信抓包" class="headerlink" title="微信抓包"></a>微信抓包</h1><ol>
<li><p>首先用数据线把手机连接到电脑。</p>
</li>
<li><p>手机打开 USB 调试。</p>
</li>
<li><p>手机进入微信随便打开一个聊天窗口输入并发送： <code>http://debugxweb.qq.com/?inspector=true</code> 点击打开这个链接，弹出“执行成功”，即可。</p>
</li>
<li><p>手机微信打开想要抓包调试的网页。</p>
</li>
<li><p>电脑上打开 chrome 内核的浏览器或 edge 浏览器。<br>chrome 内核的浏览器输入 <code>chrome://inspect/#devices</code><br>edge 浏览器输入：<code>edge://inspect/#devices</code></p>
</li>
</ol>
<p>打开后稍等片刻，然后在打开的界面中点击 inspect fallback 。</p>
<h1 id="参考连接："><a href="#参考连接：" class="headerlink" title="参考连接："></a>参考连接：</h1><p><a href="https://mp.weixin.qq.com/s/ahPbBSfkkBsv4oy265rI2Q">https://mp.weixin.qq.com/s/ahPbBSfkkBsv4oy265rI2Q</a></p>
<p><a href="https://www.cnblogs.com/lulianqi/p/11380794.html">https://www.cnblogs.com/lulianqi/p/11380794.html</a></p>
<p><a href="https://www.52pojie.cn/thread-1826013-1-1.html">https://www.52pojie.cn/thread-1826013-1-1.html</a></p>
<p><a href="http://91fans.com.cn/post/certificate/#gsc.tab=0">http://91fans.com.cn/post/certificate/#gsc.tab=0</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>Android源码阅读-dlopen</title>
    <url>/2019/11/17/Android%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-dlopen/</url>
    <content><![CDATA[<blockquote>
<p>本次阅读源码来自aosp Android 8.1.0_r1，在阅读过程中根据阅读的进度随手记录</p>
</blockquote>
<p>有过 <code>linux</code> 编成经验的都应该知道使用 <code>dlopen</code> 需要包含 <code>dlfcn.h</code> 头文件，所以直接去<code>aosp/bionic/libc/include/dlfcn.h</code> 中找到 <code>dlopen</code> 的函数定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过<code>dlopen</code>的定义找到其实现在 <code>aosp/bionic/libdl/libdl.c</code> 中，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Proxy calls to bionic loader</span><br><span class="line">void* dlopen(const char* filename, int flag) &#123;</span><br><span class="line">    /*</span><br><span class="line">  __builtin_return_address(0)的含义是，得到当前函数返回地址，即此函数被别的函数调用，然后此函数执行完毕后，返回，所谓返回地址就是那时候的地址。</span><br><span class="line">  __builtin_return_address(1)的含义是，得到当前函数的调用者的返回地址。注意是调用者的返回地址，而不是函数起始地址。 </span><br><span class="line">    */</span><br><span class="line">  const void* caller_addr = __builtin_return_address(0);//可以理解为汇编 MOV R0, LR</span><br><span class="line">  return __loader_dlopen(filename, flag, caller_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现 <code>dlopen</code> 的是通过 <code>__loader_dlopen</code> 完成其实现的。查看 <code>__loader_dlopen</code> 的实现，会发现找不到其是实现方法，只能找到相关的定义 <code>aosp/bionic/libdl/libdl.c</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__attribute__((__weak__, visibility(&quot;default&quot;)))</span><br><span class="line">void* __loader_dlopen(const char* filename, int flags, const void* caller_addr);</span><br></pre></td></tr></table></figure>
<p>通过搜索 <code>__loader_dlopen</code> 字符串，发现 <code>aosp/bionic/linker/dlfcn.cpp</code> 存在相关字符串。</p>
<img src="/2019/11/17/Android%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-dlopen/2019-11-17-15-12-04.png" class="">

<p>跟进去后发现，其被定义的在 <code>ANDROID_LIBDL_STRTAB</code> 字符串数组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const char ANDROID_LIBDL_STRTAB[] =</span><br><span class="line">  // 0000000000111111 11112222222222333 333333344444444 44555555555566666 6666677777777778 8888888889999999999</span><br><span class="line">  // 0123456789012345 67890123456789012 345678901234567 89012345678901234 5678901234567890 1234567890123456789</span><br><span class="line">    &quot;__loader_dlopen\0__loader_dlclose\0__loader_dlsym\0__loader_dlerror\0__loader_dladdr\0__loader_android_up&quot;</span><br><span class="line">  // 1*</span><br><span class="line">  // 000000000011111111112 2222222223333333333444444444455555555 5566666666667777777777888 88888889999999999</span><br><span class="line">  // 012345678901234567890 1234567890123456789012345678901234567 8901234567890123456789012 34567890123456789</span><br><span class="line">    &quot;date_LD_LIBRARY_PATH\0__loader_android_get_LD_LIBRARY_PATH\0__loader_dl_iterate_phdr\0__loader_android_&quot;</span><br><span class="line">  // 2*</span><br><span class="line">  // 00000000001 1111111112222222222333333333344444444445555555555666 6666666777777777788888888889999999999</span><br><span class="line">  // 01234567890 1234567890123456789012345678901234567890123456789012 3456789012345678901234567890123456789</span><br><span class="line">    &quot;dlopen_ext\0__loader_android_set_application_target_sdk_version\0__loader_android_get_application_targ&quot;</span><br><span class="line">  // 3*</span><br><span class="line">  // 000000000011111 111112222222222333333333344444444445555555 5556666666666777777777788888888889 999999999</span><br><span class="line">  // 012345678901234 567890123456789012345678901234567890123456 7890123456789012345678901234567890 123456789</span><br><span class="line">    &quot;et_sdk_version\0__loader_android_init_anonymous_namespace\0__loader_android_create_namespace\0__loader_&quot;</span><br><span class="line">  // 4*</span><br><span class="line">  // 0000000 000111111111122222222223333 333333444444444455 555555556666666666777777777788888 888889999999999</span><br><span class="line">  // 0123456 789012345678901234567890123 456789012345678901 234567890123456789012345678901234 567890123456789</span><br><span class="line">    &quot;dlvsym\0__loader_android_dlwarning\0__loader_cfi_fail\0__loader_android_link_namespaces\0__loader_androi&quot;</span><br><span class="line">  // 5*</span><br><span class="line">  // 0000000000111111111122222 22222</span><br><span class="line">  // 0123456789012345678901234 56789</span><br><span class="line">    &quot;d_get_exported_namespace\0&quot;</span><br><span class="line">#if defined(__arm__)</span><br><span class="line">  // 525</span><br><span class="line">    &quot;__loader_dl_unwind_find_exidx\0&quot;</span><br><span class="line">#endif</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>继续跟进，发现 <code>g_libdl_symtab</code> 中使用了 <code>ANDROID_LIBDL_STRTAB</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static ElfW(Sym) g_libdl_symtab[] = &#123;</span><br><span class="line">  // Total length of libdl_info.strtab, including trailing 0.</span><br><span class="line">  // This is actually the STH_UNDEF entry. Technically, it&#x27;s</span><br><span class="line">  // supposed to have st_name == 0, but instead, it points to an index</span><br><span class="line">  // in the strtab with a \0 to make iterating through the symtab easier.</span><br><span class="line">  ELFW(SYM_INITIALIZER)(sizeof(ANDROID_LIBDL_STRTAB) - 1, nullptr, 0),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(  0, &amp;__dlopen, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)( 16, &amp;__dlclose, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)( 33, &amp;__dlsym, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)( 48, &amp;__dlerror, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)( 65, &amp;__dladdr, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)( 81, &amp;__android_update_LD_LIBRARY_PATH, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(121, &amp;__android_get_LD_LIBRARY_PATH, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(158, &amp;dl_iterate_phdr, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(183, &amp;__android_dlopen_ext, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(211, &amp;__android_set_application_target_sdk_version, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(263, &amp;__android_get_application_target_sdk_version, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(315, &amp;__android_init_anonymous_namespace, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(357, &amp;__android_create_namespace, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(391, &amp;__dlvsym, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(407, &amp;__android_dlwarning, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(434, &amp;__cfi_fail, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(452, &amp;__android_link_namespaces, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(485, &amp;__android_get_exported_namespace, 1),</span><br><span class="line">#if defined(__arm__)</span><br><span class="line">  ELFW(SYM_INITIALIZER)(525, &amp;__dl_unwind_find_exidx, 1),</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将相关代码复制到一个C源码文件，使用 <code>g++ -E</code> 宏展开并优化后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static ElfW(Sym) g_libdl_symtab[] = &#123;</span><br><span class="line"></span><br><span class="line">  &#123; sizeof(ANDROID_LIBDL_STRTAB) - 1, 0, 0, 0, reinterpret_cast&lt;Elf64_Addr&gt;(nullptr), 0, &#125;,</span><br><span class="line">  &#123; 0, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__dlopen), 0, &#125;,</span><br><span class="line">  &#123; 16, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__dlclose), 0, &#125;,</span><br><span class="line">  &#123; 33, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__dlsym), 0, &#125;,</span><br><span class="line">  &#123; 48, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__dlerror), 0, &#125;,</span><br><span class="line">  &#123; 65, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__dladdr), 0, &#125;,</span><br><span class="line">  &#123; 81, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_update_LD_LIBRARY_PATH), 0, &#125;,</span><br><span class="line">  &#123; 121, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_get_LD_LIBRARY_PATH), 0, &#125;,</span><br><span class="line">  &#123; 158, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;dl_iterate_phdr), 0, &#125;,</span><br><span class="line">  &#123; 183, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_dlopen_ext), 0, &#125;,</span><br><span class="line">  &#123; 211, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_set_application_target_sdk_version), 0, &#125;,</span><br><span class="line">  &#123; 263, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_get_application_target_sdk_version), 0, &#125;,</span><br><span class="line">  &#123; 315, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_init_anonymous_namespace), 0, &#125;,</span><br><span class="line">  &#123; 357, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_create_namespace), 0, &#125;,</span><br><span class="line">  &#123; 391, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__dlvsym), 0, &#125;,</span><br><span class="line">  &#123; 407, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_dlwarning), 0, &#125;,</span><br><span class="line">  &#123; 434, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__cfi_fail), 0, &#125;,</span><br><span class="line">  &#123; 452, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_link_namespaces), 0, &#125;,</span><br><span class="line">  &#123; 485, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_get_exported_namespace), 0, &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2019-11-17 01:47:00.768 10666-10666&#x2F;com.example.ndkdebug E&#x2F;linker: library “&#x2F;system&#x2F;lib64&#x2F;libandroid_runtime.so” (“&#x2F;system&#x2F;lib64&#x2F;libandroid_runtime.so”) needed or dlopened by “&#x2F;data&#x2F;app&#x2F;com.example.ndkdebug-tJLtYCKjLoRt2XhNQlIu9A&#x3D;&#x3D;&#x2F;lib&#x2F;arm64&#x2F;libnative-lib.so” is not accessible for the namespace: [name&#x3D;”classloader-namespace”, ld_library_paths&#x3D;””, default_library_paths&#x3D;”&#x2F;data&#x2F;app&#x2F;com.example.ndkdebug-tJLtYCKjLoRt2XhNQlIu9A&#x3D;&#x3D;&#x2F;lib&#x2F;arm64:&#x2F;data&#x2F;app&#x2F;com.example.ndkdebug-tJLtYCKjLoRt2XhNQlIu9A&#x3D;&#x3D;&#x2F;base.apk!&#x2F;lib&#x2F;arm64-v8a”, permitted_paths&#x3D;”&#x2F;data:&#x2F;mnt&#x2F;expand:&#x2F;data&#x2F;data&#x2F;com.example.ndkdebug”]</p>
<p>未完待续。。。</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>编译Android系统</title>
    <url>/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="基本环境配置"><a href="#基本环境配置" class="headerlink" title="基本环境配置"></a>基本环境配置</h1><h2 id="JDK-环境"><a href="#JDK-环境" class="headerlink" title="JDK 环境"></a>JDK 环境</h2><p>官方 Android 版本与 JDK 版本说明：</p>
<ul>
<li>Android 7.0 (Nougat) - Android 8.0 (O)：Ubuntu - OpenJDK 8；Mac OS - jdk 8u45 或更高版本</li>
<li>Android 5.x (Lollipop) - Android 6.0 (Marshmallow)：Ubuntu - OpenJDK 7；Mac OS - jdk-7u71-macosx-x64.dmg</li>
<li>Android 2.3.x (Gingerbread) - Android 4.4.x (KitKat)：Ubuntu - Java JDK 6；Mac OS - Java JDK 6</li>
<li>Android 1.5 (Cupcake) - Android 2.2.x (Froyo)：Ubuntu - Java JDK 5</li>
</ul>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>由于国内网络环境问题，下列下载源码方式均未采用 google 官方提供的方式。</p>
<h3 id="1-下载-repo-工具"><a href="#1-下载-repo-工具" class="headerlink" title="1. 下载 repo 工具"></a>1. 下载 repo 工具</h3><p>使用清华 mirror 下载 repo 工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repo</span><br><span class="line">$ <span class="built_in">chmod</span> +x repo</span><br></pre></td></tr></table></figure>

<p>然后设置更新源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> REPO_URL=<span class="string">&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-下载-Android-源码"><a href="#2-下载-Android-源码" class="headerlink" title="2. 下载 Android 源码"></a>2. 下载 Android 源码</h3><p>因为 Android 的源码越来越大，<code>repo sync</code> 失败的概率也越来越高。<br>所以我们可以避开使用 <code>repo sync</code> 的方式，而采用下载预下载包的方式来实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget -c https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar <span class="comment"># 下载初始化包</span></span><br><span class="line">$ tar xf aosp-latest.tar</span><br><span class="line">$ <span class="built_in">cd</span> aosp   <span class="comment"># 解压得到的 aosp 工程目录</span></span><br><span class="line">$ repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-8.1.0_r1</span><br><span class="line">$ repo <span class="built_in">sync</span> <span class="comment"># 正常同步一遍即可得到完整目录</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn/</a></p>
</blockquote>
<p>这里考虑到网络问题，sync 的过程中可能会意外断开，我们不可能一直守着看的，所以通过下面的脚本来完成代码的下载。将下面的内容保存为<code>start_repo.sh</code>，然后该脚本执行权限<code>chmod a+x start_repo.sh</code>，然后就是等待了，推荐晚上睡觉扔在那里下载，第二天就可以用了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;======start repo sync======&quot;</span></span><br><span class="line">./repo <span class="built_in">sync</span> -j4</span><br><span class="line"><span class="keyword">while</span> [ $? = 1 ]; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;======sync failed, re-sync again======&quot;</span></span><br><span class="line">        <span class="built_in">sleep</span> 3</span><br><span class="line">        ./repo <span class="built_in">sync</span> -j4</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>如果不想使用上述方式下载源码，可以使用国内用户提供的百度云盘连接下载：</p>
<p><a href="http://pan.baidu.com/s/1ngsZs">http://pan.baidu.com/s/1ngsZs</a></p>
<p>以上链接来源自<a href="https://testerhome.com/topics/2229">此处</a>。</p>
<h3 id="3-android-源码查看所有分支切换分支"><a href="#3-android-源码查看所有分支切换分支" class="headerlink" title="3. android 源码查看所有分支切换分支"></a>3. android 源码查看所有分支切换分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> .repo/manifests</span><br><span class="line">git branch -a   <span class="comment">#查看所有分支</span></span><br><span class="line"></span><br><span class="line">repo init -b android-4.1.2_r1   <span class="comment"># 切换分支</span></span><br><span class="line">repo <span class="built_in">sync</span></span><br></pre></td></tr></table></figure>

<p>后续就可以进行编译了。</p>
<h1 id="Android-4-4-系统源码编译"><a href="#Android-4-4-系统源码编译" class="headerlink" title="Android 4.4 系统源码编译"></a>Android 4.4 系统源码编译</h1><p>编译环境: ubuntu 14.04 或 Ubuntu 16.04。</p>
<h2 id="安装-Java-JDK-6-环境"><a href="#安装-Java-JDK-6-环境" class="headerlink" title="安装 Java JDK 6 环境"></a>安装 Java JDK 6 环境</h2><p>JDK 6 安装包下载地址：<a href="https://repo.huaweicloud.com/java/jdk/6u45-b06/">https://repo.huaweicloud.com/java/jdk/6u45-b06/</a></p>
<p>下载 <code>jdk-6u45-linux-x64.bin</code> 并安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/local</span><br><span class="line">$ sudo <span class="built_in">mkdir</span> java</span><br><span class="line">$ <span class="built_in">cd</span> jav</span><br><span class="line">$ sudo <span class="built_in">cp</span> ~/jdk-6u45-linux-x64.bin /usr/local/java</span><br><span class="line">$ sudo <span class="built_in">chmod</span> 777 jdk-6u45-linux-x64.bin</span><br><span class="line">$ sudo ./jdk-6u45-linux-x64.bin</span><br></pre></td></tr></table></figure>

<p>打开 <code>~/.bashrc</code> 文件，将下列内容添加到文件末尾，配置 java 环境变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Java Environment</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/java/jdk1.6.0_45</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=/usr/local/java/jdk1.6.0_45/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib:<span class="variable">$JRE_HOME</span>/lib:<span class="variable">$CLASSPATH</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$JAVA_HOME</span>:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>重启终端，输入 <code>java -version</code> 验证环境是否配置完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version <span class="string">&quot;1.6.0_45&quot;</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.6.0_45-b06)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 20.45-b01, mixed mode)</span><br></pre></td></tr></table></figure>

<p>如果系统中存在多个 java 版本，可以通过下列命令设置默认的 Java 版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config java</span><br><span class="line">sudo update-alternatives --config javac</span><br></pre></td></tr></table></figure>

<h2 id="二、安装依赖库"><a href="#二、安装依赖库" class="headerlink" title="二、安装依赖库"></a>二、安装依赖库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install -y git flex bison gperf build-essential \</span><br><span class="line">libncurses5-dev:i386 libx11-dev:i386 libreadline6-dev:i386 \</span><br><span class="line">libgl1-mesa-dev g++-multilib tofrodos python-markdown libxml2-utils \</span><br><span class="line">xsltproc zlib1g-dev:i386 dpkg-dev libsdl1.2-dev libesd0-dev git-core \</span><br><span class="line">gnupg flex bison gperf build-essential zip curl zlib1g-dev \</span><br><span class="line">gcc-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev \</span><br><span class="line">libx11-dev lib32z-dev ccache unzip m4</span><br></pre></td></tr></table></figure>

<p>Ubuntu 16.04 以上的系统请务必使用上面的依赖，Ubuntu 16.04 需要的依赖和 Ubuntu 14.04 所需要的依赖是不同的。</p>
<p>以下是 Ubuntu 14.04 所需要的依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install git-core gnupg flex bison gperf build-essential \</span><br><span class="line">zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 \</span><br><span class="line">lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache \</span><br><span class="line">libgl1-mesa-dev libxml2-utils xsltproc unzip</span><br></pre></td></tr></table></figure>

<p>编译 android4.4.4 需要 make 3.81 或 3.82 ，所以要降级 make。</p>
<p>前往 <a href="ftp://ftp.gnu.org/gnu/make/">ftp://ftp.gnu.org/gnu/make/</a> 下载 <code>make-3.82.tar.gz</code>，并编译安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -zxvf make-3.82.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> make-3.82</span><br><span class="line">$ sudo ./configure</span><br><span class="line">$ sudo make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>

<p>如果出现错误，可以按如下方式修改源码：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">$ diff --git a/glob/glob.c b/glob/glob.c</span><br><span class="line"><span class="comment">index f3911bc..e4d551e 100644</span></span><br><span class="line"><span class="comment">--- a/glob/glob.c</span></span><br><span class="line"><span class="comment">+++ b/glob/glob.c</span></span><br><span class="line"><span class="meta">@@ -208,8 +208,6 @@</span> my_realloc (p, n)</span><br><span class="line">    #endif /* __GNU_LIBRARY__ || __DJGPP__ */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="deletion">-#if !defined __alloca &amp;&amp; !defined __GNU_LIBRARY__</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line">    # ifdef    __GNUC__</span><br><span class="line">    #  undef alloca</span><br><span class="line">    #  define alloca(n)        __builtin_alloca (n)</span><br><span class="line"><span class="meta">@@ -229,8 +227,6 @@</span> extern char *alloca ();</span><br><span class="line"></span><br><span class="line">    # define __alloca  alloca</span><br><span class="line"></span><br><span class="line"><span class="deletion">-#endif</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line">    #ifndef __GNU_LIBRARY__</span><br><span class="line">    # define __stat stat</span><br><span class="line">    # ifdef STAT_MACROS_BROKEN</span><br></pre></td></tr></table></figure>

<h2 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h2><ul>
<li>由于我使用的是 NEXUS 5 设备，并且打算编译 Android 4.4.4_r1 版本，所以去官方 Nexus 和 Pixel 设备的二进制驱动下载页面：<a href="https://developers.google.com/android/drivers">https://developers.google.com/android/drivers</a> 下载了相应的二进制驱动。</li>
<li>将三个压缩包解压出的自解压脚本放在源码树的根目录下并运行将会得到一个<code>Vendor</code>目录 。</li>
</ul>
<h2 id="六、开始编译"><a href="#六、开始编译" class="headerlink" title="六、开始编译"></a>六、开始编译</h2><ul>
<li><p>命令删除所有以前编译操作的已有输出：<br><code>make clobber</code></p>
</li>
<li><p>使用<code> build</code>目录中的<code>envsetup.sh </code>脚本初始化环境<br><code>source build/envsetup.sh</code></p>
</li>
<li><p>使用 lunch 选择要编译的目标<br><code>lunch</code><br>选择你想编译的版本，这里我选的是 aosp_hammerhead-userdebug,所以输入 13，</p>
</li>
<li><p>编译代码<br><code>make -j4</code><br>-j4 的意思是 4 个线程同步编译<br>关于 cpu 个数，可以用下面命令查看:<br><code>cat /proc/cpuinfo | grep processor</code><br>经过漫长的等待后就编译完成界面，如果中途出错就根据错误信息谷歌一下或者重新编译。</p>
<img src="/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/2019-11-08-11-05-30.png" class=""></li>
</ul>
<h2 id="刷入目标机器"><a href="#刷入目标机器" class="headerlink" title="刷入目标机器"></a>刷入目标机器</h2><ol>
<li><p>手机开启调试模式，连上电脑，执行<code>adb devices</code>命令将会显示连接的机器。</p>
</li>
<li><p>以 fastboot 模式启动手机，然后进行刷机<br><code>adb reboot bootloader</code></p>
</li>
<li><p>刷机<br><code>fastboot -w flashall</code></p>
</li>
</ol>
<p>至此整个编译源码并刷机的过成圆满结束了。</p>
<h2 id="遇到的一些坑"><a href="#遇到的一些坑" class="headerlink" title="遇到的一些坑"></a>遇到的一些坑</h2><ol>
<li>编译过程种突然中止，怎么都找不到原因</li>
</ol>
<p>可能是给的内存太小，重新编译几次就好了。</p>
<ol start="2">
<li>adb 和 fastboot 都没有权限</li>
</ol>
<p>可以参考<a href="https://github.com/snowdream/51-android">https://github.com/snowdream/51-android</a></p>
<ol start="3">
<li>adb 以及 fastboot 运行后提示需要安装</li>
</ol>
<p>此时可以到 android 源码目录运行<code> build</code>目录中的<code>envsetup.sh </code>脚本初始化环境<br><code>source build/envsetup.sh</code> 并 <code>lunch</code> 。</p>
<ol start="4">
<li>刷机后进不了系统，可能是 fastboot 版本过高的原因。</li>
</ol>
<p><strong>参考：</strong></p>
<p><a href="https://www.jianshu.com/p/6471bab49cb1">xposed 源码编译与集成</a></p>
<p><a href="https://bbs.pediy.com/thread-218366.htm">记一次安卓系统源码下载过程</a></p>
<p><a href="https://bbs.pediy.com/thread-218513.htm">记一次安卓系统源码编译刷机过程</a></p>
<p><a href="https://bbs.pediy.com/thread-219233.htm">记一次安卓内核源码编译刷机过程(修改反调试标志位)</a></p>
<h1 id="Android-8-1-系统源码编译"><a href="#Android-8-1-系统源码编译" class="headerlink" title="Android 8.1 系统源码编译"></a>Android 8.1 系统源码编译</h1><p>编译环境：ubuntu 18.04</p>
<h2 id="配置编译环境"><a href="#配置编译环境" class="headerlink" title="配置编译环境"></a>配置编译环境</h2><h3 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h3><p>安装 <code>openjdk-8-jdk</code> :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure>

<h3 id="安装编译所需要的包"><a href="#安装编译所需要的包" class="headerlink" title="安装编译所需要的包"></a>安装编译所需要的包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get -y install git-core gnupg flex bison build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig</span><br></pre></td></tr></table></figure>

<p>以上的依赖包在编译 <code>android-9.0.0_r36</code> 时测试没有问题，其中 <code>openjdk-8-jdk</code> 非必须。</p>
<p><strong>ubuntu 20.04 需要安装 python2 。</strong></p>
<h2 id="下载驱动-1"><a href="#下载驱动-1" class="headerlink" title="下载驱动"></a>下载驱动</h2><p>根据手机型号和 Android 版本下载对应的驱动</p>
<p><a href="https://developers.google.com/android/drivers">https://developers.google.com/android/drivers</a></p>
<p>下载完成后解压到<code>aosp</code>目录，并执行对应的脚本,最终会产生一个<code>vendor</code>目录。</p>
<img src="/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/2019-11-05-22-52-59.png" class="">

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>首先运行<code>source build/envsetup.sh</code>:</p>
<img src="/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/2019-11-05-23-36-27.png" class="">

<p>执行 <code>lunch</code> ,选择需要编译的版本,执行 <code>make -j16</code> 进行编译。</p>
<img src="/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/2019-11-05-23-04-58.png" class="">

<p>编译成功</p>
<img src="/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/2019-11-06-15-33-38.png" class="">

<h2 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h2><p>为了保险期间，建议更新 bootloader 到相应的版本,可以去官方下载刷机包，刷入对应的 bootloader，我这里就是遇到了这个坑。</p>
<p><a href="https://developers.google.com/android/images/#sailfish">https://developers.google.com/android/images/#sailfish</a></p>
<p><strong>刷机前，需要特别注意在 <code>setting-&gt;User &amp; accounts</code> 中将 Google account remove 掉，否则刷完机后会要求登录刷机前的 Google 账户才允许进入 launcher 界面。</strong></p>
<p>首先 <code>adb reboot bootloader</code> 进入 bootloader 模式，然后进入下载好的刷机包，执行 <code>./flash-base.sh</code> 即可更新 <code>bootloader</code> 和 <code>radio</code> 。</p>
<p>然后将路径切换到<code>out/target/product/sailfish</code>下，下面我们刷入其他镜像文件</p>
<p>首先是<code>boot.img</code>，执行<code>fastboot flash boot_a boot.img</code> 和 <code>fastboot flash boot_b boot.img</code> 。</p>
<p>接下来是<code>system.img</code>，执行<code>fastboot flash system system.img</code> 和 <code>fastboot flash system_b system_other.img</code> 。</p>
<p>最后是<code>vendor.img</code>，执行<code>fastboot flash vendor vendor.img</code> 。</p>
<p>当然如果你有自己定义，例如破解电信 4G 的 modem，可以执行 <code>fastboot flash modem modem.img</code><br>最后通过 <code>fastboot reboot</code>，重启手机。</p>
<p>上列命令也可以使用下列命令进行替代</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ fastboot flashall -w</span><br></pre></td></tr></table></figure>

<p>注意：此命令会在当前文件夹中查找全部 img 文件，将这些 img 文件烧写到全部相应的分区中，并又一次启动手机。</p>
<img src="/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/2019-11-07-10-49-36.png" class="">

<p>其他命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清空分区</span></span><br><span class="line">$ fastboot erase boot</span><br><span class="line">$ fastboot erase system</span><br><span class="line">$ fastboot erase data</span><br><span class="line">$ fastboot erase cache</span><br><span class="line"><span class="comment"># 上面的命令也可以简化成一条命令</span></span><br><span class="line">$ fastboot erase system -w</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单刷</span></span><br><span class="line"><span class="comment"># 最重要刷 boot.img、system.img、userdata.img、vendor.img 这四个固件.</span></span><br><span class="line">$ adb reboot bootloader</span><br><span class="line">$ fastboot flash boot boot.img</span><br><span class="line">$ fastboot flash system system.img</span><br><span class="line">$ fastboot flash userdata userdata.img</span><br><span class="line">$ fastboot flash vendor vendor.img</span><br><span class="line">$ fastboot flash recovery recovery.img <span class="comment"># 没有编出来，可选</span></span><br><span class="line">$ fastboot flash cache cache.img <span class="comment"># 没有编出来，可选</span></span><br><span class="line">$ fastboot flash persist persist.img <span class="comment"># 没有编出来，可选</span></span><br><span class="line">$ fastboot reboot</span><br></pre></td></tr></table></figure>

<p><strong>遇到的坑</strong></p>
<p>我的手机版本是 7.1.2 的，然后直接刷机，开机后开机画面一闪而过，然后无限重启循环这个过程。</p>
<p><strong>解决</strong></p>
<p>先刷官方 8.1 的系统，在刷自己编译的 8.1 系统就可以了，具体原因就是 bootloader 没有更新到相应的版本。</p>
<p>下图为刷机成功的的手机系统信息。</p>
<img src="/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/2019-11-10-14-05-29.png" class="">

<h2 id="编译内核并刷机"><a href="#编译内核并刷机" class="headerlink" title="编译内核并刷机"></a>编译内核并刷机</h2><h3 id="获取内核源码"><a href="#获取内核源码" class="headerlink" title="获取内核源码"></a>获取内核源码</h3><p>进入到源码根目录下的 kernel 文件夹中执行 <code>git clone https://aosp.tuna.tsinghua.edu.cn/kernel/msm</code>，就可以下载到相应 msm 的内核源码了。<br>通过 <a href="https://source.android.com/source/building-kernels">https://source.android.com/source/building-kernels</a> 页面找到设备对应的源码位置。</p>
<img src="/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/2019-11-07-18-13-31.png" class="">

<p>通过 <code>git branch -r|grep marlin-kernel</code> 命令查找对应的分支，然后通过 <code>git checkout remotes/origin/android-msm-marlin-3.18-oreo-mr1</code> 切换分支获取到源码。</p>
<h3 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h3><p>修改内核目录下的 <code>Makefile</code> 文件，修改内容如下：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"> # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile</span><br><span class="line"><span class="deletion">- ARCH           ?= $(SUBARCH)</span></span><br><span class="line"><span class="deletion">- CROSS_COMPILE  ?= $(CONFIG_CROSS_COMPILE:&quot;%&quot;=%)</span></span><br><span class="line"><span class="addition">+ ARCH           ?= arm64</span></span><br><span class="line"><span class="addition">+ CROSS_COMPILE  ?= aarch64-linux-android-</span></span><br><span class="line"><span class="addition">+ SUBARCH           ?= arm64</span></span><br><span class="line"><span class="addition">+ CROSS_COMPILE_ARM32  ?= arm-linux-androideabi-</span></span><br><span class="line"></span><br><span class="line"> # Architecture as present in compile.</span><br></pre></td></tr></table></figure>

<p>回到 <code>aosp</code> 目录进行 <code>source</code>、<code>lunch</code> 操作，然后进入 msm 目录执行 <code>make marlin_defconfig</code>，得到 <code>.config</code> 文件后，直接执行 <code>make -j4</code> 即可。</p>
<p>在编译过程中出现如下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/sh: 1: lz4c: not found</span><br><span class="line"><span class="built_in">arch</span>/arm64/boot/Makefile:36: recipe <span class="keyword">for</span> target <span class="string">&#x27;arch/arm64/boot/Image.lz4&#x27;</span> failed</span><br></pre></td></tr></table></figure>

<img src="/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/2019-11-07-15-36-55.png" class="">

<p>显然是<code>lz4c</code>没有找到，应该就是有依赖工具没有安装，通过 <code>sudo apt-get install liblz4-tool</code> 安装即可，继续 <code>make -j4</code> 编译，最后得到 <code>arch/arm64/boot/Image.lz4-dtb</code> 。</p>
<img src="/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/2019-11-07-15-38-29.png" class="">

<p>将上面编译得到的 <code>Image.lz4-deb</code> 文件复制到 aosp 源码目录下的 <code>device/google/marlin-kernel</code> 路径即可，然后到 aosp 源码根目录下执行 <code>make bootimage</code> 。</p>
<img src="/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/2019-11-07-15-48-06.png" class="">

<p>或者按下列命令生成 <code>boot.img</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> TARGET_PREBUILT_KERNEL=/media/ckcat/other/aosp/msm/arch/arm64/boot/Image.lz4-dtb</span><br><span class="line">$ <span class="built_in">rm</span> out/target/product/sailfish/boot.img &amp;&amp; make bootimage</span><br></pre></td></tr></table></figure>

<p>如果想要替换 <code>boot.img</code> 中的 <code>default.prop</code>,可以在 <code>build/core/Makefile</code> 中搜索关键字 <code>TARGET_RECOVERY_ROOT_OUT)/default.prop</code> 做如下修改，<a href="https://blog.csdn.net/XXOOYC/article/details/85679143">参考</a>:</p>
<img src="/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/2019-12-26-16-26-31.png" class="">

<p>最后按照前面所写的内容，使用 <code>fastboot flash boot_a boot.img</code> 和 <code>fastboot flash boot_b boot.img</code> 刷入即可。如下截图可以看到 kernel 是使用<code>ckcat</code>的机器编译的。</p>
<img src="/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/2019-11-10-14-07-09.png" class="">

<p>参考: <a href="https://blog4jimmy.com/2018/02/418.html">https://blog4jimmy.com/2018/02/418.html</a></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="flex-2-5-39-loadlocale-c-130-错误。"><a href="#flex-2-5-39-loadlocale-c-130-错误。" class="headerlink" title="flex-2.5.39: loadlocale.c:130 错误。"></a>flex-2.5.39: loadlocale.c:130 错误。</h3><p>bing 搜索相关内容，在这个<a href="https://stackoverflow.com/questions/49955137/error-when-build-lineageos-make-ninja-wrapper-error-1">链接</a>中找到解法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LC_ALL=C</span><br></pre></td></tr></table></figure>

<p>把这行代码添加到 <code>.bashrc</code> 文件中，实测有效。</p>
<p><code>LC_ALL=C</code> 是为了去除所有本地化的设置，让命令能正确执行。</p>
<p><strong>注意</strong></p>
<blockquote>
<p>以上设置可能会导致 gnome-terminal 无法启动，通过 <code>grep &quot;gnome-terminal&quot; /var/log/syslog</code> 查看会发现是 <code>Non UTF-8 locale (ANSI_X3.4-1968) is not supported!</code>。此时删掉刚才设置的 <code>export LC_ALL=C</code> 即可。</p>
</blockquote>
<p>参考：</p>
<p><a href="https://forums.linuxmint.com/viewtopic.php?t=280655">https://forums.linuxmint.com/viewtopic.php?t=280655</a></p>
<p><a href="https://blog.csdn.net/aaa111/article/details/80330848">https://blog.csdn.net/aaa111/article/details/80330848</a></p>
<h3 id="adb-和-fastboot-都没有权限"><a href="#adb-和-fastboot-都没有权限" class="headerlink" title="adb 和 fastboot 都没有权限"></a>adb 和 fastboot 都没有权限</h3><blockquote>
<p>可以参考 <a href="https://github.com/snowdream/51-android">https://github.com/snowdream/51-android</a> 或者 <a href="https://github.com/M0Rf30/android-udev-rules">https://github.com/M0Rf30/android-udev-rules</a></p>
</blockquote>
<h3 id="adb-devices-无法工作。"><a href="#adb-devices-无法工作。" class="headerlink" title="adb devices 无法工作。"></a>adb devices 无法工作。</h3><p>这是因为缺少 USB 驱动的原因，按照以下方法更新</p>
<ol>
<li>打开设备管理器</li>
<li>查找未知的 Android 设备</li>
<li>更新驱动程序</li>
<li>浏览我的计算机以查找驱动程序软件</li>
<li>让我从设备列表中选择，选择列出所有设备</li>
<li>在 Android 设备 或 Google Inc 下，您会找到 Android Bootloader Interface</li>
<li>选择 Android Bootloader 界面</li>
<li>当它说驱动程序可能不兼容时单击 是</li>
</ol>
<p>如果以上步骤 6 无法找到相应的设备，就需要安装对应的设备，参考网站 <a href="https://developer.android.com/studio/run/oem-usb#InstallingDriver">https://developer.android.com/studio/run/oem-usb#InstallingDriver</a> 上的说明进行安装即可。</p>
<blockquote>
<p>参考： <a href="https://stackoverflow.com/questions/8588595/android-fastboot-devices-not-returning-device">https://stackoverflow.com/questions/8588595/android-fastboot-devices-not-returning-device</a></p>
</blockquote>
<h3 id="SSL-error-when-connecting-to-the-Jack-server-Try-‘jack-diagnose’"><a href="#SSL-error-when-connecting-to-the-Jack-server-Try-‘jack-diagnose’" class="headerlink" title="SSL error when connecting to the Jack server. Try ‘jack-diagnose’"></a>SSL error when connecting to the Jack server. Try ‘jack-diagnose’</h3><p>原因就是编译时用的是 open-jdk 8u292，默认禁用了 TLSv1, TLSv1.1，<br>从<code>/etc/java-8-openjdk/security/java.security</code>中取消 TLSv1, TLSv1.1 禁用，<br>修改前</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#   jdk.tls.disabledAlgorithms=MD5, SSLv3, DSA, RSA keySize &lt; 2048</span></span><br><span class="line">jdk.tls.disabledAlgorithms=SSLv3, TLSv1, TLSv1.1, RC4, DES, MD5withRSA, \</span><br><span class="line">    DH keySize &lt; 1024, EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, \</span><br><span class="line">    include jdk.disabled.namedCurves</span><br></pre></td></tr></table></figure>

<p>修改后:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#   jdk.tls.disabledAlgorithms=MD5, SSLv3, DSA, RSA keySize &lt; 2048</span></span><br><span class="line">jdk.tls.disabledAlgorithms=SSLv3, RC4, DES, MD5withRSA, \</span><br><span class="line">    DH keySize &lt; 1024, EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, \</span><br><span class="line">    include jdk.disabled.namedCurves</span><br></pre></td></tr></table></figure>

<p><code>aosp/prebuilts/sdk/tools/</code> 目录下执行 <code>./jack-admin kill-server &amp;&amp; ./jack-admin start-server</code> 成功。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>编译亲儿子内核时简单几步让版本信息和官方镜像一致，而不是显示 <code>-dirty</code> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell <span class="built_in">cat</span> /proc/version</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> KBUILD_BUILD_VERSION=1</span><br><span class="line"><span class="built_in">export</span> KBUILD_BUILD_USER=android-build</span><br><span class="line"><span class="built_in">export</span> KBUILD_BUILD_HOST=xxx.google.com</span><br><span class="line"><span class="built_in">export</span> KBUILD_BUILD_TIMESTAMP=<span class="string">&quot;Web Feb 13 19:10:11 UTC 2019&quot;</span></span><br><span class="line">sed -i <span class="string">&quot;s/#define LINUX_COMPILER/#define LINUX_COMPILER &quot;</span><span class="string">&#x27;\\&quot;gcc version xxx-google xxx \\(prerelease\\) \\(GCC\\) \\&quot; # /&#x27;</span> scripts/mkcompile_h</span><br><span class="line">make xxx_defconfig</span><br><span class="line">make -j7 KERNELRELEASE=<span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>

<p>修改了 AOSP 源码之后，比如加了文件，哪怕在一个文件夹下，AS 开发时可以正常引用并使用里面的函数，但是编译时就是报找不到，此时要修改这个文件，将添加的文件包括进去。然后运行一次 <code>make update-api</code>。最后再 <code>m</code> 编译。</p>
<h1 id="lineage-16-0-编译"><a href="#lineage-16-0-编译" class="headerlink" title="lineage-16.0 编译"></a>lineage-16.0 编译</h1><h2 id="配置安装平台工具"><a href="#配置安装平台工具" class="headerlink" title="配置安装平台工具"></a>配置安装平台工具</h2><p>安装 <code>adb</code> 和 <code>fastboot</code> ， 可以从谷歌<a href="https://dl.google.com/android/repository/platform-tools-latest-linux.zip">下载</a>它们。提取运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip platform-tools-latest-linux.zip -d ~</span><br></pre></td></tr></table></figure>

<p>添加 <code>adb</code> 和 <code>fastboot</code> 到 <code>PATH</code> 。打开 <code>~/.profile</code> 并添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add Android SDK platform tools to path</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$HOME</span>/platform-tools&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">    PATH=<span class="string">&quot;<span class="variable">$HOME</span>/platform-tools:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>然后，运行 <code>source ~/.profile</code> 以更新环境。</p>
<h2 id="配置必须的环境"><a href="#配置必须的环境" class="headerlink" title="配置必须的环境"></a>配置必须的环境</h2><h3 id="安装必须的库"><a href="#安装必须的库" class="headerlink" title="安装必须的库"></a>安装必须的库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install bc bison build-essential ccache curl flex g++-multilib gcc-multilib git gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev liblz4-tool libncurses5 libncurses5-dev libsdl1.2-dev libssl-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev</span><br></pre></td></tr></table></figure>

<p>对于 20.04 之前的 Ubuntu 版本，需要安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install libwxgtk3.0-dev</span><br></pre></td></tr></table></figure>

<p>对于早于 16.04 的 Ubuntu 版本，请安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install libwxgtk2.8-dev</span><br></pre></td></tr></table></figure>

<h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><ul>
<li>LineageOS 16.0：OpenJDK 1.9（默认包含）</li>
<li>LineageOS 14.1-15.1：OpenJDK 1.8（安装 openjdk-8-jdk）</li>
<li>LineageOS 11.0-13.0：OpenJDK 1.7（安装 openjdk-7-jdk）</li>
</ul>
<h2 id="下载源码-1"><a href="#下载源码-1" class="headerlink" title="下载源码"></a>下载源码</h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>创建构建环境中设置一些目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p ~/bin</span><br><span class="line">$ <span class="built_in">mkdir</span> -p ~/android/lineage</span><br></pre></td></tr></table></figure>

<h3 id="安装-repo-命令"><a href="#安装-repo-命令" class="headerlink" title="安装 repo 命令"></a>安装 repo 命令</h3><p>输入以下内容以下载 repo 二进制文件并使其可执行（可运行）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">$ <span class="built_in">chmod</span> a+x ~/bin/repo</span><br></pre></td></tr></table></figure>

<p>将 <code>~/bin</code> 目录放在执行路径中，打开 <code>~/.profile</code> 文件，添加下列代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set PATH so it includes user&#x27;s private bin if it exists</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$HOME</span>/bin&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">    PATH=<span class="string">&quot;<span class="variable">$HOME</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>然后，运行 <code>source ~/.profile</code> 以更新环境。</p>
<h3 id="配置-git"><a href="#配置-git" class="headerlink" title="配置 git"></a>配置 git</h3><p>运行以下命令来配置 git 身份：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">$ git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化-LineageOS-源并下载源代码"><a href="#初始化-LineageOS-源并下载源代码" class="headerlink" title="初始化 LineageOS 源并下载源代码"></a>初始化 LineageOS 源并下载源代码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/android/lineage</span><br><span class="line">repo init -u https://github.com/LineageOS/android.git -b lineage-16.0</span><br><span class="line"></span><br><span class="line">repo <span class="built_in">sync</span></span><br></pre></td></tr></table></figure>

<h2 id="准备特定于设备的代码"><a href="#准备特定于设备的代码" class="headerlink" title="准备特定于设备的代码"></a>准备特定于设备的代码</h2><p>源代码下载后，确保您位于源代码的根目录 ( <code>cd ~/android/lineage</code>)，然后键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">breakfast sailfish</span><br></pre></td></tr></table></figure>

<p>这将下载您设备的<a href="https://github.com/LineageOS/android_device_google_sailfish">设备特定配置</a>和 <a href="https://github.com/LineageOS/android_kernel_google_marlin">内核</a>。</p>
<blockquote>
<p>有一些设备需要在 breakfast 之前准备好 vendor 目录 如果出现错误，按下面的方法提取专有 Blob，推荐使用 通过修改 <code>.repo/local_manifests/*.xml</code> 文件进行提取 。</p>
</blockquote>
<h2 id="提取专有-Blob"><a href="#提取专有-Blob" class="headerlink" title="提取专有 Blob"></a>提取专有 Blob</h2><h3 id="通过-extract-files-sh-脚本提取（不推荐）"><a href="#通过-extract-files-sh-脚本提取（不推荐）" class="headerlink" title="通过 extract_files.sh 脚本提取（不推荐）"></a>通过 <code>extract_files.sh</code> 脚本提取（不推荐）</h3><p>确保您的 Pixel 已通过 USB 电缆连接到计算机，并且已启用 ADB 和 root 身份，并且位于 <code>~/android/lineage/device/google/sailfish</code> 文件夹中。然后运行 <code>extract-files.sh</code>脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./extract-files.sh</span><br></pre></td></tr></table></figure>

<p>Blob 应被拉入 <code>~/android/lineage/vendor/google</code> 文件夹。</p>
<h3 id="通过修改-repo-local-manifests-xml-文件进行提取-推荐"><a href="#通过修改-repo-local-manifests-xml-文件进行提取-推荐" class="headerlink" title="通过修改 .repo/local_manifests/*.xml 文件进行提取(推荐)"></a>通过修改 <code>.repo/local_manifests/*.xml</code> 文件进行提取(推荐)</h3><p>在 <code>.repo/local_manifests/roomservice.xml</code> 文件中添加下列代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">clone-depth</span>=<span class="string">&quot;1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;TheMuppets/proprietary_vendor_google&quot;</span> <span class="attr">path</span>=<span class="string">&quot;vendor/google&quot;</span> <span class="attr">remote</span>=<span class="string">&quot;github&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>最终代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">&quot;LineageOS/android_device_google_sailfish&quot;</span> <span class="attr">path</span>=<span class="string">&quot;device/google/sailfish&quot;</span> <span class="attr">remote</span>=<span class="string">&quot;github&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">&quot;LineageOS/android_device_google_marlin&quot;</span> <span class="attr">path</span>=<span class="string">&quot;device/google/marlin&quot;</span> <span class="attr">remote</span>=<span class="string">&quot;github&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project</span> <span class="attr">name</span>=<span class="string">&quot;LineageOS/android_kernel_google_marlin&quot;</span> <span class="attr">path</span>=<span class="string">&quot;kernel/google/marlin&quot;</span> <span class="attr">remote</span>=<span class="string">&quot;github&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">project</span> <span class="attr">clone-depth</span>=<span class="string">&quot;1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;TheMuppets/proprietary_vendor_google&quot;</span> <span class="attr">path</span>=<span class="string">&quot;vendor/google&quot;</span> <span class="attr">remote</span>=<span class="string">&quot;github&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后执行 <code>repo sync</code> ， 最终将会 <code>~/android/lineage/vendor/google</code> 文件夹如下所示：</p>
<img src="/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/2020-06-07-11-17-46.png" class="">

<h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><h3 id="准备设备特定的代码"><a href="#准备设备特定的代码" class="headerlink" title="准备设备特定的代码"></a>准备设备特定的代码</h3><p>进入 <code>~/android/lineage</code> 目录中，运行下列命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">including device/generic/car/vendorsetup.sh</span><br><span class="line">including device/generic/mini-emulator-arm64/vendorsetup.sh</span><br><span class="line">including device/generic/mini-emulator-armv7-a-neon/vendorsetup.sh</span><br><span class="line">including device/generic/mini-emulator-x86/vendorsetup.sh</span><br><span class="line">including device/generic/mini-emulator-x86_64/vendorsetup.sh</span><br><span class="line">including device/generic/uml/vendorsetup.sh</span><br><span class="line">including device/google/marlin/vendorsetup.sh</span><br><span class="line">including vendor/lineage/vendorsetup.sh</span><br><span class="line">including sdk/bash_completion/adb.bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ breakfast sailfish</span><br><span class="line">including vendor/lineage/vendorsetup.sh</span><br><span class="line">Looking <span class="keyword">for</span> dependencies <span class="keyword">in</span> device/google/sailfish</span><br><span class="line">Looking <span class="keyword">for</span> dependencies <span class="keyword">in</span> device/google/marlin</span><br><span class="line">Looking <span class="keyword">for</span> dependencies <span class="keyword">in</span> kernel/google/marlin</span><br><span class="line">kernel/google/marlin has no additional dependencies.</span><br><span class="line"></span><br><span class="line">============================================</span><br><span class="line">PLATFORM_VERSION_CODENAME=REL</span><br><span class="line">PLATFORM_VERSION=9</span><br><span class="line">LINEAGE_VERSION=16.0-20200607-UNOFFICIAL-sailfish</span><br><span class="line">TARGET_PRODUCT=lineage_sailfish</span><br><span class="line">TARGET_BUILD_VARIANT=userdebug</span><br><span class="line">TARGET_BUILD_TYPE=release</span><br><span class="line">TARGET_ARCH=arm64</span><br><span class="line">TARGET_ARCH_VARIANT=armv8-a</span><br><span class="line">TARGET_CPU_VARIANT=kryo</span><br><span class="line">TARGET_2ND_ARCH=arm</span><br><span class="line">TARGET_2ND_ARCH_VARIANT=armv8-a</span><br><span class="line">TARGET_2ND_CPU_VARIANT=kryo</span><br><span class="line">HOST_ARCH=x86_64</span><br><span class="line">HOST_2ND_ARCH=x86</span><br><span class="line">HOST_OS=linux</span><br><span class="line">HOST_OS_EXTRA=Linux-5.3.0-53-generic-x86_64-Ubuntu-18.04.4-LTS</span><br><span class="line">HOST_CROSS_OS=windows</span><br><span class="line">HOST_CROSS_ARCH=x86</span><br><span class="line">HOST_CROSS_2ND_ARCH=x86_64</span><br><span class="line">HOST_BUILD_TYPE=release</span><br><span class="line">BUILD_ID=PQ3A.190801.002</span><br><span class="line">OUT_DIR=/media/ckcat/5670d030-468f-f443-9854-3a9e65ef901c/lineage/out</span><br><span class="line">============================================</span><br></pre></td></tr></table></figure>

<h3 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">croot</span><br><span class="line">brunch sailfish</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，如果使用的 ubuntu 20.04 进行编译，会出现 <code>prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-android-gcc: not found</code> 错误，这是有由于找不到 <code>/usr/bin/python</code> 的原因，此时安装 python 就好。</p>
</blockquote>
<h3 id="安装版本"><a href="#安装版本" class="headerlink" title="安装版本"></a>安装版本</h3><p>假设构建已完成且没有错误（完成后将很明显），请在构建运行的终端窗口中键入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$OUT</span></span><br></pre></td></tr></table></figure>

<p>在这里，您会找到所有已创建的文件。更具兴趣的两个文件是：</p>
<ul>
<li><p><code>boot.img</code>，这是 LineageOS 引导映像，并包含 recovery-ramdisk 。</p>
</li>
<li><p><code>lineage-17.1-20200605-UNOFFICIAL-sailfish.zip</code>，这是 LineageOS 安装程序包。</p>
</li>
</ul>
<img src="/2019/11/03/Android%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/2020-06-07-11-23-55.png" class="">

<p>成功!</p>
<h2 id="刷机-1"><a href="#刷机-1" class="headerlink" title="刷机"></a>刷机</h2><p>重启手机至 bootloader 模式，刷入 recovery 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启至 bootloader</span></span><br><span class="line">$ adb reboot bootloader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷入 recovery</span></span><br><span class="line">$ flash boot boot.img</span><br></pre></td></tr></table></figure>

<p>然后重启至 recovery 模式。选择 <strong>Apply update</strong> -&gt; <strong>Apply from ADB</strong> 再执行下列命令刷机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb sideload lineage-17.1-20220317-UNOFFICIAL-sailfish.zip</span><br></pre></td></tr></table></figure>

<p>如果需要格式化手机内的数据，则需要先选择 <strong>Factory Reset</strong> -&gt; <strong>Format data&#x2F;factory reset</strong> -&gt; <strong>Format data</strong> ，等待格式化完成，最后再安装上面的方式刷入系统即可。</p>
<p>参考：</p>
<blockquote>
<p><a href="https://wiki.lineageos.org/devices/sailfish/build">https://wiki.lineageos.org/devices/sailfish/build</a> &gt; <a href="https://www.reddit.com/r/LineageOS/comments/bjo6v3/error_building_lineageos/">https://www.reddit.com/r/LineageOS/comments/bjo6v3/error_building_lineageos/</a> &gt; <a href="https://wiki.lineageos.org/devices/sailfish/install">https://wiki.lineageos.org/devices/sailfish/install</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android系统编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder从入门到放弃（框架篇）</title>
    <url>/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>转载：<a href="https://blog.csdn.net/feelabclihu/article/details/105534145">https://blog.csdn.net/feelabclihu/article/details/105534145</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Binder</code> 从入门到放弃包括了上下篇，上篇是框架部分，即本文。下篇通过几个典型的 <code>binder</code> 通信过程来呈现其实现细节，稍后发布，敬请期待。</p>
<h1 id="一、什么是Binder？"><a href="#一、什么是Binder？" class="headerlink" title="一、什么是Binder？"></a>一、什么是Binder？</h1><p><code>Binder</code> 是安卓平台上的一种 <code>IPC framework</code> ，其整体的架构如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-22-17.png" class="">

<p><code>Binder</code> 渗透到了安卓系统的各个软件层次：在应用层，利用 <code>Framework</code> 中的 <code>binder Java</code> 接口，开发者可以方便的申请系统服务提供的服务、实现自定义 <code>Service</code> 组件并开放给其他模块等。由于 <code>Native</code> 层的 <code>binder</code> 库使用的是 <code>C++</code> ，因此安卓框架中的 <code>Binder</code> 模块会通过 <code>JNI</code> 接口进入 <code>C/C++</code> 世界。在最底层， <code>Linux</code> 内核提供了 <code>binder</code> 驱动，完成进程间通信的功能。</p>
<p><code>Binder</code> 对安卓非常重要，绝大多数的进程通信都是通过 <code>Binder</code> 完成。 <code>Binder</code> 采用了 <code>C/S</code> 的通信形式：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-23-06.png" class="">

<p>从进程角度看，参与 <code>Binder</code> 通信的实体有三个：<code>binder client</code> 、 <code>binder server</code> 和 <code>service manager</code> 。 <code>Binder server</code> 中的 <code>service</code> 组件对外提供了服务，但是需要对外公布，因此它会向 <code>service manager</code> 注册自己的服务。 <code>Binder client</code> 想要请求服务的时候统一到 <code>service manager</code> 去查询，获取了对应的描述符后即可以通过该描述符和 <code>service</code> 组件进行通信。当然，这些 <code>IPC</code> 通信并不是直接在 <code>client</code> 、 <code>server</code> 和 <code>service manager</code> 之间进行的，而都是需要通过 <code>binder driver</code> 间接完成。</p>
<p>安卓应用程序开发是基于组件的，也就是说通过四大组件（ <code>Activity</code> 、 <code>Service</code> 、 <code>Broadcast Receiver</code> 和 <code>Content Provider</code> ），开发者可以象搭积木一样的轻松开发应用程序，而无需关心底层实现。然而安卓这种面向对象的应用框架环境却是基于传统的 <code>Linux</code> 内核构建的，这使得安卓在进程间通信方面遇到了新的挑战，这也就是为何谷歌摒弃了传统的内核 <code>IPC</code> 机制（管道、命名管道、 <code>domain socket</code> 、 <code>UDP/TCP socket</code> 、 <code>system V IPC</code> ， <code>share memory</code> 等），建立了全新的 <code>binder</code> 通信形式，具体细节我们下一章分解。</p>
<h1 id="二、为什么是Binder？"><a href="#二、为什么是Binder？" class="headerlink" title="二、为什么是Binder？"></a>二、为什么是Binder？</h1><p>在上一节中，我们简单的描述了 <code>binder</code> 的 <code>C/S</code> 通信模型，在内核已经提供了 <code>socket</code> 形态的 <code>C/S</code> 通信机制的情况下，在安卓系统上直接使用 <code>socket</code> 这种 <code>IPC</code> 机制似乎是顺理成章的，为何还要重新制作一个新的轮子呢？是否需要新建轮子其实是和需求相关的，下面我们会仔细分析安卓系统上，组件之间 <code>IPC</code> 机制的需求规格，从而窥视谷歌创建全新 <code>binder</code> 通信机制背后的原因。</p>
<h2 id="1、安卓系统需要的是一个IPC框架"><a href="#1、安卓系统需要的是一个IPC框架" class="headerlink" title="1、安卓系统需要的是一个IPC框架"></a>1、安卓系统需要的是一个IPC框架</h2><p>为了提高软件生产效率，安卓的应用框架希望能够模糊进程边界，即在 A 组件调用 B 组件的方法的时候，程序员不需要考虑是否跨进程。即便是在不同的进程中，对 B 组件的服务调用仍然象本地函数调用一样简单。传统 <code>Linux</code> 内核的 <code>IPC</code> 机制是无法满足这个需求的，安卓需要一个复杂的 <code>IPC framework</code> 能够支持线程池管理、自动跟踪引用计数等有挑战性的任务。</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-23-49.png" class="">

<p>当然，基于目前 <code>Linux</code> 内核的 <code>IPC</code> 机制，也可以构建复杂的 <code>IPC framework</code> ，不过传统的内核 <code>IPC</code> 机制并没有考虑面向对象的应用框架，因此很多地方实现起来有些水土不服。上图给了一个简单的例子：在一个地址空间中跟踪对象的引用计数非常简单，可以在该对象内部构建一个引用计数，每当有本进程对象引用 <code>service</code> 组件对象的时候，引用计数加一，不再引用的时候减一，没有任何对象引用 <code>service</code> 组件对象的时候，该对象可以被销毁。不过，当引用该 <code>service</code> 组件的代理对象来自其他进程空间（例如 <code>binder client</code> 的组件代理对象）的时候，事情就不那么简单了，这需要一个复杂的 <code>IPC framework</code> 来小心的维护组件对象的引用计数，否则在 <code>server</code> 端销毁了一个组件对象，而实际上有可能在 <code>client</code> 端还在远程调度该 <code>service</code> 组件提供的服务。</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-24-18.png" class="">

<p>为了解决这个问题， <code>binder</code> 驱动构建了 <code>binder ref</code> 和 <code>binder node</code> 数据对象，分别对应到上层软件中的 <code>service</code> 组件代理和 <code>service</code> 组件对象，同时也设计了相应的 <code>binder</code> 通信协议来维护引用计数，解决了传统的 <code>IPC</code> 机制很难解决的跨进程对象生命周期问题。</p>
<h2 id="2、安卓系统需要的是高效IPC机制"><a href="#2、安卓系统需要的是高效IPC机制" class="headerlink" title="2、安卓系统需要的是高效IPC机制"></a>2、安卓系统需要的是高效IPC机制</h2><p>我们再看一下性能方面的需求：由于整个安卓系统的进程间通信量比较大，我们希望能有一个性能卓越的 <code>IPC</code> 机制。大部分传统 <code>IPC</code> 机制都需要两次拷贝容易产生性能问题。而 <code>binder</code> 只进行了一次拷贝，性能优于大部分的传统 <code>IPC</code> 机制，除了 <code>share memory</code> 。当然，从内存拷贝的角度看，<code>share memory</code> 优于 <code>binder</code> ，但实际上如果基于 <code>share memory</code> 设计安卓的 <code>IPC framework</code> ，那么还是需要构建复杂的同步机制，这也会抵消 <code>share memory</code> 部分零拷贝带来性能优势，因此 <code>Binder</code> 并没有选择共享内存方案，而是在简单和性能之间进行了平衡。在 <code>binder</code> 机制下，具体的内存拷贝如下图所示：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-24-46.png" class="">

<p><code>binder server</code> 会有专门二段用于 <code>binder</code> 通信的虚拟内存区间，一段在内核态，一段在用户空间。这两段虚拟地址空间映射到同样的物理地址上，当拷贝数据到 <code>binder server</code> 的内核态地址空间，实际上用户态也就可以直接访问了。当 <code>Binder client</code> 要把一个数据块传递到 <code>binder server</code>（通过 <code>binder transaction</code> ）的时候，实际上会在 <code>binder server</code> 的内核虚拟地址空间中分配一块内存，并把 <code>binder client</code> 的用户地址空间的数据拷贝到 <code>binder server</code> 的内核空间。因为 <code>binder server</code> 的 <code>binder</code> 内存区域被同时映射到用户空间和内核空间，因此就可以省略一次数据考虑，提高了性能。</p>
<p>并不是说安卓不使用共享内存机制，实际上当进程之间要传递大量的数据的时候（例如 APP 的图形数据要传递到 <code>surfaceflinger</code> 进行实际的显示）还是使用了 <code>share memory</code> 机制（ <code>Ashmem</code> ）。安卓使用文件描述符来标示一块匿名共享内存， <code>binder</code> 机制可以把文件描述符从一个进程传递到另外的进程，完成文件的共享。一个简单的示意图如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-25-08.png" class="">

<p>在上图中， <code>binder client</code> 传递了 <code>fd x</code> （ <code>binder client</code> 有效的描述符）到 <code>binder server</code> ，实际上 <code>binder</code> 驱动会通过既有的内核找到对应的 <code>file object</code> 对象，然后在 <code>binder server</code> 端找到一个空闲的<code>fd y</code>（ <code>binder server</code> 进程有效），让其和 <code>binder client</code> 指向同一个对象。这个 <code>binder client</code> 传递了 <code>fd x</code> 到 <code>binder server</code> ，在 <code>server</code> 端变成 <code>fd y</code> 并实现了和 <code>client</code> 进程中 <code>fd x</code> 指向同一个文件的目标。而传统的 <code>IPC</code> 机制（除了 <code>socket</code> ）没有这种机制。</p>
<h2 id="3、安卓系统需要的是稳定的IPC机制"><a href="#3、安卓系统需要的是稳定的IPC机制" class="headerlink" title="3、安卓系统需要的是稳定的IPC机制"></a>3、安卓系统需要的是稳定的IPC机制</h2><p>数据传输形态（非共享内存）的 <code>IPC</code> 机制有两种形态：<code>byte stream</code> 和 <code>message-based</code> 。如果使用字节流形态的方式（例如 <code>PIPE</code> 或者 <code>socket</code> ），那么对于 <code>reader</code> 一侧，我们需要在内核构建一个 <code>ring buffer</code> ，把 <code>writer</code> 写入的数据拷贝到 <code>reader</code> 的这个环形缓冲区。而在 <code>reader</code> 一侧的，如何管理这个 <code>ring buffer</code> 是一个头疼的事情。因此 <code>binder</code> 采用了 <code>message-based</code> 的形态，并形成了如下的缓冲区管理方式：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-25-35.png" class="">

<p>需要进行 <code>Binder</code> 通信的两个进程传递结构化的 <code>message</code> 数据，根据 <code>message</code> 的大小在内核分配同样大小的 <code>binder</code> 缓冲区（从 <code>binder</code> 内存区中分配，内核用 <code>binder alloc</code> 对象来抽象），并完成用户空间到内核空间的拷贝。 <code>Binder server</code> 在用户态的程序直接可以访问到 <code>binder buffer</code> 中的 <code>message</code> 数据。</p>
<p>从内存管理的角度来看，这样的方案是一个稳定性比较高的方案。每个进程可以使用的 <code>binder</code> 内存是有限制的，一个进程不能使用超过 <code>1M</code> 的内存，杜绝了恶意 APP 无限制的通过 <code>IPC</code> 使用内存资源。此外，如果撰写 <code>APP</code> 的工程师不那么谨慎，有些传统的 <code>Linux IPC</code> 机制容易导致内存泄露，从而导致系统稳定性问题。同样的，如果对通信中的异常（例如 <code>server</code> 进程被杀掉）没有有良好的处理机制，也会造成稳定性问题。 <code>Binder</code> 通信机制提供了 <code>death-notification</code> 机制，优雅的处理了通信两端异常退出的异常，增强了系统的稳定性。</p>
<h2 id="4、安卓系统需要的是安全的IPC机制"><a href="#4、安卓系统需要的是安全的IPC机制" class="headerlink" title="4、安卓系统需要的是安全的IPC机制"></a>4、安卓系统需要的是安全的IPC机制</h2><p>从安全性（以及稳定性）的角度，各个安卓应用在自己的 <code>sandbox</code> 中运行并用一个系统唯一的 <code>id</code> 来标示该应用（ <code>uid</code> ）。由于 APP 和系统服务进程是完全隔离的，安卓设计了 <code>transaction-based</code> 的进程间通信机制： <code>binder</code> ， APP 通过 <code>binder</code> 请求系统服务。由于 <code>binder driver</code> 隔离了通信的两段进程。因此实际上在 <code>binder driver</code> 中是最好的一个嵌入安全检查的地方，具体可以参考下面的安全检查机制示意图：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-26-08.png" class="">

<p>安卓是一个开放的系统，因此安全性显得尤为重要。在安卓世界， <code>uid</code> 用来标示一个应用，在内核（而非用户空间）中附加 <code>UID/PID</code> 标识并在具体提供服务的进程端进行安全检查，主要体现在下面两个方面：</p>
<ol>
<li><p>系统提供了唯一的上下文管理者：<code>service manager</code> 并且只有信任的 <code>uid</code> 才能注册 <code>service</code> 组件。</p>
</li>
<li><p>系统把特定的资源权限赋权给 <code>Binder server</code> （ <code>service</code> 组件绑定的进程），当 <code>binder client</code> 请求服务的时候对 <code>uid</code> 进行安全检查。</p>
</li>
</ol>
<p>传统的 <code>IPC</code> 机制在内核态并不支持 <code>uid/pid</code> 的识别，通过上层的通信协议增加发起端的 <code>id</code> 并不安全，而且传统的 <code>IPC</code> 机制没有安全检查机制，这种情况下任何人都可以撰写恶意 APP 并通过 <code>IPC</code> 访问系统服务，获取用户隐私数据。</p>
<p>解决了 what 和 why 之后，我们后续的章节将主要讲述 <code>binder</code> 的软件框架和通信框架，在了解了蓝图之后，我们再深入到 <code>binder</code> 是如何在各种场景下工作的。随着 <code>binder</code> 场景解析，我们也顺便描述了 <code>binder</code> 驱动中的主要数据结构。</p>
<h1 id="三、Binder软件框架和通信框架"><a href="#三、Binder软件框架和通信框架" class="headerlink" title="三、Binder软件框架和通信框架"></a>三、Binder软件框架和通信框架</h1><h2 id="1、软件框架"><a href="#1、软件框架" class="headerlink" title="1、软件框架"></a>1、软件框架</h2><p>一个大概的软件结构如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-26-49.png" class="">

<p>所有的通信协议都是分层的， <code>binder</code> 也不例外，只不过简单一些。 <code>Binder</code> 通信主要有三层：应用层，<code>IPC</code> 层，内核层。如果使用 <code>Java</code> 写应用，那么 <code>IPC</code> 层次要更丰富一些，需要通过 <code>Java layer</code> 、 <code>jni</code> 和 <code>Native IPC layer</code> 完成所有的 <code>IPC</code> 通信过程。如果使用 <code>C++</code> 在 <code>Native</code> 层写应用，那么基本上 <code>BpBinder</code> 和 <code>BBinder</code> 这样的 <code>Native IPC</code> 机制就足够了，这时候，软件结构退化成（后续我们基本上是基于这个软件结构描述）：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-27-14.png" class="">

<p>对于应用层而言，互相通信的实体交互的是类似 <code>start activity</code> 、 <code>add service</code> 这样的应用相关的协议数据，通信双方并不知道底层实现，感觉它们之间是直接通信似得。而实际上，应用层数据是通过 <code>Native IPC</code> 层、 <code>kerenl</code> 层的封装，解析，映射完成了最后的通信过程。在 <code>Native IPC</code> 层， <code>BpBinder</code> 和 <code>BBinder</code> 之间通信之间的封包有自己的格式，<code>IPC header</code> 会标记通信的起点和终点（ <code>binder ref</code> 或者 <code>binder node</code> ）、通信类型等信息，而应用层数据只是 <code>IPC</code> 层的 <code>payload</code> 。同样的，表面上是 <code>BpBinder</code> 和 <code>BBinder</code> 两个实体在交互 <code>IPC</code> 数据，实际上需要底层 <code>binder driver</code> 提供通信支持。</p>
<h2 id="2、通信框架"><a href="#2、通信框架" class="headerlink" title="2、通信框架"></a>2、通信框架</h2><p>分别位于 <code>binder client</code> 和 <code>server</code> 中的应用层实体进行数据交互的过程交过 <code>transaction</code> ，当然，为了保证 <code>binder transaction</code> 能够正确、稳定的完成， <code>binder</code> 代理实体、 <code>binder</code> 实体以及 <code>binder driver</code> 之间需要进行非常复杂的操作，因此 <code>binder</code> 通信定义了若干的通信协议码，下面表格列出了几个常用的 <code>binder</code> 实体或者 <code>binder</code> 代理实体发向 <code>binder driver</code> 的通信协议码：</p>
<table>
<thead>
<tr>
<th>Binder command code</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>BC_TRANSACTION</code></td>
<td><code>Binder</code> 代理实体请求数据通信服务</td>
</tr>
<tr>
<td><code>BC_REPLY</code></td>
<td><code>Binder</code> 实体完成了服务请求的回应</td>
</tr>
<tr>
<td><code>BC_INCREFS</code> <code>BC_DECREFS</code></td>
<td>管理 <code>binder ref</code> 的引用计数</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
<p>下面的表格列出了几个常用的 <code>binder driver</code> 发向 <code>binder</code> 实体或者 <code>binder</code> 代理实体的通信协议码：</p>
<table>
<thead>
<tr>
<th>Binder response code</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>BR_TRANSACTION</code></td>
<td><code>Binder driver</code> 收到 <code>transaction</code> 请求，将其转发给 <code>binder</code> 实体对象</td>
</tr>
<tr>
<td><code>BR_REPLY</code></td>
<td><code>Binder driver</code> 通知 <code>binder</code> 代理实体， <code>server</code> 端已经完成服务请求，返回结果。</td>
</tr>
<tr>
<td><code>BR_TRANSACTION_COMPLETE</code></td>
<td><code>Binder driver</code> 通知 <code>binder</code> 代理实体，它发出的 <code>transaction</code> 请求已经收到。或者 <code>Binder driver</code> 通知 <code>binder</code> 实体，它发出的 <code>transaction reply</code> 已经收到。</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
<p><code>Binder</code> 通信的形态很多种，有些只涉及 <code>binder server</code> 中的实体对象和 <code>binder driver</code> 的交互。例如： <code>BC_REGISTER_LOOPER</code> 。不过使用最多、过程最复杂的还是传递应用数据的 <code>binder transaction</code> 过程，具体如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-30-20.png" class="">


<p><code>Binder client</code> 和 <code>server</code> 之间的进程间通信实际上是通过 <code>binder driver</code> 中转的。在这样的通信框架中，<code>client/server</code> 向 <code>binder driver</code> 发送 <code>transaction/reply</code> 是直接通过 <code>ioctl</code> 完成的，而相反的方向， <code>binder driver</code> 向 <code>client/server</code> 发送的 <code>transaction/reply</code> 则有些复杂，毕竟在用户空间的 <code>client/server</code> 不可能不断的轮询接收数据。正因为如此，在 <code>binder</code> 通信中有了 <code>binder work</code> 的概念，具体的方式如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-30-56.png" class="">

<p>对于 <code>binder transaction</code> 这个场景， <code>Binder work</code> 对象是嵌入在 <code>transaction</code> 对象内的， <code>binder driver</code> 在把 <code>transaction</code> （服务请求）送达到 <code>target</code> 的时候需要做两个动作：</p>
<ol>
<li><p>选择一个合适的 <code>binder work</code> 链表把本 <code>transaction</code> 相关的 <code>work</code> 挂入链表。</p>
</li>
<li><p>唤醒 <code>target process</code> 或者 <code>target thread</code> 。</p>
</li>
</ol>
<p>对于异步 <code>binder</code> 通信， <code>work</code> 是挂入 <code>binder node</code> 对应的 <code>work</code> 链表。如果是同步 <code>binder</code> 通信，那么要看是否能够找到空闲的 <code>binder thread</code> ，如果找到那么挂入线程的 <code>work todo list</code> ，否则挂入 <code>binder process</code> 的链表。</p>
<h2 id="3、应用层通信数据格式"><a href="#3、应用层通信数据格式" class="headerlink" title="3、应用层通信数据格式"></a>3、应用层通信数据格式</h2><p>本身应用层的数据应该是通信两端的实体自己的事情，不过由于需要交互 <code>binder</code> 实体对象信息，因此这里也简单描述其数据格式，如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-31-40.png" class="">

<p><code>Binder Client</code> 和 <code>server</code> 之间通信的基本单元是 应用层的数据 + 相关的 <code>binder</code> 实体对象数据 ，这个基本的单元可以是 1 个或者多个。为了区分开各个基本的单元，在应用层数据缓冲区的尾部有一个数组保存了各个 <code>binder</code> 实体对象的位置。每一个 <code>binder</code> 实体用 <code>flat_binder_object</code> 来抽象，主要的成员包括：</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>说明该 binder 实体的类型，可能的类型包括：本地 binder 实体对象、远端 binder 实体对象（ handle ）、文件描述符</td>
</tr>
<tr>
<td>binder_uintptr_t binder</td>
<td>描述本地 binder 实体对象</td>
</tr>
<tr>
<td>__u32 handle</td>
<td>描述远端 binder 实体对象</td>
</tr>
<tr>
<td>binder_uintptr_t cookie</td>
<td>描述本地 binder 实体对象</td>
</tr>
</tbody></table>
<p>我们这里可以举一个简单的例子：假设我们写了一个 APP ，实现了一个 xxx 服务组件，在向 <code>service manager</code> 注册的时候就需要发起一次 <code>transaction</code> ，这时候缓冲区的数据就包括了上面图片中的应用层数据和一个 xxx 服务组件对应的 <code>binder</code> 实体对象。这时候应用层数据中会包括 <code>xxx service</code> 这样的字符串信息，这是方便其他 <code>client</code> 可以通过这个字符串来寻址到本 <code>service</code> 组件必须要的信息。除了应用层数据之外，还需要传递 <code>xxx service</code> 组件对应的 <code>binder</code> 实体。上面的例子说的是注册 <code>service</code> 组件的场景，因此传递的是本地 <code>binder</code> 实体对象。如果场景切换成 <code>client</code> 端申请服务的场景，这时候没有本地对象，因此需要传递的是远端的 <code>binder</code> 实体对象，即 <code>handle</code> 。因此 <code>flat_binder_object</code> 描述的是 <code>transaction</code> 相关的 <code>binder</code> 实体对象，可能是本地的，也可能是远端的。</p>
<h2 id="4、Binder帧数据格式"><a href="#4、Binder帧数据格式" class="headerlink" title="4、Binder帧数据格式"></a>4、Binder帧数据格式</h2><p><code>Binder IPC</code> 层的数据格式如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-34-35.png" class="">

<p><code>Binder IPC</code> 层看到的帧数据单元是 协议码 + 协议码数据 ，一个完整的帧数据是由一个或者多个帧数据单元组成。协议码区域就是上文中描述的 <code>BC_XXX</code> 和 <code>BR_XXX</code> ，不同的协议码有不同的协议码数据，同样的我们采用 <code>binder transaction</code> 为例说明协议码数据区域。 <code>BR_TRANSACTION</code> 、 <code>BR_REPLY</code> 、 <code>BC_TRANSACTION</code> 和 <code>BC_REPLY</code> 这四个协议码的数据都是 <code>binder_transaction_data</code> ，和应用层的数据关系如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-35-03.png" class="">

<p><code>Binder transaction</code> 信息包括：本次通信的目的地、<code>sender pid</code> 和 <code>uid</code> 等通用信息，此外还有一些成员描述应用层的数据 <code>buffer</code> 信息，具体大家可以参考源代码。顺便提一句的是这里的 <code>sender pid</code> 和 <code>uid</code> 都是内核态的 <code>binder driver</code> 附加的，用户态的程序无法自己标记，从而保证了通信的安全性。</p>
<p>了解了整体框架之后，我们后面的章节将进入细节，通过几个典型 <code>binder</code> 通信场景的分析来加强对 <code>binder</code> 通信的理解，这些将在下篇文档中呈现，敬请期待！</p>
<p>参考文献：</p>
<p>1.Android系统源代码情景分析，罗升阳著</p>
<p>2.<a href="http://gityuan.com/tags/#binder">http://gityuan.com/tags/#binder</a> ，袁辉辉的博客</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder从入门到放弃（细节篇）</title>
    <url>/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>转载：<a href="https://blog.csdn.net/feelabclihu/article/details/105534146">https://blog.csdn.net/feelabclihu/article/details/105534146</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Binder</code> 从入门到放弃包括了上下篇，上篇是框架部分，下篇通过几个典型的 <code>binder</code> 通信过程来呈现其实现细节，即本文。</p>
<h1 id="一、启动-service-manager"><a href="#一、启动-service-manager" class="headerlink" title="一、启动 service manager"></a>一、启动 service manager</h1><h2 id="1-流程"><a href="#1-流程" class="headerlink" title="1. 流程"></a>1. 流程</h2><p><code>Service manager</code> 进程和 <code>binder</code> 驱动的交互如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-39-43.png" class="">

<p>在安卓系统启动过程中， <code>init</code> 进程会启动 <code>service manager</code> 进程。<code>service manager</code> 会打开 <code>/dev/binder</code> 设备，一个进程打开 <code>binder</code> 设备就意味着该进程会使用 <code>binder</code> 这种 <code>IPC</code> 机制，这时候在内核态会相应的构建一个 <code>binder proc</code> 对象，来管理该进程相关的 <code>binder</code> 资源（ <code>binder ref</code> 、 <code>binder node</code> 、 <code>binder thread</code> 等）。为了方便 <code>binder</code> 内存管控，这时候还会映射一段 128K 的内存地址用于 <code>binder</code> 通信。之后 <code>service manager</code> 会把自己设定为 <code>context manager</code> 。所谓 <code>context manager</code> 实际上就是一个“名字服务器”，可以完成 <code>service</code> 组件名字的解析。随后 <code>service manager </code>会通过 <code>binder</code> 协议（ <code>BC_ENTER_LOOPER</code> ）告知驱动自己已经准备好接收请求了。最后 <code>service manager</code> 会进入读阻塞状态，等待来自其他进程的服务请求。</p>
<p>完成上面的一系列操作之后，内核相关的数据结构如下所示：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-40-15.png" class="">

<p>由于 <code>Service manager</code> 也算是一个特殊的 <code>service</code> 组件，因此在内核态也有一个 <code>binder node</code> 对象与之对应。 <code>service manager</code> 和其他的 <code>service</code> 组件不同的是它没有使用线程池模型，而是一个单线程的进程，因此它在内核态只有一个 <code>binder proc</code> 和 <code>binder thread</code> 。整个系统系统只有一个 <code>binder context</code> ，系统中所有的 <code>binder proc</code> 都指向这个全局唯一的 <code>binder</code> 上下文对象。而找到了 <code>binder context</code> 也就找到了 <code>service manager</code> 对应的 <code>binder node</code> 。</p>
<p><code>binder proc</code> 使用了红黑树来管理其所属的 <code>binder thread</code> 和 <code>binder node</code> ，不过在 <code>Service manager</code> 这个场景中， <code>binder proc</code> 只管理了一个 <code>binder thread</code> 和 <code>binder node</code> ，看起来似乎有些小题大做，不过在其他场景（例如 <code>system server</code> ）中，<code>binder proc</code> 会创建线程池，也可能注册多个 <code>service</code> 组件。</p>
<h2 id="2-相关数据结构"><a href="#2-相关数据结构" class="headerlink" title="2. 相关数据结构"></a>2. 相关数据结构</h2><p>在内核态，每一个参与 <code>binder</code> 通信的进程都会用一个唯一的 <code>struct binder_proc</code> 对象来表示。 <code>struct binder_proc</code> 主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>struct hlist_node proc_node</td>
<td>系统中的所有 binder proc 挂入 binder_procs 的链表中，这个成员是挂入全局 binder_procs 的链表的节点</td>
</tr>
<tr>
<td>struct rb_root threads</td>
<td>binder 进程对应的所有 binder thread 组成的红黑树， tid 作为 key</td>
</tr>
<tr>
<td>struct rb_root nodes</td>
<td>一个 binder 进程可以注册多个 service 组件，因此 binder proc 可以有很多的 binder node 。 Binder proc 对应的所有 binder node 组成一颗红黑树。当然对于 service manager 而言，它只有一个 binder node 。</td>
</tr>
<tr>
<td>struct list_head waiting_threads</td>
<td>该 binder 进程的线程池中等待处理 binder work 的 binder thread 链表</td>
</tr>
<tr>
<td>int pid</td>
<td>进程 ID</td>
</tr>
<tr>
<td>struct task_struct *tsk</td>
<td>指向该 binder 进程对应的进程描述符（指向 thread group leader 对应的 task struct ）</td>
</tr>
<tr>
<td>struct list_head todo</td>
<td>需要该 binder 进程处理的 binder work 链表</td>
</tr>
<tr>
<td>int max_threads</td>
<td>线程池中运行的最大数目</td>
</tr>
<tr>
<td>struct binder_alloc alloc</td>
<td>管理 binder 内存分配的数据结构</td>
</tr>
<tr>
<td>struct binder_context *context</td>
<td>保存 binder 上下文管理者的信息。通过 binder context 可以找到 service manager 对应的 bind node 。</td>
</tr>
</tbody></table>
<p>和进程抽象类似，<code>binder proc</code> 也是管理 <code>binder</code> 资源的实体，但是真正执行 <code>binder</code> 通信的实体是 <code>binder thread</code> 。<code>struct binder_thread</code> 主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>struct binder_proc *proc</td>
<td>该 binder thread 所属的 binder proc</td>
</tr>
<tr>
<td>struct rb_node rb_node</td>
<td>挂入 binder proc 红黑树的节点</td>
</tr>
<tr>
<td>struct list_head waiting_thread_node</td>
<td>无事可做的时候， binder thread 会挂入 binder proc 的等待队列</td>
</tr>
<tr>
<td>int pid</td>
<td>Thread id</td>
</tr>
<tr>
<td>struct binder_transaction *transaction_stack</td>
<td>该 binder thread 正在处理的transaction</td>
</tr>
<tr>
<td>struct list_head todo</td>
<td>需要该 binder 线程处理的 binder work 链表</td>
</tr>
<tr>
<td>struct task_struct *task</td>
<td>该 binder thread 对应的进程描述符</td>
</tr>
</tbody></table>
<p><code>Binder node</code> 是用户空间 <code>service</code> 组件对象的内核态实体对象， <code>struct binder_node</code> 主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>struct rb_node rb_node;</td>
<td>一个 binder proc 可能有多个 service 组件（提供多种服务），属于一个 binder proc 的 binder node 会挂入 binder proc 的红黑树，这个成员是嵌入红黑树的节点。</td>
</tr>
<tr>
<td>struct binder_proc *proc</td>
<td>该 binder node 所属的 binder proc</td>
</tr>
<tr>
<td>int debug_id</td>
<td>唯一标示该 node 的 id ，用于调试</td>
</tr>
<tr>
<td>struct hlist_head refs</td>
<td>一个 service 组件可能会有多个 client 发起服务请求，也就是说每一个 client 都是对 binder node 的一次引用，这个成员是就是保存 binder ref 的哈希表</td>
</tr>
<tr>
<td>binder_uintptr_t ptr </br>binder_uintptr_t cookie</td>
<td>指向用户空间 service 组件相关的信息</td>
</tr>
<tr>
<td>u8 sched_policy:2; </br>u8 inherit_rt:1; </br>u8 min_priority;</td>
<td>这些属性定义了该 service 组件在处理 transaction 的时候优先级的设定。</td>
</tr>
<tr>
<td>bool has_async_transaction</td>
<td>是否有异步通信需要处理</td>
</tr>
<tr>
<td>struct list_head async_todo</td>
<td>异步 binder 通信的队列</td>
</tr>
</tbody></table>
<h1 id="二、client-如何找到-service-manager-？"><a href="#二、client-如何找到-service-manager-？" class="headerlink" title="二、client 如何找到 service manager ？"></a>二、client 如何找到 service manager ？</h1><h2 id="1、流程"><a href="#1、流程" class="headerlink" title="1、流程"></a>1、流程</h2><p>为了完成 <code>service</code> 组件注册， <code>Client</code> 需要首先定位 <code>service manager</code> 组件。在 <code>client</code> 这个 <code>binder process</code> 中，我们使用 <code>handle</code> 作为地址来标记 <code>service</code> 组件。<code>Service manager</code> 比较特殊，对任何一个 <code>binder process</code> 而言， <code>handle</code> 等于 0 的那个句柄就是指向 <code>service manager</code> 组件。对内核态 <code>binder</code> 驱动而言，寻找 <code>service manager</code> 实际上就是寻找其对应的 <code>binder node</code> 。下面是一个 <code>binder client</code> 向 <code>service manager</code> 请求注册服务的过程示例，我们重点关注 <code>binder</code> 驱动如何定位 <code>service manager</code> ：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-46-02.png" class="">

<p>想要访问 <code>service manager</code> 的进程需要首先打开 <code>binder driver</code> ，这时候内核会创建该进程对应的 <code>binder proc</code> 对象，并建立 <code>binder proc</code> 和 <code>context manager</code> 的关系，这样进一步可以找到 <code>service manager</code> 对应的 <code>binder node</code> 。随后， <code>client</code> 进程会调用 <code>mmap</code> 映射了（ 1M-8K ）的 <code>binder</code> 内存空间。之所以映射这么怪异的内存 <code>size</code> 主要是为了有效的利用虚拟地址空间（ <code>VMA</code> 之间有 4K 的 <code>gap</code> ）。完成上面两步操作之后，<code>client process</code> 就可以通过 <code>ioctl</code> 向 <code>service manager</code> 发起 <code>transaction</code> 请求了，同时告知目标对象 <code>handle</code> 等于 0 。</p>
<p>实际上这个阶段的主要工作在用户空间，主要是 <code>service manager</code> 组件代理 <code>BpServiceManager</code> 以及 <code>BpBinder</code> 的创建过程。一般的通信过程需要为组件代理对象分配一个句柄，但是 <code>service manager</code> 访问比较特殊，对于每一个进程，等于 0 的句柄都保留给了 <code>service manager</code> ，因此这里就不需要分配句柄这个过程了。</p>
<h2 id="2、路由过程"><a href="#2、路由过程" class="headerlink" title="2、路由过程"></a>2、路由过程</h2><p>在 <code>binder C/S</code> 通信结构中， <code>binder client</code> 中的 <code>BpBinder</code> 找到 <code>binder server</code> 中的 <code>BBinder</code> 的过程需要如下过程：</p>
<ol>
<li><p><code>binder client</code> 用户空间中的 <code>service</code> 组件代理（ <code>BpBinder</code> ）用句柄表示要访问的 <code>server</code> 中的 <code>service</code> 组件（ <code>BBinder</code> ）。</p>
</li>
<li><p>对于每一个句柄， <code>binder client</code> 内核空间使用 <code>binder ref</code> 对象与之对应。</p>
</li>
<li><p><code>binder ref</code> 对象会指向一个 <code>binder node</code> 对象。</p>
</li>
<li><p><code>binder node</code> 对象对应一个 <code>binder server</code> 进程的 <code>service</code> 组件。</p>
</li>
</ol>
<p>在我们这个场景中， <code>binder ref</code> 是在 <code>client</code> 第一次通过 <code>ioctl</code> 和 <code>binder</code> 驱动交互时候完成的。这时候 <code>binder</code> 驱动的 <code>binder_ioctl</code> 函数中会建立上面路由过程需要的完整的数据对象：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-46-47.png" class="">

<p><code>Service manager</code> 的路由比较特殊，没有采用 <code>binder ref---&gt;binder node</code> 的过程。在 <code>binder</code> 驱动中，看到 0 号句柄自然就知道是去往 <code>service manager</code> 的请求。因此，通过 <code>binder proc---&gt;binder context-----binder node</code> 这条路径就找到了 <code>service manager</code> 。</p>
<h1 id="三、注册-Service-组件"><a href="#三、注册-Service-组件" class="headerlink" title="三、注册 Service 组件"></a>三、注册 Service 组件</h1><h2 id="1-流程-1"><a href="#1-流程-1" class="headerlink" title="1. 流程"></a>1. 流程</h2><p>上一节描述了 <code>client</code> 如何找到 <code>service manager</code> 的过程，这是整个注册 <code>service</code> 组件的前半部分，这一节我们补全整个流程。由于 <code>client</code> 和 <code>service manager</code> 都完成了 <code>open</code> 和 <code>mmap</code> 的过程，双方都准备好，后续可以通过 <code>ioctl</code> 进行 <code>binder transaction</code> 的通信过程了，因此下面的流程图主要呈现 <code>binder transaction</code> 的流程（忽略 <code>client/server</code> 和 <code>binder</code> 驱动系统调用的细节）：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-47-20.png" class="">

<p><code>Service manager</code> 是一个 <code>service</code> 组件管理中心，任何一个 <code>service</code> 组件都需要向 <code>service manager</code> 进行注册（ <code>add service</code> ），以便其他的 APP 可以通过 <code>service manager</code> 定位到该 <code>service</code> 组件（ <code>check service</code> ）。</p>
<h2 id="2、数据对象综述"><a href="#2、数据对象综述" class="headerlink" title="2、数据对象综述"></a>2、数据对象综述</h2><p>注册服务相关数据结构全图如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-47-55.png" class="">

<p>配合上面的流程， <code>binder</code> 驱动会为 <code>client</code> 和 <code>server</code> 分别创建对应的各种数据结构对象，具体过程如下：</p>
<ol>
<li><p>假设我们现在准备注册 A 服务组件，绑定 A 服务组件的进程在 <code>add service</code> 这个场景下是 <code>client process</code> ，它在用户空间首先会创建了 <code>service</code> 组件对象，在递交 <code>BC_TRANSACTION</code> 的时候会携带 <code>service</code> 组件的信息（把 <code>service</code> 组件地址信息封装在 <code>flat_binder_object</code> 数据结构中）。</p>
</li>
<li><p>在系统调用接口层面，我们使用 <code>ioctl</code> （ <code>BINDER_WRITE_READ</code> ）来完成具体 <code>transaction</code> 的递交过程。具体的 <code>transaction</code> 数据封装在 <code>struct binder_write_read</code> 对象中，具体如下图所示：</p>
</li>
</ol>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-48-16.png" class="">

<ol>
<li><p><code>Binder</code> 驱动创建 <code>binder_transaction</code> 对象来控制完成本次 <code>binder transaction</code> 。首先要初始化 <code>transaction</code> ，具体包括：和谁通信（用户空间通过 <code>binder_transaction_data</code> 的 <code>target</code> 成员告知 <code>binder</code> 驱动 <code>transaction</code> 的 <code>target</code> ）、为何通信（ <code>binder_transaction_data</code> 的 <code>code</code> ）等</p>
</li>
<li><p>对于每一个 <code>service</code> 组件，内核都会创建一个 <code>binder node</code> 与之对应。用户空间通过 <code>flat_binder_object</code> 这个数据结构把本次要注册的 <code>service</code> 组件扁平化，传递给 <code>binder</code> 驱动。驱动根据这个 <code>flat_binder_object</code> 创建并初始化了该 <code>service</code> 组件对应的 <code>binder node</code> 。由于是注册到 <code>service manager</code> ，也就是说 <code>service manager</code> 会有一个对本次注册组件的引用，所以需要在 <code>target proc</code>（即 <code>service manager</code> ）中建立一个 <code>binder ref</code> 对象（指向这个要注册的 <code>binder</code> 实体）并分配一个 <code>handle</code> 。</p>
</li>
<li><p>把一个 <code>BINDER_WORK_TRANSACTION_COMPLETE</code> 类型的 <code>binder work</code> 挂入 <code>client binder thread</code> 的 <code>todo list</code> ，通知 <code>client</code> 其请求的 <code>transaction</code> 已经被 <code>binder</code> 处理完毕，可以进行其他工作了（当然对于同步 <code>binder</code> 通信， <code>client</code> 一般会通过 <code>read</code> 类型的 <code>ioctl</code> 进入阻塞态，等待 <code>server</code> 端的回应）。</p>
</li>
<li><p>至此， <code>client</code> 端已经完成了所有操作，现在我们开始进入 <code>server</code> 端的数据流了。 <code>Binder</code> 驱动会把一个 <code>BINDER_WORK_TRANSACTION</code> 类型的 <code>binder work</code> （内嵌在 <code>binder transaction</code> ）挂入 <code>binder</code> 线程的 <code>todo list</code> ，然后唤醒它起来干活。</p>
</li>
<li><p><code>binder server</code> 端会使用 <code>ioctl</code> （ <code>BINDER_WRITE_READ</code> ）进入读阻塞状态，等待 <code>client</code> 的请求到来。一旦有请求到来，<code>Service manager</code> 进程会从 <code>binder_thread_read</code> 中醒来处理队列上的 <code>binder work</code> 。所谓处理 <code>binder work</code> 其实完成 <code>client transaction</code> 的向上递交过程。具体的<code>transaction</code> 数据封装在 <code>struct binder_write_read</code> 对象中，具体如下图所示：</p>
</li>
</ol>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-48-47.png" class="">

<p>需要强调的一点是：在步骤2中， <code>flat_binder_object</code> 传递的是 <code>binder node</code> ，而这里传递的是 <code>handle</code> （即 <code>binder ref</code> ，步骤4中创建的）</p>
<ol>
<li><p>在 <code>Service manager</code> 进程的用户态，识别了本次 <code>transaction</code> 的 <code>code</code> 是 <code>add service</code> ，那么它会把（ <code>service name</code> ， <code>handle</code> ）数据写入其数据库，完成服务注册。</p>
</li>
<li><p>从 <code>transaction</code> 的角度看，上半场已经完成。现在开始下半场的 <code>transaction</code> 的处理，即 <code>BC_REPLY</code> 的处理。和 <code>BC_TRANSACTION</code> 处理类似，也是通过 <code>binder_ioctl ---&gt; binder_ioctl_write_read ---&gt; binder_thread_write ---&gt; binder_transaction</code> 这个调用链条进入 <code>binder transaction</code> 处理流程的。</p>
</li>
<li><p>和上半场类似，在这里 <code>Binder</code> 驱动同样会创建一个 <code>binder_transaction</code> 对象来控制完成本次 <code>BC_REPLY</code> 的 <code>binder transaction</code> 。通过 <code>thread-&gt;transaction_stack</code> 可以找到其对应的 <code>BC_TRANSACTION</code> 的 <code>binder transaction</code> 对象，进而找到回应给哪一个 <code>binder process</code> 和 <code>thread</code> 。后续的处理和上半场类似，这里就不再赘述了。</p>
</li>
</ol>
<h2 id="3-相关数据结构"><a href="#3-相关数据结构" class="headerlink" title="3. 相关数据结构"></a>3. 相关数据结构</h2><p><code>struct transaction</code>主要用来表示 <code>binder client</code> 和 <code>server</code> 之间的一次通信，该数据结构的主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>work</td>
<td>本次 transaction 涉及的 binder work ，它会挂入 target proc 或者 target binder thread 的 todo list 中。</td>
</tr>
<tr>
<td>from</td>
<td>发起 binder 通信的线程</td>
</tr>
<tr>
<td>to_proc</td>
<td>处理 binder 请求的进程</td>
</tr>
<tr>
<td>to_thread</td>
<td>处理 binder 请求的线程</td>
</tr>
<tr>
<td>buffer</td>
<td>binder 通信使用的 buffe r，当 A 向 B 服务请求 binder 通信的时候， B 进程分配 buffer ，并 copy A 的数据（ user space ）到 buffer 中。<strong>这是 binder 通信唯一一次内存拷贝。</strong></td>
</tr>
<tr>
<td>code</td>
<td>本次 transaction 的操作码。 Binder server 端根据操作码提供相应的服务</td>
</tr>
<tr>
<td>flags</td>
<td>本次 transaction 的一些属性标记</td>
</tr>
<tr>
<td>Priority saved_priority</td>
<td>和优先级处理相关的成员</td>
</tr>
</tbody></table>
<p> <code>BC_TRANSACTION</code> 、 <code>BC_REPLY</code> 、 <code>BR_TRANSACTION</code> 和 <code>BR_REPLY</code> 这四个协议码的协议数据是 <code>struct binder_transaction_data</code> ，该数据结构的主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>target</td>
<td>本次 transation 去向何方？ Target 有两种形式，一种是本地 binder 实体，另外一种是表示远端 binder 实体的句柄。在 client 向 service manager 发起 transaction 的时候，那么 target.handle 等于 0 。当该 transaction 到达 service manager 的时候， binder 实体变成本地对象，因此用 Target.ptr 和 cookie 来表示。</td>
</tr>
<tr>
<td>cookie</td>
<td>如果 transaction 的目的地是本地 binder 实体，那么这个成员保存了 binder 实体对象的用户空间地址</td>
</tr>
<tr>
<td>code</td>
<td>Client 和 service 组件之间的操作码， binder 驱动不关心这个码字。</td>
</tr>
<tr>
<td>flags</td>
<td>描述 transaction 特性的 flag 。例如 TF_ONE_WAY 说明是同步还是异步 binder 通信</td>
</tr>
<tr>
<td>sender_pid sender_euid</td>
<td>是谁发起 transaction ？在 binder 驱动中会根据当前线程设定。</td>
</tr>
<tr>
<td>data_size offsets_size data</td>
<td>本次 transaction 的数据缓冲区信息。</td>
</tr>
</tbody></table>
<p><code>flat_binder_object</code> 主要用来在进程之间传递 <code>Binder</code> 对象，该数据结构的主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>hdr</td>
<td>用来描述 Binder 对象的类型，目前支持的类型有： binder 实体（本地 service 组件） Binder 句柄（远端的 service 组件） 文件描述符 本文主要关注前两种对象类型</td>
</tr>
<tr>
<td>Binder handle</td>
<td>如果 flat_binder_object 传递的是本地 service 组件，那么这个联合体中的 binder 成员有效，指向本地 service 组件（用户空间对象）的一个弱引用对象的地址。 如果 flat_binder_object 传递的是句柄，那么这个联合体中的 handle 成员有效，该 handle 对应的 binder ref 指向一个 binder 实体对象。</td>
</tr>
<tr>
<td>cookie</td>
<td>如果传递的是 binder 实体，那么这个成员保存了 binder 实体对象（ service 组件）的用户空间地址</td>
</tr>
</tbody></table>
<p><code>struct binder_ref</code> 主要用来表示一个对 <code>Binder</code> 实体对象（ <code>binder node</code> ）的引用，该数据结构的主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>data</td>
<td>这个成员最核心的数据是用户空间的句柄</td>
</tr>
<tr>
<td>rb_node_desc</td>
<td>挂入 binder proc 的红黑树（ key 是描述符， userspace 的句柄）</td>
</tr>
<tr>
<td>rb_node_node</td>
<td>挂入 binder proc 的红黑树（ key 是 binder node ）</td>
</tr>
<tr>
<td>node_entry</td>
<td>挂入 binder node 的哈希表</td>
</tr>
<tr>
<td>proc</td>
<td>该 binder ref 属于哪一个 binder  proc</td>
</tr>
<tr>
<td>node</td>
<td>该 binder ref 引用哪一个 binder node</td>
</tr>
</tbody></table>
<h1 id="四、如何和-Service-组件通信"><a href="#四、如何和-Service-组件通信" class="headerlink" title="四、如何和 Service 组件通信"></a>四、如何和 Service 组件通信</h1><p>我们以 B 进程向 A 服务组件（位于 A 进程）发起服务请求为例来说明具体的操作流程。 B 进程不能直接请求 A 服务组件的服务，因为 B 进程唯一获知的信息是 A 服务组件的名字而已。由于 A 服务组件已经注册在案，因此 <code>service manager</code> 已经有（ A 服务组件名字，句柄）的记录，因此 B 进程可以通过下面的流程获得 A 服务组件的信息并建立其代理组件对象：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-54-56.png" class="">

<p>B 进程首先发起 <code>BC_TRANSACTION</code> 操作，操作码是 <code>CHECK_SERVICE</code> ，数据是 A 服务组件的名字。 <code>Service manager</code> 找到了句柄后将其封装到 <code>BC_REPLY</code> 中。这里的句柄是 <code>service manager</code> 进程的句柄，这个句柄并不能直接被 B 进程直接使用，毕竟（进程，句柄）才对应唯一的 <code>binder</code> 实体。这里的 <code>binder driver</code> 有一个很关键的操作：把 <code>service manager</code> 中句柄 A 转换成 <code>B client</code> 进程中的句柄 B ，并封装在 <code>BR_REPLY</code> 中。这时候（ <code>service manager</code> 进程，句柄 A ）和（ <code>B client</code> 进程，句柄 B ）都指向 A 服务组件对应的 <code>bind node</code> 对象。</p>
<p>一旦定位了 A 服务组件，那么可以继续进行如下的流程：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-55-26.png" class="">

<h1 id="五、Binder内存操作"><a href="#五、Binder内存操作" class="headerlink" title="五、Binder内存操作"></a>五、Binder内存操作</h1><h2 id="1-逻辑过程"><a href="#1-逻辑过程" class="headerlink" title="1.逻辑过程"></a>1.逻辑过程</h2><p>在处理 <code>binder transaction</code> 的过程中，相关的内存操作如下所示：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-55-48.png" class="">

<p>配合上面的流程，内存操作的逻辑过程如下：</p>
<ol>
<li><p>在 <code>binder client</code> 的用户空间中，发起 <code>transaction</code> 的一方会构建用户数据缓冲区（包括两部分：实际的数据区和 <code>offset</code> 区），把想要传递到 <code>server</code> 端的数据填充到缓冲区并封装在 <code>binder_transaction_data</code> 数据结构中。</p>
</li>
<li><p><code>binder_transaction_data</code> 会被 <code>copy</code> 到内核态， <code>binder</code> 驱动会根据它计算出本次需要 <code>binder</code> 通信的数据量。</p>
</li>
<li><p>根据 <code>binder</code> 通信的数据量在 <code>server</code> 进程的 <code>binder VMA</code> 分配数据缓冲区（ <code>binder buffer</code> 是这个缓冲区的控制数据对象），同时根据需要也会分配对应的物理 <code>page</code> 并建立地址映射，以便用户空间可以访问这段 <code>buffer</code> 的数据。</p>
</li>
<li><p>建立内核地址空间的映射，把用户空间的 <code>binder</code> 数据缓冲区拷贝到内核中，然后释放掉该映射。</p>
</li>
<li><p>在把 <code>binder buffer</code> 的数据传递到 <code>server</code> 用户空间的时候，我们需要一个 <code>binder_transaction_data</code> 来描述 <code>binder</code> 通信的缓冲区数据，这个数据对象需要拷贝到用户地址空间，而 <code>binder buffer</code> 中的数据则不需要拷贝，因为在上面步骤3中已经建立了地址映射， <code>server</code> 进程可以直接访问即可。</p>
</li>
</ol>
<h2 id="2-主要的数据结构"><a href="#2-主要的数据结构" class="headerlink" title="2.主要的数据结构"></a>2.主要的数据结构</h2><p><code>struct binder_alloc</code> 用来描述 <code>binder</code> 进程内存分配器，该数据结构的主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>vma</td>
<td>binder 内存对应的 VMA</td>
</tr>
<tr>
<td>vma_vm_mm</td>
<td>binder 进程对应的地址空间描述符</td>
</tr>
<tr>
<td>buffer</td>
<td>该 binder proc 能用于 binder 通信的内存地址。该地址是 mmap 的用户空间虚拟地址。</td>
</tr>
<tr>
<td>buffers</td>
<td>所有的 binder buffers （包括空闲的和正在使用的）</td>
</tr>
<tr>
<td>free_buffers</td>
<td>空闲 binder buffers 的红黑树，按照 size 排序</td>
</tr>
<tr>
<td>allocated_buffers</td>
<td>已经分配的 binder buffers 的红黑树， key 是 buffer address</td>
</tr>
<tr>
<td>free_async_space</td>
<td>剩余的可用于异步 binder 通信的内存大小。初始化的时候配置为 2M （整个 binder 内存的一半）</td>
</tr>
<tr>
<td>pages</td>
<td>binder 内存区域对应的 page 们。在 reclaim binder 内存的时候</td>
</tr>
<tr>
<td>buffer_size</td>
<td>通过 mmap 映射的，用于 binder 通信的缓冲区大小，即 binder alloc 管理的整个内存的大小。</td>
</tr>
<tr>
<td>pid</td>
<td>Binder proc 的pid</td>
</tr>
</tbody></table>
<p><code>struct binder_buffer</code> 用来描述一个用于 <code>binder</code> 通信的缓冲区，该数据结构的主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>entry</td>
<td>挂入 binder alloc buffer 链表（ buffers 成员）的节点</td>
</tr>
<tr>
<td>rb_node</td>
<td>挂入 binder alloc 红黑树的节点：如果是空闲的 buffer ，挂入空闲红黑树，如果是已经分配的，挂入已分配红黑树。</td>
</tr>
<tr>
<td>transaction</td>
<td>Binder 缓冲区都是用于某次 binder transaction 的，这个成员指向对应的 transaction 。</td>
</tr>
<tr>
<td>target_node</td>
<td>该 buffer 的去向哪一个 node （ service 组件）</td>
</tr>
<tr>
<td>data_size offsets_size</td>
<td>Binder 缓冲区的数据区域的大小以及 offset 区域的大小。</td>
</tr>
<tr>
<td>user_data</td>
<td>该 binder buffer 的用户空间地址</td>
</tr>
</tbody></table>
<p>参考文献：</p>
<p>[1]Android系统源代码情景分析，罗升阳著</p>
<p>[2]<a href="http://gityuan.com/tags/#binder">http://gityuan.com/tags/#binder</a> ，袁辉辉的博客</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC内联汇编</title>
    <url>/2021/06/14/GCC%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<blockquote>
<p>本文主要参考 <a href="https://www.linuxprobe.com/gcc-how-to.html">https://www.linuxprobe.com/gcc-how-to.html</a></p>
</blockquote>
<h1 id="GCC-汇编语法"><a href="#GCC-汇编语法" class="headerlink" title="GCC 汇编语法"></a>GCC 汇编语法</h1><p><code>Linux</code> 上的 <code>GNU C</code> 编译器 <code>GCC</code> ，使用 <code>AT&amp;T/UNIX</code> 汇编语法。在这里，我们将使用 <code>AT&amp;T</code> 语法 进行汇编编码。<code>AT&amp;T</code> 语法和 <code>Intel</code> 语法的差别很大。</p>
<h2 id="源操作数和目的操作数顺序"><a href="#源操作数和目的操作数顺序" class="headerlink" title="源操作数和目的操作数顺序"></a>源操作数和目的操作数顺序</h2><p><code>AT&amp;T</code> 语法的操作数方向和 <code>Intel</code> 语法的刚好相反。</p>
<ul>
<li><p>在 <code>Intel</code> 语法中，第一操作数为目的操作数，第二操作数为源操作数。</p>
</li>
<li><p>在 <code>AT&amp;T</code>  语法中，第一操作数为源操作数，第二操作数为目的操作数。</p>
</li>
</ul>
<h2 id="寄存器命名"><a href="#寄存器命名" class="headerlink" title="寄存器命名"></a>寄存器命名</h2><p><code>AT&amp;T</code> 语法寄存器名称有 <code>%</code> 前缀，即如果必须使用 <code>eax</code>，它应该用作 <code>%eax</code> 。</p>
<h2 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h2><p><code>AT&amp;T</code> 语法立即数以 <code>$</code> 为前缀。静态 <code>C</code> 变量也使用 <code>$</code> 前缀。在 <code>Intel</code> 语法中，十六进制常量以 <code>h</code> 为后缀，然而 <code>AT&amp;T</code> 不使用这种语法，这里我们给常量添加前缀 <code>0x</code>。所以，对于十六进制，我们首先看到一个 <code>$</code>，然后是 <code>0x</code>，最后才是常量。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl %ecx, $label(%edx,%ebx,$0x4)</span><br></pre></td></tr></table></figure>

<h2 id="操作数大小"><a href="#操作数大小" class="headerlink" title="操作数大小"></a>操作数大小</h2><p>在 <code>AT&amp;T</code> 语法中，存储器操作数的大小取决于操作码名字的最后一个字符。操作码后缀 <code>b</code> 、<code>w</code> 、<code>l</code> 分别指明了字节（8位）、字（16位）、长型（32位）存储器引用。</p>
<p><code>Intel</code>  语法通过给存储器操作数添加 <code>byte ptr</code>、 <code>word ptr</code> 和 <code>dword ptr</code> 前缀来实现这一功能。</p>
<p>因此，<code>Intel</code> 的 <code>mov al, byte ptr foo</code> 在 <code>AT&amp;T</code> 语法中为 <code>movb foo, %al</code>。</p>
<h2 id="存储器操作数"><a href="#存储器操作数" class="headerlink" title="存储器操作数"></a>存储器操作数</h2><p>在 <code>Intel</code> 语法中，基址寄存器包含在 <code>[</code> 和 <code>]</code> 中，然而在 <code>AT&amp;T</code> 中，它们变为 <code>(</code> 和 <code>)</code>。</p>
<p>另外，在 <code>Intel</code> 语法中， 间接内存引用为 <code>section:[base + index*scale + disp]</code>，在 <code>AT&amp;T</code> 中变为 <code>section:disp(base, index, scale)</code>。</p>
<p>需要牢记的一点是，当一个常量用于 <code>disp</code> 或 <code>scale</code> ，不能添加 <code>$</code> 前缀。</p>
<p>现在我们看到了 <code>Intel</code> 语法和 <code>AT&amp;T</code> 语法之间的一些主要差别。我仅仅写了它们差别的一部分而已。关于更完整的信息，请参考 <code>GNU</code> 汇编文档。现在为了更好地理解，我们可以看一些示例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------------------+------------------------------------+</span><br><span class="line">|       Intel Code             |      AT&amp;T Code                     |</span><br><span class="line">+------------------------------+------------------------------------+</span><br><span class="line">| mov     eax,1                |  movl    $1,%eax                   |</span><br><span class="line">| mov     ebx,0ffh             |  movl    $0xff,%ebx                |</span><br><span class="line">| int     80h                  |  int     $0x80                     |</span><br><span class="line">| mov     ebx, eax             |  movl    %eax, %ebx                |</span><br><span class="line">| mov     eax,[ecx]            |  movl    (%ecx),%eax               |</span><br><span class="line">| mov     eax,[ebx+3]          |  movl    3(%ebx),%eax              |</span><br><span class="line">| mov     eax,[ebx+20h]        |  movl    0x20(%ebx),%eax           |</span><br><span class="line">| add     eax,[ebx+ecx*2h]     |  addl    (%ebx,%ecx,0x2),%eax      |</span><br><span class="line">| lea     eax,[ebx+ecx]        |  leal    (%ebx,%ecx),%eax          |</span><br><span class="line">| sub     eax,[ebx+ecx*4h-20h] |  subl    -0x20(%ebx,%ecx,0x4),%eax |</span><br><span class="line">+------------------------------+------------------------------------+</span><br></pre></td></tr></table></figure>

<h1 id="基本内联"><a href="#基本内联" class="headerlink" title="基本内联"></a>基本内联</h1><p>基本内联汇编的格式非常直接了当，它的基本格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm(&quot;汇编代码&quot;);</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span>(<span class="string">&quot;movl %ecx %eax&quot;</span>);         <span class="comment">/* 将 ecx 寄存器的内容移至 eax  */</span></span><br><span class="line">__asm__(<span class="string">&quot;movb %bh (%eax)&quot;</span>);    <span class="comment">/* 将 bh 的一个字节数据 移至 eax 寄存器指向的内存 */</span></span><br></pre></td></tr></table></figure>
<p><code>asm</code> 和 <code>__asm__</code> 这两者都是有效的，如果关键词 <code>asm</code> 和我们程序的一些标识符冲突了，我们可以使用 <code>__asm__</code>。如果我们的汇编指令有多条时，可以每一条指令一行，并用双引号圈起，同时为每条指令添加 <code>\n\t</code> 后缀。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__asm__ (<span class="string">&quot;movl %eax, %ebx\n\t&quot;</span></span><br><span class="line">         <span class="string">&quot;movl $56, %esi\n\t&quot;</span></span><br><span class="line">         <span class="string">&quot;movl %ecx, $label(%edx,%ebx,$4)\n\t&quot;</span></span><br><span class="line">         <span class="string">&quot;movb %ah, (%ebx)&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="扩展汇编"><a href="#扩展汇编" class="headerlink" title="扩展汇编"></a>扩展汇编</h1><p>在基本内联汇编中，我们只有指令，然而在扩展汇编中，我们可以同时指定操作数。操作数允许我们指定输入寄存器、输出寄存器以及修饰寄存器列表。<code>GCC</code> 不强制用户必须指定使用的寄存器。我们可以把头疼的事留给 <code>GCC</code> ，这可能可以更好地适应 <code>GCC</code> 的优化。基本格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm ( 汇编程序模板</span><br><span class="line">: 输出操作数     /* 可选的 */</span><br><span class="line">: 输入操作数     /* 可选的 */</span><br><span class="line">: 修饰寄存器列表  /* 可选的 */</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>汇编程序模板由汇编指令组成。第一个 <code>:</code> 用于将汇编程序模板和第一个输出操作数分开，第二个 <code>:</code> 用于将最后一个输出操作数和第一个输入操作数分开。 <code>,</code> 用于分离每一个组内的操作数，总操作数的数目限制在 <code>10</code> 个，或者机器描述中的任何指令格式中的最大操作数数目，以较大者为准。</p>
<p><strong>如果没有输出操作数但存在输入操作数，你必须将两个连续的冒号放置于输出操作数原本会放置的地方周围。</strong></p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span>(<span class="string">&quot;cld\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;rep\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;stosl&quot;</span></span><br><span class="line">    : <span class="comment">/* 无输出寄存器 */</span></span><br><span class="line">    : <span class="string">&quot;c&quot;</span> (count), <span class="string">&quot;a&quot;</span> (fill_value), <span class="string">&quot;D&quot;</span> (dest) <span class="comment">/* 输入操作数 引号中的内容为约束字符串，括号中的内容为被约束的变量 */</span></span><br><span class="line">    : <span class="string">&quot;%ecx&quot;</span>, <span class="string">&quot;%edi&quot;</span> <span class="comment">/* 修饰寄存器列表 */</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>以上的内联汇编是将 <code>fill_value</code> 值连续 <code>count</code> 次拷贝到寄存器 <code>edi</code> 所指位置。 它也告诉 <code>gcc</code> 寄存器 <code>ecx</code> 和 <code>edi</code> 将会被修改。</p>
<p>为了更加清晰地说明，让我们再看一个示例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="built_in">asm</span> (<span class="string">&quot;movl %1, %%eax; </span></span><br><span class="line"><span class="string">      movl %%eax, %0;&quot;</span></span><br><span class="line">     :<span class="string">&quot;=r&quot;</span>(b)        <span class="comment">/* 输出 */</span></span><br><span class="line">     :<span class="string">&quot;r&quot;</span>(a)         <span class="comment">/* 输入 */</span></span><br><span class="line">     :<span class="string">&quot;%eax&quot;</span>         <span class="comment">/* 修饰寄存器 */</span></span><br><span class="line">     );   </span><br></pre></td></tr></table></figure>
<p>这里我们所做的是使用汇编指令使 <code>b</code> 变量的值等于 <code>a</code> 变量的值。一些有意思的地方是：</p>
<ol>
<li><p><code>b</code> 为输出操作数，用 <code>%0</code> 引用；<code>a</code> 为输入操作数，用 <code>%1</code> 引用。</p>
</li>
<li><p><code>r</code> 为操作数约束。<code>r</code> 告诉 <code>GCC</code> 可以使用任一寄存器存储操作数。<code>=</code>是一个约束修饰符 ，它表明 <code>b</code> 是一个可写的输出操作数。</p>
</li>
<li><p>寄存器名字以两个 <code>%</code> 为前缀。这有利于 <code>GCC</code> 区分操作数和寄存器，操作数以一个 <code>%</code> 为前缀。</p>
</li>
<li><p>第三个冒号之后的修饰寄存器 <code>%eax</code> 用于告诉 <code>GCC</code> <code>%eax</code> 的值将会在 <code>asm</code> 内部被修改，所以 <code>GCC</code> 将不会使用此寄存器存储任何其他值。</p>
</li>
</ol>
<p>当 <code>asm</code> 执行完毕， <code>b</code> 变量会映射到更新的值，因为它被指定为输出操作数。换句话说， <code>asm</code> 内 <code>b</code> 变量的修改应该会被映射到 <code>asm</code> 外部。</p>
<h2 id="汇编程序模板"><a href="#汇编程序模板" class="headerlink" title="汇编程序模板"></a>汇编程序模板</h2><p>汇编程序模板包含了被插入到 <code>C</code> 程序的汇编指令集。其格式为：</p>
<p>每条指令用双引号圈起，或者整个指令组用双引号圈起。同时每条指令应以分界符结尾。有效的分界符有换行符（<code>\n</code>）和分号（<code>;</code>）。一般使用换行符后会添加一个制表符（<code>\t</code>），原因就是为了排版和分隔。 <code>C</code> 变量对应的操作数使用<code> %0、%1 ... %n-1</code>表示。</p>
<h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h2><p><code>C</code> 变量用作 <code>asm</code> 内的汇编指令操作数。每个操作数前面是以双引号圈起的操作数约束，对于输出操作数，在引号内还有一个额外约束修饰符。约束字符串主要用于决定操作数的寻址方式，同时也用于指定使用的寄存器。</p>
<p>如果我们使用多个操作数，那么每一个操作数用逗号隔开。</p>
<p>在汇编程序模板中，每个操作数用数字引用。编号方式如下，如果总共有 <code>n</code> 个操作数（包括输入和输出操作数），那么第一个输出操作数编号为 <code>0</code> ，逐项递增，并且最后一个输入操作数编号为 <code>n - 1</code> 。</p>
<p>输出操作数变量必须为左值。输入操作数的要求不像这样严格。扩展汇编特性常常用于编译器所不知道的机器指令 。</p>
<p>所以现在我们来关注一些示例。我们想要求一个数的5次方结果。为了计算该值，我们使用 <code>lea</code> 指令。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span> (<span class="string">&quot;leal (%1,%1,4), %0&quot;</span></span><br><span class="line">     : <span class="string">&quot;=r&quot;</span> (five_times_x)</span><br><span class="line">     : <span class="string">&quot;r&quot;</span> (x) </span><br><span class="line">     );</span><br></pre></td></tr></table></figure>

<p>如果我们想要输入和输出放在同一个寄存器里，我们也可以要求 <code>GCC</code> 这样做。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm (&quot;leal (%0,%0,4), %0&quot;</span><br><span class="line">     : &quot;=r&quot; (five_times_x)</span><br><span class="line">     : &quot;0&quot; (x) </span><br><span class="line">     );</span><br></pre></td></tr></table></figure>

<p>现在输出和输出操作数位于同一个寄存器。但是我们无法得知是哪一个寄存器。现在假如我们也想要指定操作数所在的寄存器，这里有一种方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm (&quot;leal (%%ecx,%%ecx,4), %%ecx&quot;</span><br><span class="line">     : &quot;=c&quot; (x)</span><br><span class="line">     : &quot;c&quot; (x) </span><br><span class="line">     );</span><br></pre></td></tr></table></figure>

<p>在头两个示例， <code>GCC</code> 决定了寄存器并且它知道发生了什么改变。在最后一个示例，我们不必将 <code>ecx</code> 添加到修饰寄存器列表， <code>gcc</code> 知道它表示 <code>x</code> 。因为它可以知道 <code>ecx</code> 的值，它就不被当作修饰的了。</p>
<h2 id="修饰寄存器列表"><a href="#修饰寄存器列表" class="headerlink" title="修饰寄存器列表"></a>修饰寄存器列表</h2><p>一些指令会破坏一些硬件寄存器内容。我们不得不在修饰寄存器中列出这些寄存器，即汇编函数内第三个 <code>:</code> 之后的域。这可以通知 <code>gcc</code> 我们将会自己使用和修改这些寄存器，这样 <code>gcc</code> 就不会假设存入这些寄存器的值是有效的。我们不用在这个列表里列出输入、输出寄存器。因为 <code>gcc</code> 知道 <code>asm</code> 使用了它们。如果指令隐式或显式地使用了任何其他寄存器，（并且寄存器没有出现在输出或者输出约束列表里），那么就需要在修饰寄存器列表中指定这些寄存器。</p>
<p>如果我们的指令可以修改条件码寄存器（ <code>cc</code> ），我们必须将 <code>cc</code> 添加进修饰寄存器列表。</p>
<p>如果我们的指令以不可预测的方式修改了内存，那么需要将 <code>memory</code> 添加进修饰寄存器列表。这可以使 <code>GCC</code> 不会在汇编指令间保持缓存于寄存器的内存值。如果被影响的内存不在汇编的输入或输出列表中，我们也必须添加 <code>volatile</code> 关键词。</p>
<p>我们可以按我们的需求多次读写修饰寄存器。参考一下模板内的多指令示例；它假设子例程 <code>_foo</code> 接受寄存器 <code>eax</code> 和 <code>ecx</code> 里的参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span> (<span class="string">&quot;movl %0,%%eax;</span></span><br><span class="line"><span class="string">      movl %1,%%ecx;</span></span><br><span class="line"><span class="string">      call _foo&quot;</span></span><br><span class="line">     : <span class="comment">/* no outputs */</span></span><br><span class="line">     : <span class="string">&quot;g&quot;</span> (from), <span class="string">&quot;g&quot;</span> (to)</span><br><span class="line">     : <span class="string">&quot;eax&quot;</span>, <span class="string">&quot;ecx&quot;</span></span><br><span class="line">     );</span><br></pre></td></tr></table></figure>

<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>关键词 <code>volatile</code> 放置在 <code>asm</code> 后面、<code>()</code>的前面，以防止编译器优化将指令移动、删除或者其他操作，我们将其声明为 <code>asm volatile ( ... : ... : ... : ...);</code> 。</p>
<p>如果担心发生冲突，请使用 <code>__volatile__</code>。</p>
<p>如果我们的汇编只是用于一些计算并且没有任何副作用，不使用 <code>volatile</code> 关键词会更好。不使用 <code>volatile</code> 关键字 <code>gcc</code> 将会优化代码。</p>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>约束用于表明一个操作数是否可以位于寄存器和位于哪种寄存器；操作数是否可以为一个内存引用和哪种地址；操作数是否可以为一个立即数和它可能的取值范围；等等。</p>
<h2 id="常用约束"><a href="#常用约束" class="headerlink" title="常用约束"></a>常用约束</h2><p>在许多约束中，只有小部分是常用的。我们来看看这些约束。</p>
<ol>
<li>寄存器操作数约束</li>
</ol>
<p>当使用这种约束指定操作数时，它们存储在通用寄存器（ <code>GPR</code> ）中。请看下面示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span> (<span class="string">&quot;movl %%eax, %0\n&quot;</span> :<span class="string">&quot;=r&quot;</span>(myval));</span><br></pre></td></tr></table></figure>

<p>这里，变量 <code>myval</code> 保存在寄存器中，寄存器 <code>eax</code> 的值被复制到该寄存器中，并且 <code>myval</code> 的值从寄存器更新到了内存。当指定 <code>r</code> 约束时， <code>gcc</code> 可以将变量保存在任何可用的 <code>GPR</code> 中。要指定寄存器，你必须使用特定寄存器约束直接地指定寄存器的名字。它们为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---+--------------------+</span><br><span class="line">| r |    Register(s)     |</span><br><span class="line">+---+--------------------+</span><br><span class="line">| a |   %eax, %ax, %al   |</span><br><span class="line">| b |   %ebx, %bx, %bl   |</span><br><span class="line">| c |   %ecx, %cx, %cl   |</span><br><span class="line">| d |   %edx, %dx, %dl   |</span><br><span class="line">| S |   %esi, %si        |</span><br><span class="line">| D |   %edi, %di        |</span><br><span class="line">+---+--------------------+</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>内存操作数约束</li>
</ol>
<p>当操作数位于内存时，任何对它们的操作将直接发生在内存位置，这与寄存器约束相反，后者首先将值存储在要修改的寄存器中，然后将它写回到内存位置。但寄存器约束通常用于一个指令必须使用它们或者它们可以大大提高处理速度的地方。当需要在 <code>asm</code> 内更新一个 <code>C</code> 变量，而又不想使用寄存器去保存它的值，使用内存最为有效。例如， <code>IDTR</code> 寄存器的值存储于内存位置 <code>loc</code> 处：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span>(<span class="string">&quot;sidt %0\n&quot;</span> : :<span class="string">&quot;m&quot;</span>(loc));</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>匹配约束</li>
</ol>
<p>在某些情况下，一个变量可能既充当输入操作数，也充当输出操作数。可以通过使用匹配约束在 <code>asm</code> 中指定这种情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span> (<span class="string">&quot;incl %0&quot;</span> :<span class="string">&quot;=a&quot;</span>(var):<span class="string">&quot;0&quot;</span>(var));</span><br></pre></td></tr></table></figure>

<p>在这个匹配约束的示例中，寄存器 <code>%eax</code> 既用作输入变量，也用作输出变量。 <code>var</code> 输入被读进 <code>%eax</code>，并且等递增后更新的 <code>%eax</code> 再次被存储进 <code>var</code> 。这里的 <code>&quot;0&quot;</code> 用于指定与第 <code>0</code> 个输出变量相同的约束。该约束可用于：</p>
<ul>
<li>在输入从变量读取或变量修改后且修改被写回同一变量的情况。</li>
<li>在不需要将输入操作数实例和输出操作数实例分开的情况。</li>
</ul>
<p>使用匹配约束最重要的意义在于它们可以有效地使用可用寄存器。</p>
<p>其他一些约束：</p>
<ul>
<li><code>&quot;m&quot;</code> : 允许一个内存操作数，可以使用机器普遍支持的任一种地址。</li>
<li><code>&quot;o&quot;</code> : 允许一个内存操作数，但只有当地址是可偏移的。即，该地址加上一个小的偏移量可以得到一个有效地址。</li>
<li><code>&quot;V&quot;</code> : 一个不允许偏移的内存操作数。换言之，任何适合 <code>&quot;m&quot;</code> 约束而不适合 <code>&quot;o&quot;</code> 约束的操作数。</li>
<li><code>&quot;i&quot;</code> : 允许一个（带有常量）的立即整形操作数。这包括其值仅在汇编时期知道的符号常量。</li>
<li><code>&quot;n&quot;</code> : 允许一个带有已知数字的立即整形操作数。许多系统不支持汇编时期的常量，因为操作数少于一个字宽。对于此种操作数，约束应该使用 <code>&#39;n&#39;</code> 而不是 <code>&#39;i&#39;</code>。</li>
<li><code>&quot;g&quot;</code> : 允许任一寄存器、内存或者立即整形操作数，不包括通用寄存器之外的寄存器。</li>
</ul>
<p>以下约束为 <code>x86</code> 特有。</p>
<ul>
<li><code>&quot;r&quot;</code> : 寄存器操作数约束，查看上面给定的表格。</li>
<li><code>&quot;q&quot;</code> : 寄存器 <code>a、b、c</code> 或者 <code>d</code> 。</li>
<li><code>&quot;I&quot;</code> : 范围从 <code>0</code> 到 <code>31</code> 的常量（对于 <code>32</code> 位移位）。</li>
<li><code>&quot;J&quot;</code> : 范围从 <code>0</code> 到 <code>63</code> 的常量（对于 <code>64</code> 位移位）。</li>
<li><code>&quot;K&quot;</code> : <code>0xff</code> 。</li>
<li><code>&quot;L&quot;</code> : <code>0xffff</code> 。</li>
<li><code>&quot;M&quot;</code> : <code>0、1、2</code> 或 <code>3</code> （ <code>lea</code> 指令的移位）。</li>
<li><code>&quot;N&quot;</code> : 范围从 <code>0</code> 到 <code>255</code> 的常量（对于 <code>out</code> 指令）。</li>
<li><code>&quot;f&quot;</code> : 浮点寄存器</li>
<li><code>&quot;t&quot;</code> : 第一个（栈顶）浮点寄存器</li>
<li><code>&quot;u&quot;</code> : 第二个浮点寄存器</li>
<li><code>&quot;A&quot;</code> : 指定 <code>&quot;a&quot;</code> 或 <code>&quot;d&quot;</code> 寄存器。这主要用于想要返回 <code>64</code> 位整形数，使用 <code>&quot;d&quot;</code> 寄存器保存最高有效位和 <code>&quot;a&quot;</code> 寄存器保存最低有效位。</li>
</ul>
<h2 id="约束修饰符"><a href="#约束修饰符" class="headerlink" title="约束修饰符"></a>约束修饰符</h2><p>当使用约束时，对于更精确的控制超过了对约束作用的需求，<code>GCC</code> 给我们提供了约束修饰符。最常用的约束修饰符为：</p>
<ul>
<li><code>&quot;=&quot;</code> : 意味着对于这条指令，操作数为可写的；旧值会被忽略并被输出数据所替换。</li>
<li><code>&quot;&amp;&quot;</code> : 意味着这个操作数为一个早期改动的操作数，其在该指令完成前通过使用输入操作数被修改了。因此，这个操作数不可以位于一个被用作输出操作数或任何内存地址部分的寄存器。如果在旧值被写入之前它仅用作输入而已，一个输入操作数可以为一个早期改动操作数。</li>
</ul>
<p>上述只是一些常见的的约束列表和解释。</p>
<h1 id="一些实用的诀窍"><a href="#一些实用的诀窍" class="headerlink" title="一些实用的诀窍"></a>一些实用的诀窍</h1><p>现在我们已经介绍了关于 <code>GCC</code> 内联汇编的基础理论，现在我们将专注于一些简单的例子。将内联汇编函数写成宏的形式总是非常方便的。我们可以在 <code>Linux</code> 内核代码里看到许多汇编函数。（<code>usr/src/linux/include/asm/*.h</code>）。</p>
<p>首先我们从一个简单的例子入手。我们将写一个两个数相加的程序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> foo = <span class="number">10</span>, bar = <span class="number">15</span>;</span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;addl  %%ebx,%%eax&quot;</span></span><br><span class="line">                      :<span class="string">&quot;=a&quot;</span>(foo)</span><br><span class="line">                      :<span class="string">&quot;a&quot;</span>(foo), <span class="string">&quot;b&quot;</span>(bar)</span><br><span class="line">                      );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;foo+bar=%d\n&quot;</span>, foo);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们要求 <code>GCC</code> 将 <code>foo</code> 存放于 <code>%eax</code>，将 <code>bar</code> 存放于 <code>%ebx</code>，同时我们也想要在 <code>%eax</code> 中存放结果。<code>&quot;=&quot;</code> 符号表示它是一个输出寄存器。现在我们可以以其他方式将一个整数加到一个变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__asm__ __volatile__(</span><br><span class="line">                     <span class="string">&quot;   lock       ;\n&quot;</span></span><br><span class="line">                     <span class="string">&quot;   addl %1,%0 ;\n&quot;</span></span><br><span class="line">                     : <span class="string">&quot;=m&quot;</span>  (my_var)</span><br><span class="line">                     : <span class="string">&quot;ir&quot;</span>  (my_int), <span class="string">&quot;m&quot;</span> (my_var)</span><br><span class="line">                     :                                 <span class="comment">/* 无修饰寄存器列表 */</span></span><br><span class="line">                     );</span><br></pre></td></tr></table></figure>

<p>这是一个原子加法。为了移除原子性，我们可以移除指令 <code>lock</code> 。在输出域中，<code>&quot;=m&quot;</code> 表明 <code>myvar</code> 是一个输出且位于内存。类似地，<code>&quot;ir&quot;</code> 表明 <code>myint</code> 是一个整型，并应该存在于其他寄存器。没有寄存器位于修饰寄存器列表中。</p>
<p>现在我们将在一些寄存器&#x2F;变量上展示一些操作，并比较值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__asm__ __volatile__(  <span class="string">&quot;decl %0; sete %1&quot;</span></span><br><span class="line">                     : <span class="string">&quot;=m&quot;</span> (my_var), <span class="string">&quot;=q&quot;</span> (cond)</span><br><span class="line">                     : <span class="string">&quot;m&quot;</span> (my_var) </span><br><span class="line">                     : <span class="string">&quot;memory&quot;</span></span><br><span class="line">                     );</span><br></pre></td></tr></table></figure>

<p>这里，<code>my_var</code> 的值减 <code>1</code> ，并且如果结果的值为 <code>0</code>，则变量 <code>cond</code> 置 <code>1</code> 。我们可以通过将指令 <code>&quot;lock;\n\t&quot;</code> 添加为汇编模板的第一条指令以增加原子性。</p>
<p>这里需要注意的地方是:</p>
<ul>
<li><code>my_var</code> 是一个存储于内存的变量。 </li>
<li><code>cond</code> 位于寄存器 <code>eax、ebx、ecx、edx</code> 中的任何一个。</li>
<li><code>memory</code> 位于修饰寄存器列表中。也就是说，代码将改变内存中的内容。</li>
</ul>
<p>如何置 <code>1</code> 或清 <code>0</code> 寄存器中的一个比特位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__asm__ __volatile__(   &quot;btsl %1,%0&quot;</span><br><span class="line">                      : &quot;=m&quot; (ADDR)</span><br><span class="line">                      : &quot;Ir&quot; (pos)</span><br><span class="line">                      : &quot;cc&quot;</span><br><span class="line">                      );</span><br></pre></td></tr></table></figure>

<p>这里 <code>ADDR</code> 变量的 <code>pos</code> 位置上的比特被设置为 <code>1</code> 。我们可以使用 <code>btrl</code> 来清除由 <code>btsl</code> 设置的比特位。 <code>pos</code> 的约束 <code>&quot;Ir&quot;</code> 表明 <code>pos</code> 位于寄存器，并且它的值为<code> 0-31</code>。也就是说，我们可以设置&#x2F;清除 <code>ADDR</code> 变量上第 <code>0</code> 到 <code>31</code> 位的任意位。因为条件码会被改变，所以我们将 <code>&quot;cc&quot;</code> 添加进修饰寄存器列表。</p>
<p>现在我们看看一些更为复杂而有用的函数。字符串拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">char</span> * <span class="title">strcpy</span><span class="params">(<span class="type">char</span> * dest,<span class="type">const</span> <span class="type">char</span> *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d0, d1, d2;</span><br><span class="line">    __asm__ __volatile__(  <span class="string">&quot;1:\tlodsb\n\t&quot;</span></span><br><span class="line">                           <span class="string">&quot;stosb\n\t&quot;</span></span><br><span class="line">                           <span class="string">&quot;testb %%al,%%al\n\t&quot;</span></span><br><span class="line">                           <span class="string">&quot;jne 1b&quot;</span></span><br><span class="line">                         : <span class="string">&quot;=&amp;S&quot;</span> (d0), <span class="string">&quot;=&amp;D&quot;</span> (d1), <span class="string">&quot;=&amp;a&quot;</span> (d2)</span><br><span class="line">                         : <span class="string">&quot;0&quot;</span> (src),<span class="string">&quot;1&quot;</span> (dest) </span><br><span class="line">                         : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源地址存放于 <code>esi</code>，目标地址存放于 <code>edi</code>，同时开始拷贝，当我们到达 <code>0</code> 时，拷贝完成。约束 <code>&quot;&amp;S&quot;</code>、<code>&quot;&amp;D&quot;</code>、<code>&quot;&amp;a&quot;</code> 表明寄存器 <code>esi、edi</code> 和 <code>eax</code> 早期修饰寄存器，也就是说，它们的内容在函数完成前会被改变。这里很明显可以知道为什么 <code>&quot;memory&quot;</code> 会放在修饰寄存器列表。</p>
<p>我们可以看到一个类似的函数，它能移动双字块数据。注意函数被声明为一个宏。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> mov_blk(src, dest, numwords) \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__ (                                          \</span></span><br><span class="line"><span class="meta">                       <span class="string">&quot;cld\n\t&quot;</span>                                \</span></span><br><span class="line"><span class="meta">                       <span class="string">&quot;rep\n\t&quot;</span>                                \</span></span><br><span class="line"><span class="meta">                       <span class="string">&quot;movsl&quot;</span>                                  \</span></span><br><span class="line"><span class="meta">                       :                                        \</span></span><br><span class="line"><span class="meta">                       : <span class="string">&quot;S&quot;</span> (src), <span class="string">&quot;D&quot;</span> (dest), <span class="string">&quot;c&quot;</span> (numwords)  \</span></span><br><span class="line"><span class="meta">                       : <span class="string">&quot;%ecx&quot;</span>, <span class="string">&quot;%esi&quot;</span>, <span class="string">&quot;%edi&quot;</span>                 \</span></span><br><span class="line"><span class="meta">                       )</span></span><br></pre></td></tr></table></figure>

<p>这里我们没有输出，寄存器 <code>ecx、esi</code>和 <code>edi</code> 的内容发生了改变，这是块移动的副作用。因此我们必须将它们添加进修饰寄存器列表。</p>
<p>在 <code>Linux</code> 中，系统调用使用 <code>GCC</code> 内联汇编实现。让我们看看如何实现一个系统调用。所有的系统调用被写成宏（<code>linux/unistd.h</code>）。例如，带有三个参数的系统调用被定义为如下所示的宏。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">type <span class="title">name</span><span class="params">(type1 arg1,type2 arg2,type3 arg3)</span> \</span></span><br><span class="line"><span class="function"></span>&#123; \</span><br><span class="line"><span class="type">long</span> __res; \</span><br><span class="line"><span class="function">__asm__ <span class="title">volatile</span> <span class="params">(  <span class="string">&quot;int $0x80&quot;</span> \</span></span></span><br><span class="line"><span class="params"><span class="function">                  : <span class="string">&quot;=a&quot;</span> (__res) \</span></span></span><br><span class="line"><span class="params"><span class="function">                  : <span class="string">&quot;0&quot;</span> (__NR_##name),<span class="string">&quot;b&quot;</span> ((<span class="type">long</span>)(arg1)),<span class="string">&quot;c&quot;</span> ((<span class="type">long</span>)(arg2)), \</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="string">&quot;d&quot;</span> ((<span class="type">long</span>)(arg3)))</span></span>; \</span><br><span class="line">__syscall_return(type,__res); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论何时调用带有三个参数的系统调用，以上展示的宏就会用于执行调用。系统调用号位于 <code>eax</code> 中，每个参数位于<code> ebx、ecx、edx</code> 中。最后 <code>&quot;int 0x80&quot;</code> 是一条用于执行系统调用的指令。返回值被存储于 <code>eax</code> 中。</p>
<p>每个系统调用都以类似的方式实现。<code>exit</code> 是一个单一参数的系统调用，让我们看看它的代码看起来会是怎样。它如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">asm</span>(<span class="string">&quot;movl $1,%%eax;         /* SYS_exit is 1 */</span></span><br><span class="line"><span class="string">         xorl %%ebx,%%ebx;      /* Argument is in ebx, it is 0 */</span></span><br><span class="line"><span class="string">         int  $0x80&quot;</span>            <span class="comment">/* Enter kernel mode */</span></span><br><span class="line">         );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exit</code> 的系统调用号是 <code>1</code> ，同时它的参数是 <code>0</code> 。因此我们分配 <code>eax</code> 包含 <code>1</code>，<code>ebx</code> 包含 <code>0</code> ，同时通过 <code>&quot;int $0x80&quot;</code> 执行 <code>&quot;exit(0)&quot;</code>。这就是 <code>exit</code> 的工作原理。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB命令基础，让你的程序bug无处躲藏</title>
    <url>/2020/05/05/GDB%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BA%8Fbug%E6%97%A0%E5%A4%84%E8%BA%B2%E8%97%8F/</url>
    <content><![CDATA[<blockquote>
<p>转载: <a href="https://deepzz.com/post/gdb-debug.html">https://deepzz.com/post/gdb-debug.html</a></p>
</blockquote>
<!-- TOC -->

<ul>
<li><a href="#%E4%BD%BF%E7%94%A8gdb">使用GDB</a><ul>
<li><a href="#%E5%90%AF%E5%8A%A8">启动</a></li>
<li><a href="#%E8%BF%90%E8%A1%8C">运行</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%9F%A5%E7%9C%8B%E6%96%AD%E7%82%B9breakpoint">设置&#x2F;查看断点(breakpoint)</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%9F%A5%E7%9C%8B%E8%A7%82%E5%AF%9F%E7%82%B9watchpoint">设置&#x2F;查看观察点(watchpoint)</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%9F%A5%E7%9C%8B%E6%8D%95%E6%8D%89%E7%82%B9catchpoint">设置&#x2F;查看捕捉点(catchpoint)</a></li>
<li><a href="#%E7%BB%B4%E6%8A%A4%E5%81%9C%E6%AD%A2%E7%82%B9">维护停止点</a></li>
<li><a href="#%E7%BB%B4%E6%8A%A4%E6%9D%A1%E4%BB%B6%E5%81%9C%E6%AD%A2%E7%82%B9">维护条件停止点</a></li>
<li><a href="#%E5%81%9C%E6%AD%A2%E7%82%B9%E8%AE%BE%E7%BD%AE%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4">停止点设置运行命令</a></li>
<li><a href="#%E6%96%AD%E7%82%B9%E8%8F%9C%E5%8D%95">断点菜单</a></li>
<li><a href="#%E6%81%A2%E5%A4%8D%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%92%8C%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95">恢复程序运行和单步调试</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7">信号</a></li>
<li><a href="#%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7%E9%87%8F">产生信号量</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B">线程</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%A0%88%E4%BF%A1%E6%81%AF">查看栈信息</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%BA%90%E7%A0%81">查看源码</a></li>
<li><a href="#%E6%90%9C%E7%B4%A2%E6%BA%90%E4%BB%A3%E7%A0%81">搜索源代码</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A%E6%BA%90%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84">指定源文件路径</a></li>
<li><a href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E5%86%85%E5%AD%98">源代码内存</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE">查看运行时数据</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98">查看内存</a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E6%98%BE%E7%A4%BA">自动显示</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%98%BE%E7%A4%BA%E9%80%89%E9%A1%B9">设置显示选项</a></li>
<li><a href="#%E5%8E%86%E5%8F%B2%E7%BA%AA%E5%BD%95">历史纪录</a></li>
<li><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%AF%84%E5%AD%98%E5%99%A8">查看寄存器</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C">修改程序的执行</a></li>
<li><a href="#%E8%B7%B3%E8%BD%AC%E6%89%A7%E8%A1%8C">跳转执行</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E">强制函数返回</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0">强制调用函数</a></li>
<li><a href="#gdb%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83">GDB语言环境</a></li>
<li><a href="#%E9%80%80%E5%87%BA">退出</a></li>
<li><a href="#%E6%8A%80%E5%B7%A7">技巧</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<p>软件开发，或多或少会走上调试这条路。调试工具可以帮你更加深入了解整个程序的运行状态，对程序运行有更多的主动权。你可以随心所欲的改变程序运行流程，如：有变量a，你需要不断改变该a的值，让程序运行出理想的结果，那么你可以在调试工具中轻易的实现。</p>
<ul>
<li>运行你的程序，设置所有的能影响程序运行的东西。</li>
<li>保证你的程序在指定的条件下停止。</li>
<li>当你程序停止时，让你检查发生了什么。</li>
<li>改变你的程序。那样你可以试着修正某个bug引起的问题，然后继续查找另一 个bug</li>
</ul>
<p>今天给大家带来的gdb调试工具。GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。GDB可以调试C、C++、D、Go、python、pascal、assemble(ANSI 汇编标准)等等语言。</p>
<h1 id="使用GDB"><a href="#使用GDB" class="headerlink" title="使用GDB"></a>使用GDB</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gdb program           # program是你的可执行文件，一般在当前目录</span><br><span class="line">$ gdb program core      # gdb同时调试运行程序和core文件，core是程序非法执行产生的文件</span><br><span class="line">$ gdb program pid       # 如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) r/run             # 开始运行程序</span><br><span class="line">(gdb) c/continue        # 继续运行</span><br><span class="line">(gdb) n/next            # 下一行，不进入函数调用</span><br><span class="line">(gdb) s/step            # 下一行，进入函数调用</span><br><span class="line">(gdb) ni/si             # 下一条指令，ni和si区别同上</span><br><span class="line">(gdb) fini/finish       # 继续运行至函数退出/当前栈帧</span><br><span class="line">(gdb) u/util            # 继续运行至某一行，在循环中，u可以实现运行至循环刚刚退出，但这取决于循环的实现</span><br><span class="line"></span><br><span class="line">(gdb) set args          # 设置程序启动参数，如：set args 10 20 30</span><br><span class="line">(gdb) show args         # 查看程序启动参数</span><br><span class="line">(gdb) path &lt;dir&gt;        # 设置程序的运行路径</span><br><span class="line">(gdb) show paths        # 查看程序的运行路径</span><br><span class="line">(gdb) set env &lt;name=val&gt;# 设置环境变量，如：set env USER=chen</span><br><span class="line">(gdb) show env [name]   # 查看环境变量</span><br><span class="line">(gdb) cd &lt;dir&gt;          # 相当于shell的cd命令</span><br><span class="line">(gdb) pwd               # 显示当前所在目录</span><br><span class="line"></span><br><span class="line">(gdb) shell &lt;commond&gt;   # 执行shell命令</span><br></pre></td></tr></table></figure>

<h2 id="设置-x2F-查看断点-breakpoint"><a href="#设置-x2F-查看断点-breakpoint" class="headerlink" title="设置&#x2F;查看断点(breakpoint)"></a>设置&#x2F;查看断点(breakpoint)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b/break linenum/func      # 在第linenum行或function处停住</span><br><span class="line">(gdb) b/break +/-offset         # 在当前行号后/前offset行停住</span><br><span class="line">(gdb) b/break filename:linenum  # 在源文件filename的linenum行停住</span><br><span class="line">(gdb) b/break filename:func     # 在源文件的function入口停住</span><br><span class="line">(gdb) b/break *address          # 在内存地址address处停住</span><br><span class="line">(gdb) b/break                   # 没有参数，表示下一跳指令处停住</span><br><span class="line">(gdb) b/break if &lt;condition&gt;    # 条件成立是停住，如在循环中：break if i=100</span><br><span class="line"></span><br><span class="line">(gdb) info break [n]            # 查看断点， n表示断点号</span><br></pre></td></tr></table></figure>

<h2 id="设置-x2F-查看观察点-watchpoint"><a href="#设置-x2F-查看观察点-watchpoint" class="headerlink" title="设置&#x2F;查看观察点(watchpoint)"></a>设置&#x2F;查看观察点(watchpoint)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 观察点一搬来观察某个表达式或变量的值是否有变化了，有：程序停住</span><br><span class="line">(gdb) watch &lt;expr&gt;              # 观察值是否有变化</span><br><span class="line">(gdb) rwatch &lt;expr&gt;             # 当expr被读取时，停住</span><br><span class="line">(gdb) awatch &lt;expr&gt;             # 当expr被读取或写入时，停住</span><br><span class="line"></span><br><span class="line">(gdb) info watchpoints          # 查看所有观察点</span><br></pre></td></tr></table></figure>

<h2 id="设置-x2F-查看捕捉点-catchpoint"><a href="#设置-x2F-查看捕捉点-catchpoint" class="headerlink" title="设置&#x2F;查看捕捉点(catchpoint)"></a>设置&#x2F;查看捕捉点(catchpoint)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 你可设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常。</span><br><span class="line">(gdb) tcatch &lt;event&gt;            # 只设置一次捕捉点</span><br><span class="line">(gdb) catch &lt;event&gt;             # 当event发生时，停住程序，如下：</span><br><span class="line"># throw             一个c++抛出的异常（throw为关键字）</span><br><span class="line"># catch             一个C++捕捉到的异常（catch为关键字）</span><br><span class="line"># exec              调用系统调用exec时（只在HP-UX下有用）</span><br><span class="line"># fork              调用系统调用fork时（只在HP-UX下有用）</span><br><span class="line"># vfork             调用系统调用vfork时（只在HP-UX下有用）</span><br><span class="line"># load [file]       载入共享库（动态链接库）时（只在HP-UX下有用）</span><br><span class="line"># unload [libname]  卸载共享库（动态链接库）时（只在HP-UX下有用）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="维护停止点"><a href="#维护停止点" class="headerlink" title="维护停止点"></a>维护停止点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 上面说了三种如何设置停止点的方法。在gdb中如果你觉得已经定义好的停止点没有用，那么你可以delete、clear、disable、enable进行维护</span><br><span class="line">(gdb) clear                     # 清除所有已定义的停止点。如果程序运行，清除当前行之后的</span><br><span class="line">(gdb) clear &lt;fuction&gt;           # 清除所有设置在函数上的停止点</span><br><span class="line">(gdb) clear &lt;file:line&gt;         # 清除所有设置在指定行上的停止点</span><br><span class="line">(gdb) d/delete [n]/[m-n]        # 删除断点号，不设置则删除全部，也可以范围m-n</span><br><span class="line"></span><br><span class="line"># 比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样。</span><br><span class="line">(gdb) disable [n]/[m-n]         # disable指定断点号n，不指定则disable所有，也可以范围m-n</span><br><span class="line"></span><br><span class="line">(gdb) enable [n]/[m-n]          # enable断点n，也可以范围m-n</span><br><span class="line">(gdb) enable once [n]/[m-n]     # enable断点n一次，程序停止后自动disable，也可以范围m-n</span><br><span class="line">(gdb) enable delete [n]/[m-n]   # enable断点，程序结束自动删除，也可以范围m-n</span><br></pre></td></tr></table></figure>

<h2 id="维护条件停止点"><a href="#维护条件停止点" class="headerlink" title="维护条件停止点"></a>维护条件停止点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 前面说到设置breakpoint可以设置成一个条件，这里列出相关的维护命令</span><br><span class="line">(gdb) condition &lt;bunm&gt; &lt;expr&gt;   # 修改断掉号bnum的停止条件</span><br><span class="line">(gdb) condition &lt;bnum&gt;          # 清除断点号bnum的停止条件</span><br><span class="line"></span><br><span class="line"># ignore 可以指定程序运行时，忽略停止条件几次</span><br><span class="line">(gdb) ignore &lt;bnum&gt; &lt;count&gt;     # 忽略断点号hnum的停止条件count次</span><br></pre></td></tr></table></figure>

<h2 id="停止点设置运行命令"><a href="#停止点设置运行命令" class="headerlink" title="停止点设置运行命令"></a>停止点设置运行命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当程序停住时，我们可以通过command设置其自动执行的命令，这很利于自动化调试。</span><br><span class="line">(gdb) commands [bnum]</span><br><span class="line">&gt; ... commands list ...</span><br><span class="line">&gt; end                   # 这里为断点号bnum设置一个命令列表</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">(gdb) break foo if x&gt;0</span><br><span class="line">(gdb) commands</span><br><span class="line">&gt; printf &quot;x is %dn&quot;,x</span><br><span class="line">&gt; continue</span><br><span class="line">&gt; end</span><br><span class="line"># 断点设置在函数foo中，断点条件是x&gt;0，如果程序被断住后，也就是，一旦x的值在foo函数中大于0，GDB会自动打印出x的值，并继续运行程序。</span><br><span class="line"># 如果你要清除断点上的命令序列，那么只要简单的执行一下commands命令，并直接在打个end就行了。</span><br></pre></td></tr></table></figure>

<h2 id="断点菜单"><a href="#断点菜单" class="headerlink" title="断点菜单"></a>断点菜单</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果你使用c++，有可能下断点时遇到相同名字的函数，gdb会为你列出该函数菜单供你选择。</span><br><span class="line">如：</span><br><span class="line">(gdb) b String::after</span><br><span class="line">[0] cancel</span><br><span class="line">[1] all</span><br><span class="line">[2] file:String.cc; line number:867</span><br><span class="line">[3] file:String.cc; line number:860</span><br><span class="line">[4] file:String.cc; line number:875</span><br><span class="line">[5] file:String.cc; line number:853</span><br><span class="line">[6] file:String.cc; line number:846</span><br><span class="line">[7] file</span><br><span class="line">&gt; 2 4 6</span><br><span class="line">Breakpoint 1 at 0xb26c: file String.cc, line 867.</span><br><span class="line">Breakpoint 2 at 0xb344: file String.cc, line 875.</span><br><span class="line">Breakpoint 3 at 0xafcc: file String.cc, line 846.</span><br></pre></td></tr></table></figure>

<h2 id="恢复程序运行和单步调试"><a href="#恢复程序运行和单步调试" class="headerlink" title="恢复程序运行和单步调试"></a>恢复程序运行和单步调试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当程序被停住了，你可以用c/continue恢复运行，或下一个断点到来。也可以使用step或next命令单步跟踪程序。</span><br><span class="line">(gdb) c/continue [ignore-count]     # 恢复程序运行，ignore-count忽略后面断点数</span><br><span class="line"></span><br><span class="line"># 单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug信息。很像VC等工具中的stepin。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。</span><br><span class="line">(gdb) step &lt;count&gt;</span><br><span class="line"></span><br><span class="line"># 打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。这个参数有很利于查看机器码。</span><br><span class="line">(gdb) set step-mode on</span><br><span class="line"></span><br><span class="line"># 当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</span><br><span class="line">(gdb) u/until</span><br><span class="line"></span><br><span class="line"># 单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。与之一样有相同功能的命令是“display/i $pc” ，当运行完这个命令后，单步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）</span><br><span class="line">(gdb) si/stepi</span><br><span class="line">(gdb) ni/stepi</span><br></pre></td></tr></table></figure>

<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 信号是一种软中断，是一种处理异步事件的方法。一般来说，操作系统都支持许多信号。尤其是UNIX，比较重要应用程序一般都会处理信号。UNIX定义了许多信号，比如SIGINT表示中断字符信号，也就是Ctrl+C的信号，SIGBUS表示硬件故障的信号；SIGCHLD表示子进程状态改变信号；SIGKILL表示终止程序运行的信号，等等。信号量编程是UNIX下非常重要的一种技术。</span><br><span class="line"># GDB有能力在你调试程序的时候处理任何一种信号，你可以告诉GDB需要处理哪一种信号。你可以要求GDB收到你所指定的信号时，马上停住正在运行的程序，以供你进行调试。你可以用GDB的handle命令来完成这一功能。</span><br><span class="line">(gdb) handle &lt;signal&gt; &lt;keywords...&gt;</span><br><span class="line"># 在GDB中定义一个信号处理。信号&lt;signal&gt;可以以SIG开头或不以SIG开头，可以用定义一个要处理信号的范围（如：SIGIO-SIGKILL，表示处理从SIGIO信号到SIGKILL的信号，其中包括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字all来标明要处理所有的信号。一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。其&lt;keywords&gt;可以是以下几种关键字的一个或多个。</span><br><span class="line">  nostop            # 当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号。</span><br><span class="line">  stop          # 当被调试的程序收到信号时，GDB会停住你的程序。</span><br><span class="line">  print         # 当被调试的程序收到信号时，GDB会显示出一条信息。</span><br><span class="line">  noprint           # 当被调试的程序收到信号时，GDB不会告诉你收到信号的信息。</span><br><span class="line">  pass/noignore # 当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序会处理。</span><br><span class="line">  nopass/ignore # 当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。</span><br><span class="line"></span><br><span class="line"># 查看有哪些信号在被GDB检测中。</span><br><span class="line">(gdb) info signals</span><br><span class="line">(gdb) info handle</span><br></pre></td></tr></table></figure>

<h2 id="产生信号量"><a href="#产生信号量" class="headerlink" title="产生信号量"></a>产生信号量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用singal命令，可以产生一个信号量给被调试的程序。如：中断信号Ctrl+C。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号非常有利程序的调试。语法是：</span><br><span class="line">(gdb) signal &lt;singal&gt;</span><br><span class="line"># UNIX的系统信号量通常从1到15。所以&lt;singal&gt;取值也在这个范围。</span><br><span class="line"># single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。</span><br></pre></td></tr></table></figure>

<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当你的程序时多线程的，你可以定义断点是否在所有线程或某个线程</span><br><span class="line">(gdb) info threads                          # 查看线程</span><br><span class="line">(gdb) break &lt;line&gt; thread &lt;threadno&gt;        # 指定源程序line行，线程threadno停住</span><br><span class="line">(gdb) break &lt;line&gt; thread &lt;threadno&gt; if...  # 指定源程序line行，线程threadno停住，跟上条件</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">(gdb) break frik.c:13 thread 28 if bartab &gt; lim</span><br></pre></td></tr></table></figure>

<h2 id="查看栈信息"><a href="#查看栈信息" class="headerlink" title="查看栈信息"></a>查看栈信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。</span><br><span class="line">(gdb) bt/backtrace          # 打印当前的啊还能输调用栈的所有信息</span><br><span class="line">(gdb) bt/backtrace &lt;n&gt;      # 当n为正数，打印栈顶n层。为负数，打印栈低n层</span><br><span class="line"></span><br><span class="line"># 如果你要查看某一层的信息，你需要在切换当前的栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。</span><br><span class="line">(gdb) f/frame &lt;n&gt;           # n从0开始，是栈中的编号</span><br><span class="line">(gdb) up &lt;n&gt;                # 向栈的上面移动n层。如无n，向上移动一层</span><br><span class="line">(gdb) down &lt;n&gt;              # 向栈的下面移动n层。如无n，向下移动一层</span><br><span class="line"></span><br><span class="line"># 栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。</span><br><span class="line">(gdb) f/frame</span><br><span class="line"></span><br><span class="line"># 这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内内地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等。</span><br><span class="line">(gdb) info f/frame</span><br><span class="line"></span><br><span class="line">(gdb) info args             # 打印当前函数的参数名及值</span><br><span class="line">(gdb) info locals           # 打印当前函数中所有局部变量及值</span><br><span class="line">(gdb) info catch            # 打印当前函数中的异常处理信息</span><br></pre></td></tr></table></figure>

<h2 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在程序编译时一定要加上-g的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。</span><br><span class="line">(gdb) l                         # 显示当前行前后的源码</span><br><span class="line">(gdb) l -                       # 显示当前行前的源码</span><br><span class="line">(gdb) l +                       # 显示当前行后的源码</span><br><span class="line">(gdb) l/list &lt;linuenum/func&gt;    # 查看第linenum行或者function所在行附近的10行</span><br><span class="line">(gdb) l/list                    # 查看上一次list命令列出的代码后面的10行</span><br><span class="line">(gdb) l/list m,n                # 查看从第m行到第n行的源码。m不填，则从当前行到n</span><br><span class="line">(gdb) l/list -/+offset          # 查看想对当前行偏移offset源码</span><br><span class="line">(gdb) l/list &lt;file:line&gt;        # 查看文件file的line行的源码</span><br><span class="line">(gdb) l/list &lt;func&gt;             # 查看函数名func源码</span><br><span class="line">(gdb) l/list &lt;file:func&gt;        # 查看文件file的函数func源码</span><br><span class="line">(gdb) l/list &lt;*address&gt;         # 查看运行时内存地址address的源码</span><br><span class="line"></span><br><span class="line">(gdb) set listsize              # 设置一次显示源码的行数</span><br><span class="line">(gdb) show listsize             # 查看listsize的值</span><br></pre></td></tr></table></figure>

<h2 id="搜索源代码"><a href="#搜索源代码" class="headerlink" title="搜索源代码"></a>搜索源代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) forward-search &lt;regexp&gt;   # 向前搜索，regexp是一个正则表达式</span><br><span class="line">(gdb) search &lt;regexp&gt;           # 向前搜索</span><br><span class="line">(gdb) reverse-search &lt;regexp&gt;   # 全局搜索</span><br></pre></td></tr></table></figure>

<h2 id="指定源文件路径"><a href="#指定源文件路径" class="headerlink" title="指定源文件路径"></a>指定源文件路径</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 某些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供了可以让你指定源文件的路径的命令，以便GDB进行搜索。</span><br><span class="line">(gdb) dir/directory &lt;dirname ... &gt;  # 加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，Windows下你可以使用“;”。</span><br><span class="line">(gdb) dir/directory                 # 清除所有的自定义的源文件搜索路径信息。</span><br><span class="line">(gdb) show directories              # 显示定义了的源文件搜索路径。</span><br></pre></td></tr></table></figure>

<h2 id="源代码内存"><a href="#源代码内存" class="headerlink" title="源代码内存"></a>源代码内存</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info line                     # 查看源代码在内存中的地址，还可以:</span><br><span class="line">(gdb) info line &lt;num&gt;</span><br><span class="line">(gdb) info line &lt;file:num&gt;</span><br><span class="line">(gdb) info line &lt;func&gt;</span><br><span class="line">(gdb) info line &lt;file:func&gt;</span><br><span class="line"></span><br><span class="line"># 还有一个命令（disassemble）你可以查看源程序的当前执行时的机器码，这个命令会把目前内存中的指令dump出来。如下面的示例表示查看函数func的汇编代码。</span><br><span class="line">(gdb) disassemble func</span><br></pre></td></tr></table></figure>

<h2 id="查看运行时数据"><a href="#查看运行时数据" class="headerlink" title="查看运行时数据"></a>查看运行时数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># &lt;expr&gt;是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），&lt;f&gt;是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是/x。</span><br><span class="line">(gdb) p/print &lt;expr&gt;            # expr可以是const常量、变量、函数等内容</span><br><span class="line">(gdb) p/print /&lt;f&gt; &lt;expr&gt;</span><br><span class="line"></span><br><span class="line"># 在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中。</span><br><span class="line">    @                   是一个和数组有关的操作符，在后面会有更详细的说明。</span><br><span class="line">    ::                  指定一个在文件或是一个函数中的变量。</span><br><span class="line">    &#123;&lt;type&gt;&#125; &lt;addr&gt;     表示一个指向内存地址&lt;addr&gt;的类型为type的一个对象。</span><br><span class="line"># 需要注意的是，如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。</span><br><span class="line"></span><br><span class="line"># 输出格式</span><br><span class="line"># 一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要做到这样，你可以使用GDB的数据显示格式：</span><br><span class="line">    x 按十六进制格式显示变量。</span><br><span class="line">    d 按十进制格式显示变量。</span><br><span class="line">    u 按十六进制格式显示无符号整型。</span><br><span class="line">    o 按八进制格式显示变量。</span><br><span class="line">    t 按二进制格式显示变量。</span><br><span class="line">    a 按十六进制格式显示变量。 </span><br><span class="line">    c 按字符格式显示变量。 </span><br><span class="line">    f 按浮点数格式显示变量。</span><br><span class="line">  </span><br><span class="line">如：</span><br><span class="line">(gdb) p i</span><br><span class="line">$21 = 101</span><br><span class="line">(gdb) p/a i</span><br><span class="line">$22 = 0x65</span><br></pre></td></tr></table></figure>

<h2 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：</span><br><span class="line">(gdb) x/&lt;n/f/u&gt; &lt;addr&gt;          # n, f, u可选</span><br><span class="line"></span><br><span class="line">    n       是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。</span><br><span class="line">    f       表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地址是指令地址，那么格式可以是i。</span><br><span class="line">    u       表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</span><br><span class="line">    &lt;addr&gt;  表示一个内存地址。</span><br><span class="line"></span><br><span class="line"># n/f/u三个参数可以一起使用。例如：</span><br><span class="line">(gdb) x/3uh 0x54320             #表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。</span><br></pre></td></tr></table></figure>

<h2 id="自动显示"><a href="#自动显示" class="headerlink" title="自动显示"></a>自动显示</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。</span><br><span class="line">(gdb) display &lt;expr&gt;</span><br><span class="line">(gdb) display/&lt;fmt&gt; &lt;expr&gt;</span><br><span class="line">(gdb) display/&lt;fmt&gt; &lt;addr&gt;</span><br><span class="line"># expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。</span><br><span class="line"></span><br><span class="line"># 格式i和s同样被display支持，一个非常有用的命令是：</span><br><span class="line">(gdb) display/i $pc</span><br><span class="line"># $pc是GDB的环境变量，表示着指令的地址，/i则表示输出格式为机器指令码，也就是汇编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形，这是一个很有意思的功能。</span><br><span class="line">下面是一些和display相关的GDB命令：</span><br><span class="line">(gdb) undisplay &lt;dnums...&gt;</span><br><span class="line">(gdb) delete display &lt;dnums...&gt;</span><br><span class="line"># 删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个</span><br><span class="line"># 范围内的编号，可以用减号表示（如：2-5）</span><br><span class="line">(gdb) disable display &lt;dnums...&gt;</span><br><span class="line">(gdb) enable display &lt;dnums...&gt;</span><br><span class="line"># disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。</span><br><span class="line">(gdb) info display</span><br><span class="line"># 查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。</span><br></pre></td></tr></table></figure>

<h2 id="设置显示选项"><a href="#设置显示选项" class="headerlink" title="设置显示选项"></a>设置显示选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># GDB中关于显示的选项比较多，这里我只例举大多数常用的选项。</span><br><span class="line"># 1、打开地址输出，当程序显示函数信息时，GDB会显出函数的参数地址。系统默认为打开的</span><br><span class="line">(gdb) set print address</span><br><span class="line">(gdb) set print address on </span><br><span class="line">(gdb) set print address off     # 关闭函数的参数地址显示</span><br><span class="line">(gdb) show print address        # 查看当前地址显示选项是否打开。</span><br><span class="line"></span><br><span class="line"># 2、打开数组显示，打开后当数组显示时，每个元素占一行，如果不打开的话，每个元素则以逗号分隔。这个选项默认是关闭的。</span><br><span class="line">(gdb) set print array</span><br><span class="line">(gdb) set print array on </span><br><span class="line">(gdb) set print array off</span><br><span class="line">(gdb) show print array</span><br><span class="line">(gdb) show print elements       # 查看print elements的选项信息。</span><br><span class="line">(gdb) set print elements &lt;number-of-elements&gt;</span><br><span class="line"># 这个选项主要是设置数组的，如果你的数组太大了，那么就可以指定一个&lt;number-of-elements&gt;来指定数据显示的最大长度，当到达这个长度时，GDB就不再往下显示了。如果设置为0，则表示不限制。</span><br><span class="line"></span><br><span class="line"># 3、如果打开了这个选项，那么当显示字符串时，遇到结束符则停止显示。这个选项默认为off</span><br><span class="line">(gdb) set print null-stop &lt;on/off&gt;  </span><br><span class="line"></span><br><span class="line"># 4、如果打开printf pretty这个选项，那么当GDB显示结构体时会比较漂亮。</span><br><span class="line">(gdb) set print pretty on </span><br><span class="line">(gdb) show print pretty         # 查看GDB是如何显示结构体的。\</span><br><span class="line"></span><br><span class="line"># 5、设置字符显示，是否按“nnn”的格式显示，如果打开，则字符串或字符数据按nnn显示，如“65”。</span><br><span class="line">(gdb) set print sevenbit-strings &lt;on/off&gt;</span><br><span class="line">(gdb) show print sevenbit-strings   # 查看字符显示开关是否打开。</span><br><span class="line"></span><br><span class="line"># 6、设置显示结构体时，是否显式其内的联合体数据。</span><br><span class="line">(gdb) set print union &lt;on/off&gt;</span><br><span class="line">(gdb) show print union              # 查看联合体数据的显示方式</span><br><span class="line">如：</span><br><span class="line">$1 = &#123;it = Tree, form = &#123;tree = Acorn, bug = Cocoon&#125;&#125;   # 开</span><br><span class="line">$1 = &#123;it = Tree, form = &#123;...&#125;&#125;                          # 关</span><br><span class="line"></span><br><span class="line"># 7、在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。</span><br><span class="line">(gdb) set print object &lt;on/off&gt;</span><br><span class="line">(gdb) show print object             # 查看对象选项的设置。</span><br><span class="line"></span><br><span class="line"># 8、这个选项表示，当显示一个C++对象中的内容是，是否显示其中的静态数据成员。默认是on。</span><br><span class="line">(gdb) set print static-members &lt;on/off&gt;</span><br><span class="line">(gdb) show print static-members     # 查看静态数据成员选项设置。</span><br><span class="line"></span><br><span class="line"># 9、当此选项打开时，GDB将用比较规整的格式来显示虚函数表时。其默认是关闭的。</span><br><span class="line">(gdb) set print vtbl &lt;on/off&gt;</span><br><span class="line">(gdb) show print vtbl               # 查看虚函数显示格式的选项。</span><br></pre></td></tr></table></figure>

<h2 id="历史纪录"><a href="#历史纪录" class="headerlink" title="历史纪录"></a>历史纪录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当你用GDB的print查看程序运行时的数据时，你每一个print都会被GDB记录下来。GDB会以$1, $2, $3 .....这样的方式为你每一个print命令编上号。于是，你可以使用这个编号访问以前的表达式，如$1。这个功能所带来的好处是，如果你先前输入了一个比较长的表达式，如果你还想查看这个表达式的值，你可以使用历史记录来访问，省去了重复输入。</span><br></pre></td></tr></table></figure>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 你可以在GDB的调试环境中定义自己的变量，用来保存一些调试程序中的运行数据。要定义一个GDB的变量很简单只需。 使用GDB的set命令。GDB的环境变量和UNIX一样，也是以$起头。如：</span><br><span class="line">(gdb) set $foo = *object_ptr</span><br><span class="line"># 使用环境变量时，GDB会在你第一次使用时创建这个变量，而在以后的使用中，则直接对其賦值。环境变量没有类型，你可以给环境变量定义任一的类型。包括结构体和数组。</span><br><span class="line">(gdb) show convenience</span><br><span class="line"># 该命令查看当前所设置的所有的环境变量。这是一个比较强大的功能，环境变量和程序变量的交互使用，将使得程序调试更为灵活便捷。例如：</span><br><span class="line">(gdb) set $i = 0</span><br><span class="line">(gdb) print bar[$i++]-&gt;contents</span><br><span class="line"># 于是，当你就不必，print bar[0]-&gt;contents, print bar[1]-&gt;contents地输入命令了。输入这样的命令后，只用敲回车，重复执行上一条语句，环境变量会自动累加，从而完成逐个输出的功能。</span><br></pre></td></tr></table></figure>

<h2 id="查看寄存器"><a href="#查看寄存器" class="headerlink" title="查看寄存器"></a>查看寄存器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈地址（sp）等等。你同样可以使用print命令来访问寄存器的情况，只需要在寄存器名字前加一个$符号就可以了。如：p $eip。</span><br><span class="line">(gdb) info registers        # 查看寄存器状态(除浮点寄存器)</span><br><span class="line">(gdb) info all-registers    # 查看所有寄存器状态</span><br><span class="line">(gdb) info registers regname# 查看指定寄存器状态，如：info rbp</span><br></pre></td></tr></table></figure>

<h2 id="修改程序的执行"><a href="#修改程序的执行" class="headerlink" title="修改程序的执行"></a>修改程序的执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一旦使用GDB挂上被调试程序，当程序运行起来后，你可以根据自己的调试思路来动态地在GDB中更改当前被调试程序的运行线路或是其变量的值，这个强大的功能能够让你更好的调试你的程序，比如，你可以在程序的一次运行中走遍程序的所有分支。</span><br><span class="line"></span><br><span class="line"># 一、修改变量值</span><br><span class="line"># 修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的print命令即可完成。如：</span><br><span class="line">(gdb) print x=4</span><br><span class="line"># x=4这个表达式是C/C++的语法，意为把变量x的值修改为4，如果你当前调试的语言是Pascal，那么你可以使用Pascal的语法：x:=4。</span><br><span class="line"># 在某些时候，很有可能你的变量和GDB中的参数冲突，如：</span><br><span class="line">(gdb) whatis width</span><br><span class="line">type = double</span><br><span class="line">(gdb) p width</span><br><span class="line">$4 = 13</span><br><span class="line">(gdb) set width=47</span><br><span class="line">Invalid syntax in expression.</span><br><span class="line"># 因为，set width是GDB的命令，所以，出现了“Invalid syntax in expression”的设置错误，此时，你可以使用set</span><br><span class="line"># var命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，如：</span><br><span class="line">(gdb) set var width=47</span><br><span class="line"># 另外，还可能有些情况，GDB并不报告这种错误，所以保险起见，在你改变程序变量取值时，最好都使用set var格式的GDB命令。</span><br></pre></td></tr></table></figure>

<h2 id="跳转执行"><a href="#跳转执行" class="headerlink" title="跳转执行"></a>跳转执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB的jump命令来完：</span><br><span class="line">(gdb) jump &lt;linespec&gt;</span><br><span class="line"># 指定下一条语句的运行点。&lt;linespce&gt;可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。</span><br><span class="line">(gdb) jump &lt;address&gt;</span><br><span class="line"># 这里的&lt;address&gt;是代码行的内存地址。注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常奇怪的，甚至于产生程序Core Dump。所以最好是同一个函数中进行跳转。</span><br><span class="line"># 熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行的地址。如：</span><br><span class="line">(gdb) set $pc = 0x485</span><br></pre></td></tr></table></figure>

<h2 id="强制函数返回"><a href="#强制函数返回" class="headerlink" title="强制函数返回"></a>强制函数返回</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用return命令强制函数忽略还没有执行的语句并返回。</span><br><span class="line">(gdb) return</span><br><span class="line">(gdb) return &lt;expression&gt;</span><br><span class="line"># 使用return命令取消当前函数的执行，并立即返回，如果指定了&lt;expression&gt;，那么该表达式的值会被认作函数的返回值。</span><br></pre></td></tr></table></figure>

<h2 id="强制调用函数"><a href="#强制调用函数" class="headerlink" title="强制调用函数"></a>强制调用函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) call &lt;expr&gt;</span><br><span class="line"># 表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返回值是void，那么就不显示。</span><br><span class="line"># 另一个相似的命令也可以完成这一功能——print，print后面可以跟表达式，所以也可以用他来调用函数，print和call的不同是，如果函数返回void，call则不显示，print则显示函数返回值，并把该值存入历史数据中。</span><br></pre></td></tr></table></figure>

<h2 id="GDB语言环境"><a href="#GDB语言环境" class="headerlink" title="GDB语言环境"></a>GDB语言环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) show language</span><br><span class="line"># 查看当前的语言环境。如果GDB不能识为你所调试的编程语言，那么，C语言被认为是默认的环境。</span><br><span class="line">(gdb) info frame</span><br><span class="line"># 查看当前函数的程序语言。</span><br><span class="line">(gdb) info source</span><br><span class="line"># 查看当前文件的程序语言。如果GDB没有检测出当前的程序语言，那么你也可以手动设置当前的程序语言。使用set language命令即可做到。当set language命令后什么也不跟的话，你可以查看GDB所支持的语言种类：</span><br><span class="line">(gdb) set language</span><br><span class="line">The currently understood settings are:</span><br><span class="line">local or auto Automatic setting based on source file</span><br><span class="line">c Use the C language</span><br><span class="line">c++ Use the C++ language</span><br><span class="line">asm Use the Asm language</span><br><span class="line">chill Use the Chill language</span><br><span class="line">fortran Use the Fortran language</span><br><span class="line">java Use the Java language</span><br><span class="line">modula-2 Use the Modula-2 language</span><br><span class="line">pascal Use the Pascal language</span><br><span class="line">scheme Use the Scheme language</span><br><span class="line"># 于是你可以在set language后跟上被列出来的程序语言名，来设置当前的语言环境。</span><br></pre></td></tr></table></figure>

<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) q/quit                # 退出GDB调试</span><br></pre></td></tr></table></figure>

<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b                     # 敲入b按两次TAB键</span><br><span class="line">backtrace break bt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>编译GDB</title>
    <url>/2020/09/14/GDB%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="编译-gdb-和-gdbserver"><a href="#编译-gdb-和-gdbserver" class="headerlink" title="编译 gdb 和 gdbserver"></a>编译 gdb 和 gdbserver</h1><h2 id="Download-gdb-source-code"><a href="#Download-gdb-source-code" class="headerlink" title="Download gdb source code:"></a>Download gdb source code:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget ftp://sourceware.org/pub/gdb/releases/gdb-9.1.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="Extract-file"><a href="#Extract-file" class="headerlink" title="Extract file:"></a>Extract file:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xzvf gdb-9.1.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="Move-into-source-folder"><a href="#Move-into-source-folder" class="headerlink" title="Move into source folder"></a>Move into source folder</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> gdb-9.1</span><br></pre></td></tr></table></figure>

<h2 id="Edit-file-gdb-gdbserver-linux-low-c"><a href="#Edit-file-gdb-gdbserver-linux-low-c" class="headerlink" title="Edit file gdb/gdbserver/linux-low.c :"></a>Edit file <code>gdb/gdbserver/linux-low.c</code> :</h2><h3 id="Add-two-lines-Line-107-amp-Line-122-with-the-content-below"><a href="#Add-two-lines-Line-107-amp-Line-122-with-the-content-below" class="headerlink" title="Add two lines : Line 107 &amp; Line 122 with the content below"></a>Add two lines : Line 107 &amp; Line 122 with the content below</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define HAVE_ELF32_AUXV_T  //  Line 107 (Added)</span></span><br><span class="line"><span class="comment">#ifndef HAVE_ELF32_AUXV_T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define HAVE_ELF64_AUXV_T // Line 122 (Added)</span></span><br><span class="line"><span class="comment">#ifndef HAVE_ELF64_AUXV_T</span></span><br></pre></td></tr></table></figure>
<p>This modification is neccessary to build Android, since Android system libraries already define struct Elf32_auxv_t and Elf64_auxv_t .(Please see this for detail: <a href="https://github.com/android/ndk/issues/1008">https://github.com/android/ndk/issues/1008</a>)</p>
<h3 id="Modify-function-linux-request-interrupt"><a href="#Modify-function-linux-request-interrupt" class="headerlink" title="Modify function linux_request_interrupt:"></a>Modify function linux_request_interrupt:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">linux_request_interrupt</span> <span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="comment">/* .... */</span></span><br><span class="line">-  <span class="built_in">kill</span> (-signal_pid, SIGINT); <span class="comment">// replace this line with next 3 lines</span></span><br><span class="line">+  <span class="type">int</span> r = <span class="built_in">kill</span> (-signal_pid, SIGINT);</span><br><span class="line">+  <span class="keyword">if</span> (r != <span class="number">0</span>)</span><br><span class="line">+      <span class="built_in">kill</span> (signal_pid, SIGINT);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>This fixes bug “gdbserver not handling Ctrl+C”, detail at: <a href="https://sourceware.org/bugzilla/show_bug.cgi?id=18772">https://sourceware.org/bugzilla/show_bug.cgi?id=18772</a></p>
<h2 id="Build-gdb-for-linux"><a href="#Build-gdb-for-linux" class="headerlink" title="Build gdb for linux:"></a>Build gdb for linux:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential \</span><br><span class="line">  gcc g++ make autogen m4 \</span><br><span class="line">  bison gettext libpython-dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build-linux</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> build-linux/</span><br><span class="line"></span><br><span class="line">../configure --enable-targets=all --with-python=/usr/bin/python</span><br><span class="line"></span><br><span class="line">make -j4</span><br><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>我使用 ubuntu 18.04 按照以上编译过程中，出现了一个错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcoffread.c:180:1: error: invalid conversion from ‘int’ to ‘const char*’ [-fpermissive]</span><br></pre></td></tr></table></figure>
<p>看源码注释，那段代码冒是 XCOFF 文件格式个 dwarf 节， 最后将出错那一行注释掉就好了，不影响使用。</p>
<h2 id="Build-gdbserver-for-android"><a href="#Build-gdbserver-for-android" class="headerlink" title="Build gdbserver for android:"></a>Build gdbserver for android:</h2><h3 id="Download-android-sdk"><a href="#Download-android-sdk" class="headerlink" title="Download android-sdk"></a>Download android-sdk</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> android</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> android</span><br><span class="line"></span><br><span class="line">wget https://dl.google.com/android/repository/commandlinetools-linux-6200805_latest.zip</span><br><span class="line"></span><br><span class="line">unzip commandlinetools-linux-6200805_latest.zip</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:~/android/tools/bin</span><br></pre></td></tr></table></figure>

<h3 id="Install-Ndk"><a href="#Install-Ndk" class="headerlink" title="Install Ndk"></a>Install Ndk</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sdkmanager --install <span class="string">&quot;ndk;21.0.6113669&quot;</span> --sdk_root=.</span><br></pre></td></tr></table></figure>

<h3 id="Create-standalone-toolchain-for-NDK"><a href="#Create-standalone-toolchain-for-NDK" class="headerlink" title="Create standalone toolchain for NDK"></a>Create standalone toolchain for NDK</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/android/ndk/21.0.6113669/</span><br><span class="line"></span><br><span class="line">./build/tools/make-standalone-toolchain.sh \ </span><br><span class="line">--toolchain=aarch64-linux-android-4.9 \</span><br><span class="line">--install-dir=~/android/ndk_21</span><br></pre></td></tr></table></figure>
<p>This step create the standalone toolchain at: ~&#x2F;android&#x2F;ndk_21</p>
<h3 id="Configure-and-build-gdbserver-for-android"><a href="#Configure-and-build-gdbserver-for-android" class="headerlink" title="Configure and build gdbserver for android"></a>Configure and build gdbserver for android</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/gdb-9.1</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build-android</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> build-android</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:~/android/ndk_21/bin</span><br><span class="line"></span><br><span class="line">CC=aarch64-linux-android-gcc ../configure \</span><br><span class="line">    --target=aarch64-linux-android \</span><br><span class="line">    --host=aarch64-linux-android \</span><br><span class="line">     LDFLAGS=<span class="string">&quot;-static-libstdc++&quot;</span></span><br><span class="line"></span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure>
<p>If get error related to “source-highlight”, add –disable-source-highlight to the configure flag.</p>
<p>After build finishes, gdbserver is located at: gdb&#x2F;gdbserver&#x2F;gdbserver</p>
<p>编译过程中可能出现错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aarch64.c:50: undefined reference to `set_tdesc_osabi</span><br></pre></td></tr></table></figure>
<p>但是 gdbserver 已经编译好了，所以这个错误可以不用管。</p>
<p>以上参考来自 <a href="https://stackoverflow.com/questions/60973768/build-gdb-and-gdbserver-for-android/61157179#61157179">https://stackoverflow.com/questions/60973768/build-gdb-and-gdbserver-for-android/61157179#61157179</a> 。</p>
<hr>
<p><strong>下面的内容可以忽略</strong></p>
<h1 id="Window-下编译-gdb"><a href="#Window-下编译-gdb" class="headerlink" title="Window 下编译 gdb"></a>Window 下编译 gdb</h1><p><strong>可能会遇到很多坑，不建议。</strong></p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><ol>
<li>安装 MSYS2</li>
</ol>
<p>直接去 <a href="https://www.msys2.org/">https://www.msys2.org/</a> 网站<a href="https://repo.msys2.org/distrib/x86_64/msys2-x86_64-20200903.exe">下载</a>并安装 MSYS2 。</p>
<ol start="2">
<li>安装 mingw64</li>
</ol>
<p>下载 <a href="https://sourceforge.net/projects/mingw-w64/files/">mingw64</a> 并解压到 <code>mingw64/mingw64</code> 目录。</p>
<ol start="3">
<li>安装其他工具</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pacman -S pactoys</span><br><span class="line"># 这里我使用 pacboy 安装了python3和 gcc 无法使用，所以还是使用下列网站的 gcc 吧。</span><br><span class="line"># pacboy -S gcc:x python3:x  # mingw-w64-x86_64-gcc mingw-w64-x86_64-python3</span><br><span class="line">pacman -S make texinfo bison git dejagnu </span><br></pre></td></tr></table></figure>
<p>如果后续编译报错，则根据报错信息安装相应的工具即可。</p>
<p><a href="https://sourceforge.net/projects/mingw-w64/files/">gcc下载地址</a>。</p>
<h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><ol>
<li><p>下载源码<br>直接去官网下载对应的源码 <a href="https://sourceware.org/gdb/">https://sourceware.org/gdb/</a> </p>
</li>
<li><p>启动 <code>msys64/mingw64.exe</code>, 执行下列命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd gdb-9.2</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../configure </span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>等待编译完成。</p>
</li>
</ol>
<h1 id="ubuntu-18-04-下编译"><a href="#ubuntu-18-04-下编译" class="headerlink" title="ubuntu 18.04 下编译"></a>ubuntu 18.04 下编译</h1><p>首先说明一下，由于我编译过 Android 源码，所以可能很多需要的库已经安装了，下面是给出其他博客上的环境配置，仅作参考，不一定需要安装，可以根据编译报错信息搜寻解答方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install texinfo </span><br><span class="line">sudo apt-get install libncurses5-dev </span><br><span class="line">sudo apt-get install m4</span><br><span class="line">sudo apt-get install flex </span><br><span class="line">sudo apt-get install bison</span><br><span class="line">为了支持python脚本扩展功能</span><br><span class="line">apt-get install python-dev</span><br></pre></td></tr></table></figure>
<p>由于我要编译 Android 平台的 gdb 所以使用了 Android 源码中的 gdb 源码，直接使用 gdb 官网的源码应该也不影响。</p>
<blockquote>
<p><a href="https://android.googlesource.com/toolchain/gdb/">https://android.googlesource.com/toolchain/gdb/</a>  Android 源码中的 gdb 。<br><a href="https://sourceware.org/gdb/">https://sourceware.org/gdb/</a>    gdb 官网。</p>
</blockquote>
<p>好了废话了那么多，那么开始编译吧。可以按照如下命令进行编译，其中当前目录为 gdb 源码根目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  <span class="built_in">mkdir</span> build</span><br><span class="line">➜  <span class="built_in">cd</span> build</span><br><span class="line">➜  ../configure --with-python=/usr/bin/python3.6 --target=arm-linux-androideabi --prefix=/home/ckcat/tools/gdb9.2</span><br><span class="line">➜  make -j8</span><br></pre></td></tr></table></figure>
<p>编译成功后，<code>build/gdb</code> 目录下会出现 gdb 的二进制可执行文件。</p>
<p>简单的说一下 configure 的参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--with-python=/usr/bin/python3.6     <span class="comment"># gdb 支持python3</span></span><br><span class="line">--target=arm-linux-androideabi    <span class="comment"># 目标平台为 Android ARM 如果需要支持aarch64，将参数改为 aarch64-linux-android 即可。</span></span><br><span class="line">--prefix=/home/ckcat/tools/gdb9.2    <span class="comment"># make install 安装目录</span></span><br></pre></td></tr></table></figure>
<p>当执行 <code>make install</code> 命令后，可以看到 <code>/home/ckcat/tools/gdb9.2</code> 已经包含了 gdb 相关文件。</p>
<p>如果目标平台为全平台，则应该用下面参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../configure --with-python=/usr/bin/python3.6 --enable-targets=all --prefix=/home/ckcat/tools/gdb9.2</span><br></pre></td></tr></table></figure>

<p>说一下我在编译过程中碰到的错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Makefile:541: recipe <span class="keyword">for</span> target <span class="string">&#x27;bfd.info&#x27;</span> failed</span><br></pre></td></tr></table></figure>
<p>这个错误说明没有安装 texinfo 库，安装一下就好了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">configure: error: no usable python found at /usr</span><br></pre></td></tr></table></figure>
<p>这个错误是因为我之前的参数 <code>--with-python=/usr</code> 没有指定对应的 python 文件。后面修改为  <code>--with-python=/usr/bin/python3.6 </code> 就可以了。</p>
<p>参考：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://sourceware.org/gdb/wiki/BuildingOnWindows</span><br><span class="line">https://blog.csdn.net/pfysw/article/details/105451883</span><br><span class="line">https://github.com/ikonst/gdb-7.7-android</span><br><span class="line">https://www.msys2.org/</span><br><span class="line">https://www.cntofu.com/book/46/gdb/188.md</span><br><span class="line">https://mudongliang.github.io/2017/08/12/compile-gdb-with-python-script-support.html</span><br><span class="line">https://stackoverflow.com/questions/60973768/build-gdb-and-gdbserver-for-android</span><br><span class="line">https://medium.com/@k3vinlusec/how-to-compile-gdb-9-x-and-gdbserver-for-android-24ef6625ee9a</span><br><span class="line">https://segmentfault.com/a/1190000021029824</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo｜快速搭建自己（Github）博客</title>
    <url>/2019/11/02/Hexo%EF%BD%9C%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%EF%BC%88Github%EF%BC%89%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><ul>
<li>安装<a href="https://nodejs.org/en/">nodejs</a></li>
<li>安装<a href="https://git-scm.com/">git</a></li>
<li>注册<a href="https://github.com/">github</a>账号</li>
</ul>
<h1 id="二、申请-github-博客"><a href="#二、申请-github-博客" class="headerlink" title="二、申请 github 博客"></a>二、申请 github 博客</h1><h2 id="1-创建-github-仓库"><a href="#1-创建-github-仓库" class="headerlink" title="1.创建 github 仓库"></a>1.创建 github 仓库</h2><p>创建一个新的 github 仓库，仓库名为<code>username.github.io</code>,其他选项可以默认。</p>
<img src="/2019/11/02/Hexo%EF%BD%9C%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%EF%BC%88Github%EF%BC%89%E5%8D%9A%E5%AE%A2/new_repository.png" class="">

<p>创建按仓库成功后，进入设置页面 GitHub Pages 选项，出现如下界面则表示博客页面创建成功。</p>
<img src="/2019/11/02/Hexo%EF%BD%9C%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%EF%BC%88Github%EF%BC%89%E5%8D%9A%E5%AE%A2/github_pages.png" class="">

<h1 id="三、安装-Hexo"><a href="#三、安装-Hexo" class="headerlink" title="三、安装 Hexo"></a>三、安装 Hexo</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo  init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<h2 id="2-新建文章"><a href="#2-新建文章" class="headerlink" title="2. 新建文章"></a>2. 新建文章</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;Hello-Hexo&quot;</span></span><br></pre></td></tr></table></figure>

<p>会在根目录下 <code>source/_posts/</code> 生成 <code>Hello-Hexo.md</code> 文件，使用 markdown 编辑器非常方便。</p>
<h2 id="3-开启服务"><a href="#3-开启服务" class="headerlink" title="3. 开启服务"></a>3. 开启服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>会看到提示<code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code> 代表博客已经正常运行，在浏览器打开<code>http://0.0.0.0:4000/</code> 即可预览博客的初始状态。</p>
<p>了解更多 Hexo 的信息和其他步骤请参考官网的<a href="https://hexo.io/zh-cn/docs/setup.html">这篇文档</a> 。</p>
<h1 id="四、配置-Hexo-与-Github-pages-进行关联"><a href="#四、配置-Hexo-与-Github-pages-进行关联" class="headerlink" title="四、配置 Hexo 与 Github pages 进行关联"></a>四、配置 Hexo 与 Github pages 进行关联</h1><h2 id="1-配置关联"><a href="#1-配置关联" class="headerlink" title="1. 配置关联"></a>1. 配置关联</h2><p>进入<code>Blog</code>目录，然后以文本编辑器打开 <code>_config.yml</code> 文件，修改 deploy 配置如下，rego 为 <code>CKCat.github.io.git</code> 仓库提交代码的 git 地址。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/CKCat/CKCat.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<h2 id="2-发布"><a href="#2-发布" class="headerlink" title="2. 发布"></a>2. 发布</h2><p>使用下面的命令进行发布：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean  <span class="comment"># 清除缓存</span></span><br><span class="line">hexo g      <span class="comment"># 生成本地发布文件夹</span></span><br><span class="line">hexo d      <span class="comment"># 发布到github pages上</span></span><br></pre></td></tr></table></figure>

<p>更多的 hexo 命令操作请参考<a href="https://hexo.io/zh-cn/docs/commands.html">Hexo 官方文档</a>即可。</p>
<h1 id="五、更换-NexT-主题"><a href="#五、更换-NexT-主题" class="headerlink" title="五、更换 NexT 主题"></a>五、更换 NexT 主题</h1><h2 id="1-下载主题"><a href="#1-下载主题" class="headerlink" title="1. 下载主题"></a>1. 下载主题</h2><p>在 Blog 目录运行下列命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h2 id="2-设置主题"><a href="#2-设置主题" class="headerlink" title="2. 设置主题"></a>2. 设置主题</h2><p>克隆完成以后打开站点配置 <code>_config.yml</code>，找到 theme 字段，值改为<code>next</code>。<br>运行<code>hexo server --debug</code>，访问<code>http://0.0.0.0:4000/</code> 查看主题是否生效。</p>
<h2 id="3-配置主题"><a href="#3-配置主题" class="headerlink" title="3. 配置主题"></a>3. 配置主题</h2><p>常用的配置可以直接按照主题的官方<a href="http://theme-next.iissnan.com/">参考手册</a>配置。<br>下面介绍一下常用配置：</p>
<h3 id="1-标签云页面"><a href="#1-标签云页面" class="headerlink" title="1. 标签云页面"></a>1. 标签云页面</h3><ol>
<li><p>新建一个页面，命名为 tags。命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page <span class="string">&quot;tags&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑刚新建的页面，将页面的类型设置为 tags，主题将自动为这个页面显示标签云。页面内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">title: 标签</span><br><span class="line"><span class="built_in">date</span>: 2019-11-01 11:46:23</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line"><span class="built_in">date</span>: 2019-11-01 11:46:23</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>在菜单中添加链接。编辑 <strong>主题配置文件</strong> ，添加 tags 到 menu 中，如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: /</span><br><span class="line">archives: /archives</span><br><span class="line">tags: /tags</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-分类页面"><a href="#2-分类页面" class="headerlink" title="2. 分类页面"></a>2. 分类页面</h3><ol>
<li><p>新建一个页面，命名为 categories。命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑刚新建的页面，将页面的类型设置为 categories，主题将自动为这个页面显示所有分类。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line"><span class="built_in">date</span>: 2019-11-01 12:03:27</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line"><span class="built_in">date</span>: 2019-11-01 12:03:27</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>在菜单中添加链接。编辑 <strong>主题配置文件</strong> ，将 menu 中的 categories: &#x2F;categories 注释去掉，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: /</span><br><span class="line">categories: /categories</span><br><span class="line">archives: /archives</span><br><span class="line">tags: /tags</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-About-页面"><a href="#3-About-页面" class="headerlink" title="3. About 页面"></a>3. About 页面</h3><ol>
<li><p>新建一个 about 页面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page <span class="string">&quot;about&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>菜单显示 about 链接，在 <strong>主题配置文件</strong> 设置中将 menu 中 about<br>前面的注释去掉即可。<br><code>   menu:  home: /  archives: /archives  tags: /tags  about: /about</code></p>
</li>
<li><p>友情链接编辑 <strong>站点配置文件</strong> 添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># title, chinese available</span><br><span class="line">links_title: Links</span><br><span class="line"># links</span><br><span class="line">links:</span><br><span class="line">MacTalk: http://macshuo.com/</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-腾讯公益-404-页面"><a href="#4-腾讯公益-404-页面" class="headerlink" title="4. 腾讯公益 404 页面"></a>4. 腾讯公益 404 页面</h3><p>简体中文增加腾讯公益 404 页面，寻找丢失儿童，让大家一起关注此项公益事业！效果如下 <a href="http://www.ixirong.com/404.html">http://www.ixirong.com/404.html</a></p>
<p>使用方法，新建 404.md 页面，放到主题的 source 目录下，内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-代码高亮主题"><a href="#5-代码高亮主题" class="headerlink" title="5. 代码高亮主题"></a>5. 代码高亮主题</h3><p>NexT 使用 <a href="https://github.com/chriskempson/tomorrow-theme">Tomorrow Theme0</a> 作为代码高亮，共有 5 款主题供你选择。<br>默认使用的是白色的 normal。</p>
<h3 id="6-站点建立时间"><a href="#6-站点建立时间" class="headerlink" title="6. 站点建立时间"></a>6. 站点建立时间</h3><p>这个时间将在站点的底部显示，例如<code>© 2013 - 2019</code>编辑 <strong>站点配置文件</strong>，新增字段 since。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">since: 2013</span><br></pre></td></tr></table></figure>

<h3 id="7-数学公式显示"><a href="#7-数学公式显示" class="headerlink" title="7. 数学公式显示"></a>7. 数学公式显示</h3><p>NexT 借助于 MathJax 来显示数学公式，此选项默认关闭。<br>编辑 <strong>主题配置文件</strong>，将 mathjax 设定为 true 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax: true</span><br></pre></td></tr></table></figure>

<p>ProTip: <a href="https://github.com/iissnan/hexo-theme-next/pull/363">使用七牛 CDN 来加速 MathJax 脚本的加载</a></p>
<h3 id="8-侧边栏社交链接"><a href="#8-侧边栏社交链接" class="headerlink" title="8. 侧边栏社交链接"></a>8. 侧边栏社交链接</h3><p>编辑 <strong>站点配置文件</strong> ，新增字段 social，然后添加社交站点名称与地址即可。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Social linkssocial:</span><br><span class="line">  github: https://github.com/your-user-name</span><br><span class="line">  twitter: https://twitter.com/your-user-name</span><br><span class="line">  weibo: http://weibo.com/your-user-name</span><br><span class="line">  douban: http://douban.com/people/your-user-name</span><br><span class="line">  zhihu: http://www.zhihu.com/people/your-user-name</span><br><span class="line">  # 等等</span><br></pre></td></tr></table></figure>

<h1 id="六、问题"><a href="#六、问题" class="headerlink" title="六、问题"></a>六、问题</h1><h2 id="1-hexo-引用本地图片无法显示"><a href="#1-hexo-引用本地图片无法显示" class="headerlink" title="1.hexo 引用本地图片无法显示"></a>1.hexo 引用本地图片无法显示</h2><h3 id="插件安装与配置"><a href="#插件安装与配置" class="headerlink" title="插件安装与配置"></a>插件安装与配置</h3><p><a href="https://github.com/cocowool/hexo-image-link">https://github.com/cocowool/hexo-image-link</a></p>
<p>首先我们需要安装一个图片路径转换的插件，这个插件名字是 hexo-image-link</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-image-link --save</span><br></pre></td></tr></table></figure>

<p>修改 <code>_config.next.yml</code> 配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo-asset-folder: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="hexo-升级"><a href="#hexo-升级" class="headerlink" title="hexo 升级"></a>hexo 升级</h1><p>由于最近安装了 NodeJS 14 导致无法使用旧版的 hexo，所以进行了一次升级，记录一下。</p>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>Hexo 升级需要使用 <code>npm-check</code>、<code>npm-upgrade</code>、<code>npm-update</code> 按以下顺序逐步执行完成后，Hexo 版本及系统插件均会升级到最新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//以下指令均在Hexo目录下操作，先定位到Hexo目录</span><br><span class="line">//查看当前版本，判断是否需要升级</span><br><span class="line">&gt; hexo version</span><br><span class="line"></span><br><span class="line">//全局升级hexo-cli</span><br><span class="line">&gt; npm i hexo-cli -g</span><br><span class="line"></span><br><span class="line">//再次查看版本，看hexo-cli是否升级成功</span><br><span class="line">&gt; hexo version</span><br><span class="line"></span><br><span class="line">//安装npm-check，若已安装可以跳过</span><br><span class="line">&gt; npm install -g npm-check</span><br><span class="line"></span><br><span class="line">//检查系统插件是否需要升级</span><br><span class="line">&gt; npm-check</span><br><span class="line"></span><br><span class="line">//安装npm-upgrade，若已安装可以跳过</span><br><span class="line">&gt; npm install -g npm-upgrade</span><br><span class="line"></span><br><span class="line">//更新package.json</span><br><span class="line">&gt; npm-upgrade</span><br><span class="line"></span><br><span class="line">//更新全局插件</span><br><span class="line">&gt; npm update -g</span><br><span class="line"></span><br><span class="line">//更新系统插件</span><br><span class="line">&gt; npm update --save</span><br><span class="line"></span><br><span class="line">//再次查看版本，判断是否升级成功</span><br><span class="line">&gt; hexo version</span><br></pre></td></tr></table></figure>

<h2 id="调整配置"><a href="#调整配置" class="headerlink" title="调整配置"></a>调整配置</h2><p>升级后别急着 <code>hexo g</code>，需要先调整站点配置文件 <code>hexo/_config.yml</code>，否则会报错。</p>
<p>以下是废弃的字段，需要重新配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deprecated</span></span><br><span class="line">external_link: <span class="literal">true</span>|<span class="literal">false</span></span><br><span class="line"><span class="comment"># New option</span></span><br><span class="line">external_link:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  field: site <span class="comment"># Apply to the whole site</span></span><br><span class="line">  exclude: <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deprecated</span></span><br><span class="line">use_date_for_updated: <span class="literal">true</span></span><br><span class="line"><span class="comment"># New option</span></span><br><span class="line"><span class="comment">## pdated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span></span><br><span class="line">updated_option: <span class="string">&#x27;mtime&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其他字段可以看官方文档，我这里不关心就不设置了。</p>
<h2 id="NexT-8-x-跨版本升级"><a href="#NexT-8-x-跨版本升级" class="headerlink" title="NexT-8.x 跨版本升级"></a>NexT-8.x 跨版本升级</h2><p>升级完 hexo 为 5.4 以后， next 主题也需要进行升级。</p>
<p>通过 npm 方式安装新版：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//定位到hexo目录,npm安装主题</span><br><span class="line">&gt; npm install hexo-theme-next</span><br></pre></td></tr></table></figure>

<p>将 Next 主题配置文件 <code>node_modules/hexo-theme-next/_config.yml</code> 改名为 <code>_config.next.yml</code>, 复制到根目录（与 Hexo 站点配置文件<code>_config.yml</code> 在同一目录），这个文件的作用等同于旧版 <code>next.yml</code>，但优先级最高。这样做的好处是以后可以通过 npm 顺滑升级 Next 版本，不用担心配置文件被覆盖。相关字段的解释可以通过<a href="https://theme-next.js.org/docs/getting-started/">官方文档</a>查看，我这里主要说一下摘要设置和统计人数设置。</p>
<blockquote>
<p>参考：<a href="https://www.imczw.com/post/tech/hexo5-next8-updated.html">https://www.imczw.com/post/tech/hexo5-next8-updated.html</a></p>
</blockquote>
<h2 id="设置摘要"><a href="#设置摘要" class="headerlink" title="设置摘要"></a>设置摘要</h2><p>官方给的方法：</p>
<ol>
<li>使用 <code>&lt;!-- more --&gt;</code> 插入你想设置摘要的文本位置之后，这个方法也是官方推荐的。</li>
<li>在文件头设置 <code>description</code> 字段,内容即为摘要。</li>
</ol>
<p>这两种方法都比较麻烦，我这里使用了第三方插件设置摘要。直接安装插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-excerpt --save</span><br></pre></td></tr></table></figure>

<p>在 Hexo 站点配置文件<code>_config.yml</code> 添加下列字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">excerpt:</span><br><span class="line">  depth: 10</span><br><span class="line">  excerpt_excludes: []</span><br><span class="line">  more_excludes: []</span><br><span class="line">  hideWholePostExcerpts: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="https://github.com/chekun/hexo-excerpt">https://github.com/chekun/hexo-excerpt</a></p>
</blockquote>
<h2 id="统计人数设置"><a href="#统计人数设置" class="headerlink" title="统计人数设置"></a>统计人数设置</h2><p>统计人数可以直接通过设置 <code>_config.next.yml</code> 配置文件，将 <code>enable</code> 对应的值改为 <code>true</code> 即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># For more information: http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line">busuanzi_count:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  total_visitors: <span class="literal">true</span></span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: <span class="literal">true</span></span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: <span class="literal">true</span></span><br><span class="line">  post_views_icon: far fa-eye</span><br></pre></td></tr></table></figure>

<h2 id="添加搜索插件"><a href="#添加搜索插件" class="headerlink" title="添加搜索插件"></a>添加搜索插件</h2><p>安装 hexo-generator-searchdb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<p>在 <code>_config.yml</code> 添加下面内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  content: <span class="literal">true</span></span><br><span class="line">  format: html</span><br></pre></td></tr></table></figure>

<p><code>_config.next.yml</code> 添加下列内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  trigger: auto</span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  unescape: <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  preload: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://theme-next.js.org/docs/third-party-services/search-services.html">https://theme-next.js.org/docs/third-party-services/search-services.html</a></p>
<h2 id="添加-hexo-filter-markdown-plantuml-插件"><a href="#添加-hexo-filter-markdown-plantuml-插件" class="headerlink" title="添加 hexo-filter-markdown-plantuml 插件"></a>添加 hexo-filter-markdown-plantuml 插件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-filter-markdown-plantuml --save</span><br></pre></td></tr></table></figure>

<p>后续就可以 puml 或 plantuml 标记的代码生成对应的图片。</p>
<h2 id="利用-github-action-自动部署"><a href="#利用-github-action-自动部署" class="headerlink" title="利用 github action 自动部署"></a>利用 github action 自动部署</h2><p>参考：<a href="https://hexo.io/zh-cn/docs/github-pages">https://hexo.io/zh-cn/docs/github-pages</a></p>
<p>最关键的一点是需要修改一下 <code>.github/workflows/pages.yml</code> 中的 GITHUB_TOKEN，使用自己添加的 TOKEN ，否则有随机出错的可能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: Pages</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - main # default branch</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  pages:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    permissions:</span><br><span class="line">      contents: write</span><br><span class="line">    steps:</span><br><span class="line">      - uses: actions/checkout@v2</span><br><span class="line">      - name: Use Node.js 16.x</span><br><span class="line">        uses: actions/setup-node@v2</span><br><span class="line">        with:</span><br><span class="line">          node-version: &quot;16&quot;</span><br><span class="line">      - name: Cache NPM dependencies</span><br><span class="line">        uses: actions/cache@v2</span><br><span class="line">        with:</span><br><span class="line">          path: node_modules</span><br><span class="line">          key: $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span><br><span class="line">          restore-keys: |</span><br><span class="line">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span><br><span class="line">      - name: Install Dependencies</span><br><span class="line">        run: npm install</span><br><span class="line">      - name: Build</span><br><span class="line">        run: npm run build</span><br><span class="line">      - name: Deploy</span><br><span class="line">        uses: peaceiris/actions-gh-pages@v3</span><br><span class="line">        with:</span><br><span class="line">          github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">          publish_dir: ./public</span><br></pre></td></tr></table></figure>

<p>前往 <a href="https://github.com/settings/tokens/new">https://github.com/settings/tokens/new</a> 申请一个 token，然后添加到项目的 前往 <code>Settings &gt; secrets &gt; actions</code> 添加一个变量 ACCESS_TOKEN ，然后将上面的 secrets.GITHUB_TOKEN 替换为 secrets.ACCESS_TOKEN 即可。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hexo-next.readthedocs.io/zh_CN/latest/">https://hexo-next.readthedocs.io/zh_CN/latest/</a></p>
<p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p>
<p><a href="https://theme-next.js.org/">https://theme-next.js.org/</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>IDA 插件环境配置</title>
    <url>/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>环境：vs2019,ida7.3</p>
</blockquote>
<h1 id="使用-VS-配置-IDA-C-插件环境"><a href="#使用-VS-配置-IDA-C-插件环境" class="headerlink" title="使用 VS 配置 IDA C++ 插件环境"></a>使用 VS 配置 IDA C++ 插件环境</h1><ol>
<li>使用 VS2019 新建一个 C++ 空工程，添加 C++ 文件 <code>myplugin.cpp</code> , 添加如下代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ida.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;idp.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;loader.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kernwin.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以上是导入的SDK头文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> idaapi <span class="title">init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//IDA在启动的时候会调用每个插件的init函数。</span></span><br><span class="line">	<span class="comment">//返回值有三种选项:</span></span><br><span class="line">	<span class="comment">//PLUGIN_SKIP适合那些不支持的插件，IDA将不会加载该插件</span></span><br><span class="line">	<span class="comment">//PLUGIN_OK适合那些执行一次性功能的插件</span></span><br><span class="line">	<span class="comment">//PLUGIN_KEEP适合那些需要一直保持功能的插件</span></span><br><span class="line">	<span class="keyword">return</span> PLUGIN_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> idaapi <span class="title">term</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当结束插件时，一般您可以在此添加一点任务清理的代码。</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> idaapi <span class="title">run</span><span class="params">(<span class="type">size_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当按下热键时候,执行功能的入口函数</span></span><br><span class="line">	<span class="built_in">warning</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> comment[] = <span class="string">&quot;It&#x27;s a plugin to show Hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">plugin_t</span> PLUGIN =</span><br><span class="line">&#123;</span><br><span class="line">  IDP_INTERFACE_VERSION,</span><br><span class="line">  <span class="number">0</span>,                    <span class="comment">// 插件的一些属性,一般为0即可</span></span><br><span class="line">  init,                 <span class="comment">// initialize</span></span><br><span class="line">  term,                 <span class="comment">// terminate. this pointer may be NULL.</span></span><br><span class="line">  run,                  <span class="comment">// invoke plugin</span></span><br><span class="line">  comment,              <span class="comment">// 插件的说明,会显示在IDA下方的状态栏中</span></span><br><span class="line">  <span class="string">&quot;&quot;</span>,                   <span class="comment">// multiline help about the plugin</span></span><br><span class="line">  <span class="string">&quot;Hello, world&quot;</span>,		<span class="comment">// 插件在列表中显示的名称</span></span><br><span class="line">  <span class="string">&quot;Alt-F1&quot;</span>              <span class="comment">// 插件想要注册的功能快捷键</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>进入项目属性选项，进行如下配置</li>
</ol>
<p>配置属性 -&gt; 常规 -&gt; 配置类型： 选中 <strong>动态库(.dll)。</strong></p>
<img src="/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2020-12-02-16-46-38.png" class="">

<p>C&#x2F;C++ -&gt; 常规 -&gt; 附加包含目录：添加 IDASDK include 目录。</p>
<img src="/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2020-12-02-16-48-05.png" class="">

<p>C&#x2F;C++ -&gt; 常规 -&gt; 预处理器：添加 <code>__NT__</code></p>
<img src="/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2020-12-02-16-48-58.png" class="">

<p>C&#x2F;C++ -&gt; 代码生成 -&gt; 安全检查：修改为 <strong>禁用安全检查(&#x2F;GS-)</strong></p>
<img src="/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2020-12-02-16-50-30.png" class="">

<p>链接器 -&gt; 常规 -&gt;  附加包含目录：</p>
<ul>
<li>针对 <code>ida.exe</code> ，则添加 <code>idasdk\lib\x64_win_vc_32</code>。</li>
<li>针对 <code>ida64.exe</code> ，则添加 <code>idasdk\lib\x64_win_vc_64</code> 。</li>
</ul>
<img src="/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2020-12-02-16-55-47.png" class="">

<p>链接器 -&gt; 输入 -&gt; 附加依赖项：添加 <code>ida.lib</code> 。</p>
<img src="/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2020-12-02-16-58-08.png" class="">

<p>通过以上配置就完成了 IDA 插件环境配置。</p>
<h1 id="使用-CMAKE-配置-IDA-C-插件环境"><a href="#使用-CMAKE-配置-IDA-C-插件环境" class="headerlink" title="使用 CMAKE 配置 IDA C++ 插件环境"></a>使用 CMAKE 配置 IDA C++ 插件环境</h1><p>直接使用 <a href="https://github.com/Jinmo/ida-cmake">ida-cmake</a> 项目, 不过不同的编译环境需要修改相应的 gen 代码。下面为我修改适配 vs2109 的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_cmake_gen</span>(<span class="params">target_version, custom_gen</span>):</span><br><span class="line">    <span class="keyword">if</span> custom_gen:</span><br><span class="line">        <span class="keyword">return</span> custom_gen.strip()</span><br><span class="line">    <span class="keyword">if</span> os.name == <span class="string">&#x27;posix&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Unix Makefiles&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> os.name == <span class="string">&#x27;nt&#x27;</span>:</span><br><span class="line">        gen = <span class="string">&#x27;Visual Studio &#x27;</span> + (</span><br><span class="line">            <span class="string">&#x27;10&#x27;</span> <span class="keyword">if</span> target_version[<span class="number">0</span>] &lt;= <span class="number">6</span> <span class="keyword">and</span> target_version[<span class="number">1</span>] &lt;= <span class="number">8</span> <span class="keyword">else</span> <span class="string">&#x27;16&#x27;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> (gen + <span class="string">&#x27; 2019&#x27;</span>) <span class="keyword">if</span> target_version &gt;= (<span class="number">7</span>, <span class="number">0</span>) <span class="keyword">else</span> gen</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h1 id="使用-python-编写-IDA-插件"><a href="#使用-python-编写-IDA-插件" class="headerlink" title="使用 python 编写 IDA 插件"></a>使用 python 编写 IDA 插件</h1><p>vscode 使用相应的插件 <a href="https://github.com/ioncodes/idacode">idacode</a></p>
<p>pycharm 导入对应的文件夹既可高亮提示，如下图所示如何导入：</p>
<img src="/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2020-12-02-17-29-04.png" class="">


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnknowClass</span>(idaapi.plugin_t):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        给插件接口,实例的类定义</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    flags = idaapi.PLUGIN_KEEP  <span class="comment"># 插件的状态, 当前状态保持在Plugin菜单中</span></span><br><span class="line">    comment = <span class="string">&quot;XXX&quot;</span>             <span class="comment"># 描述信息</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">help</span> = <span class="string">&quot;&quot;</span>                   <span class="comment"># 帮助信息</span></span><br><span class="line">    wanted_name = <span class="string">&quot;XXX&quot;</span>         <span class="comment"># 菜单中显示的名字</span></span><br><span class="line">    <span class="comment">#wanted_hotkey = &quot;Ctrl+Alt+Shift+F12&quot;   # 希望注册的快捷键</span></span><br><span class="line">    wanted_hotkey = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#_PREFIX_NAME = &#x27;carveSelectedBytes&#x27;</span></span><br><span class="line">    <span class="comment">#_MIN_MAX_MATH_OPS_TO_ALLOW_RENAME = 11</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	        初始化工作</span></span><br><span class="line"><span class="string">            构造基类,一般没什么实质操作, </span></span><br><span class="line"><span class="string">            记得给Super第一个参数更正为 当前类的名称</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">super</span>(UnknowClass, self).__init__()</span><br><span class="line">        self._data = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">term</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            Destory函数, 同析构函数, 留待释放资源</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            进行初始化操作,可在此输出一些描述信息</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.view = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># self._cfg = None</span></span><br><span class="line">        <span class="comment"># print(&quot;=&quot; * 80)</span></span><br><span class="line">        <span class="comment"># print(&quot;carveSelectedBytes&quot;)</span></span><br><span class="line">        <span class="comment"># print(u&quot;保存所选的 HexData 到文件&quot;)</span></span><br><span class="line">        <span class="comment"># print(&quot;=&quot; * 80)</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> idaapi.PLUGIN_OK</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            每次运行插件时, 执行的具体操作</span></span><br><span class="line"><span class="string">            功能代码在此编写</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PLUGIN_ENTRY</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        插件入口,用于实例对象</span></span><br><span class="line"><span class="string">        返回的就是插件的功能等</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> carveSelectedBytes()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>IDA</tag>
      </tags>
  </entry>
  <entry>
    <title>IDA使用技巧</title>
    <url>/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>可以使用 IDA 菜单栏 <code>Options &gt; Shortcuts</code> 来查看、修改、添加快捷键。 </p>
<h2 id="文本输入框"><a href="#文本输入框" class="headerlink" title="文本输入框"></a>文本输入框</h2><p>使用 <code>Ctrl+Enter</code> 进行确认，使用 <code>ESC</code> 取消，使用 <code>F1</code> 查看帮助。使用所有的文本输入框，如注释、编辑本地类型等。</p>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-27-13-34-19.png" class="">

<h2 id="快速菜单导航"><a href="#快速菜单导航" class="headerlink" title="快速菜单导航"></a>快速菜单导航</h2><p>使用 <code>Alt</code> 键，可以在菜单项下看到下划线，同时按住带下划线的字母可以打开该菜单。可以通过 <code>cfg/idagui.cfg</code> 文件修改相应的加速键。</p>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-27-13-42-56.png" class="">

<h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p><code>Tab</code> 键切换对话框上多个控件的焦点，使用 <code>Space</code> 键选中焦点对应的控件，也可以使用 <code>Alt</code> 键显示相关的加速键。</p>
<p>例如：快速退出 IDA 并丢弃自打开的数据库以来的所有修改，可以使用下列快捷键。</p>
<ul>
<li><code>Alt + F4</code> 退出IDA，将会显示保存数据库的对话框。</li>
<li><code>D</code> 选择 <code>DON’T SAVE the database</code> 复选框。</li>
<li><code>Enter</code> 或者 <code>Alt + K</code> 确认。</li>
</ul>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-27-13-53-34.png" class="">

<h2 id="命令面板"><a href="#命令面板" class="headerlink" title="命令面板"></a>命令面板</h2><p>使用 Ctrl + Shift + P 可以打开命令面板，可以在底部输入文本过滤相关操作。</p>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-27-14-08-36.png" class="">


<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>按住 <code>Shift</code> 使用 光标导航键 <code>← ↑ → ↓</code> 。</p>
<p><code>Alt + L</code> 选择开始，然后导航到需要选择的末尾，执行相应的操作，最后 <code>Alt + L</code> 结束选择。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p><code>Ctrl + PgUp</code> 转到数据库开头。</p>
<p><code>Ctrl + PgDn</code> 转到数据库开头。</p>
<p>选中按 <code>C</code> 将选中的数据转为代码。</p>
<p>选中按 <code>T</code> 转换为结构体偏移。</p>
<p>选中按 <code>A</code> 将选中的数据转为代码。</p>
<h2 id="高亮导航"><a href="#高亮导航" class="headerlink" title="高亮导航"></a>高亮导航</h2><p><code>Alt + Up</code> 或 <code>Alt + Down</code> 实现选中的高亮字符串之间前后跳转。</p>
<p><strong>IDA 7.5 新增功能</strong></p>
<p><code>Shift + Alt + Up</code> 查找定义（写入）所选寄存器的先前位置。<br><code>Shift + Alt + Down</code> 查找使用所选寄存器的下一个位置。</p>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-15-14-20.png" class="">

<p><strong>IDA 7.2 新增功能</strong></p>
<p><code>Ctrl + Shift + Up</code> &#x2F; <code>Ctrl + Shift + Down</code> 跳至上一个&#x2F;下一个函数的开头。</p>
<h1 id="IDA-命令行"><a href="#IDA-命令行" class="headerlink" title="IDA 命令行"></a>IDA 命令行</h1><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;filename&gt;</code> 可以是您要反汇编的新文件或现有数据库。这种用法基本上与使用“文件”-&gt;“打开”或将文件拖放到IDA的图标上相同。您仍然需要手动确认“加载文件”对话框中的选项或IDA显示的任何其他提示，但是会跳过初始启动屏幕。</p>
<h3 id="自动选择Loader"><a href="#自动选择Loader" class="headerlink" title="自动选择Loader"></a>自动选择Loader</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -T&lt;prefix&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;prefix&gt;</code> 是“加载文件”对话框中显示的加载器描述的唯一前缀。相关选项如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-TMicrosoft       Microsoft.Net程序集</span><br><span class="line">-TPortable        适用于AMD64（PE）的可移植可执行文件</span><br><span class="line">-TMS              MS-DOS可执行文件（EXE）</span><br><span class="line">-TBinary          二进制文件</span><br></pre></td></tr></table></figure>

<p>当 <code>&lt;prefix&gt;</code> 包含空格时，使用引号将  <code>&lt;prefix&gt;</code> 包起来。For example, to load the first slice from a fat Mach-O file:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida &quot;-TFat Mach-O File, 1&quot; file.macho</span><br></pre></td></tr></table></figure>

<p>如果是 ZIP 格式的归档文件，则可以指定要在冒号后装入的归档成员。要从 apk 中加载主dex文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -TZIP:classes.dex:Android file.apk</span><br></pre></td></tr></table></figure>

<p>但是，通常最好在顶层选择APK加载程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -TAPK file.apk</span><br></pre></td></tr></table></figure>

<p>当-T指定时，将跳过初始加载对话框，并且IDA会直接使用指定的加载器直接加载文件。</p>
<h3 id="使用默认模式打开文件"><a href="#使用默认模式打开文件" class="headerlink" title="使用默认模式打开文件"></a>使用默认模式打开文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -A &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>这将使用自主模式或批处理模式加载文件，其中IDA将不显示任何对话框，但在所有情况下均接受默认答案。</p>
<blockquote>
<p>在此模式下，加载完成后将不会显示任何交互式对话框。要恢复交互性，请 <code>batch(0)</code> 在 IDA 窗口底部的 IDC 或 Python 控制台中执行语句。</p>
</blockquote>
<h3 id="批量反汇编"><a href="#批量反汇编" class="headerlink" title="批量反汇编"></a>批量反汇编</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -B &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>IDA 将使用所有默认选项加载文件，等待自动分析结束，将反汇编输出到 <code>&lt;filename&gt;.asm</code> 并在保存数据库后退出。</p>
<h3 id="二进制文件选项"><a href="#二进制文件选项" class="headerlink" title="二进制文件选项"></a>二进制文件选项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -p&lt;processor&gt; -B&lt;base&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;processor&gt;</code> 是IDA支持的处理器类型之一。</li>
<li><code>&lt;base&gt;</code> 是加载基址(16进制)。</li>
</ul>
<p>例如，要在线性地址 <code>0xBFC00000</code> 上加载大端 <code>MIPS</code> 固件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -pmipsb -bBFC0000 firmware.bin</span><br></pre></td></tr></table></figure>

<p>映射到 <code>0x4000</code> 的 <code>Cortex-M3</code> 固件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -parm:ARMv7-M -b400 firmware.bin</span><br></pre></td></tr></table></figure>

<h3 id="打印log"><a href="#打印log" class="headerlink" title="打印log"></a>打印log</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -B -Lida_batch.log &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>打开 log 输出信息。</p>
<h2 id="批量反编译"><a href="#批量反编译" class="headerlink" title="批量反编译"></a>批量反编译</h2><p>反编译整个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -Ohexrays:outfile.c:ALL -A &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>反编译 main 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -Ohexrays:outfile.c:main -A &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<h3 id="定制批量反编译"><a href="#定制批量反编译" class="headerlink" title="定制批量反编译"></a>定制批量反编译</h3><p>Python脚本可与该 <code>-S</code> 开关一起使用，以在文件加载后自动运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -A -Sdecompile_entry_points.py -Llogfile.txt &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This example tries to load a decompiler plugin corresponding to the current</span></span><br><span class="line"><span class="comment"># architecture (and address size) right after auto-analysis is performed,</span></span><br><span class="line"><span class="comment"># and then tries to decompile the function at the first entrypoint.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is particularly suited for use with the &#x27;-S&#x27; flag, for example:</span></span><br><span class="line"><span class="comment"># idat -Ldecompile.log -Sdecompile_entry_points.py -c file</span></span><br><span class="line"><span class="comment"># filename: Sdecompile_entry_points.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ida_ida</span><br><span class="line"><span class="keyword">import</span> ida_auto</span><br><span class="line"><span class="keyword">import</span> ida_loader</span><br><span class="line"><span class="keyword">import</span> ida_hexrays</span><br><span class="line"><span class="keyword">import</span> ida_idp</span><br><span class="line"><span class="keyword">import</span> ida_entry</span><br><span class="line"></span><br><span class="line"><span class="comment"># becsause the -S script runs very early, we need to load the decompiler</span></span><br><span class="line"><span class="comment"># manually if we want to use it</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_hexrays</span>():</span><br><span class="line">    ALL_DECOMPILERS = &#123;</span><br><span class="line">        ida_idp.PLFM_386: <span class="string">&quot;hexrays&quot;</span>,</span><br><span class="line">        ida_idp.PLFM_ARM: <span class="string">&quot;hexarm&quot;</span>,</span><br><span class="line">        ida_idp.PLFM_PPC: <span class="string">&quot;hexppc&quot;</span>,</span><br><span class="line">        ida_idp.PLFM_MIPS: <span class="string">&quot;hexmips&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    cpu = ida_idp.ph.<span class="built_in">id</span></span><br><span class="line">    decompiler = ALL_DECOMPILERS.get(cpu, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> decompiler:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No known decompilers for architecture with ID: %d&quot;</span> % ida_idp.ph.<span class="built_in">id</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> ida_ida.inf_is_64bit():</span><br><span class="line">        <span class="keyword">if</span> cpu == ida_idp.PLFM_386:</span><br><span class="line">            decompiler = <span class="string">&quot;hexx64&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            decompiler += <span class="string">&quot;64&quot;</span></span><br><span class="line">    <span class="keyword">if</span> ida_loader.load_plugin(decompiler) <span class="keyword">and</span> ida_hexrays.init_hexrays_plugin():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Couldn\&#x27;t load or initialize decompiler: &quot;%s&quot;&#x27;</span> % decompiler)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decompile_func</span>(<span class="params">ea, outfile</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Decompiling at: %X...&quot;</span> % ea)</span><br><span class="line">    cf = ida_hexrays.decompile(ea)</span><br><span class="line">    <span class="keyword">if</span> cf:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;OK.&quot;</span>)</span><br><span class="line">        outfile.write(<span class="built_in">str</span>(cf) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;failed!&quot;</span>)</span><br><span class="line">        outfile.write(<span class="string">&quot;decompilation failure at %X!\n&quot;</span> % ea)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Waiting for autoanalysis...&quot;</span>)</span><br><span class="line">    ida_auto.auto_wait()</span><br><span class="line">    <span class="keyword">if</span> init_hexrays():</span><br><span class="line">        eqty = ida_entry.get_entry_qty()</span><br><span class="line">        <span class="keyword">if</span> eqty:</span><br><span class="line">            idbpath = idc.get_idb_path()</span><br><span class="line">            cpath = idbpath[:-<span class="number">4</span>] + <span class="string">&quot;.c&quot;</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(cpath, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;writing results to &#x27;%s&#x27;...&quot;</span> % cpath)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(eqty):</span><br><span class="line">                    ea = ida_entry.get_entry(ida_entry.get_entry_ordinal(i))</span><br><span class="line">                    decompile_func(ea, outfile)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No known entrypoint. Cannot decompile.&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> idaapi.cvar.batch:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;All done, exiting.&quot;</span>)</span><br><span class="line">        ida_pro.qexit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="加快批处理速度"><a href="#加快批处理速度" class="headerlink" title="加快批处理速度"></a>加快批处理速度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TVHEADLESS=1 idat -A -Smyscript.idc file.bin &gt;/dev/null &amp;</span><br></pre></td></tr></table></figure>
<p>idat使用轻量级文本模式UI的文本模式可执行文件，不需要初始化初始化所有依赖的UI库，可以使用命令行参数在后台运行。</p>
<h1 id="重新分析"><a href="#重新分析" class="headerlink" title="重新分析"></a>重新分析</h1><h2 id="重新分析指令"><a href="#重新分析指令" class="headerlink" title="重新分析指令"></a>重新分析指令</h2><p>将鼠标放在需要重新分析的指令上，然后按 <code>C</code> 键转换为代码。</p>
<h2 id="重新分析函数"><a href="#重新分析函数" class="headerlink" title="重新分析函数"></a>重新分析函数</h2><p>使用 Alt + P 键编辑函数。</p>
<h2 id="选中范围分析"><a href="#选中范围分析" class="headerlink" title="选中范围分析"></a>选中范围分析</h2><p>按 Alt + L 选中开始，转到选择的结尾，按 <code>C</code> 键转换为代码。</p>
<h2 id="重新分析整个数据库"><a href="#重新分析整个数据库" class="headerlink" title="重新分析整个数据库"></a>重新分析整个数据库</h2><ol>
<li>Menu Options &gt;  General…, Analysis Tab, Reanalyze program button;</li>
</ol>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-16-44-25.png" class="">

<ol start="2">
<li>右键单击IDA窗口底部的状态栏，Reanalyze program .</li>
</ol>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-16-45-30.png" class="">

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>使用 右键菜单-&gt; Array… 创建一个数据，或者按 <code>*</code> 键创建数组。</p>
<h2 id="创建字符串数组"><a href="#创建字符串数组" class="headerlink" title="创建字符串数组"></a>创建字符串数组</h2><ol>
<li>首先创建第一个字符串。</li>
<li>选择所有需要创建的字符串，创建数组。</li>
<li>不选中 <code>Create as array</code> ，点击 <code>OK</code> 即可。</li>
</ol>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="使用已经格式化的数据"><a href="#使用已经格式化的数据" class="headerlink" title="使用已经格式化的数据"></a>使用已经格式化的数据</h2><p>在反汇编中选中已经格式化数据，右键 -&gt; <code>Create struct from selection</code> 并将其创建为一个结构。</p>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-01-16.png" class="">

<h2 id="使用本地类型"><a href="#使用本地类型" class="headerlink" title="使用本地类型"></a>使用本地类型</h2><p>使用 <code>Shift+ F1</code> 或菜单 <code>View &gt; Open subviews &gt; Local Types</code> 打开本地类型。按 <code>Ins</code> 键创建一个结构体。</p>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-05-07.png" class="">

<h2 id="通过代码自动创建字段"><a href="#通过代码自动创建字段" class="headerlink" title="通过代码自动创建字段"></a>通过代码自动创建字段</h2><p>选中结构体首地址的寄存器，按 <code>T</code> 键或者右键菜单 -&gt; <code>Structure offset</code> 添加缺少的字段。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="Unicode字符串"><a href="#Unicode字符串" class="headerlink" title="Unicode字符串"></a>Unicode字符串</h2><p>如果程序使用宽字符串，则在创建字符串文字时通常使用相应的 <code>Unicode C-style</code> 选项就足够了：</p>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-13-43.png" class="">

<p>可以使用 <code>Alt + A + U</code> 快速创建 Unicode 16-bits 字符串。</p>
<h2 id="添加新的编码"><a href="#添加新的编码" class="headerlink" title="添加新的编码"></a>添加新的编码</h2><p>要将自定义编码添加到默认列表（通常为UTF-8，UTF-16LE和UTF-32LE）：</p>
<ol>
<li>Options &gt; String literals… (<code>Alt + A</code>);</li>
<li>点击 <code>Currently:</code> 按钮。</li>
<li>右键菜单 -&gt; <code>Insert…</code> (Ins);</li>
<li>指定编码名称。</li>
</ol>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-19-08.png" class="">

<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-19-14.png" class="">

<h2 id="对特定的字符串文字使用编码"><a href="#对特定的字符串文字使用编码" class="headerlink" title="对特定的字符串文字使用编码"></a>对特定的字符串文字使用编码</h2><ol>
<li>Options &gt; String literals… (<code>Alt + A</code>);</li>
<li>点击 <code>Manage defaults</code>。</li>
<li>单击 <code>Default 8-bit</code> 旁边的按钮，然后选择要使用的编码。</li>
</ol>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-23-15.png" class="">

<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-23-21.png" class="">

<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-23-28.png" class="">

<p>后续使用 <code>A</code> 键创建字符串将使用现在设置的默认编码。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>IDA 博客 Igor’s tip of the week 系列文章</p>
</blockquote>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>IDA</tag>
      </tags>
  </entry>
  <entry>
    <title>IDA动态调试so</title>
    <url>/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/</url>
    <content><![CDATA[<h1 id="动态调试送给最好的-TA"><a href="#动态调试送给最好的-TA" class="headerlink" title="动态调试送给最好的 TA"></a>动态调试送给最好的 TA</h1><blockquote>
<p>如果手机系统是 android 10 以上，那么需要 IDA 的版本大于 7.3，并且需要设置一下 <code>IDA_LIBC_PATH</code> 的环境变量。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> IDA_LIBC_PATH=/apex/com.android.runtime/lib/bionic/libc.so   <span class="comment"># 32 位</span></span><br><span class="line">$ <span class="built_in">export</span> IDA_LIBC_PATH=/apex/com.android.runtime/lib64/bionic/libc.so <span class="comment"># 64 位</span></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://bbs.pediy.com/thread-258103.htm">https://bbs.pediy.com/thread-258103.htm</a></p>
<p>本文使用以下调试环境测试均未发现问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IDA 7.7 + android 9 设置 ro.debuggable 为<span class="literal">true</span> 。</span><br><span class="line">IDA 7.7 + android 10 设置 ro.debuggable 为<span class="literal">true</span> 。</span><br></pre></td></tr></table></figure>
<p>设置 <code>ro.debuggable</code> 为 <code>true</code> 使用了这个插件 <a href="https://github.com/Magisk-Modules-Repo/MagiskHidePropsConf">MagiskHidePropsConf</a></p>
<p>还有一个 xposed 插件 <a href="https://github.com/Palatis/XAppDebug">XAppDebug</a>，暂时没有使用过，不知道效果如何。</p>
<h2 id="常规方式"><a href="#常规方式" class="headerlink" title="常规方式"></a>常规方式</h2><h3 id="1-使用-IDA-打开需要调试的-so-文件，找到关键的方法，设置断点。"><a href="#1-使用-IDA-打开需要调试的-so-文件，找到关键的方法，设置断点。" class="headerlink" title="1. 使用 IDA 打开需要调试的 so 文件，找到关键的方法，设置断点。"></a>1. 使用 IDA 打开需要调试的 so 文件，找到关键的方法，设置断点。</h3><img src="/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-20-57-11.png" class="">

<h3 id="2-选择-Android-调试器，设置-hostname-和端口。"><a href="#2-选择-Android-调试器，设置-hostname-和端口。" class="headerlink" title="2. 选择 Android 调试器，设置 hostname 和端口。"></a>2. 选择 Android 调试器，设置 hostname 和端口。</h3><img src="/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-20-58-08.png" class="">

<h3 id="3-开始调试"><a href="#3-开始调试" class="headerlink" title="3. 开始调试"></a>3. 开始调试</h3><ul>
<li>启动 <code>android_server</code> 。</li>
<li>端口转发 <code>adb forward tcp:23946 tcp:23946</code> 。</li>
<li>以调试模式启动对应的 Activaty ，<code>adb shell am start -D -n com.sgzh.dt/com.androlua.Welcome</code> 。</li>
</ul>
<p>需要注意的是，在安装 APK 时，检查对应 apk 的属性，需要满足以下两个属性均为 <code>true</code>，可以通过使用 <code>apktool</code> 解包后修改重新打包实现，也可以使用面具模块或 <code>xposed</code> 模块实现。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">android:debuggable=<span class="string">&quot;true&quot;</span></span><br><span class="line">android:extractNativeLibs=<span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>android:extractNativeLibs = &quot;true&quot;</code> 时，gradle 打包时会对工程中的 so 库进行压缩，最终生成 apk 包的体积会减小。但用户在手机端进行 apk 安装时，系统会对压缩后的 so 库进行解压，一般解压到 <code>/data/app/ </code>某一目录下，从而造成用户安装 apk 的时间变长。如果为 false 则不会解压到该目录。<br><code>minSdkVersion &gt;= 23</code> 并且 <code>Android Gradle plugin &gt;= 3.6.0</code> 情况下，打包时默认<code>android:extractNativeLibs=false</code>， 如果该属性为<code>false</code>，虽然 IDA 可以正常附加，但是无法加载对应的 so 进行调试，所以如果未开启 so 压缩会直接导致程序执行的时候 ida 不能够识别到响应的 so 加载，导致无法定位到 so 中的代码从而无法停在断点。对于未开启 so 压缩的情况需要通过重打包来修改该字段以便可以定位到 so。<br>针对性的，也有相应的模块，用于 Hook 安卓的安装器，让其在安装时将该属性的值设为 true，从而能够正确的调试，例如项目<a href="https://github.com/AlienwareHe/ForceExtractNativeLibs">ForceExtractNativeLibs</a>即通过 Xposed 进行 Hook 在安装时重置该属性。</p>
</blockquote>
<p>执行完以上操作完，使用 IDA 附加对应的 APP 。</p>
<img src="/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-02-38.png" class="">

<h3 id="4-jdb-连接"><a href="#4-jdb-连接" class="headerlink" title="4. jdb 连接"></a>4. jdb 连接</h3><p>通过执行 <code>adb forward tcp:&lt;port&gt; jdwp:&lt;pid&gt;</code> 命令将 host 机器上的 port 端口转发到 Android 上的调试进程，以便调试器通过这个端口连接到目标进程。</p>
<blockquote>
<p>打开 monitor 应用，使用 DDMS 查看 APP 的调试端口可以达到同样的目的。</p>
</blockquote>
<p>这里将转发的 port 指定为 8700，假设进程 ID 为 12345，对应的命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb forward tcp:8700 jdwp:12345</span><br></pre></td></tr></table></figure>

<p>然后使用 <code>jdb</code> 命令连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700` 。</span><br></pre></td></tr></table></figure>

<p>此时 APP 将会运行起来，IDA 将会弹出下列界面，点击 same 就可以了。</p>
<img src="/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-07-35.png" class="">

<p>最终将会断在我们之前下断点的地方。</p>
<img src="/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-08-20.png" class="">

<h3 id="5-分析并-dump-lua-字节码"><a href="#5-分析并-dump-lua-字节码" class="headerlink" title="5. 分析并 dump lua 字节码"></a>5. 分析并 dump lua 字节码</h3><p>通过参考其他文章可知 luaL_loadbufferx 是关键解密函数，但是也需要我们要分析解密的具体地方。看到有 malloc 就很可疑。我们就需要重点关注这个地方。通过调试发现其申请的空间就是存放解密后的 lua 字节码。</p>
<img src="/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-09-05.png" class="">

<p>编写 dump 脚本，下面提供了 IDC 和 Python 脚本。</p>
<p><code>dump.idc</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> i,fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;d:\\init.lua&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> start = <span class="number">0xF18B7140</span>;</span><br><span class="line">    <span class="keyword">auto</span> size = <span class="number">0x1A6</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        fputc(Byte(start + i),fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dump.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line">start_address = <span class="number">0xF18B7140</span></span><br><span class="line">data_length = <span class="number">0x1A6</span></span><br><span class="line">data = idaapi.dbg_read_memory(start_address ,</span><br><span class="line">data_length)</span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;d:\\dump1&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">fp.write(data)</span><br><span class="line">fp.close()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Dump OK&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="将字节码转换为-lua-代码"><a href="#将字节码转换为-lua-代码" class="headerlink" title="将字节码转换为 lua 代码"></a>将字节码转换为 lua 代码</h3><p>在网上找到 <code>unluac_2015_06_13.jar</code> ，将 lua 节码转换为 lua 代码。</p>
<img src="/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-13-27.png" class="">

<h2 id="修改-so-方式"><a href="#修改-so-方式" class="headerlink" title="修改 so 方式"></a>修改 so 方式</h2><p>这种方式主要是探索 IDA 断点的字节码，同样使用于探索其他调试器的断点字节码。</p>
<h3 id="修改字节码"><a href="#修改字节码" class="headerlink" title="修改字节码"></a>修改字节码</h3><p>使用 IDA 打开需要调试的 so 文件，找到关键的方法，修改字节码，并将修改后的内容保存至文件。</p>
<img src="/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-18-20.png" class="">

<p>为什么将字节码修 03 AF 改为 10 DE 。</p>
<img src="/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-19-40.png" class="">

<p>使用的 IDA 插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">下载Keypatch.py复制到插件目录：https://github.com/keystone-engine/keypatch</span><br><span class="line">下载安装keystone python模块：https://github.com/keystone-engine/keystone/releases/download/0.9.1/keystone-0.9.1-python-win64.msi</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<blockquote>
<p>其实这里不一定要使用这种方式获取断点的字节码，也可以通过循环断下来，将指令改为一个死循环，最后暂停就可以断到相应的位置了，最后再将指令改回去就可以了。</p>
</blockquote>
<p>最后重打包，按照之前的方式调试即可。</p>
<h1 id="如何在-init-proc-和-init-arrary-调用下断点"><a href="#如何在-init-proc-和-init-arrary-调用下断点" class="headerlink" title="如何在 .init_proc 和 init_arrary 调用下断点"></a>如何在 <code>.init_proc</code> 和 <code>init_arrary</code> 调用下断点</h1><h2 id="init-proc-函数和-init-arrary-的产生方法。"><a href="#init-proc-函数和-init-arrary-的产生方法。" class="headerlink" title=".init_proc 函数和 init_arrary 的产生方法。"></a><code>.init_proc</code> 函数和 <code>init_arrary</code> 的产生方法。</h2><p><code>_init</code> 函数经过编译后就是 <code>.init_proc</code> 函数，是目前我所知道的在 so 最早被调用的函数 。<code>_init</code> 函数无参，无返回值，其次必须函数名必须是 <code>_init</code> ，并且不能名称粉碎。</p>
<img src="/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-36-04.png" class="">

<p>函数添加 <code>__attribute__((constructor))</code> 属性后，就会将对应的函数指针放在 <code>init_array</code> 节中，在 JNI_Onload 之前被调用。</p>
<img src="/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-36-55.png" class="">

<p>执行结果如下：</p>
<img src="/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-41-55.png" class="">

<p>可以看到先执行的 <code>.init_proc</code> 函数，然后执行 <code>init_arrary</code> 节里的函数，最后执行 JNI_Onload 。</p>
<h2 id="通过源码找到调用的关键位置"><a href="#通过源码找到调用的关键位置" class="headerlink" title="通过源码找到调用的关键位置"></a>通过源码找到调用的关键位置</h2><p>由于 <code>.init_proc</code> 和 <code>init_arrary</code> 是在 so 加载完成前调用的，那么就需要知道他们是在何时调用的，这里就需要跟一下 dlopen 的源码，最终会发现调用他们实现在 <code>linker.cpp </code>中，这一块大家有兴趣可以自己看看。我这里就直接给 android 7.1.2 源码中的关键点了。</p>
<p><code>http://androidxref.com/7.1.2_r36/xref/bionic/linker/linker.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">soinfo::call_function</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function_name __unused,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">linker_function_t</span> function)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (function == <span class="literal">nullptr</span></span><br><span class="line">      || <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(function) == <span class="built_in">static_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(<span class="number">-1</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TRACE</span>(<span class="string">&quot;[ Calling %s @ %p for \&quot;%s\&quot; ]&quot;</span>, function_name, function, <span class="built_in">get_realpath</span>());</span><br><span class="line">  <span class="built_in">function</span>(); <span class="comment">//直接调用函数指针</span></span><br><span class="line">  <span class="built_in">TRACE</span>(<span class="string">&quot;[ Done calling %s @ %p for \&quot;%s\&quot; ]&quot;</span>, function_name, function, <span class="built_in">get_realpath</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家看源码时也最好根据自己的手机版本看相对应的源码。其中 <code>funcion()</code> 就是调用 <code>.init_proc</code> 和 <code>init_arrary</code> 的地方，大家看看这个地方有什么特点？我们可以根据其上下两行输出字符串确定其位置。</p>
<p>我们直接到手机的 <code>system/bin</code> 目录中导出 linker 文件，如果调试 ARMv8 则需要导出 linker64 文件。通过查找字符串<code> [ Calling %s @ %p for \&quot;%s\&quot; ]</code> 找到关键位置，其偏移为 0x6414 ，最后就可以通过基址+偏移得到最终的地址需要下断点的地址。</p>
<img src="/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-24-19-19-27.png" class="">

<h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><p>当在 libc 中断下来直接，ctrl+s 找到 linker 的基址，然后加上偏移 0x6414 。可以发现其基址为 0xF44DC000+0x6414 &#x3D; F44E2414 最后跳到此处，下断点直接 F9 运行。然后 jdb 连接，最终会断在此处，F7 单步步入，即为 <code>.init_proc</code> 函数，继续执行就会又断在此处，F7 步入，则 test_construtor 函数。</p>
<img src="/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-24-19-23-12.png" class="">

<img src="/2021/02/22/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-24-19-23-20.png" class="">

<p>其中也可以通过前文讲的修改 so 文件，修改字节码实现断点或无限循环达到相同的效果。</p>
<p>调试应用和代码：</p>
<p><a href="https://github.com/CKCat/CKCat.github.io/blob/main/source/_posts/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/%E9%80%81%E7%BB%99%E6%9C%80%E5%A5%BD%E7%9A%84TA.apk">送给最好的 TA</a></p>
<p><a href="https://github.com/CKCat/CKCat.github.io/blob/main/source/_posts/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/unluac_2015_06_13.jar">unluac_2015_06_13.jar</a></p>
<p><a href="https://github.com/CKCat/CKCat.github.io/tree/main/source/_posts/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/ndkcode">init_proc 相关代码</a></p>
<p>参考：</p>
<p><a href="https://bbs.pediy.com/thread-254770.htm">https://bbs.pediy.com/thread-254770.htm</a></p>
<p><a href="https://bbs.kanxue.com/thread-266378.htm">https://bbs.kanxue.com/thread-266378.htm</a></p>
<p><a href="https://blog.lleavesg.top/article/IDA-Androidso">https://blog.lleavesg.top/article/IDA-Androidso</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>IDA</tag>
      </tags>
  </entry>
  <entry>
    <title>JebAndroidSigPlugin使用记录</title>
    <url>/2021/01/28/JebAndroidSigPlugin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>最近使用了一下 JebAndroidSigPlugin 插件，感觉效果还可以，记录一下使用过程。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>直接去 <a href="https://github.com/pnfsoftware/jeb2-androsig">https://github.com/pnfsoftware/jeb2-androsig</a> 下载编译好的 jar 包， 丢到 <code>jeb/coreplugins</code> 目录下，正常情况下 JEB 应该自带该插件</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用过程主要参考下面两篇文章：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.pnfsoftware.com/blog/jeb-library-code-matching-for-android/</span><br><span class="line">https://www.pnfsoftware.com/blog/new-version-of-androsig/</span><br></pre></td></tr></table></figure>
<p>这里我直接使用上面链接提供的 <a href="https://s3-us-west-2.amazonaws.com/jebdecompiler2/androsig_1.1_db_20190515.zip">androsig_1.1_db_20190515.zip</a>,解压到 <code>JEB/coreplugins/android_sigs/</code> 目录下。</p>
<h2 id="Android-Signature-Recognizer"><a href="#Android-Signature-Recognizer" class="headerlink" title="Android Signature Recognizer"></a>Android Signature Recognizer</h2><p>JEB 打开待分析 APK ，执行 Android Signature Recognizer 插件，将会弹出下列界面，直接点击确定执行。</p>
<img src="/2021/01/28/JebAndroidSigPlugin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2021-01-29-14-12-06.png" class="">

<p>执行完成效果如下图所示</p>
<img src="/2021/01/28/JebAndroidSigPlugin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2021-01-29-14-16-28.png" class="">

<h2 id="Android-Signature-Generator"><a href="#Android-Signature-Generator" class="headerlink" title="Android Signature Generator"></a>Android Signature Generator</h2><p>接下来简单讲一下 Android Signature Generator 插件的使用，我们在分析过程中，发现了一些库被混淆了，此时就可以利用该插件制作 Sig 文件，然后利用 Android Signature Recognizer 插件进行识别。</p>
<p>这里我是用 Android Studio 创建一个新的应用，然后将 androidx 包制作一个 sig 文件，首先打开  Android Signature Generator 插件，按下图进行设置，点击确定。</p>
<img src="/2021/01/28/JebAndroidSigPlugin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2021-01-29-14-27-54.png" class="">

<p>执行成功后，将会生成一个 <code>jeb/coreplugins/android_sigs</code> 目录下 androidx.sig 文件。</p>
<img src="/2021/01/28/JebAndroidSigPlugin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2021-01-29-14-31-04.png" class="">

<p>后续如果发现 androidx 相关的包被混淆了，就可以使用 Android Signature Recognizer 插件进行识别了。</p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>JEB</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基本使用</title>
    <url>/2019/12/14/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>推荐使用 <a href="https://github.com/dbcli/mycli">mycli</a> 操作 MySQL 数据库.</p>
</blockquote>
<h1 id="MySQL-使用"><a href="#MySQL-使用" class="headerlink" title="MySQL 使用"></a>MySQL 使用</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>命令行连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -uroot -p <span class="comment">#回车后输入密码。</span></span><br></pre></td></tr></table></figure>

<p>退出登录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ quit <span class="comment"># 或 exit 或 ctrl+D</span></span><br></pre></td></tr></table></figure>

<p>其他</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select version();     <span class="comment"># 查看版本</span></span><br><span class="line">$ select now();         <span class="comment"># 查看当前时间</span></span><br></pre></td></tr></table></figure>

<img src="/2019/12/14/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/2019-12-15-16-32-28.png" class="">

<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>查看所有的数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ show databases;</span><br></pre></td></tr></table></figure>

<p>使用数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ use 数据库名;</span><br></pre></td></tr></table></figure>

<p>查看当前使用的数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select database();</span><br></pre></td></tr></table></figure>

<p>创建数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ create database 数据库名 charset=utf8mb4;</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">$ create database test01 charset=utf8mb4;</span><br></pre></td></tr></table></figure>

<p><strong>utf8mb4 才是正真的 utf8。</strong></p>
<p>查看创建数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ show create database 数据库名;</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">$ show create database test01;</span><br></pre></td></tr></table></figure>

<p>删除数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ drop database 数据库名;</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">$ drop database test01;</span><br></pre></td></tr></table></figure>

<p>当数据名称有特殊字符时，使用&#96;&#96;包起来。</p>
<h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><p>查看当前数据库中的所有表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ show tables;</span><br></pre></td></tr></table></figure>

<p>创建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建xxx表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> xxxx(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建 students表（id、name、age、high, gender、cls_id)</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> students(</span><br><span class="line">    id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    age tinyint unsigned,</span><br><span class="line">    high <span class="type">decimal</span>(<span class="number">5</span>, <span class="number">2</span>),</span><br><span class="line">    gender enum(&quot;男&quot;, &quot;女&quot;, &quot;保密&quot;) <span class="keyword">default</span> &quot;保密&quot;,</span><br><span class="line">    cls_id <span class="type">int</span> unsigned);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students <span class="keyword">values</span>(<span class="number">0</span>, &quot;zhangsan&quot;, <span class="number">18</span>, <span class="number">188</span>, &quot;男&quot;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建classe表(id、name)</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> classes(id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> auto_increment <span class="keyword">primary</span> key, name <span class="type">varchar</span>(<span class="number">30</span>));</span><br></pre></td></tr></table></figure>

<p>查看表结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ desc 表名;</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line">$ desc students;</span><br></pre></td></tr></table></figure>

<p>修改表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加字段 alter table 表名 add 列名 类型;</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">add</span> birthday datetime;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改字段 alter table 表名 modify 列名 类型;</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students modify birthday <span class="type">date</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改字段-重命名 alter table 表名 change 原名 新名 类型及约束;</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students modify birthday  birth <span class="type">date</span> <span class="keyword">default</span> &quot;2000-1-1&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除字段(尽量不用) alter table 表名 drop 列名;</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">drop</span> high;</span><br></pre></td></tr></table></figure>

<p>删除表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ drop table 表名; -- 删除表</span><br><span class="line">$ drop database 数据库; -- 删除数据库</span><br></pre></td></tr></table></figure>

<p>查看创建表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ show create table 表名;</span><br></pre></td></tr></table></figure>

<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>增加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 全列插入</span></span><br><span class="line"><span class="comment">-- insert into 表名 values(...);</span></span><br><span class="line"><span class="comment">-- 主键字段 可以用0 null default 来占位</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> classes <span class="keyword">values</span>(<span class="number">0</span>, &quot;class02&quot;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students <span class="keyword">values</span>(<span class="number">0</span>, &quot;lisi&quot;, <span class="number">18</span>, &quot;女&quot;, <span class="number">0</span>, &quot;2011-01-01&quot;, <span class="number">167</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students <span class="keyword">values</span>(<span class="keyword">null</span>, &quot;lisi&quot;, <span class="number">18</span>, &quot;女&quot;, <span class="number">0</span>, &quot;2011-01-01&quot;, <span class="number">167</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students <span class="keyword">values</span>(<span class="keyword">default</span>, &quot;lisi&quot;, <span class="number">18</span>, &quot;女&quot;, <span class="number">0</span>, &quot;2011-01-01&quot;, <span class="number">167</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students <span class="keyword">values</span>(<span class="keyword">default</span>, &quot;lisi&quot;, <span class="number">18</span>, <span class="number">1</span>, <span class="number">0</span>, &quot;2011-01-01&quot;, <span class="number">167</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students <span class="keyword">values</span>(<span class="keyword">default</span>, &quot;lisi&quot;, <span class="number">18</span>, <span class="number">3</span>, <span class="number">0</span>, &quot;2011-01-01&quot;, <span class="number">167</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 部分插入</span></span><br><span class="line"><span class="comment">-- insert into 表名(列1, 列2 ...) values(值1，值2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多行</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students (name, gender) <span class="keyword">values</span> (&quot;貂蝉&quot;, <span class="number">2</span>)，(&quot;大乔&quot;, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students <span class="keyword">values</span>(<span class="keyword">default</span>, &quot;鲁班&quot;, <span class="number">18</span>, <span class="number">2</span>, <span class="number">0</span>, &quot;2011-01-01&quot;, <span class="number">167</span>), (<span class="keyword">default</span>, &quot;后羿&quot;, <span class="number">18</span>, <span class="number">1</span>, <span class="number">0</span>, &quot;2011-01-01&quot;, <span class="number">167</span>);</span><br></pre></td></tr></table></figure>

<p>修改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- update 表名 set 列1=值1, 列2=值2 ... where 条件</span></span><br><span class="line"><span class="keyword">update</span> students <span class="keyword">set</span> gender<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> students <span class="keyword">set</span> gender<span class="operator">=</span><span class="number">2</span> <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">6</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有的列</span></span><br><span class="line"><span class="comment">-- select * from 表名;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students;</span><br><span class="line"><span class="comment">-- 查询name=&quot;lisi&quot;的所有数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> name<span class="operator">=</span>&quot;lisi&quot;;</span><br><span class="line"><span class="comment">-- 查询id &gt; 8的所有数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询指定的列</span></span><br><span class="line"><span class="comment">-- select * 列1, 列2 ... from 表名;</span></span><br><span class="line"><span class="keyword">select</span> name, gender <span class="keyword">from</span> students;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 as 为列或表指定别名</span></span><br><span class="line"><span class="comment">-- select 字段[as 别名], 字段[as 别名] from 数据表 where ...;</span></span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">as</span> 姓名, gender <span class="keyword">as</span> 性别 <span class="keyword">from</span> students;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字段的顺序</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">as</span> 序号, gender <span class="keyword">as</span> 性别, name <span class="keyword">as</span> 姓名 <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure>

<p>删除(基本不会使用，一般用一个字段标记是否删除)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- delete from 表名 where 条件;</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> students;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> students <span class="keyword">where</span> name<span class="operator">=</span>&quot;lisi&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 逻辑删除</span></span><br><span class="line"><span class="comment">-- 给students 表添加一个 is_delete 字段，bit类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">add</span> is_delete bit <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">update</span> students <span class="keyword">set</span> is_delete <span class="operator">=</span> <span class="number">1</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<h2 id="数据库备份和恢复"><a href="#数据库备份和恢复" class="headerlink" title="数据库备份和恢复"></a>数据库备份和恢复</h2><p>备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysqldump -u用户名 -p 数据库名 &gt; dump.sql <span class="comment">#按提示输入密码</span></span><br></pre></td></tr></table></figure>

<p>恢复</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -u用户名 -p 新数据库名 &lt; dump.sql <span class="comment">#按提示输入密码</span></span><br></pre></td></tr></table></figure>

<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2><p>经过研究和对使用中问题的总结，对于设计数据库提出了一些规范，这些规范被称为范式(Normal Form)，<br>目前有迹可寻的共有 8 种范式，一般需要遵守 3 范式即可。</p>
<ul>
<li>第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。</li>
<li>第二范式（2NF）：首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。</li>
<li>第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</li>
</ul>
<h2 id="E-R-模型"><a href="#E-R-模型" class="headerlink" title="E-R 模型"></a>E-R 模型</h2><ul>
<li>E 表示 entry-实体，设计实体就像定义一个类一样，指定从哪些方面描述对象，一个实体转换为数据库中的一个表。</li>
<li>R 表示 relationship-关系，关系描述两个实体之间的对应规则，关系的类型包括包括一对一、一对多、多对多。</li>
</ul>
<ol>
<li><p>一对一 :<br>但一个表的列太多时，并且某些列不经常出现在结果中，此时可以对列进行拆分，此时两个表的关系为一对一关系。实体 A 对实体 B 为 1 对 1，则在表 A 或表 B 中创建一个字段，存储另一个表的主键值。</p>
</li>
<li><p>一对多 :<br>A 表中的一条数据对应 B 表中的一条数据， B 表中的一条数据对应 A 表中的多条数据。此时 A 与 B 为多对一的关系。实体 A 对实体 B 为 1 对多：在表 B 中创建一个字段，存储表 A 的主键值。</p>
</li>
<li><p>多对多 :<br>A 表中的一条数据对应 B 表中的多条数据， B 表中的一条数据对应 A 表中的多条数据。此时 A 与 B 为多对多的关系。实体 A 对实体 B 为多对多：新建一张表 C，这个表只有两个字段，一个用于存储 A 的主键值，一个用于存储 B 的主键值。</p>
</li>
</ol>
<h1 id="更多查询用法"><a href="#更多查询用法" class="headerlink" title="更多查询用法"></a>更多查询用法</h1><p>消除重复行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select distinct 列1, 列2 ... from 表名;</span><br><span class="line"><span class="comment"># 例如:</span></span><br><span class="line">$ select distinct gender from students;</span><br></pre></td></tr></table></figure>

<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>使用 where 子句对表中的数据筛选，结果为 true 的行为会出现在结果集中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from 表名 <span class="built_in">where</span> 条件;</span><br></pre></td></tr></table></figure>

<p>where 后面支持多种运算符，进行条件的处理。</p>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ul>
<li>等于 &#x3D;</li>
<li>大于 &gt;</li>
<li>大于等于 &gt;&#x3D;</li>
<li>小于 &lt;</li>
<li>小于等于 &lt;&#x3D;</li>
<li>不等于 !&#x3D; 或 &lt;&gt;</li>
</ul>
<p>例： 查询编号大于 3 的学生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from students <span class="built_in">where</span> <span class="built_in">id</span> &gt; 3;</span><br></pre></td></tr></table></figure>

<p>例：查询编号不大于 4 的学生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from students <span class="built_in">where</span> <span class="built_in">id</span> &lt;= 4;</span><br></pre></td></tr></table></figure>

<p>例：查询姓名不是“黄蓉”的学生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from students <span class="built_in">where</span> name != <span class="string">&quot;黄蓉&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>例：查询没被删除的学生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from students <span class="built_in">where</span> is_delete=0;</span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ul>
<li>and</li>
<li>or</li>
<li>not</li>
</ul>
<p>例：查询编号大于 3 的女同学</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from students <span class="built_in">where</span> <span class="built_in">id</span> &gt; 4 or gender = 0;</span><br></pre></td></tr></table></figure>

<p>例 6：查询编号小于 4 或没被删除的学生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from students <span class="built_in">where</span> <span class="built_in">id</span> &lt; 4 or is_delete = 0;</span><br></pre></td></tr></table></figure>

<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><ul>
<li><code>like</code></li>
<li><code>%</code> 表示任意多个任意字符</li>
<li><code>_</code> 表示一个任意字符</li>
</ul>
<p>例：查询姓黄的学生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from students <span class="built_in">where</span> name like <span class="string">&quot;黄%&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>例：查询姓黄并且“名”是一个字的学生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from students <span class="built_in">where</span> name like <span class="string">&quot;黄_&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>例：查询姓黄或叫靖的学生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from students <span class="built_in">where</span> name like <span class="string">&quot;黄%&quot;</span> or name like <span class="string">&quot;%靖&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><ul>
<li><code>in</code> 表示在一个非连续的范围内</li>
</ul>
<p>例：查询编号是 1 或 3 或 8 的学生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from students <span class="built_in">where</span> <span class="built_in">id</span> <span class="keyword">in</span>(1,3, 8);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>between ... and ...</code> 表示在一个连续的范围内</li>
</ul>
<p>例：查询编号为 3 至 8 的学生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from students <span class="built_in">where</span> <span class="built_in">id</span> between 3 and 8;</span><br></pre></td></tr></table></figure>

<p>例：查询编号是 3 至 8 的男生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from students <span class="built_in">where</span> (<span class="built_in">id</span> between 3 and 8) and gender = 1;</span><br></pre></td></tr></table></figure>

<h2 id="空判断"><a href="#空判断" class="headerlink" title="空判断"></a>空判断</h2><ul>
<li>注意: <code>null</code> 和 <code>&quot;&quot;</code> 是不同的</li>
<li>判空 <code>is null</code></li>
</ul>
<p>例：查询没有填写身高的学生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from students <span class="built_in">where</span> height is null;</span><br></pre></td></tr></table></figure>

<ul>
<li>判非空 <code>is not null</code></li>
</ul>
<p>例：查询填写了身高的学生</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from students <span class="built_in">where</span> height is not null and gender=1;</span><br></pre></td></tr></table></figure>

<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><ul>
<li>优先级由高到低的顺序为：小括号，not，比较运算符，逻辑运算符</li>
<li>and 比 or 先运算，如果同时出现并希望先算 or，需要结合()使用</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]</span><br></pre></td></tr></table></figure>

<p>说明</p>
<ul>
<li>将行数据按照列 1 进行排序，如果某些行列 1 的值相同时，则按照列 2 排序，以此类推</li>
<li>默认按照列值从小到大排列（asc）</li>
<li><code>asc</code> 从小到大排列，即升序</li>
<li><code>desc</code> 从大到小排序，即降序</li>
</ul>
<p>例：查询未删除男生信息，按学号降序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ select * from students <span class="built_in">where</span> gender = 1 and is_delete = 0 order by <span class="built_in">id</span> desc;</span><br></pre></td></tr></table></figure>

<p>例：查询未删除学生信息，按名称升序(默认升序)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where is_delete=0 order by id;</span><br></pre></td></tr></table></figure>

<p>例 3：显示所有的学生信息，先按照年龄从大–&gt;小排序，当年龄相同时 按照身高从高–&gt;矮排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students order by age, height desc;</span><br></pre></td></tr></table></figure>

<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><ul>
<li>count(*)表示计算总行数，括号中写星与列名，结果是相同的</li>
</ul>
<p>例：查询学生总数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) from students;</span><br></pre></td></tr></table></figure>

<ul>
<li>max(列)表示求此列的最大值</li>
</ul>
<p>例：查询女生的编号最大值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select max(id) from students where gender = 2;</span><br></pre></td></tr></table></figure>

<ul>
<li>min(列)表示求此列的最小值</li>
</ul>
<p>例：查询未删除的学生最小编号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select min(id) from students where is_delete = 0;</span><br></pre></td></tr></table></figure>

<ul>
<li>sum(列)表示求此列的和</li>
</ul>
<p>例：查询男生的总年龄</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sum(age) from students where gender = 1;</span><br><span class="line">-- 平均年龄</span><br><span class="line">select sum(age)/count(*) from students where gender = 1;</span><br></pre></td></tr></table></figure>

<ul>
<li>avg(列)表示求此列的平均值</li>
</ul>
<p>例：查询未删除女生的编号平均值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select avg(age) from students where is_delete = 0 and gender = 2;</span><br></pre></td></tr></table></figure>

<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><ul>
<li>group by 的含义:将查询结果按照 1 个或多个字段进行分组，字段值相同的为一组</li>
<li>group by 可用于单个字段分组，也可用于多个字段分组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 根据gender字段来分组</span><br><span class="line">select gender from students group by gender;</span><br></pre></td></tr></table></figure>

<p>group by + group_concat()</p>
<ul>
<li>group_concat(字段名)可以作为一个输出字段来使用，</li>
<li>表示分组之后，根据分组结果，使用 group_concat()来放置每一组的某字段的值的集合</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select gender, group_concat(name) from students group by gender;</span><br><span class="line"></span><br><span class="line">select gender, group_concat(id) from students group by gender;</span><br><span class="line">+--------+------------------+</span><br><span class="line">| gender | group_concat(id) |</span><br><span class="line">+--------+------------------+</span><br><span class="line">| 男     | 3,4,8,9,13,15    |</span><br><span class="line">| 女     | 1,2,5,7,10,12,14 |</span><br><span class="line">| 中性   | 11               |</span><br><span class="line">| 保密   | 6                |</span><br><span class="line">+--------+------------------+</span><br></pre></td></tr></table></figure>

<p>group by + 集合函数</p>
<ul>
<li>通过 group_concat()的启发，我们既然可以统计出每个分组的某字段的值的集合，那么我们也可以通过集合函数来对这个值的集合做一些操作。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select gender, group_concat(age) from students group by gender;</span><br><span class="line"></span><br><span class="line">-- 分别统计性别为男/女的平均年龄</span><br><span class="line">select gender, avg(age) from students group by gender;</span><br><span class="line"></span><br><span class="line">-- 分别统计性别的个数</span><br><span class="line">select gender, count(*) from students group by gender;</span><br></pre></td></tr></table></figure>

<p>group by + having</p>
<ul>
<li>having 条件表达式：用来分组查询后指定一些条件来输出查询结果</li>
<li>having 作用和 where 一样，但 having 只能用于 group by</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select gender, count(*) from students group by gender</span><br><span class="line"> having count(*) &gt;2;</span><br></pre></td></tr></table></figure>

<p>group by + with rollup</p>
<ul>
<li>with rollup 的作用是：在最后新增一行，来记录当前列里所有记录的总和</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select gender, count(*) from students group by gender</span><br><span class="line">with rollup;</span><br><span class="line"></span><br><span class="line">select gender, group_concat(age) from students group by gender with rollup;</span><br></pre></td></tr></table></figure>

<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表名 limit start,count</span><br></pre></td></tr></table></figure>

<p>说明</p>
<ul>
<li>从 start 开始，获取 count 条数据</li>
</ul>
<p>例：查询前 3 行男生信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where gender = 1 limit 0,3;</span><br></pre></td></tr></table></figure>

<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>当查询结果的列来源于多张表时，需要将多张表连接成一个大的数据集，再选择合适的列返回</p>
<p>mysql 支持三种类型的连接查询，分别为：</p>
<ul>
<li>内连接查询：查询的结果为两个表匹配到的数据</li>
</ul>
<img src="/2019/12/14/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/2019-12-18-12-55-40.png" class="">

<ul>
<li>右连接查询：查询的结果为两个表匹配到的数据，右表特有的数据，对于左表中不存在的数据使用 null 填充</li>
</ul>
<img src="/2019/12/14/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/2019-12-18-12-55-57.png" class="">

<ul>
<li>左连接查询：查询的结果为两个表匹配到的数据，左表特有的数据，对于右表中不存在的数据使用 null 填充</li>
</ul>
<img src="/2019/12/14/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/2019-12-18-12-56-06.png" class="">

<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表1 inner 或 left 或 right join 表2 on 表1.列 = 表2.列;</span><br></pre></td></tr></table></figure>

<p>例：使用内连接查询班级表与学生表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students inner join classes on students.cls_id = classes.id;</span><br></pre></td></tr></table></figure>

<p>例 2：使用左连接查询班级表与学生表, 此处使用了 as 为表起别名，目的是编写简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students as s left join classes as c on s.cls_id = c.id;</span><br></pre></td></tr></table></figure>

<p>例 3：使用右连接查询班级表与学生表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students as s right join classes as c on s.cls_id = c.id;</span><br></pre></td></tr></table></figure>

<p>例 4：查询学生姓名及班级名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select s.name, c.name from students as s inner join classes as c on s.cls_id = c.id;</span><br></pre></td></tr></table></figure>

<h2 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h2><ul>
<li><p>设计省信息的表结构 provinces</p>
<ul>
<li>id</li>
<li>ptitle</li>
</ul>
</li>
<li><p>设计市信息的表结构 citys</p>
<ul>
<li>id</li>
<li>ctitle</li>
<li>proid</li>
</ul>
</li>
<li><p>citys 表的 proid 表示城市所属的省，对应着 provinces 表的 id 值</p>
</li>
</ul>
<p>问题：</p>
<blockquote>
<p>能不能将两个表合成一张表呢？</p>
</blockquote>
<p>思考：</p>
<blockquote>
<p>观察两张表发现，citys 表比 provinces 表多一个列 proid，其它列的类型都是一样的</p>
</blockquote>
<p>意义：</p>
<blockquote>
<p>存储的都是地区信息，而且每种信息的数据量有限，没必要增加一个新表，或者将来还要存储区、乡镇信息，都增加新表的开销太大</p>
</blockquote>
<p>答案：</p>
<blockquote>
<p>定义表 areas，结构如下</p>
</blockquote>
<ul>
<li>id</li>
<li>atitle</li>
<li>pid</li>
</ul>
<p>说明:</p>
<ul>
<li>因为省没有所属的省份，所以可以填写为 null</li>
<li>城市所属的省份 pid，填写省所对应的编号 id</li>
<li>这就是自关联，表中的某一列，关联了这个表中的另外一列，但是它们的业务逻辑含义是不一样的，城市信息的 pid 引用的是省信息的 id</li>
<li>在这个表中，结构不变，可以添加区县、乡镇街道、村社区等信息</li>
</ul>
<img src="/2019/12/14/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/2019-12-18-22-07-15.png" class="">

<ul>
<li>创建 areas 表的语句如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table areas(</span><br><span class="line">    aid int primary key,</span><br><span class="line">    atitle varchar(20),</span><br><span class="line">    pid int</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>从 sql 文件中导入数据, <code>areas.sql</code> <a href="https://github.com/CKCat/Note/blob/master/Django/areas.sql">文件地址</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source areas.sql;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询一共有多少个省</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) from areas where pid is null;</span><br></pre></td></tr></table></figure>

<p>例：查询省的名称为“山西省”的所有城市</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select city.* from areas as city</span><br><span class="line">inner join areas as province on city.pid=province.aid</span><br><span class="line">where province.atitle=&#x27;山西省&#x27;;</span><br></pre></td></tr></table></figure>

<p>例：查询市的名称为“广州市”的所有区县</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select dis.* from areas as dis</span><br><span class="line">inner join areas as city on city.aid=dis.pid</span><br><span class="line">where city.atitle=&#x27;广州市&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询</p>
<blockquote>
<p>在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为子查询语句。</p>
</blockquote>
<p>主查询</p>
<blockquote>
<p>主要查询的对象,第一条 select 语句</p>
</blockquote>
<p>主查询和子查询的关系</p>
<ul>
<li>子查询是嵌入到主查询中</li>
<li>子查询是辅助主查询的,要么充当条件,要么充当数据源</li>
<li>子查询是可以独立存在的语句,是一条完整的 select 语句</li>
</ul>
<p>子查询分类</p>
<ul>
<li>标量子查询: 子查询返回的结果是一个数据(一行一列)</li>
<li>列子查询: 返回的结果是一列(一列多行)</li>
<li>行子查询: 返回的结果是一行(一行多列)</li>
</ul>
<p>标量子查询 - 查询班级学生的平均身高</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where age &gt; (select avg(age) from students);</span><br></pre></td></tr></table></figure>

<p>列级子查询 - 查询还有学生在班的所有班级名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name from classes where id in (select cls_id from students);</span><br></pre></td></tr></table></figure>

<p>行级子查询 - 查找班级年龄最大,身高最高的学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where (height,age) = (select max(height),max(age) from students);</span><br></pre></td></tr></table></figure>

<p>子查询中特定关键字使用</p>
<ul>
<li>in 范围<ul>
<li>格式: 主查询 where 条件 in (列子查询)</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>查询的完整格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT select_expr [,select_expr,...] [</span><br><span class="line">      FROM tb_name</span><br><span class="line">      [WHERE 条件判断]</span><br><span class="line">      [GROUP BY &#123;col_name | postion&#125; [ASC | DESC], ...]</span><br><span class="line">      [HAVING WHERE 条件判断]</span><br><span class="line">      [ORDER BY &#123;col_name|expr|postion&#125; [ASC | DESC], ...]</span><br><span class="line">      [ LIMIT &#123;[offset,]rowcount | row_count OFFSET offset&#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>完整的 select 语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct *</span><br><span class="line">from 表名</span><br><span class="line">where ....</span><br><span class="line">group by ... having ...</span><br><span class="line">order by ...</span><br><span class="line">limit start,count</span><br></pre></td></tr></table></figure>

<h1 id="MySql-高级"><a href="#MySql-高级" class="headerlink" title="MySql 高级"></a>MySql 高级</h1><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="视图是什么"><a href="#视图是什么" class="headerlink" title="视图是什么"></a>视图是什么</h3><p>通俗的讲，视图就是一条 SELECT 语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条 SQL 查询语句上。</p>
<p>视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；</p>
<p>方便操作，特别是查询操作，减少复杂的 SQL 语句，增强可读性；</p>
<h3 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create view 视图名称 as select语句;</span><br></pre></td></tr></table></figure>

<h3 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h3><p>查看表会将所有的视图也列出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>

<h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><p>视图的用途就是查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from v_stu_score;</span><br></pre></td></tr></table></figure>

<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop view 视图名称;</span><br><span class="line">例：</span><br><span class="line">drop view v_stu_sco;</span><br></pre></td></tr></table></figure>

<h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><ul>
<li>提高了重用性，就像一个函数</li>
<li>对数据库重构，却不影响程序的运行</li>
<li>提高了安全性能，可以对不同的用户</li>
<li>让数据更加清晰</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>所谓事务,它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。</p>
<h3 id="事务四大特性-简称-ACID"><a href="#事务四大特性-简称-ACID" class="headerlink" title="事务四大特性(简称 ACID)"></a>事务四大特性(简称 ACID)</h3><h4 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h4><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性.</p>
<h4 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h4><p>数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，支票账户中也不会损失 200 美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）</p>
<h4 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性(Isolation)"></a>隔离性(Isolation)</h4><p>通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去 200 美元。）</p>
<h4 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h4><p>一旦事务提交，则其所做的修改会永久保存到数据库。（此时即使系统崩溃，修改的数据也不会丢失。）</p>
<h3 id="事务命令"><a href="#事务命令" class="headerlink" title="事务命令"></a>事务命令</h3><p>表的引擎类型必须是 innodb 类型才可以使用事务，这是 mysql 表的默认引擎</p>
<p>查看表的创建语句，可以看到 engine&#x3D;innodb</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 选择数据库</span><br><span class="line">use jing_dong;</span><br><span class="line">-- 查看goods表</span><br><span class="line">show create table goods;</span><br></pre></td></tr></table></figure>

<p>开启事务，命令如下：</p>
<p>开启事务后执行修改命令，变更会维护到本地缓存中，而不维护到物理表中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">或者</span><br><span class="line">start transaction;</span><br></pre></td></tr></table></figure>

<p>提交事务，命令如下</p>
<p>将缓存中的数据变更维护到物理表中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>回滚事务，命令如下：</p>
<p>放弃缓存中变更的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rollback;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<ul>
<li>修改数据的命令会自动的触发事务，包括 insert、update、delete</li>
<li>而在 SQL 语句中有手动开启事务的原因是：可以进行多次数据的修改，如果成功一起成功，否则一起会滚到之前的数据</li>
</ul>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>为了演示效果，需要打开两个终端窗口，使用同一个数据库，操作同一张表</p>
<p>step1：连接</p>
<p>终端 1：查询商品分类信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>

<p>step2：增加数据</p>
<p>终端 2：开启事务，插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into goods_cates(name) values(&#x27;小霸王游戏机&#x27;);</span><br></pre></td></tr></table></figure>

<p>终端 2：查询数据，此时有新增的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>

<p>step3：查询</p>
<p>终端 1：查询数据，发现并没有新增的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>

<p>step4：提交</p>
<p>终端 2：完成提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>step5：查询</p>
<p>终端 1：查询，发现有新增的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>

<h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><p>为了演示效果，需要打开两个终端窗口，使用同一个数据库，操作同一张表</p>
<p>step1：连接</p>
<p>终端 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>

<p>step2：增加数据</p>
<p>终端 2：开启事务，插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into goods_cates(name) values(&#x27;小霸王游戏机&#x27;);</span><br></pre></td></tr></table></figure>

<p>终端 2：查询数据，此时有新增的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>

<p>step3：查询</p>
<p>终端 1：查询数据，发现并没有新增的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>

<p>step4：回滚</p>
<p>终端 2：完成回滚</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rollback;</span><br></pre></td></tr></table></figure>

<p>step5：查询</p>
<p>终端 1：查询数据，发现没有新增的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>

<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h4><p>索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p>
<p>更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。</p>
<h4 id="索引目的"><a href="#索引目的" class="headerlink" title="索引目的"></a>索引目的</h4><p>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到 m 字母，然后从下往下找到 y 字母，再找到剩下的 sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到 m 开头的单词呢？或者 ze 开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p>
<h4 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h4><p>除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。</p>
<p>数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果 1000 条数据，1 到 100 分成第一段，101 到 200 分成第二段，201 到 300 分成第三段……这样查第 250 条数据，只要找第三段就可以了，一下子去除了 90%的无效数据。</p>
<h4 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h4><p>查看索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show index from 表名;</span><br></pre></td></tr></table></figure>

<p>创建索引</p>
<ul>
<li>如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致</li>
<li>字段类型如果不是字符串，可以不填写长度部分</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index 索引名称 on 表名(字段名称(长度))</span><br></pre></td></tr></table></figure>

<p>删除索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop index 索引名称 on 表名;</span><br></pre></td></tr></table></figure>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>创建测试表 testindex</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table test_index(title varchar(10));</span><br></pre></td></tr></table></figure>

<p>使用 python 程序通过 pymsql 模块 向表中加入十万条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pymysql import *</span><br><span class="line"></span><br><span class="line">def insert():</span><br><span class="line">    # 创建 Connection 连接</span><br><span class="line">    conn = connect(host=&quot;localhost&quot;, port=3306, database=&quot;jing_dong&quot;, user=&quot;ckcat&quot;, password=&quot;mysql&quot;, charset=&quot;utf8mb4&quot;)</span><br><span class="line">    # 获得 Cursor 对象</span><br><span class="line">    cs = conn.cursor()</span><br><span class="line"></span><br><span class="line">    # 插入10万次数据</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        cs.execute(&quot;insert into test_index values(&#x27;ha-%d&#x27;)&quot; % i)</span><br><span class="line">    # 提交数据</span><br><span class="line">    conn.commit()</span><br><span class="line"></span><br><span class="line">    # 关闭 cursor 对象 和 Connection 对象</span><br><span class="line">    cs.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    insert()</span><br></pre></td></tr></table></figure>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>开启运行时间监测：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set profiling=1;</span><br></pre></td></tr></table></figure>

<p>查找第 1 万条数据 ha-99999</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test_index where title=&#x27;ha-99999&#x27;;</span><br></pre></td></tr></table></figure>

<p>查看执行的时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show profiles;</span><br></pre></td></tr></table></figure>

<p>为表 title_index 的 title 列创建索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index title_index on test_index(title(10));</span><br></pre></td></tr></table></figure>

<p>执行查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test_index where title=&#x27;ha-99999&#x27;;</span><br></pre></td></tr></table></figure>

<p>再次查看执行的时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show profiles;</span><br></pre></td></tr></table></figure>

<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>要注意的是，建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件。对于一个经常需要更新和插入的表格，就没有必要为一个很少使用的 where 字句单独建立索引了，对于比较小的表，排序的开销不会很大，也没有必要建立另外的索引。</p>
<p>建立索引会占用磁盘空间</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核模块编程指南</title>
    <url>/2023/09/18/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>本文内容来自：<a href="https://sysprog21.github.io/lkmpg/">https://sysprog21.github.io/lkmpg/</a> ，使用 <a href="https://github.com/immersive-translate/immersive-translate">Immersive Translate</a> 进行翻译。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>The Linux Kernel Module Programming Guide is a free book; you may reproduce and&#x2F;or modify it under the terms of the <a href="https://opensource.org/licenses/OSL-3.0">Open Software License</a>, version 3.0.<br>《Linux 内核模块编程指南》是一本免费书籍；您可以根据<a href="https://opensource.org/licenses/OSL-3.0">开放软件许可证</a> 3.0 版的条款复制和&#x2F;或修改它。</p>
<p>This book is distributed in the hope that it would be useful, but without any warranty, without even the implied warranty of merchantability or fitness for a particular purpose.<br>分发本书的目的是希望它有用，但没有任何保证，甚至没有对适销性或针对特定用途的适用性的默示保证。</p>
<p>The author encourages wide distribution of this book for personal or commercial use, provided the above copyright notice remains intact and the method adheres to the provisions of the <a href="https://opensource.org/licenses/OSL-3.0">Open Software License</a>. In summary, you may copy and distribute this book free of charge or for a profit. No explicit permission is required from the author for reproduction of this book in any medium, physical or electronic.<br>作者鼓励将本书广泛分发用于个人或商业用途，前提是上述版权声明保持完整并且方法遵守<a href="https://opensource.org/licenses/OSL-3.0">开放软件许可证</a>的规定。总之，您可以免费或以营利为目的复制和分发本书。以任何物理或电子媒介复制本书无需获得作者的明确许可。</p>
<p>Derivative works and translations of this document must be placed under the <a href="https://opensource.org/licenses/OSL-3.0">Open Software License</a>, and the original copyright notice must remain intact. If you have contributed new material to this book, you must make the material and source code available for your revisions. Please make revisions and updates available directly to the document maintainer, Jim Huang <a href="mailto:&#x6a;&#115;&#101;&#114;&#x76;&#64;&#x63;&#99;&#110;&#x73;&#46;&#110;&#x63;&#107;&#117;&#x2e;&#101;&#x64;&#117;&#46;&#116;&#x77;">&#x6a;&#115;&#101;&#114;&#x76;&#64;&#x63;&#99;&#110;&#x73;&#46;&#110;&#x63;&#107;&#117;&#x2e;&#101;&#x64;&#117;&#46;&#116;&#x77;</a>. This will allow for the merging of updates and provide consistent revisions to the Linux community.<br>本文档的衍生作品和翻译必须置于<a href="https://opensource.org/licenses/OSL-3.0">开放软件许可证</a>之下，并且原始版权声明必须保持完整。如果您为本书贡献了新材料，则必须提供这些材料和源代码以供修订。请直接向文档维护者 Jim Huang 提供修订和更新。这将允许合并更新并为 Linux 社区提供一致的修订。</p>
<p>If you publish or distribute this book commercially, donations, royalties, and&#x2F;or printed copies are greatly appreciated by the author and the <a href="https://tldp.org/">Linux Documentation Project</a> (LDP). Contributing in this way shows your support for free software and the LDP. If you have questions or comments, please contact the address above.<br>如果您以商业方式出版或分发本书，作者和 <a href="https://tldp.org/">Linux 文档项目</a> (LDP) 将非常感谢您的捐赠、版税和&#x2F;或印刷版。以这种方式做出贡献表明您对自由软件和自民党的支持。如果您有疑问或意见，请联系上述地址。</p>
<h4 id="Authorship-作者身份"><a href="#Authorship-作者身份" class="headerlink" title="Authorship 作者身份"></a>Authorship 作者身份</h4><p>The Linux Kernel Module Programming Guide was initially authored by Ori Pomerantz for Linux v2.2. As the Linux kernel evolved, Ori’s availability to maintain the document diminished. Consequently, Peter Jay Salzman assumed the role of maintainer and updated the guide for Linux v2.4. Similar constraints arose for Peter when tracking developments in Linux v2.6, leading to Michael Burian joining as a co-maintainer to bring the guide up to speed with Linux v2.6. Bob Mottram contributed to the guide by updating examples for Linux v3.8 and later. Jim Huang then undertook the task of updating the guide for recent Linux versions (v5.0 and beyond), along with revising the LaTeX document.<br>Linux 内核模块编程指南最初由 Ori Pomerantz 针对 Linux v2.2 编写。随着 Linux 内核的发展，Ori 维护文档的可用性逐渐减弱。因此，Peter Jay Salzman 承担了维护者的角色并更新了 Linux v2.4 的指南。 Peter 在跟踪 Linux v2.6 的开发时也遇到了类似的限制，导致 Michael Burian 作为共同维护者加入，以加快该指南与 Linux v2.6 的速度。 Bob Mottram 通过更新 Linux v3.8 及更高版本的示例为本指南做出了贡献。 Jim Huang 随后承担了更新最新 Linux 版本（v5.0 及更高版本）指南以及修订 LaTeX 文档的任务。</p>
<h4 id="Acknowledgements-致谢"><a href="#Acknowledgements-致谢" class="headerlink" title="Acknowledgements 致谢"></a>Acknowledgements 致谢</h4><p>The following people have contributed corrections or good suggestions:<br>以下人员提供了更正或好的建议：</p>
<p>Andy Shevchenko, Arush Sharma, Benno Bielmeier, Bob Lee, Brad Baker, Che-Chia Chang, Chih-En Lin, Chih-Hsuan Yang, Chih-Yu Chen, Ching-Hua (Vivian) Lin, Chin Yik Ming, Cyril Brulebois, Daniele Paolo Scarpazza, David Porter, demonsome, Dimo Velev, Ekang Monyet, Ethan Chan, fennecJ, Francois Audeon, Gilad Reti, Horst Schirmeier, Hsin-Hsiang Peng, Ignacio Martin, Iûnn Kiàn-îng, Jian-Xing Wu, Johan Calle, keytouch, Kohei Otsuka, manbing, Marconi Jiang, mengxinayan, Peter Lin, Roman Lakeev, Sam Erickson, Shao-Tse Hung, Stacy Prowell, Steven Lung, Tristan Lelong, Tse-Wei Lin, Tucker Polomik, Tyler Fanelli, VxTeemo, Wei-Lun Tsai, Xatierlike Lee, Yin-Chiuan Chen, Yi-Wei Lin, Ylowy, Yu-Hsiang Tseng.</p>
<h4 id="What-Is-A-Kernel-Module-什么是内核模块？"><a href="#What-Is-A-Kernel-Module-什么是内核模块？" class="headerlink" title="What Is A Kernel Module? 什么是内核模块？"></a>What Is A Kernel Module? 什么是内核模块？</h4><p>Involvement in the development of Linux kernel modules requires a foundation in the C programming language and a track record of creating conventional programs intended for process execution. This pursuit delves into a domain where an unregulated pointer, if disregarded, may potentially trigger the total elimination of an entire file system, resulting in a scenario that necessitates a complete system reboot.<br>参与 Linux 内核模块的开发需要具备 C 编程语言基础以及创建用于进程执行的传统程序的记录。这种追求深入研究了一个领域，其中不受监管的指针如果被忽视，可能会触发整个文件系统的彻底消除，从而导致需要完全重新启动系统的情况。</p>
<p>A Linux kernel module is precisely defined as a code segment capable of dynamic loading and unloading within the kernel as needed. These modules enhance kernel capabilities without necessitating a system reboot. A notable example is seen in the device driver module, which facilitates kernel interaction with hardware components linked to the system. In the absence of modules, the prevailing approach leans toward monolithic kernels, requiring direct integration of new functionalities into the kernel image. This approach leads to larger kernels and necessitates kernel rebuilding and subsequent system rebooting when new functionalities are desired.<br>Linux 内核模块被精确地定义为能够根据需要在内核内动态加载和卸载的代码段。这些模块增强了内核功能，而无需重新启动系统。一个值得注意的例子是设备驱动程序模块，它促进内核与链接到系统的硬件组件的交互。在没有模块的情况下，流行的方法倾向于整体内核，需要将新功能直接集成到内核映像中。这种方法会导致内核更大，并且在需要新功能时需要重建内核并随后重新启动系统。</p>
<h4 id="Kernel-module-package"><a href="#Kernel-module-package" class="headerlink" title="Kernel module package"></a>Kernel module package</h4><p>1.4 内核模块包</p>
<p>Linux distributions provide the commands modprobe , insmod and depmod within a package.<br>Linux 发行版在包中提供了命令 modprobe 、 insmod 和 depmod 。</p>
<p>On Ubuntu&#x2F;Debian GNU&#x2F;Linux:<br>在 Ubuntu&#x2F;Debian GNU&#x2F;Linux 上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential kmod</span><br></pre></td></tr></table></figure>

<p>On Arch Linux:<br>在 Arch Linux 上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S gcc kmod</span><br></pre></td></tr></table></figure>

<h4 id="What-Modules-are-in-my-Kernel-我的内核中有哪些模块？"><a href="#What-Modules-are-in-my-Kernel-我的内核中有哪些模块？" class="headerlink" title="What Modules are in my Kernel? 我的内核中有哪些模块？"></a>What Modules are in my Kernel? 我的内核中有哪些模块？</h4><p>To discover what modules are already loaded within your current kernel use the command lsmod .<br>要发现当前内核中已加载哪些模块，请使用命令 lsmod 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo lsmod</span><br></pre></td></tr></table></figure>

<p>Modules are stored within the file <code>/proc/modules</code>, so you can also see them with:<br>模块存储在文件 <code>/proc/modules</code> 中，因此您还可以使用以下命令查看它们：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cat</span> /proc/modules</span><br></pre></td></tr></table></figure>

<p>This can be a long list, and you might prefer to search for something particular. To search for the fat module:<br>这可能是一个很长的列表，您可能更喜欢搜索特定的内容。搜索 fat 模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo lsmod | grep fat</span><br></pre></td></tr></table></figure>

<h4 id="Is-there-a-need-to-download-and-compile-the-kernel-是否需要下载编译内核？"><a href="#Is-there-a-need-to-download-and-compile-the-kernel-是否需要下载编译内核？" class="headerlink" title="Is there a need to download and compile the kernel? 是否需要下载编译内核？"></a>Is there a need to download and compile the kernel? 是否需要下载编译内核？</h4><p>To effectively follow this guide, there is no obligatory requirement for performing such actions. Nonetheless, a prudent approach involves executing the examples within a test distribution on a virtual machine, thus mitigating any potential risk of disrupting the system.<br>为了有效遵循本指南，执行此类操作没有强制性要求。尽管如此，谨慎的方法是在虚拟机上执行测试发行版中的示例，从而减轻破坏系统的任何潜在风险。</p>
<h4 id="Before-We-Begin-开始之前"><a href="#Before-We-Begin-开始之前" class="headerlink" title="Before We Begin 开始之前"></a>Before We Begin 开始之前</h4><p>Before delving into code, certain matters require attention. Variances exist among individuals’ systems, and distinct personal approaches are evident. The achievement of successful compilation and loading of the inaugural “hello world” program may, at times, present challenges. It is reassuring to note that overcoming the initial obstacle in the first attempt paves the way for subsequent endeavors to proceed seamlessly.<br>在深入研究代码之前，需要注意某些事项。个体系统之间存在差异，并且明显存在不同的个人方法。成功编译和加载首个“hello world”程序有时可能会带来挑战。令人欣慰的是，克服第一次尝试中最初的障碍将为后续努力的顺利进行铺平道路。</p>
<ol>
<li><p>Modversioning. A module compiled for one kernel will not load if a different kernel is booted, unless CONFIG_MODVERSIONS is enabled in the kernel. Module versioning will be discussed later in this guide. Until module versioning is covered, the examples in this guide may not work correctly if running a kernel with modversioning turned on. However, most stock Linux distribution kernels come with modversioning enabled. If difficulties arise when loading the modules due to versioning errors, consider compiling a kernel with modversioning turned off.<br>改装。如果启动不同的内核，则不会加载为一个内核编译的模块，除非在内核中启用了 CONFIG_MODVERSIONS 。本指南稍后将讨论模块版本控制。在介绍模块版本控制之前，如果在打开 modversioning 的情况下运行内核，本指南中的示例可能无法正常工作。然而，大多数现有的 Linux 发行版内核都启用了 modversioning。如果由于版本控制错误而在加载模块时出现困难，请考虑在关闭 modversioning 的情况下编译内核。</p>
</li>
<li><p>Using X Window System. It is highly recommended to extract, compile, and load all the examples discussed in this guide from a console. Working on these tasks within the X Window System is discouraged.<br>使用 X 窗口系统。强烈建议从控制台提取、编译和加载本指南中讨论的所有示例。不鼓励在 X Window 系统内执行这些任务。<br>Modules cannot directly print to the screen like printf() can, but they can log information and warnings that are eventually displayed on the screen, specifically within a console. If a module is loaded from an xterm , the information and warnings will be logged, but solely within the systemd journal. These logs will not be visible unless consulting the journalctl . Refer to 4 for more information. For instant access to this information, it is advisable to perform all tasks from the console.<br>模块无法像 printf() 那样直接打印到屏幕，但它们可以记录最终显示在屏幕上的信息和警告，特别是在控制台中。如果从 xterm 加载模块，则会记录信息和警告，但仅记录在 systemd 日志中。除非查阅 journalctl ，否则这些日志将不可见。请参阅 4 了解更多信息。为了即时访问此信息，建议从控制台执行所有任务。</p>
</li>
<li><p>SecureBoot. Numerous modern computers arrive pre-configured with UEFI SecureBoot enabled—an essential security standard ensuring booting exclusively through trusted software endorsed by the original equipment manufacturer. Certain Linux distributions even ship with the default Linux kernel configured to support SecureBoot. In these cases, the kernel module necessitates a signed security key.<br>安全启动。许多现代计算机都预先配置了 UEFI SecureBoot，这是一项重要的安全标准，可确保仅通过原始设备制造商认可的可信软件进行启动。某些 Linux 发行版甚至附带配置为支持 SecureBoot 的默认 Linux 内核。在这些情况下，内核模块需要一个签名的安全密钥。<br>Failing this, an attempt to insert your first “hello world” module would result in the message: “ERROR: could not insert module”. If this message Lockdown: insmod: unsigned module loading is restricted; see man kernel lockdown.7 appears in the dmesg output, the simplest approach involves disabling UEFI SecureBoot from the boot menu of your PC or laptop, allowing the successful insertion of ‘hello world” module. Naturally, an alternative involves undergoing intricate procedures such as generating keys, system key installation, and module signing to achieve functionality. However, this intricate process is less appropriate for beginners. If interested, more detailed steps for <a href="https://wiki.debian.org/SecureBoot">SecureBoot</a> can be explored and followed.<br>如果失败，尝试插入第一个“hello world”模块将导致消息：“错误：无法插入模块”。如果出现此消息 Lockdown：insmod：未签名的模块加载受到限制；看到 man kernellockdown.7 出现在 dmesg 输出中，最简单的方法是从 PC 或笔记本电脑的启动菜单中禁用 UEFI SecureBoot，从而允许成功插入“hello world”模块。当然，替代方案涉及经历复杂的过程，例如生成密钥、系统密钥安装和模块签名以实现功能。然而，这个复杂的过程不太适合初学者。如果有兴趣，可以探索并遵循更详细的 <a href="https://wiki.debian.org/SecureBoot">SecureBoot</a> 步骤。</p>
</li>
</ol>
<h3 id="Headers-头文件"><a href="#Headers-头文件" class="headerlink" title="Headers 头文件"></a>Headers 头文件</h3><p>Before you can build anything you’ll need to install the header files for your kernel.<br>在构建任何东西之前，您需要安装内核的头文件。</p>
<p>On Ubuntu&#x2F;Debian GNU&#x2F;Linux:<br>在 Ubuntu&#x2F;Debian GNU&#x2F;Linux 上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">apt-cache search linux-headers-`<span class="built_in">uname</span> -r`</span><br></pre></td></tr></table></figure>

<p>This will tell you what kernel header files are available. Then for example:<br>这将告诉您哪些内核头文件可用。那么例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install kmod linux-headers-5.4.0-80-generic</span><br></pre></td></tr></table></figure>

<p>On Arch Linux:<br>在 Arch Linux 上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S linux-headers</span><br></pre></td></tr></table></figure>

<p>On Fedora:<br>在 Fedora 上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dnf install kernel-devel kernel-headers</span><br></pre></td></tr></table></figure>

<h3 id="Examples-示例"><a href="#Examples-示例" class="headerlink" title="Examples 示例"></a>Examples 示例</h3><p>All the examples from this document are available within the examples subdirectory.<br>本文档中的所有示例都可以在示例子目录中找到。</p>
<p>If there are any compile errors then you might have a more recent kernel version or need to install the corresponding kernel header files.<br>如果存在任何编译错误，则您可能拥有更新的内核版本或需要安装相应的内核头文件。</p>
<h3 id="Hello-World-4-你好世界"><a href="#Hello-World-4-你好世界" class="headerlink" title="Hello World 4 你好世界"></a>Hello World 4 你好世界</h3><h4 id="The-Simplest-Module-最简单的模块"><a href="#The-Simplest-Module-最简单的模块" class="headerlink" title="The Simplest Module 最简单的模块"></a>The Simplest Module 最简单的模块</h4><p>Most people learning programming start out with some sort of “hello world” example. I don’t know what happens to people who break with this tradition, but I think it is safer not to find out. We will start with a series of hello world programs that demonstrate the different aspects of the basics of writing a kernel module.<br>大多数学习编程的人都是从某种“hello world”示例开始的。我不知道打破这一传统的人会发生什么，但我认为不去发现更安全。我们将从一系列 hello world 程序开始，这些程序演示了编写内核模块的基础知识的不同方面。</p>
<p>Here is the simplest module possible.<br>这是最简单的模块。</p>
<p>Make a test directory:<br>建立一个测试目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/develop/kernel/hello-1</span><br><span class="line"><span class="built_in">cd</span> ~/develop/kernel/hello-1</span><br></pre></td></tr></table></figure>

<p>Paste this into your favorite editor and save it as hello-1.c:<br>将其粘贴到您最喜欢的编辑器中并将其另存为 <code>hello-1.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hello-1.c - The simplest kernel module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span> <span class="comment">/* Needed for pr_info() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Hello world 1.\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* A non 0 return means init_module failed; module can&#x27;t be loaded. */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Goodbye world 1.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Now you will need a Makefile. If you copy and paste this, change the indentation to use tabs, not spaces.<br>现在您需要一个 Makefile。如果复制并粘贴此内容，请将缩进更改为使用制表符，而不是空格。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m += hello-1.o</span><br><span class="line"></span><br><span class="line">PWD := <span class="variable">$(CURDIR)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>In Makefile, <code>$(CURDIR)</code> can set to the absolute pathname of the current working directory(after all -C options are processed, if any). See more about CURDIR in GNU make manual.<br>在 Makefile 中，<code>$(CURDIR)</code>可以设置为当前工作目录的绝对路径名（在处理所有-C 选项之后，如果有的话）。有关 CURDIR 的更多信息，请参阅 GNU make 手册。</p>
<p>And finally, just run make directly.<br>最后，直接运行 make 即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>If there is no <code>PWD := $(CURDIR)</code> statement in Makefile, then it may not compile correctly with sudo make. Because some environment variables are specified by the security policy, they can’t be inherited. The default security policy is sudoers. In the sudoers security policy, env_reset is enabled by default, which restricts environment variables. Specifically, path variables are not retained from the user environment, they are set to default values (For more information see: <a href="https://www.sudo.ws/docs/man/sudoers.man/">sudoers manual</a>)). You can see the environment variable settings by:<br>如果 Makefile 中没有 <code>PWD := $(CURDIR)</code> 语句，则可能无法使用 <code>sudo make</code> 正确编译。由于某些环境变量是由安全策略指定的，因此无法继承。默认安全策略是 sudoers。在 sudoers 安全策略中，env_reset 默认是开启的，它限制了环境变量。具体来说，路径变量不会从用户环境中保留，而是设置为默认值（有关更多信息，请参阅：sudoers 手册）。您可以通过以下方式查看环境变量设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo -s</span><br><span class="line"><span class="comment"># sudo -V</span></span><br></pre></td></tr></table></figure>

<p>Here is a simple Makefile as an example to demonstrate the problem mentioned above.<br>这里以一个简单的 Makefile 为例来演示上述问题。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="variable">$(PWD)</span></span><br></pre></td></tr></table></figure>

<p>Then, we can use -p flag to print out the environment variable values from the Makefile.<br>然后，我们可以使用 -p 标志从 Makefile 中打印出环境变量值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make -p | grep PWD</span><br><span class="line">PWD = /home/ubuntu/temp</span><br><span class="line">OLDPWD = /home/ubuntu</span><br><span class="line">    <span class="built_in">echo</span> $(PWD)</span><br></pre></td></tr></table></figure>

<p>The PWD variable won’t be inherited with sudo.<br>PWD 变量不会被 sudo 继承。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo make -p | grep PWD</span><br><span class="line">    <span class="built_in">echo</span> $(PWD)</span><br></pre></td></tr></table></figure>

<p>However, there are three ways to solve this problem.<br>然而，有三种方法可以解决这个问题。</p>
<ol>
<li><p>You can use the -E flag to temporarily preserve them.<br>您可以使用 -E 标志暂时保留它们。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo -E make -p | grep PWD</span><br><span class="line"></span><br><span class="line">PWD = /home/ubuntu/temp</span><br><span class="line"></span><br><span class="line">OLDPWD = /home/ubuntu</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> $(PWD)</span><br></pre></td></tr></table></figure>
</li>
<li><p>You can set the env_reset disabled by editing the &#x2F;etc&#x2F;sudoers with root and visudo.<br>您可以通过使用 root 和 visudo 编辑 &#x2F;etc&#x2F;sudoers 来设置禁用 env_reset。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## sudoers file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Defaults env_reset</span><br><span class="line"></span><br><span class="line"><span class="comment">## Change env_reset to !env_reset in previous line to keep all environment variables</span></span><br></pre></td></tr></table></figure>

<p>Then execute env and sudo env individually.<br>然后分别执行 env 和 sudo env。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># disable the env_reset</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;user:&quot;</span> &gt; non-env_reset.log; <span class="built_in">env</span> &gt;&gt; non-env_reset.log</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;root:&quot;</span> &gt;&gt; non-env_reset.log; sudo <span class="built_in">env</span> &gt;&gt; non-env_reset.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable the env_reset</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;user:&quot;</span> &gt; env_reset.log; <span class="built_in">env</span> &gt;&gt; env_reset.log</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;root:&quot;</span> &gt;&gt; env_reset.log; sudo <span class="built_in">env</span> &gt;&gt; env_reset.log</span><br></pre></td></tr></table></figure>

<p>You can view and compare these logs to find differences between env_reset and !env_reset.<br>您可以查看并比较这些日志以查找 env_reset 和 !env_reset 之间的差异。</p>
</li>
<li><p>You can preserve environment variables by appending them to env_keep in &#x2F;etc&#x2F;sudoers.<br>您可以通过将环境变量附加到 &#x2F;etc&#x2F;sudoers 中的 env_keep 来保留环境变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Defaults env_keep += <span class="string">&quot;PWD&quot;</span></span><br></pre></td></tr></table></figure>

<p>After applying the above change, you can check the environment variable settings by:<br>应用上述更改后，您可以通过以下方式检查环境变量设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo -s</span><br><span class="line"><span class="comment"># sudo -V</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>If all goes smoothly you should then find that you have a compiled hello-1.ko module. You can find info on it with the command:<br>如果一切顺利，您应该会发现您已经编译了 hello-1.ko 模块。您可以使用以下命令找到有关它的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modinfo hello-1.ko</span><br></pre></td></tr></table></figure>

<p>At this point the command:<br>此时命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo lsmod | grep hello</span><br></pre></td></tr></table></figure>

<p>should return nothing. You can try loading your shiny new module with:<br>不应该返回任何内容。您可以尝试使用以下命令加载闪亮的新模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo insmod hello-1.ko</span><br></pre></td></tr></table></figure>

<p>The dash character will get converted to an underscore, so when you again try:<br>破折号字符将转换为下划线，因此当您再次尝试时：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo lsmod | grep hello</span><br></pre></td></tr></table></figure>

<p>You should now see your loaded module. It can be removed again with:<br>您现在应该看到已加载的模块。可以使用以下方法再次将其删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rmmod hello_1</span><br></pre></td></tr></table></figure>

<p>Notice that the dash was replaced by an underscore. To see what just happened in the logs:<br>请注意，破折号已替换为下划线。要查看日志中刚刚发生的情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo journalctl --since <span class="string">&quot;1 hour ago&quot;</span> | grep kernel</span><br></pre></td></tr></table></figure>

<p>You now know the basics of creating, compiling, installing and removing modules. Now for more of a description of how this module works.<br>您现在已经了解了创建、编译、安装和删除模块的基础知识。现在更多地描述该模块如何工作。</p>
<p>Kernel modules must have at least two functions: a “start” (initialization) function called <code>init_module()</code> which is called when the module is <code>insmod</code> ed into the kernel, and an “end” (cleanup) function called <code>cleanup_module()</code> which is called just before it is removed from the kernel. Actually, things have changed starting with kernel 2.3.13. You can now use whatever name you like for the start and end functions of a module, and you will learn how to do this in Section <a href="https://sysprog21.github.io/lkmpg/#hello-and-goodbye">4.2</a>. In fact, the new method is the preferred method. However, many people still use <code>init_module()</code> and <code>cleanup_module()</code> for their start and end functions.<br>内核模块必须至少有两个函数：一个名为 <code>init_module()</code> 的“启动”（初始化）函数，当模块 <code>insmod</code> 插入内核时调用该函数，以及一个“结束”（ cleanup) 函数称为 <code>cleanup_module()</code> ，该函数在从内核中删除之前被调用。实际上，从内核 2.3.13 开始，情况发生了变化。现在，您可以为模块的开始和结束函数使用任何您喜欢的名称，您将在第 4.2 节中学习如何执行此操作。事实上，新方法是首选方法。然而，许多人仍然使用 <code>init_module()</code> 和 <code>cleanup_module()</code> 作为开始和结束函数。</p>
<p>Typically, <code>init_module()</code> either registers a handler for something with the kernel, or it replaces one of the kernel functions with its own code (usually code to do something and then call the original function). The <code>cleanup_module()</code> function is supposed to undo whatever <code>init_module()</code> did, so the module can be unloaded safely.<br>通常， <code>init_module()</code> 要么向内核注册某个处理程序，要么用自己的代码替换内核函数之一（通常是执行某些操作然后调用原始函数的代码）。 <code>cleanup_module()</code> 函数应该撤消 <code>init_module()</code> 所做的任何事情，因此可以安全地卸载模块。</p>
<p>Lastly, every kernel module needs to include &lt;linux&#x2F;module.h&gt;. We needed to include &lt;linux&#x2F;printk.h&gt; only for the macro expansion for the <code>pr_alert()</code> log level, which you’ll learn about in Section <a href="https://sysprog21.github.io/lkmpg/#x1-121662">2</a>.<br>最后，每个内核模块都需要包含 。我们只需要包含 来进行 <code>pr_alert()</code> 日志级别的宏扩展，您将在第 2 节中了解这一点。</p>
<ol>
<li><p>A point about coding style. Another thing which may not be immediately obvious to anyone getting started with kernel programming is that indentation within your code should be using tabs and not spaces. It is one of the coding conventions of the kernel. You may not like it, but you’ll need to get used to it if you ever submit a patch upstream.<br>关于编码风格的一点。对于任何开始内核编程的人来说，另一件事可能不会立即显而易见，那就是代码中的缩进应该使用制表符而不是空格。它是内核的编码约定之一。您可能不喜欢它，但如果您向上游提交补丁，则需要习惯它。</p>
</li>
<li><p>Introducing print macros. In the beginning there was <code>printk</code> , usually followed by a priority such as <code>KERN_INFO</code> or <code>KERN_DEBUG</code> . More recently this can also be expressed in abbreviated form using a set of print macros, such as <code>pr_info</code> and <code>pr_debug</code> . This just saves some mindless keyboard bashing and looks a bit neater. They can be found within <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/printk.h">include&#x2F;linux&#x2F;printk.h</a>. Take time to read through the available priority macros.<br>介绍打印宏。一开始有 <code>printk</code> ，通常后面跟着一个优先级，例如 <code>KERN_INFO</code> 或 <code>KERN_DEBUG</code> 。最近，这也可以使用一组打印宏以缩写形式表示，例如 <code>pr_info</code> 和 <code>pr_debug</code> 。这只是节省了一些无意识的键盘敲打，而且看起来更整洁一些。它们可以在 include&#x2F;linux&#x2F;printk.h 中找到。花时间阅读可用的优先级宏。</p>
</li>
<li><p>About Compiling. Kernel modules need to be compiled a bit differently from regular userspace apps. Former kernel versions required us to care much about these settings, which are usually stored in Makefiles. Although hierarchically organized, many redundant settings accumulated in sublevel Makefiles and made them large and rather difficult to maintain. Fortunately, there is a new way of doing these things, called kbuild, and the build process for external loadable modules is now fully integrated into the standard kernel build mechanism. To learn more on how to compile modules which are not part of the official kernel (such as all the examples you will find in this guide), see file <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/kbuild/modules.rst">Documentation&#x2F;kbuild&#x2F;modules.rst</a>.<br>关于编译。内核模块的编译方式与常规用户空间应用程序略有不同。以前的内核版本需要我们非常关心这些设置，这些设置通常存储在 Makefile 中。尽管是分层组织的，但许多冗余设置累积在子级 Makefile 中，导致它们变得庞大且难以维护。幸运的是，有一种新的方法可以完成这些事情，称为 kbuild，并且外部可加载模块的构建过程现在已完全集成到标准内核构建机制中。要了解有关如何编译不属于官方内核的模块的更多信息（例如您将在本指南中找到的所有示例），请参阅文件 Documentation&#x2F;kbuild&#x2F;modules.rst。</p>
<p>Additional details about Makefiles for kernel modules are available in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/kbuild/makefiles.rst">Documentation&#x2F;kbuild&#x2F;makefiles.rst</a>. Be sure to read this and the related files before starting to hack Makefiles. It will probably save you lots of work.<br>有关内核模块 Makefile 的更多详细信息，请参阅 Documentation&#x2F;kbuild&#x2F;makefiles.rst。在开始破解 Makefile 之前，请务必阅读本文和相关文件。它可能会为您节省大量工作。</p>
<blockquote>
<p>Here is another exercise for the reader. See that comment above the return statement in <code>init_module()</code> ? Change the return value to something negative, recompile and load the module again. What happens?<br>这是给读者的另一个练习。看到 <code>init_module()</code> 中 return 语句上方的注释了吗？将返回值更改为负值，重新编译并再次加载模块。会发生什么？</p>
</blockquote>
</li>
</ol>
<h4 id="4-2-Hello-and-Goodbye-4-2-你好和再见"><a href="#4-2-Hello-and-Goodbye-4-2-你好和再见" class="headerlink" title="4.2 Hello and Goodbye 4.2 你好和再见"></a>4.2 Hello and Goodbye 4.2 你好和再见</h4><p>In early kernel versions you had to use the <code>init_module</code> and <code>cleanup_module</code> functions, as in the first hello world example, but these days you can name those anything you want by using the <code>module_init</code> and <code>module_exit</code> macros. These macros are defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/module.h">include&#x2F;linux&#x2F;module.h</a>. The only requirement is that your init and cleanup functions must be defined before calling the those macros, otherwise you’ll get compilation errors. Here is an example of this technique:<br>在早期的内核版本中，您必须使用 <code>init_module</code> 和 <code>cleanup_module</code> 函数，如第一个 hello world 示例中所示，但现在您可以使用 <code>module_init</code> 和 <code>module_exit</code> 宏。这些宏在 include&#x2F;linux&#x2F;module.h 中定义。唯一的要求是你的 init 和 cleanup 函数必须在调用这些宏之前定义，否则你会得到编译错误。下面是该技术的一个示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hello-2.c - Demonstrating the module_init() and module_exit() macros.</span></span><br><span class="line"><span class="comment"> * This is preferred over using init_module() and cleanup_module().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> <span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span> <span class="comment">/* Needed for pr_info() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_2_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Hello, world 2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_2_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Goodbye, world 2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_2_init);</span><br><span class="line">module_exit(hello_2_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>So now we have two real kernel modules under our belt. Adding another module is as simple as this:<br>现在我们有了两个真正的内核模块。添加另一个模块就像这样简单：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m += hello-1.o</span><br><span class="line">obj-m += hello-2.o</span><br><span class="line"></span><br><span class="line">PWD := <span class="variable">$(CURDIR)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>Now have a look at <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/drivers/char/Makefile">drivers&#x2F;char&#x2F;Makefile</a> for a real world example. As you can see, some things got hardwired into the kernel (obj-y) but where have all those obj-m gone? Those familiar with shell scripts will easily be able to spot them. For those who are not, the obj-$(CONFIG_FOO) entries you see everywhere expand into obj-y or obj-m, depending on whether the CONFIG_FOO variable has been set to y or m. While we are at it, those were exactly the kind of variables that you have set in the .config file in the top-level directory of Linux kernel source tree, the last time when you said <code>make menuconfig</code> or something like that.<br>现在看一下 drivers&#x2F;char&#x2F;Makefile 的真实示例。正如您所看到的，有些东西被硬连线到内核（obj-y）中，但是所有这些 obj-m 到哪里去了？熟悉 shell 脚本的人很容易就能发现它们。对于那些不这样做的人，您随处看到的 obj-$(CONFIG_FOO) 条目会扩展为 obj-y 或 obj-m，具体取决于 CONFIG_FOO 变量是否设置为 y 还是 m。当我们这样做时，这些正是您在 Linux 内核源代码树顶级目录的 .config 文件中设置的变量类型，上次您说 <code>make menuconfig</code> 或类似的内容时那。</p>
<h4 id="4-3-The-init-and-exit-Macros"><a href="#4-3-The-init-and-exit-Macros" class="headerlink" title="4.3 The **init and **exit Macros"></a>4.3 The **init and **exit Macros</h4><p>4.3 **init 和 **exit 宏</p>
<p>The <code>__init</code> macro causes the init function to be discarded and its memory freed once the init function finishes for built-in drivers, but not loadable modules. If you think about when the init function is invoked, this makes perfect sense.<br>一旦内置驱动程序（但不是可加载模块）的 init 函数完成， <code>__init</code> 宏会导致 init 函数被丢弃并释放其内存。如果您考虑一下 init 函数何时被调用，这就很有意义了。</p>
<p>There is also an <code>__initdata</code> which works similarly to <code>__init</code> but for init variables rather than functions.<br>还有一个 <code>__initdata</code> ，其工作方式与 <code>__init</code> 类似，但用于初始化变量而不是函数。</p>
<p>The <code>__exit</code> macro causes the omission of the function when the module is built into the kernel, and like <code>__init</code> , has no effect for loadable modules. Again, if you consider when the cleanup function runs, this makes complete sense; built-in drivers do not need a cleanup function, while loadable modules do.<br>当模块内置到内核中时， <code>__exit</code> 宏会导致函数的省略，并且与 <code>__init</code> 一样，对于可加载模块没有影响。同样，如果您考虑清理函数何时运行，这是完全有道理的；内置驱动程序不需要清理功能，而可加载模块则需要。</p>
<p>These macros are defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/init.h">include&#x2F;linux&#x2F;init.h</a> and serve to free up kernel memory. When you boot your kernel and see something like Freeing unused kernel memory: 236k freed, this is precisely what the kernel is freeing.<br>这些宏在 include&#x2F;linux&#x2F;init.h 中定义，用于释放内核内存。当您启动内核并看到类似“释放未使用的内核内存：已释放 236k”之类的内容时，这正是内核正在释放的内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hello-3.c - Illustrating the __init, __initdata and __exit macros.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> <span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span> <span class="comment">/* Needed for pr_info() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hello3_data __initdata = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_3_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Hello, world %d\n&quot;</span>, hello3_data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_3_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Goodbye, world 3\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_3_init);</span><br><span class="line">module_exit(hello_3_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="4-4-Licensing-and-Module-Documentation"><a href="#4-4-Licensing-and-Module-Documentation" class="headerlink" title="4.4 Licensing and Module Documentation"></a>4.4 Licensing and Module Documentation</h4><p>4.4 许可和模块文档</p>
<p>Honestly, who loads or even cares about proprietary modules? If you do then you might have seen something like this:<br>老实说，谁加载甚至关心专有模块？如果您这样做，那么您可能会看到类似这样的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo insmod xxxxxx.ko</span><br><span class="line">loading out-of-tree module taints kernel.</span><br><span class="line">module license <span class="string">&#x27;unspecified&#x27;</span> taints kernel.</span><br></pre></td></tr></table></figure>

<p>You can use a few macros to indicate the license for your module. Some examples are “GPL”, “GPL v2”, “GPL and additional rights”, “Dual BSD&#x2F;GPL”, “Dual MIT&#x2F;GPL”, “Dual MPL&#x2F;GPL” and “Proprietary”. They are defined within <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/module.h">include&#x2F;linux&#x2F;module.h</a>.<br>您可以使用一些宏来指示模块的许可证。一些示例包括“GPL”、“GPL v2”、“GPL 和附加权利”、“双 BSD&#x2F;GPL”、“双 MIT&#x2F;GPL”、“双 MPL&#x2F;GPL”和“专有”。它们在 include&#x2F;linux&#x2F;module.h 中定义。</p>
<p>To reference what license you’re using a macro is available called <code>MODULE_LICENSE</code> . This and a few other macros describing the module are illustrated in the below example.<br>要引用您正在使用的许可证，可以使用名为 <code>MODULE_LICENSE</code> 的宏。下面的示例说明了这个宏和描述该模块的其他一些宏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hello-4.c - Demonstrates module documentation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span> <span class="comment">/* Needed for the macros */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Needed by all modules */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span> <span class="comment">/* Needed for pr_info() */</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;LKMPG&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A sample driver&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_hello_4</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Hello, world 4\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">cleanup_hello_4</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Goodbye, world 4\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(init_hello_4);</span><br><span class="line">module_exit(cleanup_hello_4);</span><br></pre></td></tr></table></figure>

<h4 id="4-5-Passing-Command-Line-Arguments-to-a-Module"><a href="#4-5-Passing-Command-Line-Arguments-to-a-Module" class="headerlink" title="4.5 Passing Command Line Arguments to a Module"></a>4.5 Passing Command Line Arguments to a Module</h4><p>4.5 将命令行参数传递给模块</p>
<p>Modules can take command line arguments, but not with the argc&#x2F;argv you might be used to.<br>模块可以接受命令行参数，但不能使用您可能习惯的 argc&#x2F;argv。</p>
<p>To allow arguments to be passed to your module, declare the variables that will take the values of the command line arguments as global and then use the <code>module_param()</code> macro, (defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/moduleparam.h">include&#x2F;linux&#x2F;moduleparam.h</a>) to set the mechanism up. At runtime, <code>insmod</code> will fill the variables with any command line arguments that are given, like <code>insmod mymodule.ko myvariable=5</code> . The variable declarations and macros should be placed at the beginning of the module for clarity. The example code should clear up my admittedly lousy explanation.<br>要允许将参数传递到模块，请声明将命令行参数的值作为全局变量，然后使用 <code>module_param()</code> 宏（在 include&#x2F;linux&#x2F;moduleparam.h 中定义）来建立机制。在运行时， <code>insmod</code> 将使用给定的任何命令行参数填充变量，例如 <code>insmod mymodule.ko myvariable=5</code> 。为了清晰起见，变量声明和宏应放置在模块的开头。示例代码应该可以澄清我公认的糟糕的解释。</p>
<p>The <code>module_param()</code> macro takes 3 arguments: the name of the variable, its type and permissions for the corresponding file in sysfs. Integer types can be signed as usual or unsigned. If you’d like to use arrays of integers or strings see <code>module_param_array()</code> and <code>module_param_string()</code> .<br><code>module_param()</code> 宏有 3 个参数：变量的名称、变量的类型以及 sysfs 中相应文件的权限。整数类型可以照常带符号或不带符号。如果您想使用整数或字符串数组，请参阅 <code>module_param_array()</code> 和 <code>module_param_string()</code> 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> myint = <span class="number">3</span>;</span><br><span class="line">module_param(myint, <span class="type">int</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>Arrays are supported too, but things are a bit different now than they were in the olden days. To keep track of the number of parameters you need to pass a pointer to a count variable as third parameter. At your option, you could also ignore the count and pass <code>NULL</code> instead. We show both possibilities here:<br>数组也受支持，但现在的情况与以前有些不同。要跟踪参数的数量，您需要将指向计数变量的指针作为第三个参数传递。您也可以选择忽略计数并传递 <code>NULL</code> 。我们在这里展示了两种可能性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> myintarray[<span class="number">2</span>];</span><br><span class="line">module_param_array(myintarray, <span class="type">int</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">/* not interested in count */</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> myshortarray[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line">module_param_array(myshortarray, <span class="type">short</span>, &amp;count, <span class="number">0</span>); <span class="comment">/* put count into &quot;count&quot; variable */</span></span><br></pre></td></tr></table></figure>

<p>A good use for this is to have the module variable’s default values set, like a port or IO address. If the variables contain the default values, then perform autodetection (explained elsewhere). Otherwise, keep the current value. This will be made clear later on.<br>一个很好的用途是设置模块变量的默认值，例如端口或 IO 地址。如果变量包含默认值，则执行自动检测（在其他地方解释）。否则，保持当前值。这一点稍后会明确。</p>
<p>Lastly, there is a macro function, <code>MODULE_PARM_DESC()</code> , that is used to document arguments that the module can take. It takes two parameters: a variable name and a free form string describing that variable.<br>最后，有一个宏函数 <code>MODULE_PARM_DESC()</code> ，用于记录模块可以采用的参数。它需要两个参数：变量名称和描述该变量的自由格式字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hello-5.c - Demonstrates command line argument passing to a module.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">/* for ARRAY_SIZE() */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">short</span> <span class="type">int</span> myshort = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myint = <span class="number">420</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">int</span> mylong = <span class="number">9999</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mystring = <span class="string">&quot;blah&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myintarray[<span class="number">2</span>] = &#123; <span class="number">420</span>, <span class="number">420</span> &#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> arr_argc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* module_param(foo, int, 0000)</span></span><br><span class="line"><span class="comment"> * The first param is the parameters name.</span></span><br><span class="line"><span class="comment"> * The second param is its data type.</span></span><br><span class="line"><span class="comment"> * The final argument is the permissions bits,</span></span><br><span class="line"><span class="comment"> * for exposing parameters in sysfs (if non-zero) at a later stage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">module_param(myshort, <span class="type">short</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);</span><br><span class="line">MODULE_PARM_DESC(myshort, <span class="string">&quot;A short integer&quot;</span>);</span><br><span class="line">module_param(myint, <span class="type">int</span>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line">MODULE_PARM_DESC(myint, <span class="string">&quot;An integer&quot;</span>);</span><br><span class="line">module_param(mylong, <span class="type">long</span>, S_IRUSR);</span><br><span class="line">MODULE_PARM_DESC(mylong, <span class="string">&quot;A long integer&quot;</span>);</span><br><span class="line">module_param(mystring, charp, <span class="number">0000</span>);</span><br><span class="line">MODULE_PARM_DESC(mystring, <span class="string">&quot;A character string&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* module_param_array(name, type, num, perm);</span></span><br><span class="line"><span class="comment"> * The first param is the parameter&#x27;s (in this case the array&#x27;s) name.</span></span><br><span class="line"><span class="comment"> * The second param is the data type of the elements of the array.</span></span><br><span class="line"><span class="comment"> * The third argument is a pointer to the variable that will store the number</span></span><br><span class="line"><span class="comment"> * of elements of the array initialized by the user at module loading time.</span></span><br><span class="line"><span class="comment"> * The fourth argument is the permission bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">module_param_array(myintarray, <span class="type">int</span>, &amp;arr_argc, <span class="number">0000</span>);</span><br><span class="line">MODULE_PARM_DESC(myintarray, <span class="string">&quot;An array of integers&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_5_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Hello, world 5\n=============\n&quot;</span>);</span><br><span class="line">    pr_info(<span class="string">&quot;myshort is a short integer: %hd\n&quot;</span>, myshort);</span><br><span class="line">    pr_info(<span class="string">&quot;myint is an integer: %d\n&quot;</span>, myint);</span><br><span class="line">    pr_info(<span class="string">&quot;mylong is a long integer: %ld\n&quot;</span>, mylong);</span><br><span class="line">    pr_info(<span class="string">&quot;mystring is a string: %s\n&quot;</span>, mystring);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(myintarray); i++)</span><br><span class="line">        pr_info(<span class="string">&quot;myintarray[%d] = %d\n&quot;</span>, i, myintarray[i]);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;got %d arguments for myintarray.\n&quot;</span>, arr_argc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_5_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Goodbye, world 5\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_5_init);</span><br><span class="line">module_exit(hello_5_exit);</span><br></pre></td></tr></table></figure>

<p>I would recommend playing around with this code:<br>我建议使用以下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo insmod hello-5.ko mystring=<span class="string">&quot;bebop&quot;</span> myintarray=-1</span><br><span class="line">$ sudo dmesg -t | <span class="built_in">tail</span> -7</span><br><span class="line">myshort is a short <span class="built_in">integer</span>: 1</span><br><span class="line">myint is an <span class="built_in">integer</span>: 420</span><br><span class="line">mylong is a long <span class="built_in">integer</span>: 9999</span><br><span class="line">mystring is a string: bebop</span><br><span class="line">myintarray[0] = -1</span><br><span class="line">myintarray[1] = 420</span><br><span class="line">got 1 arguments <span class="keyword">for</span> myintarray.</span><br><span class="line"></span><br><span class="line">$ sudo rmmod hello-5</span><br><span class="line">$ sudo dmesg -t | <span class="built_in">tail</span> -1</span><br><span class="line">Goodbye, world 5</span><br><span class="line"></span><br><span class="line">$ sudo insmod hello-5.ko mystring=<span class="string">&quot;supercalifragilisticexpialidocious&quot;</span> myintarray=-1,-1</span><br><span class="line">$ sudo dmesg -t | <span class="built_in">tail</span> -7</span><br><span class="line">myshort is a short <span class="built_in">integer</span>: 1</span><br><span class="line">myint is an <span class="built_in">integer</span>: 420</span><br><span class="line">mylong is a long <span class="built_in">integer</span>: 9999</span><br><span class="line">mystring is a string: supercalifragilisticexpialidocious</span><br><span class="line">myintarray[0] = -1</span><br><span class="line">myintarray[1] = -1</span><br><span class="line">got 2 arguments <span class="keyword">for</span> myintarray.</span><br><span class="line"></span><br><span class="line">$ sudo rmmod hello-5</span><br><span class="line">$ sudo dmesg -t | <span class="built_in">tail</span> -1</span><br><span class="line">Goodbye, world 5</span><br><span class="line"></span><br><span class="line">$ sudo insmod hello-5.ko mylong=hello</span><br><span class="line">insmod: ERROR: could not insert module hello-5.ko: Invalid parameters</span><br></pre></td></tr></table></figure>

<h4 id="4-6-Modules-Spanning-Multiple-Files"><a href="#4-6-Modules-Spanning-Multiple-Files" class="headerlink" title="4.6 Modules Spanning Multiple Files"></a>4.6 Modules Spanning Multiple Files</h4><p>4.6 跨多个文件的模块</p>
<p>Sometimes it makes sense to divide a kernel module between several source files.<br>有时，将内核模块划分为多个源文件是有意义的。</p>
<p>Here is an example of such a kernel module.<br>这是此类内核模块的示例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * start.c - Illustration of multi filed modules</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">/* We are doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Hello, world - this is the kernel speaking\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>The next file:<br>下一个文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stop.c - Illustration of multi filed modules</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">/* We are doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Specifically, a module  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Short is the life of a kernel module\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>And finally, the makefile:<br>最后是 makefile：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-m += hello-1.o</span><br><span class="line">obj-m += hello-2.o</span><br><span class="line">obj-m += hello-3.o</span><br><span class="line">obj-m += hello-4.o</span><br><span class="line">obj-m += hello-5.o</span><br><span class="line">obj-m += startstop.o</span><br><span class="line">startstop-objs := start.o stop.o</span><br><span class="line"></span><br><span class="line">PWD := <span class="variable">$(CURDIR)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>This is the complete makefile for all the examples we have seen so far. The first five lines are nothing special, but for the last example we will need two lines. First we invent an object name for our combined module, second we tell <code>make</code> what object files are part of that module.<br>这是迄今为止我们看到的所有示例的完整 makefile。前五行没什么特别的，但对于最后一个例子，我们需要两行。首先，我们为组合模块发明一个对象名称，其次我们告诉 <code>make</code> 哪些对象文件是该模块的一部分。</p>
<h4 id="4-7-Building-modules-for-a-precompiled-kernel"><a href="#4-7-Building-modules-for-a-precompiled-kernel" class="headerlink" title="4.7 Building modules for a precompiled kernel"></a>4.7 Building modules for a precompiled kernel</h4><p>4.7 为预编译内核构建模块</p>
<p>Obviously, we strongly suggest you to recompile your kernel, so that you can enable a number of useful debugging features, such as forced module unloading ( <code>MODULE_FORCE_UNLOAD</code> ): when this option is enabled, you can force the kernel to unload a module even when it believes it is unsafe, via a <code>sudo rmmod -f module</code> command. This option can save you a lot of time and a number of reboots during the development of a module. If you do not want to recompile your kernel then you should consider running the examples within a test distribution on a virtual machine. If you mess anything up then you can easily reboot or restore the virtual machine (VM).<br>显然，我们强烈建议您重新编译内核，以便您可以启用许多有用的调试功能，例如强制模块卸载（ <code>MODULE_FORCE_UNLOAD</code> ）：启用此选项后，您可以强制内核即使模块认为不安全，也可以通过 <code>sudo rmmod -f module</code> 命令卸载模块。此选项可以在模块开发过程中为您节省大量时间和多次重新启动。如果您不想重新编译内核，那么您应该考虑在虚拟机上运行测试发行版中的示例。如果出现任何问题，您可以轻松重新启动或恢复虚拟机 (VM)。</p>
<p>There are a number of cases in which you may want to load your module into a precompiled running kernel, such as the ones shipped with common Linux distributions, or a kernel you have compiled in the past. In certain circumstances you could require to compile and insert a module into a running kernel which you are not allowed to recompile, or on a machine that you prefer not to reboot. If you can’t think of a case that will force you to use modules for a precompiled kernel you might want to skip this and treat the rest of this chapter as a big footnote.<br>在许多情况下，您可能希望将模块加载到预编译的运行内核中，例如常见 Linux 发行版附带的模块，或者您过去编译过的内核。在某些情况下，您可能需要编译模块并将其插入到正在运行的内核中，而不允许重新编译该模块，或者插入到您不希望重新启动的计算机上。如果您想不出强制您为预编译内核使用模块的情况，您可能想跳过这一点并将本章的其余部分视为一个大脚注。</p>
<p>Now, if you just install a kernel source tree, use it to compile your kernel module and you try to insert your module into the kernel, in most cases you would obtain an error as follows:<br>现在，如果您只是安装内核源代码树，使用它来编译内核模块，然后尝试将模块插入内核中，在大多数情况下您会收到如下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insmod: ERROR: could not insert module poet.ko: Invalid module format</span><br></pre></td></tr></table></figure>

<p>Less cryptic information is logged to the systemd journal:<br>不太神秘的信息会记录到 systemd 日志中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kernel: poet: disagrees about version of symbol module_layout</span><br></pre></td></tr></table></figure>

<p>In other words, your kernel refuses to accept your module because version strings (more precisely, version magic, see <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/vermagic.h">include&#x2F;linux&#x2F;vermagic.h</a>) do not match. Incidentally, version magic strings are stored in the module object in the form of a static string, starting with <code>vermagic:</code> . Version data are inserted in your module when it is linked against the kernel&#x2F;module.o file. To inspect version magics and other strings stored in a given module, issue the command <code>modinfo module.ko</code> :<br>换句话说，您的内核拒绝接受您的模块，因为版本字符串（更准确地说，版本魔法，请参阅 include&#x2F;linux&#x2F;vermagic.h）不匹配。顺便说一句，版本魔术字符串以静态字符串的形式存储在模块对象中，以 <code>vermagic:</code> 开头。当链接到 kernel&#x2F;module.o 文件时，版本数据将插入到模块中。要检查给定模块中存储的版本魔法和其他字符串，请发出命令 <code>modinfo module.ko</code> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ modinfo hello-4.ko</span><br><span class="line">description:    A sample driver</span><br><span class="line">author:         LKMPG</span><br><span class="line">license:        GPL</span><br><span class="line">srcversion:     B2AA7FBFCC2C39AED665382</span><br><span class="line">depends:</span><br><span class="line">retpoline:      Y</span><br><span class="line">name:           hello_4</span><br><span class="line">vermagic:       5.4.0-70-generic SMP mod_unload modversions</span><br></pre></td></tr></table></figure>

<p>To overcome this problem we could resort to the –force-vermagic option, but this solution is potentially unsafe, and unquestionably unacceptable in production modules. Consequently, we want to compile our module in an environment which was identical to the one in which our precompiled kernel was built. How to do this, is the subject of the remainder of this chapter.<br>为了解决这个问题，我们可以求助于 –force-vermagic 选项，但这种解决方案可能不安全，并且在生产模块中无疑是不可接受的。因此，我们希望在与构建预编译内核的环境相同的环境中编译我们的模块。如何做到这一点是本章剩余部分的主题。</p>
<p>First of all, make sure that a kernel source tree is available, having exactly the same version as your current kernel. Then, find the configuration file which was used to compile your precompiled kernel. Usually, this is available in your current boot directory, under a name like config-5.14.x. You may just want to copy it to your kernel source tree: <code>cp /boot/config-`uname -r` .config</code> .<br>首先，确保内核源代码树可用，并且具有与当前内核完全相同的版本。然后，找到用于编译预编译内核的配置文件。通常，它可以在您当前的引导目录中使用，名称如 config-5.14.x。您可能只想将其复制到内核源代码树： <code>cp /boot/config-`uname -r` .config</code> 。</p>
<p>Let’s focus again on the previous error message: a closer look at the version magic strings suggests that, even with two configuration files which are exactly the same, a slight difference in the version magic could be possible, and it is sufficient to prevent insertion of the module into the kernel. That slight difference, namely the custom string which appears in the module’s version magic and not in the kernel’s one, is due to a modification with respect to the original, in the makefile that some distributions include. Then, examine your Makefile, and make sure that the specified version information matches exactly the one used for your current kernel. For example, your makefile could start as follows:<br>让我们再次关注前面的错误消息：仔细观察版本魔术字符串表明，即使有两个完全相同的配置文件，版本魔术也可能存在细微差别，并且足以防止插入模块进入内核。这种细微的差异，即出现在模块版本魔法中而不是内核版本魔法中的自定义字符串，是由于某些发行版包含的 makefile 中对原始字符串的修改造成的。然后，检查您的 Makefile，并确保指定的版本信息与当前内核使用的版本信息完全匹配。例如，您的 makefile 可以如下启动：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VERSION = 5</span><br><span class="line">PATCHLEVEL = 14</span><br><span class="line">SUBLEVEL = 0</span><br><span class="line">EXTRAVERSION = -rc2</span><br></pre></td></tr></table></figure>

<p>In this case, you need to restore the value of symbol EXTRAVERSION to -rc2. We suggest to keep a backup copy of the makefile used to compile your kernel available in &#x2F;lib&#x2F;modules&#x2F;5.14.0-rc2&#x2F;build. A simple command as following should suffice.<br>在这种情况下，您需要将符号 EXTRAVERSION 的值恢复为-rc2。我们建议在 &#x2F;lib&#x2F;modules&#x2F;5.14.0-rc2&#x2F;build 中保留用于编译内核的 makefile 的备份副本。下面的简单命令就足够了。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cp /lib/modules/`uname -r`/build/Makefile linux-`uname -r`</span><br></pre></td></tr></table></figure>

<p>Here <code>linux-`uname -r`</code> is the Linux kernel source you are attempting to build.<br>这里 <code>linux-`uname -r`</code> 是您尝试构建的 Linux 内核源代码。</p>
<p>Now, please run <code>make</code> to update configuration and version headers and objects:<br>现在，请运行 <code>make</code> 来更新配置和版本标头和对象：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">  SYNC    include/config/auto.conf.cmd</span><br><span class="line">  HOSTCC  scripts/basic/fixdep</span><br><span class="line">  HOSTCC  scripts/kconfig/conf.o</span><br><span class="line">  HOSTCC  scripts/kconfig/confdata.o</span><br><span class="line">  HOSTCC  scripts/kconfig/expr.o</span><br><span class="line">  LEX     scripts/kconfig/lexer.lex.c</span><br><span class="line">  YACC    scripts/kconfig/parser.tab.[ch]</span><br><span class="line">  HOSTCC  scripts/kconfig/preprocess.o</span><br><span class="line">  HOSTCC  scripts/kconfig/symbol.o</span><br><span class="line">  HOSTCC  scripts/kconfig/util.o</span><br><span class="line">  HOSTCC  scripts/kconfig/lexer.lex.o</span><br><span class="line">  HOSTCC  scripts/kconfig/parser.tab.o</span><br><span class="line">  HOSTLD  scripts/kconfig/conf</span><br></pre></td></tr></table></figure>

<p>If you do not desire to actually compile the kernel, you can interrupt the build process (CTRL-C) just after the SPLIT line, because at that time, the files you need are ready. Now you can turn back to the directory of your module and compile it: It will be built exactly according to your current kernel settings, and it will load into it without any errors.<br>如果您不想实际编译内核，您可以在 SPLIT 行之后中断构建过程 (CTRL-C)，因为此时您需要的文件已准备就绪。现在您可以返回模块的目录并编译它：它将完全根据您当前的内核设置构建，并且加载到其中时不会出现任何错误。</p>
<h3 id="5-Preliminaries-5-预赛"><a href="#5-Preliminaries-5-预赛" class="headerlink" title="5 Preliminaries 5 预赛"></a>5 Preliminaries 5 预赛</h3><h4 id="5-1-How-modules-begin-and-end"><a href="#5-1-How-modules-begin-and-end" class="headerlink" title="5.1 How modules begin and end"></a>5.1 How modules begin and end</h4><p>5.1 模块如何开始和结束</p>
<p>A program usually begins with a <code>main()</code> function, executes a bunch of instructions and terminates upon completion of those instructions. Kernel modules work a bit differently. A module always begin with either the <code>init_module</code> or the function you specify with <code>module_init</code> call. This is the entry function for modules; it tells the kernel what functionality the module provides and sets up the kernel to run the module’s functions when they are needed. Once it does this, entry function returns and the module does nothing until the kernel wants to do something with the code that the module provides.<br>程序通常以 <code>main()</code> 函数开始，执行一堆指令并在完成这些指令后终止。内核模块的工作方式略有不同。模块始终以 <code>init_module</code> 或您通过 <code>module_init</code> 调用指定的函数开头。这是模块的入口函数；它告诉内核该模块提供什么功能，并设置内核在需要时运行该模块的功能。一旦完成此操作，入口函数返回并且模块不执行任何操作，直到内核想要使用模块提供的代码执行某些操作。</p>
<p>All modules end by calling either <code>cleanup_module</code> or the function you specify with the <code>module_exit</code> call. This is the exit function for modules; it undoes whatever entry function did. It unregisters the functionality that the entry function registered.<br>所有模块都以调用 <code>cleanup_module</code> 或您通过 <code>module_exit</code> 调用指定的函数结束。这是模块的退出函数；它会撤消输入函数所做的任何操作。它取消注册入口函数注册的功能。</p>
<p>Every module must have an entry function and an exit function. Since there’s more than one way to specify entry and exit functions, I will try my best to use the terms “entry function” and “exit function”, but if I slip and simply refer to them as <code>init_module</code> and <code>cleanup_module</code> , I think you will know what I mean.<br>每个模块必须有一个入口函数和一个出口函数。由于指定进入和退出函数的方法不止一种，我会尽力使用术语“进入函数”和“退出函数”，但如果我忽略并简单地将它们称为 <code>init_module</code> 和 <code>cleanup_module</code> ，我想你会明白我的意思。</p>
<h4 id="5-2-Functions-available-to-modules"><a href="#5-2-Functions-available-to-modules" class="headerlink" title="5.2 Functions available to modules"></a>5.2 Functions available to modules</h4><p>5.2 模块可用的功能</p>
<p>Programmers use functions they do not define all the time. A prime example of this is <code>printf()</code> . You use these library functions which are provided by the standard C library, libc. The definitions for these functions do not actually enter your program until the linking stage, which insures that the code (for <code>printf()</code> for example) is available, and fixes the call instruction to point to that code.<br>程序员始终使用他们未定义的函数。一个典型的例子是 <code>printf()</code> 。您可以使用标准 C 库 libc 提供的这些库函数。这些函数的定义直到链接阶段才真正进入您的程序，这确保了代码（例如 <code>printf()</code> ）可用，并修复了调用指令以指向该代码。</p>
<p>Kernel modules are different here, too. In the hello world example, you might have noticed that we used a function, <code>pr_info()</code> but did not include a standard I&#x2F;O library. That is because modules are object files whose symbols get resolved upon running <code>insmod</code> or <code>modprobe</code> . The definition for the symbols comes from the kernel itself; the only external functions you can use are the ones provided by the kernel. If you’re curious about what symbols have been exported by your kernel, take a look at &#x2F;proc&#x2F;kallsyms.<br>这里的内核模块也不同。在 hello world 示例中，您可能已经注意到我们使用了函数 <code>pr_info()</code> 但没有包含标准 I&#x2F;O 库。这是因为模块是对象文件，其符号在运行 <code>insmod</code> 或 <code>modprobe</code> 时得到解析。符号的定义来自内核本身；您可以使用的唯一外部函数是内核提供的函数。如果您对内核导出了哪些符号感到好奇，请查看 &#x2F;proc&#x2F;kallsyms。</p>
<p>One point to keep in mind is the difference between library functions and system calls. Library functions are higher level, run completely in user space and provide a more convenient interface for the programmer to the functions that do the real work — system calls. System calls run in kernel mode on the user’s behalf and are provided by the kernel itself. The library function <code>printf()</code> may look like a very general printing function, but all it really does is format the data into strings and write the string data using the low-level system call <code>write()</code> , which then sends the data to standard output.<br>需要记住的一点是库函数和系统调用之间的区别。库函数是更高级别的，完全在用户空间中运行，并为程序员提供更方便的接口来执行实际工作的函数（系统调用）。系统调用代表用户在内核模式下运行，由内核本身提供。库函数 <code>printf()</code> 可能看起来像一个非常通用的打印函数，但它实际上所做的只是将数据格式化为字符串并使用低级系统调用 <code>write()</code> 写入字符串数据，然后将数据发送到标准输出。</p>
<p>Would you like to see what system calls are made by <code>printf()</code> ? It is easy! Compile the following program:<br>您想查看 <code>printf()</code> 进行了哪些系统调用吗？这很容易！编译以下程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>with <code>gcc -Wall -o hello hello.c</code> . Run the executable with <code>strace ./hello</code> . Are you impressed? Every line you see corresponds to a system call. <a href="https://strace.io/">strace</a> is a handy program that gives you details about what system calls a program is making, including which call is made, what its arguments are and what it returns. It is an invaluable tool for figuring out things like what files a program is trying to access. Towards the end, you will see a line which looks like <code>write(1, &quot;hello&quot;, 5hello)</code> . There it is. The face behind the <code>printf()</code> mask. You may not be familiar with write, since most people use library functions for file I&#x2F;O (like <code>fopen</code> , <code>fputs</code> , <code>fclose</code> ). If that is the case, try looking at man 2 write. The 2nd man section is devoted to system calls (like <code>kill()</code> and <code>read()</code> ). The 3rd man section is devoted to library calls, which you would probably be more familiar with (like <code>cosh()</code> and <code>random()</code> ).<br>与 <code>gcc -Wall -o hello hello.c</code> 。使用 <code>strace ./hello</code> 运行可执行文件。你印象深刻吗？您看到的每一行都对应一个系统调用。 strace 是一个方便的程序，它为您提供有关程序正在执行哪些系统调用的详细信息，包括进行了哪个调用、其参数是什么以及返回什么。它是一个非常宝贵的工具，可以用来找出诸如程序试图访问哪些文件之类的事情。最后，您将看到一行看起来像 <code>write(1, &quot;hello&quot;, 5hello)</code> 的行。就在那里。 <code>printf()</code> 面具后面的脸。您可能不熟悉 write，因为大多数人使用库函数进行文件 I&#x2F;O（例如 <code>fopen</code> 、 <code>fputs</code> 、 <code>fclose</code> ）。如果是这种情况，请尝试查看 man 2 write。第二部分专门讨论系统调用（如 <code>kill()</code> 和 <code>read()</code> ）。第三个人部分专门用于库调用，您可能会更熟悉它（例如 <code>cosh()</code> 和 <code>random()</code> ）。</p>
<p>You can even write modules to replace the kernel’s system calls, which we will do shortly. Crackers often make use of this sort of thing for backdoors or trojans, but you can write your own modules to do more benign things, like have the kernel write Tee hee, that tickles! every time someone tries to delete a file on your system.<br>您甚至可以编写模块来替换内核的系统调用，我们很快就会这样做。破解者经常利用这种东西来创建后门或木马，但您可以编写自己的模块来做更多良性的事情，例如让内核写入 Tee hee，这很有趣！每次有人尝试删除您系统上的文件时。</p>
<h4 id="5-3-User-Space-vs-Kernel-Space"><a href="#5-3-User-Space-vs-Kernel-Space" class="headerlink" title="5.3 User Space vs Kernel Space"></a>5.3 User Space vs Kernel Space</h4><p>5.3 用户空间与内核空间</p>
<p>A kernel is all about access to resources, whether the resource in question happens to be a video card, a hard drive or even memory. Programs often compete for the same resource. As I just saved this document, updatedb started updating the locate database. My vim session and updatedb are both using the hard drive concurrently. The kernel needs to keep things orderly, and not give users access to resources whenever they feel like it. To this end, a CPU can run in different modes. Each mode gives a different level of freedom to do what you want on the system. The Intel 80386 architecture had 4 of these modes, which were called rings. Unix uses only two rings; the highest ring (ring 0, also known as “supervisor mode” where everything is allowed to happen) and the lowest ring, which is called “user mode”.<br>内核的核心就是对资源的访问，无论所讨论的资源是显卡、硬盘还是内存。程序经常争夺相同的资源。当我刚刚保存此文档时，updatedb 开始更新 locate 数据库。我的 vim 会话和 updateb 都同时使用硬盘。内核需要保持一切有序，并且不让用户随时访问资源。为此，CPU 可以运行在不同的模式下。每种模式都提供不同程度的自由度，让您可以在系统上执行您想要的操作。 Intel 80386 架构有 4 种这样的模式，称为环。 Unix 只使用两个环；最高的环（环 0，也称为“管理员模式”，允许一切发生）和最低的环，称为“用户模式”。</p>
<p>Recall the discussion about library functions vs system calls. Typically, you use a library function in user mode. The library function calls one or more system calls, and these system calls execute on the library function’s behalf, but do so in supervisor mode since they are part of the kernel itself. Once the system call completes its task, it returns and execution gets transferred back to user mode.<br>回想一下关于库函数与系统调用的讨论。通常，您在用户模式下使用库函数。库函数调用一个或多个系统调用，这些系统调用代表库函数执行，但在管理程序模式下执行，因为它们是内核本身的一部分。一旦系统调用完成其任务，它就会返回并将执行转移回用户模式。</p>
<h4 id="5-4-Name-Space-5-4-命名空间"><a href="#5-4-Name-Space-5-4-命名空间" class="headerlink" title="5.4 Name Space 5.4 命名空间"></a>5.4 Name Space 5.4 命名空间</h4><p>When you write a small C program, you use variables which are convenient and make sense to the reader. If, on the other hand, you are writing routines which will be part of a bigger problem, any global variables you have are part of a community of other peoples’ global variables; some of the variable names can clash. When a program has lots of global variables which aren’t meaningful enough to be distinguished, you get namespace pollution. In large projects, effort must be made to remember reserved names, and to find ways to develop a scheme for naming unique variable names and symbols.<br>当您编写小型 C 程序时，您使用的变量对读者来说很方便且有意义。另一方面，如果您正在编写将成为更大问题的一部分的例程，那么您拥有的任何全局变量都是其他人的全局变量社区的一部分；一些变量名称可能会发生冲突。当一个程序有大量的全局变量，而这些变量的意义不足以区分时，就会出现命名空间污染。在大型项目中，必须努力记住保留名称，并找到方法来开发命名唯一变量名称和符号的方案。</p>
<p>When writing kernel code, even the smallest module will be linked against the entire kernel, so this is definitely an issue. The best way to deal with this is to declare all your variables as static and to use a well-defined prefix for your symbols. By convention, all kernel prefixes are lowercase. If you do not want to declare everything as static, another option is to declare a symbol table and register it with the kernel. We will get to this later.<br>当编写内核代码时，即使是最小的模块也会链接到整个内核，所以这绝对是一个问题。处理这个问题的最佳方法是将所有变量声明为静态，并为符号使用定义明确的前缀。按照惯例，所有内核前缀都是小写的。如果您不想将所有内容声明为静态，另一种选择是声明符号表并将其注册到内核。我们稍后会讨论这个。</p>
<p>The file &#x2F;proc&#x2F;kallsyms holds all the symbols that the kernel knows about and which are therefore accessible to your modules since they share the kernel’s codespace.<br>文件 &#x2F;proc&#x2F;kallsyms 保存了内核知道的所有符号，因此您的模块可以访问这些符号，因为它们共享内核的代码空间。</p>
<h4 id="5-5-Code-space-5-5-代码空间"><a href="#5-5-Code-space-5-5-代码空间" class="headerlink" title="5.5 Code space 5.5 代码空间"></a>5.5 Code space 5.5 代码空间</h4><p>Memory management is a very complicated subject and the majority of O’Reilly’s <a href="https://www.oreilly.com/library/view/understanding-the-linux/0596005652/">Understanding The Linux Kernel</a> exclusively covers memory management! We are not setting out to be experts on memory managements, but we do need to know a couple of facts to even begin worrying about writing real modules.<br>内存管理是一个非常复杂的主题，O’Reilly 的《Understanding The Linux Kernel》的大部分内容都专门涉及内存管理！我们并不是想成为内存管理方面的专家，但我们确实需要了解一些事实才能开始担心编写真正的模块。</p>
<p>If you have not thought about what a segfault really means, you may be surprised to hear that pointers do not actually point to memory locations. Not real ones, anyway. When a process is created, the kernel sets aside a portion of real physical memory and hands it to the process to use for its executing code, variables, stack, heap and other things which a computer scientist would know about. This memory begins with 0x00000000 and extends up to whatever it needs to be. Since the memory space for any two processes do not overlap, every process that can access a memory address, say 0xbffff978, would be accessing a different location in real physical memory! The processes would be accessing an index named 0xbffff978 which points to some kind of offset into the region of memory set aside for that particular process. For the most part, a process like our Hello, World program can’t access the space of another process, although there are ways which we will talk about later.<br>如果您还没有考虑过段错误的真正含义，您可能会惊讶地发现指针实际上并不指向内存位置。无论如何，不是真实的。当一个进程被创建时，内核会留出一部分真实的物理内存，并将其交给进程用于执行代码、变量、堆栈、堆和计算机科学家所知道的其他内容。该内存从 0x00000000 开始，一直延伸到它需要的任何位置。由于任何两个进程的内存空间不重叠，因此每个可以访问内存地址（例如 0xbffff978）的进程都将访问真实物理内存中的不同位置！这些进程将访问名为 0xbffff978 的索引，该索引指向为该特定进程预留的内存区域中的某种偏移量。在大多数情况下，像我们的 Hello, World 程序这样的进程无法访问另一个进程的空间，尽管我们稍后会讨论一些方法。</p>
<p>The kernel has its own space of memory as well. Since a module is code which can be dynamically inserted and removed in the kernel (as opposed to a semi-autonomous object), it shares the kernel’s codespace rather than having its own. Therefore, if your module segfaults, the kernel segfaults. And if you start writing over data because of an off-by-one error, then you’re trampling on kernel data (or code). This is even worse than it sounds, so try your best to be careful.<br>内核也有自己的内存空间。由于模块是可以在内核中动态插入和删除的代码（与半自治对象相反），因此它共享内核的代码空间而不是拥有自己的代码空间。因此，如果您的模块出现段错误，内核也会出现段错误。如果您因为差一错误而开始重写数据，那么您就是在践踏内核数据（或代码）。这比听起来更糟糕，所以请尽量小心。</p>
<p>By the way, I would like to point out that the above discussion is true for any operating system which uses a monolithic kernel. This is not quite the same thing as “building all your modules into the kernel”, although the idea is the same. There are things called microkernels which have modules which get their own codespace. The <a href="https://www.gnu.org/software/hurd/">GNU Hurd</a> and the <a href="https://fuchsia.dev/fuchsia-src/concepts/kernel">Zircon kernel</a> of Google Fuchsia are two examples of a microkernel.<br>顺便说一句，我想指出，上述讨论对于任何使用单片内核的操作系统都是正确的。尽管想法是相同的，但这与“将所有模块构建到内核中”并不完全相同。有些东西称为微内核，它们的模块有自己的代码空间。 GNU Hurd 和 Google Fuchsia 的 Zircon 内核是微内核的两个示例。</p>
<h4 id="5-6-Device-Drivers-5-6-设备驱动程序"><a href="#5-6-Device-Drivers-5-6-设备驱动程序" class="headerlink" title="5.6 Device Drivers 5.6 设备驱动程序"></a>5.6 Device Drivers 5.6 设备驱动程序</h4><p>One class of module is the device driver, which provides functionality for hardware like a serial port. On Unix, each piece of hardware is represented by a file located in &#x2F;dev named a device file which provides the means to communicate with the hardware. The device driver provides the communication on behalf of a user program. So the es1370.ko sound card device driver might connect the &#x2F;dev&#x2F;sound device file to the Ensoniq IS1370 sound card. A userspace program like mp3blaster can use &#x2F;dev&#x2F;sound without ever knowing what kind of sound card is installed.<br>一类模块是设备驱动程序，它为串行端口等硬件提供功能。在 Unix 上，每个硬件都由位于 &#x2F;dev 中的一个名为设备文件的文件表示，该文件提供与硬件通信的方式。设备驱动程序代表用户程序提供通信。因此 es1370.ko 声卡设备驱动程序可能会将 &#x2F;dev&#x2F;sound 设备文件连接到 Ensoniq IS1370 声卡。像 mp3blaster 这样的用户空间程序可以使用 &#x2F;dev&#x2F;sound，而无需知道安装了哪种声卡。</p>
<p>Let’s look at some device files. Here are device files which represent the first three partitions on the primary master IDE hard drive:<br>让我们看一些设备文件。以下是代表主要主 IDE 硬盘驱动器上前三个分区的设备文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /dev/hda[1-3]</span><br><span class="line">brw-rw----  1 root  disk  3, 1 Jul  5  2000 /dev/hda1</span><br><span class="line">brw-rw----  1 root  disk  3, 2 Jul  5  2000 /dev/hda2</span><br><span class="line">brw-rw----  1 root  disk  3, 3 Jul  5  2000 /dev/hda3</span><br></pre></td></tr></table></figure>

<p>Notice the column of numbers separated by a comma. The first number is called the device’s major number. The second number is the minor number. The major number tells you which driver is used to access the hardware. Each driver is assigned a unique major number; all device files with the same major number are controlled by the same driver. All the above major numbers are 3, because they’re all controlled by the same driver.<br>请注意用逗号分隔的数字列。第一个数字称为设备的主号码。第二个数字是次要数字。主设备号告诉您使用哪个驱动程序来访问硬件。每个驱动程序都被分配了一个唯一的主编号；所有具有相同主设备号的设备文件都由同一个驱动程序控制。上面所有的主编号都是 3，因为它们都是由同一个驱动程序控制的。</p>
<p>The minor number is used by the driver to distinguish between the various hardware it controls. Returning to the example above, although all three devices are handled by the same driver they have unique minor numbers because the driver sees them as being different pieces of hardware.<br>驱动程序使用次设备号来区分它控制的各种硬件。回到上面的示例，尽管所有三个设备都由同一驱动程序处理，但它们具有唯一的次设备号，因为驱动程序将它们视为不同的硬件。</p>
<p>Devices are divided into two types: character devices and block devices. The difference is that block devices have a buffer for requests, so they can choose the best order in which to respond to the requests. This is important in the case of storage devices, where it is faster to read or write sectors which are close to each other, rather than those which are further apart. Another difference is that block devices can only accept input and return output in blocks (whose size can vary according to the device), whereas character devices are allowed to use as many or as few bytes as they like. Most devices in the world are character, because they don’t need this type of buffering, and they don’t operate with a fixed block size. You can tell whether a device file is for a block device or a character device by looking at the first character in the output of <code>ls -l</code> . If it is ‘b’ then it is a block device, and if it is ‘c’ then it is a character device. The devices you see above are block devices. Here are some character devices (the serial ports):<br>设备分为两种类型：字符设备和块设备。不同之处在于块设备有一个用于请求的缓冲区，因此它们可以选择响应请求的最佳顺序。这对于存储设备来说很重要，因为在存储设备中读取或写入彼此靠近的扇区比那些相距较远的扇区更快。另一个区别是块设备只能以块的形式接受输入和返回输出（块的大小可能根据设备而变化），而字符设备则允许使用任意多或尽可能少的字节。世界上大多数设备都是字符设备，因为它们不需要这种类型的缓冲，并且它们不以固定的块大小运行。您可以通过查看 <code>ls -l</code> 输出中的第一个字符来判断设备文件是用于块设备还是字符设备。如果是“b”，则它是块设备，如果是“c”，则它是字符设备。您在上面看到的设备是块设备。以下是一些字符设备（串行端口）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crw-rw----  1 root  dial 4, 64 Feb 18 23:34 /dev/ttyS0</span><br><span class="line">crw-r-----  1 root  dial 4, 65 Nov 17 10:26 /dev/ttyS1</span><br><span class="line">crw-rw----  1 root  dial 4, 66 Jul  5  2000 /dev/ttyS2</span><br><span class="line">crw-rw----  1 root  dial 4, 67 Jul  5  2000 /dev/ttyS3</span><br></pre></td></tr></table></figure>

<p>If you want to see which major numbers have been assigned, you can look at <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/admin-guide/devices.txt">Documentation&#x2F;admin-guide&#x2F;devices.txt</a>.<br>如果您想查看已分配了哪些主编号，可以查看 Documentation&#x2F;admin-guide&#x2F;devices.txt。</p>
<p>When the system was installed, all of those device files were created by the <code>mknod</code> command. To create a new char device named coffee with major&#x2F;minor number 12 and 2, simply do <code>mknod /dev/coffee c 12 2</code> . You do not have to put your device files into &#x2F;dev, but it is done by convention. Linus put his device files in &#x2F;dev, and so should you. However, when creating a device file for testing purposes, it is probably OK to place it in your working directory where you compile the kernel module. Just be sure to put it in the right place when you’re done writing the device driver.<br>当系统安装时，所有这些设备文件都是由 <code>mknod</code> 命令创建的。要创建一个名为 Coffee 且主次编号为 12 和 2 的新字符设备，只需执行 <code>mknod /dev/coffee c 12 2</code> 即可。您不必将设备文件放入 &#x2F;dev，但这是按照惯例完成的。 Linus 将他的设备文件放在 &#x2F;dev 中，你也应该这样做。但是，当创建用于测试目的的设备文件时，将其放置在编译内核模块的工作目录中可能是可以的。编写完设备驱动程序后，请务必将其放在正确的位置。</p>
<p>I would like to make a few last points which are implicit from the above discussion, but I would like to make them explicit just in case. When a device file is accessed, the kernel uses the major number of the file to determine which driver should be used to handle the access. This means that the kernel doesn’t really need to use or even know about the minor number. The driver itself is the only thing that cares about the minor number. It uses the minor number to distinguish between different pieces of hardware.<br>我想提出上述讨论中隐含的最后几点，但为了以防万一，我想将它们明确化。当访问设备文件时，内核使用文件的主设备号来确定应使用哪个驱动程序来处理访问。这意味着内核实际上不需要使用甚至不需要知道次要编号。驱动程序本身是唯一关心次要号码的东西。它使用次要编号来区分不同的硬件。</p>
<p>By the way, when I say “hardware”, I mean something a bit more abstract than a PCI card that you can hold in your hand. Look at these two device files:<br>顺便说一句，当我说“硬件”时，我指的是比你可以握在手中的 PCI 卡更抽象的东西。查看这两个设备文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /dev/sda /dev/sdb</span><br><span class="line">brw-rw---- 1 root disk 8,  0 Jan  3 09:02 /dev/sda</span><br><span class="line">brw-rw---- 1 root disk 8, 16 Jan  3 09:02 /dev/sdb</span><br></pre></td></tr></table></figure>

<p>By now you can look at these two device files and know instantly that they are block devices and are handled by same driver (block major 8). Sometimes two device files with the same major but different minor number can actually represent the same piece of physical hardware. So just be aware that the word “hardware” in our discussion can mean something very abstract.<br>现在您可以查看这两个设备文件并立即知道它们是块设备并且由相同的驱动程序处理（块主要 8）。有时，两个具有相同主设备号但不同次设备号的设备文件实际上可以代表同一块物理硬件。因此请注意，我们讨论中的“硬件”一词可能意味着非常抽象的东西。</p>
<h3 id="6-Character-Device-drivers"><a href="#6-Character-Device-drivers" class="headerlink" title="6 Character Device drivers"></a>6 Character Device drivers</h3><p>6 字符设备驱动程序</p>
<h4 id="6-1-The-file-operations-Structure"><a href="#6-1-The-file-operations-Structure" class="headerlink" title="6.1 The file_operations Structure"></a>6.1 The file_operations Structure</h4><p>6.1 文件操作结构</p>
<p>The <code>file_operations</code> structure is defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h">include&#x2F;linux&#x2F;fs.h</a>, and holds pointers to functions defined by the driver that perform various operations on the device. Each field of the structure corresponds to the address of some function defined by the driver to handle a requested operation.<br><code>file_operations</code> 结构在 include&#x2F;linux&#x2F;fs.h 中定义，并保存指向驱动程序定义的函数的指针，这些函数在设备上执行各种操作。该结构的每个字段对应于驱动程序定义的某个函数的地址，用于处理请求的操作。</p>
<p>For example, every character driver needs to define a function that reads from the device. The <code>file_operations</code> structure holds the address of the module’s function that performs that operation. Here is what the definition looks like for kernel 5.4:<br>例如，每个字符驱动程序都需要定义一个从设备读取的函数。 <code>file_operations</code> 结构保存执行该操作的模块函数的地址。以下是内核 5.4 的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">    <span class="type">int</span> (*iopoll)(<span class="keyword">struct</span> kiocb *kiocb, <span class="type">bool</span> spin);</span><br><span class="line">    <span class="type">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">    <span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">    <span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line">    <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line">    <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">    <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">    <span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line">    <span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">        <span class="type">loff_t</span> len);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line">    <span class="type">ssize_t</span> (*copy_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *,</span><br><span class="line">        <span class="type">loff_t</span>, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">loff_t</span> (*remap_file_range)(<span class="keyword">struct</span> file *file_in, <span class="type">loff_t</span> pos_in,</span><br><span class="line">             <span class="keyword">struct</span> file *file_out, <span class="type">loff_t</span> pos_out,</span><br><span class="line">             <span class="type">loff_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> remap_flags);</span><br><span class="line">    <span class="type">int</span> (*fadvise)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>Some operations are not implemented by a driver. For example, a driver that handles a video card will not need to read from a directory structure. The corresponding entries in the <code>file_operations</code> structure should be set to <code>NULL</code> .<br>有些操作不是由驱动程序实现的。例如，处理视频卡的驱动程序不需要从目录结构中读取。 <code>file_operations</code> 结构中的相应条目应设置为 <code>NULL</code> 。</p>
<p>There is a gcc extension that makes assigning to this structure more convenient. You will see it in modern drivers, and may catch you by surprise. This is what the new way of assigning to the structure looks like:<br>有一个 gcc 扩展可以使分配给这个结构更加方便。您会在现代驾驶员中看到它，并且可能会让您感到惊讶。这就是分配给结构的新方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">    read: device_read,</span><br><span class="line">    write: device_write,</span><br><span class="line">    open: device_open,</span><br><span class="line">    release: device_release</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>However, there is also a C99 way of assigning to elements of a structure, <a href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">designated initializers</a>, and this is definitely preferred over using the GNU extension. You should use this syntax in case someone wants to port your driver. It will help with compatibility:<br>然而，还有一种 C99 方法可以分配给结构的元素、指定的初始值设定项，这绝对优于使用 GNU 扩展。如果有人想要移植您的驱动程序，您应该使用此语法。它将有助于兼容性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">    .read = device_read,</span><br><span class="line">    .write = device_write,</span><br><span class="line">    .open = device_open,</span><br><span class="line">    .release = device_release</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The meaning is clear, and you should be aware that any member of the structure which you do not explicitly assign will be initialized to <code>NULL</code> by gcc.<br>含义很清楚，您应该知道，您未显式分配的结构体中的任何成员都将被 gcc 初始化为 <code>NULL</code> 。</p>
<p>An instance of <code>struct file_operations</code> containing pointers to functions that are used to implement <code>read</code> , <code>write</code> , <code>open</code> , … system calls is commonly named <code>fops</code> .<br><code>struct file_operations</code> 的实例包含指向用于实现 <code>read</code> 、 <code>write</code> 、 <code>open</code> 等系统调用的函数的指针，通常命名为 &lt; b4&gt; 。</p>
<p>Since Linux v3.14, the read, write and seek operations are guaranteed for thread-safe by using the <code>f_pos</code> specific lock, which makes the file position update to become the mutual exclusion. So, we can safely implement those operations without unnecessary locking.<br>从 Linux v3.14 开始，通过使用 <code>f_pos</code> 特定锁来保证读、写和查找操作的线程安全，这使得文件位置更新成为互斥。因此，我们可以安全地实现这些操作，而无需不必要的锁定。</p>
<p>Additionally, since Linux v5.6, the <code>proc_ops</code> structure was introduced to replace the use of the <code>file_operations</code> structure when registering proc handlers. See more information in the <a href="https://sysprog21.github.io/lkmpg/#the-procops-structure">7.1</a> section.<br>此外，从 Linux v5.6 开始，在注册 proc 处理程序时引入了 <code>proc_ops</code> 结构来替换 <code>file_operations</code> 结构的使用。更多信息请参见 7.1 节。</p>
<h4 id="6-2-The-file-structure-6-2-文件结构"><a href="#6-2-The-file-structure-6-2-文件结构" class="headerlink" title="6.2 The file structure 6.2 文件结构"></a>6.2 The file structure 6.2 文件结构</h4><p>Each device is represented in the kernel by a file structure, which is defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h">include&#x2F;linux&#x2F;fs.h</a>. Be aware that a file is a kernel level structure and never appears in a user space program. It is not the same thing as a <code>FILE</code> , which is defined by glibc and would never appear in a kernel space function. Also, its name is a bit misleading; it represents an abstract open ‘file’, not a file on a disk, which is represented by a structure named <code>inode</code> .<br>每个设备在内核中都由一个文件结构表示，该结构在 include&#x2F;linux&#x2F;fs.h 中定义。请注意，文件是内核级结构，永远不会出现在用户空间程序中。它与 <code>FILE</code> 不同，后者由 glibc 定义，永远不会出现在内核空间函数中。另外，它的名字有点误导；它代表一个抽象的打开“文件”，而不是磁盘上的文件，它由名为 <code>inode</code> 的结构表示。</p>
<p>An instance of struct file is commonly named <code>filp</code> . You’ll also see it referred to as a struct file object. Resist the temptation.<br>struct file 的实例通常命名为 <code>filp</code> 。您还会看到它被称为结构文件对象。抵制诱惑。</p>
<p>Go ahead and look at the definition of file. Most of the entries you see, like struct dentry are not used by device drivers, and you can ignore them. This is because drivers do not fill file directly; they only use structures contained in file which are created elsewhere.<br>继续看一下文件的定义。您看到的大多数条目（例如 struct dentry）不被设备驱动程序使用，您可以忽略它们。这是因为驱动程序不直接填充文件；他们只使用在其他地方创建的文件中包含的结构。</p>
<h4 id="6-3-Registering-A-Device-6-3-注册设备"><a href="#6-3-Registering-A-Device-6-3-注册设备" class="headerlink" title="6.3 Registering A Device 6.3 注册设备"></a>6.3 Registering A Device 6.3 注册设备</h4><p>As discussed earlier, char devices are accessed through device files, usually located in &#x2F;dev. This is by convention. When writing a driver, it is OK to put the device file in your current directory. Just make sure you place it in &#x2F;dev for a production driver. The major number tells you which driver handles which device file. The minor number is used only by the driver itself to differentiate which device it is operating on, just in case the driver handles more than one device.<br>如前所述，字符设备是通过设备文件访问的，通常位于 &#x2F;dev 中。这是按照惯例。编写驱动程序时，将设备文件放在当前目录下就可以了。只需确保将其放置在 &#x2F;dev 中作为生产驱动程序。主设备号告诉您哪个驱动程序处理哪个设备文件。次设备号仅由驱动程序本身用来区分正在运行的设备，以防驱动程序处理多个设备。</p>
<p>Adding a driver to your system means registering it with the kernel. This is synonymous with assigning it a major number during the module’s initialization. You do this by using the <code>register_chrdev</code> function, defined by <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/fs.h">include&#x2F;linux&#x2F;fs.h</a>.<br>将驱动程序添加到系统意味着将其注册到内核。这与在模块初始化期间为其分配主编号是同义的。您可以使用 include&#x2F;linux&#x2F;fs.h 定义的 <code>register_chrdev</code> 函数来执行此操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> file_operations *fops)</span>;</span><br></pre></td></tr></table></figure>

<p>Where unsigned int major is the major number you want to request, <code>const char *name</code> is the name of the device as it will appear in &#x2F;proc&#x2F;devices and <code>struct file_operations *fops</code> is a pointer to the <code>file_operations</code> table for your driver. A negative return value means the registration failed. Note that we didn’t pass the minor number to <code>register_chrdev</code> . That is because the kernel doesn’t care about the minor number; only our driver uses it.<br>其中 unsigned int Major 是您要请求的主设备号， <code>const char *name</code> 是将出现在 &#x2F;proc&#x2F;devices 中的设备名称， <code>struct file_operations *fops</code> 是指向 <code>file_operations</code> 为您的司机准备的表格。返回值为负数表示注册失败。请注意，我们没有将次要编号传递给 <code>register_chrdev</code> 。这是因为内核不关心次设备号；只有我们的司机使用它。</p>
<p>Now the question is, how do you get a major number without hijacking one that’s already in use? The easiest way would be to look through <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/admin-guide/devices.txt">Documentation&#x2F;admin-guide&#x2F;devices.txt</a> and pick an unused one. That is a bad way of doing things because you will never be sure if the number you picked will be assigned later. The answer is that you can ask the kernel to assign you a dynamic major number.<br>现在的问题是，如何在不劫持已在使用的号码的情况下获得主号码？最简单的方法是查看 Documentation&#x2F;admin-guide&#x2F;devices.txt 并选择一个未使用的。这是一种糟糕的做法，因为您永远无法确定您选择的号码稍后是否会被分配。答案是，您可以要求内核为您分配一个动态主编号。</p>
<p>If you pass a major number of 0 to <code>register_chrdev</code> , the return value will be the dynamically allocated major number. The downside is that you can not make a device file in advance, since you do not know what the major number will be. There are a couple of ways to do this. First, the driver itself can print the newly assigned number and we can make the device file by hand. Second, the newly registered device will have an entry in &#x2F;proc&#x2F;devices, and we can either make the device file by hand or write a shell script to read the file in and make the device file. The third method is that we can have our driver make the device file using the <code>device_create</code> function after a successful registration and <code>device_destroy</code> during the call to <code>cleanup_module</code> .<br>如果将主设备号 0 传递给 <code>register_chrdev</code> ，则返回值将是动态分配的主设备号。缺点是您无法提前创建设备文件，因为您不知道主设备号是什么。有几种方法可以做到这一点。首先，驱动程序本身可以打印新分配的编号，我们可以手工制作设备文件。其次，新注册的设备将在&#x2F;proc&#x2F;devices 中有一个条目，我们可以手动制作设备文件，也可以编写 shell 脚本读取该文件并制作设备文件。第三种方法是，我们可以让驱动程序在成功注册后使用 <code>device_create</code> 函数创建设备文件，并在调用 <code>cleanup_module</code> 期间使用 <code>device_destroy</code> 函数创建设备文件。</p>
<p>However, <code>register_chrdev()</code> would occupy a range of minor numbers associated with the given major. The recommended way to reduce waste for char device registration is using cdev interface.<br>但是， <code>register_chrdev()</code> 将占用与给定主要相关的一系列次要编号。减少 char 设备注册浪费的推荐方法是使用 cdev 接口。</p>
<p>The newer interface completes the char device registration in two distinct steps. First, we should register a range of device numbers, which can be completed with <code>register_chrdev_region</code> or <code>alloc_chrdev_region</code> .<br>新的界面通过两个不同的步骤完成字符设备注册。首先，我们应该注册一系列设备编号，可以用 <code>register_chrdev_region</code> 或 <code>alloc_chrdev_region</code> 来完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev_region</span><span class="params">(<span class="type">dev_t</span> from, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>

<p>The choice between two different functions depends on whether you know the major numbers for your device. Using <code>register_chrdev_region</code> if you know the device major number and <code>alloc_chrdev_region</code> if you would like to allocate a dynamicly-allocated major number.<br>两种不同功能之间的选择取决于您是否知道设备的主编号。如果您知道设备主设备号，请使用 <code>register_chrdev_region</code> ；如果您想分配动态分配的主设备号，请使用 <code>alloc_chrdev_region</code> 。</p>
<p>Second, we should initialize the data structure <code>struct cdev</code> for our char device and associate it with the device numbers. To initialize the <code>struct cdev</code> , we can achieve by the similar sequence of the following codes.<br>其次，我们应该初始化字符设备的数据结构 <code>struct cdev</code> 并将其与设备号相关联。要初始化 <code>struct cdev</code> ，我们可以通过以下代码的类似序列来实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">my_dev</span> =</span> cdev_alloc();</span><br><span class="line">my_cdev-&gt;ops = &amp;my_fops;</span><br></pre></td></tr></table></figure>

<p>However, the common usage pattern will embed the <code>struct cdev</code> within a device-specific structure of your own. In this case, we’ll need <code>cdev_init</code> for the initialization.<br>但是，常见的使用模式会将 <code>struct cdev</code> 嵌入到您自己的设备特定结构中。在这种情况下，我们需要 <code>cdev_init</code> 进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span>;</span><br></pre></td></tr></table></figure>

<p>Once we finish the initialization, we can add the char device to the system by using the <code>cdev_add</code> .<br>完成初始化后，我们可以使用 <code>cdev_add</code> 将字符设备添加到系统中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>To find an example using the interface, you can see ioctl.c described in section <a href="https://sysprog21.github.io/lkmpg/#talking-to-device-files">9</a>.<br>要查找使用该接口的示例，您可以参见第 9 节中描述的 ioctl.c。</p>
<h4 id="6-4-Unregistering-A-Device"><a href="#6-4-Unregistering-A-Device" class="headerlink" title="6.4 Unregistering A Device"></a>6.4 Unregistering A Device</h4><p>6.4 注销设备</p>
<p>We can not allow the kernel module to be <code>rmmod</code> ’ed whenever root feels like it. If the device file is opened by a process and then we remove the kernel module, using the file would cause a call to the memory location where the appropriate function (read&#x2F;write) used to be. If we are lucky, no other code was loaded there, and we’ll get an ugly error message. If we are unlucky, another kernel module was loaded into the same location, which means a jump into the middle of another function within the kernel. The results of this would be impossible to predict, but they can not be very positive.<br>只要 root 愿意，我们就不能允许内核模块被 <code>rmmod</code> 编辑。如果设备文件被进程打开，然后我们删除内核模块，则使用该文件将导致调用适当函数（读&#x2F;写）曾经所在的内存位置。如果幸运的话，那里没有加载其他代码，我们会收到一条丑陋的错误消息。如果我们运气不好，另一个内核模块会被加载到同一位置，这意味着跳转到内核中另一个函数的中间。其结果无法预测，但也不会非常积极。</p>
<p>Normally, when you do not want to allow something, you return an error code (a negative number) from the function which is supposed to do it. With <code>cleanup_module</code> that’s impossible because it is a void function. However, there is a counter which keeps track of how many processes are using your module. You can see what its value is by looking at the 3rd field with the command <code>cat /proc/modules</code> or <code>sudo lsmod</code> . If this number isn’t zero, <code>rmmod</code> will fail. Note that you do not have to check the counter within <code>cleanup_module</code> because the check will be performed for you by the system call <code>sys_delete_module</code> , defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/syscalls.h">include&#x2F;linux&#x2F;syscalls.h</a>. You should not use this counter directly, but there are functions defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/module.h">include&#x2F;linux&#x2F;module.h</a> which let you increase, decrease and display this counter:<br>通常，当您不想允许某些操作时，您会从应该执行该操作的函数返回错误代码（负数）。对于 <code>cleanup_module</code> 这是不可能的，因为它是一个 void 函数。但是，有一个计数器可以跟踪有多少进程正在使用您的模块。您可以通过使用命令 <code>cat /proc/modules</code> 或 <code>sudo lsmod</code> 查看第三个字段来查看其值。如果该数字不为零， <code>rmmod</code> 将失败。请注意，您不必检查 <code>cleanup_module</code> 中的计数器，因为该检查将由 include&#x2F;linux&#x2F;syscalls.h 中定义的系统调用 <code>sys_delete_module</code> 为您执行。你不应该直接使用这个计数器，但是 include&#x2F;linux&#x2F;module.h 中定义了一些函数，可以让你增加、减少和显示这个计数器：</p>
<ul>
<li><code>try_module_get(THIS_MODULE)</code> : Increment the reference count of current module.<br><code>try_module_get(THIS_MODULE)</code> ：增加当前模块的引用计数。</li>
<li><code>module_put(THIS_MODULE)</code> : Decrement the reference count of current module.<br><code>module_put(THIS_MODULE)</code> ：减少当前模块的引用计数。</li>
<li><code>module_refcount(THIS_MODULE)</code> : Return the value of reference count of current module.<br><code>module_refcount(THIS_MODULE)</code> ：返回当前模块的引用计数值。</li>
</ul>
<p>It is important to keep the counter accurate; if you ever do lose track of the correct usage count, you will never be able to unload the module; it’s now reboot time, boys and girls. This is bound to happen to you sooner or later during a module’s development.<br>保持计数器准确非常重要；如果您确实忘记了正确的使用计数，您将永远无法卸载该模块；现在是重新启动的时间，男孩和女孩。在模块的开发过程中，这种情况迟早会发生在你身上。</p>
<h4 id="6-5-chardev-c"><a href="#6-5-chardev-c" class="headerlink" title="6.5 chardev.c"></a>6.5 chardev.c</h4><p>The next code sample creates a char driver named chardev. You can dump its device file.<br>下一个代码示例创建一个名为 chardev 的字符驱动程序。您可以转储其设备文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/devices</span><br></pre></td></tr></table></figure>

<p>(or open the file with a program) and the driver will put the number of times the device file has been read from into the file. We do not support writing to the file (like <code>echo &quot;hi&quot; &gt; /dev/hello</code> ), but catch these attempts and tell the user that the operation is not supported. Don’t worry if you don’t see what we do with the data we read into the buffer; we don’t do much with it. We simply read in the data and print a message acknowledging that we received it.<br>（或用程序打开文件），驱动程序会将设备文件被读取的次数放入文件中。我们不支持写入文件（如 <code>echo &quot;hi&quot; &gt; /dev/hello</code> ），但会捕获这些尝试并告诉用户不支持该操作。如果您看不到我们如何处理读入缓冲区的数据，请不要担心；我们并没有用它做太多事情。我们只需读入数据并打印一条消息来确认我们收到了它。</p>
<p>In the multiple-threaded environment, without any protection, concurrent access to the same memory may lead to the race condition, and will not preserve the performance. In the kernel module, this problem may happen due to multiple instances accessing the shared resources. Therefore, a solution is to enforce the exclusive access. We use atomic Compare-And-Swap (CAS) to maintain the states, <code>CDEV_NOT_USED</code> and <code>CDEV_EXCLUSIVE_OPEN</code> , to determine whether the file is currently opened by someone or not. CAS compares the contents of a memory location with the expected value and, only if they are the same, modifies the contents of that memory location to the desired value. See more concurrency details in the <a href="https://sysprog21.github.io/lkmpg/#avoiding-collisions-and-deadlocks">12</a> section.<br>在多线程环境下，在没有任何保护的情况下，并发访问同一内存可能会导致竞争条件，并且不会保留性能。在内核模块中，由于多个实例访问共享资源，可能会出现此问题。因此，解决方案是强制执行独占访问。我们使用原子比较和交换（CAS）来维护状态 <code>CDEV_NOT_USED</code> 和 <code>CDEV_EXCLUSIVE_OPEN</code> ，以确定文件当前是否被某人打开。 CAS 将内存位置的内容与预期值进行比较，只有当它们相同时，才会将该内存位置的内容修改为所需值。请参阅第 12 节中的更多并发详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * chardev.c: Creates a read-only char device that says how many times</span><br><span class="line"> * you have read from the dev file</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;linux/atomic.h&gt;</span><br><span class="line">#include &lt;linux/cdev.h&gt;</span><br><span class="line">#include &lt;linux/delay.h&gt;</span><br><span class="line">#include &lt;linux/device.h&gt;</span><br><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/kernel.h&gt; /* for sprintf() */</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/printk.h&gt;</span><br><span class="line">#include &lt;linux/types.h&gt;</span><br><span class="line">#include &lt;linux/uaccess.h&gt; /* for get_user and put_user */</span><br><span class="line">#include &lt;linux/version.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;asm/errno.h&gt;</span><br><span class="line"></span><br><span class="line">/*  Prototypes - this would normally go in a .h file */</span><br><span class="line">static int device_open(struct inode *, struct file *);</span><br><span class="line">static int device_release(struct inode *, struct file *);</span><br><span class="line">static ssize_t device_read(struct file *, char __user *, size_t, loff_t *);</span><br><span class="line">static ssize_t device_write(struct file *, const char __user *, size_t,</span><br><span class="line">                            loff_t *);</span><br><span class="line"></span><br><span class="line">#define SUCCESS 0</span><br><span class="line">#define DEVICE_NAME &quot;chardev&quot; /* Dev name as it appears in /proc/devices   */</span><br><span class="line">#define BUF_LEN 80 /* Max length of the message from the device */</span><br><span class="line"></span><br><span class="line">/* Global variables are declared as static, so are global within the file. */</span><br><span class="line"></span><br><span class="line">static int major; /* major number assigned to our device driver */</span><br><span class="line"></span><br><span class="line">enum &#123;</span><br><span class="line">    CDEV_NOT_USED = 0,</span><br><span class="line">    CDEV_EXCLUSIVE_OPEN = 1,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* Is device open? Used to prevent multiple access to device */</span><br><span class="line">static atomic_t already_open = ATOMIC_INIT(CDEV_NOT_USED);</span><br><span class="line"></span><br><span class="line">static char msg[BUF_LEN + 1]; /* The msg the device will give when asked */</span><br><span class="line"></span><br><span class="line">static struct class *cls;</span><br><span class="line"></span><br><span class="line">static struct file_operations chardev_fops = &#123;</span><br><span class="line">    .read = device_read,</span><br><span class="line">    .write = device_write,</span><br><span class="line">    .open = device_open,</span><br><span class="line">    .release = device_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init chardev_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    major = register_chrdev(0, DEVICE_NAME, &amp;chardev_fops);</span><br><span class="line"></span><br><span class="line">    if (major &lt; 0) &#123;</span><br><span class="line">        pr_alert(&quot;Registering char device failed with %d\n&quot;, major);</span><br><span class="line">        return major;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(&quot;I was assigned major number %d.\n&quot;, major);</span><br><span class="line"></span><br><span class="line">#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(6, 4, 0)</span><br><span class="line">    cls = class_create(DEVICE_NAME);</span><br><span class="line">#else</span><br><span class="line">    cls = class_create(THIS_MODULE, DEVICE_NAME);</span><br><span class="line">#endif</span><br><span class="line">    device_create(cls, NULL, MKDEV(major, 0), NULL, DEVICE_NAME);</span><br><span class="line"></span><br><span class="line">    pr_info(&quot;Device created on /dev/%s\n&quot;, DEVICE_NAME);</span><br><span class="line"></span><br><span class="line">    return SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit chardev_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(cls, MKDEV(major, 0));</span><br><span class="line">    class_destroy(cls);</span><br><span class="line"></span><br><span class="line">    /* Unregister the device */</span><br><span class="line">    unregister_chrdev(major, DEVICE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Methods */</span><br><span class="line"></span><br><span class="line">/* Called when a process tries to open the device file, like</span><br><span class="line"> * &quot;sudo cat /dev/chardev&quot;</span><br><span class="line"> */</span><br><span class="line">static int device_open(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">    static int counter = 0;</span><br><span class="line"></span><br><span class="line">    if (atomic_cmpxchg(&amp;already_open, CDEV_NOT_USED, CDEV_EXCLUSIVE_OPEN))</span><br><span class="line">        return -EBUSY;</span><br><span class="line"></span><br><span class="line">    sprintf(msg, &quot;I already told you %d times Hello world!\n&quot;, counter++);</span><br><span class="line">    try_module_get(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">    return SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Called when a process closes the device file. */</span><br><span class="line">static int device_release(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">    /* We&#x27;re now ready for our next caller */</span><br><span class="line">    atomic_set(&amp;already_open, CDEV_NOT_USED);</span><br><span class="line"></span><br><span class="line">    /* Decrement the usage count, or else once you opened the file, you will</span><br><span class="line">     * never get rid of the module.</span><br><span class="line">     */</span><br><span class="line">    module_put(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">    return SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Called when a process, which already opened the dev file, attempts to</span><br><span class="line"> * read from it.</span><br><span class="line"> */</span><br><span class="line">static ssize_t device_read(struct file *filp, /* see include/linux/fs.h   */</span><br><span class="line">                           char __user *buffer, /* buffer to fill with data */</span><br><span class="line">                           size_t length, /* length of the buffer     */</span><br><span class="line">                           loff_t *offset)</span><br><span class="line">&#123;</span><br><span class="line">    /* Number of bytes actually written to the buffer */</span><br><span class="line">    int bytes_read = 0;</span><br><span class="line">    const char *msg_ptr = msg;</span><br><span class="line"></span><br><span class="line">    if (!*(msg_ptr + *offset)) &#123; /* we are at the end of message */</span><br><span class="line">        *offset = 0; /* reset the offset */</span><br><span class="line">        return 0; /* signify end of file */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg_ptr += *offset;</span><br><span class="line"></span><br><span class="line">    /* Actually put the data into the buffer */</span><br><span class="line">    while (length &amp;&amp; *msg_ptr) &#123;</span><br><span class="line">        /* The buffer is in the user data segment, not the kernel</span><br><span class="line">         * segment so &quot;*&quot; assignment won&#x27;t work.  We have to use</span><br><span class="line">         * put_user which copies data from the kernel data segment to</span><br><span class="line">         * the user data segment.</span><br><span class="line">         */</span><br><span class="line">        put_user(*(msg_ptr++), buffer++);</span><br><span class="line">        length--;</span><br><span class="line">        bytes_read++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *offset += bytes_read;</span><br><span class="line"></span><br><span class="line">    /* Most read functions return the number of bytes put into the buffer. */</span><br><span class="line">    return bytes_read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Called when a process writes to dev file: echo &quot;hi&quot; &gt; /dev/hello */</span><br><span class="line">static ssize_t device_write(struct file *filp, const char __user *buff,</span><br><span class="line">                            size_t len, loff_t *off)</span><br><span class="line">&#123;</span><br><span class="line">    pr_alert(&quot;Sorry, this operation is not supported.\n&quot;);</span><br><span class="line">    return -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(chardev_init);</span><br><span class="line">module_exit(chardev_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="6-6-Writing-Modules-for-Multiple-Kernel-Versions"><a href="#6-6-Writing-Modules-for-Multiple-Kernel-Versions" class="headerlink" title="6.6 Writing Modules for Multiple Kernel Versions"></a>6.6 Writing Modules for Multiple Kernel Versions</h4><p>6.6 为多个内核版本编写模块</p>
<p>The system calls, which are the major interface the kernel shows to the processes, generally stay the same across versions. A new system call may be added, but usually the old ones will behave exactly like they used to. This is necessary for backward compatibility – a new kernel version is not supposed to break regular processes. In most cases, the device files will also remain the same. On the other hand, the internal interfaces within the kernel can and do change between versions.<br>系统调用是内核向进程显示的主要接口，通常在各个版本中保持相同。可能会添加新的系统调用，但通常旧的系统调用的行为与以前完全相同。这对于向后兼容是必要的——新的内核版本不应该破坏常规进程。在大多数情况下，设备文件也将保持不变。另一方面，内核中的内部接口可以并且确实在版本之间发生变化。</p>
<p>There are differences between different kernel versions, and if you want to support multiple kernel versions, you will find yourself having to code conditional compilation directives. The way to do this to compare the macro <code>LINUX_VERSION_CODE</code> to the macro <code>KERNEL_VERSION</code> . In version a.b.c of the kernel, the value of this macro would be <img src="https://sysprog21.github.io/lkmpg/lkmpg-for-ht0x.svg" alt="216a+ 28b+ c  ">.<br>不同的内核版本之间存在差异，如果你想支持多个内核版本，你会发现自己必须编写条件编译指令。执行此操作的方法是将宏 <code>LINUX_VERSION_CODE</code> 与宏 <code>KERNEL_VERSION</code> 进行比较。在内核版本 a.b.c 中，该宏的值为 <img src="https://sysprog21.github.io/lkmpg/lkmpg-for-ht0x.svg" alt="216a+ 28b+ c  "> 。</p>
<h3 id="7-The-x2F-proc-File-System"><a href="#7-The-x2F-proc-File-System" class="headerlink" title="7 The &#x2F;proc File System"></a>7 The &#x2F;proc File System</h3><p>7 &#x2F;proc 文件系统</p>
<p>In Linux, there is an additional mechanism for the kernel and kernel modules to send information to processes — the &#x2F;proc file system. Originally designed to allow easy access to information about processes (hence the name), it is now used by every bit of the kernel which has something interesting to report, such as &#x2F;proc&#x2F;modules which provides the list of modules and &#x2F;proc&#x2F;meminfo which gathers memory usage statistics.<br>在 Linux 中，内核和内核模块有一个额外的机制来向进程发送信息 - &#x2F;proc 文件系统。最初的设计目的是允许轻松访问有关进程的信息（因此得名），现在它被内核的每个部分使用，其中有一些有趣的报告，例如提供模块列表的 &#x2F;proc&#x2F;modules 和 &#x2F;proc&#x2F;meminfo 它收集内存使用统计信息。</p>
<p>The method to use the proc file system is very similar to the one used with device drivers — a structure is created with all the information needed for the &#x2F;proc file, including pointers to any handler functions (in our case there is only one, the one called when somebody attempts to read from the &#x2F;proc file). Then, <code>init_module</code> registers the structure with the kernel and <code>cleanup_module</code> unregisters it.<br>使用 proc 文件系统的方法与设备驱动程序使用的方法非常相似 — 使用 &#x2F;proc 文件所需的所有信息创建一个结构，包括指向任何处理函数的指针（在我们的例子中只有一个，当有人尝试读取 &#x2F;proc 文件时调用）。然后， <code>init_module</code> 向内核注册该结构并 <code>cleanup_module</code> 取消注册它。</p>
<p>Normal file systems are located on a disk, rather than just in memory (which is where &#x2F;proc is), and in that case the index-node (inode for short) number is a pointer to a disk location where the file’s inode is located. The inode contains information about the file, for example the file’s permissions, together with a pointer to the disk location or locations where the file’s data can be found.<br>普通文件系统位于磁盘上，而不仅仅是内存中（&#x2F;proc 所在的位置），在这种情况下，索引节点（简称 inode）编号是指向文件 inode 所在磁盘位置的指针。索引节点包含有关文件的信息，例如文件的权限，以及指向磁盘位置或可以找到文件数据的位置的指针。</p>
<p>Because we don’t get called when the file is opened or closed, there’s nowhere for us to put <code>try_module_get</code> and <code>module_put</code> in this module, and if the file is opened and then the module is removed, there’s no way to avoid the consequences.<br>因为当文件打开或关闭时我们不会被调用，所以我们没有地方可以将 <code>try_module_get</code> 和 <code>module_put</code> 放入此模块中，并且如果打开文件然后模块被删除了，后果是无法避免的。</p>
<p>Here a simple example showing how to use a &#x2F;proc file. This is the HelloWorld for the &#x2F;proc filesystem. There are three parts: create the file &#x2F;proc&#x2F;helloworld in the function <code>init_module</code> , return a value (and a buffer) when the file &#x2F;proc&#x2F;helloworld is read in the callback function <code>procfile_read</code> , and delete the file &#x2F;proc&#x2F;helloworld in the function <code>cleanup_module</code> .<br>这里有一个简单的例子展示如何使用 &#x2F;proc 文件。这是 &#x2F;proc 文件系统的 HelloWorld。分为三个部分：在函数 <code>init_module</code> 中创建文件 &#x2F;proc&#x2F;helloworld，在回调函数中读取文件 &#x2F;proc&#x2F;helloworld 时返回一个值（和一个缓冲区） <code>procfile_read</code> ，并删除函数 <code>cleanup_module</code> 中的文件 &#x2F;proc&#x2F;helloworld 。</p>
<p>The &#x2F;proc&#x2F;helloworld is created when the module is loaded with the function <code>proc_create</code> . The return value is a <code>struct proc_dir_entry</code> , and it will be used to configure the file &#x2F;proc&#x2F;helloworld (for example, the owner of this file). A null return value means that the creation has failed.<br>&#x2F;proc&#x2F;helloworld 在使用函数 <code>proc_create</code> 加载模块时创建。返回值是 <code>struct proc_dir_entry</code> ，它将用于配置文件 &#x2F;proc&#x2F;helloworld （例如，该文件的所有者）。如果返回值为空，则表示创建失败。</p>
<p>Every time the file &#x2F;proc&#x2F;helloworld is read, the function <code>procfile_read</code> is called. Two parameters of this function are very important: the buffer (the second parameter) and the offset (the fourth one). The content of the buffer will be returned to the application which read it (for example the <code>cat</code> command). The offset is the current position in the file. If the return value of the function is not null, then this function is called again. So be careful with this function, if it never returns zero, the read function is called endlessly.<br>每次读取文件 &#x2F;proc&#x2F;helloworld 时，都会调用函数 <code>procfile_read</code> 。该函数有两个参数非常重要：缓冲区（第二个参数）和偏移量（第四个参数）。缓冲区的内容将返回到读取它的应用程序（例如 <code>cat</code> 命令）。偏移量是文件中的当前位置。如果函数的返回值不为空，则再次调用该函数。所以要小心这个函数，如果它从不返回零，那么读取函数就会被无休止地调用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/helloworld</span><br><span class="line">HelloWorld!</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * procfs1.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_PROC_OPS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> procfs_name <span class="string">&quot;helloworld&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">our_proc_file</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">procfile_read</span><span class="params">(<span class="keyword">struct</span> file *file_pointer, <span class="type">char</span> __user *buffer,</span></span><br><span class="line"><span class="params">                             <span class="type">size_t</span> buffer_length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">13</span>] = <span class="string">&quot;HelloWorld!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(s);</span><br><span class="line">    <span class="type">ssize_t</span> ret = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*offset &gt;= len || copy_to_user(buffer, s, len)) &#123;</span><br><span class="line">        pr_info(<span class="string">&quot;copy_to_user failed\n&quot;</span>);</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pr_info(<span class="string">&quot;procfile read %s\n&quot;</span>, file_pointer-&gt;f_path.dentry-&gt;d_name.name);</span><br><span class="line">        *offset += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PROC_OPS</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">proc_file_fops</span> =</span> &#123;</span><br><span class="line">    .proc_read = procfile_read,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_file_fops</span> =</span> &#123;</span><br><span class="line">    .read = procfile_read,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">procfs1_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    our_proc_file = proc_create(procfs_name, <span class="number">0644</span>, <span class="literal">NULL</span>, &amp;proc_file_fops);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == our_proc_file) &#123;</span><br><span class="line">        proc_remove(our_proc_file);</span><br><span class="line">        pr_alert(<span class="string">&quot;Error:Could not initialize /proc/%s\n&quot;</span>, procfs_name);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;/proc/%s created\n&quot;</span>, procfs_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">procfs1_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    proc_remove(our_proc_file);</span><br><span class="line">    pr_info(<span class="string">&quot;/proc/%s removed\n&quot;</span>, procfs_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(procfs1_init);</span><br><span class="line">module_exit(procfs1_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="7-1-The-proc-ops-Structure"><a href="#7-1-The-proc-ops-Structure" class="headerlink" title="7.1 The proc_ops Structure"></a>7.1 The proc_ops Structure</h4><p>7.1 proc_ops 结构</p>
<p>The <code>proc_ops</code> structure is defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/proc_fs.h">include&#x2F;linux&#x2F;proc_fs.h</a> in Linux v5.6+. In older kernels, it used <code>file_operations</code> for custom hooks in &#x2F;proc file system, but it contains some members that are unnecessary in VFS, and every time VFS expands <code>file_operations</code> set, &#x2F;proc code comes bloated. On the other hand, not only the space, but also some operations were saved by this structure to improve its performance. For example, the file which never disappears in &#x2F;proc can set the <code>proc_flag</code> as <code>PROC_ENTRY_PERMANENT</code> to save 2 atomic ops, 1 allocation, 1 free in per open&#x2F;read&#x2F;close sequence.<br><code>proc_ops</code> 结构在 Linux v5.6+ 中的 include&#x2F;linux&#x2F;proc_fs.h 中定义。在较旧的内核中，它使用 <code>file_operations</code> 进行 &#x2F;proc 文件系统中的自定义挂钩，但它包含一些 VFS 中不需要的成员，并且每次 VFS 扩展 <code>file_operations</code> 设置时，&#x2F;proc 代码变得臃肿。另一方面，这种结构不仅节省了空间，还节省了一些操作，提高了性能。例如，&#x2F;proc 中永不消失的文件可以将 <code>proc_flag</code> 设置为 <code>PROC_ENTRY_PERMANENT</code> ，以在每个打开&#x2F;读取&#x2F;关闭序列中保存 2 个原子操作、1 个分配、1 个空闲。</p>
<h4 id="7-2-Read-and-Write-a-x2F-proc-File"><a href="#7-2-Read-and-Write-a-x2F-proc-File" class="headerlink" title="7.2 Read and Write a &#x2F;proc File"></a>7.2 Read and Write a &#x2F;proc File</h4><p>7.2 读写 &#x2F;proc 文件</p>
<p>We have seen a very simple example for a &#x2F;proc file where we only read the file &#x2F;proc&#x2F;helloworld. It is also possible to write in a &#x2F;proc file. It works the same way as read, a function is called when the &#x2F;proc file is written. But there is a little difference with read, data comes from user, so you have to import data from user space to kernel space (with <code>copy_from_user</code> or <code>get_user</code> )<br>我们已经看到了一个非常简单的 &#x2F;proc 文件示例，其中我们只读取文件 &#x2F;proc&#x2F;helloworld。也可以写入 &#x2F;proc 文件中。它的工作方式与 read 相同，当写入&#x2F;proc 文件时调用一个函数。但是和 read 有一点区别，数据来自用户，所以你必须将数据从用户空间导入到内核空间（使用 <code>copy_from_user</code> 或 <code>get_user</code> ）</p>
<p>The reason for <code>copy_from_user</code> or <code>get_user</code> is that Linux memory (on Intel architecture, it may be different under some other processors) is segmented. This means that a pointer, by itself, does not reference a unique location in memory, only a location in a memory segment, and you need to know which memory segment it is to be able to use it. There is one memory segment for the kernel, and one for each of the processes.<br><code>copy_from_user</code> 或 <code>get_user</code> 的原因是 Linux 内存（在 Intel 架构上，在某些其他处理器下可能有所不同）是分段的。这意味着指针本身并不引用内存中的唯一位置，而仅引用内存段中的位置，并且您需要知道它是哪个内存段才能使用它。内核有一个内存段，每个进程也有一个内存段。</p>
<p>The only memory segment accessible to a process is its own, so when writing regular programs to run as processes, there is no need to worry about segments. When you write a kernel module, normally you want to access the kernel memory segment, which is handled automatically by the system. However, when the content of a memory buffer needs to be passed between the currently running process and the kernel, the kernel function receives a pointer to the memory buffer which is in the process segment. The <code>put_user</code> and <code>get_user</code> macros allow you to access that memory. These functions handle only one character, you can handle several characters with <code>copy_to_user</code> and <code>copy_from_user</code> . As the buffer (in read or write function) is in kernel space, for write function you need to import data because it comes from user space, but not for the read function because data is already in kernel space.<br>进程可以访问的唯一内存段是它自己的内存段，因此在编写常规程序作为进程运行时，无需担心段。当你编写内核模块时，通常你想要访问内核内存段，这是由系统自动处理的。然而，当内存缓冲区的内容需要在当前运行的进程和内核之间传递时，内核函数会收到一个指向进程段中的内存缓冲区的指针。 <code>put_user</code> 和 <code>get_user</code> 宏允许您访问该内存。这些函数仅处理一个字符，您可以使用 <code>copy_to_user</code> 和 <code>copy_from_user</code> 处理多个字符。由于缓冲区（在读或写函数中）位于内核空间中，因此对于写函数，您需要导入数据，因为它来自用户空间，但对于读函数则不需要导入数据，因为数据已经在内核空间中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * procfs2.c -  create a &quot;file&quot; in /proc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">/* We&#x27;re doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span> <span class="comment">/* Necessary because we use the proc fs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> <span class="comment">/* for copy_from_user */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_PROC_OPS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_MAX_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_NAME <span class="string">&quot;buffer1k&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This structure hold information about the /proc file */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">our_proc_file</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The buffer used to store character for this module */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> procfs_buffer[PROCFS_MAX_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The size of the buffer */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> procfs_buffer_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called then the /proc file is read */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">procfile_read</span><span class="params">(<span class="keyword">struct</span> file *file_pointer, <span class="type">char</span> __user *buffer,</span></span><br><span class="line"><span class="params">                             <span class="type">size_t</span> buffer_length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">13</span>] = <span class="string">&quot;HelloWorld!\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(s);</span><br><span class="line">    <span class="type">ssize_t</span> ret = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*offset &gt;= len || copy_to_user(buffer, s, len)) &#123;</span><br><span class="line">        pr_info(<span class="string">&quot;copy_to_user failed\n&quot;</span>);</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pr_info(<span class="string">&quot;procfile read %s\n&quot;</span>, file_pointer-&gt;f_path.dentry-&gt;d_name.name);</span><br><span class="line">        *offset += len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called with the /proc file is written. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">procfile_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buff,</span></span><br><span class="line"><span class="params">                              <span class="type">size_t</span> len, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    procfs_buffer_size = len;</span><br><span class="line">    <span class="keyword">if</span> (procfs_buffer_size &gt; PROCFS_MAX_SIZE)</span><br><span class="line">        procfs_buffer_size = PROCFS_MAX_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(procfs_buffer, buff, procfs_buffer_size))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    procfs_buffer[procfs_buffer_size &amp; (PROCFS_MAX_SIZE - <span class="number">1</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    *off += procfs_buffer_size;</span><br><span class="line">    pr_info(<span class="string">&quot;procfile write %s\n&quot;</span>, procfs_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> procfs_buffer_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PROC_OPS</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">proc_file_fops</span> =</span> &#123;</span><br><span class="line">    .proc_read = procfile_read,</span><br><span class="line">    .proc_write = procfile_write,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_file_fops</span> =</span> &#123;</span><br><span class="line">    .read = procfile_read,</span><br><span class="line">    .write = procfile_write,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">procfs2_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    our_proc_file = proc_create(PROCFS_NAME, <span class="number">0644</span>, <span class="literal">NULL</span>, &amp;proc_file_fops);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == our_proc_file) &#123;</span><br><span class="line">        pr_alert(<span class="string">&quot;Error:Could not initialize /proc/%s\n&quot;</span>, PROCFS_NAME);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;/proc/%s created\n&quot;</span>, PROCFS_NAME);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">procfs2_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    proc_remove(our_proc_file);</span><br><span class="line">    pr_info(<span class="string">&quot;/proc/%s removed\n&quot;</span>, PROCFS_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(procfs2_init);</span><br><span class="line">module_exit(procfs2_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="7-3-Manage-x2F-proc-file-with-standard-filesystem"><a href="#7-3-Manage-x2F-proc-file-with-standard-filesystem" class="headerlink" title="7.3 Manage &#x2F;proc file with standard filesystem"></a>7.3 Manage &#x2F;proc file with standard filesystem</h4><p>7.3 使用标准文件系统管理 &#x2F;proc 文件</p>
<p>We have seen how to read and write a &#x2F;proc file with the &#x2F;proc interface. But it is also possible to manage &#x2F;proc file with inodes. The main concern is to use advanced functions, like permissions.<br>我们已经了解了如何使用 &#x2F;proc 接口读写 &#x2F;proc 文件。但也可以使用 inode 来管理 &#x2F;proc 文件。主要关注的是使用高级功能，例如权限。</p>
<p>In Linux, there is a standard mechanism for file system registration. Since every file system has to have its own functions to handle inode and file operations, there is a special structure to hold pointers to all those functions, <code>struct inode_operations</code> , which includes a pointer to <code>struct proc_ops</code> .<br>在 Linux 中，有一个标准的文件系统注册机制。由于每个文件系统都必须有自己的函数来处理 inode 和文件操作，因此有一个特殊的结构来保存指向所有这些函数的指针 <code>struct inode_operations</code> ，其中包括指向 <code>struct proc_ops</code> 的指针。</p>
<p>The difference between file and inode operations is that file operations deal with the file itself whereas inode operations deal with ways of referencing the file, such as creating links to it.<br>文件和索引节点操作之间的区别在于，文件操作处理文件本身，而索引节点操作处理引用文件的方式，例如创建指向文件的链接。</p>
<p>In &#x2F;proc, whenever we register a new file, we’re allowed to specify which <code>struct inode_operations</code> will be used to access to it. This is the mechanism we use, a <code>struct inode_operations</code> which includes a pointer to a <code>struct proc_ops</code> which includes pointers to our <code>procf_read</code> and <code>procfs_write</code> functions.<br>在 &#x2F;proc 中，每当我们注册一个新文件时，我们都可以指定使用哪个 <code>struct inode_operations</code> 来访问它。这是我们使用的机制， <code>struct inode_operations</code> 包含指向 <code>struct proc_ops</code> 的指针，而 <code>struct proc_ops</code> 包含指向 <code>procf_read</code> 和 <code>procfs_write</code> 函数的指针。</p>
<p>Another interesting point here is the <code>module_permission</code> function. This function is called whenever a process tries to do something with the &#x2F;proc file, and it can decide whether to allow access or not. Right now it is only based on the operation and the uid of the current user (as available in current, a pointer to a structure which includes information on the currently running process), but it could be based on anything we like, such as what other processes are doing with the same file, the time of day, or the last input we received.<br>这里另一个有趣的点是 <code>module_permission</code> 函数。每当进程尝试对 &#x2F;proc 文件执行某些操作时都会调用此函数，并且它可以决定是否允许访问。现在它仅基于当前用户的操作和 uid（在 current 中可用，指向包含当前正在运行的进程的信息的结构的指针），但它可以基于我们喜欢的任何内容，例如其他进程正在处理同一文件、一天中的时间或我们收到的最后一个输入。</p>
<p>It is important to note that the standard roles of read and write are reversed in the kernel. Read functions are used for output, whereas write functions are used for input. The reason for that is that read and write refer to the user’s point of view — if a process reads something from the kernel, then the kernel needs to output it, and if a process writes something to the kernel, then the kernel receives it as input.<br>值得注意的是，读和写的标准角色在内核中是相反的。读函数用于输出，而写函数用于输入。原因是读和写是指用户的观点——如果一个进程从内核读取一些东西，那么内核需要输出它，如果一个进程向内核写一些东西，那么内核会接收它输入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * procfs3.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 10, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/minmax.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_PROC_OPS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_MAX_SIZE 2048UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCFS_ENTRY_FILENAME <span class="string">&quot;buffer2k&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">our_proc_file</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> procfs_buffer[PROCFS_MAX_SIZE];</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> procfs_buffer_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">procfs_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buffer,</span></span><br><span class="line"><span class="params">                           <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*offset || procfs_buffer_size == <span class="number">0</span>) &#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;procfs_read: END\n&quot;</span>);</span><br><span class="line">        *offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    procfs_buffer_size = min(procfs_buffer_size, length);</span><br><span class="line">    <span class="keyword">if</span> (copy_to_user(buffer, procfs_buffer, procfs_buffer_size))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    *offset += procfs_buffer_size;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;procfs_read: read %lu bytes\n&quot;</span>, procfs_buffer_size);</span><br><span class="line">    <span class="keyword">return</span> procfs_buffer_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">procfs_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer,</span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span> len, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    procfs_buffer_size = min(PROCFS_MAX_SIZE, len);</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(procfs_buffer, buffer, procfs_buffer_size))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    *off += procfs_buffer_size;</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;procfs_write: write %lu bytes\n&quot;</span>, procfs_buffer_size);</span><br><span class="line">    <span class="keyword">return</span> procfs_buffer_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">procfs_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    try_module_get(THIS_MODULE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">procfs_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    module_put(THIS_MODULE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PROC_OPS</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">file_ops_4_our_proc_file</span> =</span> &#123;</span><br><span class="line">    .proc_read = procfs_read,</span><br><span class="line">    .proc_write = procfs_write,</span><br><span class="line">    .proc_open = procfs_open,</span><br><span class="line">    .proc_release = procfs_close,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">file_ops_4_our_proc_file</span> =</span> &#123;</span><br><span class="line">    .read = procfs_read,</span><br><span class="line">    .write = procfs_write,</span><br><span class="line">    .open = procfs_open,</span><br><span class="line">    .release = procfs_close,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">procfs3_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    our_proc_file = proc_create(PROCFS_ENTRY_FILENAME, <span class="number">0644</span>, <span class="literal">NULL</span>,</span><br><span class="line">                                &amp;file_ops_4_our_proc_file);</span><br><span class="line">    <span class="keyword">if</span> (our_proc_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;Error: Could not initialize /proc/%s\n&quot;</span>,</span><br><span class="line">                 PROCFS_ENTRY_FILENAME);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    proc_set_size(our_proc_file, <span class="number">80</span>);</span><br><span class="line">    proc_set_user(our_proc_file, GLOBAL_ROOT_UID, GLOBAL_ROOT_GID);</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s created\n&quot;</span>, PROCFS_ENTRY_FILENAME);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">procfs3_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    remove_proc_entry(PROCFS_ENTRY_FILENAME, <span class="literal">NULL</span>);</span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s removed\n&quot;</span>, PROCFS_ENTRY_FILENAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(procfs3_init);</span><br><span class="line">module_exit(procfs3_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Still hungry for procfs examples? Well, first of all keep in mind, there are rumors around, claiming that procfs is on its way out, consider using sysfs instead. Consider using this mechanism, in case you want to document something kernel related yourself.<br>仍然渴望 procfs 示例吗？好吧，首先请记住，有传言称 procfs 即将被淘汰，请考虑使用 sysfs。如果您想自己记录与内核相关的内容，请考虑使用此机制。</p>
<h4 id="7-4-Manage-x2F-proc-file-with-seq-file"><a href="#7-4-Manage-x2F-proc-file-with-seq-file" class="headerlink" title="7.4 Manage &#x2F;proc file with seq_file"></a>7.4 Manage &#x2F;proc file with seq_file</h4><p>7.4 使用 seq_file 管理&#x2F;proc 文件</p>
<p>As we have seen, writing a &#x2F;proc file may be quite “complex”. So to help people writing &#x2F;proc file, there is an API named <code>seq_file</code> that helps formatting a &#x2F;proc file for output. It is based on sequence, which is composed of 3 functions: <code>start()</code> , <code>next()</code> , and <code>stop()</code> . The <code>seq_file</code> API starts a sequence when a user read the &#x2F;proc file.<br>正如我们所见，编写 &#x2F;proc 文件可能相当“复杂”。因此，为了帮助人们编写 &#x2F;proc 文件，有一个名为 <code>seq_file</code> 的 API 可以帮助格式化 &#x2F;proc 文件以进行输出。它基于序列，由 3 个函数组成： <code>start()</code> 、 <code>next()</code> 和 <code>stop()</code> 。当用户读取 &#x2F;proc 文件时， <code>seq_file</code> API 启动一个序列。</p>
<p>A sequence begins with the call of the function <code>start()</code> . If the return is a non <code>NULL</code> value, the function <code>next()</code> is called. This function is an iterator, the goal is to go through all the data. Each time <code>next()</code> is called, the function <code>show()</code> is also called. It writes data values in the buffer read by the user. The function <code>next()</code> is called until it returns <code>NULL</code> . The sequence ends when <code>next()</code> returns <code>NULL</code> , then the function <code>stop()</code> is called.<br>序列以调用函数 <code>start()</code> 开始。如果返回的是非 <code>NULL</code> 值，则调用函数 <code>next()</code> 。该函数是一个迭代器，目标是遍历所有数据。每次调用 <code>next()</code> 时，也会调用函数 <code>show()</code> 。它将数据值写入用户读取的缓冲区中。调用函数 <code>next()</code> 直到返回 <code>NULL</code> 。当 <code>next()</code> 返回 <code>NULL</code> 时序列结束，然后调用函数 <code>stop()</code> 。</p>
<p>BE CAREFUL: when a sequence is finished, another one starts. That means that at the end of function <code>stop()</code> , the function <code>start()</code> is called again. This loop finishes when the function <code>start()</code> returns <code>NULL</code> . You can see a scheme of this in the Figure <a href="https://sysprog21.github.io/lkmpg/#ignorespaces-how-seqfile-works">1</a>.<br>请注意：一个序列完成后，另一个序列就会开始。这意味着在函数 <code>stop()</code> 结束时，函数 <code>start()</code> 被再次调用。当函数 <code>start()</code> 返回 <code>NULL</code> 时，此循环结束。您可以在图 1 中看到该方案。</p>
<p><img src="https://sysprog21.github.io/lkmpg/lkmpg-for-ht1x.svg" alt="srYrsNNYtaeenetoooertusetupstrxr((ntn))( tis)istrr teeaNreNatUaUtmLtLmeLmLen?e?ntntt  "></p>
<p>Figure 1:How seq_file works<br>图 1：seq_file 的工作原理</p>
<p>The <code>seq_file</code> provides basic functions for <code>proc_ops</code> , such as <code>seq_read</code> , <code>seq_lseek</code> , and some others. But nothing to write in the &#x2F;proc file. Of course, you can still use the same way as in the previous example.<br><code>seq_file</code> 为 <code>proc_ops</code> 提供基本功能，例如 <code>seq_read</code> 、 <code>seq_lseek</code> 等。但 &#x2F;proc 文件中没有任何内容可写。当然，您仍然可以使用与上一个示例相同的方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * procfs4.c -  create a &quot;file&quot; in /proc</span></span><br><span class="line"><span class="comment"> * This program uses the seq_file library to manage the /proc file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">/* We are doing kernel work */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span> <span class="comment">/* Necessary because we use proc fs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span> <span class="comment">/* for seq_file */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_PROC_OPS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROC_NAME <span class="string">&quot;iter&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called at the beginning of a sequence.</span></span><br><span class="line"><span class="comment"> * ie, when:</span></span><br><span class="line"><span class="comment"> *   - the /proc file is read (first time)</span></span><br><span class="line"><span class="comment"> *   - after the function stop (end of sequence)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">my_seq_start</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* beginning a new sequence? */</span></span><br><span class="line">    <span class="keyword">if</span> (*pos == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* yes =&gt; return a non null value to begin the sequence */</span></span><br><span class="line">        <span class="keyword">return</span> &amp;counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* no =&gt; it is the end of the sequence, return end to stop reading */</span></span><br><span class="line">    *pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called after the beginning of a sequence.</span></span><br><span class="line"><span class="comment"> * It is called untill the return is NULL (this ends the sequence).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">my_seq_next</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *tmp_v = (<span class="type">unsigned</span> <span class="type">long</span> *)v;</span><br><span class="line">    (*tmp_v)++;</span><br><span class="line">    (*pos)++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called at the end of a sequence. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_seq_stop</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* nothing to do, we use a static value in start() */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called for each &quot;step&quot; of a sequence. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_seq_show</span><span class="params">(<span class="keyword">struct</span> seq_file *s, <span class="type">void</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">loff_t</span> *spos = (<span class="type">loff_t</span> *)v;</span><br><span class="line"></span><br><span class="line">    seq_printf(s, <span class="string">&quot;%Ld\n&quot;</span>, *spos);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This structure gather &quot;function&quot; to manage the sequence */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> <span class="title">my_seq_ops</span> =</span> &#123;</span><br><span class="line">    .start = my_seq_start,</span><br><span class="line">    .next = my_seq_next,</span><br><span class="line">    .stop = my_seq_stop,</span><br><span class="line">    .show = my_seq_show,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called when the /proc file is open. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> seq_open(file, &amp;my_seq_ops);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This structure gather &quot;function&quot; that manage the /proc file */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PROC_OPS</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">my_file_ops</span> =</span> &#123;</span><br><span class="line">    .proc_open = my_open,</span><br><span class="line">    .proc_read = seq_read,</span><br><span class="line">    .proc_lseek = seq_lseek,</span><br><span class="line">    .proc_release = seq_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">my_file_ops</span> =</span> &#123;</span><br><span class="line">    .open = my_open,</span><br><span class="line">    .read = seq_read,</span><br><span class="line">    .llseek = seq_lseek,</span><br><span class="line">    .release = seq_release,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">procfs4_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line">    entry = proc_create(PROC_NAME, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;my_file_ops);</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;Error: Could not initialize /proc/%s\n&quot;</span>, PROC_NAME);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">procfs4_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    remove_proc_entry(PROC_NAME, <span class="literal">NULL</span>);</span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s removed\n&quot;</span>, PROC_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(procfs4_init);</span><br><span class="line">module_exit(procfs4_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>If you want more information, you can read this web page:<br>如果您想了解更多信息，您可以阅读此网页：</p>
<ul>
<li><a href="https://lwn.net/Articles/22355/">https://lwn.net/Articles/22355/</a></li>
<li><a href="https://kernelnewbies.org/Documents/SeqFileHowTo">https://kernelnewbies.org/Documents/SeqFileHowTo</a></li>
</ul>
<p>You can also read the code of <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/fs/seq_file.c">fs&#x2F;seq_file.c</a> in the linux kernel.<br>您还可以阅读 linux 内核中的 fs&#x2F;seq_file.c 的代码。</p>
<h3 id="8-sysfs-Interacting-with-your-module"><a href="#8-sysfs-Interacting-with-your-module" class="headerlink" title="8 sysfs: Interacting with your module"></a>8 sysfs: Interacting with your module</h3><p>8 sysfs：与模块交互</p>
<p>sysfs allows you to interact with the running kernel from userspace by reading or setting variables inside of modules. This can be useful for debugging purposes, or just as an interface for applications or scripts. You can find sysfs directories and files under the &#x2F;sys directory on your system.<br>sysfs 允许您通过读取或设置模块内部的变量来从用户空间与正在运行的内核进行交互。这对于调试目的很有用，或者只是作为应用程序或脚本的接口。您可以在系统的 &#x2F;sys 目录下找到 sysfs 目录和文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l /sys</span><br></pre></td></tr></table></figure>

<p>Attributes can be exported for kobjects in the form of regular files in the filesystem. Sysfs forwards file I&#x2F;O operations to methods defined for the attributes, providing a means to read and write kernel attributes.<br>可以以文件系统中常规文件的形式导出 kobject 的属性。 Sysfs 将文件 I&#x2F;O 操作转发给为属性定义的方法，提供读写内核属性的方法。</p>
<p>An attribute definition in simply:<br>简单的属性定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">umode_t</span> mode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysfs_create_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="type">const</span> <span class="keyword">struct</span> attribute * attr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sysfs_remove_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="type">const</span> <span class="keyword">struct</span> attribute * attr)</span>;</span><br></pre></td></tr></table></figure>

<p>For example, the driver model defines <code>struct device_attribute</code> like:<br>例如，驱动程序模型定义 <code>struct device_attribute</code> 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line">                    <span class="type">char</span> *buf);</span><br><span class="line">    <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">device_create_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">device_remove_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *)</span>;</span><br></pre></td></tr></table></figure>

<p>To read or write attributes, <code>show()</code> or <code>store()</code> method must be specified when declaring the attribute. For the common cases <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/sysfs.h">include&#x2F;linux&#x2F;sysfs.h</a> provides convenience macros ( <code>__ATTR</code> , <code>__ATTR_RO</code> , <code>__ATTR_WO</code> , etc.) to make defining attributes easier as well as making code more concise and readable.<br>要读取或写入属性，必须在声明属性时指定 <code>show()</code> 或 <code>store()</code> 方法。对于常见情况，include&#x2F;linux&#x2F;sysfs.h 提供了方便的宏（ <code>__ATTR</code> 、 <code>__ATTR_RO</code> 、 <code>__ATTR_WO</code> 等），使定义属性更容易使代码更加简洁和可读。</p>
<p>An example of a hello world module which includes the creation of a variable accessible via sysfs is given below.<br>下面给出了一个 hello world 模块的示例，其中包括创建可通过 sysfs 访问的变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hello-sysfs.c sysfs example</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kobject.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sysfs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">mymodule</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* the variable you want to be able to change */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myvariable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">myvariable_show</span><span class="params">(<span class="keyword">struct</span> kobject *kobj,</span></span><br><span class="line"><span class="params">                               <span class="keyword">struct</span> kobj_attribute *attr, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d\n&quot;</span>, myvariable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">myvariable_store</span><span class="params">(<span class="keyword">struct</span> kobject *kobj,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> kobj_attribute *attr, <span class="type">char</span> *buf,</span></span><br><span class="line"><span class="params">                                <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%du&quot;</span>, &amp;myvariable);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_attribute</span> <span class="title">myvariable_attribute</span> =</span></span><br><span class="line">    __ATTR(myvariable, <span class="number">0660</span>, myvariable_show, (<span class="type">void</span> *)myvariable_store);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mymodule_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;mymodule: initialised\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mymodule = kobject_create_and_add(<span class="string">&quot;mymodule&quot;</span>, kernel_kobj);</span><br><span class="line">    <span class="keyword">if</span> (!mymodule)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    error = sysfs_create_file(mymodule, &amp;myvariable_attribute.attr);</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        pr_info(<span class="string">&quot;failed to create the myvariable file &quot;</span></span><br><span class="line">                <span class="string">&quot;in /sys/kernel/mymodule\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mymodule_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;mymodule: Exit success\n&quot;</span>);</span><br><span class="line">    kobject_put(mymodule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mymodule_init);</span><br><span class="line">module_exit(mymodule_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Make and install the module:<br>制作并安装模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">sudo insmod hello-sysfs.ko</span><br></pre></td></tr></table></figure>

<p>Check that it exists:<br>检查它是否存在：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo lsmod | grep hello_sysfs</span><br></pre></td></tr></table></figure>

<p>What is the current value of <code>myvariable</code> ?<br><code>myvariable</code> 的当前值是多少？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/kernel/mymodule/myvariable</span><br></pre></td></tr></table></figure>

<p>Set the value of <code>myvariable</code> and check that it changed.<br>设置 <code>myvariable</code> 的值并检查它是否改变。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;32&quot;</span> &gt; /sys/kernel/mymodule/myvariable</span><br><span class="line"><span class="built_in">cat</span> /sys/kernel/mymodule/myvariable</span><br></pre></td></tr></table></figure>

<p>Finally, remove the test module:<br>最后，删除测试模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rmmod hello_sysfs</span><br></pre></td></tr></table></figure>

<p>In the above case, we use a simple kobject to create a directory under sysfs, and communicate with its attributes. Since Linux v2.6.0, the <code>kobject</code> structure made its appearance. It was initially meant as a simple way of unifying kernel code which manages reference counted objects. After a bit of mission creep, it is now the glue that holds much of the device model and its sysfs interface together. For more information about kobject and sysfs, see <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/driver-api/driver-model/driver.rst">Documentation&#x2F;driver-api&#x2F;driver-model&#x2F;driver.rst</a> and <a href="https://lwn.net/Articles/51437/">https://lwn.net/Articles/51437/</a>.<br>在上面的例子中，我们使用一个简单的 kobject 在 sysfs 下创建一个目录，并与其属性进行通信。从 Linux v2.6.0 开始， <code>kobject</code> 结构出现了。它最初的目的是作为一种统一管理引用计数对象的内核代码的简单方法。经过一些任务的扩展之后，它现在成为将设备模型的大部分及其 sysfs 接口粘合在一起的粘合剂。有关 kobject 和 sysfs 的更多信息，请参阅 Documentation&#x2F;driver-api&#x2F;driver-model&#x2F;driver.rst 和 <a href="https://lwn.net/Articles/51437/%E3%80%82">https://lwn.net/Articles/51437/。</a></p>
<h3 id="9-Talking-To-Device-Files"><a href="#9-Talking-To-Device-Files" class="headerlink" title="9 Talking To Device Files"></a>9 Talking To Device Files</h3><p>9 与设备文件对话</p>
<p>Device files are supposed to represent physical devices. Most physical devices are used for output as well as input, so there has to be some mechanism for device drivers in the kernel to get the output to send to the device from processes. This is done by opening the device file for output and writing to it, just like writing to a file. In the following example, this is implemented by <code>device_write</code> .<br>设备文件应该代表物理设备。大多数物理设备都用于输出和输入，因此内核中的设备驱动程序必须有某种机制来获取输出以从进程发送到设备。这是通过打开设备文件进行输出并写入它来完成的，就像写入文件一样。在以下示例中，这是由 <code>device_write</code> 实现的。</p>
<p>This is not always enough. Imagine you had a serial port connected to a modem (even if you have an internal modem, it is still implemented from the CPU’s perspective as a serial port connected to a modem, so you don’t have to tax your imagination too hard). The natural thing to do would be to use the device file to write things to the modem (either modem commands or data to be sent through the phone line) and read things from the modem (either responses for commands or the data received through the phone line). However, this leaves open the question of what to do when you need to talk to the serial port itself, for example to configure the rate at which data is sent and received.<br>这并不总是足够的。想象一下您有一个连接到调制解调器的串行端口（即使您有一个内部调制解调器，从 CPU 的角度来看，它仍然是作为连接到调制解调器的串行端口实现的，因此您不必太考验您的想象力）。自然的做法是使用设备文件将内容写入调制解调器（调制解调器命令或通过电话线发送的数据）并从调制解调器读取内容（命令响应或通过电话接收的数据）线）。然而，这留下了一个问题：当您需要与串行端口本身通信时该怎么做，例如配置发送和接收数据的速率。</p>
<p>The answer in Unix is to use a special function called <code>ioctl</code> (short for Input Output ConTroL). Every device can have its own <code>ioctl</code> commands, which can be read ioctl’s (to send information from a process to the kernel), write ioctl’s (to return information to a process), both or neither. Notice here the roles of read and write are reversed again, so in ioctl’s read is to send information to the kernel and write is to receive information from the kernel.<br>Unix 中的答案是使用一个名为 <code>ioctl</code> 的特殊函数（Input Output ConTroL 的缩写）。每个设备都可以有自己的 <code>ioctl</code> 命令，这些命令可以读取 ioctl（将信息从进程发送到内核）、写入 ioctl（将信息返回给进程），或者两者都可以。注意这里读和写的角色又颠倒了，所以在 ioctl 中读是向内核发送信息，写是从内核接收信息。</p>
<p>The ioctl function is called with three parameters: the file descriptor of the appropriate device file, the ioctl number, and a parameter, which is of type long so you can use a cast to use it to pass anything. You will not be able to pass a structure this way, but you will be able to pass a pointer to the structure. Here is an example:<br>ioctl 函数使用三个参数调用：相应设备文件的文件描述符、ioctl 编号和一个参数，该参数的类型为 long，因此您可以使用强制转换来使用它来传递任何内容。您将无法以这种方式传递结构，但可以传递指向该结构的指针。这是一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ioctl.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ioctl_arg</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Documentation/userspace-api/ioctl/ioctl-number.rst */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC <span class="string">&#x27;\x66&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALSET _IOW(IOC_MAGIC, 0, struct ioctl_arg)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALGET _IOR(IOC_MAGIC, 1, struct ioctl_arg)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALGET_NUM _IOR(IOC_MAGIC, 2, int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VALSET_NUM _IOW(IOC_MAGIC, 3, int)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_VAL_MAXNR 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_NAME <span class="string">&quot;ioctltest&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> test_ioctl_major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> num_of_dev = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">test_ioctl_cdev</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ioctl_num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> val;</span><br><span class="line">    <span class="type">rwlock_t</span> lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">test_ioctl_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">                             <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> *<span class="title">ioctl_data</span> =</span> filp-&gt;private_data;</span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ioctl_arg</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;data, <span class="number">0</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALSET:</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;data, (<span class="type">int</span> __user *)arg, <span class="keyword">sizeof</span>(data))) &#123;</span><br><span class="line">            retval = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pr_alert(<span class="string">&quot;IOCTL set val:%x .\n&quot;</span>, data.val);</span><br><span class="line">        write_lock(&amp;ioctl_data-&gt;lock);</span><br><span class="line">        ioctl_data-&gt;val = data.val;</span><br><span class="line">        write_unlock(&amp;ioctl_data-&gt;lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALGET:</span><br><span class="line">        read_lock(&amp;ioctl_data-&gt;lock);</span><br><span class="line">        val = ioctl_data-&gt;val;</span><br><span class="line">        read_unlock(&amp;ioctl_data-&gt;lock);</span><br><span class="line">        data.val = val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user((<span class="type">int</span> __user *)arg, &amp;data, <span class="keyword">sizeof</span>(data))) &#123;</span><br><span class="line">            retval = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALGET_NUM:</span><br><span class="line">        retval = __put_user(ioctl_num, (<span class="type">int</span> __user *)arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> IOCTL_VALSET_NUM:</span><br><span class="line">        ioctl_num = arg;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        retval = -ENOTTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">test_ioctl_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">                               <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> *<span class="title">ioctl_data</span> =</span> filp-&gt;private_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> val;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    read_lock(&amp;ioctl_data-&gt;lock);</span><br><span class="line">    val = ioctl_data-&gt;val;</span><br><span class="line">    read_unlock(&amp;ioctl_data-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(&amp;buf[i], &amp;val, <span class="number">1</span>)) &#123;</span><br><span class="line">            retval = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    retval = count;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_ioctl_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_alert(<span class="string">&quot;%s call.\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;private_data) &#123;</span><br><span class="line">        kfree(filp-&gt;private_data);</span><br><span class="line">        filp-&gt;private_data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_ioctl_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_ioctl_data</span> *<span class="title">ioctl_data</span>;</span></span><br><span class="line"></span><br><span class="line">    pr_alert(<span class="string">&quot;%s call.\n&quot;</span>, __func__);</span><br><span class="line">    ioctl_data = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> test_ioctl_data), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioctl_data == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    rwlock_init(&amp;ioctl_data-&gt;lock);</span><br><span class="line">    ioctl_data-&gt;val = <span class="number">0xFF</span>;</span><br><span class="line">    filp-&gt;private_data = ioctl_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = test_ioctl_open,</span><br><span class="line">    .release = test_ioctl_close,</span><br><span class="line">    .read = test_ioctl_read,</span><br><span class="line">    .unlocked_ioctl = test_ioctl_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ioctl_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dev_t</span> dev;</span><br><span class="line">    <span class="type">int</span> alloc_ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> cdev_ret = <span class="number">-1</span>;</span><br><span class="line">    alloc_ret = alloc_chrdev_region(&amp;dev, <span class="number">0</span>, num_of_dev, DRIVER_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alloc_ret)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    test_ioctl_major = MAJOR(dev);</span><br><span class="line">    cdev_init(&amp;test_ioctl_cdev, &amp;fops);</span><br><span class="line">    cdev_ret = cdev_add(&amp;test_ioctl_cdev, dev, num_of_dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cdev_ret)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    pr_alert(<span class="string">&quot;%s driver(major: %d) installed.\n&quot;</span>, DRIVER_NAME,</span><br><span class="line">             test_ioctl_major);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">error:</span><br><span class="line">    <span class="keyword">if</span> (cdev_ret == <span class="number">0</span>)</span><br><span class="line">        cdev_del(&amp;test_ioctl_cdev);</span><br><span class="line">    <span class="keyword">if</span> (alloc_ret == <span class="number">0</span>)</span><br><span class="line">        unregister_chrdev_region(dev, num_of_dev);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ioctl_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dev_t</span> dev = MKDEV(test_ioctl_major, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cdev_del(&amp;test_ioctl_cdev);</span><br><span class="line">    unregister_chrdev_region(dev, num_of_dev);</span><br><span class="line">    pr_alert(<span class="string">&quot;%s driver removed.\n&quot;</span>, DRIVER_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(ioctl_init);</span><br><span class="line">module_exit(ioctl_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;This is test_ioctl module&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>You can see there is an argument called <code>cmd</code> in <code>test_ioctl_ioctl()</code> function. It is the ioctl number. The ioctl number encodes the major device number, the type of the ioctl, the command, and the type of the parameter. This ioctl number is usually created by a macro call ( <code>_IO</code> , <code>_IOR</code> , <code>_IOW</code> or <code>_IOWR</code> — depending on the type) in a header file. This header file should then be included both by the programs which will use ioctl (so they can generate the appropriate ioctl’s) and by the kernel module (so it can understand it). In the example below, the header file is chardev.h and the program which uses it is userspace_ioctl.c.<br>您可以看到 <code>test_ioctl_ioctl()</code> 函数中有一个名为 <code>cmd</code> 的参数。它是 ioctl 编号。 ioctl 编号编码主设备编号、ioctl 类型、命令和参数类型。此 ioctl 编号通常由宏调用（ <code>_IO</code> 、 <code>_IOR</code> 、 <code>_IOW</code> 或 <code>_IOWR</code> - 取决于类型）在头文件。然后，将使用 ioctl 的程序（以便它们可以生成适当的 ioctl）和内核模块（以便它可以理解它）都应该包含该头文件。在下面的示例中，头文件是 chardev.h，使用它的程序是 userspace_ioctl.c。</p>
<p>If you want to use ioctls in your own kernel modules, it is best to receive an official ioctl assignment, so if you accidentally get somebody else’s ioctls, or if they get yours, you’ll know something is wrong. For more information, consult the kernel source tree at <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/userspace-api/ioctl/ioctl-number.rst">Documentation&#x2F;userspace-api&#x2F;ioctl&#x2F;ioctl-number.rst</a>.<br>如果您想在自己的内核模块中使用 ioctl，最好接受官方的 ioctl 分配，因此，如果您不小心获得了别人的 ioctl，或者他们获得了您的 ioctl，您就会知道出了问题。有关更多信息，请参阅位于 Documentation&#x2F;userspace-api&#x2F;ioctl&#x2F;ioctl-number.rst 的内核源代码树。</p>
<p>Also, we need to be careful that concurrent access to the shared resources will lead to the race condition. The solution is using atomic Compare-And-Swap (CAS), which we mentioned at <a href="https://sysprog21.github.io/lkmpg/#chardevc">6.5</a> section, to enforce the exclusive access.<br>另外，我们需要注意对共享资源的并发访问会导致竞争条件。解决方案是使用我们在 6.5 节中提到的原子比较和交换 (CAS) 来强制执行独占访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * chardev2.c - Create an input/output character device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> <span class="comment">/* for get_user and put_user */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chardev.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;char_dev&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 80</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CDEV_NOT_USED = <span class="number">0</span>,</span><br><span class="line">    CDEV_EXCLUSIVE_OPEN = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Is the device open right now? Used to prevent concurrent access into</span></span><br><span class="line"><span class="comment"> * the same device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">atomic_t</span> already_open = ATOMIC_INIT(CDEV_NOT_USED);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The message the device will give when asked */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> message[BUF_LEN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">cls</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is called whenever a process attempts to open the device file */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;device_open(%p)\n&quot;</span>, file);</span><br><span class="line"></span><br><span class="line">    try_module_get(THIS_MODULE);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;device_release(%p,%p)\n&quot;</span>, inode, file);</span><br><span class="line"></span><br><span class="line">    module_put(THIS_MODULE);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called whenever a process which has already opened the</span></span><br><span class="line"><span class="comment"> * device file attempts to read from it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="comment">/* see include/linux/fs.h   */</span></span></span><br><span class="line"><span class="params">                           <span class="type">char</span> __user *buffer, <span class="comment">/* buffer to be filled  */</span></span></span><br><span class="line"><span class="params">                           <span class="type">size_t</span> length, <span class="comment">/* length of the buffer     */</span></span></span><br><span class="line"><span class="params">                           <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Number of bytes actually written to the buffer */</span></span><br><span class="line">    <span class="type">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* How far did the process reading the message get? Useful if the message</span></span><br><span class="line"><span class="comment">     * is larger than the size of the buffer we get to fill in device_read.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message_ptr = message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!*(message_ptr + *offset)) &#123; <span class="comment">/* we are at the end of message */</span></span><br><span class="line">        *offset = <span class="number">0</span>; <span class="comment">/* reset the offset */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* signify end of file */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    message_ptr += *offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Actually put the data into the buffer */</span></span><br><span class="line">    <span class="keyword">while</span> (length &amp;&amp; *message_ptr) &#123;</span><br><span class="line">        <span class="comment">/* Because the buffer is in the user data segment, not the kernel</span></span><br><span class="line"><span class="comment">         * data segment, assignment would not work. Instead, we have to</span></span><br><span class="line"><span class="comment">         * use put_user which copies data from the kernel data segment to</span></span><br><span class="line"><span class="comment">         * the user data segment.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        put_user(*(message_ptr++), buffer++);</span><br><span class="line">        length--;</span><br><span class="line">        bytes_read++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Read %d bytes, %ld left\n&quot;</span>, bytes_read, length);</span><br><span class="line"></span><br><span class="line">    *offset += bytes_read;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read functions are supposed to return the number of bytes actually</span></span><br><span class="line"><span class="comment">     * inserted into the buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* called when somebody tries to write into our device file. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer,</span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;device_write(%p,%p,%ld)&quot;</span>, file, buffer, length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length &amp;&amp; i &lt; BUF_LEN; i++)</span><br><span class="line">        get_user(message[i], buffer + i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Again, return the number of input characters used. */</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function is called whenever a process tries to do an ioctl on our</span></span><br><span class="line"><span class="comment"> * device file. We get two extra parameters (additional to the inode and file</span></span><br><span class="line"><span class="comment"> * structures, which all device functions get): the number of the ioctl called</span></span><br><span class="line"><span class="comment"> * and the parameter given to the ioctl function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the ioctl is write or read/write (meaning output is returned to the</span></span><br><span class="line"><span class="comment"> * calling process), the ioctl call returns the output of this function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">device_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="comment">/* ditto */</span></span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> <span class="type">int</span> ioctl_num, <span class="comment">/* number and param for ioctl */</span></span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> <span class="type">long</span> ioctl_param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">long</span> ret = SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We don&#x27;t want to talk to two processes at the same time. */</span></span><br><span class="line">    <span class="keyword">if</span> (atomic_cmpxchg(&amp;already_open, CDEV_NOT_USED, CDEV_EXCLUSIVE_OPEN))</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Switch according to the ioctl called */</span></span><br><span class="line">    <span class="keyword">switch</span> (ioctl_num) &#123;</span><br><span class="line">    <span class="keyword">case</span> IOCTL_SET_MSG: &#123;</span><br><span class="line">        <span class="comment">/* Receive a pointer to a message (in user space) and set that to</span></span><br><span class="line"><span class="comment">         * be the device&#x27;s message. Get the parameter given to ioctl by</span></span><br><span class="line"><span class="comment">         * the process.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">char</span> __user *tmp = (<span class="type">char</span> __user *)ioctl_param;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Find the length of the message */</span></span><br><span class="line">        get_user(ch, tmp);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; ch &amp;&amp; i &lt; BUF_LEN; i++, tmp++)</span><br><span class="line">            get_user(ch, tmp);</span><br><span class="line"></span><br><span class="line">        device_write(file, (<span class="type">char</span> __user *)ioctl_param, i, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> IOCTL_GET_MSG: &#123;</span><br><span class="line">        <span class="type">loff_t</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Give the current message to the calling process - the parameter</span></span><br><span class="line"><span class="comment">         * we got is a pointer, fill it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        i = device_read(file, (<span class="type">char</span> __user *)ioctl_param, <span class="number">99</span>, &amp;offset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Put a zero at the end of the buffer, so it will be properly</span></span><br><span class="line"><span class="comment">         * terminated.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        put_user(<span class="string">&#x27;\0&#x27;</span>, (<span class="type">char</span> __user *)ioctl_param + i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> IOCTL_GET_NTH_BYTE:</span><br><span class="line">        <span class="comment">/* This ioctl is both input (ioctl_param) and output (the return</span></span><br><span class="line"><span class="comment">         * value of this function).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ret = (<span class="type">long</span>)message[ioctl_param];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We&#x27;re now ready for our next caller */</span></span><br><span class="line">    <span class="type">atomic_set</span>(&amp;already_open, CDEV_NOT_USED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Module Declarations */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This structure will hold the functions to be called when a process does</span></span><br><span class="line"><span class="comment"> * something to the device we created. Since a pointer to this structure</span></span><br><span class="line"><span class="comment"> * is kept in the devices table, it can&#x27;t be local to init_module. NULL is</span></span><br><span class="line"><span class="comment"> * for unimplemented functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">    .read = device_read,</span><br><span class="line">    .write = device_write,</span><br><span class="line">    .unlocked_ioctl = device_ioctl,</span><br><span class="line">    .open = device_open,</span><br><span class="line">    .release = device_release, <span class="comment">/* a.k.a. close */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize the module - Register the character device */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chardev2_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Register the character device (atleast try) */</span></span><br><span class="line">    <span class="type">int</span> ret_val = register_chrdev(MAJOR_NUM, DEVICE_NAME, &amp;fops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Negative values signify an error */</span></span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_alert(<span class="string">&quot;%s failed with %d\n&quot;</span>,</span><br><span class="line">                 <span class="string">&quot;Sorry, registering the character device &quot;</span>, ret_val);</span><br><span class="line">        <span class="keyword">return</span> ret_val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(6, 4, 0)</span></span><br><span class="line">    cls = class_create(DEVICE_FILE_NAME);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    cls = class_create(THIS_MODULE, DEVICE_FILE_NAME);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    device_create(cls, <span class="literal">NULL</span>, MKDEV(MAJOR_NUM, <span class="number">0</span>), <span class="literal">NULL</span>, DEVICE_FILE_NAME);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Device created on /dev/%s\n&quot;</span>, DEVICE_FILE_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Cleanup - unregister the appropriate file from /proc */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chardev2_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(cls, MKDEV(MAJOR_NUM, <span class="number">0</span>));</span><br><span class="line">    class_destroy(cls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unregister the device */</span></span><br><span class="line">    unregister_chrdev(MAJOR_NUM, DEVICE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(chardev2_init);</span><br><span class="line">module_exit(chardev2_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * chardev.h - the header file with the ioctl definitions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The declarations here have to be in a header file, because they need</span></span><br><span class="line"><span class="comment"> * to be known both to the kernel module (in chardev2.c) and the process</span></span><br><span class="line"><span class="comment"> * calling ioctl() (in userspace_ioctl.c).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHARDEV_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHARDEV_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The major device number. We can not rely on dynamic registration</span></span><br><span class="line"><span class="comment"> * any more, because ioctls need to know it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR_NUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the message of the device driver */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_SET_MSG _IOW(MAJOR_NUM, 0, char *)</span></span><br><span class="line"><span class="comment">/* _IOW means that we are creating an ioctl command number for passing</span></span><br><span class="line"><span class="comment"> * information from a user process to the kernel module.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The first arguments, MAJOR_NUM, is the major device number we are using.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The second argument is the number of the command (there could be several</span></span><br><span class="line"><span class="comment"> * with different meanings).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The third argument is the type we want to get from the process to the</span></span><br><span class="line"><span class="comment"> * kernel.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the message of the device driver */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_GET_MSG _IOR(MAJOR_NUM, 1, char *)</span></span><br><span class="line"><span class="comment">/* This IOCTL is used for output, to get the message of the device driver.</span></span><br><span class="line"><span class="comment"> * However, we still need the buffer to place the message in to be input,</span></span><br><span class="line"><span class="comment"> * as it is allocated by the process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the n&#x27;th byte of the message */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_GET_NTH_BYTE _IOWR(MAJOR_NUM, 2, int)</span></span><br><span class="line"><span class="comment">/* The IOCTL is used for both input and output. It receives from the user</span></span><br><span class="line"><span class="comment"> * a number, n, and returns message[n].</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The name of the device file */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_FILE_NAME <span class="string">&quot;char_dev&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_PATH <span class="string">&quot;/dev/char_dev&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  userspace_ioctl.c - the process to use ioctl&#x27;s to control the kernel module</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Until now we could have used cat for input and output.  But now</span></span><br><span class="line"><span class="comment"> *  we need to do ioctl&#x27;s, which require writing our own process.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* device specifics, such as ioctl numbers and the</span></span><br><span class="line"><span class="comment"> * major device file. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../chardev.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">/* standard I/O */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> <span class="comment">/* open */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">/* close */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">/* exit */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span> <span class="comment">/* ioctl */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Functions for the ioctl calls */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl_set_msg</span><span class="params">(<span class="type">int</span> file_desc, <span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret_val;</span><br><span class="line"></span><br><span class="line">    ret_val = ioctl(file_desc, IOCTL_SET_MSG, message);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ioctl_set_msg failed:%d\n&quot;</span>, ret_val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl_get_msg</span><span class="params">(<span class="type">int</span> file_desc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret_val;</span><br><span class="line">    <span class="type">char</span> message[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Warning - this is dangerous because we don&#x27;t tell</span></span><br><span class="line"><span class="comment">   * the kernel how far it&#x27;s allowed to write, so it</span></span><br><span class="line"><span class="comment">   * might overflow the buffer. In a real production</span></span><br><span class="line"><span class="comment">   * program, we would have used two ioctls - one to tell</span></span><br><span class="line"><span class="comment">   * the kernel the buffer length and another to give</span></span><br><span class="line"><span class="comment">   * it the buffer to fill</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    ret_val = ioctl(file_desc, IOCTL_GET_MSG, message);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret_val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ioctl_get_msg failed:%d\n&quot;</span>, ret_val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get_msg message:%s&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl_get_nth_byte</span><span class="params">(<span class="type">int</span> file_desc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get_nth_byte message:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        c = ioctl(file_desc, IOCTL_GET_NTH_BYTE, i++);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\nioctl_get_nth_byte failed at the %d&#x27;th byte:\n&quot;</span>, i);</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">putchar</span>(c);</span><br><span class="line">    &#125; <span class="keyword">while</span> (c != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main - Call the ioctl functions */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> file_desc, ret_val;</span><br><span class="line">    <span class="type">char</span> *msg = <span class="string">&quot;Message passed by ioctl\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    file_desc = open(DEVICE_PATH, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (file_desc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open device file: %s, error:%d\n&quot;</span>, DEVICE_PATH,</span><br><span class="line">               file_desc);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret_val = ioctl_set_msg(file_desc, msg);</span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    ret_val = ioctl_get_nth_byte(file_desc);</span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    ret_val = ioctl_get_msg(file_desc);</span><br><span class="line">    <span class="keyword">if</span> (ret_val)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">    close(file_desc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">error:</span><br><span class="line">    close(file_desc);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-System-Calls-10-系统调用"><a href="#10-System-Calls-10-系统调用" class="headerlink" title="10 System Calls 10 系统调用"></a>10 System Calls 10 系统调用</h3><p>So far, the only thing we’ve done was to use well defined kernel mechanisms to register &#x2F;proc files and device handlers. This is fine if you want to do something the kernel programmers thought you’d want, such as write a device driver. But what if you want to do something unusual, to change the behavior of the system in some way? Then, you are mostly on your own.<br>到目前为止，我们所做的唯一一件事就是使用定义良好的内核机制来注册 &#x2F;proc 文件和设备处理程序。如果您想做内核程序员认为您想做的事情，例如编写设备驱动程序，那么这很好。但是，如果您想做一些不寻常的事情，以某种方式改变系统的行为怎么办？然后，你就只能靠自己了。</p>
<p>If you are not being sensible and using a virtual machine then this is where kernel programming can become hazardous. While writing the example below, I killed the <code>open()</code> system call. This meant I could not open any files, I could not run any programs, and I could not shutdown the system. I had to restart the virtual machine. No important files got annihilated, but if I was doing this on some live mission critical system then that could have been a possible outcome. To ensure you do not lose any files, even within a test environment, please run <code>sync</code> right before you do the <code>insmod</code> and the <code>rmmod</code> .<br>如果您不明智地使用虚拟机，那么这就是内核编程可能变得危险的地方。在编写下面的示例时，我终止了 <code>open()</code> 系统调用。这意味着我无法打开任何文件，无法运行任何程序，也无法关闭系统。我不得不重新启动虚拟机。没有重要的文件被消灭，但如果我在一些实时任务关键系统上执行此操作，那么这可能是一个可能的结果。为了确保即使在测试环境中也不会丢失任何文件，请在执行 <code>insmod</code> 和 <code>rmmod</code> 之前运行 <code>sync</code> 。</p>
<p>Forget about &#x2F;proc files, forget about device files. They are just minor details. Minutiae in the vast expanse of the universe. The real process to kernel communication mechanism, the one used by all processes, is system calls. When a process requests a service from the kernel (such as opening a file, forking to a new process, or requesting more memory), this is the mechanism used. If you want to change the behaviour of the kernel in interesting ways, this is the place to do it. By the way, if you want to see which system calls a program uses, run <code>strace &lt;arguments&gt;</code> .<br>忘记 &#x2F;proc 文件，忘记设备文件。它们只是一些小细节。浩瀚宇宙中的细枝末节。所有进程都使用的真正的进程与内核通信机制是系统调用。当进程向内核请求服务（例如打开文件、分叉到新进程或请求更多内存）时，就会使用这种机制。如果你想以有趣的方式改变内核的行为，这里就是你可以做的地方。顺便说一句，如果您想查看程序使用哪个系统调用，请运行 <code>strace &lt;arguments&gt;</code> 。</p>
<p>In general, a process is not supposed to be able to access the kernel. It can not access kernel memory and it can’t call kernel functions. The hardware of the CPU enforces this (that is the reason why it is called “protected mode” or “page protection”).<br>一般来说，进程不应该能够访问内核。它无法访问内核内存，也无法调用内核函数。 CPU 的硬件强制执行此操作（这就是它被称为“保护模式”或“页面保护”的原因）。</p>
<p>System calls are an exception to this general rule. What happens is that the process fills the registers with the appropriate values and then calls a special instruction which jumps to a previously defined location in the kernel (of course, that location is readable by user processes, it is not writable by them). Under Intel CPUs, this is done by means of interrupt 0x80. The hardware knows that once you jump to this location, you are no longer running in restricted user mode, but as the operating system kernel — and therefore you’re allowed to do whatever you want.<br>系统调用是此一般规则的一个例外。发生的情况是，进程用适当的值填充寄存器，然后调用一条特殊指令，该指令跳转到内核中先前定义的位置（当然，该位置可由用户进程读取，但不可写入）。在 Intel CPU 下，这是通过中断 0x80 完成的。硬件知道，一旦你跳转到这个位置，你就不再运行在受限用户模式下，而是作为操作系统内核运行——因此你可以做任何你想做的事情。</p>
<p>The location in the kernel a process can jump to is called system_call. The procedure at that location checks the system call number, which tells the kernel what service the process requested. Then, it looks at the table of system calls ( <code>sys_call_table</code> ) to see the address of the kernel function to call. Then it calls the function, and after it returns, does a few system checks and then return back to the process (or to a different process, if the process time ran out). If you want to read this code, it is at the source file arch&#x2F;$(architecture)&#x2F;kernel&#x2F;entry.S, after the line <code>ENTRY(system_call)</code> .<br>进程在内核中可以跳转到的位置称为system_call。该位置的过程检查系统调用号，它告诉内核进程请求什么服务。然后，它查看系统调用表 ( <code>sys_call_table</code> ) 以查看要调用的内核函数的地址。然后它调用该函数，并在返回后执行一些系统检查，然后返回到该进程（或者返回到另一个进程，如果进程时间用完）。如果你想阅读这段代码，它位于源文件 arch&#x2F;$(architecture)&#x2F;kernel&#x2F;entry.S 的 <code>ENTRY(system_call)</code> 行之后。</p>
<p>So, if we want to change the way a certain system call works, what we need to do is to write our own function to implement it (usually by adding a bit of our own code, and then calling the original function) and then change the pointer at <code>sys_call_table</code> to point to our function. Because we might be removed later and we don’t want to leave the system in an unstable state, it’s important for <code>cleanup_module</code> to restore the table to its original state.<br>所以，如果我们想要改变某个系统调用的工作方式，我们需要做的就是编写自己的函数来实现它（通常是添加一点我们自己的代码，然后调用原来的函数），然后改变 <code>sys_call_table</code> 处的指针指向我们的函数。因为我们稍后可能会被删除，并且我们不想让系统处于不稳定状态，所以 <code>cleanup_module</code> 将表恢复到原始状态非常重要。</p>
<p>To modify the content of <code>sys_call_table</code> , we need to consider the control register. A control register is a processor register that changes or controls the general behavior of the CPU. For x86 architecture, the cr0 register has various control flags that modify the basic operation of the processor. The WP flag in cr0 stands for write protection. Once the WP flag is set, the processor disallows further write attempts to the read-only sections Therefore, we must disable the WP flag before modifying <code>sys_call_table</code> . Since Linux v5.3, the <code>write_cr0</code> function cannot be used because of the sensitive cr0 bits pinned by the security issue, the attacker may write into CPU control registers to disable CPU protections like write protection. As a result, we have to provide the custom assembly routine to bypass it.<br>要修改 <code>sys_call_table</code> 的内容，我们需要考虑控制寄存器。控制寄存器是改变或控制 CPU 一般行为的处理器寄存器。对于 x86 架构，cr0 寄存器有各种控制标志，可以修改处理器的基本操作。 cr0 中的 WP 标志代表写保护。一旦设置了 WP 标志，处理器就不允许对只读部分进行进一步的写入尝试，因此，我们必须在修改 <code>sys_call_table</code> 之前禁用 WP 标志。从 Linux v5.3 开始，由于安全问题固定了敏感的 cr0 位， <code>write_cr0</code> 功能无法使用，攻击者可能会写入 CPU 控制寄存器以禁用写保护等 CPU 保护。因此，我们必须提供自定义汇编例程来绕过它。</p>
<p>However, <code>sys_call_table</code> symbol is unexported to prevent misuse. But there have few ways to get the symbol, manual symbol lookup and <code>kallsyms_lookup_name</code> . Here we use both depend on the kernel version.<br>但是， <code>sys_call_table</code> 符号未导出以防止误用。但获取符号的方法很少，手动符号查找和 <code>kallsyms_lookup_name</code> 。这里我们使用两者取决于内核版本。</p>
<p>Because of the control-flow integrity, which is a technique to prevent the redirect execution code from the attacker, for making sure that the indirect calls go to the expected addresses and the return addresses are not changed. Since Linux v5.7, the kernel patched the series of control-flow enforcement (CET) for x86, and some configurations of GCC, like GCC versions 9 and 10 in Ubuntu Linux, will add with CET (the -fcf-protection option) in the kernel by default. Using that GCC to compile the kernel with retpoline off may result in CET being enabled in the kernel. You can use the following command to check out the -fcf-protection option is enabled or not:<br>因为控制流完整性是一种防止攻击者重定向执行代码的技术，以确保间接调用到达预期地址并且返回地址不被改变。从 Linux v5.7 开始，内核修补了 x86 的一系列控制流强制 (CET)，并且 GCC 的某些配置（例如 Ubuntu Linux 中的 GCC 版本 9 和 10）将添加 CET（-fcf-protection 选项）默认情况下在内核中。使用该 GCC 在关闭 retpoline 的情况下编译内核可能会导致在内核中启用 CET。您可以使用以下命令来检查 -fcf-protection 选项是否启用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -v -Q -O2 --<span class="built_in">help</span>=target | grep protection</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper</span><br><span class="line">...</span><br><span class="line">gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04)</span><br><span class="line">COLLECT_GCC_OPTIONS=<span class="string">&#x27;-v&#x27;</span> <span class="string">&#x27;-Q&#x27;</span> <span class="string">&#x27;-O2&#x27;</span> <span class="string">&#x27;--help=target&#x27;</span> <span class="string">&#x27;-mtune=generic&#x27;</span> <span class="string">&#x27;-march=x86-64&#x27;</span></span><br><span class="line"> /usr/lib/gcc/x86_64-linux-gnu/9/cc1 -v ... -fcf-protection ...</span><br><span class="line"> GNU C17 (Ubuntu 9.3.0-17ubuntu1~20.04) version 9.3.0 (x86_64-linux-gnu)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>But CET should not be enabled in the kernel, it may break the Kprobes and bpf. Consequently, CET is disabled since v5.11. To guarantee the manual symbol lookup worked, we only use up to v5.4.<br>但不应在内核中启用 CET，它可能会破坏 Kprobes 和 bpf。因此，自 v5.11 起 CET 被禁用。为了保证手动符号查找有效，我们最多只使用 v5.4。</p>
<p>Unfortunately, since Linux v5.7 <code>kallsyms_lookup_name</code> is also unexported, it needs certain trick to get the address of <code>kallsyms_lookup_name</code> . If <code>CONFIG_KPROBES</code> is enabled, we can facilitate the retrieval of function addresses by means of Kprobes to dynamically break into the specific kernel routine. Kprobes inserts a breakpoint at the entry of function by replacing the first bytes of the probed instruction. When a CPU hits the breakpoint, registers are stored, and the control will pass to Kprobes. It passes the addresses of the saved registers and the Kprobe struct to the handler you defined, then executes it. Kprobes can be registered by symbol name or address. Within the symbol name, the address will be handled by the kernel.<br>不幸的是，由于 Linux v5.7 <code>kallsyms_lookup_name</code> 也未导出，因此需要一定的技巧来获取 <code>kallsyms_lookup_name</code> 的地址。如果启用 <code>CONFIG_KPROBES</code> ，我们可以方便地通过 Kprobes 检索函数地址，从而动态地侵入特定的内核例程。 Kprobes 通过替换探测指令的第一个字节在函数入口处插入断点。当 CPU 到达断点时，寄存器被存储，控制权将传递给 Kprobes。它将保存的寄存器的地址和 Kprobe 结构传递给您定义的处理程序，然后执行它。 Kprobes 可以通过符号名称或地址来注册。在符号名称中，地址将由内核处理。</p>
<p>Otherwise, specify the address of <code>sys_call_table</code> from &#x2F;proc&#x2F;kallsyms and &#x2F;boot&#x2F;System.map into <code>sym</code> parameter. Following is the sample usage for &#x2F;proc&#x2F;kallsyms:<br>否则，将 &#x2F;proc&#x2F;kallsyms 和 &#x2F;boot&#x2F;System.map 中的 <code>sys_call_table</code> 地址指定到 <code>sym</code> 参数中。以下是 &#x2F;proc&#x2F;kallsyms 的示例用法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo grep sys_call_table /proc/kallsyms</span><br><span class="line">ffffffff82000280 R x32_sys_call_table</span><br><span class="line">ffffffff820013a0 R sys_call_table</span><br><span class="line">ffffffff820023e0 R ia32_sys_call_table</span><br><span class="line">$ sudo insmod syscall.ko sym=0xffffffff820013a0</span><br></pre></td></tr></table></figure>

<p>Using the address from &#x2F;boot&#x2F;System.map, be careful about KASLR (Kernel Address Space Layout Randomization). KASLR may randomize the address of kernel code and data at every boot time, such as the static address listed in &#x2F;boot&#x2F;System.map will offset by some entropy. The purpose of KASLR is to protect the kernel space from the attacker. Without KASLR, the attacker may find the target address in the fixed address easily. Then the attacker can use return-oriented programming to insert some malicious codes to execute or receive the target data by a tampered pointer. KASLR mitigates these kinds of attacks because the attacker cannot immediately know the target address, but a brute-force attack can still work. If the address of a symbol in &#x2F;proc&#x2F;kallsyms is different from the address in &#x2F;boot&#x2F;System.map, KASLR is enabled with the kernel, which your system running on.<br>使用 &#x2F;boot&#x2F;System.map 中的地址，请注意 KASLR（内核地址空间布局随机化）。 KASLR 可能会在每次启动时随机化内核代码和数据的地址，例如 &#x2F;boot&#x2F;System.map 中列出的静态地址会偏移一些熵。 KASLR 的目的是保护内核空间免受攻击者的侵害。如果没有 KASLR，攻击者可以很容易地在固定地址中找到目标地址。那么攻击者就可以利用面向返回的编程方式插入一些恶意代码，通过被篡改的指针来执行或接收目标数据。 KASLR 可以缓解此类攻击，因为攻击者无法立即知道目标地址，但暴力攻击仍然可以发挥作用。如果 &#x2F;proc&#x2F;kallsyms 中的符号地址与 &#x2F;boot&#x2F;System.map 中的地址不同，则系统运行所在的内核会启用 KASLR。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ grep GRUB_CMDLINE_LINUX_DEFAULT /etc/default/grub</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;quiet splash&quot;</span></span><br><span class="line">$ sudo grep sys_call_table /boot/System.map-$(<span class="built_in">uname</span> -r)</span><br><span class="line">ffffffff82000300 R sys_call_table</span><br><span class="line">$ sudo grep sys_call_table /proc/kallsyms</span><br><span class="line">ffffffff820013a0 R sys_call_table</span><br><span class="line"><span class="comment"># Reboot</span></span><br><span class="line">$ sudo grep sys_call_table /boot/System.map-$(<span class="built_in">uname</span> -r)</span><br><span class="line">ffffffff82000300 R sys_call_table</span><br><span class="line">$ sudo grep sys_call_table /proc/kallsyms</span><br><span class="line">ffffffff86400300 R sys_call_table</span><br></pre></td></tr></table></figure>

<p>If KASLR is enabled, we have to take care of the address from &#x2F;proc&#x2F;kallsyms each time we reboot the machine. In order to use the address from &#x2F;boot&#x2F;System.map, make sure that KASLR is disabled. You can add the nokaslr for disabling KASLR in next booting time:<br>如果启用了 KASLR，我们每次重新启动机器时都必须处理 &#x2F;proc&#x2F;kallsyms 中的地址。为了使用 &#x2F;boot&#x2F;System.map 中的地址，请确保禁用 KASLR。您可以添加 nokaslr 以在下次启动时禁用 KASLR：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ grep GRUB_CMDLINE_LINUX_DEFAULT /etc/default/grub</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;quiet splash&quot;</span></span><br><span class="line">$ sudo perl -i -pe <span class="string">&#x27;m/quiet/ and s//quiet nokaslr/&#x27;</span> /etc/default/grub</span><br><span class="line">$ grep quiet /etc/default/grub</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;quiet nokaslr splash&quot;</span></span><br><span class="line">$ sudo update-grub</span><br></pre></td></tr></table></figure>

<p>For more information, check out the following:<br>欲了解更多信息，请查看以下内容：</p>
<ul>
<li><a href="https://lwn.net/Articles/804849/">Cook: Security things in Linux v5.3<br>Cook：Linux v5.3 中的安全问题</a></li>
<li><a href="https://lwn.net/Articles/12211/">Unexporting the system call table<br>取消导出系统调用表</a></li>
<li><a href="https://lwn.net/Articles/810077/">Control-flow integrity for the kernel<br>内核的控制流完整性</a></li>
<li><a href="https://lwn.net/Articles/813350/">Unexporting kallsyms_lookup_name()<br>取消导出 kallsyms_lookup_name()</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/kprobes.txt">Kernel Probes (Kprobes)<br>内核探针（Kprobes）</a></li>
<li><a href="https://lwn.net/Articles/569635/">Kernel address space layout randomization<br>内核地址空间布局随机化</a></li>
</ul>
<p>The source code here is an example of such a kernel module. We want to “spy” on a certain user, and to <code>pr_info()</code> a message whenever that user opens a file. Towards this end, we replace the system call to open a file with our own function, called <code>our_sys_openat</code> . This function checks the uid (user’s id) of the current process, and if it is equal to the uid we spy on, it calls <code>pr_info()</code> to display the name of the file to be opened. Then, either way, it calls the original <code>openat()</code> function with the same parameters, to actually open the file.<br>这里的源代码是此类内核模块的示例。我们想要“监视”某个用户，并在该用户打开文件时 <code>pr_info()</code> 发送一条消息。为此，我们用我们自己的函数 <code>our_sys_openat</code> 替换打开文件的系统调用。该函数检查当前进程的 uid（用户 id），如果它与我们监视的 uid 相同，则调用 <code>pr_info()</code> 来显示要打开的文件的名称。然后，无论哪种方式，它都会使用相同的参数调用原始的 <code>openat()</code> 函数来实际打开文件。</p>
<p>The <code>init_module</code> function replaces the appropriate location in <code>sys_call_table</code> and keeps the original pointer in a variable. The <code>cleanup_module</code> function uses that variable to restore everything back to normal. This approach is dangerous, because of the possibility of two kernel modules changing the same system call. Imagine we have two kernel modules, A and B. A’s openat system call will be <code>A_openat</code> and B’s will be <code>B_openat</code> . Now, when A is inserted into the kernel, the system call is replaced with <code>A_openat</code> , which will call the original <code>sys_openat</code> when it is done. Next, B is inserted into the kernel, which replaces the system call with <code>B_openat</code> , which will call what it thinks is the original system call, <code>A_openat</code> , when it’s done.<br><code>init_module</code> 函数替换 <code>sys_call_table</code> 中的适当位置，并将原始指针保留在变量中。 <code>cleanup_module</code> 函数使用该变量将一切恢复正常。这种方法很危险，因为两个内核模块可能会更改同一个系统调用。假设我们有两个内核模块，A 和 B。A 的 openat 系统调用为 <code>A_openat</code> ，B 的 openat 系统调用为 <code>B_openat</code> 。现在，当 A 插入内核时，系统调用被替换为 <code>A_openat</code> ，完成后将调用原始的 <code>sys_openat</code> 。接下来，B 被插入到内核中，内核用 <code>B_openat</code> 替换系统调用，完成后它将调用它认为是原始系统调用的 <code>A_openat</code> 。</p>
<p>Now, if B is removed first, everything will be well — it will simply restore the system call to <code>A_openat</code> , which calls the original. However, if A is removed and then B is removed, the system will crash. A’s removal will restore the system call to the original, <code>sys_openat</code> , cutting B out of the loop. Then, when B is removed, it will restore the system call to what it thinks is the original, <code>A_openat</code> , which is no longer in memory. At first glance, it appears we could solve this particular problem by checking if the system call is equal to our open function and if so not changing it at all (so that B won’t change the system call when it is removed), but that will cause an even worse problem. When A is removed, it sees that the system call was changed to <code>B_openat</code> so that it is no longer pointing to <code>A_openat</code> , so it will not restore it to <code>sys_openat</code> before it is removed from memory. Unfortunately, <code>B_openat</code> will still try to call <code>A_openat</code> which is no longer there, so that even without removing B the system would crash.<br>现在，如果先删除 B，一切都会好起来 - 它只会将系统调用恢复到 <code>A_openat</code> ，它调用原始系统调用。但是，如果删除 A，然后删除 B，系统就会崩溃。 A 的删除会将系统调用恢复为原始 <code>sys_openat</code> ，从而将 B 切出循环。然后，当 B 被删除时，它会将系统调用恢复到它认为的原始 <code>A_openat</code> ，该调用不再位于内存中。乍一看，我们似乎可以通过检查系统调用是否等于我们的 open 函数来解决这个特殊问题，如果是则根本不改变它（这样当系统调用被删除时 B 就不会改变它），但是这会导致更严重的问题。当 A 被删除时，它看到系统调用已更改为 <code>B_openat</code> ，因此它不再指向 <code>A_openat</code> ，因此不会将其恢复为 <code>sys_openat</code> 在从内存中删除之前。不幸的是， <code>B_openat</code> 仍会尝试调用不再存在的 <code>A_openat</code> ，因此即使不删除 B，系统也会崩溃。</p>
<p>Note that all the related problems make syscall stealing unfeasible for production use. In order to keep people from doing potential harmful things <code>sys_call_table</code> is no longer exported. This means, if you want to do something more than a mere dry run of this example, you will have to patch your current kernel in order to have <code>sys_call_table</code> exported.<br>请注意，所有相关问题使得系统调用窃取在生产使用中不可行。为了防止人们做潜在有害的事情 <code>sys_call_table</code> 不再导出。这意味着，如果您想要做的不仅仅是这个示例的演练，您将必须修补当前的内核才能导出 <code>sys_call_table</code> 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * syscall.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * System call &quot;stealing&quot; sample.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Disables page protection at a processor level by changing the 16th bit</span></span><br><span class="line"><span class="comment"> * in the cr0 register (could be Intel specific).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Based on example by Peter Jay Salzman and</span></span><br><span class="line"><span class="comment"> * https://bbs.archlinux.org/viewtopic.php?id=139406</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span> <span class="comment">/* which will have params */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unistd.h&gt;</span> <span class="comment">/* The list of system calls */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cred.h&gt;</span> <span class="comment">/* For current_uid() */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uidgid.h&gt;</span> <span class="comment">/* For __kuid_val() */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* For the current (process) structure, we need this to know who the</span></span><br><span class="line"><span class="comment"> * current user is.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The way we access &quot;sys_call_table&quot; varies as kernel internal changes.</span></span><br><span class="line"><span class="comment"> * - Prior to v5.4 : manual symbol lookup</span></span><br><span class="line"><span class="comment"> * - v5.5 to v5.6  : use kallsyms_lookup_name()</span></span><br><span class="line"><span class="comment"> * - v5.7+         : Kprobes or specific kernel module parameter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The in-kernel calls to the ksys_close() syscall were removed in Linux v5.11+.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LINUX_VERSION_CODE &lt; KERNEL_VERSION(5, 7, 0))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &lt;= KERNEL_VERSION(5, 4, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_KSYS_CLOSE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/syscalls.h&gt;</span> <span class="comment">/* For ksys_close() */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kallsyms.h&gt;</span> <span class="comment">/* For kallsyms_lookup_name */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_KPROBES)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_KPROBES 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kprobes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_PARAM 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kallsyms.h&gt;</span> <span class="comment">/* For sprint_symbol */</span></span></span><br><span class="line"><span class="comment">/* The address of the sys_call_table, which can be obtained with looking up</span></span><br><span class="line"><span class="comment"> * &quot;/boot/System.map&quot; or &quot;/proc/kallsyms&quot;. When the kernel version is v5.7+,</span></span><br><span class="line"><span class="comment"> * without CONFIG_KPROBES, you can input the parameter or the module will look</span></span><br><span class="line"><span class="comment"> * up all the memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> sym = <span class="number">0</span>;</span><br><span class="line">module_param(sym, ulong, <span class="number">0644</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_KPROBES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* Version &lt; v5.7 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> **sys_call_table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UID we want to spy on - will be filled from the command line. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uid_t</span> uid = <span class="number">-1</span>;</span><br><span class="line">module_param(uid, <span class="type">int</span>, <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A pointer to the original system call. The reason we keep this, rather</span></span><br><span class="line"><span class="comment"> * than call the original function (sys_openat), is because somebody else</span></span><br><span class="line"><span class="comment"> * might have replaced the system call before us. Note that this is not</span></span><br><span class="line"><span class="comment"> * 100% safe, because if another module replaced sys_openat before us,</span></span><br><span class="line"><span class="comment"> * then when we are inserted, we will call the function in that module -</span></span><br><span class="line"><span class="comment"> * and it might be removed before we are.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Another reason for this is that we can not get sys_openat.</span></span><br><span class="line"><span class="comment"> * It is a static variable, so it is not exported.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_HAS_SYSCALL_WRAPPER</span></span><br><span class="line"><span class="type">static</span> asmlinkage <span class="title function_">long</span> <span class="params">(*original_call)</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pt_regs *)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> asmlinkage <span class="title function_">long</span> <span class="params">(*original_call)</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">int</span>, <span class="type">umode_t</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The function we will replace sys_openat (the function called when you</span></span><br><span class="line"><span class="comment"> * call the open system call) with. To find the exact prototype, with</span></span><br><span class="line"><span class="comment"> * the number and type of arguments, we find the original function first</span></span><br><span class="line"><span class="comment"> * (it is at fs/open.c).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In theory, this means that we are tied to the current version of the</span></span><br><span class="line"><span class="comment"> * kernel. In practice, the system calls almost never change (it would</span></span><br><span class="line"><span class="comment"> * wreck havoc and require programs to be recompiled, since the system</span></span><br><span class="line"><span class="comment"> * calls are the interface between the kernel and the processes).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_HAS_SYSCALL_WRAPPER</span></span><br><span class="line"><span class="type">static</span> asmlinkage <span class="type">long</span> <span class="title function_">our_sys_openat</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> asmlinkage <span class="type">long</span> <span class="title function_">our_sys_openat</span><span class="params">(<span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> __user *filename,</span></span><br><span class="line"><span class="params">                                      <span class="type">int</span> flags, <span class="type">umode_t</span> mode)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__kuid_val(current_uid()) != uid)</span><br><span class="line">        <span class="keyword">goto</span> orig_call;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Report the file, if relevant */</span></span><br><span class="line">    pr_info(<span class="string">&quot;Opened file by %d: &quot;</span>, uid);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_HAS_SYSCALL_WRAPPER</span></span><br><span class="line">        get_user(ch, (<span class="type">char</span> __user *)regs-&gt;si + i);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        get_user(ch, (<span class="type">char</span> __user *)filename + i);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        i++;</span><br><span class="line">        pr_info(<span class="string">&quot;%c&quot;</span>, ch);</span><br><span class="line">    &#125; <span class="keyword">while</span> (ch != <span class="number">0</span>);</span><br><span class="line">    pr_info(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">orig_call:</span><br><span class="line">    <span class="comment">/* Call the original sys_openat - otherwise, we lose the ability to</span></span><br><span class="line"><span class="comment">     * open files.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_HAS_SYSCALL_WRAPPER</span></span><br><span class="line">    <span class="keyword">return</span> original_call(regs);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> original_call(dfd, filename, flags, mode);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> **<span class="title function_">acquire_sys_call_table</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_KSYS_CLOSE</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> offset = PAGE_OFFSET;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> **sct;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (offset &lt; ULLONG_MAX) &#123;</span><br><span class="line">        sct = (<span class="type">unsigned</span> <span class="type">long</span> **)offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sct[__NR_close] == (<span class="type">unsigned</span> <span class="type">long</span> *)ksys_close)</span><br><span class="line">            <span class="keyword">return</span> sct;</span><br><span class="line"></span><br><span class="line">        offset += <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PARAM</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> sct_name[<span class="number">15</span>] = <span class="string">&quot;sys_call_table&quot;</span>;</span><br><span class="line">    <span class="type">char</span> symbol[<span class="number">40</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym == <span class="number">0</span>) &#123;</span><br><span class="line">        pr_alert(<span class="string">&quot;For Linux v5.7+, Kprobes is the preferable way to get &quot;</span></span><br><span class="line">                 <span class="string">&quot;symbol.\n&quot;</span>);</span><br><span class="line">        pr_info(<span class="string">&quot;If Kprobes is absent, you have to specify the address of &quot;</span></span><br><span class="line">                <span class="string">&quot;sys_call_table symbol\n&quot;</span>);</span><br><span class="line">        pr_info(<span class="string">&quot;by /boot/System.map or /proc/kallsyms, which contains all the &quot;</span></span><br><span class="line">                <span class="string">&quot;symbol addresses, into sym parameter.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sprint_symbol(symbol, sym);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(sct_name, symbol, <span class="keyword">sizeof</span>(sct_name) - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span> **)sym;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_KPROBES</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*kallsyms_lookup_name)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kprobe</span> <span class="title">kp</span> =</span> &#123;</span><br><span class="line">        .symbol_name = <span class="string">&quot;kallsyms_lookup_name&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (register_kprobe(&amp;kp) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    kallsyms_lookup_name = (<span class="type">unsigned</span> <span class="type">long</span> (*)(<span class="type">const</span> <span class="type">char</span> *name))kp.addr;</span><br><span class="line">    unregister_kprobe(&amp;kp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span> **)kallsyms_lookup_name(<span class="string">&quot;sys_call_table&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 3, 0)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __write_cr0(<span class="type">unsigned</span> <span class="type">long</span> cr0)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov %0,%%cr0&quot;</span> : <span class="string">&quot;+r&quot;</span>(cr0) : : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __write_cr0 write_cr0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">enable_write_protection</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cr0 = read_cr0();</span><br><span class="line">    set_bit(<span class="number">16</span>, &amp;cr0);</span><br><span class="line">    __write_cr0(cr0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">disable_write_protection</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cr0 = read_cr0();</span><br><span class="line">    clear_bit(<span class="number">16</span>, &amp;cr0);</span><br><span class="line">    __write_cr0(cr0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">syscall_start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(sys_call_table = acquire_sys_call_table()))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    disable_write_protection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* keep track of the original open function */</span></span><br><span class="line">    original_call = (<span class="type">void</span> *)sys_call_table[__NR_openat];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use our openat function instead */</span></span><br><span class="line">    sys_call_table[__NR_openat] = (<span class="type">unsigned</span> <span class="type">long</span> *)our_sys_openat;</span><br><span class="line"></span><br><span class="line">    enable_write_protection();</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Spying on UID:%d\n&quot;</span>, uid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">syscall_end</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sys_call_table)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the system call back to normal */</span></span><br><span class="line">    <span class="keyword">if</span> (sys_call_table[__NR_openat] != (<span class="type">unsigned</span> <span class="type">long</span> *)our_sys_openat) &#123;</span><br><span class="line">        pr_alert(<span class="string">&quot;Somebody else also played with the &quot;</span>);</span><br><span class="line">        pr_alert(<span class="string">&quot;open system call\n&quot;</span>);</span><br><span class="line">        pr_alert(<span class="string">&quot;The system may be left in &quot;</span>);</span><br><span class="line">        pr_alert(<span class="string">&quot;an unstable state.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    disable_write_protection();</span><br><span class="line">    sys_call_table[__NR_openat] = (<span class="type">unsigned</span> <span class="type">long</span> *)original_call;</span><br><span class="line">    enable_write_protection();</span><br><span class="line"></span><br><span class="line">    msleep(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(syscall_start);</span><br><span class="line">module_exit(syscall_end);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="11-Blocking-Processes-and-threads"><a href="#11-Blocking-Processes-and-threads" class="headerlink" title="11 Blocking Processes and threads"></a>11 Blocking Processes and threads</h3><p>11 阻塞进程和线程</p>
<h4 id="11-1-Sleep-11-1-睡眠"><a href="#11-1-Sleep-11-1-睡眠" class="headerlink" title="11.1 Sleep 11.1 睡眠"></a>11.1 Sleep 11.1 睡眠</h4><p>What do you do when somebody asks you for something you can not do right away? If you are a human being and you are bothered by a human being, the only thing you can say is: “Not right now, I’m busy. Go away!”. But if you are a kernel module and you are bothered by a process, you have another possibility. You can put the process to sleep until you can service it. After all, processes are being put to sleep by the kernel and woken up all the time (that is the way multiple processes appear to run on the same time on a single CPU).<br>当有人向你提出一些你不能立即做的事情时，你会怎么做？如果你是一个人，并且你被一个人打扰，你唯一能说的是：“现在不行，我很忙。走开！”。但如果你是一个内核模块并且你被一个进程打扰，你还有另一种可能性。您可以让该进程进入休眠状态，直到可以为其提供服务为止。毕竟，进程一直被内核置于睡眠状态并被唤醒（这就是多个进程在单个 CPU 上同时运行的方式）。</p>
<p>This kernel module is an example of this. The file (called &#x2F;proc&#x2F;sleep) can only be opened by a single process at a time. If the file is already open, the kernel module calls <code>wait_event_interruptible</code> . The easiest way to keep a file open is to open it with:<br>这个内核模块就是一个例子。该文件（称为 &#x2F;proc&#x2F;sleep）一次只能由一个进程打开。如果文件已打开，内核模块将调用 <code>wait_event_interruptible</code> 。保持文件打开的最简单方法是使用以下命令打开它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f</span><br></pre></td></tr></table></figure>

<p>This function changes the status of the task (a task is the kernel data structure which holds information about a process and the system call it is in, if any) to <code>TASK_INTERRUPTIBLE</code> , which means that the task will not run until it is woken up somehow, and adds it to WaitQ, the queue of tasks waiting to access the file. Then, the function calls the scheduler to context switch to a different process, one which has some use for the CPU.<br>该函数将任务的状态（任务是内核数据结构，保存有关进程及其所在系统调用的信息，如果有的话）更改为 <code>TASK_INTERRUPTIBLE</code> ，这意味着该任务将不会运行直到它以某种方式被唤醒，并将其添加到 WaitQ（等待访问文件的任务队列）。然后，该函数调用调度程序将上下文切换到另一个进程，该进程对 CPU 有一定的使用。</p>
<p>When a process is done with the file, it closes it, and <code>module_close</code> is called. That function wakes up all the processes in the queue (there’s no mechanism to only wake up one of them). It then returns and the process which just closed the file can continue to run. In time, the scheduler decides that that process has had enough and gives control of the CPU to another process. Eventually, one of the processes which was in the queue will be given control of the CPU by the scheduler. It starts at the point right after the call to <code>wait_event_interruptible</code> .<br>当进程处理完该文件后，它会关闭该文件，并调用 <code>module_close</code> 。该函数会唤醒队列中的所有进程（没有机制只能唤醒其中一个进程）。然后它返回，刚刚关闭文件的进程可以继续运行。随着时间的推移，调度程序认为该进程已经受够了，并将 CPU 控制权交给另一个进程。最终，队列中的进程之一将由调度程序授予 CPU 控制权。它从调用 <code>wait_event_interruptible</code> 之后的位置开始。</p>
<p>This means that the process is still in kernel mode - as far as the process is concerned, it issued the open system call and the system call has not returned yet. The process does not know somebody else used the CPU for most of the time between the moment it issued the call and the moment it returned.<br>这意味着该进程仍处于内核模式 - 就该进程而言，它发出了 open 系统调用，并且该系统调用尚未返回。从发出调用到返回的大部分时间里，进程并不知道其他人使用了 CPU。</p>
<p>It can then proceed to set a global variable to tell all the other processes that the file is still open and go on with its life. When the other processes get a piece of the CPU, they’ll see that global variable and go back to sleep.<br>然后它可以继续设置一个全局变量来告诉所有其他进程该文件仍然打开并继续其生命周期。当其他进程获得 CPU 的一部分时，它们将看到该全局变量并返回睡眠状态。</p>
<p>So we will use <code>tail -f</code> to keep the file open in the background, while trying to access it with another process (again in the background, so that we need not switch to a different vt). As soon as the first background process is killed with kill %1 , the second is woken up, is able to access the file and finally terminates.<br>因此，我们将使用 <code>tail -f</code> 使文件在后台保持打开状态，同时尝试使用另一个进程访问它（再次在后台，这样我们就不需要切换到不同的 vt）。一旦第一个后台进程被 Kill %1 杀死，第二个后台进程就会被唤醒，能够访问该文件并最终终止。</p>
<p>To make our life more interesting, <code>module_close</code> does not have a monopoly on waking up the processes which wait to access the file. A signal, such as Ctrl +c (SIGINT) can also wake up a process. This is because we used <code>wait_event_interruptible</code> . We could have used <code>wait_event</code> instead, but that would have resulted in extremely angry users whose Ctrl+c’s are ignored.<br>为了让我们的生活更有趣， <code>module_close</code> 并不垄断唤醒等待访问文件的进程。信号，例如 Ctrl +c (SIGINT) 也可以唤醒进程。这是因为我们使用了 <code>wait_event_interruptible</code> 。我们本来可以使用 <code>wait_event</code> 来代替，但这会导致用户非常愤怒，他们的 Ctrl+c 会被忽略。</p>
<p>In that case, we want to return with <code>-EINTR</code> immediately. This is important so users can, for example, kill the process before it receives the file.<br>在这种情况下，我们希望立即返回 <code>-EINTR</code> 。这很重要，例如，用户可以在进程收到文件之前终止该进程。</p>
<p>There is one more point to remember. Some times processes don’t want to sleep, they want either to get what they want immediately, or to be told it cannot be done. Such processes use the <code>O_NONBLOCK</code> flag when opening the file. The kernel is supposed to respond by returning with the error code <code>-EAGAIN</code> from operations which would otherwise block, such as opening the file in this example. The program <code>cat_nonblock</code> , available in the examples&#x2F;other directory, can be used to open a file with <code>O_NONBLOCK</code> .<br>还有一点要记住。有时进程不想休眠，它们想要立即得到它们想要的东西，或者被告知它无法完成。此类进程在打开文件时使用 <code>O_NONBLOCK</code> 标志。内核应该通过从否则会阻塞的操作返回错误代码 <code>-EAGAIN</code> 来做出响应，例如在本例中打开文件。程序 <code>cat_nonblock</code> 位于 Examples&#x2F;other 目录中，可用于使用 <code>O_NONBLOCK</code> 打开文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo insmod sleep.ko</span><br><span class="line">$ cat_nonblock /proc/sleep</span><br><span class="line">Last input:</span><br><span class="line">$ <span class="built_in">tail</span> -f /proc/sleep &amp;</span><br><span class="line">Last input:</span><br><span class="line">Last input:</span><br><span class="line">Last input:</span><br><span class="line">Last input:</span><br><span class="line">Last input:</span><br><span class="line">Last input:</span><br><span class="line">Last input:</span><br><span class="line"><span class="built_in">tail</span>: /proc/sleep: file truncated</span><br><span class="line">[1] 6540</span><br><span class="line">$ cat_nonblock /proc/sleep</span><br><span class="line">Open would block</span><br><span class="line">$ <span class="built_in">kill</span> %1</span><br><span class="line">[1]+  Terminated              <span class="built_in">tail</span> -f /proc/sleep</span><br><span class="line">$ cat_nonblock /proc/sleep</span><br><span class="line">Last input:</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sleep.c - create a /proc file, and if several processes try to open it</span></span><br><span class="line"><span class="comment"> * at the same time, put all but one to sleep.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">/* for sprintf() */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> <span class="comment">/* Specifically, a module */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span> <span class="comment">/* Necessary because we use proc fs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> <span class="comment">/* for get_user and put_user */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span> <span class="comment">/* For putting processes to sleep and</span></span></span><br><span class="line"><span class="comment"><span class="meta">                                   waking them up */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/current.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 6, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAVE_PROC_OPS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Here we keep the last message received, to prove that we can process our</span></span><br><span class="line"><span class="comment"> * input.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESSAGE_LENGTH 80</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> message[MESSAGE_LENGTH];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">our_proc_file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROC_ENTRY_FILENAME <span class="string">&quot;sleep&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Since we use the file operations struct, we can&#x27;t use the special proc</span></span><br><span class="line"><span class="comment"> * output provisions - we have to use a standard read function, which is this</span></span><br><span class="line"><span class="comment"> * function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">module_output</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="comment">/* see include/linux/fs.h   */</span></span></span><br><span class="line"><span class="params">                             <span class="type">char</span> __user *buf, <span class="comment">/* The buffer to put data to</span></span></span><br><span class="line"><span class="comment"><span class="params">                                                   (in the user segment)    */</span></span></span><br><span class="line"><span class="params">                             <span class="type">size_t</span> len, <span class="comment">/* The length of the buffer */</span></span></span><br><span class="line"><span class="params">                             <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> finished = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> output_msg[MESSAGE_LENGTH + <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return 0 to signify end of file - that we have nothing more to say</span></span><br><span class="line"><span class="comment">     * at this point.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">        finished = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(output_msg, <span class="string">&quot;Last input:%s\n&quot;</span>, message);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len &amp;&amp; output_msg[i]; i++)</span><br><span class="line">        put_user(output_msg[i], buf + i);</span><br><span class="line"></span><br><span class="line">    finished = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">/* Return the number of bytes &quot;read&quot; */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This function receives input from the user when the user writes to the</span></span><br><span class="line"><span class="comment"> * /proc file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">module_input</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="comment">/* The file itself */</span></span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="comment">/* The buffer with input */</span></span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span> length, <span class="comment">/* The buffer&#x27;s length */</span></span></span><br><span class="line"><span class="params">                            <span class="type">loff_t</span> *offset)</span> <span class="comment">/* offset to file - ignore */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Put the input into Message, where module_output will later be able</span></span><br><span class="line"><span class="comment">     * to use it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MESSAGE_LENGTH - <span class="number">1</span> &amp;&amp; i &lt; length; i++)</span><br><span class="line">        get_user(message[i], buf + i);</span><br><span class="line">    <span class="comment">/* we want a standard, zero terminated string */</span></span><br><span class="line">    message[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to return the number of input characters used */</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1 if the file is currently open by somebody */</span></span><br><span class="line"><span class="type">static</span> <span class="type">atomic_t</span> already_open = ATOMIC_INIT(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Queue of processes who want our file */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(waitq)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called when the /proc file is opened */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">module_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* If the file&#x27;s flags include O_NONBLOCK, it means the process does not</span></span><br><span class="line"><span class="comment">     * want to wait for the file. In this case, if the file is already open,</span></span><br><span class="line"><span class="comment">     * we should fail with -EAGAIN, meaning &quot;you will have to try again&quot;,</span></span><br><span class="line"><span class="comment">     * instead of blocking a process which would rather stay awake.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((file-&gt;f_flags &amp; O_NONBLOCK) &amp;&amp; <span class="type">atomic_read</span>(&amp;already_open))</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is the correct place for try_module_get(THIS_MODULE) because if</span></span><br><span class="line"><span class="comment">     * a process is in the loop, which is within the kernel module,</span></span><br><span class="line"><span class="comment">     * the kernel module must not be removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    try_module_get(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (atomic_cmpxchg(&amp;already_open, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> i, is_sig = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This function puts the current process, including any system</span></span><br><span class="line"><span class="comment">         * calls, such as us, to sleep.  Execution will be resumed right</span></span><br><span class="line"><span class="comment">         * after the function call, either because somebody called</span></span><br><span class="line"><span class="comment">         * wake_up(&amp;waitq) (only module_close does that, when the file</span></span><br><span class="line"><span class="comment">         * is closed) or when a signal, such as Ctrl-C, is sent</span></span><br><span class="line"><span class="comment">         * to the process</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        wait_event_interruptible(waitq, !<span class="type">atomic_read</span>(&amp;already_open));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we woke up because we got a signal we&#x27;re not blocking,</span></span><br><span class="line"><span class="comment">         * return -EINTR (fail the system call).  This allows processes</span></span><br><span class="line"><span class="comment">         * to be killed or stopped.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; _NSIG_WORDS &amp;&amp; !is_sig; i++)</span><br><span class="line">            is_sig = current-&gt;pending.signal.sig[i] &amp; ~current-&gt;blocked.sig[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_sig) &#123;</span><br><span class="line">            <span class="comment">/* It is important to put module_put(THIS_MODULE) here, because</span></span><br><span class="line"><span class="comment">             * for processes where the open is interrupted there will never</span></span><br><span class="line"><span class="comment">             * be a corresponding close. If we do not decrement the usage</span></span><br><span class="line"><span class="comment">             * count here, we will be left with a positive usage count</span></span><br><span class="line"><span class="comment">             * which we will have no way to bring down to zero, giving us</span></span><br><span class="line"><span class="comment">             * an immortal module, which can only be killed by rebooting</span></span><br><span class="line"><span class="comment">             * the machine.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            module_put(THIS_MODULE);</span><br><span class="line">            <span class="keyword">return</span> -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Allow the access */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called when the /proc file is closed */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">module_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Set already_open to zero, so one of the processes in the waitq will</span></span><br><span class="line"><span class="comment">     * be able to set already_open back to one and to open the file. All</span></span><br><span class="line"><span class="comment">     * the other processes will be called when already_open is back to one,</span></span><br><span class="line"><span class="comment">     * so they&#x27;ll go back to sleep.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">atomic_set</span>(&amp;already_open, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wake up all the processes in waitq, so if anybody is waiting for the</span></span><br><span class="line"><span class="comment">     * file, they can have it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    wake_up(&amp;waitq);</span><br><span class="line"></span><br><span class="line">    module_put(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* success */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Structures to register as the /proc file, with pointers to all the relevant</span></span><br><span class="line"><span class="comment"> * functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* File operations for our proc file. This is where we place pointers to all</span></span><br><span class="line"><span class="comment"> * the functions called when somebody tries to do something to our file. NULL</span></span><br><span class="line"><span class="comment"> * means we don&#x27;t want to deal with something.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PROC_OPS</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">file_ops_4_our_proc_file</span> =</span> &#123;</span><br><span class="line">    .proc_read = module_output, <span class="comment">/* &quot;read&quot; from the file */</span></span><br><span class="line">    .proc_write = module_input, <span class="comment">/* &quot;write&quot; to the file */</span></span><br><span class="line">    .proc_open = module_open, <span class="comment">/* called when the /proc file is opened */</span></span><br><span class="line">    .proc_release = module_close, <span class="comment">/* called when it&#x27;s closed */</span></span><br><span class="line">    .proc_lseek = noop_llseek, <span class="comment">/* return file-&gt;f_pos */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">file_ops_4_our_proc_file</span> =</span> &#123;</span><br><span class="line">    .read = module_output,</span><br><span class="line">    .write = module_input,</span><br><span class="line">    .open = module_open,</span><br><span class="line">    .release = module_close,</span><br><span class="line">    .llseek = noop_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize the module - register the proc file */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">sleep_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    our_proc_file =</span><br><span class="line">        proc_create(PROC_ENTRY_FILENAME, <span class="number">0644</span>, <span class="literal">NULL</span>, &amp;file_ops_4_our_proc_file);</span><br><span class="line">    <span class="keyword">if</span> (our_proc_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pr_debug(<span class="string">&quot;Error: Could not initialize /proc/%s\n&quot;</span>, PROC_ENTRY_FILENAME);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    proc_set_size(our_proc_file, <span class="number">80</span>);</span><br><span class="line">    proc_set_user(our_proc_file, GLOBAL_ROOT_UID, GLOBAL_ROOT_GID);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;/proc/%s created\n&quot;</span>, PROC_ENTRY_FILENAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Cleanup - unregister our file from /proc.  This could get dangerous if</span></span><br><span class="line"><span class="comment"> * there are still processes waiting in waitq, because they are inside our</span></span><br><span class="line"><span class="comment"> * open function, which will get unloaded. I&#x27;ll explain how to avoid removal</span></span><br><span class="line"><span class="comment"> * of a kernel module in such a case in chapter 10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">sleep_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    remove_proc_entry(PROC_ENTRY_FILENAME, <span class="literal">NULL</span>);</span><br><span class="line">    pr_debug(<span class="string">&quot;/proc/%s removed\n&quot;</span>, PROC_ENTRY_FILENAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(sleep_init);</span><br><span class="line">module_exit(sleep_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  cat_nonblock.c - open a file and display its contents, but exit rather than</span></span><br><span class="line"><span class="comment"> *  wait for input.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span> <span class="comment">/* for errno */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> <span class="comment">/* for open */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">/* standard I/O */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">/* for exit */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">/* for read */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BYTES 1024 * 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* The file descriptor for the file to read */</span></span><br><span class="line">    <span class="type">size_t</span> bytes; <span class="comment">/* The number of bytes read */</span></span><br><span class="line">    <span class="type">char</span> buffer[MAX_BYTES]; <span class="comment">/* The buffer for the bytes */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Usage */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;filename&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Reads the content of a file, but doesn&#x27;t wait for input&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open the file for reading in non blocking mode */</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDONLY | O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If open failed */</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(errno == EAGAIN ? <span class="string">&quot;Open would block&quot;</span> : <span class="string">&quot;Open failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read the file and output its contents */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* Read characters from the file */</span></span><br><span class="line">        bytes = read(fd, buffer, MAX_BYTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If there&#x27;s an error, report it and die */</span></span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Normally I&#x27;d block, but you told me not to&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Another read error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Print the characters */</span></span><br><span class="line">        <span class="keyword">if</span> (bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bytes; i++)</span><br><span class="line">                <span class="built_in">putchar</span>(buffer[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* While there are no errors and the file isn&#x27;t over */</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (bytes &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-2-Completions-11-2-竣工"><a href="#11-2-Completions-11-2-竣工" class="headerlink" title="11.2 Completions 11.2 竣工"></a>11.2 Completions 11.2 竣工</h4><p>Sometimes one thing should happen before another within a module having multiple threads. Rather than using <code>/bin/sleep</code> commands, the kernel has another way to do this which allows timeouts or interrupts to also happen.<br>有时，在具有多个线程的模块中，一件事应该在另一件事之前发生。内核不使用 <code>/bin/sleep</code> 命令，而是使用另一种方法来执行此操作，该方法也允许发生超时或中断。</p>
<p>In the following example two threads are started, but one needs to start before another.<br>在以下示例中，启动了两个线程，但其中一个线程需要在另一个线程之前启动。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * completions.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/completion.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/err.h&gt;</span> <span class="comment">/* for IS_ERR() */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">crank_comp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">flywheel_comp</span>;</span></span><br><span class="line">&#125; machine;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">machine_crank_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Turn the crank\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    complete_all(&amp;machine.crank_comp);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 17, 0)</span></span><br><span class="line">    kthread_complete_and_exit(&amp;machine.crank_comp, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    complete_and_exit(&amp;machine.crank_comp, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">machine_flywheel_spinup_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    wait_for_completion(&amp;machine.crank_comp);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Flywheel spins up\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    complete_all(&amp;machine.flywheel_comp);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 17, 0)</span></span><br><span class="line">    kthread_complete_and_exit(&amp;machine.flywheel_comp, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    complete_and_exit(&amp;machine.flywheel_comp, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">completions_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">crank_thread</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">flywheel_thread</span>;</span></span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;completions example\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    init_completion(&amp;machine.crank_comp);</span><br><span class="line">    init_completion(&amp;machine.flywheel_comp);</span><br><span class="line"></span><br><span class="line">    crank_thread = kthread_create(machine_crank_thread, <span class="literal">NULL</span>, <span class="string">&quot;KThread Crank&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(crank_thread))</span><br><span class="line">        <span class="keyword">goto</span> ERROR_THREAD_1;</span><br><span class="line"></span><br><span class="line">    flywheel_thread = kthread_create(machine_flywheel_spinup_thread, <span class="literal">NULL</span>,</span><br><span class="line">                                     <span class="string">&quot;KThread Flywheel&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(flywheel_thread))</span><br><span class="line">        <span class="keyword">goto</span> ERROR_THREAD_2;</span><br><span class="line"></span><br><span class="line">    wake_up_process(flywheel_thread);</span><br><span class="line">    wake_up_process(crank_thread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ERROR_THREAD_2:</span><br><span class="line">    kthread_stop(crank_thread);</span><br><span class="line">ERROR_THREAD_1:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">completions_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    wait_for_completion(&amp;machine.crank_comp);</span><br><span class="line">    wait_for_completion(&amp;machine.flywheel_comp);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;completions exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(completions_init);</span><br><span class="line">module_exit(completions_exit);</span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Completions example&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>The <code>machine</code> structure stores the completion states for the two threads. At the exit point of each thread the respective completion state is updated, and <code>wait_for_completion</code> is used by the flywheel thread to ensure that it does not begin prematurely.<br><code>machine</code> 结构存储两个线程的完成状态。在每个线程的退出点，相应的完成状态都会更新，飞轮线程使用 <code>wait_for_completion</code> 来确保它不会过早开始。</p>
<p>So even though <code>flywheel_thread</code> is started first you should notice if you load this module and run <code>dmesg</code> that turning the crank always happens first because the flywheel thread waits for it to complete.<br>因此，即使首先启动 <code>flywheel_thread</code> ，您也应该注意到，如果加载此模块并运行 <code>dmesg</code> ，转动曲柄总是首先发生，因为飞轮线程等待它完成。</p>
<p>There are other variations upon the <code>wait_for_completion</code> function, which include timeouts or being interrupted, but this basic mechanism is enough for many common situations without adding a lot of complexity.<br><code>wait_for_completion</code> 函数还有其他变体，其中包括超时或中断，但这种基本机制足以满足许多常见情况，而不会增加很多复杂性。</p>
<h3 id="12-Avoiding-Collisions-and-Deadlocks"><a href="#12-Avoiding-Collisions-and-Deadlocks" class="headerlink" title="12 Avoiding Collisions and Deadlocks"></a>12 Avoiding Collisions and Deadlocks</h3><p>12 避免冲突和死锁</p>
<p>If processes running on different CPUs or in different threads try to access the same memory, then it is possible that strange things can happen or your system can lock up. To avoid this, various types of mutual exclusion kernel functions are available. These indicate if a section of code is “locked” or “unlocked” so that simultaneous attempts to run it can not happen.<br>如果在不同 CPU 或不同线程上运行的进程尝试访问相同的内存，则可能会发生奇怪的事情或者您的系统可能会锁定。为了避免这种情况，可以使用各种类型的互斥内核函数。这些指示一段代码是否被“锁定”或“解锁”，以便不能同时尝试运行它。</p>
<h4 id="12-1-Mutex-12-1-互斥体"><a href="#12-1-Mutex-12-1-互斥体" class="headerlink" title="12.1 Mutex 12.1 互斥体"></a>12.1 Mutex 12.1 互斥体</h4><p>You can use kernel mutexes (mutual exclusions) in much the same manner that you might deploy them in userland. This may be all that is needed to avoid collisions in most cases.<br>您可以使用内核互斥体（互斥），其方式与在用户态中部署它们的方式大致相同。在大多数情况下，这可能是避免碰撞所需的全部内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * example_mutex.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_MUTEX</span><span class="params">(mymutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">example_mutex_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;example_mutex init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ret = mutex_trylock(&amp;mymutex);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        pr_info(<span class="string">&quot;mutex is locked\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_is_locked(&amp;mymutex) == <span class="number">0</span>)</span><br><span class="line">            pr_info(<span class="string">&quot;The mutex failed to lock!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;mymutex);</span><br><span class="line">        pr_info(<span class="string">&quot;mutex is unlocked\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        pr_info(<span class="string">&quot;Failed to lock\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">example_mutex_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;example_mutex exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(example_mutex_init);</span><br><span class="line">module_exit(example_mutex_exit);</span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Mutex example&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="12-2-Spinlocks-12-2-自旋锁"><a href="#12-2-Spinlocks-12-2-自旋锁" class="headerlink" title="12.2 Spinlocks 12.2 自旋锁"></a>12.2 Spinlocks 12.2 自旋锁</h4><p>As the name suggests, spinlocks lock up the CPU that the code is running on, taking 100% of its resources. Because of this you should only use the spinlock mechanism around code which is likely to take no more than a few milliseconds to run and so will not noticeably slow anything down from the user’s point of view.<br>顾名思义，自旋锁会锁定正在运行代码的 CPU，占用其 100% 的资源。因此，您应该只在运行时间可能不超过几毫秒的代码周围使用自旋锁机制，因此从用户的角度来看不会明显减慢任何速度。</p>
<p>The example here is “irq safe” in that if interrupts happen during the lock then they will not be forgotten and will activate when the unlock happens, using the <code>flags</code> variable to retain their state.<br>这里的例子是“irq 安全”的，因为如果在锁定期间发生中断，那么它们将不会被忘记，并且会在解锁发生时激活，使用 <code>flags</code> 变量来保留它们的状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * example_spinlock.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_SPINLOCK</span><span class="params">(sl_static)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">spinlock_t</span> sl_dynamic;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">example_spinlock_static</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;sl_static, flags);</span><br><span class="line">    pr_info(<span class="string">&quot;Locked static spinlock\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do something or other safely. Because this uses 100% CPU time, this</span></span><br><span class="line"><span class="comment">     * code should take no more than a few milliseconds to run.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;sl_static, flags);</span><br><span class="line">    pr_info(<span class="string">&quot;Unlocked static spinlock\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">example_spinlock_dynamic</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    spin_lock_init(&amp;sl_dynamic);</span><br><span class="line">    spin_lock_irqsave(&amp;sl_dynamic, flags);</span><br><span class="line">    pr_info(<span class="string">&quot;Locked dynamic spinlock\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do something or other safely. Because this uses 100% CPU time, this</span></span><br><span class="line"><span class="comment">     * code should take no more than a few milliseconds to run.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;sl_dynamic, flags);</span><br><span class="line">    pr_info(<span class="string">&quot;Unlocked dynamic spinlock\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">example_spinlock_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;example spinlock started\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    example_spinlock_static();</span><br><span class="line">    example_spinlock_dynamic();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">example_spinlock_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;example spinlock exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(example_spinlock_init);</span><br><span class="line">module_exit(example_spinlock_exit);</span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Spinlock example&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="12-3-Read-and-write-locks"><a href="#12-3-Read-and-write-locks" class="headerlink" title="12.3 Read and write locks"></a>12.3 Read and write locks</h4><p>12.3 读写锁</p>
<p>Read and write locks are specialised kinds of spinlocks so that you can exclusively read from something or write to something. Like the earlier spinlocks example, the one below shows an “irq safe” situation in which if other functions were triggered from irqs which might also read and write to whatever you are concerned with then they would not disrupt the logic. As before it is a good idea to keep anything done within the lock as short as possible so that it does not hang up the system and cause users to start revolting against the tyranny of your module.<br>读锁和写锁是特殊类型的自旋锁，因此您可以独占地读取某些内容或写入某些内容。与前面的自旋锁示例一样，下面的示例显示了一种“irq 安全”情况，其中如果从 irq 触发其他函数，这些函数也可能读取和写入您所关心的任何内容，那么它们不会破坏逻辑。和以前一样，最好让锁内完成的任何事情尽可能短，这样就不会挂起系统并导致用户开始反抗模块的暴政。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * example_rwlock.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/rwlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_RWLOCK</span><span class="params">(myrwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">example_read_lock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    read_lock_irqsave(&amp;myrwlock, flags);</span><br><span class="line">    pr_info(<span class="string">&quot;Read Locked\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read from something */</span></span><br><span class="line"></span><br><span class="line">    read_unlock_irqrestore(&amp;myrwlock, flags);</span><br><span class="line">    pr_info(<span class="string">&quot;Read Unlocked\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">example_write_lock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    write_lock_irqsave(&amp;myrwlock, flags);</span><br><span class="line">    pr_info(<span class="string">&quot;Write Locked\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write to something */</span></span><br><span class="line"></span><br><span class="line">    write_unlock_irqrestore(&amp;myrwlock, flags);</span><br><span class="line">    pr_info(<span class="string">&quot;Write Unlocked\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">example_rwlock_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;example_rwlock started\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    example_read_lock();</span><br><span class="line">    example_write_lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">example_rwlock_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;example_rwlock exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(example_rwlock_init);</span><br><span class="line">module_exit(example_rwlock_exit);</span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Read/Write locks example&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Of course, if you know for sure that there are no functions triggered by irqs which could possibly interfere with your logic then you can use the simpler <code>read_lock(&amp;myrwlock)</code> and <code>read_unlock(&amp;myrwlock)</code> or the corresponding write functions.<br>当然，如果您确定没有由 irqs 触发的函数可能会干扰您的逻辑，那么您可以使用更简单的 <code>read_lock(&amp;myrwlock)</code> 和 <code>read_unlock(&amp;myrwlock)</code> 或相应的写入函数。</p>
<h4 id="12-4-Atomic-operations-12-4-原子操作"><a href="#12-4-Atomic-operations-12-4-原子操作" class="headerlink" title="12.4 Atomic operations 12.4 原子操作"></a>12.4 Atomic operations 12.4 原子操作</h4><p>If you are doing simple arithmetic: adding, subtracting or bitwise operations, then there is another way in the multi-CPU and multi-hyperthreaded world to stop other parts of the system from messing with your mojo. By using atomic operations you can be confident that your addition, subtraction or bit flip did actually happen and was not overwritten by some other shenanigans. An example is shown below.<br>如果您正在做简单的算术：加法、减法或按位运算，那么在多 CPU 和多超线程世界中还有另一种方法可以阻止系统的其他部分扰乱您的魔力。通过使用原子操作，您可以确信您的加法、减法或位翻转确实发生了，并且没有被其他一些恶作剧覆盖。一个例子如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * example_atomic.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bitops.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE_TO_BINARY_PATTERN <span class="string">&quot;%c%c%c%c%c%c%c%c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE_TO_BINARY(byte)                                                   \</span></span><br><span class="line"><span class="meta">    ((byte &amp; 0x80) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>), ((byte &amp; 0x40) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>),                  \</span></span><br><span class="line"><span class="meta">        ((byte &amp; 0x20) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>), ((byte &amp; 0x10) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>),              \</span></span><br><span class="line"><span class="meta">        ((byte &amp; 0x08) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>), ((byte &amp; 0x04) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>),              \</span></span><br><span class="line"><span class="meta">        ((byte &amp; 0x02) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>), ((byte &amp; 0x01) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">atomic_add_subtract</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">atomic_t</span> debbie;</span><br><span class="line">    <span class="type">atomic_t</span> chris = ATOMIC_INIT(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">atomic_set</span>(&amp;debbie, <span class="number">45</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* subtract one */</span></span><br><span class="line">    <span class="type">atomic_dec</span>(&amp;debbie);</span><br><span class="line"></span><br><span class="line">    <span class="type">atomic_add</span>(<span class="number">7</span>, &amp;debbie);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add one */</span></span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;debbie);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;chris: %d, debbie: %d\n&quot;</span>, <span class="type">atomic_read</span>(&amp;chris),</span><br><span class="line">            <span class="type">atomic_read</span>(&amp;debbie));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">atomic_bitwise</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> word = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Bits 0: &quot;</span> BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));</span><br><span class="line">    set_bit(<span class="number">3</span>, &amp;word);</span><br><span class="line">    set_bit(<span class="number">5</span>, &amp;word);</span><br><span class="line">    pr_info(<span class="string">&quot;Bits 1: &quot;</span> BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));</span><br><span class="line">    clear_bit(<span class="number">5</span>, &amp;word);</span><br><span class="line">    pr_info(<span class="string">&quot;Bits 2: &quot;</span> BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));</span><br><span class="line">    change_bit(<span class="number">3</span>, &amp;word);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Bits 3: &quot;</span> BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));</span><br><span class="line">    <span class="keyword">if</span> (test_and_set_bit(<span class="number">3</span>, &amp;word))</span><br><span class="line">        pr_info(<span class="string">&quot;wrong\n&quot;</span>);</span><br><span class="line">    pr_info(<span class="string">&quot;Bits 4: &quot;</span> BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));</span><br><span class="line"></span><br><span class="line">    word = <span class="number">255</span>;</span><br><span class="line">    pr_info(<span class="string">&quot;Bits 5: &quot;</span> BYTE_TO_BINARY_PATTERN, BYTE_TO_BINARY(word));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">example_atomic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;example_atomic started\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    atomic_add_subtract();</span><br><span class="line">    atomic_bitwise();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">example_atomic_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;example_atomic exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(example_atomic_init);</span><br><span class="line">module_exit(example_atomic_exit);</span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Atomic operations example&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Before the C11 standard adopts the built-in atomic types, the kernel already provided a small set of atomic types by using a bunch of tricky architecture-specific codes. Implementing the atomic types by C11 atomics may allow the kernel to throw away the architecture-specific codes and letting the kernel code be more friendly to the people who understand the standard. But there are some problems, such as the memory model of the kernel doesn’t match the model formed by the C11 atomics. For further details, see:<br>在 C11 标准采用内置原子类型之前，内核已经通过使用一堆棘手的特定于体系结构的代码提供了一小部分原子类型。通过 C11 原子实现原子类型可以允许内核丢弃特定于体系结构的代码，并让内核代码对理解标准的人更加友好。但存在一些问题，例如内核的内存模型与 C11 原子形成的模型不匹配。有关更多详细信息，请参阅：</p>
<ul>
<li><a href="https://www.kernel.org/doc/Documentation/atomic_t.txt">kernel documentation of atomic types<br>原子类型的内核文档</a></li>
<li><a href="https://lwn.net/Articles/691128/">Time to move to C11 atomics?<br>是时候转向 C11 原子了吗？</a></li>
<li><a href="https://lwn.net/Articles/698315/">Atomic usage patterns in the kernel<br>内核中的原子使用模式</a></li>
</ul>
<h3 id="13-Replacing-Print-Macros"><a href="#13-Replacing-Print-Macros" class="headerlink" title="13 Replacing Print Macros"></a>13 Replacing Print Macros</h3><p>13 替换打印宏</p>
<h4 id="13-1-Replacement-13-1-更换"><a href="#13-1-Replacement-13-1-更换" class="headerlink" title="13.1 Replacement 13.1 更换"></a>13.1 Replacement 13.1 更换</h4><p>In Section <a href="https://sysprog21.github.io/lkmpg/#before-we-begin">1.7</a>, it was noted that the X Window System and kernel module programming are not conducive to integration. This remains valid during the development of kernel modules. However, in practical scenarios, the necessity emerges to relay messages to the tty (teletype) originating the module load command.<br>在 1.7 节中，指出 X Window 系统和内核模块编程不利于集成。这在内核模块的开发过程中仍然有效。然而，在实际场景中，需要将消息中继到发出模块加载命令的 tty（电传打字机）。</p>
<p>The term “tty” originates from teletype, which initially referred to a combined keyboard-printer for Unix system communication. Today, it signifies a text stream abstraction employed by Unix programs, encompassing physical terminals, xterms in X displays, and network connections like SSH.<br>“tty”一词源自电传打字机，最初指的是用于 Unix 系统通信的组合键盘打印机。今天，它表示 Unix 程序使用的文本流抽象，包括物理终端、X 显示器中的 xterm 以及 SSH 等网络连接。</p>
<p>To achieve this, the “current” pointer is leveraged to access the active task’s tty structure. Within this structure lies a pointer to a string write function, facilitating the string’s transmission to the tty.<br>为了实现这一点，利用“当前”指针来访问活动任务的 tty 结构。该结构中有一个指向字符串写入函数的指针，有助于将字符串传输到 tty。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * print_string.c - Send output to the tty we&#x27;re running on, regardless if</span></span><br><span class="line"><span class="comment"> * it is through X11, telnet, etc.  We do this by printing the string to the</span></span><br><span class="line"><span class="comment"> * tty associated with the current task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span> <span class="comment">/* For current */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span> <span class="comment">/* For the tty declarations */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">print_string</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* The tty for the current task */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">my_tty</span> =</span> get_current_tty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If my_tty is NULL, the current task has no tty you can print to (i.e.,</span></span><br><span class="line"><span class="comment">     * if it is a daemon). If so, there is nothing we can do.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (my_tty) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ttyops</span> =</span> my_tty-&gt;driver-&gt;ops;</span><br><span class="line">        <span class="comment">/* my_tty-&gt;driver is a struct which holds the tty&#x27;s functions,</span></span><br><span class="line"><span class="comment">         * one of which (write) is used to write strings to the tty.</span></span><br><span class="line"><span class="comment">         * It can be used to take a string either from the user&#x27;s or</span></span><br><span class="line"><span class="comment">         * kernel&#x27;s memory segment.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The function&#x27;s 1st parameter is the tty to write to, because the</span></span><br><span class="line"><span class="comment">         * same function would normally be used for all tty&#x27;s of a certain</span></span><br><span class="line"><span class="comment">         * type.</span></span><br><span class="line"><span class="comment">         * The 2nd parameter is a pointer to a string.</span></span><br><span class="line"><span class="comment">         * The 3rd parameter is the length of the string.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * As you will see below, sometimes it&#x27;s necessary to use</span></span><br><span class="line"><span class="comment">         * preprocessor stuff to create code that works for different</span></span><br><span class="line"><span class="comment">         * kernel versions. The (naive) approach we&#x27;ve taken here does not</span></span><br><span class="line"><span class="comment">         * scale well. The right way to deal with this is described in</span></span><br><span class="line"><span class="comment">         * section 2 of</span></span><br><span class="line"><span class="comment">         * linux/Documentation/SubmittingPatches</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        (ttyops-&gt;write)(my_tty, <span class="comment">/* The tty itself */</span></span><br><span class="line">                        str, <span class="comment">/* String */</span></span><br><span class="line">                        <span class="built_in">strlen</span>(str)); <span class="comment">/* Length */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ttys were originally hardware devices, which (usually) strictly</span></span><br><span class="line"><span class="comment">         * followed the ASCII standard. In ASCII, to move to a new line you</span></span><br><span class="line"><span class="comment">         * need two characters, a carriage return and a line feed. On Unix,</span></span><br><span class="line"><span class="comment">         * the ASCII line feed is used for both purposes - so we can not</span></span><br><span class="line"><span class="comment">         * just use \n, because it would not have a carriage return and the</span></span><br><span class="line"><span class="comment">         * next line will start at the column right after the line feed.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is why text files are different between Unix and MS Windows.</span></span><br><span class="line"><span class="comment">         * In CP/M and derivatives, like MS-DOS and MS Windows, the ASCII</span></span><br><span class="line"><span class="comment">         * standard was strictly adhered to, and therefore a newline requires</span></span><br><span class="line"><span class="comment">         * both a LF and a CR.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        (ttyops-&gt;write)(my_tty, <span class="string">&quot;\015\012&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">print_string_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print_string(<span class="string">&quot;The module has been inserted.  Hello world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">print_string_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print_string(<span class="string">&quot;The module has been removed.  Farewell world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(print_string_init);</span><br><span class="line">module_exit(print_string_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="13-2-Flashing-keyboard-LEDs"><a href="#13-2-Flashing-keyboard-LEDs" class="headerlink" title="13.2 Flashing keyboard LEDs"></a>13.2 Flashing keyboard LEDs</h4><p>13.2 键盘 LED 闪烁</p>
<p>In certain conditions, you may desire a simpler and more direct way to communicate to the external world. Flashing keyboard LEDs can be such a solution: It is an immediate way to attract attention or to display a status condition. Keyboard LEDs are present on every hardware, they are always visible, they do not need any setup, and their use is rather simple and non-intrusive, compared to writing to a tty or a file.<br>在某些情况下，您可能希望有一种更简单、更直接的方式与外部世界进行交流。闪烁的键盘 LED 可以是这样的解决方案：它是吸引注意力或显示状态条件的直接方法。每个硬件上都有键盘 LED，它们始终可见，不需要任何设置，并且与写入 tty 或文件相比，它们的使用相当简单且非侵入性。</p>
<p>From v4.14 to v4.15, the timer API made a series of changes to improve memory safety. A buffer overflow in the area of a <code>timer_list</code> structure may be able to overwrite the <code>function</code> and <code>data</code> fields, providing the attacker with a way to use return-object programming (ROP) to call arbitrary functions within the kernel. Also, the function prototype of the callback, containing a <code>unsigned long</code> argument, will prevent work from any type checking. Furthermore, the function prototype with <code>unsigned long</code> argument may be an obstacle to the forward-edge protection of control-flow integrity. Thus, it is better to use a unique prototype to separate from the cluster that takes an <code>unsigned long</code> argument. The timer callback should be passed a pointer to the <code>timer_list</code> structure rather than an <code>unsigned long</code> argument. Then, it wraps all the information the callback needs, including the <code>timer_list</code> structure, into a larger structure, and it can use the <code>container_of</code> macro instead of the <code>unsigned long</code> value. For more information see: <a href="https://lwn.net/Articles/735887/">Improving the kernel timers API</a>.<br>从 v4.14 到 v4.15，定时器 API 进行了一系列更改以提高内存安全性。 <code>timer_list</code> 结构区域中的缓冲区溢出可能会覆盖 <code>function</code> 和 <code>data</code> 字段，为攻击者提供使用返回对象的方法编程（ROP）来调用内核中的任意函数。此外，包含 <code>unsigned long</code> 参数的回调函数原型将阻止任何类型检查的工作。此外，带有 <code>unsigned long</code> 参数的函数原型可能会成为控制流完整性的前缘保护的障碍。因此，最好使用唯一的原型来与采用 <code>unsigned long</code> 参数的集群分开。计时器回调应该传递一个指向 <code>timer_list</code> 结构的指针，而不是 <code>unsigned long</code> 参数。然后，它将回调所需的所有信息（包括 <code>timer_list</code> 结构）包装到一个更大的结构中，并且可以使用 <code>container_of</code> 宏代替 <code>unsigned long</code> 价值。有关更多信息，请参阅：改进内核计时器 API。</p>
<p>Before Linux v4.14, <code>setup_timer</code> was used to initialize the timer and the <code>timer_list</code> structure looked like:<br>在 Linux v4.14 之前， <code>setup_timer</code> 用于初始化计时器， <code>timer_list</code> 结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires;</span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">    u32 flags;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer, <span class="type">void</span> (*callback)(<span class="type">unsigned</span> <span class="type">long</span>),</span></span><br><span class="line"><span class="params">                 <span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br></pre></td></tr></table></figure>

<p>Since Linux v4.14, <code>timer_setup</code> is adopted and the kernel step by step converting to <code>timer_setup</code> from <code>setup_timer</code> . One of the reasons why API was changed is it need to coexist with the old version interface. Moreover, the <code>timer_setup</code> was implemented by <code>setup_timer</code> at first.<br>从 Linux v4.14 开始，采用 <code>timer_setup</code> ，内核逐步从 <code>setup_timer</code> 转换为 <code>timer_setup</code> 。 API 变更的原因之一是需要与旧版本接口共存。而且， <code>timer_setup</code> 最初是由 <code>setup_timer</code> 实现的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_setup</span><span class="params">(<span class="keyword">struct</span> timer_list *timer,</span></span><br><span class="line"><span class="params">                 <span class="type">void</span> (*callback)(<span class="keyword">struct</span> timer_list *), <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>The <code>setup_timer</code> was then removed since v4.15. As a result, the <code>timer_list</code> structure had changed to the following.<br>自 v4.15 起， <code>setup_timer</code> 被删除。结果， <code>timer_list</code> 结构更改为以下内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires;</span><br><span class="line">    <span class="type">void</span> (*function)(<span class="keyword">struct</span> timer_list *);</span><br><span class="line">    u32 flags;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The following source code illustrates a minimal kernel module which, when loaded, starts blinking the keyboard LEDs until it is unloaded.<br>下面的源代码说明了一个最小的内核模块，加载后，键盘 LED 开始闪烁，直到卸载。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kbleds.c - Blink keyboard leds until the module is unloaded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kd.h&gt;</span> <span class="comment">/* For KDSETLED */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span> <span class="comment">/* For tty_struct */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/vt.h&gt;</span> <span class="comment">/* For MAX_NR_CONSOLES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/vt_kern.h&gt;</span> <span class="comment">/* for fg_console */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/console_struct.h&gt;</span> <span class="comment">/* For vc_cons */</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Example module illustrating the use of Keyboard LEDs.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">my_timer</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">my_driver</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> kbledstatus = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLINK_DELAY HZ / 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALL_LEDS_ON 0x07</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESTORE_LEDS 0xFF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Function my_timer_func blinks the keyboard LEDs periodically by invoking</span></span><br><span class="line"><span class="comment"> * command KDSETLED of ioctl() on the keyboard driver. To learn more on virtual</span></span><br><span class="line"><span class="comment"> * terminal ioctl operations, please see file:</span></span><br><span class="line"><span class="comment"> *   drivers/tty/vt/vt_ioctl.c, function vt_ioctl().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The argument to KDSETLED is alternatively set to 7 (thus causing the led</span></span><br><span class="line"><span class="comment"> * mode to be set to LED_SHOW_IOCTL, and all the leds are lit) and to 0xFF</span></span><br><span class="line"><span class="comment"> * (any value above 7 switches back the led mode to LED_SHOW_FLAGS, thus</span></span><br><span class="line"><span class="comment"> * the LEDs reflect the actual keyboard status).  To learn more on this,</span></span><br><span class="line"><span class="comment"> * please see file: drivers/tty/vt/keyboard.c, function setledstate().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_timer_func</span><span class="params">(<span class="keyword">struct</span> timer_list *unused)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">t</span> =</span> vc_cons[fg_console].d-&gt;port.tty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kbledstatus == ALL_LEDS_ON)</span><br><span class="line">        kbledstatus = RESTORE_LEDS;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        kbledstatus = ALL_LEDS_ON;</span><br><span class="line"></span><br><span class="line">    (my_driver-&gt;ops-&gt;ioctl)(t, KDSETLED, kbledstatus);</span><br><span class="line"></span><br><span class="line">    my_timer.expires = jiffies + BLINK_DELAY;</span><br><span class="line">    add_timer(&amp;my_timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kbleds_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;kbleds: loading\n&quot;</span>);</span><br><span class="line">    pr_info(<span class="string">&quot;kbleds: fgconsole is %x\n&quot;</span>, fg_console);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_NR_CONSOLES; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vc_cons[i].d)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        pr_info(<span class="string">&quot;poet_atkm: console[%i/%i] #%i, tty %p\n&quot;</span>, i, MAX_NR_CONSOLES,</span><br><span class="line">                vc_cons[i].d-&gt;vc_num, (<span class="type">void</span> *)vc_cons[i].d-&gt;port.tty);</span><br><span class="line">    &#125;</span><br><span class="line">    pr_info(<span class="string">&quot;kbleds: finished scanning consoles\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    my_driver = vc_cons[fg_console].d-&gt;port.tty-&gt;driver;</span><br><span class="line">    pr_info(<span class="string">&quot;kbleds: tty driver name %s\n&quot;</span>, my_driver-&gt;driver_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up the LED blink timer the first time. */</span></span><br><span class="line">    timer_setup(&amp;my_timer, my_timer_func, <span class="number">0</span>);</span><br><span class="line">    my_timer.expires = jiffies + BLINK_DELAY;</span><br><span class="line">    add_timer(&amp;my_timer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">kbleds_cleanup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;kbleds: unloading...\n&quot;</span>);</span><br><span class="line">    del_timer(&amp;my_timer);</span><br><span class="line">    (my_driver-&gt;ops-&gt;ioctl)(vc_cons[fg_console].d-&gt;port.tty, KDSETLED,</span><br><span class="line">                            RESTORE_LEDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(kbleds_init);</span><br><span class="line">module_exit(kbleds_cleanup);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>If none of the examples in this chapter fit your debugging needs, there might yet be some other tricks to try. Ever wondered what <code>CONFIG_LL_DEBUG</code> in <code>make menuconfig</code> is good for? If you activate that you get low level access to the serial port. While this might not sound very powerful by itself, you can patch <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/printk.c">kernel&#x2F;printk.c</a> or any other essential syscall to print ASCII characters, thus making it possible to trace virtually everything what your code does over a serial line. If you find yourself porting the kernel to some new and former unsupported architecture, this is usually amongst the first things that should be implemented. Logging over a netconsole might also be worth a try.<br>如果本章中的示例都不符合您的调试需求，可能还可以尝试一些其他技巧。有没有想过 <code>make menuconfig</code> 中的 <code>CONFIG_LL_DEBUG</code> 有什么用处？如果激活它，您将获得对串行端口的低级别访问权限。虽然这本身听起来不是很强大，但您可以修补 kernel&#x2F;printk.c 或任何其他必要的系统调用来打印 ASCII 字符，从而可以跟踪代码通过串行线路执行的几乎所有操作。如果您发现自己将内核移植到一些新的和以前不受支持的体系结构，这通常是首先应该实现的事情之一。通过网络控制台登录也可能值得一试。</p>
<p>While you have seen lots of stuff that can be used to aid debugging here, there are some things to be aware of. Debugging is almost always intrusive. Adding debug code can change the situation enough to make the bug seem to disappear. Thus, you should keep debug code to a minimum and make sure it does not show up in production code.<br>虽然您在这里看到了很多可用于帮助调试的内容，但仍有一些事情需要注意。调试几乎总是侵入性的。添加调试代码可以改变情况，足以使错误看起来消失。因此，您应该将调试代码保持在最低限度，并确保它不会出现在生产代码中。</p>
<h3 id="14-Scheduling-Tasks-14-调度任务"><a href="#14-Scheduling-Tasks-14-调度任务" class="headerlink" title="14 Scheduling Tasks 14 调度任务"></a>14 Scheduling Tasks 14 调度任务</h3><p>There are two main ways of running tasks: tasklets and work queues. Tasklets are a quick and easy way of scheduling a single function to be run. For example, when triggered from an interrupt, whereas work queues are more complicated but also better suited to running multiple things in a sequence.<br>运行任务有两种主要方式：tasklet 和工作队列。 Tasklet 是一种安排单个函数运行的快速而简单的方法。例如，当从中断触发时，工作队列更复杂，但也更适合按顺序运行多个事物。</p>
<h4 id="14-1-Tasklets-14-1-小任务"><a href="#14-1-Tasklets-14-1-小任务" class="headerlink" title="14.1 Tasklets 14.1 小任务"></a>14.1 Tasklets 14.1 小任务</h4><p>Here is an example tasklet module. The <code>tasklet_fn</code> function runs for a few seconds. In the meantime, execution of the <code>example_tasklet_init</code> function may continue to the exit point, depending on whether it is interrupted by softirq.<br>这是一个示例 tasklet 模块。 <code>tasklet_fn</code> 函数运行几秒钟。同时， <code>example_tasklet_init</code> 函数的执行可能会继续到退出点，具体取决于它是否被 softirq 中断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * example_tasklet.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macro DECLARE_TASKLET_OLD exists for compatibility.</span></span><br><span class="line"><span class="comment"> * See https://lwn.net/Articles/830964/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DECLARE_TASKLET_OLD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET_OLD(arg1, arg2) DECLARE_TASKLET(arg1, arg2, 0L)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tasklet_fn</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Example tasklet starts\n&quot;</span>);</span><br><span class="line">    mdelay(<span class="number">5000</span>);</span><br><span class="line">    pr_info(<span class="string">&quot;Example tasklet ends\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_TASKLET_OLD</span><span class="params">(mytask, tasklet_fn)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">example_tasklet_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;tasklet example init\n&quot;</span>);</span><br><span class="line">    tasklet_schedule(&amp;mytask);</span><br><span class="line">    mdelay(<span class="number">200</span>);</span><br><span class="line">    pr_info(<span class="string">&quot;Example tasklet init continues...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">example_tasklet_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;tasklet example exit\n&quot;</span>);</span><br><span class="line">    tasklet_kill(&amp;mytask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(example_tasklet_init);</span><br><span class="line">module_exit(example_tasklet_exit);</span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Tasklet example&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>So with this example loaded <code>dmesg</code> should show:<br>因此，加载此示例后 <code>dmesg</code> 应显示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tasklet example init</span><br><span class="line">Example tasklet starts</span><br><span class="line">Example tasklet init continues...</span><br><span class="line">Example tasklet ends</span><br></pre></td></tr></table></figure>

<p>Although tasklet is easy to use, it comes with several defators, and developers are discussing about getting rid of tasklet in linux kernel. The tasklet callback runs in atomic context, inside a software interrupt, meaning that it cannot sleep or access user-space data, so not all work can be done in a tasklet handler. Also, the kernel only allows one instance of any given tasklet to be running at any given time; multiple different tasklet callbacks can run in parallel.<br>虽然 tasklet 很容易使用，但它带有几个 defators，开发人员正在讨论在 linux 内核中摆脱 tasklet。小任务回调在软件中断内的原子上下文中运行，这意味着它无法休眠或访问用户空间数据，因此并非所有工作都可以在小任务处理程序中完成。此外，内核只允许任何给定微线程的一个实例在任何给定时间运行；多个不同的 tasklet 回调可以并行运行。</p>
<p>In recent kernels, tasklets can be replaced by workqueues, timers, or threaded interrupts.<a href="https://sysprog21.github.io/lkmpg/#fn1x0"><sup data-immersive-translate-effect="1" data-immersive_translate_walked="8ab93f9b-58ac-4b89-b455-647ae1c1af85">1</sup></a> While the removal of tasklets remains a longer-term goal, the current kernel contains more than a hundred uses of tasklets. Now developers are proceeding with the API changes and the macro <code>DECLARE_TASKLET_OLD</code> exists for compatibility. For further information, see <a href="https://lwn.net/Articles/830964/">https://lwn.net/Articles/830964/</a>.<br>在最近的内核中，tasklet 可以被工作队列、定时器或线程中断所取代。 <sup data-immersive-translate-effect="1" data-immersive_translate_walked="8ab93f9b-58ac-4b89-b455-647ae1c1af85">1</sup> 虽然删除微线程仍然是一个长期目标，但当前内核包含一百多种微线程的用途。现在开发人员正在继续进行 API 更改，宏 <code>DECLARE_TASKLET_OLD</code> 的存在是为了兼容。有关更多信息，请参阅 <a href="https://lwn.net/Articles/830964/%E3%80%82">https://lwn.net/Articles/830964/。</a></p>
<h4 id="14-2-Work-queues-14-2-工作队列"><a href="#14-2-Work-queues-14-2-工作队列" class="headerlink" title="14.2 Work queues 14.2 工作队列"></a>14.2 Work queues 14.2 工作队列</h4><p>To add a task to the scheduler we can use a workqueue. The kernel then uses the Completely Fair Scheduler (CFS) to execute work within the queue.<br>要将任务添加到调度程序，我们可以使用工作队列。然后，内核使用完全公平调度程序 (CFS) 来执行队列中的工作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sched.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">queue</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_handler</span><span class="params">(<span class="keyword">struct</span> work_struct *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;work handler function.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">sched_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">queue</span> = alloc_workqueue(<span class="string">&quot;HELLOWORLD&quot;</span>, WQ_UNBOUND, <span class="number">1</span>);</span><br><span class="line">    INIT_WORK(&amp;work, work_handler);</span><br><span class="line">    schedule_work(&amp;work);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">sched_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    destroy_workqueue(<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(sched_init);</span><br><span class="line">module_exit(sched_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Workqueue example&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="15-Interrupt-Handlers-15-个中断处理程序"><a href="#15-Interrupt-Handlers-15-个中断处理程序" class="headerlink" title="15 Interrupt Handlers 15 个中断处理程序"></a>15 Interrupt Handlers 15 个中断处理程序</h3><h4 id="15-1-Interrupt-Handlers-15-1-中断处理程序"><a href="#15-1-Interrupt-Handlers-15-1-中断处理程序" class="headerlink" title="15.1 Interrupt Handlers 15.1 中断处理程序"></a>15.1 Interrupt Handlers 15.1 中断处理程序</h4><p>Except for the last chapter, everything we did in the kernel so far we have done as a response to a process asking for it, either by dealing with a special file, sending an <code>ioctl()</code> , or issuing a system call. But the job of the kernel is not just to respond to process requests. Another job, which is every bit as important, is to speak to the hardware connected to the machine.<br>除了最后一章之外，到目前为止我们在内核中所做的一切都是为了响应进程的请求，无论是处理特殊文件，发送 <code>ioctl()</code> ，还是发出系统调用。但内核的工作不仅仅是响应进程请求。另一项同样重要的工作是与连接到机器的硬件进行通信。</p>
<p>There are two types of interaction between the CPU and the rest of the computer’s hardware. The first type is when the CPU gives orders to the hardware, the other is when the hardware needs to tell the CPU something. The second, called interrupts, is much harder to implement because it has to be dealt with when convenient for the hardware, not the CPU. Hardware devices typically have a very small amount of RAM, and if you do not read their information when available, it is lost.<br>CPU 和计算机硬件的其余部分之间有两种类型的交互。第一种是 CPU 向硬件发出命令，另一种是硬件需要告诉 CPU 一些事情。第二种称为中断，实现起来要困难得多，因为它必须在硬件（而不是 CPU）方便的时候进行处理。硬件设备通常具有非常少量的 RAM，如果您不读取可用的信息，这些信息就会丢失。</p>
<p>Under Linux, hardware interrupts are called IRQ’s (Interrupt ReQuests). There are two types of IRQ’s, short and long. A short IRQ is one which is expected to take a very short period of time, during which the rest of the machine will be blocked and no other interrupts will be handled. A long IRQ is one which can take longer, and during which other interrupts may occur (but not interrupts from the same device). If at all possible, it is better to declare an interrupt handler to be long.<br>在 Linux 下，硬件中断称为 IRQ（中断请求）。 IRQ 有两种类型：短中断和长中断。短 IRQ 是指预计需要很短时间的中断，在此期间机器的其余部分将被阻塞，并且不会处理其他中断。长 IRQ 可能需要更长的时间，并且在此期间可能会发生其他中断（但不是来自同一设备的中断）。如果可能的话，最好将中断处理程序声明得较长。</p>
<p>When the CPU receives an interrupt, it stops whatever it is doing (unless it is processing a more important interrupt, in which case it will deal with this one only when the more important one is done), saves certain parameters on the stack and calls the interrupt handler. This means that certain things are not allowed in the interrupt handler itself, because the system is in an unknown state. Linux kernel solves the problem by splitting interrupt handling into two parts. The first part executes right away and masks the interrupt line. Hardware interrupts must be handled quickly, and that is why we need the second part to handle the heavy work deferred from an interrupt handler. Historically, BH (Linux naming for Bottom Halves) statistically book-keeps the deferred functions. Softirq and its higher level abstraction, Tasklet, replace BH since Linux 2.3.<br>当 CPU 收到一个中断时，它会停止正在做的任何事情（除非它正在处理一个更重要的中断，在这种情况下，只有当更重要的中断完成时，它才会处理这个中断），将某些参数保存在堆栈上并调用中断处理程序。这意味着中断处理程序本身不允许执行某些操作，因为系统处于未知状态。 Linux 内核通过将中断处理分为两部分来解决这个问题。第一部分立即执行并屏蔽中断线。硬件中断必须快速处理，这就是为什么我们需要第二部分来处理中断处理程序推迟的繁重工作。从历史上看，BH（Linux 下半部分的命名）以统计方式记录延迟函数。自 Linux 2.3 起，Softirq 及其更高级别的抽象 Tasklet 取代了 BH。</p>
<p>The way to implement this is to call <code>request_irq()</code> to get your interrupt handler called when the relevant IRQ is received.<br>实现此目的的方法是调用 <code>request_irq()</code> 以在收到相关 IRQ 时调用中断处理程序。</p>
<p>In practice IRQ handling can be a bit more complex. Hardware is often designed in a way that chains two interrupt controllers, so that all the IRQs from interrupt controller B are cascaded to a certain IRQ from interrupt controller A. Of course, that requires that the kernel finds out which IRQ it really was afterwards and that adds overhead. Other architectures offer some special, very low overhead, so called “fast IRQ” or FIQs. To take advantage of them requires handlers to be written in assembly language, so they do not really fit into the kernel. They can be made to work similar to the others, but after that procedure, they are no longer any faster than “common” IRQs. SMP enabled kernels running on systems with more than one processor need to solve another truckload of problems. It is not enough to know if a certain IRQs has happened, it’s also important to know what CPU(s) it was for. People still interested in more details, might want to refer to “APIC” now.<br>实际上，IRQ 处理可能有点复杂。硬件通常设计为链接两个中断控制器，以便中断控制器 B 的所有 IRQ 都级联到中断控制器 A 的某个 IRQ。当然，这需要内核随后找出它到底是哪个 IRQ，并这会增加开销。其他架构提供一些特殊的、非常低的开销，即所谓的“快速 IRQ”或 FIQ。要利用它们，需要用汇编语言编写处理程序，因此它们并不真正适合内核。它们可以与其他 IRQ 类似地工作，但在该过程之后，它们不再比“常见”IRQ 快。在具有多个处理器的系统上运行的支持 SMP 的内核需要解决另一堆问题。仅仅知道某个 IRQ 是否发生还不够，了解它用于哪些 CPU 也很重要。人们仍然对更多细节感兴趣，现在可能想参考“APIC”。</p>
<p>This function receives the IRQ number, the name of the function, flags, a name for &#x2F;proc&#x2F;interrupts and a parameter to be passed to the interrupt handler. Usually there is a certain number of IRQs available. How many IRQs there are is hardware-dependent. The flags can include <code>SA_SHIRQ</code> to indicate you are willing to share the IRQ with other interrupt handlers (usually because a number of hardware devices sit on the same IRQ) and <code>SA_INTERRUPT</code> to indicate this is a fast interrupt. This function will only succeed if there is not already a handler on this IRQ, or if you are both willing to share.<br>该函数接收 IRQ 号、函数名称、标志、&#x2F;proc&#x2F;interrupts 的名称以及要传递给中断处理程序的参数。通常有一定数量的可用 IRQ。有多少个 IRQ 取决于硬件。这些标志可以包含 <code>SA_SHIRQ</code> 来指示您愿意与其他中断处理程序共享 IRQ（通常是因为许多硬件设备位于同一 IRQ）和 <code>SA_INTERRUPT</code> 来指示这是快速中断。仅当此 IRQ 上尚无处理程序或者双方都愿意共享时，此函数才会成功。</p>
<h4 id="15-2-Detecting-button-presses"><a href="#15-2-Detecting-button-presses" class="headerlink" title="15.2 Detecting button presses"></a>15.2 Detecting button presses</h4><p>15.2 检测按钮按下</p>
<p>Many popular single board computers, such as Raspberry Pi or Beagleboards, have a bunch of GPIO pins. Attaching buttons to those and then having a button press do something is a classic case in which you might need to use interrupts, so that instead of having the CPU waste time and battery power polling for a change in input state, it is better for the input to trigger the CPU to then run a particular handling function.<br>许多流行的单板计算机，例如 Raspberry Pi 或 Beagleboard，都有一堆 GPIO 引脚。将按钮附加到这些按钮上，然后按下按钮执行某些操作是一种典型的情况，在这种情况下，您可能需要使用中断，这样就不必让 CPU 浪费时间和电池电量来轮询输入状态的变化，而是更好地执行操作。输入触发 CPU 然后运行特定的处理函数。</p>
<p>Here is an example where buttons are connected to GPIO numbers 17 and 18 and an LED is connected to GPIO 4. You can change those numbers to whatever is appropriate for your board.<br>下面是一个示例，其中按钮连接到 GPIO 编号 17 和 18，LED 连接到 GPIO 4。您可以将这些编号更改为适合您的主板的编号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * intrpt.c - Handling GPIO with interrupts</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Based upon the RPi example by Stefan Wendler (devnull@kaltpost.de)</span></span><br><span class="line"><span class="comment"> * from:</span></span><br><span class="line"><span class="comment"> *   https://github.com/wendlers/rpi-kmod-samples</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Press one button to turn on a LED and another to turn it off.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">/* for ARRAY_SIZE() */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> button_irqs[] = &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define GPIOs for LEDs.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> Change the numbers for the GPIO on your board.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio</span> <span class="title">leds</span>[] =</span> &#123; &#123; <span class="number">4</span>, GPIOF_OUT_INIT_LOW, <span class="string">&quot;LED 1&quot;</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define GPIOs for BUTTONS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> Change the numbers for the GPIO on your board.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio</span> <span class="title">buttons</span>[] =</span> &#123; &#123; <span class="number">17</span>, GPIOF_IN, <span class="string">&quot;LED 1 ON BUTTON&quot;</span> &#125;,</span><br><span class="line">                                 &#123; <span class="number">18</span>, GPIOF_IN, <span class="string">&quot;LED 1 OFF BUTTON&quot;</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* interrupt function triggered when a button is pressed. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">button_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* first button */</span></span><br><span class="line">    <span class="keyword">if</span> (irq == button_irqs[<span class="number">0</span>] &amp;&amp; !gpio_get_value(leds[<span class="number">0</span>].gpio))</span><br><span class="line">        gpio_set_value(leds[<span class="number">0</span>].gpio, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* second button */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (irq == button_irqs[<span class="number">1</span>] &amp;&amp; gpio_get_value(leds[<span class="number">0</span>].gpio))</span><br><span class="line">        gpio_set_value(leds[<span class="number">0</span>].gpio, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">intrpt_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;%s\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register LED gpios */</span></span><br><span class="line">    ret = gpio_request_array(leds, ARRAY_SIZE(leds));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Unable to request GPIOs for LEDs: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register BUTTON gpios */</span></span><br><span class="line">    ret = gpio_request_array(buttons, ARRAY_SIZE(buttons));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Unable to request GPIOs for BUTTONs: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> fail1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Current button1 value: %d\n&quot;</span>, gpio_get_value(buttons[<span class="number">0</span>].gpio));</span><br><span class="line"></span><br><span class="line">    ret = gpio_to_irq(buttons[<span class="number">0</span>].gpio);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Unable to request IRQ: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> fail2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    button_irqs[<span class="number">0</span>] = ret;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Successfully requested BUTTON1 IRQ # %d\n&quot;</span>, button_irqs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    ret = request_irq(button_irqs[<span class="number">0</span>], button_isr,</span><br><span class="line">                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,</span><br><span class="line">                      <span class="string">&quot;gpiomod#button1&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Unable to request IRQ: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> fail2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = gpio_to_irq(buttons[<span class="number">1</span>].gpio);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Unable to request IRQ: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> fail2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    button_irqs[<span class="number">1</span>] = ret;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Successfully requested BUTTON2 IRQ # %d\n&quot;</span>, button_irqs[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    ret = request_irq(button_irqs[<span class="number">1</span>], button_isr,</span><br><span class="line">                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,</span><br><span class="line">                      <span class="string">&quot;gpiomod#button2&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Unable to request IRQ: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> fail3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* cleanup what has been setup so far */</span></span><br><span class="line">fail3:</span><br><span class="line">    free_irq(button_irqs[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">fail2:</span><br><span class="line">    gpio_free_array(buttons, ARRAY_SIZE(leds));</span><br><span class="line"></span><br><span class="line">fail1:</span><br><span class="line">    gpio_free_array(leds, ARRAY_SIZE(leds));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">intrpt_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;%s\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free irqs */</span></span><br><span class="line">    free_irq(button_irqs[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    free_irq(button_irqs[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* turn all LEDs off */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(leds); i++)</span><br><span class="line">        gpio_set_value(leds[i].gpio, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unregister */</span></span><br><span class="line">    gpio_free_array(leds, ARRAY_SIZE(leds));</span><br><span class="line">    gpio_free_array(buttons, ARRAY_SIZE(buttons));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(intrpt_init);</span><br><span class="line">module_exit(intrpt_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Handle some GPIO interrupts&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="15-3-Bottom-Half-15-3-下半部分"><a href="#15-3-Bottom-Half-15-3-下半部分" class="headerlink" title="15.3 Bottom Half 15.3 下半部分"></a>15.3 Bottom Half 15.3 下半部分</h4><p>Suppose you want to do a bunch of stuff inside of an interrupt routine. A common way to do that without rendering the interrupt unavailable for a significant duration is to combine it with a tasklet. This pushes the bulk of the work off into the scheduler.<br>假设您想在中断例程内执行一系列操作。在不使中断长时间不可用的情况下实现此目的的一种常见方法是将其与微线程结合起来。这将大部分工作推入调度程序。</p>
<p>The example below modifies the previous example to also run an additional task when an interrupt is triggered.<br>下面的示例修改了前面的示例，以便在触发中断时也运行附加任务。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bottomhalf.c - Top and bottom half interrupt handling</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Based upon the RPi example by Stefan Wendler (devnull@kaltpost.de)</span></span><br><span class="line"><span class="comment"> * from:</span></span><br><span class="line"><span class="comment"> *    https://github.com/wendlers/rpi-kmod-samples</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Press one button to turn on an LED and another to turn it off</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macro DECLARE_TASKLET_OLD exists for compatibiity.</span></span><br><span class="line"><span class="comment"> * See https://lwn.net/Articles/830964/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DECLARE_TASKLET_OLD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET_OLD(arg1, arg2) DECLARE_TASKLET(arg1, arg2, 0L)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> button_irqs[] = &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define GPIOs for LEDs.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> Change the numbers for the GPIO on your board.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio</span> <span class="title">leds</span>[] =</span> &#123; &#123; <span class="number">4</span>, GPIOF_OUT_INIT_LOW, <span class="string">&quot;LED 1&quot;</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define GPIOs for BUTTONS</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> Change the numbers for the GPIO on your board.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio</span> <span class="title">buttons</span>[] =</span> &#123;</span><br><span class="line">    &#123; <span class="number">17</span>, GPIOF_IN, <span class="string">&quot;LED 1 ON BUTTON&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="number">18</span>, GPIOF_IN, <span class="string">&quot;LED 1 OFF BUTTON&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tasklet containing some non-trivial amount of processing */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">bottomhalf_tasklet_fn</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Bottom half tasklet starts\n&quot;</span>);</span><br><span class="line">    <span class="comment">/* do something which takes a while */</span></span><br><span class="line">    mdelay(<span class="number">500</span>);</span><br><span class="line">    pr_info(<span class="string">&quot;Bottom half tasklet ends\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_TASKLET_OLD</span><span class="params">(buttontask, bottomhalf_tasklet_fn)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* interrupt function triggered when a button is pressed */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">button_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Do something quickly right now */</span></span><br><span class="line">    <span class="keyword">if</span> (irq == button_irqs[<span class="number">0</span>] &amp;&amp; !gpio_get_value(leds[<span class="number">0</span>].gpio))</span><br><span class="line">        gpio_set_value(leds[<span class="number">0</span>].gpio, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (irq == button_irqs[<span class="number">1</span>] &amp;&amp; gpio_get_value(leds[<span class="number">0</span>].gpio))</span><br><span class="line">        gpio_set_value(leds[<span class="number">0</span>].gpio, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do the rest at leisure via the scheduler */</span></span><br><span class="line">    tasklet_schedule(&amp;buttontask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">bottomhalf_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;%s\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register LED gpios */</span></span><br><span class="line">    ret = gpio_request_array(leds, ARRAY_SIZE(leds));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Unable to request GPIOs for LEDs: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register BUTTON gpios */</span></span><br><span class="line">    ret = gpio_request_array(buttons, ARRAY_SIZE(buttons));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Unable to request GPIOs for BUTTONs: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> fail1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Current button1 value: %d\n&quot;</span>, gpio_get_value(buttons[<span class="number">0</span>].gpio));</span><br><span class="line"></span><br><span class="line">    ret = gpio_to_irq(buttons[<span class="number">0</span>].gpio);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Unable to request IRQ: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> fail2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    button_irqs[<span class="number">0</span>] = ret;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Successfully requested BUTTON1 IRQ # %d\n&quot;</span>, button_irqs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    ret = request_irq(button_irqs[<span class="number">0</span>], button_isr,</span><br><span class="line">                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,</span><br><span class="line">                      <span class="string">&quot;gpiomod#button1&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Unable to request IRQ: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> fail2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = gpio_to_irq(buttons[<span class="number">1</span>].gpio);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Unable to request IRQ: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> fail2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    button_irqs[<span class="number">1</span>] = ret;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Successfully requested BUTTON2 IRQ # %d\n&quot;</span>, button_irqs[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    ret = request_irq(button_irqs[<span class="number">1</span>], button_isr,</span><br><span class="line">                      IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,</span><br><span class="line">                      <span class="string">&quot;gpiomod#button2&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Unable to request IRQ: %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">goto</span> fail3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* cleanup what has been setup so far */</span></span><br><span class="line">fail3:</span><br><span class="line">    free_irq(button_irqs[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">fail2:</span><br><span class="line">    gpio_free_array(buttons, ARRAY_SIZE(leds));</span><br><span class="line"></span><br><span class="line">fail1:</span><br><span class="line">    gpio_free_array(leds, ARRAY_SIZE(leds));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">bottomhalf_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;%s\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free irqs */</span></span><br><span class="line">    free_irq(button_irqs[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    free_irq(button_irqs[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* turn all LEDs off */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(leds); i++)</span><br><span class="line">        gpio_set_value(leds[i].gpio, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unregister */</span></span><br><span class="line">    gpio_free_array(leds, ARRAY_SIZE(leds));</span><br><span class="line">    gpio_free_array(buttons, ARRAY_SIZE(buttons));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(bottomhalf_init);</span><br><span class="line">module_exit(bottomhalf_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Interrupt with top and bottom half&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="16-Crypto-16-加密货币"><a href="#16-Crypto-16-加密货币" class="headerlink" title="16 Crypto 16 加密货币"></a>16 Crypto 16 加密货币</h3><p>At the dawn of the internet, everybody trusted everybody completely…but that did not work out so well. When this guide was originally written, it was a more innocent era in which almost nobody actually gave a damn about crypto - least of all kernel developers. That is certainly no longer the case now. To handle crypto stuff, the kernel has its own API enabling common methods of encryption, decryption and your favourite hash functions.<br>在互联网诞生之初，每个人都完全信任每个人……但效果并不那么好。当本指南最初编写时，那是一个更加天真的时代，几乎没有人真正关心加密——尤其是所有内核开发人员。现在情况肯定不再是这样了。为了处理加密内容，内核有自己的 API，支持常见的加密、解密方法和您最喜欢的哈希函数。</p>
<h4 id="16-1-Hash-functions-16-1-哈希函数"><a href="#16-1-Hash-functions-16-1-哈希函数" class="headerlink" title="16.1 Hash functions 16.1 哈希函数"></a>16.1 Hash functions 16.1 哈希函数</h4><p>Calculating and checking the hashes of things is a common operation. Here is a demonstration of how to calculate a sha256 hash within a kernel module. To provide the sha256 algorithm support, make sure <code>CONFIG_CRYPTO_SHA256</code> is enabled in kernel.<br>计算和检查事物的哈希值是一种常见的操作。以下演示了如何在内核模块内计算 sha256 哈希值。要提供 sha256 算法支持，请确保在内核中启用 <code>CONFIG_CRYPTO_SHA256</code> 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cryptosha256.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crypto/internal/hash.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHA256_LENGTH 32</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_hash_result</span><span class="params">(<span class="type">char</span> *plaintext, <span class="type">char</span> *hash_sha256)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> str[SHA256_LENGTH * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;sha256 test for string: \&quot;%s\&quot;\n&quot;</span>, plaintext);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SHA256_LENGTH; i++)</span><br><span class="line">        <span class="built_in">sprintf</span>(&amp;str[i * <span class="number">2</span>], <span class="string">&quot;%02x&quot;</span>, (<span class="type">unsigned</span> <span class="type">char</span>)hash_sha256[i]);</span><br><span class="line">    str[i * <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    pr_info(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">cryptosha256_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *plaintext = <span class="string">&quot;This is a test&quot;</span>;</span><br><span class="line">    <span class="type">char</span> hash_sha256[SHA256_LENGTH];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">crypto_shash</span> *<span class="title">sha256</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shash_desc</span> *<span class="title">shash</span>;</span></span><br><span class="line"></span><br><span class="line">    sha256 = crypto_alloc_shash(<span class="string">&quot;sha256&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(sha256)) &#123;</span><br><span class="line">        pr_err(</span><br><span class="line">            <span class="string">&quot;%s(): Failed to allocate sha256 algorithm, enable CONFIG_CRYPTO_SHA256 and try again.\n&quot;</span>,</span><br><span class="line">            __func__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shash = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> shash_desc) + crypto_shash_descsize(sha256),</span><br><span class="line">                    GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!shash)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    shash-&gt;tfm = sha256;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (crypto_shash_init(shash))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (crypto_shash_update(shash, plaintext, <span class="built_in">strlen</span>(plaintext)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (crypto_shash_final(shash, hash_sha256))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    kfree(shash);</span><br><span class="line">    crypto_free_shash(sha256);</span><br><span class="line"></span><br><span class="line">    show_hash_result(plaintext, hash_sha256);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">cryptosha256_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(cryptosha256_init);</span><br><span class="line">module_exit(cryptosha256_exit);</span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;sha256 hash test&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Install the module:<br>安装模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo insmod cryptosha256.ko</span><br><span class="line">sudo dmesg</span><br></pre></td></tr></table></figure>

<p>And you should see that the hash was calculated for the test string.<br>您应该看到为测试字符串计算了哈希值。</p>
<p>Finally, remove the test module:<br>最后，删除测试模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rmmod cryptosha256</span><br></pre></td></tr></table></figure>

<h4 id="16-2-Symmetric-key-encryption"><a href="#16-2-Symmetric-key-encryption" class="headerlink" title="16.2 Symmetric key encryption"></a>16.2 Symmetric key encryption</h4><p>16.2 对称密钥加密</p>
<p>Here is an example of symmetrically encrypting a string using the AES algorithm and a password.<br>以下是使用 AES 算法和密码对字符串进行对称加密的示例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cryptosk.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crypto/internal/skcipher.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/crypto.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/random.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/scatterlist.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYMMETRIC_KEY_LENGTH 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIPHER_BLOCK_SIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcrypt_result</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">completion</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skcipher_def</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> <span class="title">sg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">crypto_skcipher</span> *<span class="title">tfm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skcipher_request</span> *<span class="title">req</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcrypt_result</span> <span class="title">result</span>;</span></span><br><span class="line">    <span class="type">char</span> *scratchpad;</span><br><span class="line">    <span class="type">char</span> *ciphertext;</span><br><span class="line">    <span class="type">char</span> *ivdata;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">skcipher_def</span> <span class="title">sk</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">test_skcipher_finish</span><span class="params">(<span class="keyword">struct</span> skcipher_def *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;tfm)</span><br><span class="line">        crypto_free_skcipher(sk-&gt;tfm);</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;req)</span><br><span class="line">        skcipher_request_free(sk-&gt;req);</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;ivdata)</span><br><span class="line">        kfree(sk-&gt;ivdata);</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;scratchpad)</span><br><span class="line">        kfree(sk-&gt;scratchpad);</span><br><span class="line">    <span class="keyword">if</span> (sk-&gt;ciphertext)</span><br><span class="line">        kfree(sk-&gt;ciphertext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_skcipher_result</span><span class="params">(<span class="keyword">struct</span> skcipher_def *sk, <span class="type">int</span> rc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (rc) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -EINPROGRESS || -EBUSY:</span><br><span class="line">        rc = wait_for_completion_interruptible(&amp;sk-&gt;result.completion);</span><br><span class="line">        <span class="keyword">if</span> (!rc &amp;&amp; !sk-&gt;result.err) &#123;</span><br><span class="line">            reinit_completion(&amp;sk-&gt;result.completion);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pr_info(<span class="string">&quot;skcipher encrypt returned with %d result %d\n&quot;</span>, rc,</span><br><span class="line">                sk-&gt;result.err);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        pr_info(<span class="string">&quot;skcipher encrypt returned with %d result %d\n&quot;</span>, rc,</span><br><span class="line">                sk-&gt;result.err);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_completion(&amp;sk-&gt;result.completion);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">test_skcipher_callback</span><span class="params">(<span class="keyword">struct</span> crypto_async_request *req, <span class="type">int</span> error)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcrypt_result</span> *<span class="title">result</span> =</span> req-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error == -EINPROGRESS)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    result-&gt;err = error;</span><br><span class="line">    complete(&amp;result-&gt;completion);</span><br><span class="line">    pr_info(<span class="string">&quot;Encryption finished successfully\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* decrypt data */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span>*)sk.scratchpad, <span class="string">&#x27;-&#x27;</span>, CIPHER_BLOCK_SIZE);</span><br><span class="line">    ret = crypto_skcipher_decrypt(sk.req);</span><br><span class="line">    ret = test_skcipher_result(&amp;sk, ret);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    sg_copy_from_buffer(&amp;sk.sg, <span class="number">1</span>, sk.scratchpad, CIPHER_BLOCK_SIZE);</span><br><span class="line">    sk.scratchpad[CIPHER_BLOCK_SIZE<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Decryption request successful\n&quot;</span>);</span><br><span class="line">    pr_info(<span class="string">&quot;Decrypted: %s\n&quot;</span>, sk.scratchpad);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">test_skcipher_encrypt</span><span class="params">(<span class="type">char</span> *plaintext, <span class="type">char</span> *password,</span></span><br><span class="line"><span class="params">                                 <span class="keyword">struct</span> skcipher_def *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = -EFAULT;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> key[SYMMETRIC_KEY_LENGTH];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sk-&gt;tfm) &#123;</span><br><span class="line">        sk-&gt;tfm = crypto_alloc_skcipher(<span class="string">&quot;cbc-aes-aesni&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(sk-&gt;tfm)) &#123;</span><br><span class="line">            pr_info(<span class="string">&quot;could not allocate skcipher handle\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> PTR_ERR(sk-&gt;tfm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sk-&gt;req) &#123;</span><br><span class="line">        sk-&gt;req = skcipher_request_alloc(sk-&gt;tfm, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!sk-&gt;req) &#123;</span><br><span class="line">            pr_info(<span class="string">&quot;could not allocate skcipher request\n&quot;</span>);</span><br><span class="line">            ret = -ENOMEM;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    skcipher_request_set_callback(sk-&gt;req, CRYPTO_TFM_REQ_MAY_BACKLOG,</span><br><span class="line">                                  test_skcipher_callback, &amp;sk-&gt;result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clear the key */</span></span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span> *)key, <span class="string">&#x27;\0&#x27;</span>, SYMMETRIC_KEY_LENGTH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use the world&#x27;s favourite password */</span></span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span> *)key, <span class="string">&quot;%s&quot;</span>, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* AES 256 with given symmetric key */</span></span><br><span class="line">    <span class="keyword">if</span> (crypto_skcipher_setkey(sk-&gt;tfm, key, SYMMETRIC_KEY_LENGTH)) &#123;</span><br><span class="line">        pr_info(<span class="string">&quot;key could not be set\n&quot;</span>);</span><br><span class="line">        ret = -EAGAIN;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    pr_info(<span class="string">&quot;Symmetric key: %s\n&quot;</span>, key);</span><br><span class="line">    pr_info(<span class="string">&quot;Plaintext: %s\n&quot;</span>, plaintext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sk-&gt;ivdata) &#123;</span><br><span class="line">        <span class="comment">/* see https://en.wikipedia.org/wiki/Initialization_vector */</span></span><br><span class="line">        sk-&gt;ivdata = kmalloc(CIPHER_BLOCK_SIZE, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!sk-&gt;ivdata) &#123;</span><br><span class="line">            pr_info(<span class="string">&quot;could not allocate ivdata\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        get_random_bytes(sk-&gt;ivdata, CIPHER_BLOCK_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sk-&gt;scratchpad) &#123;</span><br><span class="line">        <span class="comment">/* The text to be encrypted */</span></span><br><span class="line">        sk-&gt;scratchpad = kmalloc(CIPHER_BLOCK_SIZE, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!sk-&gt;scratchpad) &#123;</span><br><span class="line">            pr_info(<span class="string">&quot;could not allocate scratchpad\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="type">char</span> *)sk-&gt;scratchpad, <span class="string">&quot;%s&quot;</span>, plaintext);</span><br><span class="line"></span><br><span class="line">    sg_init_one(&amp;sk-&gt;sg, sk-&gt;scratchpad, CIPHER_BLOCK_SIZE);</span><br><span class="line">    skcipher_request_set_crypt(sk-&gt;req, &amp;sk-&gt;sg, &amp;sk-&gt;sg, CIPHER_BLOCK_SIZE,</span><br><span class="line">                               sk-&gt;ivdata);</span><br><span class="line">    init_completion(&amp;sk-&gt;result.completion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* encrypt data */</span></span><br><span class="line">    ret = crypto_skcipher_encrypt(sk-&gt;req);</span><br><span class="line">    ret = test_skcipher_result(sk, ret);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Encryption request successful\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">cryptoapi_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* The world&#x27;s favorite password */</span></span><br><span class="line">    <span class="type">char</span> *password = <span class="string">&quot;password123&quot;</span>;</span><br><span class="line"></span><br><span class="line">    sk.tfm = <span class="literal">NULL</span>;</span><br><span class="line">    sk.req = <span class="literal">NULL</span>;</span><br><span class="line">    sk.scratchpad = <span class="literal">NULL</span>;</span><br><span class="line">    sk.ciphertext = <span class="literal">NULL</span>;</span><br><span class="line">    sk.ivdata = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    test_skcipher_encrypt(<span class="string">&quot;Testing&quot;</span>, password, &amp;sk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">cryptoapi_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    test_skcipher_finish(&amp;sk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(cryptoapi_init);</span><br><span class="line">module_exit(cryptoapi_exit);</span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Symmetric key encryption example&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="17-Virtual-Input-Device-Driver"><a href="#17-Virtual-Input-Device-Driver" class="headerlink" title="17 Virtual Input Device Driver"></a>17 Virtual Input Device Driver</h3><p>17 虚拟输入设备驱动</p>
<p>The input device driver is a module that provides a way to communicate with the interaction device via the event. For example, the keyboard can send the press or release event to tell the kernel what we want to do. The input device driver will allocate a new input structure with <code>input_allocate_device()</code> and sets up input bitfields, device id, version, etc. After that, registers it by calling <code>input_register_device()</code> .<br>输入设备驱动程序是提供通过事件与交互设备进行通信的方式的模块。例如，键盘可以发送按下或释放事件来告诉内核我们想要做什么。输入设备驱动程序将使用 <code>input_allocate_device()</code> 分配一个新的输入结构，并设置输入位字段、设备 ID、版本等。之后，通过调用 <code>input_register_device()</code> 注册它。</p>
<p>Here is an example, vinput, It is an API to allow easy development of virtual input drivers. The drivers needs to export a <code>vinput_device()</code> that contains the virtual device name and <code>vinput_ops</code> structure that describes:<br>这是一个例子，vinput，它是一个 API，可以轻松开发虚拟输入驱动程序。驱动程序需要导出包含虚拟设备名称的 <code>vinput_device()</code> 和描述以下内容的 <code>vinput_ops</code> 结构：</p>
<ul>
<li>the init function: <code>init()</code><br>初始化函数： <code>init()</code></li>
<li>the input event injection function: <code>send()</code><br>输入事件注入函数： <code>send()</code></li>
<li>the readback function: <code>read()</code><br>回读功能： <code>read()</code></li>
</ul>
<p>Then using <code>vinput_register_device()</code> and <code>vinput_unregister_device()</code> will add a new device to the list of support virtual input devices.<br>然后使用 <code>vinput_register_device()</code> 和 <code>vinput_unregister_device()</code> 将新设备添加到支持虚拟输入设备列表中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">init</span><span class="params">(<span class="keyword">struct</span> vinput *)</span>;</span><br></pre></td></tr></table></figure>

<p>This function is passed a <code>struct vinput</code> already initialized with an allocated <code>struct input_dev</code> . The <code>init()</code> function is responsible for initializing the capabilities of the input device and register it.<br>该函数传递一个已经用分配的 <code>struct input_dev</code> 初始化的 <code>struct vinput</code> 。 <code>init()</code> 函数负责初始化输入设备的能力并注册。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">send</span><span class="params">(<span class="keyword">struct</span> vinput *, <span class="type">char</span> *, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>This function will receive a user string to interpret and inject the event using the <code>input_report_XXXX</code> or <code>input_event</code> call. The string is already copied from user.<br>此函数将接收用户字符串，以使用 <code>input_report_XXXX</code> 或 <code>input_event</code> 调用解释和注入事件。该字符串已从用户复制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="keyword">struct</span> vinput *, <span class="type">char</span> *, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>This function is used for debugging and should fill the buffer parameter with the last event sent in the virtual input device format. The buffer will then be copied to user.<br>此函数用于调试，应使用以虚拟输入设备格式发送的最后一个事件填充缓冲区参数。然后缓冲区将被复制给用户。</p>
<p>vinput devices are created and destroyed using sysfs. And, event injection is done through a &#x2F;dev node. The device name will be used by the userland to export a new virtual input device.<br>vinput 设备是使用 sysfs 创建和销毁的。并且，事件注入是通过 &#x2F;dev 节点完成的。用户空间将使用设备名称来导出新的虚拟输入设备。</p>
<p>The <code>class_attribute</code> structure is similar to other attribute types we talked about in section <a href="https://sysprog21.github.io/lkmpg/#sysfs-interacting-with-your-module">8</a>:<br><code>class_attribute</code> 结构与我们在第 8 节中讨论的其他属性类型类似：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> class *class, <span class="keyword">struct</span> class_attribute *attr,</span><br><span class="line">                    <span class="type">char</span> *buf);</span><br><span class="line">    <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> class *class, <span class="keyword">struct</span> class_attribute *attr,</span><br><span class="line">                    <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>In vinput.c, the macro <code>CLASS_ATTR_WO(export/unexport)</code> defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/device.h">include&#x2F;linux&#x2F;device.h</a> (in this case, device.h is included in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/input.h">include&#x2F;linux&#x2F;input.h</a>) will generate the <code>class_attribute</code> structures which are named class_attr_export&#x2F;unexport. Then, put them into <code>vinput_class_attrs</code> array and the macro <code>ATTRIBUTE_GROUPS(vinput_class)</code> will generate the <code>struct attribute_group vinput_class_group</code> that should be assigned in <code>vinput_class</code> . Finally, call <code>class_register(&amp;vinput_class)</code> to create attributes in sysfs.<br>在 vinput.c 中，include&#x2F;linux&#x2F;device.h 中定义的宏 <code>CLASS_ATTR_WO(export/unexport)</code> （在本例中，device.h 包含在 include&#x2F;linux&#x2F;input.h 中）将生成 <code>class_attribute</code> 数组中，宏 <code>ATTRIBUTE_GROUPS(vinput_class)</code> 将生成应在 <code>vinput_class</code> 中分配的 <code>struct attribute_group vinput_class_group</code> 。最后调用 <code>class_register(&amp;vinput_class)</code> 在 sysfs 中创建属性。</p>
<p>To create a vinputX sysfs entry and &#x2F;dev node.<br>创建 vinputX sysfs 条目和 &#x2F;dev 节点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;vkbd&quot;</span> | sudo <span class="built_in">tee</span> /sys/class/vinput/export</span><br></pre></td></tr></table></figure>

<p>To unexport the device, just echo its id in unexport:<br>要取消导出设备，只需在 unexport 中回显其 ID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0&quot;</span> | sudo <span class="built_in">tee</span> /sys/class/vinput/unexport</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vinput.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VINPUT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VINPUT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VINPUT_MAX_LEN 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VINPUT 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VINPUT_MINORS MAX_VINPUT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dev_to_vinput(dev) container_of(dev, struct vinput, dev)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vinput_device</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vinput</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> id;</span><br><span class="line">    <span class="type">long</span> devno;</span><br><span class="line">    <span class="type">long</span> last_entry;</span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *priv_data;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vinput_device</span> *<span class="title">type</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vinput_ops</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*init)(<span class="keyword">struct</span> vinput *);</span><br><span class="line">    <span class="type">int</span> (*kill)(<span class="keyword">struct</span> vinput *);</span><br><span class="line">    <span class="type">int</span> (*send)(<span class="keyword">struct</span> vinput *, <span class="type">char</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*read)(<span class="keyword">struct</span> vinput *, <span class="type">char</span> *, <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vinput_device</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vinput_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vinput_register</span><span class="params">(<span class="keyword">struct</span> vinput_device *dev)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vinput_unregister</span><span class="params">(<span class="keyword">struct</span> vinput_device *dev)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vinput.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vinput.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVER_NAME <span class="string">&quot;vinput&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dev_to_vinput(dev) container_of(dev, struct vinput, dev)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_BITMAP</span><span class="params">(vinput_ids, VINPUT_MINORS)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(vinput_devices)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(vinput_vdevices)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> vinput_dev;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">vinput_lock</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> <span class="title">vinput_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search the name of vinput device in the vinput_devices linked list,</span></span><br><span class="line"><span class="comment"> * which added at vinput_register().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vinput_device *<span class="title function_">vinput_get_device_by_type</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vinput_device</span> *<span class="title">vinput</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">curr</span>;</span></span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;vinput_lock);</span><br><span class="line">    list_for_each (curr, &amp;vinput_devices) &#123;</span><br><span class="line">        vinput = list_entry(curr, <span class="keyword">struct</span> vinput_device, <span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">if</span> (vinput &amp;&amp; <span class="built_in">strncmp</span>(type, vinput-&gt;name, <span class="built_in">strlen</span>(vinput-&gt;name)) == <span class="number">0</span>) &#123;</span><br><span class="line">            found = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;vinput_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (found)</span><br><span class="line">        <span class="keyword">return</span> vinput;</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search the id of virtual device in the vinput_vdevices linked list,</span></span><br><span class="line"><span class="comment"> * which added at vinput_alloc_vdevice().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vinput *<span class="title function_">vinput_get_vdevice_by_id</span><span class="params">(<span class="type">long</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vinput</span> *<span class="title">vinput</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">curr</span>;</span></span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;vinput_lock);</span><br><span class="line">    list_for_each (curr, &amp;vinput_vdevices) &#123;</span><br><span class="line">        vinput = list_entry(curr, <span class="keyword">struct</span> vinput, <span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">if</span> (vinput &amp;&amp; vinput-&gt;id == id)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;vinput_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vinput &amp;&amp; vinput-&gt;id == id)</span><br><span class="line">        <span class="keyword">return</span> vinput;</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(-ENODEV);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vinput_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vinput</span> *<span class="title">vinput</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    vinput = vinput_get_vdevice_by_id(iminor(inode));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(vinput))</span><br><span class="line">        err = PTR_ERR(vinput);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        file-&gt;private_data = vinput;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vinput_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">vinput_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buffer, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">                           <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> buff[VINPUT_MAX_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vinput</span> *<span class="title">vinput</span> =</span> file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    len = vinput-&gt;type-&gt;ops-&gt;read(vinput, buff, count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*offset &gt; len)</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (count + *offset &gt; VINPUT_MAX_LEN)</span><br><span class="line">        count = len - *offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (raw_copy_to_user(buffer, buff + *offset, count))</span><br><span class="line">        count = -EFAULT;</span><br><span class="line"></span><br><span class="line">    *offset += count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">vinput_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buffer,</span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span> count, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buff[VINPUT_MAX_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vinput</span> *<span class="title">vinput</span> =</span> file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buff, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>) * (VINPUT_MAX_LEN + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count &gt; VINPUT_MAX_LEN) &#123;</span><br><span class="line">        dev_warn(&amp;vinput-&gt;dev, <span class="string">&quot;Too long. %d bytes allowed\n&quot;</span>, VINPUT_MAX_LEN);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (raw_copy_from_user(buff, buffer, count))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vinput-&gt;type-&gt;ops-&gt;send(vinput, buff, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">vinput_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = vinput_open,</span><br><span class="line">    .release = vinput_release,</span><br><span class="line">    .read = vinput_read,</span><br><span class="line">    .write = vinput_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vinput_unregister_vdevice</span><span class="params">(<span class="keyword">struct</span> vinput *vinput)</span></span><br><span class="line">&#123;</span><br><span class="line">    input_unregister_device(vinput-&gt;input);</span><br><span class="line">    <span class="keyword">if</span> (vinput-&gt;type-&gt;ops-&gt;kill)</span><br><span class="line">        vinput-&gt;type-&gt;ops-&gt;kill(vinput);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vinput_destroy_vdevice</span><span class="params">(<span class="keyword">struct</span> vinput *vinput)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Remove from the list first */</span></span><br><span class="line">    spin_lock(&amp;vinput_lock);</span><br><span class="line">    list_del(&amp;vinput-&gt;<span class="built_in">list</span>);</span><br><span class="line">    clear_bit(vinput-&gt;id, vinput_ids);</span><br><span class="line">    spin_unlock(&amp;vinput_lock);</span><br><span class="line"></span><br><span class="line">    module_put(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">    kfree(vinput);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vinput_release_dev</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vinput</span> *<span class="title">vinput</span> =</span> dev_to_vinput(dev);</span><br><span class="line">    <span class="type">int</span> id = vinput-&gt;id;</span><br><span class="line"></span><br><span class="line">    vinput_destroy_vdevice(vinput);</span><br><span class="line"></span><br><span class="line">    pr_debug(<span class="string">&quot;released vinput%d.\n&quot;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vinput *<span class="title function_">vinput_alloc_vdevice</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vinput</span> *<span class="title">vinput</span> =</span> kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> vinput), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    try_module_get(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(vinput, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> vinput));</span><br><span class="line"></span><br><span class="line">    spin_lock_init(&amp;vinput-&gt;lock);</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;vinput_lock);</span><br><span class="line">    vinput-&gt;id = find_first_zero_bit(vinput_ids, VINPUT_MINORS);</span><br><span class="line">    <span class="keyword">if</span> (vinput-&gt;id &gt;= VINPUT_MINORS) &#123;</span><br><span class="line">        err = -ENOBUFS;</span><br><span class="line">        <span class="keyword">goto</span> fail_id;</span><br><span class="line">    &#125;</span><br><span class="line">    set_bit(vinput-&gt;id, vinput_ids);</span><br><span class="line">    list_add(&amp;vinput-&gt;<span class="built_in">list</span>, &amp;vinput_vdevices);</span><br><span class="line">    spin_unlock(&amp;vinput_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate the input device */</span></span><br><span class="line">    vinput-&gt;input = input_allocate_device();</span><br><span class="line">    <span class="keyword">if</span> (vinput-&gt;input == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;vinput: Cannot allocate vinput input device\n&quot;</span>);</span><br><span class="line">        err = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> fail_input_dev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize device */</span></span><br><span class="line">    vinput-&gt;dev.class = &amp;vinput_class;</span><br><span class="line">    vinput-&gt;dev.release = vinput_release_dev;</span><br><span class="line">    vinput-&gt;dev.devt = MKDEV(vinput_dev, vinput-&gt;id);</span><br><span class="line">    dev_set_name(&amp;vinput-&gt;dev, DRIVER_NAME <span class="string">&quot;%lu&quot;</span>, vinput-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vinput;</span><br><span class="line"></span><br><span class="line">fail_input_dev:</span><br><span class="line">    spin_lock(&amp;vinput_lock);</span><br><span class="line">    list_del(&amp;vinput-&gt;<span class="built_in">list</span>);</span><br><span class="line">fail_id:</span><br><span class="line">    spin_unlock(&amp;vinput_lock);</span><br><span class="line">    module_put(THIS_MODULE);</span><br><span class="line">    kfree(vinput);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vinput_register_vdevice</span><span class="params">(<span class="keyword">struct</span> vinput *vinput)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* register the input device */</span></span><br><span class="line">    vinput-&gt;input-&gt;name = vinput-&gt;type-&gt;name;</span><br><span class="line">    vinput-&gt;input-&gt;phys = <span class="string">&quot;vinput&quot;</span>;</span><br><span class="line">    vinput-&gt;input-&gt;dev.parent = &amp;vinput-&gt;dev;</span><br><span class="line"></span><br><span class="line">    vinput-&gt;input-&gt;id.bustype = BUS_VIRTUAL;</span><br><span class="line">    vinput-&gt;input-&gt;id.product = <span class="number">0x0000</span>;</span><br><span class="line">    vinput-&gt;input-&gt;id.vendor = <span class="number">0x0000</span>;</span><br><span class="line">    vinput-&gt;input-&gt;id.version = <span class="number">0x0000</span>;</span><br><span class="line"></span><br><span class="line">    err = vinput-&gt;type-&gt;ops-&gt;init(vinput);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>)</span><br><span class="line">        dev_info(&amp;vinput-&gt;dev, <span class="string">&quot;Registered virtual input %s %ld\n&quot;</span>,</span><br><span class="line">                 vinput-&gt;type-&gt;name, vinput-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">export_store</span><span class="params">(<span class="keyword">struct</span> class *class, <span class="keyword">struct</span> class_attribute *attr,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vinput</span> *<span class="title">vinput</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vinput_device</span> *<span class="title">device</span>;</span></span><br><span class="line"></span><br><span class="line">    device = vinput_get_device_by_type(buf);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(device)) &#123;</span><br><span class="line">        pr_info(<span class="string">&quot;vinput: This virtual device isn&#x27;t registered\n&quot;</span>);</span><br><span class="line">        err = PTR_ERR(device);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vinput = vinput_alloc_vdevice();</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(vinput)) &#123;</span><br><span class="line">        err = PTR_ERR(vinput);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vinput-&gt;type = device;</span><br><span class="line">    err = device_register(&amp;vinput-&gt;dev);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail_register;</span><br><span class="line"></span><br><span class="line">    err = vinput_register_vdevice(vinput);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fail_register_vinput;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">fail_register_vinput:</span><br><span class="line">    device_unregister(&amp;vinput-&gt;dev);</span><br><span class="line">fail_register:</span><br><span class="line">    vinput_destroy_vdevice(vinput);</span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* This macro generates class_attr_export structure and export_store() */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">CLASS_ATTR_WO</span><span class="params">(export)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">unexport_store</span><span class="params">(<span class="keyword">struct</span> class *class, <span class="keyword">struct</span> class_attribute *attr,</span></span><br><span class="line"><span class="params">                              <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vinput</span> *<span class="title">vinput</span>;</span></span><br><span class="line"></span><br><span class="line">    err = kstrtol(buf, <span class="number">10</span>, &amp;id);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vinput = vinput_get_vdevice_by_id(id);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(vinput)) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;vinput: No such vinput device %ld\n&quot;</span>, id);</span><br><span class="line">        err = PTR_ERR(vinput);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vinput_unregister_vdevice(vinput);</span><br><span class="line">    device_unregister(&amp;vinput-&gt;dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* This macro generates class_attr_unexport structure and unexport_store() */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">CLASS_ATTR_WO</span><span class="params">(unexport)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> *<span class="title">vinput_class_attrs</span>[] =</span> &#123;</span><br><span class="line">    &amp;class_attr_export.attr,</span><br><span class="line">    &amp;class_attr_unexport.attr,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This macro generates vinput_class_groups structure */</span></span><br><span class="line">ATTRIBUTE_GROUPS(vinput_class);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> <span class="title">vinput_class</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;vinput&quot;</span>,</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .class_groups = vinput_class_groups,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vinput_register</span><span class="params">(<span class="keyword">struct</span> vinput_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock(&amp;vinput_lock);</span><br><span class="line">    list_add(&amp;dev-&gt;<span class="built_in">list</span>, &amp;vinput_devices);</span><br><span class="line">    spin_unlock(&amp;vinput_lock);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;vinput: registered new virtual input device &#x27;%s&#x27;\n&quot;</span>, dev-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vinput_register);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vinput_unregister</span><span class="params">(<span class="keyword">struct</span> vinput_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">curr</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove from the list first */</span></span><br><span class="line">    spin_lock(&amp;vinput_lock);</span><br><span class="line">    list_del(&amp;dev-&gt;<span class="built_in">list</span>);</span><br><span class="line">    spin_unlock(&amp;vinput_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unregister all devices of this type */</span></span><br><span class="line">    list_for_each_safe (curr, next, &amp;vinput_vdevices) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vinput</span> *<span class="title">vinput</span> =</span> list_entry(curr, <span class="keyword">struct</span> vinput, <span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">if</span> (vinput &amp;&amp; vinput-&gt;type == dev) &#123;</span><br><span class="line">            vinput_unregister_vdevice(vinput);</span><br><span class="line">            device_unregister(&amp;vinput-&gt;dev);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;vinput: unregistered virtual input device &#x27;%s&#x27;\n&quot;</span>, dev-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vinput_unregister);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">vinput_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;vinput: Loading virtual input driver\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    vinput_dev = register_chrdev(<span class="number">0</span>, DRIVER_NAME, &amp;vinput_fops);</span><br><span class="line">    <span class="keyword">if</span> (vinput_dev &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;vinput: Unable to allocate char dev region\n&quot;</span>);</span><br><span class="line">        err = vinput_dev;</span><br><span class="line">        <span class="keyword">goto</span> failed_alloc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_lock_init(&amp;vinput_lock);</span><br><span class="line"></span><br><span class="line">    err = class_register(&amp;vinput_class);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;vinput: Unable to register vinput class\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed_class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">failed_class:</span><br><span class="line">    class_unregister(&amp;vinput_class);</span><br><span class="line">failed_alloc:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">vinput_end</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;vinput: Unloading virtual input driver\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    unregister_chrdev(vinput_dev, DRIVER_NAME);</span><br><span class="line">    class_unregister(&amp;vinput_class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(vinput_init);</span><br><span class="line">module_exit(vinput_end);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Emulate input events&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Here the virtual keyboard is one of example to use vinput. It supports all <code>KEY_MAX</code> keycodes. The injection format is the <code>KEY_CODE</code> such as defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/input.h">include&#x2F;linux&#x2F;input.h</a>. A positive value means <code>KEY_PRESS</code> while a negative value is a <code>KEY_RELEASE</code> . The keyboard supports repetition when the key stays pressed for too long. The following demonstrates how simulation work.<br>这里虚拟键盘是使用 vinput 的示例之一。它支持所有 <code>KEY_MAX</code> 键码。注入格式是 <code>KEY_CODE</code> ，例如在 include&#x2F;linux&#x2F;input.h 中定义的。正值表示 <code>KEY_PRESS</code> ，负值表示 <code>KEY_RELEASE</code> 。当按键按下时间过长时，键盘支持重复。下面演示了模拟是如何工作的。</p>
<p>Simulate a key press on “g” ( <code>KEY_G</code> &#x3D; 34):<br>模拟按下“g”键（ <code>KEY_G</code> &#x3D; 34）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;+34&quot;</span> | sudo <span class="built_in">tee</span> /dev/vinput0</span><br></pre></td></tr></table></figure>

<p>Simulate a key release on “g” ( <code>KEY_G</code> &#x3D; 34):<br>模拟“g”上的按键释放 ( <code>KEY_G</code> &#x3D; 34)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;-34&quot;</span> | sudo <span class="built_in">tee</span> /dev/vinput0</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vkbd.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vinput.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VINPUT_KBD <span class="string">&quot;vkbd&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VINPUT_RELEASE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VINPUT_PRESS 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">short</span> vkeymap[KEY_MAX];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vinput_vkbd_init</span><span class="params">(<span class="keyword">struct</span> vinput *vinput)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up the input bitfield */</span></span><br><span class="line">    vinput-&gt;input-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">    vinput-&gt;input-&gt;keycodesize = <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span>);</span><br><span class="line">    vinput-&gt;input-&gt;keycodemax = KEY_MAX;</span><br><span class="line">    vinput-&gt;input-&gt;keycode = vkeymap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_MAX; i++)</span><br><span class="line">        set_bit(vkeymap[i], vinput-&gt;input-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* vinput will help us allocate new input device structure via</span></span><br><span class="line"><span class="comment">     * input_allocate_device(). So, we can register it straightforwardly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> input_register_device(vinput-&gt;input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vinput_vkbd_read</span><span class="params">(<span class="keyword">struct</span> vinput *vinput, <span class="type">char</span> *buff, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock(&amp;vinput-&gt;lock);</span><br><span class="line">    len = <span class="built_in">snprintf</span>(buff, len, <span class="string">&quot;%+ld\n&quot;</span>, vinput-&gt;last_entry);</span><br><span class="line">    spin_unlock(&amp;vinput-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vinput_vkbd_send</span><span class="params">(<span class="keyword">struct</span> vinput *vinput, <span class="type">char</span> *buff, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">long</span> key = <span class="number">0</span>;</span><br><span class="line">    <span class="type">short</span> type = VINPUT_PRESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Determine which event was received (press or release)</span></span><br><span class="line"><span class="comment">     * and store the state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (buff[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        ret = kstrtol(buff + <span class="number">1</span>, <span class="number">10</span>, &amp;key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = kstrtol(buff, <span class="number">10</span>, &amp;key);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        dev_err(&amp;vinput-&gt;dev, <span class="string">&quot;error during kstrtol: -%d\n&quot;</span>, ret);</span><br><span class="line">    spin_lock(&amp;vinput-&gt;lock);</span><br><span class="line">    vinput-&gt;last_entry = key;</span><br><span class="line">    spin_unlock(&amp;vinput-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        type = VINPUT_RELEASE;</span><br><span class="line">        key = -key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dev_info(&amp;vinput-&gt;dev, <span class="string">&quot;Event %s code %ld\n&quot;</span>,</span><br><span class="line">             (type == VINPUT_RELEASE) ? <span class="string">&quot;VINPUT_RELEASE&quot;</span> : <span class="string">&quot;VINPUT_PRESS&quot;</span>, key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Report the state received to input subsystem. */</span></span><br><span class="line">    input_report_key(vinput-&gt;input, key, type);</span><br><span class="line">    <span class="comment">/* Tell input subsystem that it finished the report. */</span></span><br><span class="line">    input_sync(vinput-&gt;input);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vinput_ops</span> <span class="title">vkbd_ops</span> =</span> &#123;</span><br><span class="line">    .init = vinput_vkbd_init,</span><br><span class="line">    .send = vinput_vkbd_send,</span><br><span class="line">    .read = vinput_vkbd_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vinput_device</span> <span class="title">vkbd_dev</span> =</span> &#123;</span><br><span class="line">    .name = VINPUT_KBD,</span><br><span class="line">    .ops = &amp;vkbd_ops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">vkbd_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_MAX; i++)</span><br><span class="line">        vkeymap[i] = i;</span><br><span class="line">    <span class="keyword">return</span> vinput_register(&amp;vkbd_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">vkbd_end</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    vinput_unregister(&amp;vkbd_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(vkbd_init);</span><br><span class="line">module_exit(vkbd_end);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Emulate keyboard input events through /dev/vinput&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="18-Standardizing-the-interfaces-The-Device-Model"><a href="#18-Standardizing-the-interfaces-The-Device-Model" class="headerlink" title="18 Standardizing the interfaces: The Device Model"></a>18 Standardizing the interfaces: The Device Model</h3><p>18 标准化接口：设备模型</p>
<p>Up to this point we have seen all kinds of modules doing all kinds of things, but there was no consistency in their interfaces with the rest of the kernel. To impose some consistency such that there is at minimum a standardized way to start, suspend and resume a device model was added. An example is shown below, and you can use this as a template to add your own suspend, resume or other interface functions.<br>到目前为止，我们已经看到各种各样的模块在做各种各样的事情，但是它们的接口与内核的其余部分没有一致性。为了强加一定的一致性，至少添加了一种启动、暂停和恢复设备模型的标准化方法。下面是一个示例，您可以以此为模板添加自己的挂起、恢复或其他接口函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * devicemodel.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">devicemodel_data</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *greeting;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">devicemodel_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">devicemodel_data</span> *<span class="title">pd</span> =</span></span><br><span class="line">        (<span class="keyword">struct</span> devicemodel_data *)(dev-&gt;dev.platform_data);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;devicemodel probe\n&quot;</span>);</span><br><span class="line">    pr_info(<span class="string">&quot;devicemodel greeting: %s; %d\n&quot;</span>, pd-&gt;greeting, pd-&gt;number);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Your device initialization code */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">devicemodel_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;devicemodel example removed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Your device removal code */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">devicemodel_suspend</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;devicemodel example suspend\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Your device suspend code */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">devicemodel_resume</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;devicemodel example resume\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Your device resume code */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> <span class="title">devicemodel_pm_ops</span> =</span> &#123;</span><br><span class="line">    .suspend = devicemodel_suspend,</span><br><span class="line">    .resume = devicemodel_resume,</span><br><span class="line">    .poweroff = devicemodel_suspend,</span><br><span class="line">    .freeze = devicemodel_suspend,</span><br><span class="line">    .thaw = devicemodel_resume,</span><br><span class="line">    .restore = devicemodel_resume,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">devicemodel_driver</span> =</span> &#123;</span><br><span class="line">    .driver =</span><br><span class="line">        &#123;</span><br><span class="line">            .name = <span class="string">&quot;devicemodel_example&quot;</span>,</span><br><span class="line">            .pm = &amp;devicemodel_pm_ops,</span><br><span class="line">        &#125;,</span><br><span class="line">    .probe = devicemodel_probe,</span><br><span class="line">    .remove = devicemodel_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">devicemodel_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;devicemodel init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ret = platform_driver_register(&amp;devicemodel_driver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Unable to register driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">devicemodel_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;devicemodel exit\n&quot;</span>);</span><br><span class="line">    platform_driver_unregister(&amp;devicemodel_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(devicemodel_init);</span><br><span class="line">module_exit(devicemodel_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Linux Device Model example&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="19-Optimizations-19-优化"><a href="#19-Optimizations-19-优化" class="headerlink" title="19 Optimizations 19 优化"></a>19 Optimizations 19 优化</h3><h4 id="19-1-Likely-and-Unlikely-conditions"><a href="#19-1-Likely-and-Unlikely-conditions" class="headerlink" title="19.1 Likely and Unlikely conditions"></a>19.1 Likely and Unlikely conditions</h4><p>19.1 可能和不可能的情况</p>
<p>Sometimes you might want your code to run as quickly as possible, especially if it is handling an interrupt or doing something which might cause noticeable latency. If your code contains boolean conditions and if you know that the conditions are almost always likely to evaluate as either <code>true</code> or <code>false</code> , then you can allow the compiler to optimize for this using the <code>likely</code> and <code>unlikely</code> macros. For example, when allocating memory you are almost always expecting this to succeed.<br>有时您可能希望代码尽可能快地运行，特别是当它正在处理中断或执行可能导致明显延迟的操作时。如果您的代码包含布尔条件，并且您知道这些条件几乎总是可能计算为 <code>true</code> 或 <code>false</code> ，那么您可以允许编译器使用 &lt; b2&gt; 和 <code>unlikely</code> 宏。例如，当分配内存时，您几乎总是期望它会成功。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bvl = bvec_alloc(gfp_mask, nr_iovecs, &amp;idx);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!bvl)) &#123;</span><br><span class="line">    mempool_free(bio, bio_pool);</span><br><span class="line">    bio = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When the <code>unlikely</code> macro is used, the compiler alters its machine instruction output, so that it continues along the false branch and only jumps if the condition is true. That avoids flushing the processor pipeline. The opposite happens if you use the <code>likely</code> macro.<br>当使用 <code>unlikely</code> 宏时，编译器会更改其机器指令输出，以便它沿着 false 分支继续，并且仅在条件为 true 时才跳转。这可以避免刷新处理器管道。如果您使用 <code>likely</code> 宏，则会发生相反的情况。</p>
<h4 id="19-2-Static-keys-19-2-静态键"><a href="#19-2-Static-keys-19-2-静态键" class="headerlink" title="19.2 Static keys 19.2 静态键"></a>19.2 Static keys 19.2 静态键</h4><p>Static keys allow us to enable or disable kernel code paths based on the runtime state of key. Its APIs have been available since 2010 (most architectures are already supported), use self-modifying code to eliminate the overhead of cache and branch prediction. The most typical use case of static keys is for performance-sensitive kernel code, such as tracepoints, context switching, networking, etc. These hot paths of the kernel often contain branches and can be optimized easily using this technique. Before we can use static keys in the kernel, we need to make sure that gcc supports <code>asm goto</code> inline assembly, and the following kernel configurations are set:<br>静态键允许我们根据键的运行时状态启用或禁用内核代码路径。它的 API 自 2010 年以来就已经可用（大多数架构已经支持），使用自修改代码来消除缓存和分支预测的开销。静态键最典型的用例是性能敏感的内核代码，例如跟踪点、上下文切换、网络等。内核的这些热路径通常包含分支，并且可以使用此技术轻松优化。在内核中使用静态键之前，我们需要确保 gcc 支持 <code>asm goto</code> 内联汇编，并设置以下内核配置：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CONFIG_JUMP_LABEL=y</span><br><span class="line">CONFIG_HAVE_ARCH_JUMP_LABEL=y</span><br><span class="line">CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE=y</span><br></pre></td></tr></table></figure>

<p>To declare a static key, we need to define a global variable using the <code>DEFINE_STATIC_KEY_FALSE</code> or <code>DEFINE_STATIC_KEY_TRUE</code> macro defined in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/linux/jump_label.h">include&#x2F;linux&#x2F;jump_label.h</a>. This macro initializes the key with the given initial value, which is either false or true, respectively. For example, to declare a static key with an initial value of false, we can use the following code:<br>要声明静态键，我们需要使用 include&#x2F;linux&#x2F;jump_label.h 中定义的 <code>DEFINE_STATIC_KEY_FALSE</code> 或 <code>DEFINE_STATIC_KEY_TRUE</code> 宏定义一个全局变量。该宏使用给定的初始值初始化键，该初始值分别为 false 或 true。例如，要声明一个初始值为 false 的静态键，我们可以使用以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_STATIC_KEY_FALSE(fkey);</span><br></pre></td></tr></table></figure>

<p>Once the static key has been declared, we need to add branching code to the module that uses the static key. For example, the code includes a fastpath, where a no-op instruction will be generated at compile time as the key is initialized to false and the branch is unlikely to be taken.<br>声明静态密钥后，我们需要向使用静态密钥的模块添加分支代码。例如，代码包含快速路径，其中将在编译时生成无操作指令，因为密钥被初始化为 false 并且不太可能采用分支。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pr_info(<span class="string">&quot;fastpath 1\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (static_branch_unlikely(&amp;fkey))</span><br><span class="line">    pr_alert(<span class="string">&quot;do unlikely thing\n&quot;</span>);</span><br><span class="line">pr_info(<span class="string">&quot;fastpath 2\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>If the key is enabled at runtime by calling <code>static_branch_enable(&amp;fkey)</code> , the fastpath will be patched with an unconditional jump instruction to the slowpath code <code>pr_alert</code> , so the branch will always be taken until the key is disabled again.<br>如果在运行时通过调用 <code>static_branch_enable(&amp;fkey)</code> 启用该键，则快速路径将使用无条件跳转指令修补到慢速路径代码 <code>pr_alert</code> ，因此将始终采用分支，直到该键被调用为止。再次禁用。</p>
<p>The following kernel module derived from chardev.c, demonstrates how the static key works.<br>以下源自 chardev.c 的内核模块演示了静态密钥的工作原理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * static_key.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span> <span class="comment">/* for sprintf() */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/printk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span> <span class="comment">/* for get_user and put_user */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/jump_label.h&gt;</span> <span class="comment">/* for static key macros */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">                           <span class="type">loff_t</span> *ppos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;key_state&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CDEV_NOT_USED = <span class="number">0</span>,</span><br><span class="line">    CDEV_EXCLUSIVE_OPEN = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">atomic_t</span> already_open = ATOMIC_INIT(CDEV_NOT_USED);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> msg[BUF_LEN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">cls</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_STATIC_KEY_FALSE</span><span class="params">(fkey)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">chardev_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = device_open,</span><br><span class="line">    .release = device_release,</span><br><span class="line">    .read = device_read,</span><br><span class="line">    .write = device_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chardev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;chardev_fops);</span><br><span class="line">    <span class="keyword">if</span> (major &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_alert(<span class="string">&quot;Registering char device failed with %d\n&quot;</span>, major);</span><br><span class="line">        <span class="keyword">return</span> major;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;I was assigned major number %d\n&quot;</span>, major);</span><br><span class="line"></span><br><span class="line">    cls = class_create(THIS_MODULE, DEVICE_NAME);</span><br><span class="line"></span><br><span class="line">    device_create(cls, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, DEVICE_NAME);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;Device created on /dev/%s\n&quot;</span>, DEVICE_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chardev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(cls, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(cls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unregister the device */</span></span><br><span class="line">    unregister_chrdev(major, DEVICE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Methods */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called when a process tried to open the device file, like</span></span><br><span class="line"><span class="comment"> * cat /dev/key_state</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (atomic_cmpxchg(&amp;already_open, CDEV_NOT_USED, CDEV_EXCLUSIVE_OPEN))</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(msg, static_key_enabled(&amp;fkey) ? <span class="string">&quot;enabled\n&quot;</span> : <span class="string">&quot;disabled\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;fastpath 1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (static_branch_unlikely(&amp;fkey))</span><br><span class="line">        pr_alert(<span class="string">&quot;do unlikely thing\n&quot;</span>);</span><br><span class="line">    pr_info(<span class="string">&quot;fastpath 2\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    try_module_get(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called when a process closes the device file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">device_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* We are now ready for our next caller. */</span></span><br><span class="line">    <span class="type">atomic_set</span>(&amp;already_open, CDEV_NOT_USED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Decrement the usage count, or else once you opened the file, you will</span></span><br><span class="line"><span class="comment">     * never get rid of the module.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    module_put(THIS_MODULE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called when a process, which already opened the dev file, attempts to</span></span><br><span class="line"><span class="comment"> * read from it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="comment">/* see include/linux/fs.h */</span></span></span><br><span class="line"><span class="params">                           <span class="type">char</span> __user *buffer, <span class="comment">/* buffer to fill with data */</span></span></span><br><span class="line"><span class="params">                           <span class="type">size_t</span> length, <span class="comment">/* length of the buffer */</span></span></span><br><span class="line"><span class="params">                           <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Number of the bytes actually written to the buffer */</span></span><br><span class="line">    <span class="type">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *msg_ptr = msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!*(msg_ptr + *offset)) &#123; <span class="comment">/* We are at the end of the message */</span></span><br><span class="line">        *offset = <span class="number">0</span>; <span class="comment">/* reset the offset */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* signify end of file */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg_ptr += *offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Actually put the data into the buffer */</span></span><br><span class="line">    <span class="keyword">while</span> (length &amp;&amp; *msg_ptr) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The buffer is in the user data segment, not the kernel</span></span><br><span class="line"><span class="comment">         * segment so &quot;*&quot; assignment won&#x27;t work. We have to use</span></span><br><span class="line"><span class="comment">         * put_user which copies data from the kernel data segment to</span></span><br><span class="line"><span class="comment">         * the user data segment.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        put_user(*(msg_ptr++), buffer++);</span><br><span class="line">        length--;</span><br><span class="line">        bytes_read++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *offset += bytes_read;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Most read functions return the number of bytes put into the buffer. */</span></span><br><span class="line">    <span class="keyword">return</span> bytes_read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called when a process writes to dev file; echo &quot;enable&quot; &gt; /dev/key_state */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">device_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buffer,</span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> command[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;command exceeded 10 char\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(command, buffer, length))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(command, <span class="string">&quot;enable&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;enable&quot;</span>)) == <span class="number">0</span>)</span><br><span class="line">        static_branch_enable(&amp;fkey);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(command, <span class="string">&quot;disable&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;disable&quot;</span>)) == <span class="number">0</span>)</span><br><span class="line">        static_branch_disable(&amp;fkey);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Invalid command: %s\n&quot;</span>, command);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Again, return the number of input characters used. */</span></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(chardev_init);</span><br><span class="line">module_exit(chardev_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>To check the state of the static key, we can use the &#x2F;dev&#x2F;key_state interface.<br>要检查静态密钥的状态，我们可以使用 &#x2F;dev&#x2F;key_state 接口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /dev/key_state</span><br></pre></td></tr></table></figure>

<p>This will display the current state of the key, which is disabled by default.<br>这将显示该键的当前状态，默认情况下该状态是禁用的。</p>
<p>To change the state of the static key, we can perform a write operation on the file:<br>要更改静态密钥的状态，我们可以对文件执行写操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="built_in">enable</span> &gt; /dev/key_state</span><br></pre></td></tr></table></figure>

<p>This will enable the static key, causing the code path to switch from the fastpath to the slowpath.<br>这将启用静态密钥，导致代码路径从快速路径切换到慢速路径。</p>
<p>In some cases, the key is enabled or disabled at initialization and never changed, we can declare a static key as read-only, which means that it can only be toggled in the module init function. To declare a read-only static key, we can use the <code>DEFINE_STATIC_KEY_FALSE_RO</code> or <code>DEFINE_STATIC_KEY_TRUE_RO</code> macro instead. Attempts to change the key at runtime will result in a page fault. For more information, see <a href="https://www.kernel.org/doc/Documentation/static-keys.txt">Static keys</a><br>在某些情况下，密钥在初始化时启用或禁用并且从未更改，我们可以将静态密钥声明为只读，这意味着它只能在模块初始化函数中切换。要声明只读静态键，我们可以使用 <code>DEFINE_STATIC_KEY_FALSE_RO</code> 或 <code>DEFINE_STATIC_KEY_TRUE_RO</code> 宏。尝试在运行时更改密钥将导致页面错误。有关详细信息，请参阅静态键</p>
<h3 id="20-Common-Pitfalls-20-个常见陷阱"><a href="#20-Common-Pitfalls-20-个常见陷阱" class="headerlink" title="20 Common Pitfalls 20 个常见陷阱"></a>20 Common Pitfalls 20 个常见陷阱</h3><h4 id="20-1-Using-standard-libraries"><a href="#20-1-Using-standard-libraries" class="headerlink" title="20.1 Using standard libraries"></a>20.1 Using standard libraries</h4><p>20.1 使用标准库</p>
<p>You can not do that. In a kernel module, you can only use kernel functions which are the functions you can see in &#x2F;proc&#x2F;kallsyms.<br>你不能这样做。在内核模块中，您只能使用内核函数，这些函数可以在 &#x2F;proc&#x2F;kallsyms 中看到。</p>
<h4 id="20-2-Disabling-interrupts"><a href="#20-2-Disabling-interrupts" class="headerlink" title="20.2 Disabling interrupts"></a>20.2 Disabling interrupts</h4><p>20.2 禁用中断</p>
<p>You might need to do this for a short time and that is OK, but if you do not enable them afterwards, your system will be stuck and you will have to power it off.<br>您可能需要在短时间内执行此操作，这没关系，但如果您之后不启用它们，您的系统将被卡住，您将不得不将其关闭。</p>
<h3 id="21-Where-To-Go-From-Here"><a href="#21-Where-To-Go-From-Here" class="headerlink" title="21 Where To Go From Here?"></a>21 Where To Go From Here?</h3><p>21 下一步该去哪里？</p>
<p>For people seriously interested in kernel programming, I recommend <a href="https://kernelnewbies.org/">kernelnewbies.org</a> and the <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation">Documentation</a> subdirectory within the kernel source code which is not always easy to understand but can be a starting point for further investigation. Also, as Linus Torvalds said, the best way to learn the kernel is to read the source code yourself.<br>对于对内核编程非常感兴趣的人，我推荐 kernelnewbies.org 和内核源代码中的 Documentation 子目录，它并不总是很容易理解，但可以作为进一步研究的起点。另外，正如 Linus Torvalds 所说，学习内核的最好方法就是自己阅读源代码。</p>
<p>If you would like to contribute to this guide or notice anything glaringly wrong, please create an issue at <a href="https://github.com/sysprog21/lkmpg">https://github.com/sysprog21/lkmpg</a>. Your pull requests will be appreciated.<br>如果您想为本指南做出贡献或发现任何明显错误，请在 <a href="https://github.com/sysprog21/lkmpg">https://github.com/sysprog21/lkmpg</a> 上创建问题。您的拉取请求将不胜感激。</p>
<p>Happy hacking!   快乐黑客！</p>
<p><a href="https://sysprog21.github.io/lkmpg/#fn1x0-bk"><sup data-immersive-translate-effect="1" data-immersive_translate_walked="8ab93f9b-58ac-4b89-b455-647ae1c1af85">1</sup></a>The goal of threaded interrupts is to push more of the work to separate threads, so that the minimum needed for acknowledging an interrupt is reduced, and therefore the time spent handling the interrupt (where it can’t handle any other interrupts at the same time) is reduced. See <a href="https://lwn.net/Articles/302043/">https://lwn.net/Articles/302043/</a><br><sup data-immersive-translate-effect="1" data-immersive_translate_walked="8ab93f9b-58ac-4b89-b455-647ae1c1af85">1</sup> 线程中断的目标是将更多的工作推送到单独的线程，从而减少确认中断所需的最少时间，从而减少处理中断所花费的时间（在它无法处理的情况下）同时减少任何其他中断。参见<a href="https://lwn.net/Articles/302043/">https://lwn.net/Articles/302043/</a>.</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux 内核</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的安装和配置</title>
    <url>/2019/12/15/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="MySQL-服务其安装与配置"><a href="#MySQL-服务其安装与配置" class="headerlink" title="MySQL 服务其安装与配置"></a>MySQL 服务其安装与配置</h1><blockquote>
<p>转载：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-18-04">https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-18-04</a></p>
</blockquote>
<h2 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h2><p>首先运行下面命令更新软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure>

<p>然后安装默认软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install mysql-server</span><br></pre></td></tr></table></figure>

<p>这将安装 MySQL，但不会提示您设置密码或进行任何其他配置更改。</p>
<h2 id="调整用户身份验证和特权"><a href="#调整用户身份验证和特权" class="headerlink" title="调整用户身份验证和特权"></a>调整用户身份验证和特权</h2><h3 id="创建-root-密码"><a href="#创建-root-密码" class="headerlink" title="创建 root 密码"></a>创建 root 密码</h3><p>在运行 MySQL 5.7（及更高版本）的 Ubuntu 系统中，默认情况下，MySQL root 用户设置为使用 <code>auth_socket</code> 插件而不是密码进行身份验证。</p>
<p>为了使用密码，以 root 用户身份连接到 MySQL ，您需要将其身份验证方法从切换 <code>auth_socket</code> 为 <code>mysql_native_password</code> ，首先使用 root 账号打开 mysql。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo mysql</span><br></pre></td></tr></table></figure>

<p>接下来，使用以下命令检查每个 MySQL 用户帐户使用的身份验证方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT user,authentication_string,plugin,host FROM mysql.user;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Output</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">| user             | authentication_string                     | plugin                | host      |</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">| root             |                                           | auth_socket           | localhost |</span><br><span class="line">| mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost |</span><br><span class="line">| mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost |</span><br><span class="line">| debian-sys-maint | *CC744277A401A7D25BE1CA89AFF17BF607F876FF | mysql_native_password | localhost |</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>在此示例中，您可以看到 root 用户实际上使用 <code>auth_socket</code> 插件进行了身份验证。要将 root 帐户配置为使用密码进行身份验证，请运行以下 <code>ALTER USER</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后，运行 <code>FLUSH PRIVILEGES</code> 告诉服务器重新加载授权表并使新的更改生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>再次检查每个用户使用的身份验证方法，以确认 root 不再使用该 auth_socket 插件进行身份验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT user,authentication_string,plugin,host FROM mysql.user;</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">| user             | authentication_string                     | plugin                | host      |</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">| root             | *3636DACC8616D997782ADD0839F92C1571D6D78F | mysql_native_password | localhost |</span><br><span class="line">| mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost |</span><br><span class="line">| mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost |</span><br><span class="line">| debian-sys-maint | *CC744277A401A7D25BE1CA89AFF17BF607F876FF | mysql_native_password | localhost |</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>您可以在此示例输出中看到，MySQL 根用户现在使用密码进行了身份验证。</p>
<h3 id="创建普通用户"><a href="#创建普通用户" class="headerlink" title="创建普通用户"></a>创建普通用户</h3><p>一般情况下，我们会创建一个普通用户操作 mysql 数据库，可以按下面方法创建一个普通用户。</p>
<p>首先使用 root 账号进入 mysql 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>接着创建一个新用户并为其设置一个强密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE USER <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span> IDENTIFIED BY <span class="string">&#x27;password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>username: 创建的用户名。</li>
<li>host: 指定该用户在哪个主机上可以登陆，如果是本地用户可用 <code>localhost</code>，如果是远程登陆，可以使用通配符 <code>%</code> 。</li>
<li>password：用户的登陆密码。</li>
</ul>
<p>其中需要注意的是，如果 host 指定为 <code>%</code> ，那么还需要进入设置 <code>/etc/mysql/mysql.conf.d/mysqld.cnf</code> 配置文件，注释掉其中的 <code>bind-address = 127.0.0.1</code> 行，然后执行 <code>sudo systemctl restart mysql</code> 重新启动 mysql 服务。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE USER <span class="string">&#x27;ckcat&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;xxxxxxxx&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="给新用户授权"><a href="#给新用户授权" class="headerlink" title="给新用户授权"></a>给新用户授权</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; GRANT privileges ON databasename.tablename TO <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>privileges：用户的操作权限。如 SELECT，INSERT，UPDATE 等，如果要授予所的权限则使用 ALL</li>
<li>databasename：数据库名</li>
<li>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<code>*.*</code>表示。</li>
</ul>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; GRANT SELECT, INSERT ON test.user TO <span class="string">&#x27;ckcat&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">mysql&gt; GRANT ALL ON *.* TO <span class="string">&#x27;ckcat&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">mysql&gt; show grants <span class="keyword">for</span> <span class="string">&#x27;ckcat&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="配置-MySQL"><a href="#配置-MySQL" class="headerlink" title="配置 MySQL"></a>配置 MySQL</h2><p>对于全新安装，您将需要运行随附的安全脚本。这会更改一些不太安全的默认选项，例如远程 root 登录和样本用户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>

<p>这将引导您完成一系列提示，在其中您可以对 MySQL 安装的安全性选项进行一些更改。第一个提示将询问您是否要设置验证密码插件，该插件可用于测试 MySQL 密码的强度。无论您选择什么，下一个提示都是为 MySQL root 用户设置密码。输入，然后确认您选择的安全密码。</p>
<h2 id="1-4-测试-MySQL"><a href="#1-4-测试-MySQL" class="headerlink" title="1.4. 测试 MySQL"></a>1.4. 测试 MySQL</h2><p>无论您如何安装，MySQL 都应该已经开始自动运行。要对此进行测试，请检查其状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  systemctl status mysql.service</span><br></pre></td></tr></table></figure>

<p>您将看到类似于以下内容的输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">● mysql.service - MySQL Community Server</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: en</span><br><span class="line">   Active: active (running) since Sun 2019-12-15 10:36:06 CST; 32min ago</span><br><span class="line"> Main PID: 8876 (mysqld)</span><br><span class="line">    Tasks: 35 (<span class="built_in">limit</span>: 4915)</span><br><span class="line">   CGroup: /system.slice/mysql.service</span><br><span class="line">           └─8876 /usr/sbin/mysqld --daemonize --pid-file=/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line">Dec 15 10:36:05 ckcat-ubuntu systemd[1]: Starting MySQL Community Server...</span><br><span class="line">Dec 15 10:36:06 ckcat-ubuntu systemd[1]: Started MySQL Community Server.</span><br></pre></td></tr></table></figure>

<p>如果 MySQL 未运行，则可以使用来启动它 <code>sudo systemctl start mysql</code> ，也可以通过下列方法进行操作。</p>
<p>启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service mysql start</span><br></pre></td></tr></table></figure>

<p>停止服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service mysql stop</span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service mysql restart</span><br></pre></td></tr></table></figure>

<h2 id="使用-MySQL-Workbench-连接数据库"><a href="#使用-MySQL-Workbench-连接数据库" class="headerlink" title="使用 MySQL Workbench 连接数据库"></a>使用 MySQL Workbench 连接数据库</h2><p>安装 MySQL Workbench</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install mysql-workbench</span><br></pre></td></tr></table></figure>

<p>启动 MySQL Workbench ，选择 ip、端口、用户名，输入密码连接对应的数据库</p>
<img src="/2019/12/15/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/2019-12-15-11-30-54.png" class="">

<h1 id="将-MySQL-数据目录移动到新位置"><a href="#将-MySQL-数据目录移动到新位置" class="headerlink" title="将 MySQL 数据目录移动到新位置"></a>将 MySQL 数据目录移动到新位置</h1><blockquote>
<p>参考：<a href="https://www.digitalocean.com/community/tutorials/how-to-move-a-mysql-data-directory-to-a-new-location-on-ubuntu-18-04">https://www.digitalocean.com/community/tutorials/how-to-move-a-mysql-data-directory-to-a-new-location-on-ubuntu-18-04</a></p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>数据库会随着时间增长，有时会超出文件系统上的空间。当 <code>I/O</code> 与操作系统的其余部分位于同一分区时，您也可能会遇到 <code>I/O</code> 竞争。 RAID 、网络块存储和其他设备可以提供冗余和其他所需的功能。无论您是要添加更多空间，评估优化性能的方式还是希望利用其他存储功能，本教程都将指导您重新定位 MySQL 的数据目录。</p>
<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>要完成本指南，您将需要：</p>
<ul>
<li>具有非 root 用户 sudo 特权的 Ubuntu 18.04 服务器。</li>
<li>一个 MySQL 服务器</li>
</ul>
<p>在此示例中，我们将数据移至 <code>~/.mysqldata</code> 目录中。</p>
<h2 id="第-1-步-移动-MySQL-数据目录"><a href="#第-1-步-移动-MySQL-数据目录" class="headerlink" title="第 1 步-移动 MySQL 数据目录"></a>第 1 步-移动 MySQL 数据目录</h2><p>为了准备移动 MySQL 的数据目录，让我们通过使用管理凭据启动交互式 MySQL 会话来验证当前位置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>出现提示时，提供 MySQL root 密码。然后在 MySQL 提示符下，选择数据目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; select @@datadir;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Output</span><br><span class="line">+-----------------+</span><br><span class="line">| @@datadir       |</span><br><span class="line">+-----------------+</span><br><span class="line">| /var/lib/mysql/ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>此输出确认 MySQL 已配置为使用默认数据目录， <code>/var/lib/mysql/</code> ,因此这是我们需要移动的目录。</p>
<p>为了确保数据的完整性，在实际更改数据目录之前，我们将关闭 MySQL：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl stop mysql</span><br></pre></td></tr></table></figure>

<p><code>systemctl</code> 不会显示所有服务管理命令的结果，因此，如果要确保成功，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl status mysql</span><br></pre></td></tr></table></figure>

<p>如果输出的最后一行告诉您服务器已停止，则可以确定它已关闭：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">Dec 15 11:42:15 ckcat-ubuntu systemd[1]: Stopped MySQL Community Server.</span><br></pre></td></tr></table></figure>

<p>现在服务器已关闭，我们将使用 <code>rsync</code> 将现有数据库目录复制到新位置。使用该 <code>-a</code> 标志保留权限和其他目录属性，同时 <code>-v</code> 提供详细的输出，以便您可以跟踪进度。</p>
<blockquote>
<p>注意：请确保目录上没有斜杠，如果使用制表符补全，可以添加斜杠。当出现斜杠时，rsync 会将目录的内容转储到安装点，而不是将其传输到包含 mysql 目录.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo rsync -av /var/lib/mysql ~/.mysqldata</span><br></pre></td></tr></table></figure>

<p>一旦 <code>rsync</code> 完成，用 <code>.bak</code> 扩展名重命名当前文件夹中保存，直到我们已经证实，此举是成功的。通过重命名，我们可以避免新旧位置文件引起的混乱：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">mv</span> /var/lib/mysql /var/lib/mysql.bak</span><br></pre></td></tr></table></figure>

<p>现在，我们准备将注意力转向配置。</p>
<h2 id="第-2-步-指向新数据位置"><a href="#第-2-步-指向新数据位置" class="headerlink" title="第 2 步-指向新数据位置"></a>第 2 步-指向新数据位置</h2><p>MySQL 有几种方法可以覆盖配置值。默认情况下， <code>/etc/mysql/mysql.conf.d/mysqld.cnf</code> 在文件中 <code>datadir</code> 设置为 <code>/var/lib/mysql</code> 。编辑此文件以反映新的数据目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>

<p>找到开头的行， <code>datadir=</code> 并更改其后的路径以反映新位置。</p>
<p>在我们的例子中，更新后的文件如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">datadir=~/.mysqldata/mysql</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<p>这似乎是重新启动 MySQL 的正确时机，但是在成功完成此配置之前，还需要配置一件事。</p>
<h2 id="步骤-3-—配置-AppArmor-访问控制规则"><a href="#步骤-3-—配置-AppArmor-访问控制规则" class="headerlink" title="步骤 3 —配置 AppArmor 访问控制规则"></a>步骤 3 —配置 AppArmor 访问控制规则</h2><p>我们需要告诉 AppArmor 通过在默认目录和新位置之间创建别名来让 MySQL 写入新目录。为此，请编辑 AppArmor <code>alias</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/apparmor.d/tunables/alias</span><br></pre></td></tr></table></figure>

<p>在文件底部，添加以下别名规则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line"><span class="built_in">alias</span> /var/lib/mysql/ -&gt; ~/.mysqldata/mysql,</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<p>为了使更改生效，请重新启动 AppArmor：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl restart apparmor</span><br></pre></td></tr></table></figure>

<p> 注意：如果跳过 AppArmor 配置步骤，则会遇到以下错误消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Job <span class="keyword">for</span> mysql.service failed because the control process</span><br><span class="line">exited with error code. See <span class="string">&quot;systemctl status mysql.service&quot;</span></span><br><span class="line">and <span class="string">&quot;journalctl -xe&quot;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<p>从 <code>systemctl</code> 和<code>journalctl</code> 两者的输出结尾判断：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Jul 18 11:03:24 ubuntu-512mb-nyc1-01 systemd[1]:</span><br><span class="line">mysql.service: Main process exited, code=exited, status=1/FAILURE</span><br></pre></td></tr></table></figure>

<p>由于消息没有在 AppArmor 和数据目录之间建立显式连接，因此该错误可能需要一些时间才能弄清楚。</p>
<h2 id="第-4-步-重新启动-MySQL"><a href="#第-4-步-重新启动-MySQL" class="headerlink" title="第 4 步-重新启动 MySQL"></a>第 4 步-重新启动 MySQL</h2><p>下一步是启动 MySQL ，但如果这样做，则会遇到另一个错误。这次不是发生 AppArmor 问题，而是因为该脚本 <code>mysql-systemd-start</code> 检查是否存在与两个默认路径匹配的目录 <code>-d</code> 或符号链接 <code>-L</code> 。如果找不到它们，它将失败：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line"><span class="keyword">if</span> [ ! -d /var/lib/mysql ] &amp;&amp; [ ! -L /var/lib/mysql ]; <span class="keyword">then</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;MySQL data dir not found at /var/lib/mysql. Please create one.&quot;</span></span><br><span class="line"> <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -d /var/lib/mysql/mysql ] &amp;&amp; [ ! -L /var/lib/mysql/mysql ]; <span class="keyword">then</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;MySQL system database not found. Please run mysql_install_db tool.&quot;</span></span><br><span class="line"> <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<p>因为我们需要这些来启动服务器，所以我们将创建最小的目录结构以通过脚本的环境检查。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">mkdir</span> /var/lib/mysql/mysql -p</span><br></pre></td></tr></table></figure>

<p>现在我们准备启动 MySQL。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start mysql</span><br><span class="line">$ sudo systemctl status mysql</span><br></pre></td></tr></table></figure>

<p>为了确保确实使用了新的数据目录，请启动 MySQL 监视器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>再次查看数据目录的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; select @@datadir;</span><br><span class="line"></span><br><span class="line">+-------------------------------+</span><br><span class="line">| @@datadir                     |</span><br><span class="line">+-------------------------------+</span><br><span class="line">| /home/ckcat/.mysqldata/mysql/ |</span><br><span class="line">+-------------------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>现在，您已经重新启动了 MySQL 并确认它正在使用新位置，请借此机会确保您的数据库可以正常运行。验证所有现有数据的完整性后，即可删除备份数据目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">rm</span> -Rf /var/lib/mysql.bak</span><br></pre></td></tr></table></figure>

<p>最后一次重启 MySQL，以确保它能按预期运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl restart mysql</span><br><span class="line">$ sudo systemctl status mysql</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本教程中，我们将 MySQL 的数据目录移动到了新位置，并更新了 Ubuntu 的 AppArmor ACL 以适应该调整。尽管我们使用的是块存储设备，但无论底层技术如何，此处的说明都应适用于重新定义数据目录的位置。</p>
<p>有关管理 MySQL 数据目录的更多信息，请参见 MySQL 官方文档中的以下部分：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/data-directory.html">Mysql 数据目录</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/multiple-data-directories.html">设置多个数据目录</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 库打包分发(setup.py 编写)简易指南</title>
    <url>/2019/12/31/Python-%E5%BA%93%E6%89%93%E5%8C%85%E5%88%86%E5%8F%91-setup-py-%E7%BC%96%E5%86%99-%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p>转载 <a href="http://blog.konghy.cn/2018/04/29/setup-dot-py/">http://blog.konghy.cn/2018/04/29/setup-dot-py/</a></p>
</blockquote>
<p>Python 有非常丰富的第三方库可以使用，很多开发者会向 <a href="https://pypi.org/">pypi</a> 上提交自己的 Python 包。要想向 pypi 包仓库提交自己开发的包，首先要将自己的代码打包，才能上传分发。</p>
<h2 id="distutils-简介"><a href="#distutils-简介" class="headerlink" title="distutils 简介"></a>distutils 简介</h2><p><code>distutils</code> 是标准库中负责建立 Python 第三方库的安装器，使用它能够进行 Python 模块的安装和发布。<code>distutils</code> 对于简单的分发很有用，但功能缺少。大部分 Python 用户会使用更先进的 <code>setuptools</code> 模块.</p>
<h2 id="setuptools-简介"><a href="#setuptools-简介" class="headerlink" title="setuptools 简介"></a>setuptools 简介</h2><p><code>setuptools</code> 是 <code>distutils</code> 增强版，不包括在标准库中。其扩展了很多功能，能够帮助开发者更好的创建和分发 Python 包。大部分 Python 用户都会使用更先进的 <a href="https://setuptools.readthedocs.io/">setuptools</a> 模块。</p>
<p><code>Setuptools</code> 有一个 fork 分支是 <code>distribute</code>。它们共享相同的命名空间，因此如果安装了 <code>distribute</code>，<code>import setuptools</code> 时实际上将导入使用 <code>distribute</code> 创建的包。<code>Distribute</code> 已经合并回 <code>setuptools</code>。</p>
<p>还有一个大包分发工具是 <code>distutils2</code> ，其试图尝试充分利用 <code>distutils</code>，<code>detuptools</code> 和 <code>distribute</code> 并成为 Python 标准库中的标准工具。但该计划并没有达到预期的目的，且已经是一个废弃的项目。</p>
<p>因此，<code>setuptools</code> 是一个优秀的，可靠的 Pthon 包安装与分发工具。以下设计到包的安装与分发均针对 <code>setuptools</code>，并不保证 <code>distutils</code> 可用。</p>
<h2 id="包格式"><a href="#包格式" class="headerlink" title="包格式"></a>包格式</h2><p>Python 库打包的格式包括 <code>Wheel</code> 和 <code>Egg</code>。<code>Egg</code> 格式是由 <code>setuptools</code> 在 2004 年引入，而 <code>Wheel</code> 格式是由 PEP427 在 2012 年定义。使用 <code>Wheel</code> 和 <code>Egg</code> 安装都不需要重新构建和编译，其在发布之前就应该完成测试和构建。</p>
<p><code>Egg</code> 和 <code>Wheel</code> 本质上都是一个 zip 格式包，<code>Egg</code> 文件使用 <code>.egg</code> 扩展名，<code>Wheel</code> 使用 <code>.whl</code> 扩展名。<code>Wheel</code> 的出现是为了替代 <code>Egg</code>，其现在被认为是 Python 的二进制包的标准格式。</p>
<p>以下是 <code>Wheel</code> 和 <code>Egg</code> 的主要区别：</p>
<ul>
<li><code>Wheel</code> 有一个官方的 PEP427 来定义，而 <code>Egg</code> 没有 PEP 定义</li>
<li><code>Wheel</code> 是一种分发格式，即打包格式。而 <code>Egg</code> 既是一种分发格式，也是一种运行时安装的格式，并且是可以被直接 import</li>
<li><code>Wheel</code> 文件不会包含 <code>.pyc</code> 文件</li>
<li><code>Wheel</code> 使用和 PEP376 兼容的 <code>.dist-info</code> 目录，而 Egg 使用 <code>.egg-info</code> 目录</li>
<li><code>Wheel</code> 有着更丰富的命名规则。</li>
<li><code>Wheel</code> 是有版本的。每个 <code>Wheel</code> 文件都包含 <code>wheel</code> 规范的版本和打包的实现</li>
<li><code>Wheel</code> 在内部被 <code>sysconfig path type</code> 管理，因此转向其他格式也更容易</li>
</ul>
<p>详细描述可见：<a href="https://packaging.python.org/discussions/wheel-vs-egg/">Wheel vs Egg</a></p>
<h2 id="setup-py-文件"><a href="#setup-py-文件" class="headerlink" title="setup.py 文件"></a><code>setup.py</code> 文件</h2><p>Python 库打包分发的关键在于编写 <code>setup.py</code> 文件。<code>setup.py</code> 文件编写的规则是从 <code>setuptools</code> 或者 <code>distuils</code> 模块导入 <code>setup</code> 函数，并传入各类参数进行调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="comment"># from distutils.core import setup</span></span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">        name=<span class="string">&#x27;demo&#x27;</span>,     <span class="comment"># 包名字</span></span><br><span class="line">        version=<span class="string">&#x27;1.0&#x27;</span>,   <span class="comment"># 包版本</span></span><br><span class="line">        description=<span class="string">&#x27;This is a test of the setup&#x27;</span>,   <span class="comment"># 简单描述</span></span><br><span class="line">        author=<span class="string">&#x27;huoty&#x27;</span>,  <span class="comment"># 作者</span></span><br><span class="line">        author_email=<span class="string">&#x27;sudohuoty@163.com&#x27;</span>,  <span class="comment"># 作者邮箱</span></span><br><span class="line">        url=<span class="string">&#x27;https://www.konghy.com&#x27;</span>,      <span class="comment"># 包的主页</span></span><br><span class="line">        packages=[<span class="string">&#x27;demo&#x27;</span>],                 <span class="comment"># 包</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="参数概述"><a href="#参数概述" class="headerlink" title="参数概述"></a>参数概述</h2><p>setup 函数常用的参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>包名称</td>
</tr>
<tr>
<td>version</td>
<td>包版本</td>
</tr>
<tr>
<td>author</td>
<td>程序的作者</td>
</tr>
<tr>
<td>author_email</td>
<td>程序的作者的邮箱地址</td>
</tr>
<tr>
<td>maintainer</td>
<td>维护者</td>
</tr>
<tr>
<td>maintainer_email</td>
<td>维护者的邮箱地址</td>
</tr>
<tr>
<td>url</td>
<td>程序的官网地址</td>
</tr>
<tr>
<td>license</td>
<td>程序的授权信息</td>
</tr>
<tr>
<td>description</td>
<td>程序的简单描述</td>
</tr>
<tr>
<td>long_description</td>
<td>程序的详细描述</td>
</tr>
<tr>
<td>platforms</td>
<td>程序适用的软件平台列表</td>
</tr>
<tr>
<td>classifiers</td>
<td>程序的所属分类列表</td>
</tr>
<tr>
<td>keywords</td>
<td>程序的关键字列表</td>
</tr>
<tr>
<td>packages</td>
<td>需要处理的包目录(通常为包含 <code>__init__.py</code> 的文件夹)</td>
</tr>
<tr>
<td>py_modules</td>
<td>需要打包的 Python 单文件列表</td>
</tr>
<tr>
<td>download_url</td>
<td>程序的下载地址</td>
</tr>
<tr>
<td>cmdclass</td>
<td>添加自定义命令</td>
</tr>
<tr>
<td>package_data</td>
<td>指定包内需要包含的数据文件</td>
</tr>
<tr>
<td>include_package_data</td>
<td>自动包含包内所有受版本控制(cvs&#x2F;svn&#x2F;git)的数据文件</td>
</tr>
<tr>
<td>exclude_package_data</td>
<td>当 include_package_data 为 True 时该选项用于排除部分文件</td>
</tr>
<tr>
<td>data_files</td>
<td>打包时需要打包的数据文件，如图片，配置文件等</td>
</tr>
<tr>
<td>ext_modules</td>
<td>指定扩展模块</td>
</tr>
<tr>
<td>scripts</td>
<td>指定可执行脚本,安装时脚本会被安装到系统 PATH 路径下</td>
</tr>
<tr>
<td>package_dir</td>
<td>指定哪些目录下的文件被映射到哪个源码包</td>
</tr>
<tr>
<td>requires</td>
<td>指定依赖的其他包</td>
</tr>
<tr>
<td>provides</td>
<td>指定可以为哪些模块提供依赖</td>
</tr>
<tr>
<td>install_requires</td>
<td>安装时需要安装的依赖包</td>
</tr>
<tr>
<td>entry_points</td>
<td>动态发现服务和插件，下面详细讲</td>
</tr>
<tr>
<td>setup_requires</td>
<td>指定运行 <code>setup.py</code> 文件本身所依赖的包</td>
</tr>
<tr>
<td>dependency_links</td>
<td>指定依赖包的下载地址</td>
</tr>
<tr>
<td>extras_require</td>
<td>当前包的高级&#x2F;额外特性需要依赖的分发包</td>
</tr>
<tr>
<td>zip_safe</td>
<td>不压缩包，而是以目录的形式安装</td>
</tr>
</tbody></table>
<p>更多参数可见：<a href="https://setuptools.readthedocs.io/en/latest/setuptools.html">https://setuptools.readthedocs.io/en/latest/setuptools.html</a></p>
<h2 id="find-packages"><a href="#find-packages" class="headerlink" title="find_packages"></a>find_packages</h2><p>对于简单工程来说，手动增加 <code>packages</code> 参数是容易。而对于复杂的工程来说，可能添加很多的包，这是手动添加就变得麻烦。<code>Setuptools</code> 模块提供了一个 <code>find_packages</code> 函数，它默认在与 <code>setup.py</code> 文件同一目录下搜索各个含有 <code>__init__.py</code> 的目录做为要添加的包。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find_packages(where=<span class="string">&#x27;.&#x27;</span>, exclude=(), include=(<span class="string">&#x27;*&#x27;</span>,))</span><br></pre></td></tr></table></figure>

<p><code>find_packages</code> 函数的第一个参数用于指定在哪个目录下搜索包，参数 <strong>exclude</strong> 用于指定排除哪些包，参数 <strong>include</strong> 指出要包含的包。</p>
<p>默认默认情况下 <code>setup.py</code> 文件只在其所在的目录下搜索包。如果不用 <code>find_packages</code> ，想要找到其他目录下的包，也可以设置 <strong>package_dir</strong> 参数，其指定哪些目录下的文件被映射到哪个源码包，如: <code>package_dir=&#123;&#39;&#39;: &#39;src&#39;&#125;</code> 表示 <code>root package</code> 中的模块都在 <code>src</code> 目录中。</p>
<h2 id="包含数据文件"><a href="#包含数据文件" class="headerlink" title="包含数据文件"></a>包含数据文件</h2><ul>
<li><strong>package_data</strong>:</li>
</ul>
<p>该参数是一个从包名称到 <code>glob</code> 模式列表的字典。如果数据文件包含在包的子目录中，则 <code>glob</code> 可以包括子目录名称。其格式一般为 <code>&#123;&#39;package_name&#39;: [&#39;files&#39;]&#125;</code> ，比如： <code>package_data=&#123;&#39;mypkg&#39;: [&#39;data/*.dat&#39;],&#125;</code> 。</p>
<ul>
<li><strong>include_package_data</strong>:</li>
</ul>
<p>该参数被设置为 <code>True</code> 时自动添加包中受版本控制的数据文件，可替代 <code>package_data</code>，同时， <code>exclude_package_data</code> 可以排除某些文件。注意当需要加入没有被版本控制的文件时，还是仍然需要使用 <code>package_data</code> 参数才行。</p>
<ul>
<li><strong>data_files</strong>:</li>
</ul>
<p>该参数通常用于包含不在包内的数据文件，即包的外部文件，如：配置文件，消息目录，数据文件。其指定了一系列二元组，即(目的安装目录，源文件) ，表示哪些文件被安装到哪些目录中。如果目录名是相对路径，则相对于安装前缀进行解释。</p>
<ul>
<li><strong>manifest template</strong>:</li>
</ul>
<p><code>manifest template</code> 即编写 <code>MANIFEST.in</code> 文件，文件内容就是需要包含在分发包中的文件。一个 <code>MANIFEST.in</code> 文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">include *.txt</span><br><span class="line">recursive-include examples *.txt *.py</span><br><span class="line">prune examples/sample?/build</span><br></pre></td></tr></table></figure>

<p><code>MANIFEST.in</code> 文件的编写规则可参考：<a href="https://docs.python.org/3.6/distutils/sourcedist.html">https://docs.python.org/3.6/distutils/sourcedist.html</a></p>
<h2 id="生成脚本"><a href="#生成脚本" class="headerlink" title="生成脚本"></a>生成脚本</h2><p>有两个参数 <code>scripts</code> 参数或 <code>console_scripts</code> 可用于生成脚本。</p>
<p><code>entry_points</code> 参数用来支持自动生成脚本，其值应该为是一个字典，从 <code>entry_point</code> 组名映射到一个表示 <code>entry_point</code> 的字符串或字符串列表，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setup(</span><br><span class="line">    <span class="comment"># other arguments here...</span></span><br><span class="line">    entry_points=&#123;</span><br><span class="line">        <span class="string">&#x27;console_scripts&#x27;</span>: [</span><br><span class="line">            <span class="string">&#x27;foo=foo.entry:main&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;bar=foo.entry:main&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>scripts</code> 参数是一个 <code>list</code>，安装包时在该参数中列出的文件会被安装到系统 <code>PATH</code> 路径下。如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scripts=[<span class="string">&#x27;bin/foo.sh&#x27;</span>, <span class="string">&#x27;bar.py&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>用如下方法可以将脚本重命名，例如去掉脚本文件的扩展名(<code>.py</code>、<code>.sh</code>):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools.command.install_scripts <span class="keyword">import</span> install_scripts</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InstallScripts</span>(<span class="title class_ inherited__">install_scripts</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        setuptools.command.install_scripts.install_scripts.run(self)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Rename some script files</span></span><br><span class="line">        <span class="keyword">for</span> script <span class="keyword">in</span> self.get_outputs():</span><br><span class="line">            <span class="keyword">if</span> basename.endswith(<span class="string">&quot;.py&quot;</span>) <span class="keyword">or</span> basename.endswith(<span class="string">&quot;.sh&quot;</span>):</span><br><span class="line">                dest = script[:-<span class="number">3</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;moving %s to %s&quot;</span> % (script, dest))</span><br><span class="line">            shutil.move(script, dest)</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    <span class="comment"># other arguments here...</span></span><br><span class="line">    cmdclass=&#123;</span><br><span class="line">        <span class="string">&quot;install_scripts&quot;</span>: InstallScripts</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>其中，<code>cmdclass</code> 参数表示自定制命令，后文详述。</p>
<h2 id="ext-modules"><a href="#ext-modules" class="headerlink" title="ext_modules"></a>ext_modules</h2><p><code>ext_modules</code> 参数用于构建 C 和 C++ 扩展扩展包。其是 <code>Extension</code> 实例的列表，每一个 <code>Extension</code> 实例描述了一个独立的扩展模块，扩展模块可以设置扩展包名，头文件、源文件、链接库及其路径、宏定义和编辑参数等。如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setup(</span><br><span class="line">    <span class="comment"># other arguments here...</span></span><br><span class="line">    ext_modules=[</span><br><span class="line">        Extension(<span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">                  glob(path.join(here, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;*.c&#x27;</span>)),</span><br><span class="line">                  libraries = [ <span class="string">&#x27;rt&#x27;</span> ],</span><br><span class="line">                  include_dirs=[numpy.get_include()])</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>详细了解可参考：<a href="https://docs.python.org/3.6/distutils/setupscript.html#preprocessor-options">https://docs.python.org/3.6/distutils/setupscript.html#preprocessor-options</a></p>
<h2 id="zip-safe"><a href="#zip-safe" class="headerlink" title="zip_safe"></a>zip_safe</h2><p><code>zip_safe</code> 参数决定包是否作为一个 zip 压缩后的 <code>egg</code> 文件安装，还是作为一个以 <code>.egg</code> 结尾的目录安装。因为有些工具不支持 zip 压缩文件，而且压缩后的包也不方便调试，所以建议将其设为 <code>False</code>，即 <code>zip_safe=False</code> 。</p>
<h2 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h2><p><code>Setup.py</code> 文件有很多内置的的命令，可以使用 <code>python setup.py --help-commands</code> 查看。如果想要定制自己需要的命令，可以添加 <code>cmdclass</code> 参数，其值为一个 <code>dict</code>。实现自定义命名需要继承 <code>setuptools.Command</code> 或者 <code>distutils.core.Command</code> 并重写 <code>run</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup, Command</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InstallCommand</span>(<span class="title class_ inherited__">Command</span>):</span><br><span class="line">    description = <span class="string">&quot;Installs the foo.&quot;</span></span><br><span class="line">    user_options = [</span><br><span class="line">        (<span class="string">&#x27;foo=&#x27;</span>, <span class="literal">None</span>, <span class="string">&#x27;Specify the foo to bar.&#x27;</span>),</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initialize_options</span>(<span class="params">self</span>):</span><br><span class="line">        self.foo = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">finalize_options</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">assert</span> self.foo <span class="keyword">in</span> (<span class="literal">None</span>, <span class="string">&#x27;myFoo&#x27;</span>, <span class="string">&#x27;myFoo2&#x27;</span>), <span class="string">&#x27;Invalid foo!&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        install_all_the_things()</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    ...,</span><br><span class="line">    cmdclass=&#123;</span><br><span class="line">        <span class="string">&#x27;install&#x27;</span>: InstallCommand,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>如果包依赖其他的包，可以指定 <code>install_requires</code> 参数，其值为一个 <code>list</code>，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">install_requires=[</span><br><span class="line">    <span class="string">&#x27;requests&gt;=1.0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;flask&gt;=1.0&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>指定该参数后，在安装包时会自定从 pypi 仓库中下载指定的依赖包安装。</p>
<p>此外，还支持从指定链接下载依赖，即指定 <code>dependency_links</code> 参数，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependency_links = [</span><br><span class="line">    &quot;http://packages.example.com/snapshots/foo-1.0.tar.gz&quot;,</span><br><span class="line">    &quot;http://example2.com/p/bar-1.0.tar.gz&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="分类信息"><a href="#分类信息" class="headerlink" title="分类信息"></a>分类信息</h2><p><code>classifiers</code> 参数说明包的分类信息。所有支持的分类列表见：<a href="https://pypi.org/pypi?:action=list_classifiers">https://pypi.org/pypi?%3Aaction=list_classifiers</a></p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classifiers = [</span><br><span class="line">    <span class="comment"># 发展时期,常见的如下</span></span><br><span class="line">    <span class="comment">#   3 - Alpha</span></span><br><span class="line">    <span class="comment">#   4 - Beta</span></span><br><span class="line">    <span class="comment">#   5 - Production/Stable</span></span><br><span class="line">    <span class="string">&#x27;Development Status :: 3 - Alpha&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开发的目标用户</span></span><br><span class="line">    <span class="string">&#x27;Intended Audience :: Developers&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 属于什么类型</span></span><br><span class="line">    <span class="string">&#x27;Topic :: Software Development :: Build Tools&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 许可证信息</span></span><br><span class="line">    <span class="string">&#x27;License :: OSI Approved :: MIT License&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 目标 Python 版本</span></span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 2.7&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 3.3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 3.4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Programming Language :: Python :: 3.5&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="setup-py-命令"><a href="#setup-py-命令" class="headerlink" title="setup.py 命令"></a><code>setup.py</code> 命令</h2><p><code>setup.py</code> 文件有很多内置命令可供使用，查看所有支持的命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python setup.py --<span class="built_in">help</span>-commands</span><br></pre></td></tr></table></figure>

<p>此处列举一些常用命令：</p>
<ul>
<li><strong>build</strong>:</li>
</ul>
<p>构建安装时所需的所有内容</p>
<ul>
<li><strong>sdist</strong>:</li>
</ul>
<p>构建源码分发包，在 Windows 下为 zip 格式，Linux 下为 <code>tag.gz</code> 格式 。执行 <code>sdist</code> 命令时，默认会被打包的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所有 py_modules 或 packages 指定的源码文件</span><br><span class="line">所有 ext_modules 指定的文件</span><br><span class="line">所有 package_data 或 data_files 指定的文件</span><br><span class="line">所有 scripts 指定的脚本文件</span><br><span class="line">README、README.txt、setup.py 和 setup.cfg文件</span><br></pre></td></tr></table></figure>

<p>该命令构建的包主要用于发布，例如上传到 pypi 上。</p>
<ul>
<li><strong>bdist</strong>:</li>
</ul>
<p>构建一个二进制的分发包。</p>
<ul>
<li><strong>bdist_egg</strong>:</li>
</ul>
<p>构建一个 <code>egg</code> 分发包，经常用来替代基于 <code>bdist</code> 生成的模式</p>
<ul>
<li><strong>install</strong>:</li>
</ul>
<p>安装包到系统环境中。</p>
<ul>
<li><strong>develop</strong>:</li>
</ul>
<p>以开发方式安装包，该命名不会真正的安装包，而是在系统环境中创建一个软链接指向包实际所在目录。这边在修改包之后不用再安装就能生效，便于调试。</p>
<ul>
<li><strong>register、upload</strong>:</li>
</ul>
<p>用于包的上传发布，后文详述。</p>
<h2 id="setup-cfg-文件"><a href="#setup-cfg-文件" class="headerlink" title="setup.cfg 文件"></a>setup.cfg 文件</h2><p><code>setup.cfg</code> 文件用于提供 setup.py 的默认参数，详细的书写规则可参考：<a href="https://docs.python.org/3/distutils/configfile.html">https://docs.python.org/3/distutils/configfile.html</a></p>
<h2 id="版本命名"><a href="#版本命名" class="headerlink" title="版本命名"></a>版本命名</h2><p>包版本的命名格式应为如下形式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">N.N[.N]+[&#123;a|b|c|rc&#125;N[.N]+][.postN][.devN]</span><br></pre></td></tr></table></figure>

<p>从左向右做一个简单的解释：</p>
<ul>
<li><code>N.N</code>: 必须的部分，两个 “N” 分别代表了主版本和副版本号</li>
<li><code>[.N]</code>: 次要版本号，可以有零或多个</li>
<li><code>&#123;a|b|c|rc&#125;</code>: 阶段代号，可选, a, b, c, rc 分别代表 alpha, beta, candidate 和 release candidate</li>
<li><code>N[.N]</code>: 阶段版本号，如果提供，则至少有一位主版本号，后面可以加无限多位的副版本号</li>
<li><code>.postN</code>: 发行后更新版本号，可选</li>
<li><code>.devN</code>: 开发期间的发行版本号，可选</li>
</ul>
<h2 id="easy-install-与-pip"><a href="#easy-install-与-pip" class="headerlink" title="easy_install 与 pip"></a>easy_install 与 pip</h2><p><code>easy_insall</code> 是 <code>setuptool</code> 包提供的第三方包安装工具，而 <code>pip</code> 是 Python 中一个功能完备的包管理工具，是 <code>easy_install</code> 的改进版，提供更好的提示信息，删除包等功能。</p>
<p><code>pip</code> 相对于 <code>easy_install</code> 进行了以下几个方面的改进:</p>
<ul>
<li>所有的包是在安装之前就下载了，所以不可能出现只安装了一部分的情况</li>
<li>在终端上的输出更加友好</li>
<li>对于动作的原因进行持续的跟踪。例如，如果一个包正在安装，那么 <code>pip</code> 就会跟踪为什么这个包会被安装</li>
<li>错误信息会非常有用</li>
<li>代码简洁精悍可以很好的编程</li>
<li>不必作为 <code>egg</code> 存档，能扁平化安装(仍然保存 egg 元数据)</li>
<li>原生的支持其他版本控制系统(Git, Mercurial and Bazaar)</li>
<li>加入卸载包功能</li>
<li>可以简单的定义修改一系列的安装依赖，还可以可靠的赋值一系列依赖包</li>
</ul>
<h2 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h2><p>PyPI(Python Package Index) 是 Python 官方维护的第三方包仓库，用于统一存储和管理开发者发布的 Python 包。</p>
<p>如果要发布自己的包，需要先到 <code>pypi</code> 上注册账号。然后创建 <code>~/.pypirc</code> 文件，此文件中配置 <code>PyPI</code> 访问地址和账号。如的<code>.pypirc</code> 文件内容请根据自己的账号来修改。</p>
<p>典型的 <code>.pypirc</code> 文件</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[distutils]</span></span><br><span class="line"><span class="attr">index-servers</span> = pypi</span><br><span class="line"></span><br><span class="line"><span class="section">[pypi]</span></span><br><span class="line">username:xxx</span><br><span class="line">password:xxx</span><br></pre></td></tr></table></figure>

<p>接着注册项目：</p>
<blockquote>
<p>python setup.py register</p>
</blockquote>
<p>该命令在 PyPi 上注册项目信息，成功注册之后，可以在 PyPi 上看到项目信息。最后构建源码包发布即可：</p>
<blockquote>
<p>python setup.py sdist upload</p>
</blockquote>
<h1 id="Python-Packages"><a href="#Python-Packages" class="headerlink" title="Python Packages"></a>Python Packages</h1><p><a href="https://py-pkgs.org/">Python Packages</a> 是一本开源书籍，描述了用于创建 Python 包的现代高效工作流程。</p>
<p>在开始前首先安装下列包：</p>
<ul>
<li><a href="https://github.com/pypa/pipx">pipx</a>：在隔离环境中安装和运行 Python 应用程序。</li>
<li><a href="https://python-poetry.org/">poetry</a> ：将帮助我们构建自己的 Python 包的软件。</li>
<li><a href="https://github.com/cookiecutter/cookiecutter">cookiecutter</a> ：将帮助我们从预制模板创建包的软件。</li>
</ul>
<h2 id="如何实现一个-python-包"><a href="#如何实现一个-python-包" class="headerlink" title="如何实现一个 python 包"></a>如何实现一个 python 包</h2><h3 id="初始化包"><a href="#初始化包" class="headerlink" title="初始化包"></a>初始化包</h3><p>我们将创建一个示例包 <code>pycounts</code> 帮助我们计算文本文件中的字数，使用 <code>cookiecutter</code> 工具为我们创建包结构。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cookiecutter https://github.com/py-pkgs/py-pkgs-cookiecutter.git</span><br><span class="line">author_name [Monty Python]: ckcat</span><br><span class="line">package_name [mypkg]: pycounts</span><br><span class="line">package_short_description [A package <span class="keyword">for</span> doing great things!]: Calculate word counts <span class="keyword">in</span> a text</span><br><span class="line">package_version [0.1.0]:</span><br><span class="line">python_version [3.9]:</span><br><span class="line">Select open_source_license:</span><br><span class="line">1 - MIT</span><br><span class="line">2 - Apache License 2.0</span><br><span class="line">3 - GNU General Public License v3.0</span><br><span class="line">4 - CC0 v1.0 Universal</span><br><span class="line">5 - BSD 3-Clause</span><br><span class="line">6 - Proprietary</span><br><span class="line">7 - None</span><br><span class="line">Choose from 1, 2, 3, 4, 5, 6, 7 [1]:</span><br><span class="line">Select include_github_actions:</span><br><span class="line">1 - no</span><br><span class="line">2 - ci</span><br><span class="line">3 - ci+<span class="built_in">cd</span></span><br><span class="line">Choose from 1, 2, 3 [1]:</span><br></pre></td></tr></table></figure>

<p>根据提示操作完成后，会在当前目录下创建一个名为 <code>pycounts</code> 的新目录，其中包含适合构建功能齐全的 Python 包的内容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pycounts</span><br><span class="line">├── .readthedocs.yml           ┐</span><br><span class="line">├── CHANGELOG.md               │</span><br><span class="line">├── CONDUCT.md                 │</span><br><span class="line">├── CONTRIBUTING.md            │</span><br><span class="line">├── docs                       │</span><br><span class="line">│   ├── changelog.md           │</span><br><span class="line">│   ├── conduct.md             │</span><br><span class="line">│   ├── conf.py                │</span><br><span class="line">│   ├── contributing.md        │ Package documentation</span><br><span class="line">│   ├── example.ipynb          │</span><br><span class="line">│   ├── index.md               │</span><br><span class="line">│   ├── make.bat               │</span><br><span class="line">│   ├── Makefile               │</span><br><span class="line">│   └── requirements.txt       │</span><br><span class="line">├── LICENSE                    │</span><br><span class="line">├── README.md                  ┘</span><br><span class="line">├── pyproject.toml             ┐</span><br><span class="line">├── src                        │</span><br><span class="line">│   └── pycounts               │ Package <span class="built_in">source</span> code, metadata,</span><br><span class="line">│       ├── __init__.py        │ and build instructions</span><br><span class="line">│       └── pycounts.py        ┘</span><br><span class="line">└── tests                      ┐</span><br><span class="line">    └── test_pycounts.py       ┘ Package tests</span><br></pre></td></tr></table></figure>

<p>接着将我们的包设置本地版本控制。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> pycounts\</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> .../python/pycounts/.git/</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m<span class="string">&quot;initial package setup&quot;</span></span><br><span class="line">[master (root-commit) 453ffcc] initial package setup</span><br><span class="line"> 20 files changed, 504 insertions(+)</span><br><span class="line"> create mode 100644 .gitignore</span><br><span class="line"> create mode 100644 .readthedocs.yml</span><br><span class="line"> create mode 100644 CHANGELOG.md</span><br><span class="line"> ...</span><br><span class="line"> create mode 100644 src/pycounts/__init__.py</span><br><span class="line"> create mode 100644 src/pycounts/pycounts.py</span><br><span class="line"> create mode 100644 tests/test_pycounts.py</span><br></pre></td></tr></table></figure>

<h3 id="实现包的功能"><a href="#实现包的功能" class="headerlink" title="实现包的功能"></a>实现包的功能</h3><p>修改 <code>src/pycounts/pycounts.py</code> 文件，内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> punctuation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_text</span>(<span class="params">input_file</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Load text from a text file and return as a string.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        text = file.read()</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_text</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Lowercase and remove punctuation from a string.&quot;&quot;&quot;</span></span><br><span class="line">    text = text.lower()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> punctuation:</span><br><span class="line">        text = text.replace(p, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_words</span>(<span class="params">input_file</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Count unique words in a string.&quot;&quot;&quot;</span></span><br><span class="line">    text = load_text(input_file)</span><br><span class="line">    text = clean_text(text)</span><br><span class="line">    words = text.split()</span><br><span class="line">    <span class="keyword">return</span> Counter(words)</span><br></pre></td></tr></table></figure>

<p>下面我们将使用 <code>poetry</code> 对包进行管理，<code>pyproject.toml </code>文件存储包的所有元数据和安装说明。内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[tool.poetry]</span><br><span class="line">name = <span class="string">&quot;pycounts&quot;</span></span><br><span class="line">version = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line">description = <span class="string">&quot;Calculate word counts in a text&quot;</span></span><br><span class="line">authors = [<span class="string">&quot;ckcat&quot;</span>]</span><br><span class="line">license = <span class="string">&quot;MIT&quot;</span></span><br><span class="line">readme = <span class="string">&quot;README.md&quot;</span></span><br><span class="line"></span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python = <span class="string">&quot;^3.9&quot;</span></span><br><span class="line"></span><br><span class="line">[tool.poetry.dev-dependencies]</span><br><span class="line"></span><br><span class="line">[build-system]</span><br><span class="line">requires = [<span class="string">&quot;poetry-core&gt;=1.0.0&quot;</span>]</span><br><span class="line">build-backend = <span class="string">&quot;poetry.core.masonry.api&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>[tool.poetry]</code> 定义包元数据。包的 name 、 version 、 description 和 authors 是必需的。<br><code>[tool.poetry.dependencies]</code> 标识包的依赖项。<br><code>[tool.poetry.dev-dependencies]</code> 标识包的开发依赖项<br><code>[build-system]</code> 标识构建包所需的构建工具。</p>
<p>可以使用命令 <code>poetry install</code> 安装我们的包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> $ poetry.exe install</span><br><span class="line">Creating virtualenv pycounts-SDM4jxal-py3.9 <span class="keyword">in</span></span><br><span class="line">...\AppData\Local\pypoetry\Cache\virtualenvsvirtualenvs</span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies... (0.1s)</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br><span class="line"></span><br><span class="line">Installing the current project: pycounts (0.1.0)</span><br></pre></td></tr></table></figure>

<p>当运行 <code>poetry install</code> 时， poetry 会创建一个 <code>poetry.lock</code> 文件，其中包含您在开发包时安装的所有依赖项的记录。</p>
<p>接下来添加版本控制。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add src\pycounts\pycounts.py</span><br><span class="line">$ git commit  -m<span class="string">&quot;feat: add word counting functions&quot;</span></span><br><span class="line">[master 510913a] feat: add word counting <span class="built_in">functions</span></span><br><span class="line"> 1 file changed, 23 insertions(+)</span><br></pre></td></tr></table></figure>

<p>其中对 Git 提交消息使用 Angular 风格。</p>
<ul>
<li>build：表示对构建系统或外部依赖项的更改。</li>
<li>docs：表示对文档的更改。</li>
<li>feat：表示添加到代码库的新功能。</li>
<li>fix: indicates a bug fix. “fix”：表示错误修复。</li>
<li>test：表示测试框架的变化。</li>
</ul>
<p>可以使用命令 <code>poetry add</code> 将依赖项添加到包里。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">base) $ poetry add matplotlib</span><br><span class="line">Using version ^3.7.1 <span class="keyword">for</span> matplotlib</span><br><span class="line"></span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies...</span><br><span class="line"></span><br><span class="line">Resolving dependencies... (52.9s)</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br><span class="line"></span><br><span class="line">Package operations: 13 installs, 0 updates, 0 removals</span><br><span class="line"></span><br><span class="line">  • Installing numpy (1.24.3)</span><br><span class="line">  • Installing six (1.16.0)</span><br><span class="line">  • Installing zipp (3.15.0)</span><br><span class="line">  • Installing contourpy (1.0.7)</span><br><span class="line">  • Installing cycler (0.11.0)</span><br><span class="line">  • Installing fonttools (4.39.3)</span><br><span class="line">  • Installing importlib-resources (5.12.0)</span><br><span class="line">  • Installing kiwisolver (1.4.4)</span><br><span class="line">  • Installing packaging (23.1)</span><br><span class="line">  • Installing pillow (9.5.0)</span><br><span class="line">  • Installing pyparsing (3.0.9)</span><br><span class="line">  • Installing python-dateutil (2.8.2)</span><br><span class="line">  • Installing matplotlib (3.7.1)</span><br></pre></td></tr></table></figure>

<p>此命令会将指定的依赖项安装到当前虚拟环境中，并将更新 <code>pyproject.toml</code> 文件的 <code>[tool.poetry.dependencies]</code> 部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python = &quot;^3.9&quot;</span><br><span class="line">matplotlib = &quot;^3.4.3&quot;</span><br></pre></td></tr></table></figure>

<p>然后创建一个名为 <code>src/pycounts/plotting.py</code> 的新模块来容纳我们的绘图函数 <code>plot_words()</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_words</span>(<span class="params">word_counts, n=<span class="number">10</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Plot a bar chart of word counts.&quot;&quot;&quot;</span></span><br><span class="line">    top_n_words = word_counts.most_common(n)</span><br><span class="line">    word, count = <span class="built_in">zip</span>(*top_n_words)</span><br><span class="line">    fig = plt.bar(<span class="built_in">range</span>(n), count)</span><br><span class="line">    plt.xticks(<span class="built_in">range</span>(n), labels=word, rotation=<span class="number">45</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&quot;Word&quot;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&quot;Count&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> fig</span><br></pre></td></tr></table></figure>

<p>接着添加版本控制：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add src\pycounts\plotting.py</span><br><span class="line">$ git commit -m<span class="string">&quot;feat: add plotting module&quot;</span></span><br><span class="line">[master fa9bb17] feat: add plotting module</span><br><span class="line"> 1 file changed, 11 insertions(+)</span><br><span class="line"> create mode 100644 src/pycounts/plotting.py</span><br><span class="line">$ git add pyproject.toml poetry.lock</span><br><span class="line">$ git commit -m<span class="string">&quot;build: add matplotlib as a dependency&quot;</span></span><br><span class="line">[master 6f01657] build: add matplotlib as a dependency</span><br><span class="line"> 2 files changed, 468 insertions(+)</span><br><span class="line"> create mode 100644 poetry.lock</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用命令 <code>poetry add --dev</code> 将它添加为包的开发依赖项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ poetry add --dev pytest</span><br><span class="line">The --dev option is deprecated, use the `--group dev` notation instead.</span><br><span class="line">Using version ^7.3.1 <span class="keyword">for</span> pytest</span><br><span class="line"></span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies... (2.1s)</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br><span class="line"></span><br><span class="line">Package operations: 6 installs, 0 updates, 0 removals</span><br><span class="line"></span><br><span class="line">  • Installing colorama (0.4.6)</span><br><span class="line">  • Installing exceptiongroup (1.1.1)</span><br><span class="line">  • Installing iniconfig (2.0.0)</span><br><span class="line">  • Installing pluggy (1.0.0)</span><br><span class="line">  • Installing tomli (2.0.1)</span><br><span class="line">  • Installing pytest (7.3.1)</span><br></pre></td></tr></table></figure>

<p><code>pytest</code> 将会被添加到 <code>pyproject.toml</code> 文件的 <code>[tool.poetry.dev-dependencies]</code> 部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[tool.poetry.dev-dependencies]</span><br><span class="line">pytest = &quot;^6.2.5&quot;</span><br></pre></td></tr></table></figure>

<p><code>pytest</code> 测试被编写为以 <code>test_</code> 为前缀的函数，其中包含一个或多个检查某些代码功能的 <code>assert</code> 语句。</p>
<p>将单元测试作为测试函数添加到 <code>tests/test_pycounts.py</code> ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pycounts.pycounts <span class="keyword">import</span> count_words</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_count_words</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Test word counting from a file.&quot;&quot;&quot;</span></span><br><span class="line">    expected = Counter(&#123;<span class="string">&#x27;insanity&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;is&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;doing&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                        <span class="string">&#x27;the&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;same&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;thing&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                        <span class="string">&#x27;over&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;and&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;expecting&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                        <span class="string">&#x27;different&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;results&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">    actual = count_words(<span class="string">&quot;tests/einstein.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> actual == expected, <span class="string">&quot;Einstein quote counted incorrectly!&quot;</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>einstein.txt</code> 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Insanity is doing the same thing over and over and expecting different results.</span><br></pre></td></tr></table></figure>

<p>使用 <code>pytest</code> 来运行我们的测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> $ poetry.exe run pytest tests\</span><br><span class="line">============================================ <span class="built_in">test</span> session starts</span><br><span class="line">...</span><br><span class="line">tests\test_pycounts.py .                                                                                [100%]</span><br><span class="line"></span><br><span class="line">============================================= 1 passed <span class="keyword">in</span> 0.05s </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python使用</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA算法原理</title>
    <url>/2024/06/12/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>转载： <a href="https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html">https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html</a></p>
</blockquote>
<p>如果你问我，哪一种算法最重要？</p>
<p>我可能会回答”公钥加密算法”。</p>
<p>因为它是计算机通信安全的基石，保证了加密数据不会被破解。你可以想象一下，信用卡交易被破解的后果。</p>
<p>进入正题之前，我先简单介绍一下，什么是”公钥加密算法”。</p>
<h1 id="一点历史"><a href="#一点历史" class="headerlink" title="一点历史"></a>一点历史</h1><p>1976 年以前，所有的加密方法都是同一种模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）甲方选择某一种加密规则，对信息进行加密；</span><br><span class="line">（2）乙方使用同一种规则，对信息进行解密。</span><br></pre></td></tr></table></figure>

<p>由于加密和解密使用同样规则（简称”密钥”），这被称为”对称加密算法”（Symmetric-key algorithm）。</p>
<p>这种加密模式有一个最大弱点：甲方必须把加密规则告诉乙方，否则无法解密。保存和传递密钥，就成了最头疼的问题。</p>
<p>1976 年，两位美国计算机学家 Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为”Diffie-Hellman 密钥交换算法”。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。</p>
<p>这种新的加密模式被称为”非对称加密算法”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。</span><br><span class="line">（2）甲方获取乙方的公钥，然后用它对信息加密。</span><br><span class="line">（3）乙方得到加密后的信息，用私钥解密。</span><br></pre></td></tr></table></figure>

<p>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</p>
<p>1977 年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做 RSA 算法。从那时直到现在，RSA 算法一直是最广为使用的”非对称加密算法”。毫不夸张地说，只要有计算机网络的地方，就有 RSA 算法。</p>
<p>这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长 RSA 密钥是 768 个二进制位。也就是说，长度超过 768 位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024 位的 RSA 密钥基本安全，2048 位的密钥极其安全。</p>
<p>下面，我就进入正题，解释 RSA 算法的原理。文章共分成两部分，今天是第一部分，介绍要用到的四个数学概念。你可以看到，RSA 算法并不难，只需要一点数论知识就可以理解。</p>
<h1 id="互质关系"><a href="#互质关系" class="headerlink" title="互质关系"></a>互质关系</h1><p>如果两个正整数，除了 1 以外，没有其他公因子，我们就称这两个数是互质关系（coprime）。比如，15 和 32 没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。</p>
<p>关于互质关系，不难得到以下结论：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 任意两个质数构成互质关系，比如 13 和 61。</span><br><span class="line">2. 一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如 3 和 10。</span><br><span class="line">3. 如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如 97 和 57。</span><br><span class="line">4. 1 和任意一个自然数是都是互质关系，比如 1 和 99。</span><br><span class="line">5. p 是大于 1 的整数，则 p 和 p-1 构成互质关系，比如 57 和 56。</span><br><span class="line">6. p 是大于 1 的奇数，则 p 和 p-2 构成互质关系，比如 17 和 15。</span><br></pre></td></tr></table></figure>
<h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><p>请思考以下问题：</p>
<blockquote>
<p>任意给定正整数 n，请问在小于等于 n 的正整数之中，有多少个与 n 构成互质关系？（比如，在 1 到 8 之中，有多少个数与 8 构成互质关系？）</p>
</blockquote>
<p>计算这个值的方法就叫做欧拉函数，以 φ(n)表示。在 1 到 8 之中，与 8 形成互质关系的是 1、3、5、7，所以 φ(n) &#x3D; 4。</p>
<p>φ(n) 的计算方法并不复杂，但是为了得到最后那个公式，需要一步步讨论。</p>
<p><strong>第一种情况</strong></p>
<p>如果 n&#x3D;1，则 φ(1) &#x3D; 1 。因为 1 与任何数（包括自身）都构成互质关系。</p>
<p><strong>第二种情况</strong></p>
<p>如果 n 是质数，则 φ(n)&#x3D;n-1 。因为质数与小于它的每一个数，都构成互质关系。比如 5 与 1、2、3、4 都构成互质关系。</p>
<p><strong>第三种情况</strong></p>
<p>如果 n 是质数的某一个次方，即 n &#x3D; p^k (p 为质数，k 为大于等于 1 的整数)，则</p>
<img src="/2024/06/12/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/2024-06-12-10-21-39.png" class="">

<p>比如 φ(8) &#x3D; φ(2^3) &#x3D;2^3 - 2^2 &#x3D; 8 -4 &#x3D; 4。</p>
<p>这是因为只有当一个数不包含质数 p，才可能与 n 互质。而包含质数 p 的数一共有 p^(k-1)个，即 1×p、2×p、3×p、…、p^(k-1)×p，把它们去除，剩下的就是与 n 互质的数。</p>
<p>上面的式子还可以写成下面的形式：</p>
<img src="/2024/06/12/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/2024-06-12-10-23-11.png" class="">

<p>可以看出，上面的第二种情况是 k&#x3D;1 时的特例。</p>
<p><strong>第四种情况</strong></p>
<p>如果 n 可以分解成两个互质的整数之积，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = p1 × p2</span><br></pre></td></tr></table></figure>

<p>则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">φ(n) = φ(p1p2) = φ(p1)φ(p2)</span><br></pre></td></tr></table></figure>

<p>即积的欧拉函数等于各个因子的欧拉函数之积。比如，φ(56)&#x3D;φ(8×7)&#x3D;φ(8)×φ(7)&#x3D;4×6&#x3D;24。</p>
<p>这一条的证明要用到”中国剩余定理”，这里就不展开了，只简单说一下思路：如果 a 与 p1 互质(a&lt;p1)，b 与 p2 互质(b&lt;p2)，c 与 p1p2 互质(c&lt;p1p2)，则 c 与数对 (a,b) 是一一对应关系。由于 a 的值有 φ(p1) 种可能，b 的值有 φ(p2) 种可能，则数对 (a,b) 有 φ(p1)φ(p2) 种可能，而 c 的值有 φ(p1p2) 种可能，所以 φ(p1p2) 就等于 φ(p1)φ(p2)。</p>
<p><strong>第五种情况</strong></p>
<p>因为任意一个大于 1 的正整数，都可以写成一系列质数的<br>积。</p>
<img src="/2024/06/12/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/2024-06-12-10-23-49.png" class="">

<p>根据第 4 条的结论，得到</p>
<img src="/2024/06/12/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/2024-06-12-10-23-56.png" class="">

<p>再根据第 3 条的结论，得到</p>
<img src="/2024/06/12/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/2024-06-12-10-24-04.png" class="">

<p>也就等于</p>
<img src="/2024/06/12/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/2024-06-12-10-24-10.png" class="">

<p>这就是欧拉函数的通用计算公式。比如，1323 的欧拉函数，计算过程如下：</p>
<img src="/2024/06/12/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/2024-06-12-10-24-18.png" class="">

<h1 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h1><p>欧拉函数的用处，在于欧拉定理。”欧拉定理”指的是：</p>
<blockquote>
<p>如果两个正整数 a 和 n 互质，则 n 的欧拉函数 φ(n) 可以让下面的等式成立：</p>
</blockquote>
<img src="/2024/06/12/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/2024-06-12-10-24-31.png" class="">

<p>也就是说，a 的 φ(n) 次方被 n 除的余数为 1。或者说，a 的 φ(n) 次方减去 1，可以被 n 整除。比如，3 和 7 互质，而 7 的欧拉函数 φ(7) 等于 6，所以 3 的 6 次方（729）减去 1，可以被 7 整除（728&#x2F;7&#x3D;104）。</p>
<p>欧拉定理的证明比较复杂，这里就省略了。我们只要记住它的结论就行了。</p>
<p>欧拉定理可以大大简化某些运算。比如，7 和 10 互质，根据欧拉定理，</p>
<img src="/2024/06/12/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/2024-06-12-10-24-52.png" class="">

<p>已知 φ(10) 等于 4，所以马上得到 7 的 4 倍数次方的个位数肯定是 1。</p>
<img src="/2024/06/12/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/2024-06-12-10-24-59.png" class="">

<p>因此，7 的任意次方的个位数（例如 7 的 222 次方），心算就可以算出来。</p>
<p>欧拉定理有一个特殊情况。</p>
<blockquote>
<p>假设正整数 a 与质数 p 互质，因为质数 p 的 φ(p)等于 p-1，则欧拉定理可以写成</p>
</blockquote>
<img src="/2024/06/12/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/2024-06-12-10-25-09.png" class="">

<p>这就是著名的费马小定理。它是欧拉定理的特例。</p>
<p>欧拉定理是 RSA 算法的核心。理解了这个定理，就可以理解 RSA。</p>
<h1 id="模反元素"><a href="#模反元素" class="headerlink" title="模反元素"></a>模反元素</h1><p>还剩下最后一个概念：</p>
<blockquote>
<p>如果两个正整数 a 和 n 互质，那么一定可以找到整数 b，使得 ab-1 被 n 整除，或者说 ab 被 n 除的余数是 1。</p>
</blockquote>
<img src="/2024/06/12/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/2024-06-12-10-25-24.png" class="">

<blockquote>
<p>这时，b 就叫做 a 的”模反元素”。</p>
</blockquote>
<p>比如，3 和 11 互质，那么 3 的模反元素就是 4，因为 (3 × 4)-1 可以被 11 整除。显然，模反元素不止一个， 4 加减 11 的整数倍都是 3 的模反元素 {…,-18,-7,4,15,26,…}，即如果 b 是 a 的模反元素，则 b+kn 都是 a 的模反元素。</p>
<p>欧拉定理可以用来证明模反元素必然存在。</p>
<img src="/2024/06/12/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/2024-06-12-10-25-49.png" class="">

<p>可以看到，a 的 φ(n)-1 次方，就是 a 的模反元素。</p>
<hr>
<p>好了，需要用到的数学工具，全部介绍完了。RSA 算法涉及的数学知识，就是上面这些，下一次我就来介绍公钥和私钥到底是怎么生成的。</p>
<p>有了这些知识，我们就可以看懂 RSA 算法。这是目前地球上最重要的加密算法。</p>
<h1 id="密钥生成的步骤"><a href="#密钥生成的步骤" class="headerlink" title="密钥生成的步骤"></a>密钥生成的步骤</h1><p>我们通过一个例子，来理解 RSA 算法。假设爱丽丝要与鲍勃进行加密通信，她该怎么生成公钥和私钥呢？</p>
<img src="/2024/06/12/RSA%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/2024-06-12-10-34-45.png" class="">

<p><strong>第一步，随机选择两个不相等的质数 p 和 q。</strong></p>
<p>爱丽丝选择了 61 和 53。（实际应用中，这两个质数越大，就越难破解。）</p>
<p><strong>第二步，计算 p 和 q 的乘积 n。</strong></p>
<p>爱丽丝就把 61 和 53 相乘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = 61×53 = 3233</span><br></pre></td></tr></table></figure>

<p>n 的长度就是密钥长度。3233 写成二进制是 110010100001，一共有 12 位，所以这个密钥就是 12 位。实际应用中，RSA 密钥一般是 1024 位，重要场合则为 2048 位。</p>
<p><strong>第三步，计算 n 的欧拉函数 φ(n)。</strong></p>
<p>根据公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">φ(n) = (p-1)(q-1)</span><br></pre></td></tr></table></figure>

<p>爱丽丝算出 φ(3233)等于 60×52，即 3120。</p>
<p><strong>第四步，随机选择一个整数 e，条件是 1&lt; e &lt; φ(n)，且 e 与 φ(n) 互质。</strong></p>
<p>爱丽丝就在 1 到 3120 之间，随机选择了 17。（实际应用中，常常选择 65537。）</p>
<p><strong>第五步，计算 e 对于 φ(n)的模反元素 d。</strong></p>
<p>所谓”模反元素”就是指有一个整数 d，可以使得 ed 被 φ(n)除的余数为 1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ed ≡ 1 (mod φ(n))</span><br></pre></td></tr></table></figure>

<p>这个式子等价于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ed - 1 = kφ(n)</span><br></pre></td></tr></table></figure>

<p>于是，找到模反元素 d，实质上就是对下面这个二元一次方程求解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ex + φ(n)y = 1</span><br></pre></td></tr></table></figure>

<p>已知 e&#x3D;17, φ(n)&#x3D;3120，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17x + 3120y = 1</span><br></pre></td></tr></table></figure>

<p>这个方程可以用”扩展欧几里得算法”求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (x,y)&#x3D;(2753,-15)，即 d&#x3D;2753。</p>
<p>至此所有计算完成。</p>
<p><strong>第六步，将 n 和 e 封装成公钥，n 和 d 封装成私钥。</strong></p>
<p>在爱丽丝的例子中，n&#x3D;3233，e&#x3D;17，d&#x3D;2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。</p>
<p>实际应用中，公钥和私钥的数据都采用 ASN.1 格式表达（实例）。</p>
<h1 id="RSA-算法的可靠性"><a href="#RSA-算法的可靠性" class="headerlink" title="RSA 算法的可靠性"></a>RSA 算法的可靠性</h1><p>回顾上面的密钥生成步骤，一共出现六个数字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　p</span><br><span class="line">　　q</span><br><span class="line">　　n</span><br><span class="line">　　φ(n)</span><br><span class="line">　　e</span><br><span class="line">　　d</span><br></pre></td></tr></table></figure>

<p>这六个数字之中，公钥用到了两个（n 和 e），其余四个数字都是不公开的。其中最关键的是 d，因为 n 和 d 组成了私钥，一旦 d 泄漏，就等于私钥泄漏。</p>
<p><strong>那么，有无可能在已知 n 和 e 的情况下，推导出 d？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）ed≡1 (mod φ(n))。只有知道 e 和 φ(n)，才能算出 d。</span><br><span class="line"></span><br><span class="line">（2）φ(n)=(p-1)(q-1)。只有知道 p 和 q，才能算出 φ(n)。</span><br><span class="line"></span><br><span class="line">（3）n=pq。只有将 n 因数分解，才能算出 p 和 q。</span><br></pre></td></tr></table></figure>

<p><strong>结论：如果 n 可以被因数分解，d 就可以算出，也就意味着私钥被破解。</strong></p>
<p>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。维基百科这样写道：</p>
<blockquote>
<p>“对极大整数做因数分解的难度决定了 RSA 算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。</p>
</blockquote>
<blockquote>
<p>假如有人找到一种快速因数分解的算法，那么 RSA 的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的 RSA 密钥才可能被暴力破解。到 2008 年为止，世界上还没有任何可靠的攻击 RSA 算法的方式。</p>
</blockquote>
<blockquote>
<p>只要密钥长度足够长，用 RSA 加密的信息实际上是不能被解破的。”</p>
</blockquote>
<p>举例来说，你可以对 3233 进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">　　12301866845301177551304949</span><br><span class="line">　　58384962720772853569595334</span><br><span class="line">　　79219732245215172640050726</span><br><span class="line">　　36575187452021997864693899</span><br><span class="line">　　56474942774063845925192557</span><br><span class="line">　　32630345373154826850791702</span><br><span class="line">　　61221429134616704292143116</span><br><span class="line">　　02221240479274737794080665</span><br><span class="line">　　351419597459856902143413</span><br></pre></td></tr></table></figure>

<p>它等于这样两个质数的乘积：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">　　33478071698956898786044169</span><br><span class="line">　　84821269081770479498371376</span><br><span class="line">　　85689124313889828837938780</span><br><span class="line">　　02287614711652531743087737</span><br><span class="line">　　814467999489</span><br><span class="line">　　　　×</span><br><span class="line">　　36746043666799590428244633</span><br><span class="line">　　79962795263227915816434308</span><br><span class="line">　　76426760322838157396665112</span><br><span class="line">　　79233373417143396810270092</span><br><span class="line">　　798736308917</span><br></pre></td></tr></table></figure>

<p>事实上，这大概是人类已经分解的最大整数（232 个十进制位，768 个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长 RSA 密钥就是 768 位。</p>
<h1 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h1><p>有了公钥和密钥，就能进行加密和解密了。</p>
<p><strong>（1）加密要用公钥 (n,e)</strong></p>
<p>假设鲍勃要向爱丽丝发送加密信息 m，他就要用爱丽丝的公钥 (n,e) 对 m 进行加密。这里需要注意，m 必须是整数（字符串可以取 ascii 值或 unicode 值），且 m 必须小于 n。</p>
<p>所谓”加密”，就是算出下式的 c：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">me ≡ c (mod n)</span><br></pre></td></tr></table></figure>

<p>爱丽丝的公钥是 (3233, 17)，鲍勃的 m 假设是 65，那么可以算出下面的等式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6517 ≡ 2790 (mod 3233)</span><br></pre></td></tr></table></figure>

<p>于是，c 等于 2790，鲍勃就把 2790 发给了爱丽丝。</p>
<p><strong>（2）解密要用私钥(n,d)</strong></p>
<p>爱丽丝拿到鲍勃发来的 2790 以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ≡ m (mod n)</span><br></pre></td></tr></table></figure>

<p>也就是说，c 的 d 次方除以 n 的余数为 m。现在，c 等于 2790，私钥是(3233, 2753)，那么，爱丽丝算出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">27902753 ≡ 65 (mod 3233)</span><br></pre></td></tr></table></figure>

<p>因此，爱丽丝知道了鲍勃加密前的原文就是 65。</p>
<p>至此，”加密–解密”的整个过程全部完成。</p>
<p>我们可以看到，如果不知道 d，就没有办法从 c 求出 m。而前面已经说过，要知道 d 就必须分解 n，这是极难做到的，所以 RSA 算法保证了通信安全。</p>
<p>你可能会问，公钥(n,e) 只能加密小于 n 的整数 m，那么如果要加密大于 n 的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种”对称性加密算法”（比如 DES），用这种算法的密钥加密信息，再用 RSA 公钥加密 DES 密钥。</p>
<h1 id="私钥解密的证明"><a href="#私钥解密的证明" class="headerlink" title="私钥解密的证明"></a>私钥解密的证明</h1><p>最后，我们来证明，为什么用私钥解密，一定可以正确地得到 m。也就是证明下面这个式子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ≡ m (mod n)</span><br></pre></td></tr></table></figure>

<p>因为，根据加密规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ｍe ≡ c (mod n)</span><br></pre></td></tr></table></figure>

<p>于是，c 可以写成下面的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c = me - kn</span><br></pre></td></tr></table></figure>

<p>将 c 代入要我们要证明的那个解密规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(me - kn)d ≡ m (mod n)</span><br></pre></td></tr></table></figure>

<p>它等同于求证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">med ≡ m (mod n)</span><br></pre></td></tr></table></figure>

<p>由于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ed ≡ 1 (mod φ(n))</span><br></pre></td></tr></table></figure>

<p>所以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ed = hφ(n)+1</span><br></pre></td></tr></table></figure>

<p>将 ed 代入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mhφ(n)+1 ≡ m (mod n)</span><br></pre></td></tr></table></figure>

<p>接下来，分成两种情况证明上面这个式子。</p>
<p><strong>（1）m 与 n 互质。</strong></p>
<p>根据欧拉定理，此时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mφ(n) ≡ 1 (mod n)</span><br></pre></td></tr></table></figure>

<p>得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(mφ(n))h × m ≡ m (mod n)</span><br></pre></td></tr></table></figure>

<p>原式得到证明。</p>
<p><strong>（2）m 与 n 不是互质关系。</strong></p>
<p>此时，由于 n 等于质数 p 和 q 的乘积，所以 m 必然等于 kp 或 kq。</p>
<p>以 m &#x3D; kp 为例，考虑到这时 k 与 q 必然互质，则根据欧拉定理，下面的式子成立：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(kp)q-1 ≡ 1 (mod q)</span><br></pre></td></tr></table></figure>

<p>进一步得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[(kp)q-1]h(p-1) × kp ≡ kp (mod q)</span><br></pre></td></tr></table></figure>

<p>即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(kp)ed ≡ kp (mod q)</span><br></pre></td></tr></table></figure>

<p>将它改写成下面的等式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(kp)ed = tq + kp</span><br></pre></td></tr></table></figure>

<p>这时 t 必然能被 p 整除，即 t&#x3D;t’p</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(kp)ed = t&#x27;pq + kp</span><br></pre></td></tr></table></figure>

<p>因为 m&#x3D;kp，n&#x3D;pq，所以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">med ≡ m (mod n)</span><br></pre></td></tr></table></figure>

<p>原式得到证明。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>UEFI模式Windows10上安装Ubuntu 18.04.1 LTS双系统</title>
    <url>/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://www.mzihen.com/how-to-install-ubuntu-18-04-lts-with-windows-10-on-uefi/">https://www.mzihen.com/how-to-install-ubuntu-18-04-lts-with-windows-10-on-uefi/</a></p>
</blockquote>
<!-- TOC -->

<ul>
<li><a href="#%E4%B8%80%E5%88%B6%E4%BD%9C%E6%94%AF%E6%8C%81uefi%E5%90%AF%E5%8A%A8%E7%9A%84ubuntu-usb%E5%90%AF%E5%8A%A8%E7%9B%98">一、制作支持UEFI启动的Ubuntu USB启动盘</a></li>
<li><a href="#%E4%BA%8Cwindows10%E4%B8%AD%E7%9A%84%E8%AE%BE%E7%BD%AE">二、Windows10中的设置</a></li>
<li><a href="#%E4%B8%89%E5%88%86%E5%8C%BA">三、分区</a></li>
<li><a href="#%E5%9B%9B%E5%AE%89%E8%A3%85ubuntu%E7%B3%BB%E7%BB%9F">四、安装Ubuntu系统</a></li>
<li><a href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">存在的问题。</a></li>
</ul>
<!-- /TOC -->
<h1 id="一、制作支持UEFI启动的Ubuntu-USB启动盘"><a href="#一、制作支持UEFI启动的Ubuntu-USB启动盘" class="headerlink" title="一、制作支持UEFI启动的Ubuntu USB启动盘"></a>一、制作支持UEFI启动的Ubuntu USB启动盘</h1><p>我使用了开源软件Rufus（<a href="https://rufus.akeo.ie/?locale=zh_CN">Rufus官网</a>）创建的USB启动盘，Ubuntu使用了最新版的Ubuntu 18.04.1 LTS（<a href="https://www.ubuntu.com/download/desktop">ubuntu官网</a>）。</p>
<p>现有台式机是SSD硬盘加机械硬盘，win10系统安装在SSD硬盘，SSD是MBR分区的，机械硬盘是GPT分区，主板使用的UEFI启动模式。因为要将Ubuntu安装在机械硬盘上，所以制作启动盘选择的 <strong>分区类型选择GPT，目标系统类型选择UEFI(非CSM)</strong> ，其它都按照我设置的即可，如下图。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-42-00.png" class="">

<p>需要注意的是，建议使用新版本的Ubuntu，因为低版本的Ubuntu不支持UEFI+GPT，比如Ubuntu16.04 386（32bit），而Ubuntu 18.04版本是64位的，支持UEFI+GPT。</p>
<h1 id="二、Windows10中的设置"><a href="#二、Windows10中的设置" class="headerlink" title="二、Windows10中的设置"></a>二、Windows10中的设置</h1><p>在“控制面板\硬件和声音\电源选项\系统设置”去掉勾选“启用快速启动（推荐）”</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-45-27.png" class="">

<p>取消”启用快速启动(推荐)”的原因是： “快速启动”是Windows8时代引进的新特性，“快速启动”会影响Grub开机引导过程，可能出现无法载入Ubuntu的状况，最后选择“保存修改”。（<a href="https://www.jianshu.com/p/0ccf1778d8ae">点击浏览更多…</a>）</p>
<p>另外还要禁用主板上的“安全启动（Secure Boot）”，而我的主板B150-Plus安全启动是默认勾选且灰色不可修改的，便没有更改此项。但是可以选择Windows系统或者其它操作系统。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-46-16.png" class="">

<h1 id="三、分区"><a href="#三、分区" class="headerlink" title="三、分区"></a>三、分区</h1><p>准备工作：备份好数据。<br>使用软件DiskGenius（<a href="http://www.diskgenius.cn/">官网</a>）将机械硬盘第一个分区压缩出80G空闲区出来，网上有说30G就够了，具体看硬盘容量情况。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-47-09.png" class="">

<h1 id="四、安装Ubuntu系统"><a href="#四、安装Ubuntu系统" class="headerlink" title="四、安装Ubuntu系统"></a>四、安装Ubuntu系统</h1><p>进入BIOS，设置boot启动选项，选择从U盘启动，或者第一启动盘为U盘，保存并退出。<br>进入Ubuntu安装界面，有提示试用还是安装。我先进入了试用界面，然后在试用界面里选择的安装。</p>
<p>选择好语言，点击继续。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-47-43.png" class="">

<p>选择好键盘布局，点击继续。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-48-11.png" class="">

<p>这里选择“正常安装”，在其他选项中，如果网络不好或者想安装速度快一些，不勾选“安装 Ubuntu时下载更新”。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-48-42.png" class="">

<p>因为是安装到指定盘里，并不是全新安装，也不希望清除掉硬盘里其它分区的数据，所以这里选择“其他选项”。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-51-09.png" class="">

<p>选择“其他选项”后，开始给硬盘进行分区。跟安装Windows类似，Windows会自动分成几个隐藏的区：450 MB恢复分区、100 MB系统分区和16 MB的MSR (保留)分区，Ubuntu略微不同，需要手动划分。</p>
<p>一般Linux设置4个分区：</p>
<blockquote>
<p>&#x2F; ：根分区，一般分8G就可以，如果磁盘空间足够，10G~16G也可以，甚至有人分了30G，这里最好选择30G。</p>
</blockquote>
<blockquote>
<p>swap ：交换空间，即虚拟内存，建议是你机器的物理内存小于1G的话虚拟内存设置为物理内存的2倍；如果物理内存大于1G，建议在物理内存的基础上加2G，最大不要超过两倍。我的物理内存是16g，只要20g足矣。因磁盘空间又够，所以分了32G。</p>
</blockquote>
<blockquote>
<p>&#x2F;boot ：启动分区，系统的启动文件，大小一般分200M。</p>
</blockquote>
<blockquote>
<p><del>efi ：EFI系统分区，系统的启动文件，大小一般分200M。</del></p>
</blockquote>
<blockquote>
<p>&#x2F;home ：home目录，文件分区，存放个人文件，分完其他所有区之后，剩下的空间全部给它即可。</p>
</blockquote>
<p>我第一次设置了&#x2F;boot分区而不是设置的efi分区，出现了错误：</p>
<blockquote>
<blockquote>
<p>在复制系统文件的时候出现了“无法将 grub-efi-amd64-signed 软件包安装到 &#x2F;target&#x2F;中。如果没有 GRUB 启动引导器，所安装的系统将无法启动。”</p>
</blockquote>
</blockquote>
<p>重新安装了两次出现一样的错误结果。参考<a href="https://www.zhihu.com/question/36811339">知乎上这个答案后</a>，使用eif系统分区取代了boot分区，最后安装成功。后面截图有出现错误的地方</p>
<p>选择125G的空闲区（前文分了80G的空闲区，再加上其它的空闲区，有了125G多点），点击下面“+”号，添加&#x2F;分区，依次选择 大小10240MB（10GB）、主分区、空间起始位置，Ext4日志文件系统、挂载点&#x2F;，然后点击OK。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-56-30.png" class="">

<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-57-03.png" class="">

<p>继续点击“+”号，添加swap分区（交换分区），大小填32768MB（32G），（如果你的物理内存是16G，建议此处填写20480MB（20G）），逻辑分区，空间起始位置，交换空间，点击OK。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-57-37.png" class="">

<p>点击“+”号，添加EFI系统分区，大小200MB，逻辑分区，空间起始位置，EFI系统分区，点击OK。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-58-00.png" class="">

<p>点击“+”号，添加&#x2F;home分区，大小直接默认，也就是剩余的所有空间，逻辑分区，空间起始位置，挂载点选择&#x2F;home，点击OK。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-58-27.png" class="">

<p>注意最下面的“安装启动引导器的设备”，要选择跟efi一致，选择好后点击现在安装。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-58-57.png" class="">

<p>接下来就提示哪些分区被会操作。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-59-17.png" class="">

<p>你在什么地方，选择shanghai，也可依据自己需要选择其它地区。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-59-35.png" class="">

<p>填写用户名和密码。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-59-58.png" class="">

<p>接下来就静静等待安装即可。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-11-00-21.png" class="">

<p>下面一个截图是特地截取的，前几次安装都是失败在此处。前面有错误说明</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-11-01-00.png" class="">

<p>安装成功。因为在试用界面安装的Ubuntu，所以会提示继续试用，还是重启。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-11-01-26.png" class="">

<p>重启，按住del键进入BIOS，将Ubuntu系统所在的硬盘拖到第一位，保存并退出，就会进入Ubuntu系统。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-11-01-54.png" class="">

<p>删掉分区，只设置了EFI系统分区，系统完全可以安装，且Windows10可见4个区分。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-11-02-17.png" class="">


<h1 id="存在的问题。"><a href="#存在的问题。" class="headerlink" title="存在的问题。"></a>存在的问题。</h1><p>1、Ubuntu 18.04.1 LTS下建 &#x2F;boot 和 分区是无效的，需要建EFI系统分区。</p>
<p>2、有人将启动引导向设置在wi10的启动引导分区里，而我是单独建了一个引导分区，导致的结果就是开机直接进入系统，如果要切换Window10系统，需要到BIOS里切换。</p>
<p>3、进入系统后经常死机，可能跟显卡驱动有关，可以去更新显卡驱动，选择（tested)。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 18.4使用docker配置TensorFlow GPU环境</title>
    <url>/2019/11/09/Ubuntu-18-4%E4%BD%BF%E7%94%A8docker%E9%85%8D%E7%BD%AETensorFlow-GPU%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E4%B8%80%E5%AE%89%E8%A3%85nvidia%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8">一、安装nvidia显卡驱动</a><ul>
<li><a href="#1-%E9%A6%96%E5%85%88%E5%B0%86ppagraphics-driversppa%E5%AD%98%E5%82%A8%E5%BA%93%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%82%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD">1. 首先，将ppa:graphics-drivers&#x2F;ppa存储库添加到您的系统中：</a></li>
<li><a href="#2-%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%A1%AE%E5%AE%9A%E6%82%A8%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%8D%A1%E5%9E%8B%E5%8F%B7%E5%92%8C%E6%8E%A8%E8%8D%90%E7%9A%84%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F">2. 接下来，确定您的图形卡型号和推荐的驱动程序：</a></li>
<li><a href="#3-%E4%B8%8E%E4%B8%8A%E9%9D%A2%E7%9A%84%E6%A0%87%E5%87%86ubuntu%E5%AD%98%E5%82%A8%E5%BA%93%E7%A4%BA%E4%BE%8B%E7%9B%B8%E5%90%8C%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85%E6%89%80%E6%9C%89%E6%8E%A8%E8%8D%90%E7%9A%84%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F">3. 与上面的标准Ubuntu存储库示例相同，可以自动安装所有推荐的驱动程序：</a></li>
<li><a href="#4-%E5%AE%8C%E6%88%90%E5%90%8E%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8%E7%B3%BB%E7%BB%9F">4. 完成后，重新启动系统。</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%AE%89%E8%A3%85docker">二、安装docker</a><ul>
<li><a href="#1-%E8%AE%BE%E7%BD%AEdocker%E5%AD%98%E5%82%A8%E5%BA%93">1. 设置Docker存储库</a><ul>
<li><a href="#1-%E6%9B%B4%E6%96%B0apt%E5%8C%85%E7%B4%A2%E5%BC%95">1. 更新apt包索引：</a></li>
<li><a href="#2-%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85%E4%BB%A5%E5%85%81%E8%AE%B8apt%E9%80%9A%E8%BF%87https%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E5%BA%93">2. 安装软件包以允许apt通过HTTPS使用存储库：</a></li>
<li><a href="#3-%E6%B7%BB%E5%8A%A0docker%E7%9A%84%E5%AE%98%E6%96%B9gpg%E5%AF%86%E9%92%A5">3. 添加Docker的官方GPG密钥：</a></li>
<li><a href="#4-%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8B%E5%91%BD%E4%BB%A4%E6%9D%A5%E8%AE%BE%E7%BD%AE%E7%A8%B3%E5%AE%9A%E7%9A%84%E5%AD%98%E5%82%A8%E5%BA%93">4. 使用以下命令来设置稳定的存储库。</a></li>
</ul>
</li>
<li><a href="#2-%E5%AE%89%E8%A3%85docker-engine-%E7%A4%BE%E5%8C%BA">2. 安装DOCKER ENGINE-社区</a><ul>
<li><a href="#1-%E6%9B%B4%E6%96%B0apt%E5%8C%85%E7%B4%A2%E5%BC%95-1">1. 更新apt包索引。</a></li>
<li><a href="#2-%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84docker-engine-community%E5%92%8Ccontainerd%E6%88%96%E8%80%85%E8%BD%AC%E5%88%B0%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%AE%89%E8%A3%85%E7%89%B9%E5%AE%9A%E7%89%88%E6%9C%AC">2. 安装最新版本的Docker Engine-Community和containerd，或者转到下一步安装特定版本：</a></li>
<li><a href="#3-%E8%A6%81%E5%AE%89%E8%A3%85%E7%89%B9%E5%AE%9A%E7%89%88%E6%9C%AC%E7%9A%84docker-engine-community%E8%AF%B7%E5%9C%A8%E5%AD%98%E5%82%A8%E5%BA%93%E4%B8%AD%E5%88%97%E5%87%BA%E5%8F%AF%E7%94%A8%E7%89%88%E6%9C%AC%E7%84%B6%E5%90%8E%E9%80%89%E6%8B%A9%E5%B9%B6%E5%AE%89%E8%A3%85">3. 要安装特定版本的Docker Engine-Community，请在存储库中列出可用版本，然后选择并安装：</a></li>
<li><a href="#4-%E9%80%9A%E8%BF%87%E8%BF%90%E8%A1%8Chello-world-%E6%98%A0%E5%83%8F%E6%9D%A5%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE%E5%AE%89%E8%A3%85%E4%BA%86docker-engine-community-">4. 通过运行hello-world 映像来验证是否正确安装了Docker Engine-Community 。</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89nvidia-docker%E5%92%8Cnvidia-container-runtime%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE">三、<code>nvidia-docker</code>和<code>nvidia-container-runtime</code>安装和配置</a><ul>
<li><a href="#1-%E5%AE%89%E8%A3%85nvidia-docker-">1. 安装<code>nvidia-docker</code> 。</a></li>
<li><a href="#2-%E5%AE%89%E8%A3%85nvidia-container-runtime">2. 安装nvidia-container-runtime</a></li>
<li><a href="#3-docker%E5%BC%95%E6%93%8E%E9%85%8D%E7%BD%AE">3. Docker引擎配置</a><ul>
<li><a href="#1-systemd-drop-in-file">1. Systemd drop-in file</a></li>
<li><a href="#2-daemon-configuration-file">2. Daemon configuration file</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E9%85%8D%E7%BD%AEtensorflow">四、配置tensorflow</a><ul>
<li><a href="#1-%E9%AA%8C%E8%AF%81-nvidia-docker-%E5%AE%89%E8%A3%85">1. 验证 nvidia-docker 安装</a></li>
<li><a href="#2-%E4%B8%8B%E8%BD%BD%E5%B9%B6%E8%BF%90%E8%A1%8C%E6%94%AF%E6%8C%81-gpu-%E7%9A%84-tensorflow-%E6%98%A0%E5%83%8F">2. 下载并运行支持 <code>GPU</code> 的 <code>TensorFlow</code> 映像</a><ul>
<li><a href="#1-%E4%B8%8B%E8%BD%BD%E6%94%AF%E6%8C%81-gpu-%E7%9A%84-tensorflow-%E6%98%A0%E5%83%8F">1. 下载支持 <code>GPU</code> 的 <code>TensorFlow</code> 映像</a></li>
<li><a href="#2-%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95">2. 环境测试</a></li>
<li><a href="#3-%E4%BD%BF%E7%94%A8%E6%9C%80%E6%96%B0%E7%9A%84-tensorflow-gpu-%E6%98%A0%E5%83%8F%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%90%AF%E5%8A%A8-bash-shell-%E4%BC%9A%E8%AF%9D">3. 使用最新的 TensorFlow GPU 映像在容器中启动 bash shell 会话</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%94%E9%80%9A%E8%BF%87%E8%BD%AF%E9%93%BE%E6%8E%A5%E4%BF%AE%E6%94%B9docker%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE">五、通过软链接修改Docker配置本地镜像与容器的存储位置</a></li>
<li><a href="#%E5%85%AD%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E8%BF%90%E8%A1%8Cdocker">六、使用非root用户运行docker</a></li>
</ul>
<!-- /TOC -->
<h1 id="一、安装nvidia显卡驱动"><a href="#一、安装nvidia显卡驱动" class="headerlink" title="一、安装nvidia显卡驱动"></a>一、安装nvidia显卡驱动</h1><h2 id="1-首先，将ppa-graphics-drivers-x2F-ppa存储库添加到您的系统中："><a href="#1-首先，将ppa-graphics-drivers-x2F-ppa存储库添加到您的系统中：" class="headerlink" title="1. 首先，将ppa:graphics-drivers&#x2F;ppa存储库添加到您的系统中："></a>1. 首先，将ppa:graphics-drivers&#x2F;ppa存储库添加到您的系统中：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure>

<h2 id="2-接下来，确定您的图形卡型号和推荐的驱动程序："><a href="#2-接下来，确定您的图形卡型号和推荐的驱动程序：" class="headerlink" title="2. 接下来，确定您的图形卡型号和推荐的驱动程序："></a>2. 接下来，确定您的图形卡型号和推荐的驱动程序：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ubuntu-drivers devices</span><br><span class="line">== /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0 ==</span><br><span class="line">modalias : pci:v000010DEd00001C8Csv00001558sd000055A1bc03sc00i00</span><br><span class="line">vendor   : NVIDIA Corporation</span><br><span class="line">model    : GP107M [GeForce GTX 1050 Ti Mobile]</span><br><span class="line">driver   : nvidia-driver-415 - third-party free</span><br><span class="line">driver   : nvidia-driver-390 - third-party free</span><br><span class="line">driver   : nvidia-driver-440 - third-party free recommended</span><br><span class="line">driver   : nvidia-driver-430 - distro non-free</span><br><span class="line">driver   : nvidia-driver-410 - third-party free</span><br><span class="line">driver   : nvidia-driver-435 - distro non-free</span><br><span class="line">driver   : xserver-xorg-video-nouveau - distro free <span class="built_in">builtin</span></span><br></pre></td></tr></table></figure>

<h2 id="3-与上面的标准Ubuntu存储库示例相同，可以自动安装所有推荐的驱动程序："><a href="#3-与上面的标准Ubuntu存储库示例相同，可以自动安装所有推荐的驱动程序：" class="headerlink" title="3. 与上面的标准Ubuntu存储库示例相同，可以自动安装所有推荐的驱动程序："></a>3. 与上面的标准Ubuntu存储库示例相同，可以自动安装所有推荐的驱动程序：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo ubuntu-drivers autoinstall</span><br></pre></td></tr></table></figure>
<p>或选择性地使用<code>apt</code>命令。例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install nvidia-410</span><br></pre></td></tr></table></figure>
<h2 id="4-完成后，重新启动系统。"><a href="#4-完成后，重新启动系统。" class="headerlink" title="4. 完成后，重新启动系统。"></a>4. 完成后，重新启动系统。</h2><p>使用<code>nvidia-smi</code>查看显卡信息：</p>
<img src="/2019/11/09/Ubuntu-18-4%E4%BD%BF%E7%94%A8docker%E9%85%8D%E7%BD%AETensorFlow-GPU%E7%8E%AF%E5%A2%83/2019-11-09-17-06-46.png" class="">

<blockquote>
<p>参考连接：<a href="https://linuxconfig.org/how-to-install-the-nvidia-drivers-on-ubuntu-18-04-bionic-beaver-linux">https://linuxconfig.org/how-to-install-the-nvidia-drivers-on-ubuntu-18-04-bionic-beaver-linux</a></p>
</blockquote>
<h1 id="二、安装docker"><a href="#二、安装docker" class="headerlink" title="二、安装docker"></a>二、安装docker</h1><h2 id="1-设置Docker存储库"><a href="#1-设置Docker存储库" class="headerlink" title="1. 设置Docker存储库"></a>1. 设置Docker存储库</h2><h3 id="1-更新apt包索引："><a href="#1-更新apt包索引：" class="headerlink" title="1. 更新apt包索引："></a>1. 更新apt包索引：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>

<h3 id="2-安装软件包以允许apt通过HTTPS使用存储库："><a href="#2-安装软件包以允许apt通过HTTPS使用存储库：" class="headerlink" title="2. 安装软件包以允许apt通过HTTPS使用存储库："></a>2. 安装软件包以允许apt通过HTTPS使用存储库：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure>

<h3 id="3-添加Docker的官方GPG密钥："><a href="#3-添加Docker的官方GPG密钥：" class="headerlink" title="3. 添加Docker的官方GPG密钥："></a>3. 添加Docker的官方GPG密钥：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p>通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥 <code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">    </span><br><span class="line">pub   rsa4096 2017-02-22 [SCEA]</span><br><span class="line">      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   rsa4096 2017-02-22 [S]</span><br></pre></td></tr></table></figure>

<h3 id="4-使用以下命令来设置稳定的存储库。"><a href="#4-使用以下命令来设置稳定的存储库。" class="headerlink" title="4. 使用以下命令来设置稳定的存储库。"></a>4. 使用以下命令来设置稳定的存储库。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure>

<h2 id="2-安装DOCKER-ENGINE-社区"><a href="#2-安装DOCKER-ENGINE-社区" class="headerlink" title="2. 安装DOCKER ENGINE-社区"></a>2. 安装DOCKER ENGINE-社区</h2><h3 id="1-更新apt包索引。"><a href="#1-更新apt包索引。" class="headerlink" title="1. 更新apt包索引。"></a>1. 更新apt包索引。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>

<h3 id="2-安装最新版本的Docker-Engine-Community和containerd，或者转到下一步安装特定版本："><a href="#2-安装最新版本的Docker-Engine-Community和containerd，或者转到下一步安装特定版本：" class="headerlink" title="2. 安装最新版本的Docker Engine-Community和containerd，或者转到下一步安装特定版本："></a>2. 安装最新版本的Docker Engine-Community和containerd，或者转到下一步安装特定版本：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<h3 id="3-要安装特定版本的Docker-Engine-Community，请在存储库中列出可用版本，然后选择并安装："><a href="#3-要安装特定版本的Docker-Engine-Community，请在存储库中列出可用版本，然后选择并安装：" class="headerlink" title="3. 要安装特定版本的Docker Engine-Community，请在存储库中列出可用版本，然后选择并安装："></a>3. 要安装特定版本的Docker Engine-Community，请在存储库中列出可用版本，然后选择并安装：</h3><ul>
<li><p>列出您的仓库中可用的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br><span class="line"></span><br><span class="line">  docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  docker-ce | 18.06.1~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  docker-ce | 18.06.0~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用第二列中的版本字符串安装特定版本，例如<code>5:18.09.1~3-0~ubuntu-xenial</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-通过运行hello-world-映像来验证是否正确安装了Docker-Engine-Community-。"><a href="#4-通过运行hello-world-映像来验证是否正确安装了Docker-Engine-Community-。" class="headerlink" title="4. 通过运行hello-world 映像来验证是否正确安装了Docker Engine-Community 。"></a>4. 通过运行hello-world 映像来验证是否正确安装了Docker Engine-Community 。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<p>此命令下载测试镜像并在容器中运行。容器运行时，它会打印参考消息并退出。</p>
<blockquote>
<p>参考：<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></p>
</blockquote>
<h1 id="三、nvidia-docker和nvidia-container-runtime安装和配置"><a href="#三、nvidia-docker和nvidia-container-runtime安装和配置" class="headerlink" title="三、nvidia-docker和nvidia-container-runtime安装和配置"></a>三、<code>nvidia-docker</code>和<code>nvidia-container-runtime</code>安装和配置</h1><h2 id="1-安装nvidia-docker-。"><a href="#1-安装nvidia-docker-。" class="headerlink" title="1. 安装nvidia-docker 。"></a>1. 安装<code>nvidia-docker</code> 。</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Add the package repositories</span><br><span class="line">$ distribution=$(. /etc/os-release;echo $ID$VERSION_ID)</span><br><span class="line">$ curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -</span><br><span class="line">$ curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list</span><br><span class="line"></span><br><span class="line">$ sudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-container-toolkit</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="2-安装nvidia-container-runtime"><a href="#2-安装nvidia-container-runtime" class="headerlink" title="2. 安装nvidia-container-runtime"></a>2. 安装nvidia-container-runtime</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install nvidia-container-runtime</span><br></pre></td></tr></table></figure>

<h2 id="3-Docker引擎配置"><a href="#3-Docker引擎配置" class="headerlink" title="3. Docker引擎配置"></a>3. Docker引擎配置</h2><h3 id="1-Systemd-drop-in-file"><a href="#1-Systemd-drop-in-file" class="headerlink" title="1. Systemd drop-in file"></a>1. Systemd drop-in file</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">sudo tee /etc/systemd/system/docker.service.d/override.conf &lt;&lt;EOF</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd --host=fd:// --add-runtime=nvidia=/usr/bin/nvidia-container-runtime</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="2-Daemon-configuration-file"><a href="#2-Daemon-configuration-file" class="headerlink" title="2. Daemon configuration file"></a>2. Daemon configuration file</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;runtimes&quot;: &#123;</span><br><span class="line">        &quot;nvidia&quot;: &#123;</span><br><span class="line">            &quot;path&quot;: &quot;/usr/bin/nvidia-container-runtime&quot;,</span><br><span class="line">            &quot;runtimeArgs&quot;: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo pkill -SIGHUP dockerd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：</p>
<p><a href="https://github.com/NVIDIA/nvidia-docker">https://github.com/NVIDIA/nvidia-docker</a></p>
<p><a href="https://github.com/nvidia/nvidia-container-runtime">https://github.com/nvidia/nvidia-container-runtime</a></p>
</blockquote>
<h1 id="四、配置tensorflow"><a href="#四、配置tensorflow" class="headerlink" title="四、配置tensorflow"></a>四、配置tensorflow</h1><h2 id="1-验证-nvidia-docker-安装"><a href="#1-验证-nvidia-docker-安装" class="headerlink" title="1. 验证 nvidia-docker 安装"></a>1. 验证 nvidia-docker 安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run --runtime=nvidia --rm nvidia/cuda nvidia-smi</span><br></pre></td></tr></table></figure>
<img src="/2019/11/09/Ubuntu-18-4%E4%BD%BF%E7%94%A8docker%E9%85%8D%E7%BD%AETensorFlow-GPU%E7%8E%AF%E5%A2%83/2019-11-09-17-34-09.png" class="">

<h2 id="2-下载并运行支持-GPU-的-TensorFlow-映像"><a href="#2-下载并运行支持-GPU-的-TensorFlow-映像" class="headerlink" title="2. 下载并运行支持 GPU 的 TensorFlow 映像"></a>2. 下载并运行支持 <code>GPU</code> 的 <code>TensorFlow</code> 映像</h2><h3 id="1-下载支持-GPU-的-TensorFlow-映像"><a href="#1-下载支持-GPU-的-TensorFlow-映像" class="headerlink" title="1. 下载支持 GPU 的 TensorFlow 映像"></a>1. 下载支持 <code>GPU</code> 的 <code>TensorFlow</code> 映像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run --runtime=nvidia -it --rm tensorflow/tensorflow:latest-gpu</span><br></pre></td></tr></table></figure>
<img src="/2019/11/09/Ubuntu-18-4%E4%BD%BF%E7%94%A8docker%E9%85%8D%E7%BD%AETensorFlow-GPU%E7%8E%AF%E5%A2%83/2019-11-09-17-37-14.png" class="">

<h3 id="2-环境测试"><a href="#2-环境测试" class="headerlink" title="2. 环境测试"></a>2. 环境测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -c &quot;import tensorflow as tf;print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot;</span><br></pre></td></tr></table></figure>
<img src="/2019/11/09/Ubuntu-18-4%E4%BD%BF%E7%94%A8docker%E9%85%8D%E7%BD%AETensorFlow-GPU%E7%8E%AF%E5%A2%83/2019-11-09-17-39-56.png" class="">

<h3 id="3-使用最新的-TensorFlow-GPU-映像在容器中启动-bash-shell-会话"><a href="#3-使用最新的-TensorFlow-GPU-映像在容器中启动-bash-shell-会话" class="headerlink" title="3. 使用最新的 TensorFlow GPU 映像在容器中启动 bash shell 会话"></a>3. 使用最新的 TensorFlow GPU 映像在容器中启动 bash shell 会话</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run --runtime=nvidia -it tensorflow/tensorflow:latest-gpu bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="https://www.tensorflow.org/install/docker">https://www.tensorflow.org/install/docker</a></p>
</blockquote>
<h1 id="五、通过软链接修改Docker配置本地镜像与容器的存储位置"><a href="#五、通过软链接修改Docker配置本地镜像与容器的存储位置" class="headerlink" title="五、通过软链接修改Docker配置本地镜像与容器的存储位置"></a>五、通过软链接修改Docker配置本地镜像与容器的存储位置</h1><p>默认情况下Docker的存放位置为：<code>/var/lib/docker</code> ,由于我的系统分区比较小，需要修改Docker配置本地镜像与容器的存储位置。</p>
<p>可以通过下面命令查看具体位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker info | grep &quot;Docker Root Dir&quot;</span><br></pre></td></tr></table></figure>
<p>解决这个问题，最直接的方法当然是挂载分区到这个目录，但是我的数据盘还有其他东西，这肯定不好管理，所以采用修改镜像和容器的存放路径的方式达到目的。</p>
<p>这个方法里将通过软连接来实现。</p>
<p>首先停掉Docker服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br><span class="line">或者</span><br><span class="line">$ sudo service docker stop</span><br></pre></td></tr></table></figure>

<p>然后移动整个&#x2F;var&#x2F;lib&#x2F;docker目录到目的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo sudo mv /var/lib/docker /root/data/docker</span><br><span class="line">$ sudo ln -s /root/data/docker /var/lib/docker</span><br></pre></td></tr></table></figure>
<p>这时候启动Docker时发现存储目录依旧是&#x2F;var&#x2F;lib&#x2F;docker，但是实际上是存储在数据盘的，你可以在数据盘上看到容量变化。</p>
<h1 id="六、使用非root用户运行docker"><a href="#六、使用非root用户运行docker" class="headerlink" title="六、使用非root用户运行docker"></a>六、使用非root用户运行docker</h1><p>默认情况下，docker 命令会使用 Unix socket 与 Docker 主机通讯，安装完docker主机后默认会创建一个docke用户组。而只有 root 用户和 docker 组的用户才可以访问 Docker 主机的 Unix socket，所以需要把linux非root用户添加到docker组才能直接访问docker 主机。步骤如下：</p>
<ol>
<li><p>如果没有创建docker用户组，则需要先创建一个docket用户组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>将指定的用户添加到docker用户组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG docker userName</span><br></pre></td></tr></table></figure></li>
<li><p>重启docker服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo service docker restart //或者 </span><br><span class="line">$ sudo /etc/init.d/docker restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后注销重登陆使用户组生效，或者使用以下命令直接登陆到docker组中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ newgrp - docker //切换到docker用户组</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/wenwenxiong/article/details/78728696">https://blog.csdn.net/wenwenxiong/article/details/78728696</a></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>Ubuntu Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下安装使用v2ray</title>
    <url>/2019/11/04/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8v2ray/</url>
    <content><![CDATA[<blockquote>
<p>文章转载自：<a href="https://deng55.github.io/2017/12/04/Ubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8V2ray/">https://deng55.github.io/2017/12/04/Ubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8V2ray/</a></p>
<p><a href="https://www.imcaviare.com/2018-12-18-1/">https://www.imcaviare.com/2018-12-18-1/</a></p>
</blockquote>
<!-- TOC -->

<ul>
<li><a href="#1%E5%AE%89%E8%A3%85v2ray">1.安装v2ray</a></li>
<li><a href="#2%E9%85%8D%E7%BD%AE">2.配置</a><ul>
<li><a href="#1-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1">1. 启动服务</a></li>
</ul>
</li>
<li><a href="#3-%E9%85%8D%E7%BD%AEpac">3. 配置PAC</a></li>
</ul>
<!-- /TOC -->
<p>由于最近把系统换成了ubuntu，虽然已经用上了shadowsocks-qt5，但是本着折腾的态度，还是想把v2ray部署起来。</p>
<h1 id="1-安装v2ray"><a href="#1-安装v2ray" class="headerlink" title="1.安装v2ray"></a>1.安装v2ray</h1><p>安装的过程比较简单，可直接按照官方教程。</p>
<p>ubuntu系统下使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure>

<p>命令执行完之后，会自动生成如下文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/v2ray/v2ray：V2Ray 程序；</span><br><span class="line">/etc/v2ray/config.json：配置文件；</span><br></pre></td></tr></table></figure>

<h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h1><p>找了很多教程，在配置这一块都比较模糊，特别是linux环境下的配置。</p>
<p>很多教程说是去下载官方的<code>v2ray-core</code>包，之后的步骤就没详细说了，我也在这一块浪费了很多时间，部署起来后才知道确实是自己想复杂了</p>
<p>还记得我们第一步的安装过程吗，安装成功后会生成<code>/etc/v2ray/config.json</code>文件，其实在ubuntu系统下这个文件不需要，因为本身是当做客户端来使用的，这时候去看下载的核心包</p>
<p>下载核心包后，解压出来会有一些配置文件，核心包里面我们需要的文件是：<code>vpoint_socks_vmess.json</code> ，这个文件才是最终要使用的配置文件，把这个文件改名为<code>config.json</code>，并替换第一步安装的<code>/etc/v2ray/config.json</code></p>
<p>vpoint_socks_vmess.json文件截图如下：</p>
<img src="/2019/11/04/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8v2ray/UbuntuUseV2ray.png" class="">

<p>这就和windows下的配置是一样的了。</p>
<p>上面截图我有一块注释掉了，主要是不太了解这里的配置，不注释跑不起来</p>
<p>其实可以用偷懒的方法，如果之前在windows下部署过了，直接把config.json文件拿过来，放到<code>/etc/v2ray</code>目录下即可（删除该目录下原有的配置文件）</p>
<h2 id="1-启动服务"><a href="#1-启动服务" class="headerlink" title="1. 启动服务"></a>1. 启动服务</h2><p>文件替换之后，就可以使用<code>service v2ray start</code>来启动 V2Ray 进程，chrome下配合SwitchyOmega扩展来使用，剩下的应该都会了。</p>
<p>使用以下命令启动 V2Ray:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start v2ray</span><br></pre></td></tr></table></figure>
<p>停止运行 V2Ray：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop v2ray</span><br></pre></td></tr></table></figure>
<p>重启 V2Ray:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart v2ray</span><br></pre></td></tr></table></figure>
<p>其他的命令可以参考官方文档，以上就是ubuntu下使用的办法了。</p>
<h1 id="3-配置PAC"><a href="#3-配置PAC" class="headerlink" title="3. 配置PAC"></a>3. 配置PAC</h1><p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pip install genpac</span><br><span class="line"></span><br><span class="line"># 从gfwlist生成代理信息为SOCKS5 127.0.0.1:1080的PAC文件</span><br><span class="line">genpac --format=pac --pac-proxy=&quot;SOCKS5 127.0.0.1:1080&quot; -o /etc/v2ray/autoproxy.pac</span><br></pre></td></tr></table></figure>
<p>为避免不必要的bug请注意以下两点：</p>
<ul>
<li>文件有足够的读写权限</li>
<li>配置URL以file:&#x2F;&#x2F;开头电脑根目录为起始。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu死机解决方法汇总</title>
    <url>/2019/11/08/Ubuntu%E6%AD%BB%E6%9C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<blockquote>
<p>转载自 : <a href="https://blog.csdn.net/frogoscar/article/details/64921708">https://blog.csdn.net/frogoscar/article/details/64921708</a></p>
</blockquote>
<!-- TOC -->

<ul>
<li><a href="#1-%E8%BF%9B%E5%85%A5tty%E7%BB%88%E7%AB%AF">1. 进入TTY终端</a></li>
<li><a href="#2-%E7%9B%B4%E6%8E%A5%E6%B3%A8%E9%94%80%E7%94%A8%E6%88%B7">2. 直接注销用户</a></li>
<li><a href="#3-%E5%BA%95%E5%B1%82%E6%96%B9%E6%B3%95">3. 底层方法</a></li>
</ul>
<!-- /TOC -->
<p>可尝试的解决方法</p>
<h1 id="1-进入TTY终端"><a href="#1-进入TTY终端" class="headerlink" title="1. 进入TTY终端"></a>1. 进入TTY终端</h1><p><code>Ctrl+Alt+F1</code>进入<code>TTY1</code>终端字符界面, 输入用户名和密码以登录。</p>
<p>输入<code>top</code>命令, 找到可能造成假死的进程, 用<code>kill</code>命令结束掉进程。然后<code>Ctrl+Alt+F7</code>回到桌面。</p>
<h1 id="2-直接注销用户"><a href="#2-直接注销用户" class="headerlink" title="2. 直接注销用户"></a>2. 直接注销用户</h1><p><code>Ctrl+Alt+F1</code>进入<code>TTY1</code>终端字符界面, 输入用户名和密码以登录。</p>
<p>然后执行以下的任意一个命令注销桌面重新登录。</p>
<p><code>sudo pkill Xorg</code>或者<code>sudo restart lightdm</code> 。</p>
<h1 id="3-底层方法"><a href="#3-底层方法" class="headerlink" title="3. 底层方法"></a>3. 底层方法</h1><p>如果上面两种方法不成功, 那有可能是比较底层的软件出现问题。</p>
<p>可以试试 : <code>reisub</code> 方法。</p>
<p>说具体一点, 是一种系统请求, 直接交给内核处理。</p>
<p>键盘上一般都有一个键<code>SysRq</code>, 和<code>PrintScreen</code>(截屏)在一个键位上，这就是系统请求的键。</p>
<p>这个方法可以在死机的情况下安全地重启计算机, 数据不会丢失。</p>
<p>下面解释一下这个方法：</p>
<p>其实 <code>SysRq</code>是一种叫做系统请求的东西, 按住 <code>Alt-Print</code> 的时候就相当于按住了<code>SysRq</code>键，这个时候输入的一切都会直接由 <code>Linux</code> 内核来处理，它可以进行许多低级操作。</p>
<p>这个时候 <code>reisub</code> 中的每一个字母都是一个独立操作，分别表示：</p>
<p><code>r</code> : <code>unRaw</code> 将键盘控制从 <code>X Server</code> 那里抢回来。</p>
<p><code>e</code> : <code>tErminate</code> 给所有进程发送 <code>SIGTERM</code> 信号，让它们自己解决善后</p>
<p><code>i</code> : <code>kIll</code> 给所有进程发送 <code>SIGKILL</code> 信号，强制他们马上关闭</p>
<p><code>s</code> : <code>Sync</code> 将所有数据同步至磁盘</p>
<p><code>u</code> : <code>Unmount</code> 将所有分区挂载为只读模式</p>
<p><code>b</code> : <code>reBoo</code>t 重启</p>
<p>魔法键组合 <code>reisub</code> 究竟该怎么用？<br>如果某一天你的 <code>Linux</code> 死机了，键盘不听使唤了，<code>Ctrl+Alt+F1</code> 已经没有任何反应，该怎么办呢？</p>
<p>使用“魔法键”：<code>Alt+SysRq + r,e,i,s,u,b</code>（确实很好背，就是单词 <code>busier</code> (英语”更忙”的意思)的倒写）。</p>
<p>好的，平时电脑那么正常，你自然也不会去按这些按钮。等到真的出事的时候，你把记在小纸条上的这些 tips 拿出来，然后在键盘上按，结果发现啥反应也没有，于是只能欲哭无泪了。</p>
<p>问题在于：究竟该怎么按这些按钮才会有效？<br>首先，你的系统要支持这个功能，查看和开启的方法大家应该很熟悉了，网上也有很多说明，而且最幸运的是：Ubuntu 默认已经开启了这个功能。</p>
<p>接下来就是操作：马上你就会发现，同时按下<code>&lt;Alt&gt;+&lt;SysRq&gt;</code>压根儿行不通！只会蹦出来一个屏幕截图窗口。所以，真正的做法应该是：</p>
<p>伸出你的左手，同时按住<code>&lt;Ctrl&gt;+&lt;Alt&gt;</code>键，别松开<br>右手先按一下<code>&lt;SysRq&gt;</code>，左手别松开，等1秒<br>右手按一下 <code>R</code>，左手别松开，等1秒<br>右手按一下 <code>E</code>，左手别松开。这时包括桌面在内，所有程序都会终止，你会看到一个黑乎乎的屏幕，稍微等一段时间<br>右手依次按下 <code>I，S，U，B</code>，左手别松开。每按一次都等那么几秒种，你会发现每按一次，屏幕上信息都会有所变化。最后按下<code>B</code>时，屏幕显示<code>reset</code>，这时你的左手可以松开了，等几秒钟，计算机就会安全重启。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode插件</title>
    <url>/2019/11/13/VSCode%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="记录以下自己常用的-VSCode-插件"><a href="#记录以下自己常用的-VSCode-插件" class="headerlink" title="记录以下自己常用的 VSCode 插件"></a>记录以下自己常用的 VSCode 插件</h1><ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=dan-c-underwood.arm">Arm Assembly</a> - ARM 汇编语法高亮。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=RalfZhang.filetemplate">File Template</a> - 一个自动生成文件模板的 ode 扩展。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=jebbs.markdown-extended">Markdown Extended</a> - markdown 扩展。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=huntertran.auto-markdown-toc">Markdown TOC</a> - 自动生成 toc 。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=mushan.vscode-paste-image">Paste Image</a> - 将图像直接从剪贴板粘贴到 kdown&#x2F;asciidoc 。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=LoyieKing.smalise">Smalise</a> : smali 语法高亮插件。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=TabNine.tabnine-vscode">TabNine</a> : AI 代码神器。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=vscode-icons-team.vscode-icons">vscode-icons</a> : - Icons for ual Studio Code。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=infosec-intern.yara">YARA</a> - yara 语法高亮。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=kiteco.kite">kite</a> - AI 代码神奇。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=cschlosser.doxdocgen">Doxygen Documentation Generator</a> - ygen 文档注释生成。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=rsbondi.highlight-words">highlight-words</a> - 选中高亮</li>
</ul>
<h1 id="修改-terminal-默认为-cmder"><a href="#修改-terminal-默认为-cmder" class="headerlink" title="修改 terminal 默认为 cmder"></a>修改 terminal 默认为 cmder</h1><p>打开终端设置 <code>terminal.integrated.env.windows</code> 配置文件，添加下列配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;terminal.integrated.defaultProfile.windows&quot;</span>: <span class="string">&quot;Cmder&quot;</span>,</span><br><span class="line"><span class="string">&quot;terminal.integrated.profiles.windows&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Cmder&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;path&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;<span class="variable">$&#123;env:windir&#125;</span>\\Sysnative\\cmd.exe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;<span class="variable">$&#123;env:windir&#125;</span>\\System32\\cmd.exe&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;/k D:\\Downloads\\cmder\\vendor\\init.bat&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;terminal-cmd&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>VSCode 插件</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2折腾记录</title>
    <url>/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>最近看到很多大佬对于wsl2的推崇，于是就想体验一番，将系统升级到2004，下面记录以下折腾过程。</p>
<!-- TOC -->

<ul>
<li><a href="#1-%E7%B3%BB%E7%BB%9F%E5%8D%87%E7%BA%A7">1. 系统升级</a><ul>
<li><a href="#11-%E9%97%AE%E9%A2%98%E6%88%91%E4%BB%AC%E6%97%A0%E6%B3%95%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F%E4%BF%9D%E7%95%99%E7%9A%84%E5%88%86%E5%8C%BA">1.1. 问题：我们无法更新系统保留的分区</a></li>
<li><a href="#12-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">1.2. 解决办法</a><ul>
<li><a href="#121-%E5%A4%87%E4%BB%BDefi%E5%88%86%E5%8C%BA">1.2.1. 备份EFI分区</a></li>
<li><a href="#122-%E5%88%A0%E9%99%A4efiesp-%E5%88%86%E5%8C%BA">1.2.2. 删除EFI&#x2F;ESP 分区</a></li>
<li><a href="#123-%E6%89%A9%E5%A4%A7-efi-%E5%88%86%E5%8C%BA">1.2.3. 扩大 EFI 分区</a></li>
<li><a href="#124-%E6%96%B0%E5%BB%BAespmsr%E5%88%86%E5%8C%BA">1.2.4. 新建ESP&#x2F;MSR分区</a></li>
<li><a href="#125-%E8%BF%98%E5%8E%9F-efi-%E5%88%86%E5%8C%BA%E9%95%9C%E5%83%8F">1.2.5. 还原 EFI 分区镜像</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E5%AE%89%E8%A3%85-wsl2">2. 安装 WSL2</a><ul>
<li><a href="#21-%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%90%AF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B9%B3%E5%8F%B0%E5%92%8C-linux-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD">2.1. 第一步：启用虚拟机平台和 Linux 子系统功能</a></li>
<li><a href="#22-%E5%90%AF%E7%94%A8-wsl2-%E5%B9%B6%E5%AE%89%E8%A3%85-linux-%E5%AD%90%E7%B3%BB%E7%BB%9F">2.2. 启用 WSL2 并安装 linux 子系统</a></li>
<li><a href="#23-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE">2.3. 自定义安装位置</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->


<h1 id="1-系统升级"><a href="#1-系统升级" class="headerlink" title="1. 系统升级"></a>1. 系统升级</h1><h2 id="1-1-问题：我们无法更新系统保留的分区"><a href="#1-1-问题：我们无法更新系统保留的分区" class="headerlink" title="1.1. 问题：我们无法更新系统保留的分区"></a>1.1. 问题：我们无法更新系统保留的分区</h2><p>首先进行系统升级就出现了问题“我们无法更新系统保留的分区”，对于这个问题，网上很多人给的答案是 MSR(Microsoft Reserved)分区太小的问题，然而实际问题是ESP(EFI System Partition)分区 “EFI系统分区” 太小的原因，微软在这里所提示的系统保留的分区实际上是指“EFI系统分区”。</p>
<h2 id="1-2-解决办法"><a href="#1-2-解决办法" class="headerlink" title="1.2. 解决办法"></a>1.2. 解决办法</h2><p>备份 EFI 系统分区，然后进入PE系统，删除EFI分区和MSR分区，将C盘空间分出500M空间给EFI分区和MSR分区，然后建立ESP&#x2F;MSR分区，将备份的EFI分区还原就可以了。</p>
<p>下面说一下详细步骤：</p>
<h3 id="1-2-1-备份EFI分区"><a href="#1-2-1-备份EFI分区" class="headerlink" title="1.2.1. 备份EFI分区"></a>1.2.1. 备份EFI分区</h3><p>使用 DiskGenius 备份EFI分区，如下图：</p>
<img src="/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/2020-06-07-10-00-23.png" class="">

<h3 id="1-2-2-删除EFI-x2F-ESP-分区"><a href="#1-2-2-删除EFI-x2F-ESP-分区" class="headerlink" title="1.2.2. 删除EFI&#x2F;ESP 分区"></a>1.2.2. 删除EFI&#x2F;ESP 分区</h3><p>进入PE系统删除 EFI 分区和 ESP 分区，我的电脑中存在一个系统还原的分区，由于我不需要系统还原，就直接删掉了，当然也可以备份，后续再还原。</p>
<img src="/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/2020-06-07-10-06-59.png" class="">

<h3 id="1-2-3-扩大-EFI-分区"><a href="#1-2-3-扩大-EFI-分区" class="headerlink" title="1.2.3. 扩大 EFI 分区"></a>1.2.3. 扩大 EFI 分区</h3><p>将 C 盘空间分出 500M 给 EFI 分区，如果担心不够，你也可以多分一点。</p>
<img src="/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/2020-06-07-10-11-18.png" class="">

<h3 id="1-2-4-新建ESP-x2F-MSR分区"><a href="#1-2-4-新建ESP-x2F-MSR分区" class="headerlink" title="1.2.4. 新建ESP&#x2F;MSR分区"></a>1.2.4. 新建ESP&#x2F;MSR分区</h3><p>选择新建ESP&#x2F;MSR分区，后续的选项保持默认就可以，可以看到分区比之前的要大一些了。</p>
<img src="/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/2020-06-07-10-15-16.png" class="">

<img src="/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/2020-06-07-10-21-00.png" class="">

<h3 id="1-2-5-还原-EFI-分区镜像"><a href="#1-2-5-还原-EFI-分区镜像" class="headerlink" title="1.2.5. 还原 EFI 分区镜像"></a>1.2.5. 还原 EFI 分区镜像</h3><p>选中 EFI 分区，右键-&gt;从镜像文件还原分区，还原之前保存的 EFI 分区镜像。</p>
<img src="/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/2020-06-07-10-16-27.png" class="">

<p>重启系统，然后就可以愉快的升级了，记得C 盘空余空间保持在20G以上。</p>
<h1 id="2-安装-WSL2"><a href="#2-安装-WSL2" class="headerlink" title="2. 安装 WSL2"></a>2. 安装 WSL2</h1><h2 id="2-1-第一步：启用虚拟机平台和-Linux-子系统功能"><a href="#2-1-第一步：启用虚拟机平台和-Linux-子系统功能" class="headerlink" title="2.1. 第一步：启用虚拟机平台和 Linux 子系统功能"></a>2.1. 第一步：启用虚拟机平台和 Linux 子系统功能</h2><p>以管理员权限启动 PowerShell，然后输入以下命令启用虚拟机平台：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform</span><br></pre></td></tr></table></figure>

<p>以管理员权限启动 PowerShell，然后输入以下命令启用 Linux 子系统功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</span><br></pre></td></tr></table></figure>
<p>在以上每一步命令执行完之后，PowerShell 中可能会提示你重新启动计算机。按“Y”可以重新启动。</p>
<p>以上操作可能需要先<a href="https://docs.microsoft.com/zh-cn/windows/wsl/wsl2-kernel">更新 WSL 2 Linux 内核</a>。</p>
<h2 id="2-2-启用-WSL2-并安装-linux-子系统"><a href="#2-2-启用-WSL2-并安装-linux-子系统" class="headerlink" title="2.2. 启用 WSL2 并安装 linux 子系统"></a>2.2. 启用 WSL2 并安装 linux 子系统</h2><p>使用以下命令可以在以后安装 Linux 的时候默认启用 WSL2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure>
<p>去应用商店安装 linux 子系统，安装好后使用以下命令查看，可以看到 VESION 为 2 即为 wsl2 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --list --verbose</span><br><span class="line">  NAME            STATE           VERSION</span><br><span class="line">* Ubuntu-18.04    Stopped         2</span><br></pre></td></tr></table></figure>

<h2 id="2-3-自定义安装位置"><a href="#2-3-自定义安装位置" class="headerlink" title="2.3. 自定义安装位置"></a>2.3. 自定义安装位置</h2><p>下载 <a href="https://github.com/DDoSolitary/LxRunOffline/releases">LxRunOffline</a>，可以发现版本 v3.4.1 已经支持 wsl2 了。</p>
<p>执行 <code>LxRunOffline move -n &#123;version&#125; -d &#123;dir&#125;</code> ，将 Linux 移动到指定的目录。其中，<code>&#123;version&#125;</code>是版本号，可以通过 <code>LxRunOffline list</code> 来查看，<code>&#123;dir&#125;</code>是目标目录。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LxRunOffline.exe m -n Ubuntu-18.04 -d D:/WSL/Ubuntu-18.04</span><br></pre></td></tr></table></figure>
<p>最终效果，如下图：</p>
<img src="/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/2020-06-07-10-44-20.png" class="">

<p>至此，整个折腾过程到此结束。</p>
<p>参考：</p>
<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a></p>
<p><a href="https://blog.walterlv.com/post/how-to-install-wsl2.html">https://blog.walterlv.com/post/how-to-install-wsl2.html</a></p>
<p><a href="https://answers.microsoft.com/zh-hans/windows/forum/all/%E6%9B%B4%E6%96%B0windows10%E9%81%87%E5%88%B0/5bea3327-38e0-4c20-837a-90f156655e32">https://answers.microsoft.com/zh-hans/windows/forum/all/%E6%9B%B4%E6%96%B0windows10%E9%81%87%E5%88%B0/5bea3327-38e0-4c20-837a-90f156655e32</a></p>
<p><a href="https://www.cnblogs.com/NBDWDYS2214143926/p/11543815.html">https://www.cnblogs.com/NBDWDYS2214143926/p/11543815.html</a></p>
<p><a href="https://www.bilibili.com/read/cv1429071/">https://www.bilibili.com/read/cv1429071/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>WhatsAppWrom分析过程</title>
    <url>/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>关于 WhatsAppWrom 的相关报告可以参考:</p>
<blockquote>
<p><a href="https://blogs.360.cn/post/Alert_new_Android_malware_spreads_through_WhatsApp.html">https://blogs.360.cn/post/Alert_new_Android_malware_spreads_through_WhatsApp.html</a></p>
</blockquote>
<p>样本md5: <a href="JebAndroidSigPlugin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/huawei.apk">121AB9F7C0F439274478099D9E550473</a>。</p>
<p>使用 JEB 打开该样本，可以发现混淆比较严重，代码实现在 <code>com.jan.flixonlines.NotificationService.onNotificationPosted</code> 方法中实现，如下图所示：</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/2021-02-03-15-29-46.png" class="">

<p>这里有两个关键方法，需要进一步跟进，首先是进入 <code>d.a</code> 方法，可以发现混淆比较严重,如下图所示：</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/2021-02-03-15-34-33.png" class="">

<p>不过发现字符串 <code>&quot;android.wearable.EXTENSIONS&quot;</code> 未被混淆，应该可以作为突破口。结合 <code>getBundle</code> 方法，初步猜测使用了 <code>Bundle</code> 传递蠕虫消息，但是还是不太清楚原理，接着看一下 <code>v9.a</code> 方法，如下图所示：</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/2021-02-03-15-37-42.png" class="">

<p>图中框起来的表示当时分析时认为的可疑点，当时由于没有相关开发经验，也不清楚其中的原理。</p>
<p>分析到这里后，有点卡住了，然后习惯性的试了一下 Android Signature Recognizer 插件，发现恢复了部分类。其中比较关键类就是 <code>androidx.core.graphics.drawable.IconCompat</code> 。跟进之前的关键方法 <code>d.a</code> 中，发现一个 <code>a.e.d.d</code> 的类，继续跟进该类，发现了 <code>IconCompat.createWithResource</code> 方法，如下图所示：</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/2021-02-03-15-50-14.png" class="">

<p>接下来就开始 google 搜索了，首先搜索 <code>&quot;android.wearable.EXTENSIONS&quot;</code> 关键字，如下图所示：</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/2021-02-03-15-53-06.png" class="">

<p>搜索结果的第一篇文章就讲了实现原理，但是我但是分析时参考的时这一篇文章的<a href="https://github.com/hehonghui/android-tech-frontier/blob/master/issue-8/%E5%A6%82%E4%BD%95%E5%9C%A8Android%E4%B8%8A%E5%93%8D%E5%BA%94%E5%90%84%E7%A7%8D%E4%BF%A1%E6%81%AF%E9%80%9A%E7%9F%A5.md">翻译文</a>。到这里应该就已经结束了，毕竟该文章提供了源码。但是经过测试该源码后，发现不能实现相应的功能，那么就继续硬刚。</p>
<p>在 Android 提供的 <a href="https://cs.android.com/">Android Code Search
</a>页面搜索 <code>IconCompat.createWithResource</code> ，发现一段代码与 JEB 反汇编的代码类似，如下图所示：</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/2021-02-03-16-12-17.png" class="">

<p>最终发现待代码片段和 JEB 反编译的代码几乎一样，可以认为时同一个类，所以将 <code>a.e.d.d</code> 还原成了 <code>Action</code> ，后面通过类似的方法将整个 APK 关键的类都还原了，还原后的关键方法代码如下图所示：</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/2021-02-03-16-19-37.png" class="">

<p>对应的 <a href="WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/huawei.apk.jdb2">JEB 数据库</a></p>
<p>不过最终根据 APK 还原的代码还是有点问题，最终发现好像时导库的有问题。最后通过<a href="https://gist.github.com/tajchert/53f728fadae7e3e9d77a#file-wearableextendersender">链接</a>中的代码搞定了。</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/%E6%95%88%E6%9E%9C%E5%9B%BE.gif" class="">

<p><a href="https://github.com/CKCat/Blog/tree/master/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/WhatsAppWrom">相关代码</a></p>
<p>不过今天搜索 <code>&quot;android.car.EXTENSIONS&quot;</code> 关键字，突然发现了<a href="https://stackoverflow.com/questions/46788600/automatic-reply-for-whatsapp-messages-approach">另一篇文章</a>，该文章的实现代码和 WhatsAppWrom 相似度非常高，WhatsAppWrom 开发者参考了相关代码。</p>
<p>该文章回复帖子中提到了 Android 7 以上的版本利用通知栏直接回复的功能实现自动回复，也附上了相关<a href="https://stackoverflow.com/questions/40369508/how-to-utilize-android-nougats-direct-reply-feature-with-a-notificationlistener?rq=1">文章</a>。其实最初分析这个样本的时候，也以为是利用了  Android 7 的直接回复功能，并在这里耗了一段时间，如果早点看到这一篇文章，或许分析起来就更轻松了吧。</p>
<p>简单的来个总结吧：</p>
<ol>
<li>个人代码量积累不够，各种功能需要搜索才能知道其功能，导致分析时间过长。</li>
<li>要善用搜索引擎，抓住关键字，毕竟总会有你不会的东西， 需要搜索引擎来解决。</li>
</ol>
<p>参考：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://medium.com/@polidea/how-to-respond-to-any-messaging-notification-on-android-7befa483e2d7</span><br><span class="line">https://github.com/hehonghui/android-tech-frontier/blob/master/issue-8/%E5%A6%82%E4%BD%95%E5%9C%A8Android%E4%B8%8A%E5%93%8D%E5%BA%94%E5%90%84%E7%A7%8D%E4%BF%A1%E6%81%AF%E9%80%9A%E7%9F%A5.md</span><br><span class="line">https://stackoverflow.com/questions/46788600/automatic-reply-for-whatsapp-messages-approach</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>dexsim插件-Geost</title>
    <url>/2020/03/13/dexsim%E6%8F%92%E4%BB%B6-Geost/</url>
    <content><![CDATA[<p>最近分析Geost家族银行木马，记录一下该木马字符串解密插件编写。</p>
<blockquote>
<p>样本来源：<a href="https://blog.trendmicro.com/trendlabs-security-intelligence/dissecting-geost-exposing-the-anatomy-of-the-android-trojan-targeting-russian-banks/">https://blog.trendmicro.com/trendlabs-security-intelligence/dissecting-geost-exposing-the-anatomy-of-the-android-trojan-targeting-russian-banks/</a></p>
</blockquote>
<p><a href="dexsim%E6%8F%92%E4%BB%B6-Geost/92394e82d9cf5de5cb9c7ac072e774496bd1c7e2944683837d30b188804c1810">样本下载</a></p>
<h1 id="分析字符串解密特点"><a href="#分析字符串解密特点" class="headerlink" title="分析字符串解密特点"></a>分析字符串解密特点</h1><p>首先查看样本中解密字符串方法的特点</p>
<img src="/2020/03/13/dexsim%E6%8F%92%E4%BB%B6-Geost/2020-03-13-14-51-04.png" class="">

<p>可以发现解密字符串函数为 <code>Lcom/rgamtgid/hnsolues/QLwdDnU;-&gt;UGanmSarY([B)[B</code> , 此代码的特征为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fill-array-data v2, :array_2e</span><br><span class="line">invoke-virtual &#123;p0, v2&#125;, Lcom/rgamtgid/hnsolues/QLwdDnU;-&gt;UGanmSarY([B)[B</span><br><span class="line">move-result-object v2</span><br><span class="line">invoke-direct &#123;v1, v2&#125;, Ljava/lang/String;-&gt;&lt;init&gt;([B)V</span><br></pre></td></tr></table></figure>

<p>对应的正则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r&#x27;fill-array-data v\d+, :(\w+)\s+?&#x27;</span><br><span class="line">r&#x27;invoke-virtual &#123;p0, v\d&#125;, (.*?);-&gt;(.*?)\(\[B\)\[B\s+?&#x27;</span><br><span class="line">r&#x27;move-result-object v\d+\s+?&#x27;</span><br><span class="line">r&#x27;invoke-direct &#123;(v\d+), v\d+&#125;, Ljava/lang/String;-&gt;&lt;init&gt;\(\[B\)V&#x27;</span><br></pre></td></tr></table></figure>

<p>继续观察<code>Lcom/rgamtgid/hnsolues/QLwdDnU;-&gt;UGanmSarY([B)[B</code> 函数，发现该函数为非静态函数，需要先调用函数所在类的构造函数，然后再调用该解密函数，并且该函数返回值为 <code>byte[]</code> , 需要转成 <code>String</code> 类型, 所以需要修改 <code>dss</code> 相关代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object obj = null;</span><br><span class="line">try&#123;</span><br><span class="line">    Constructor&lt;?&gt; con = clz.getConstructor();</span><br><span class="line">    obj = con.newInstance();</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">ret = mtd.invoke(obj, target.getParameters());</span><br><span class="line">result = new String((byte[])ret);</span><br></pre></td></tr></table></figure>
<p>开始解密，发现解密结果为乱码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;f2e3d508ee217c095861d260a3a9eee8f61603ed045bb4817fd28a7da11b3d9f&quot;: [&quot;ġ��\\u001D3\\u0002��&quot;],</span><br><span class="line">	&quot;38a80467b6d5b816cd91776ed8e51cce0df8a73d46bd47b7d188d1d84eaa678f&quot;: [&quot;ˮ��\\u0019(\\u0003&quot;],</span><br><span class="line">	&quot;b4e499760697584cc82d02559489ce6a99e497ab066d1a2b34a33cbfce943193&quot;: [&quot;���&quot;],</span><br><span class="line">	&quot;70216d6f207a1c0e370b7113334d14e9ebb12c766568369eda1a1f8afee15fc7&quot;: [&quot;����\\u0019,\\u0006���i�&quot;],</span><br><span class="line">	&quot;d1cdc906ab0b7c1c64a29537e9c4020f52790b0ac1e5045eaf321e9bbfe14d6f&quot;: [&quot;Δ��\\u0005!\\u0000��n�&quot;],</span><br><span class="line">	&quot;d0532ef95194e0763b588f5b2ac1304c5f15333bfda545f929b3c0a8885643c3&quot;: [&quot;ŭ��\\u001D&quot;],</span><br><span class="line">	&quot;df2641fd22aa51c58d5150e925d75b797dac6cdd9491950a912b8c4230e22836&quot;: [&quot;ġ��\\u00072&quot;],</span><br><span class="line">	&quot;1c3fbc0ef0a73334f447ceb1e6eeb53afc8d38c5e054d4ceaef30ccd828b4ff3&quot;: [&quot;ʪ��\\u0007!\\u000B&quot;],</span><br><span class="line">	&quot;1a9a46b987f24ecf7d3be2e6501c7b6622d169a7af407a9e31ef0337bc0141d6&quot;: [&quot;ǥ��\\u0007+I��|����;o�xl���\\u0003b6�&quot;],</span><br><span class="line">	&quot;ff3cb5db4c0284f1bfe203fee5804cd6724267b24ee7d9596f775cd5eead7c2e&quot;: [&quot;ġ��\\u0001.\\u0014��k���&quot;],</span><br><span class="line">	&quot;40e2c22abf4d042c6e20a11e6ba7b2065f709005f6044ed3a4fe7835d041033a&quot;: [&quot;ѡ��&quot;],</span><br><span class="line">	&quot;d5f583b8ec55407eadf5a51dd3ff16b493fb94fae0e202ffd6000af1561bbd9f&quot;: [&quot;ġ��\\u000C3\\u0008��m����&quot;],</span><br><span class="line">	&quot;13a9e458bb010ab664661af1f4f08f084937847fc0768ca47ace65b17243fcb7&quot;: [&quot;(��\\u000B&quot;],</span><br><span class="line">	&quot;a0bcd2c1609d0cd07c8e2a41adbbb3cda932c6c6dca4bfefe481e0adbc83b0cd&quot;: [&quot;д��\\u000B&quot;],</span><br><span class="line">	&quot;7787842e5212469cec7aaa95cd6d8df30d34fb6d0e7a6f1713c0cb5df550f714&quot;: [&quot;ɥ��@,\\u0006誅z���=c�Wb���\\u0017e&#x27;�I&quot;],</span><br><span class="line">	&quot;4d44e4687a94b79a8665bdf15134fd026587af5eed3ecae594fafe6f1a9d891d&quot;: [&quot;ȯ��\\n*\\u0014��&#123;���(q�pa���\\u0015&quot;],</span><br><span class="line">	&quot;73101d880bbfd59702d96ecc3c47618dffdcf243bb3bd275484c002cb76e32db&quot;: [&quot;¶��\\u0017#\\u0008��&quot;],</span><br><span class="line">	&quot;8f03d383773c013569e3e1d910bd8c32fcbed206d3b5c7907bbb99310e33d617&quot;: [&quot;ɥ��@)\\u0008���d�ތ�.b�Gy����&quot;],</span><br><span class="line">	&quot;83718a06bf29a60b800595e9b9ca01708b6e7147b7a3513ecf7b7daa9516c24b&quot;: [&quot;Զ��\\u000B&quot;],</span><br><span class="line">	&quot;05711d0cc4b04eb073b4401b429f20868cba513f4828112442a2c64e379252d1&quot;: [&quot;ġ��\\u0002!\\u0014��i���&quot;],</span><br><span class="line">	&quot;454cf7696e8e0c6abcb6881b67a2831a5465ee7325ee08bf70cf4cc3f42d8e9c&quot;: [&quot;ǡ�&quot;],</span><br><span class="line">	&quot;40848d17e138ba5da879256aea50c6cda50167d856ad7c65ccfd15c60d15455b&quot;: [&quot;ū��\\u000F-\\u0002&quot;],</span><br><span class="line">	&quot;473b6b3f80874a14505ac2577547c5e7e3c96766c74f571bdd736c3844ae33c6&quot;: [&quot;����\\u000F,\\u0014��g���-c�y&#125;�浺[&gt;d�\\n�&quot;],</span><br><span class="line">	&quot;11b2149c2d5239839c10533b4e5363f104d69b7c79c5355ea45d8c5c884dce77&quot;: [&quot;ש��\\u0008)\\u000B�&quot;],</span><br><span class="line">	&quot;bc84eb8f3200f991cd94bf299877f0ffdec6503b41bc344e19e354c1acb1e794&quot;: [&quot;С�&quot;],</span><br><span class="line">	&quot;a47cf816863a4ecf54a03e1a6aaae35f33ddf4ba3f5139286e2bafa26bac0a6e&quot;: [&quot;����&quot;],</span><br><span class="line">	&quot;43ec42d64409376307a36c21db552f5335267593004c139ea1d2d5bd14d6c224&quot;: [&quot;̴�� /\\tǾ�m�ם&quot;],</span><br><span class="line">	&quot;04e8065097330a367c4cd538afc8678d6c9ef24584d7d20c07e94cc754a88816&quot;: [&quot;ǡ��\\u001A%&quot;],</span><br><span class="line">	&quot;561904e2cb0afd0008c5d16fbe3a4ba7cf0b5e5b13ba27eb8092287f0bfb96f8&quot;: [&quot;͡��\\u00003\\u0013��m&quot;],</span><br><span class="line">	&quot;77659956a9e869a9b051ac32cc4f457066332bb0195076d4ed1a8e8019ad4041&quot;: [&quot;ɥ��@,\\u0006誅J����?y&quot;],</span><br><span class="line">	&quot;c16af871c0dd1a66fc41afdc138004641939e1e2b78df4b157037466a5979423&quot;: [&quot;̾��&quot;],</span><br><span class="line">	&quot;f640b5ab7d87d84978011661e769a196fbd3198caaea6fa9263bfa745bd6dd88&quot;: [&quot;ġ��\\u000F3\\u0002Ţ�|���&quot;],</span><br><span class="line">	&quot;9153ef9514c3d163349095f4701d2cba5c06dd49c00c8a3c659d28ef81927040&quot;: [&quot;С��\\u000D#\\u0002��j��&quot;],</span><br><span class="line">	&quot;75dd6f4f0e3b7cffb60fc0fdae51becfb27ce3d6a7ad6518db5a7fe0fb4145fb&quot;: [&quot;ɥ��@,\\u0006誅K���\\u0012x�ph��&quot;],</span><br><span class="line">	&quot;ce505ef1025a3c319094bfd9c0173e62448f78ab255ab4af8d11520bd8767c73&quot;: [&quot;6��\\u001A%.��|���?z&quot;],</span><br><span class="line">	&quot;7a3b634862a85e9cdd1946f52e8080a613aaff393c75715971ed562f940e3e7d&quot;: [&quot;ɥ��@)\\u0008���d�&quot;],</span><br><span class="line">	&quot;cfdf953a68d2b070f380deaefaec4020a2851a2eebb9826f7079272f6b6edd88&quot;: [&quot;ɥ��@,\\u0006誅K���\\u0012x�ph�&quot;],</span><br><span class="line">	&quot;7a193ee83f77b5f3f484573fe8d7645066f0698cc31d9abfc80bd1ba32a9c158&quot;: [&quot;·��\\u001D3+��m�&quot;],</span><br><span class="line">	&quot;13aa89b020ddf7150202fa0bdfb9c28e9580edc3e2059eaf5ef5d12c7ac12bb2&quot;: [&quot;ͥ��&quot;],</span><br><span class="line">	&quot;2148fad735ee74a155c3b34327cde1ff3b50cd6e441f10a85babc7c9e3b9dad2&quot;: [&quot;+��\\u0007&#x27;I���&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续分析，发现 <code>Lcom/rgamtgid/hnsolues/QLwdDnU;-&gt;UGanmSarY([B)[B</code> 函数解密过程中需要成员变量 <code>GXGAvefgwV</code> 参与</p>
<img src="/2020/03/13/dexsim%E6%8F%92%E4%BB%B6-Geost/2020-03-13-15-01-28.png" class="">

<p>查找该成员变量的初始地方，发现 <code>UGanmSarY</code> 函数。</p>
<img src="/2020/03/13/dexsim%E6%8F%92%E4%BB%B6-Geost/2020-03-13-15-03-56.png" class="">

<p>该函数需要两个参数，继续找调用该函数的地方，发现在 <code>oVRoXE</code> 函数中被调用，并且 <code>oVRoXE</code> 为无参函数。</p>
<img src="/2020/03/13/dexsim%E6%8F%92%E4%BB%B6-Geost/2020-03-13-15-05-33.png" class="">

<p>到此为止找到了解密函数所需的所有参数，开始编写解密脚本以及修改 <code>dss</code> 代码，相关代码如下：</p>
<p><code>Geost.py</code> 代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import tempfile</span><br><span class="line">from json import JSONEncoder</span><br><span class="line"></span><br><span class="line">from colorclass.color import Color</span><br><span class="line">from dexsim import get_value</span><br><span class="line">from dexsim.plugin import Plugin</span><br><span class="line"></span><br><span class="line">PLUGIN_CLASS_NAME = &quot;Geost&quot;</span><br><span class="line"></span><br><span class="line"># fill-array-data v2, :array_2e</span><br><span class="line"># invoke-virtual &#123;p0, v2&#125;, Lcom/rgamtgid/hnsolues/QLwdDnU;-&gt;UGanmSarY([B)[B</span><br><span class="line"># move-result-object v2</span><br><span class="line"># invoke-direct &#123;v1, v2&#125;, Ljava/lang/String;-&gt;&lt;init&gt;([B)V</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Geost(Plugin):</span><br><span class="line">    name = PLUGIN_CLASS_NAME</span><br><span class="line">    enabled = True</span><br><span class="line">    tname = None</span><br><span class="line">    index = 3</span><br><span class="line"></span><br><span class="line">    def __init__(self, driver, smalidir):</span><br><span class="line">        Plugin.__init__(self, driver, smalidir)</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        if self.ONE_TIME:</span><br><span class="line">            return</span><br><span class="line">        self.ONE_TIME = True</span><br><span class="line">        print(&#x27;Run &#x27; + __name__, end=&#x27; &#x27;, flush=True)</span><br><span class="line"></span><br><span class="line">        regex = (</span><br><span class="line">            r&#x27;fill-array-data v\d+, :(\w+)\s+?&#x27;</span><br><span class="line">            r&#x27;invoke-virtual &#123;p0, v\d&#125;, (.*?);-&gt;(.*?)\(\[B\)\[B\s+?&#x27;</span><br><span class="line">            r&#x27;move-result-object v\d+\s+?&#x27;</span><br><span class="line">            r&#x27;invoke-direct &#123;(v\d+), v\d+&#125;, Ljava/lang/String;-&gt;&lt;init&gt;\(\[B\)V&#x27;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        ptn = re.compile(regex, re.MULTILINE)</span><br><span class="line">        for sf in self.smalidir:</span><br><span class="line">            for mtd in sf.get_methods():</span><br><span class="line">                self._process_mtd(mtd, ptn)</span><br><span class="line">        self.decode()</span><br><span class="line"></span><br><span class="line">    def _process_mtd(self, mtd, ptn):</span><br><span class="line">        body = mtd.get_body()</span><br><span class="line"></span><br><span class="line">        for item in ptn.finditer(body):</span><br><span class="line">            old_content = item.group()  # 匹配到的内容，用来替换</span><br><span class="line">            arg_pos, cname, mname, rtn_name = item.groups()</span><br><span class="line">            cname = cname[1:].replace(&#x27;/&#x27;, &#x27;.&#x27;)</span><br><span class="line">            # 通过参数位置获取参数值</span><br><span class="line">            rex = arg_pos + &#x27;\s*.array-data 1([\w\W\s]+?).end array-data&#x27;</span><br><span class="line">            ptn_arr = re.compile(rex, re.MULTILINE)</span><br><span class="line">            bjson = []</span><br><span class="line">            for it in ptn_arr.finditer(body):</span><br><span class="line">                arr = it.groups()</span><br><span class="line">                for i in arr[0].split(&quot;\n&quot;):</span><br><span class="line">                    i = i.strip()</span><br><span class="line">                    if i == &quot;&quot;:</span><br><span class="line">                        continue</span><br><span class="line">                    bjson.append(int(i.replace(&#x27;t&#x27;, &#x27;&#x27;), 16))</span><br><span class="line">            arguments = [&#x27;[B:&#x27; + str(bjson)]</span><br><span class="line">            json_item = self.get_json_item(cname, mname, arguments)</span><br><span class="line">            self.append_json_item(json_item, mtd, old_content, rtn_name)</span><br><span class="line"></span><br><span class="line">    def decode(self):</span><br><span class="line">        if not self.json_list or not self.target_contexts:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        jsons = JSONEncoder().encode(self.json_list)</span><br><span class="line"></span><br><span class="line">        outputs = &#123;&#125;</span><br><span class="line">        with tempfile.NamedTemporaryFile(mode=&#x27;w+&#x27;, delete=False) as tfile:</span><br><span class="line">            tfile.write(jsons)</span><br><span class="line">        outputs = self.driver.decode(tfile.name)</span><br><span class="line">        os.unlink(tfile.name)</span><br><span class="line"></span><br><span class="line">        if not outputs:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        for key, value in outputs.items():</span><br><span class="line">            if key not in self.target_contexts:</span><br><span class="line">                print(key, value, &quot;not in&quot;)</span><br><span class="line">                continue</span><br><span class="line">            for mtd, old_content, new_content in self.target_contexts[key]:</span><br><span class="line">                old_body = mtd.get_body()</span><br><span class="line">                new_content = new_content.format(value[0])</span><br><span class="line">                body = old_body.replace(old_content, new_content)</span><br><span class="line">                mtd.set_body(body)</span><br><span class="line">                self.make_changes = True</span><br><span class="line">                mtd.set_modified(True)</span><br><span class="line">        self.smali_files_update()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>dss</code> 相关代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object invoke(InvocationTarget target) &#123;</span><br><span class="line">    Class&lt;?&gt; clz = loadClass(target.getClassName());</span><br><span class="line">    if (clz == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method mtd = getMethod(clz, target);</span><br><span class="line">    if (mtd == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object result = null;</span><br><span class="line">    Object obj = null;</span><br><span class="line">    try&#123;</span><br><span class="line">        Constructor&lt;?&gt; con = clz.getConstructor();</span><br><span class="line">        obj = con.newInstance();</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        Object ret = null;</span><br><span class="line">        InvocationTarget aa= new InvocationTarget(null, null, &quot;oVRoXE&quot;, null, null);</span><br><span class="line">        Method init = getMethod(clz, aa);</span><br><span class="line">        init.invoke(obj,null);</span><br><span class="line">        ret = mtd.invoke(obj, target.getParameters());</span><br><span class="line">        result = new String((byte[])ret);</span><br><span class="line">    &#125; catch (IllegalAccessException ignore) &#123;</span><br><span class="line">        ignore.printStackTrace();</span><br><span class="line">    &#125; catch (InvocationTargetException ignore) &#123;</span><br><span class="line">        ignore.printStackTrace();</span><br><span class="line">    &#125; catch (ExceptionInInitializerError e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (VerifyError e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后开始解密，对应的解密结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;f2e3d508ee217c095861d260a3a9eee8f61603ed045bb4817fd28a7da11b3d9f&quot;: [&quot;getAssets&quot;],</span><br><span class="line">	&quot;38a80467b6d5b816cd91776ed8e51cce0df8a73d46bd47b7d188d1d84eaa678f&quot;: [&quot;hjgfwhd&quot;],</span><br><span class="line">	&quot;b4e499760697584cc82d02559489ce6a99e497ab066d1a2b34a33cbfce943193&quot;: [&quot;TRUE&quot;],</span><br><span class="line">	&quot;70216d6f207a1c0e370b7113334d14e9ebb12c766568369eda1a1f8afee15fc7&quot;: [&quot;/ydxwlab.jar&quot;],</span><br><span class="line">	&quot;d1cdc906ab0b7c1c64a29537e9c4020f52790b0ac1e5045eaf321e9bbfe14d6f&quot;: [&quot;mPackageInfo&quot;],</span><br><span class="line">	&quot;d0532ef95194e0763b588f5b2ac1304c5f15333bfda545f929b3c0a8885643c3&quot;: [&quot;files&quot;],</span><br><span class="line">	&quot;df2641fd22aa51c58d5150e925d75b797dac6cdd9491950a912b8c4230e22836&quot;: [&quot;getDir&quot;],</span><br><span class="line">	&quot;1c3fbc0ef0a73334f447ceb1e6eeb53afc8d38c5e054d4ceaef30ccd828b4ff3&quot;: [&quot;initial&quot;],</span><br><span class="line">	&quot;1a9a46b987f24ecf7d3be2e6501c7b6622d169a7af407a9e31ef0337bc0141d6&quot;: [&quot;dalvik.system.DexClassLoader&quot;],</span><br><span class="line">	&quot;ff3cb5db4c0284f1bfe203fee5804cd6724267b24ee7d9596f775cd5eead7c2e&quot;: [&quot;getConstructor&quot;],</span><br><span class="line">	&quot;40e2c22abf4d042c6e20a11e6ba7b2065f709005f6044ed3a4fe7835d041033a&quot;: [&quot;read&quot;],</span><br><span class="line">	&quot;d5f583b8ec55407eadf5a51dd3ff16b493fb94fae0e202ffd6000af1561bbd9f&quot;: [&quot;getAbsolutePath&quot;],</span><br><span class="line">	&quot;13a9e458bb010ab664661af1f4f08f084937847fc0768ca47ace65b17243fcb7&quot;: [&quot;close&quot;],</span><br><span class="line">	&quot;a0bcd2c1609d0cd07c8e2a41adbbb3cda932c6c6dca4bfefe481e0adbc83b0cd&quot;: [&quot;space&quot;],</span><br><span class="line">	&quot;7787842e5212469cec7aaa95cd6d8df30d34fb6d0e7a6f1713c0cb5df550f714&quot;: [&quot;java.lang.reflect.Constructor&quot;],</span><br><span class="line">	&quot;4d44e4687a94b79a8665bdf15134fd026587af5eed3ecae594fafe6f1a9d891d&quot;: [&quot;kkksdjsdnssvfsnvfsdlfkjew&quot;],</span><br><span class="line">	&quot;73101d880bbfd59702d96ecc3c47618dffdcf243bb3bd275484c002cb76e32db&quot;: [&quot;arraycopy&quot;],</span><br><span class="line">	&quot;8f03d383773c013569e3e1d910bd8c32fcbed206d3b5c7907bbb99310e33d617&quot;: [&quot;java.io.FileOutputStream&quot;],</span><br><span class="line">	&quot;83718a06bf29a60b800595e9b9ca01708b6e7147b7a3513ecf7b7daa9516c24b&quot;: [&quot;write&quot;],</span><br><span class="line">	&quot;05711d0cc4b04eb073b4401b429f20868cba513f4828112442a2c64e379252d1&quot;: [&quot;getClassLoader&quot;],</span><br><span class="line">	&quot;454cf7696e8e0c6abcb6881b67a2831a5465ee7325ee08bf70cf4cc3f42d8e9c&quot;: [&quot;dex&quot;],</span><br><span class="line">	&quot;40848d17e138ba5da879256aea50c6cda50167d856ad7c65ccfd15c60d15455b&quot;: [&quot;forName&quot;],</span><br><span class="line">	&quot;473b6b3f80874a14505ac2577547c5e7e3c96766c74f571bdd736c3844ae33c6&quot;: [&quot;.localsinfotimestamp1494987116&quot;],</span><br><span class="line">	&quot;11b2149c2d5239839c10533b4e5363f104d69b7c79c5355ea45d8c5c884dce77&quot;: [&quot;tmp_file&quot;],</span><br><span class="line">	&quot;bc84eb8f3200f991cd94bf299877f0ffdec6503b41bc344e19e354c1acb1e794&quot;: [&quot;set&quot;],</span><br><span class="line">	&quot;a47cf816863a4ecf54a03e1a6aaae35f33ddf4ba3f5139286e2bafa26bac0a6e&quot;: [&quot;%s%s&quot;],</span><br><span class="line">	&quot;43ec42d64409376307a36c21db552f5335267593004c139ea1d2d5bd14d6c224&quot;: [&quot;openNonAssetFd&quot;],</span><br><span class="line">	&quot;04e8065097330a367c4cd538afc8678d6c9ef24584d7d20c07e94cc754a88816&quot;: [&quot;delete&quot;],</span><br><span class="line">	&quot;561904e2cb0afd0008c5d16fbe3a4ba7cf0b5e5b13ba27eb8092287f0bfb96f8&quot;: [&quot;newInstance&quot;],</span><br><span class="line">	&quot;77659956a9e869a9b051ac32cc4f457066332bb0195076d4ed1a8e8019ad4041&quot;: [&quot;java.lang.Boolean&quot;],</span><br><span class="line">	&quot;c16af871c0dd1a66fc41afdc138004641939e1e2b78df4b157037466a5979423&quot;: [&quot;ozht&quot;],</span><br><span class="line">	&quot;f640b5ab7d87d84978011661e769a196fbd3198caaea6fa9263bfa745bd6dd88&quot;: [&quot;getBaseContext&quot;],</span><br><span class="line">	&quot;9153ef9514c3d163349095f4701d2cba5c06dd49c00c8a3c659d28ef81927040&quot;: [&quot;setAccessible&quot;],</span><br><span class="line">	&quot;75dd6f4f0e3b7cffb60fc0fdae51becfb27ce3d6a7ad6518db5a7fe0fb4145fb&quot;: [&quot;java.lang.ClassLoader2&quot;],</span><br><span class="line">	&quot;ce505ef1025a3c319094bfd9c0173e62448f78ab255ab4af8d11520bd8767c73&quot;: [&quot;createInputStream&quot;],</span><br><span class="line">	&quot;7a3b634862a85e9cdd1946f52e8080a613aaff393c75715971ed562f940e3e7d&quot;: [&quot;java.io.File&quot;],</span><br><span class="line">	&quot;cfdf953a68d2b070f380deaefaec4020a2851a2eebb9826f7079272f6b6edd88&quot;: [&quot;java.lang.ClassLoader&quot;],</span><br><span class="line">	&quot;7a193ee83f77b5f3f484573fe8d7645066f0698cc31d9abfc80bd1ba32a9c158&quot;: [&quot;mClassLoader&quot;],</span><br><span class="line">	&quot;13aa89b020ddf7150202fa0bdfb9c28e9580edc3e2059eaf5ef5d12c7ac12bb2&quot;: [&quot;name&quot;],</span><br><span class="line">	&quot;2148fad735ee74a155c3b34327cde1ff3b50cd6e441f10a85babc7c9e3b9dad2&quot;: [&quot;config.xml&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/03/13/dexsim%E6%8F%92%E4%BB%B6-Geost/2020-03-13-15-12-09.png" class="">]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>dex字符串解密</tag>
      </tags>
  </entry>
  <entry>
    <title>awesome-adb</title>
    <url>/2020/08/06/awesome-adb/</url>
    <content><![CDATA[<blockquote>
<p>转载：<a href="https://github.com/mzlogin/awesome-adb">https://github.com/mzlogin/awesome-adb</a></p>
</blockquote>
<!-- vim-markdown-toc GFM -->

<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a><ul>
<li><a href="#%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95">命令语法</a></li>
<li><a href="#%E4%B8%BA%E5%91%BD%E4%BB%A4%E6%8C%87%E5%AE%9A%E7%9B%AE%E6%A0%87%E8%AE%BE%E5%A4%87">为命令指定目标设备</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8%E5%81%9C%E6%AD%A2">启动&#x2F;停止</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B-adb-%E7%89%88%E6%9C%AC">查看 adb 版本</a></li>
<li><a href="#%E4%BB%A5-root-%E6%9D%83%E9%99%90%E8%BF%90%E8%A1%8C-adbd">以 root 权限运行 adbd</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A-adb-server-%E7%9A%84%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3">指定 adb server 的网络端口</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">设备连接管理</a><ul>
<li><a href="#%E6%9F%A5%E8%AF%A2%E5%B7%B2%E8%BF%9E%E6%8E%A5%E8%AE%BE%E5%A4%87%E6%A8%A1%E6%8B%9F%E5%99%A8">查询已连接设备&#x2F;模拟器</a></li>
<li><a href="#usb-%E8%BF%9E%E6%8E%A5">USB 连接</a></li>
<li><a href="#%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5%E9%9C%80%E8%A6%81%E5%80%9F%E5%8A%A9-usb-%E7%BA%BF">无线连接（需要借助 USB 线）</a></li>
<li><a href="#%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5%E6%97%A0%E9%9C%80%E5%80%9F%E5%8A%A9-usb-%E7%BA%BF">无线连接（无需借助 USB 线）</a></li>
</ul>
</li>
<li><a href="#%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86">应用管理</a><ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%88%97%E8%A1%A8">查看应用列表</a><ul>
<li><a href="#%E6%89%80%E6%9C%89%E5%BA%94%E7%94%A8">所有应用</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8">系统应用</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8">第三方应用</a></li>
<li><a href="#%E5%8C%85%E5%90%8D%E5%8C%85%E5%90%AB%E6%9F%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%94%E7%94%A8">包名包含某字符串的应用</a></li>
</ul>
</li>
<li><a href="#%E5%AE%89%E8%A3%85-apk">安装 APK</a></li>
<li><a href="#%E5%8D%B8%E8%BD%BD%E5%BA%94%E7%94%A8">卸载应用</a></li>
<li><a href="#%E6%B8%85%E9%99%A4%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BC%93%E5%AD%98">清除应用数据与缓存</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%89%8D%E5%8F%B0-activity">查看前台 Activity</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84-services">查看正在运行的 Services</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF">查看应用详细信息</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84">查看应用安装路径</a></li>
</ul>
</li>
<li><a href="#%E4%B8%8E%E5%BA%94%E7%94%A8%E4%BA%A4%E4%BA%92">与应用交互</a><ul>
<li><a href="#%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8-%E8%B0%83%E8%B5%B7-activity">启动应用&#x2F; 调起 Activity</a></li>
<li><a href="#%E8%B0%83%E8%B5%B7-service">调起 Service</a></li>
<li><a href="#%E5%81%9C%E6%AD%A2-service">停止 Service</a></li>
<li><a href="#%E5%8F%91%E9%80%81%E5%B9%BF%E6%92%AD">发送广播</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%BA%94%E7%94%A8">强制停止应用</a></li>
<li><a href="#%E6%94%B6%E7%B4%A7%E5%86%85%E5%AD%98">收紧内存</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">文件管理</a><ul>
<li><a href="#%E5%A4%8D%E5%88%B6%E8%AE%BE%E5%A4%87%E9%87%8C%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%B0%E7%94%B5%E8%84%91">复制设备里的文件到电脑</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6%E7%94%B5%E8%84%91%E9%87%8C%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%B0%E8%AE%BE%E5%A4%87">复制电脑里的文件到设备</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E6%8B%9F%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5">模拟按键&#x2F;输入</a><ul>
<li><a href="#%E7%94%B5%E6%BA%90%E9%94%AE">电源键</a></li>
<li><a href="#%E8%8F%9C%E5%8D%95%E9%94%AE">菜单键</a></li>
<li><a href="#home-%E9%94%AE">HOME 键</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E9%94%AE">返回键</a></li>
<li><a href="#%E9%9F%B3%E9%87%8F%E6%8E%A7%E5%88%B6">音量控制</a></li>
<li><a href="#%E5%AA%92%E4%BD%93%E6%8E%A7%E5%88%B6">媒体控制</a></li>
<li><a href="#%E7%82%B9%E4%BA%AE%E7%86%84%E7%81%AD%E5%B1%8F%E5%B9%95">点亮&#x2F;熄灭屏幕</a></li>
<li><a href="#%E6%BB%91%E5%8A%A8%E8%A7%A3%E9%94%81">滑动解锁</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%96%87%E6%9C%AC">输入文本</a></li>
</ul>
</li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97">查看日志</a><ul>
<li><a href="#android-%E6%97%A5%E5%BF%97">Android 日志</a><ul>
<li><a href="#%E6%8C%89%E7%BA%A7%E5%88%AB%E8%BF%87%E6%BB%A4%E6%97%A5%E5%BF%97">按级别过滤日志</a></li>
<li><a href="#%E6%8C%89-tag-%E5%92%8C%E7%BA%A7%E5%88%AB%E8%BF%87%E6%BB%A4%E6%97%A5%E5%BF%97">按 tag 和级别过滤日志</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F">日志格式</a></li>
<li><a href="#%E6%B8%85%E7%A9%BA%E6%97%A5%E5%BF%97">清空日志</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E6%A0%B8%E6%97%A5%E5%BF%97">内核日志</a></li>
</ul>
</li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF">查看设备信息</a><ul>
<li><a href="#%E5%9E%8B%E5%8F%B7">型号</a></li>
<li><a href="#%E7%94%B5%E6%B1%A0%E7%8A%B6%E5%86%B5">电池状况</a></li>
<li><a href="#%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87">屏幕分辨率</a></li>
<li><a href="#%E5%B1%8F%E5%B9%95%E5%AF%86%E5%BA%A6">屏幕密度</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%8F%82%E6%95%B0">显示屏参数</a></li>
<li><a href="#android_id">android_id</a></li>
<li><a href="#imei">IMEI</a></li>
<li><a href="#android-%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC">Android 系统版本</a></li>
<li><a href="#ip-%E5%9C%B0%E5%9D%80">IP 地址</a></li>
<li><a href="#mac-%E5%9C%B0%E5%9D%80">Mac 地址</a></li>
<li><a href="#cpu-%E4%BF%A1%E6%81%AF">CPU 信息</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF">内存信息</a></li>
<li><a href="#%E6%9B%B4%E5%A4%9A%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7">更多硬件与系统属性</a></li>
</ul>
</li>
<li><a href="#%E4%BF%AE%E6%94%B9%E8%AE%BE%E7%BD%AE">修改设置</a><ul>
<li><a href="#%E5%88%86%E8%BE%A8%E7%8E%87">分辨率</a></li>
<li><a href="#%E5%B1%8F%E5%B9%95%E5%AF%86%E5%BA%A6-1">屏幕密度</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA%E5%8C%BA%E5%9F%9F">显示区域</a></li>
<li><a href="#%E5%85%B3%E9%97%AD-usb-%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F">关闭 USB 调试模式</a></li>
<li><a href="#%E5%85%81%E8%AE%B8%E7%A6%81%E6%AD%A2%E8%AE%BF%E9%97%AE%E9%9D%9E-sdk-api">允许&#x2F;禁止访问非 SDK API</a></li>
<li><a href="#%E7%8A%B6%E6%80%81%E6%A0%8F%E5%92%8C%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%9A%84%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F">状态栏和导航栏的显示隐藏</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD">实用功能</a><ul>
<li><a href="#%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">屏幕截图</a></li>
<li><a href="#%E5%BD%95%E5%88%B6%E5%B1%8F%E5%B9%95">录制屏幕</a></li>
<li><a href="#%E9%87%8D%E6%96%B0%E6%8C%82%E8%BD%BD-system-%E5%88%86%E5%8C%BA%E4%B8%BA%E5%8F%AF%E5%86%99">重新挂载 system 分区为可写</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%9A%84-wifi-%E5%AF%86%E7%A0%81">查看连接过的 WiFi 密码</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4">设置系统日期和时间</a></li>
<li><a href="#%E9%87%8D%E5%90%AF%E6%89%8B%E6%9C%BA">重启手机</a></li>
<li><a href="#%E6%A3%80%E6%B5%8B%E8%AE%BE%E5%A4%87%E6%98%AF%E5%90%A6%E5%B7%B2-root">检测设备是否已 root</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-monkey-%E8%BF%9B%E8%A1%8C%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95">使用 Monkey 进行压力测试</a></li>
<li><a href="#%E5%BC%80%E5%90%AF%E5%85%B3%E9%97%AD-wifi">开启&#x2F;关闭 WiFi</a></li>
</ul>
</li>
<li><a href="#%E5%88%B7%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">刷机相关命令</a><ul>
<li><a href="#%E9%87%8D%E5%90%AF%E5%88%B0-recovery-%E6%A8%A1%E5%BC%8F">重启到 Recovery 模式</a></li>
<li><a href="#%E4%BB%8E-recovery-%E9%87%8D%E5%90%AF%E5%88%B0-android">从 Recovery 重启到 Android</a></li>
<li><a href="#%E9%87%8D%E5%90%AF%E5%88%B0-fastboot-%E6%A8%A1%E5%BC%8F">重启到 Fastboot 模式</a></li>
<li><a href="#%E9%80%9A%E8%BF%87-sideload-%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F">通过 sideload 更新系统</a></li>
</ul>
</li>
<li><a href="#%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">安全相关命令</a><ul>
<li><a href="#%E5%90%AF%E7%94%A8%E7%A6%81%E7%94%A8-selinux">启用&#x2F;禁用 SELinux</a></li>
<li><a href="#%E5%90%AF%E7%94%A8%E7%A6%81%E7%94%A8-dm_verity">启用&#x2F;禁用 dm_verity</a></li>
</ul>
</li>
<li><a href="#%E6%9B%B4%E5%A4%9A-adb-shell-%E5%91%BD%E4%BB%A4">更多 adb shell 命令</a><ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B">查看进程</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%AE%9E%E6%97%B6%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5">查看实时资源占用情况</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B-uid">查看进程 UID</a></li>
<li><a href="#%E5%85%B6%E5%AE%83">其它</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a><ul>
<li><a href="#%E5%90%AF%E5%8A%A8-adb-server-%E5%A4%B1%E8%B4%A5">启动 adb server 失败</a></li>
<li><a href="#comandroidddmlibadbcommandrejectedexception">com.android.ddmlib.AdbCommandRejectedException</a></li>
</ul>
</li>
<li><a href="#adb-%E7%9A%84%E9%9D%9E%E5%AE%98%E6%96%B9%E5%AE%9E%E7%8E%B0">adb 的非官方实现</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">相关命令</a></li>
<li><a href="#%E8%87%B4%E8%B0%A2">致谢</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>
</ul>
<!-- vim-markdown-toc -->

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h3><p>adb 命令的基本语法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb [-d|-e|-s &lt;serialNumber&gt;] &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>

<p>如果只有一个设备&#x2F;模拟器连接时，可以省略掉 <code>[-d|-e|-s &lt;serialNumber&gt;]</code> 这一部分，直接使用 <code>adb &lt;command&gt;</code>。</p>
<h3 id="为命令指定目标设备"><a href="#为命令指定目标设备" class="headerlink" title="为命令指定目标设备"></a>为命令指定目标设备</h3><p>如果有多个设备&#x2F;模拟器连接，则需要为命令指定目标设备。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>指定当前唯一通过 USB 连接的 Android 设备为命令目标</td>
</tr>
<tr>
<td>-e</td>
<td>指定当前唯一运行的模拟器为命令目标</td>
</tr>
<tr>
<td><code>-s &lt;serialNumber&gt;</code></td>
<td>指定相应 serialNumber 号的设备&#x2F;模拟器为命令目标</td>
</tr>
</tbody></table>
<p>在多个设备&#x2F;模拟器连接的情况下较常用的是 <code>-s &lt;serialNumber&gt;</code> 参数，serialNumber 可以通过 <code>adb devices</code> 命令获取。如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line"></span><br><span class="line">List of devices attached</span><br><span class="line">cf264b8f	device</span><br><span class="line">emulator-5554	device</span><br><span class="line">10.129.164.6:5555	device</span><br></pre></td></tr></table></figure>

<p>输出里的 <code>cf264b8f</code>、<code>emulator-5554</code> 和 <code>10.129.164.6:5555</code> 即为 serialNumber。</p>
<p>比如这时想指定 <code>cf264b8f</code> 这个设备来运行 adb 命令获取屏幕分辨率：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb -s cf264b8f shell wm size</span><br></pre></td></tr></table></figure>

<p>又如想给 <code>10.129.164.6:5555</code> 这个设备安装应用（<em>这种形式的 serialNumber 格式为 <code>&lt;IP&gt;:&lt;Port&gt;</code>，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器</em>）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb -s 10.129.164.6:5555 install test.apk</span><br></pre></td></tr></table></figure>

<p><strong>遇到多设备&#x2F;模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。</strong></p>
<h3 id="启动-x2F-停止"><a href="#启动-x2F-停止" class="headerlink" title="启动&#x2F;停止"></a>启动&#x2F;停止</h3><p>启动 adb server 命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb start-server</span><br></pre></td></tr></table></figure>

<p>（一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。）</p>
<p>停止 adb server 命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb kill-server</span><br></pre></td></tr></table></figure>

<h3 id="查看-adb-版本"><a href="#查看-adb-版本" class="headerlink" title="查看 adb 版本"></a>查看 adb 版本</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb version</span><br></pre></td></tr></table></figure>

<p>示例输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Android Debug Bridge version 1.0.36</span><br><span class="line">Revision 8f855a3d9b35-android</span><br></pre></td></tr></table></figure>

<h3 id="以-root-权限运行-adbd"><a href="#以-root-权限运行-adbd" class="headerlink" title="以 root 权限运行 adbd"></a>以 root 权限运行 adbd</h3><p>adb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。</p>
<p>所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 <code>adb xxx</code> 执行。这时可以 <code>adb shell</code> 然后 <code>su</code> 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb root</span><br></pre></td></tr></table></figure>

<p>正常输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">restarting adbd as root</span><br></pre></td></tr></table></figure>

<p>现在再运行 <code>adb shell</code>，看看命令行提示符是不是变成 <code>#</code> 了？</p>
<p>有些手机 root 后也无法通过 <code>adb root</code> 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 <code>adbd cannot run as root in production builds</code>，此时可以先安装 adbd Insecure，然后 <code>adb root</code> 试试。</p>
<p>相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 <code>adb unroot</code> 命令。</p>
<h3 id="指定-adb-server-的网络端口"><a href="#指定-adb-server-的网络端口" class="headerlink" title="指定 adb server 的网络端口"></a>指定 adb server 的网络端口</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb -P &lt;port&gt; start-server</span><br></pre></td></tr></table></figure>

<p>默认端口为 5037。</p>
<h2 id="设备连接管理"><a href="#设备连接管理" class="headerlink" title="设备连接管理"></a>设备连接管理</h2><h3 id="查询已连接设备-x2F-模拟器"><a href="#查询已连接设备-x2F-模拟器" class="headerlink" title="查询已连接设备&#x2F;模拟器"></a>查询已连接设备&#x2F;模拟器</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">cf264b8f	device</span><br><span class="line">emulator-5554	device</span><br><span class="line">10.129.164.6:5555	device</span><br></pre></td></tr></table></figure>

<p>输出格式为 <code>[serialNumber] [state]</code>，serialNumber 即我们常说的 SN，state 有如下几种：</p>
<ul>
<li><p><code>offline</code> —— 表示设备未连接成功或无响应。</p>
</li>
<li><p><code>device</code> —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。</p>
</li>
<li><p><code>no device</code> —— 没有设备&#x2F;模拟器连接。</p>
</li>
</ul>
<p>以上输出显示当前已经连接了三台设备&#x2F;模拟器，<code>cf264b8f</code>、<code>emulator-5554</code> 和 <code>10.129.164.6:5555</code> 分别是它们的 SN。从 <code>emulator-5554</code> 这个名字可以看出它是一个 Android 模拟器，而 <code>10.129.164.6:5555</code> 这种形为 <code>&lt;IP&gt;:&lt;Port&gt;</code> 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。</p>
<p>常见异常输出：</p>
<ol>
<li><p>没有设备&#x2F;模拟器连接成功。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">List of devices attached</span><br></pre></td></tr></table></figure>
</li>
<li><p>设备&#x2F;模拟器未连接到 adb 或无响应。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">cf264b8f	offline</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="USB-连接"><a href="#USB-连接" class="headerlink" title="USB 连接"></a>USB 连接</h3><p>通过 USB 连接来正常使用 adb 需要保证几点：</p>
<ol>
<li><p>硬件状态正常。</p>
<p>包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。</p>
</li>
<li><p>Android 设备的开发者选项和 USB 调试模式已开启。</p>
<p>可以到「设置」-「开发者选项」-「Android 调试」查看。</p>
<p>如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。</p>
</li>
<li><p>设备驱动状态正常。</p>
<p>这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。</p>
</li>
<li><p>通过 USB 线连接好电脑和设备后确认状态。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<p>如果能看到</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xxxxxx device</span><br></pre></td></tr></table></figure>

<p>说明连接成功。</p>
</li>
</ol>
<h3 id="无线连接（需要借助-USB-线）"><a href="#无线连接（需要借助-USB-线）" class="headerlink" title="无线连接（需要借助 USB 线）"></a>无线连接（需要借助 USB 线）</h3><p>除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！</p>
<p>操作步骤：</p>
<ol>
<li><p>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</p>
</li>
<li><p>将设备与电脑通过 USB 线连接。</p>
<p>应确保连接成功（可运行 <code>adb devices</code> 看是否能列出该设备）。</p>
</li>
<li><p>让设备在 5555 端口监听 TCP&#x2F;IP 连接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb tcpip 5555</span><br></pre></td></tr></table></figure>
</li>
<li><p>断开 USB 连接。</p>
</li>
<li><p>找到设备的 IP 地址。</p>
<p>一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 <a href="#ip-%E5%9C%B0%E5%9D%80">查看设备信息 - IP 地址</a> 一节里的方法用 adb 命令来查看。</p>
</li>
<li><p>通过 IP 地址连接设备。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb connect &lt;device-ip-address&gt;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>&lt;device-ip-address&gt;</code> 就是上一步中找到的设备 IP 地址。</p>
</li>
<li><p>确认连接状态。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<p>如果能看到</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;device-ip-address&gt;:5555 device</span><br></pre></td></tr></table></figure>

<p>说明连接成功。</p>
</li>
</ol>
<p>如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 <code>adb connect &lt;device-ip-address&gt;</code> 那一步；</p>
<p>如果还是不行的话，通过 <code>adb kill-server</code> 重新启动 adb 然后从头再来一次试试。</p>
<p><strong>断开无线连接</strong></p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb disconnect &lt;device-ip-address&gt;</span><br></pre></td></tr></table></figure>

<h3 id="无线连接（无需借助-USB-线）"><a href="#无线连接（无需借助-USB-线）" class="headerlink" title="无线连接（无需借助 USB 线）"></a>无线连接（无需借助 USB 线）</h3><p><strong>注：需要 root 权限。</strong></p>
<p>上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。</p>
<p>既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。</p>
<ol>
<li><p>在 Android 设备上安装一个终端模拟器。</p>
<p>已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：<a href="https://jackpal.github.io/Android-Terminal-Emulator/">Terminal Emulator for Android Downloads</a></p>
</li>
<li><p>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</p>
</li>
<li><p>打开 Android 设备上的终端模拟器，在里面依次运行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">su</span><br><span class="line">setprop service.adb.tcp.port 5555</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到 Android 设备的 IP 地址。</p>
<p>一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 <a href="#ip-%E5%9C%B0%E5%9D%80">查看设备信息 - IP 地址</a> 一节里的方法用 adb 命令来查看。</p>
</li>
<li><p>在电脑上通过 adb 和 IP 地址连接 Android 设备。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb connect &lt;device-ip-address&gt;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>&lt;device-ip-address&gt;</code> 就是上一步中找到的设备 IP 地址。</p>
<p>如果能看到 <code>connected to &lt;device-ip-address&gt;:5555</code> 这样的输出则表示连接成功。</p>
</li>
</ol>
<p><em>节注一：</em></p>
<p>有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">restart adbd</span><br></pre></td></tr></table></figure>

<p>如果 restart 无效，尝试以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">stop adbd</span><br><span class="line">start adbd</span><br></pre></td></tr></table></figure>

<h2 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h2><h3 id="查看应用列表"><a href="#查看应用列表" class="headerlink" title="查看应用列表"></a>查看应用列表</h3><p>查看应用列表的基本命令格式是</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER]</span><br></pre></td></tr></table></figure>

<p>即在 <code>adb shell pm list packages</code> 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示列表</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>所有应用</td>
</tr>
<tr>
<td>-f</td>
<td>显示应用关联的 apk 文件</td>
</tr>
<tr>
<td>-d</td>
<td>只显示 disabled 的应用</td>
</tr>
<tr>
<td>-e</td>
<td>只显示 enabled 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>只显示系统应用</td>
</tr>
<tr>
<td>-3</td>
<td>只显示第三方应用</td>
</tr>
<tr>
<td>-i</td>
<td>显示应用的 installer</td>
</tr>
<tr>
<td>-u</td>
<td>包含已卸载应用</td>
</tr>
<tr>
<td><code>&lt;FILTER&gt;</code></td>
<td>包名包含 <code>&lt;FILTER&gt;</code> 字符串</td>
</tr>
</tbody></table>
<h4 id="所有应用"><a href="#所有应用" class="headerlink" title="所有应用"></a>所有应用</h4><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">package:com.android.smoketest</span><br><span class="line">package:com.example.android.livecubes</span><br><span class="line">package:com.android.providers.telephony</span><br><span class="line">package:com.google.android.googlequicksearchbox</span><br><span class="line">package:com.android.providers.calendar</span><br><span class="line">package:com.android.providers.media</span><br><span class="line">package:com.android.protips</span><br><span class="line">package:com.android.documentsui</span><br><span class="line">package:com.android.gallery</span><br><span class="line">package:com.android.externalstorage</span><br><span class="line">...</span><br><span class="line">// other packages here</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="系统应用"><a href="#系统应用" class="headerlink" title="系统应用"></a>系统应用</h4><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -s</span><br></pre></td></tr></table></figure>

<h4 id="第三方应用"><a href="#第三方应用" class="headerlink" title="第三方应用"></a>第三方应用</h4><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -3</span><br></pre></td></tr></table></figure>

<h4 id="包名包含某字符串的应用"><a href="#包名包含某字符串的应用" class="headerlink" title="包名包含某字符串的应用"></a>包名包含某字符串的应用</h4><p>比如要查看包名包含字符串 <code>mazhuang</code> 的应用列表，命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages mazhuang</span><br></pre></td></tr></table></figure>

<p>当然也可以使用 grep 来过滤：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages | grep mazhuang</span><br></pre></td></tr></table></figure>

<h3 id="安装-APK"><a href="#安装-APK" class="headerlink" title="安装 APK"></a>安装 APK</h3><p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb install [-lrtsdg] &lt;path_to_apk&gt;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p><code>adb install</code> 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>将应用安装到保护目录 &#x2F;mnt&#x2F;asec</td>
</tr>
<tr>
<td>-r</td>
<td>允许覆盖安装</td>
</tr>
<tr>
<td>-t</td>
<td>允许安装 AndroidManifest.xml 里 application 指定 <code>android:testOnly=&quot;true&quot;</code> 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>将应用安装到 sdcard</td>
</tr>
<tr>
<td>-d</td>
<td>允许降级覆盖安装</td>
</tr>
<tr>
<td>-g</td>
<td>授予所有运行时权限</td>
</tr>
</tbody></table>
<p>运行命令后如果见到类似如下输出（状态为 <code>Success</code>）代表安装成功：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[100%] /data/local/tmp/1.apk</span><br><span class="line">	pkg: /data/local/tmp/1.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure>

<p>上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。</p>
<p>使用旧版本 adb 的输出则是这样的：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">12040 KB/s (22205609 bytes <span class="keyword">in</span> 1.801s)</span><br><span class="line">        pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure>

<p>而如果状态为 <code>Failure</code> 则表示安装失败，比如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[100%] /data/local/tmp/map-20160831.apk</span><br><span class="line">        pkg: /data/local/tmp/map-20160831.apk</span><br><span class="line">Failure [INSTALL_FAILED_ALREADY_EXISTS]</span><br></pre></td></tr></table></figure>

<p>常见安装失败输出代码、含义及可能的解决办法如下：</p>
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
<th>解决办法</th>
</tr>
</thead>
<tbody><tr>
<td>INSTALL_FAILED_ALREADY_EXISTS</td>
<td>应用已经存在，或卸载了但没卸载干净</td>
<td><code>adb install</code> 时使用 <code>-r</code> 参数，或者先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_APK</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_URI</td>
<td>无效的 APK 文件名</td>
<td>确保 APK 文件名里无中文</td>
</tr>
<tr>
<td>INSTALL_FAILED_INSUFFICIENT_STORAGE</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PACKAGE</td>
<td>已经存在同名程序</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_SHARED_USER</td>
<td>请求的共享用户不存在</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UPDATE_INCOMPATIBLE</td>
<td>以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致</td>
<td>先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_SHARED_USER_INCOMPATIBLE</td>
<td>请求的共享用户存在但签名不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_SHARED_LIBRARY</td>
<td>安装包使用了设备上不可用的共享库</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_REPLACE_COULDNT_DELETE</td>
<td>替换时无法删除</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DEXOPT</td>
<td>dex 优化验证失败或空间不足</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_OLDER_SDK</td>
<td>设备系统版本低于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONFLICTING_PROVIDER</td>
<td>设备里已经存在与应用里同名的 content provider</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NEWER_SDK</td>
<td>设备系统版本高于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>应用是 test-only 的，但安装时没有指定 <code>-t</code> 参数</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CPU_ABI_INCOMPATIBLE</td>
<td>包含不兼容设备 CPU 应用程序二进制接口的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_FEATURE</td>
<td>应用使用了设备不可用的功能</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONTAINER_ERROR</td>
<td>1. sdcard 访问失败;<br />2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 确认 sdcard 可用，或者安装到内置存储;<br />2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_INSTALL_LOCATION</td>
<td>1. 不能安装到指定位置;<br />2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 切换安装位置，添加或删除 <code>-s</code> 参数;<br />2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_MEDIA_UNAVAILABLE</td>
<td>安装位置不可用</td>
<td>一般为 sdcard，确认 sdcard 可用或安装到内置存储</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_TIMEOUT</td>
<td>验证安装包超时</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_FAILURE</td>
<td>验证安装包失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_PACKAGE_CHANGED</td>
<td>应用与调用程序期望的不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UID_CHANGED</td>
<td>以前安装过该应用，与本次分配的 UID 不一致</td>
<td>清除以前安装过的残留文件</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERSION_DOWNGRADE</td>
<td>已经安装了该应用更高版本</td>
<td>使用 <code>-d</code> 参数</td>
</tr>
<tr>
<td>INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE</td>
<td>已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NOT_APK</td>
<td>指定路径不是文件，或不是以 <code>.apk</code> 结尾</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_MANIFEST</td>
<td>无法解析的 AndroidManifest.xml 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION</td>
<td>解析器遇到异常</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NO_CERTIFICATES</td>
<td>安装包没有签名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES</td>
<td>已安装该应用，且签名与 APK 文件不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING</td>
<td>解析 APK 文件时遇到 <code>CertificateEncodingException</code></td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME</td>
<td>manifest 文件里没有或者使用了无效的包名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID</td>
<td>manifest 文件里指定了无效的共享用户 ID</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_MALFORMED</td>
<td>解析 manifest 文件时遇到结构性错误</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_EMPTY</td>
<td>在 manifest 文件里找不到找可操作标签（instrumentation 或 application）</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INTERNAL_ERROR</td>
<td>因系统问题安装失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_USER_RESTRICTED</td>
<td>用户被限制安装应用</td>
<td>在开发者选项里将「USB安装」打开，如果已经打开了，那先关闭再打开。</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PERMISSION</td>
<td>应用尝试定义一个已经存在的权限名称</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_MATCHING_ABIS</td>
<td>应用包含设备的应用程序二进制接口不支持的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_CANCELED_BY_USER</td>
<td>应用安装需要在设备上确认，但未操作设备或点了取消</td>
<td>在设备上同意安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_ACWF_INCOMPATIBLE</td>
<td>应用程序与设备不兼容</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>APK 文件是使用 Android Studio 直接 RUN 编译出来的文件</td>
<td>通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK</td>
</tr>
<tr>
<td>does not contain AndroidManifest.xml</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>is not a valid zip file</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>Offline</td>
<td>设备未连接成功</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>unauthorized</td>
<td>设备未授权允许调试</td>
<td></td>
</tr>
<tr>
<td>error: device not found</td>
<td>没有连接成功的设备</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>protocol failure</td>
<td>设备已断开连接</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>Unknown option: -s</td>
<td>Android 2.2 以下不支持安装到 sdcard</td>
<td>不使用 <code>-s</code> 参数</td>
</tr>
<tr>
<td>No space left on device</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>Permission denied … sdcard …</td>
<td>sdcard 不可用</td>
<td></td>
</tr>
<tr>
<td>signatures do not match the previously installed version; ignoring!</td>
<td>已安装该应用且签名不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
</tbody></table>
<p>参考：<a href="https://github.com/android/platform_frameworks_base/blob/master/core%2Fjava%2Fandroid%2Fcontent%2Fpm%2FPackageManager.java">PackageManager.java</a></p>
<p><em><code>adb install</code> 内部原理简介</em></p>
<p><code>adb install</code> 实际是分三步完成：</p>
<ol>
<li><p>push apk 文件到 &#x2F;data&#x2F;local&#x2F;tmp。</p>
</li>
<li><p>调用 pm install 安装。</p>
</li>
<li><p>删除 &#x2F;data&#x2F;local&#x2F;tmp 下的对应 apk 文件。</p>
</li>
</ol>
<p>所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。</p>
<h3 id="卸载应用"><a href="#卸载应用" class="headerlink" title="卸载应用"></a>卸载应用</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb uninstall [-k] &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;packagename&gt;</code> 表示应用的包名，<code>-k</code> 参数可选，表示卸载应用但保留数据和缓存目录。</p>
<p>命令示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb uninstall com.qihoo360.mobilesafe</span><br></pre></td></tr></table></figure>

<p>表示卸载 360 手机卫士。</p>
<h3 id="清除应用数据与缓存"><a href="#清除应用数据与缓存" class="headerlink" title="清除应用数据与缓存"></a>清除应用数据与缓存</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm clear &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;packagename&gt;</code> 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</p>
<p>命令示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm clear com.qihoo360.mobilesafe</span><br></pre></td></tr></table></figure>

<p>表示清除 360 手机卫士的数据和缓存。</p>
<h3 id="查看前台-Activity"><a href="#查看前台-Activity" class="headerlink" title="查看前台 Activity"></a>查看前台 Activity</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity activities | grep mResumedActivity</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mResumedActivity: ActivityRecord&#123;8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42&#125;</span><br></pre></td></tr></table></figure>

<p>其中的 <code>com.cyanogenmod.trebuchet/com.android.launcher3.Launcher</code> 就是当前处于前台的 Activity。</p>
<p><em>在 Windows 下以上命令可能不可用，可以尝试 <code>adb shell dumpsys activity activities | findstr mResumedActivity</code> 或 <code>adb shell &quot;dumpsys activity activities | grep mResumedActivity&quot;</code>。</em></p>
<h3 id="查看正在运行的-Services"><a href="#查看正在运行的-Services" class="headerlink" title="查看正在运行的 Services"></a>查看正在运行的 Services</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity services [&lt;packagename&gt;]</span><br></pre></td></tr></table></figure>

<p><code>&lt;packagename&gt;</code> 参数不是必须的，指定 <code>&lt;packagename&gt;</code> 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。</p>
<p><code>&lt;packagename&gt;</code> 不一定要给出完整的包名，比如运行 <code>adb shell dumpsys activity services org.mazhuang</code>，那么包名 <code>org.mazhuang.demo1</code>、<code>org.mazhuang.demo2</code> 和 <code>org.mazhuang123</code> 等相关的 Services 都会列出来。</p>
<h3 id="查看应用详细信息"><a href="#查看应用详细信息" class="headerlink" title="查看应用详细信息"></a>查看应用详细信息</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys package &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<p>输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。</p>
<p><code>&lt;packagename&gt;</code> 表示应用包名。</p>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Activity Resolver Table:</span><br><span class="line">  Non-Data Actions:</span><br><span class="line">      android.intent.action.MAIN:</span><br><span class="line">        5b4cba8 org.mazhuang.guanggoo/.SplashActivity filter 5ec9dcc</span><br><span class="line">          Action: <span class="string">&quot;android.intent.action.MAIN&quot;</span></span><br><span class="line">          Category: <span class="string">&quot;android.intent.category.LAUNCHER&quot;</span></span><br><span class="line">          AutoVerify=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Registered ContentProviders:</span><br><span class="line">  org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider:</span><br><span class="line">    Provider&#123;7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider&#125;</span><br><span class="line"></span><br><span class="line">ContentProvider Authorities:</span><br><span class="line">  [org.mazhuang.guanggoo.fileProvider]:</span><br><span class="line">    Provider&#123;7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider&#125;</span><br><span class="line">      applicationInfo=ApplicationInfo&#123;7754242 org.mazhuang.guanggoo&#125;</span><br><span class="line"></span><br><span class="line">Key Set Manager:</span><br><span class="line">  [org.mazhuang.guanggoo]</span><br><span class="line">      Signing KeySets: 501</span><br><span class="line"></span><br><span class="line">Packages:</span><br><span class="line">  Package [org.mazhuang.guanggoo] (c1d7f):</span><br><span class="line">    userId=10394</span><br><span class="line">    pkg=Package&#123;55f714c org.mazhuang.guanggoo&#125;</span><br><span class="line">    codePath=/data/app/org.mazhuang.guanggoo-2</span><br><span class="line">    resourcePath=/data/app/org.mazhuang.guanggoo-2</span><br><span class="line">    legacyNativeLibraryDir=/data/app/org.mazhuang.guanggoo-2/lib</span><br><span class="line">    primaryCpuAbi=null</span><br><span class="line">    secondaryCpuAbi=null</span><br><span class="line">    versionCode=74 minSdk=15 targetSdk=25</span><br><span class="line">    versionName=1.1.74</span><br><span class="line">    splits=[base]</span><br><span class="line">    apkSigningVersion=2</span><br><span class="line">    applicationInfo=ApplicationInfo&#123;7754242 org.mazhuang.guanggoo&#125;</span><br><span class="line">    flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ]</span><br><span class="line">    privateFlags=[ RESIZEABLE_ACTIVITIES ]</span><br><span class="line">    dataDir=/data/user/0/org.mazhuang.guanggoo</span><br><span class="line">    supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity]</span><br><span class="line">    timeStamp=2017-10-22 23:50:53</span><br><span class="line">    firstInstallTime=2017-10-22 23:50:25</span><br><span class="line">    lastUpdateTime=2017-10-22 23:50:55</span><br><span class="line">    installerPackageName=com.miui.packageinstaller</span><br><span class="line">    signatures=PackageSignatures&#123;af09595 [53c7caa2]&#125;</span><br><span class="line">    installPermissionsFixed=<span class="literal">true</span> installStatus=1</span><br><span class="line">    pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ]</span><br><span class="line">    requested permissions:</span><br><span class="line">      android.permission.READ_PHONE_STATE</span><br><span class="line">      android.permission.INTERNET</span><br><span class="line">      android.permission.ACCESS_NETWORK_STATE</span><br><span class="line">      android.permission.ACCESS_WIFI_STATE</span><br><span class="line">      android.permission.READ_LOGS</span><br><span class="line">      android.permission.WRITE_EXTERNAL_STORAGE</span><br><span class="line">      android.permission.READ_EXTERNAL_STORAGE</span><br><span class="line">    install permissions:</span><br><span class="line">      android.permission.INTERNET: granted=<span class="literal">true</span></span><br><span class="line">      android.permission.ACCESS_NETWORK_STATE: granted=<span class="literal">true</span></span><br><span class="line">      android.permission.ACCESS_WIFI_STATE: granted=<span class="literal">true</span></span><br><span class="line">    User 0: ceDataInode=1155675 installed=<span class="literal">true</span> hidden=<span class="literal">false</span> suspended=<span class="literal">false</span> stopped=<span class="literal">true</span> notLaunched=<span class="literal">false</span> enabled=0</span><br><span class="line">      gids=[3003]</span><br><span class="line">      runtime permissions:</span><br><span class="line">        android.permission.READ_EXTERNAL_STORAGE: granted=<span class="literal">true</span></span><br><span class="line">        android.permission.READ_PHONE_STATE: granted=<span class="literal">true</span></span><br><span class="line">        android.permission.WRITE_EXTERNAL_STORAGE: granted=<span class="literal">true</span></span><br><span class="line">    User 999: ceDataInode=0 installed=<span class="literal">false</span> hidden=<span class="literal">false</span> suspended=<span class="literal">false</span> stopped=<span class="literal">true</span> notLaunched=<span class="literal">true</span> enabled=0</span><br><span class="line">      gids=[3003]</span><br><span class="line">      runtime permissions:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dexopt state:</span><br><span class="line">  [org.mazhuang.guanggoo]</span><br><span class="line">    Instruction Set: arm64</span><br><span class="line">      path: /data/app/org.mazhuang.guanggoo-2/base.apk</span><br><span class="line">      status: /data/app/org.mazhuang.guanggoo-2/oat/arm64/base.odex [compilation_filter=speed-profile, status=kOatUpToDa</span><br><span class="line">      te]</span><br></pre></td></tr></table></figure>

<h3 id="查看应用安装路径"><a href="#查看应用安装路径" class="headerlink" title="查看应用安装路径"></a>查看应用安装路径</h3><p>命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm path &lt;PACKAGE&gt;</span><br></pre></td></tr></table></figure>

<p>输出应用安装路径</p>
<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm path ecarx.weather</span><br><span class="line"></span><br><span class="line">package:/data/app/ecarx.weather-1.apk</span><br></pre></td></tr></table></figure>

<h2 id="与应用交互"><a href="#与应用交互" class="headerlink" title="与应用交互"></a>与应用交互</h2><p>主要是使用 <code>am &lt;command&gt;</code> 命令，常用的 <code>&lt;command&gt;</code> 如下：</p>
<table>
<thead>
<tr>
<th>command</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>start [options] &lt;INTENT&gt;</code></td>
<td>启动 <code>&lt;INTENT&gt;</code> 指定的 Activity</td>
</tr>
<tr>
<td><code>startservice [options] &lt;INTENT&gt;</code></td>
<td>启动 <code>&lt;INTENT&gt;</code> 指定的 Service</td>
</tr>
<tr>
<td><code>broadcast [options] &lt;INTENT&gt;</code></td>
<td>发送 <code>&lt;INTENT&gt;</code> 指定的广播</td>
</tr>
<tr>
<td><code>force-stop &lt;packagename&gt;</code></td>
<td>停止 <code>&lt;packagename&gt;</code> 相关的进程</td>
</tr>
</tbody></table>
<p><code>&lt;INTENT&gt;</code> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</p>
<p>用于决定 intent 对象的选项如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-a &lt;ACTION&gt;</code></td>
<td>指定 action，比如 <code>android.intent.action.VIEW</code></td>
</tr>
<tr>
<td><code>-c &lt;CATEGORY&gt;</code></td>
<td>指定 category，比如 <code>android.intent.category.APP_CONTACTS</code></td>
</tr>
<tr>
<td><code>-n &lt;COMPONENT&gt;</code></td>
<td>指定完整 component 名，用于明确指定启动哪个 Activity，如 <code>com.example.app/.ExampleActivity</code></td>
</tr>
</tbody></table>
<p><code>&lt;INTENT&gt;</code> 里还能带数据，就像写代码时的 Bundle 一样：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>--esn &lt;EXTRA_KEY&gt;</code></td>
<td>null 值（只有 key 名）</td>
</tr>
<tr>
<td>&#96;-e</td>
<td>–es <EXTRA_KEY> <EXTRA_STRING_VALUE>&#96;</td>
</tr>
<tr>
<td><code>--ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt;</code></td>
<td>boolean 值</td>
</tr>
<tr>
<td><code>--ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;</code></td>
<td>integer 值</td>
</tr>
<tr>
<td><code>--el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;</code></td>
<td>long 值</td>
</tr>
<tr>
<td><code>--ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt;</code></td>
<td>float 值</td>
</tr>
<tr>
<td><code>--eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt;</code></td>
<td>URI</td>
</tr>
<tr>
<td><code>--ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt;</code></td>
<td>component name</td>
</tr>
<tr>
<td><code>--eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...]</code></td>
<td>integer 数组</td>
</tr>
<tr>
<td><code>--ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...]</code></td>
<td>long 数组</td>
</tr>
</tbody></table>
<h3 id="启动应用-x2F-调起-Activity"><a href="#启动应用-x2F-调起-Activity" class="headerlink" title="启动应用&#x2F; 调起 Activity"></a>启动应用&#x2F; 调起 Activity</h3><blockquote>
<p>指定Activity名称启动</p>
</blockquote>
<p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am start [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am start -n com.tencent.mm/.ui.LauncherUI</span><br></pre></td></tr></table></figure>

<p>表示调起微信主界面。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es <span class="string">&quot;toast&quot;</span> <span class="string">&quot;hello, world&quot;</span></span><br></pre></td></tr></table></figure>

<p>表示调起 <code>org.mazhuang.boottimemeasure/.MainActivity</code> 并传给它 string 数据键值对 <code>toast - hello, world</code>。</p>
<blockquote>
<p>不指定Activity名称启动（启动主Activity）</p>
</blockquote>
<p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell monkey -p &lt;packagename&gt; -c android.intent.category.LAUNCHER 1</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell monkey -p com.tencent.mm -c android.intent.category.LAUNCHER 1</span><br></pre></td></tr></table></figure>

<p>表示调起微信主界面。</p>
<h3 id="调起-Service"><a href="#调起-Service" class="headerlink" title="调起 Service"></a>调起 Service</h3><p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am startservice [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService</span><br></pre></td></tr></table></figure>

<p>表示调起微信的某 Service。</p>
<p>另外一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am startservice -n com.android.systemui/.SystemUIService</span><br></pre></td></tr></table></figure>

<h3 id="停止-Service"><a href="#停止-Service" class="headerlink" title="停止 Service"></a>停止 Service</h3><p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am stopservice [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>

<h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>

<p>可以向所有组件广播，也可以只向指定组件广播。</p>
<p>例如，向所有组件广播 <code>BOOT_COMPLETED</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED</span><br></pre></td></tr></table></figure>

<p>又例如，只向 <code>org.mazhuang.boottimemeasure/.BootCompletedReceiver</code> 广播 <code>BOOT_COMPLETED</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver</span><br></pre></td></tr></table></figure>

<p>这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。</p>
<p>既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机：</p>
<table>
<thead>
<tr>
<th>action</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>android.net.conn.CONNECTIVITY_CHANGE</td>
<td>网络连接发生变化</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_ON</td>
<td>屏幕点亮</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_OFF</td>
<td>屏幕熄灭</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_LOW</td>
<td>电量低，会弹出电量低提示框</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_OKAY</td>
<td>电量恢复了</td>
</tr>
<tr>
<td>android.intent.action.BOOT_COMPLETED</td>
<td>设备启动完毕</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_LOW</td>
<td>存储空间过低</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_OK</td>
<td>存储空间恢复</td>
</tr>
<tr>
<td>android.intent.action.PACKAGE_ADDED</td>
<td>安装了新的应用</td>
</tr>
<tr>
<td>android.net.wifi.STATE_CHANGE</td>
<td>WiFi 连接状态发生变化</td>
</tr>
<tr>
<td>android.net.wifi.WIFI_STATE_CHANGED</td>
<td>WiFi 状态变为启用&#x2F;关闭&#x2F;正在启动&#x2F;正在关闭&#x2F;未知</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_CHANGED</td>
<td>电池电量发生变化</td>
</tr>
<tr>
<td>android.intent.action.INPUT_METHOD_CHANGED</td>
<td>系统输入法发生变化</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_CONNECTED</td>
<td>外部电源连接</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_DISCONNECTED</td>
<td>外部电源断开连接</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STARTED</td>
<td>系统开始休眠</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STOPPED</td>
<td>系统停止休眠</td>
</tr>
<tr>
<td>android.intent.action.WALLPAPER_CHANGED</td>
<td>壁纸发生变化</td>
</tr>
<tr>
<td>android.intent.action.HEADSET_PLUG</td>
<td>插入耳机</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_UNMOUNTED</td>
<td>卸载外部介质</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_MOUNTED</td>
<td>挂载外部介质</td>
</tr>
<tr>
<td>android.os.action.POWER_SAVE_MODE_CHANGED</td>
<td>省电模式开启</td>
</tr>
</tbody></table>
<p><em>（以上广播均可使用 adb 触发）</em></p>
<h3 id="强制停止应用"><a href="#强制停止应用" class="headerlink" title="强制停止应用"></a>强制停止应用</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am force-stop &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<p>命令示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am force-stop com.qihoo360.mobilesafe</span><br></pre></td></tr></table></figure>

<p>表示停止 360 安全卫士的一切进程与服务。</p>
<h3 id="收紧内存"><a href="#收紧内存" class="headerlink" title="收紧内存"></a>收紧内存</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am send-trim-memory  &lt;pid&gt; &lt;level&gt;</span><br></pre></td></tr></table></figure>

<p>pid: 进程 ID<br>level:<br>    HIDDEN、RUNNING_MODERATE、BACKGROUND、<br>    RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE</p>
<p>命令示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am send-trim-memory 12345 RUNNING_LOW</span><br></pre></td></tr></table></figure>

<p>表示向 pid&#x3D;12345 的进程，发出 level&#x3D;RUNNING_LOW 的收紧内存命令。</p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="复制设备里的文件到电脑"><a href="#复制设备里的文件到电脑" class="headerlink" title="复制设备里的文件到电脑"></a>复制设备里的文件到电脑</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb pull &lt;设备里的文件路径&gt; [电脑上的目录]</span><br></pre></td></tr></table></figure>

<p>其中 <code>电脑上的目录</code> 参数可以省略，默认复制到当前目录。</p>
<p>例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/sr.mp4 ~/tmp/</span><br></pre></td></tr></table></figure>

<p><em>小技巧：</em>设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 <code>adb shell</code> 和 <code>su</code> 命令在 adb shell 里获取 root 权限后，先 <code>cp /path/on/device /sdcard/filename</code> 将文件复制到 sdcard，然后 <code>adb pull /sdcard/filename /path/on/pc</code>。</p>
<h3 id="复制电脑里的文件到设备"><a href="#复制电脑里的文件到设备" class="headerlink" title="复制电脑里的文件到设备"></a>复制电脑里的文件到设备</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt;</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb push ~/sr.mp4 /sdcard/</span><br></pre></td></tr></table></figure>

<p><em>小技巧：</em>设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 <code>adb push /path/on/pc /sdcard/filename</code>，然后 <code>adb shell</code> 和 <code>su</code> 在 adb shell 里获取 root 权限后，<code>cp /sdcard/filename /path/on/device</code>。</p>
<h2 id="模拟按键-x2F-输入"><a href="#模拟按键-x2F-输入" class="headerlink" title="模拟按键&#x2F;输入"></a>模拟按键&#x2F;输入</h2><p>在 <code>adb shell</code> 里有个很实用的命令叫 <code>input</code>，通过它可以做一些有趣的事情。</p>
<p><code>input</code> 命令的完整 help 信息如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Usage: input [&lt;<span class="built_in">source</span>&gt;] &lt;<span class="built_in">command</span>&gt; [&lt;arg&gt;...]</span><br><span class="line"></span><br><span class="line">The sources are:</span><br><span class="line">      mouse</span><br><span class="line">      keyboard</span><br><span class="line">      joystick</span><br><span class="line">      touchnavigation</span><br><span class="line">      touchpad</span><br><span class="line">      trackball</span><br><span class="line">      stylus</span><br><span class="line">      dpad</span><br><span class="line">      gesture</span><br><span class="line">      touchscreen</span><br><span class="line">      gamepad</span><br><span class="line"></span><br><span class="line">The commands and default sources are:</span><br><span class="line">      text &lt;string&gt; (Default: touchscreen)</span><br><span class="line">      keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard)</span><br><span class="line">      tap &lt;x&gt; &lt;y&gt; (Default: touchscreen)</span><br><span class="line">      swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)</span><br><span class="line">      press (Default: trackball)</span><br><span class="line">      roll &lt;dx&gt; &lt;dy&gt; (Default: trackball)</span><br></pre></td></tr></table></figure>

<p>比如使用 <code>adb shell input keyevent &lt;keycode&gt;</code> 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 <a href="https://developer.android.com/reference/android/view/KeyEvent.html">KeyEvent</a>，摘引部分我觉得有意思的如下：</p>
<table>
<thead>
<tr>
<th>keycode</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>HOME 键</td>
</tr>
<tr>
<td>4</td>
<td>返回键</td>
</tr>
<tr>
<td>5</td>
<td>打开拨号应用</td>
</tr>
<tr>
<td>6</td>
<td>挂断电话</td>
</tr>
<tr>
<td>24</td>
<td>增加音量</td>
</tr>
<tr>
<td>25</td>
<td>降低音量</td>
</tr>
<tr>
<td>26</td>
<td>电源键</td>
</tr>
<tr>
<td>27</td>
<td>拍照（需要在相机应用里）</td>
</tr>
<tr>
<td>64</td>
<td>打开浏览器</td>
</tr>
<tr>
<td>82</td>
<td>菜单键</td>
</tr>
<tr>
<td>85</td>
<td>播放&#x2F;暂停</td>
</tr>
<tr>
<td>86</td>
<td>停止播放</td>
</tr>
<tr>
<td>87</td>
<td>播放下一首</td>
</tr>
<tr>
<td>88</td>
<td>播放上一首</td>
</tr>
<tr>
<td>122</td>
<td>移动光标到行首或列表顶部</td>
</tr>
<tr>
<td>123</td>
<td>移动光标到行末或列表底部</td>
</tr>
<tr>
<td>126</td>
<td>恢复播放</td>
</tr>
<tr>
<td>127</td>
<td>暂停播放</td>
</tr>
<tr>
<td>164</td>
<td>静音</td>
</tr>
<tr>
<td>176</td>
<td>打开系统设置</td>
</tr>
<tr>
<td>187</td>
<td>切换应用</td>
</tr>
<tr>
<td>207</td>
<td>打开联系人</td>
</tr>
<tr>
<td>208</td>
<td>打开日历</td>
</tr>
<tr>
<td>209</td>
<td>打开音乐</td>
</tr>
<tr>
<td>210</td>
<td>打开计算器</td>
</tr>
<tr>
<td>220</td>
<td>降低屏幕亮度</td>
</tr>
<tr>
<td>221</td>
<td>提高屏幕亮度</td>
</tr>
<tr>
<td>223</td>
<td>系统休眠</td>
</tr>
<tr>
<td>224</td>
<td>点亮屏幕</td>
</tr>
<tr>
<td>231</td>
<td>打开语音助手</td>
</tr>
<tr>
<td>276</td>
<td>如果没有 wakelock 则让系统休眠</td>
</tr>
</tbody></table>
<p>下面是 <code>input</code> 命令的一些用法举例。</p>
<h3 id="电源键"><a href="#电源键" class="headerlink" title="电源键"></a>电源键</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 26</span><br></pre></td></tr></table></figure>

<p>执行效果相当于按电源键。</p>
<h3 id="菜单键"><a href="#菜单键" class="headerlink" title="菜单键"></a>菜单键</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 82</span><br></pre></td></tr></table></figure>

<h3 id="HOME-键"><a href="#HOME-键" class="headerlink" title="HOME 键"></a>HOME 键</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 3</span><br></pre></td></tr></table></figure>

<h3 id="返回键"><a href="#返回键" class="headerlink" title="返回键"></a>返回键</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 4</span><br></pre></td></tr></table></figure>

<h3 id="音量控制"><a href="#音量控制" class="headerlink" title="音量控制"></a>音量控制</h3><p>增加音量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 24</span><br></pre></td></tr></table></figure>

<p>降低音量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 25</span><br></pre></td></tr></table></figure>

<p>静音：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 164</span><br></pre></td></tr></table></figure>

<h3 id="媒体控制"><a href="#媒体控制" class="headerlink" title="媒体控制"></a>媒体控制</h3><p>播放&#x2F;暂停：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 85</span><br></pre></td></tr></table></figure>

<p>停止播放：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 86</span><br></pre></td></tr></table></figure>

<p>播放下一首：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 87</span><br></pre></td></tr></table></figure>

<p>播放上一首：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 88</span><br></pre></td></tr></table></figure>

<p>恢复播放：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 126</span><br></pre></td></tr></table></figure>

<p>暂停播放：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 127</span><br></pre></td></tr></table></figure>

<h3 id="点亮-x2F-熄灭屏幕"><a href="#点亮-x2F-熄灭屏幕" class="headerlink" title="点亮&#x2F;熄灭屏幕"></a>点亮&#x2F;熄灭屏幕</h3><p>可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。</p>
<p>点亮屏幕：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 224</span><br></pre></td></tr></table></figure>

<p>熄灭屏幕：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 223</span><br></pre></td></tr></table></figure>

<h3 id="滑动解锁"><a href="#滑动解锁" class="headerlink" title="滑动解锁"></a>滑动解锁</h3><p>如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 <code>input swipe</code> 来解锁。</p>
<p>命令（参数以机型 Nexus 5，向上滑动手势解锁举例）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input swipe 300 1000 300 500</span><br></pre></td></tr></table></figure>

<p>参数 <code>300 1000 300 500</code> 分别表示<code>起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标</code>。</p>
<h3 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h3><p>在焦点处于某文本框时，可以通过 <code>input</code> 命令来输入文本。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input text hello</span><br></pre></td></tr></table></figure>

<p>现在 <code>hello</code> 出现在文本框了。</p>
<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p>Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 &#x2F;proc&#x2F;kmsg，Android 的日志输出到 &#x2F;dev&#x2F;log。</p>
<h3 id="Android-日志"><a href="#Android-日志" class="headerlink" title="Android 日志"></a>Android 日志</h3><p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...</span><br></pre></td></tr></table></figure>

<p>常用用法列举如下：</p>
<h4 id="按级别过滤日志"><a href="#按级别过滤日志" class="headerlink" title="按级别过滤日志"></a>按级别过滤日志</h4><p>Android 的日志分为如下几个优先级（priority）：</p>
<ul>
<li>V —— Verbose（最低，输出得最多）</li>
<li>D —— Debug</li>
<li>I —— Info</li>
<li>W —— Warning</li>
<li>E —— Error</li>
<li>F —— Fatal</li>
<li>S —— Silent（最高，啥也不输出）</li>
</ul>
<p>按某级别过滤日志则会将该级别及以上的日志输出。</p>
<p>比如，命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb logcat *:W</span><br></pre></td></tr></table></figure>

<p>会将 Warning、Error、Fatal 和 Silent 日志输出。</p>
<p>（<strong>注：</strong> 在 macOS 下需要给 <code>*:W</code> 这样以 <code>*</code> 作为 tag 的参数加双引号，如 <code>adb logcat &quot;*:W&quot;</code>，不然会报错 <code>no matches found: *:W</code>。）</p>
<h4 id="按-tag-和级别过滤日志"><a href="#按-tag-和级别过滤日志" class="headerlink" title="按 tag 和级别过滤日志"></a>按 tag 和级别过滤日志</h4><p><code>&lt;filter-spec&gt;</code> 可以由多个 <code>&lt;tag&gt;[:priority]</code> 组成。</p>
<p>比如，命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb logcat ActivityManager:I MyApp:D *:S</span><br></pre></td></tr></table></figure>

<p>表示输出 tag <code>ActivityManager</code> 的 Info 以上级别日志，输出 tag <code>MyApp</code> 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p>
<h4 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h4><p>可以用 <code>adb logcat -v &lt;format&gt;</code> 选项指定日志输出格式。</p>
<p>日志支持按以下几种 <code>&lt;format&gt;</code>：</p>
<ul>
<li><p>brief</p>
<p>默认格式。格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>process</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">D( 1785) Disconnected process message: 10, size: 0  (HeadsetStateMachine)</span><br></pre></td></tr></table></figure>
</li>
<li><p>tag</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">D/HeadsetStateMachine: Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>raw</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>time</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">08-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>threadtime</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">08-28 22:39:39.974  1785  1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>long</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]</span><br><span class="line">&lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ 08-28 22:39:39.974  1785: 1832 D/HeadsetStateMachine ]</span><br><span class="line">Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure></li>
</ul>
<p>指定格式可与上面的过滤同时使用。比如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb logcat -v long ActivityManager:I *:S</span><br></pre></td></tr></table></figure>

<h4 id="清空日志"><a href="#清空日志" class="headerlink" title="清空日志"></a>清空日志</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb logcat -c</span><br></pre></td></tr></table></figure>

<h3 id="内核日志"><a href="#内核日志" class="headerlink" title="内核日志"></a>内核日志</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dmesg</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs</span><br><span class="line">&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs</span><br><span class="line">&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs</span><br><span class="line">&lt;4&gt;[14201.755954] Restarting tasks ... <span class="keyword">done</span>.</span><br><span class="line">&lt;6&gt;[14201.771229] PM: <span class="built_in">suspend</span> <span class="built_in">exit</span> 2016-08-28 13:31:32.679217193 UTC</span><br><span class="line">&lt;6&gt;[14201.872373] PM: <span class="built_in">suspend</span> entry 2016-08-28 13:31:32.780363596 UTC</span><br><span class="line">&lt;6&gt;[14201.872498] PM: Syncing filesystems ... <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>

<p>中括号里的 <code>[14201.684016]</code> 代表内核开始启动后的时间，单位为秒。</p>
<p>通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 <code>Freeing init memory</code> 那一行前面的时间就是。</p>
<h2 id="查看设备信息"><a href="#查看设备信息" class="headerlink" title="查看设备信息"></a>查看设备信息</h2><h3 id="型号"><a href="#型号" class="headerlink" title="型号"></a>型号</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.product.model</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Nexus 5</span><br></pre></td></tr></table></figure>

<h3 id="电池状况"><a href="#电池状况" class="headerlink" title="电池状况"></a>电池状况</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys battery</span><br></pre></td></tr></table></figure>

<p>输入示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Current Battery Service state:</span><br><span class="line">  AC powered: <span class="literal">false</span></span><br><span class="line">  USB powered: <span class="literal">true</span></span><br><span class="line">  Wireless powered: <span class="literal">false</span></span><br><span class="line">  status: 2</span><br><span class="line">  health: 2</span><br><span class="line">  present: <span class="literal">true</span></span><br><span class="line">  level: 44</span><br><span class="line">  scale: 100</span><br><span class="line">  voltage: 3872</span><br><span class="line">  temperature: 280</span><br><span class="line">  technology: Li-poly</span><br></pre></td></tr></table></figure>

<p>其中 <code>scale</code> 代表最大电量，<code>level</code> 代表当前电量。上面的输出表示还剩下 44% 的电量。</p>
<h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm size</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Physical size: 1080x1920</span><br></pre></td></tr></table></figure>

<p>该设备屏幕分辨率为 1080px * 1920px。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Physical size: 1080x1920</span><br><span class="line">Override size: 480x1024</span><br></pre></td></tr></table></figure>

<p>表明设备的屏幕分辨率原本是 1080px * 1920px，当前被修改为 480px * 1024px。</p>
<h3 id="屏幕密度"><a href="#屏幕密度" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm density</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Physical density: 420</span><br></pre></td></tr></table></figure>

<p>该设备屏幕密度为 420dpi。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Physical density: 480</span><br><span class="line">Override density: 160</span><br></pre></td></tr></table></figure>

<p>表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。</p>
<h3 id="显示屏参数"><a href="#显示屏参数" class="headerlink" title="显示屏参数"></a>显示屏参数</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys window displays</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays)</span><br><span class="line">  Display: mDisplayId=0</span><br><span class="line">    init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731</span><br><span class="line">    deferred=<span class="literal">false</span> layoutNeeded=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>mDisplayId</code> 为 显示屏编号，<code>init</code> 是初始分辨率和屏幕密度，<code>app</code> 的高度比 <code>init</code> 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 &#x3D; 126px 合 42dp。</p>
<h3 id="android-id"><a href="#android-id" class="headerlink" title="android_id"></a>android_id</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings get secure android_id</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">51b6be48bac8c569</span><br></pre></td></tr></table></figure>

<h3 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h3><p>在 Android 4.4 及以下版本可通过如下命令获取 IMEI：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys iphonesubinfo</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Phone Subscriber Info:</span><br><span class="line">  Phone Type = GSM</span><br><span class="line">  Device ID = 860955027785041</span><br></pre></td></tr></table></figure>

<p>其中的 <code>Device ID</code> 就是 IMEI。</p>
<p>而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">service call iphonesubinfo 1</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Result: Parcel(</span><br><span class="line">  0x00000000: 00000000 0000000f 00360038 00390030 <span class="string">&#x27;........8.6.0.9.&#x27;</span></span><br><span class="line">  0x00000010: 00350035 00320030 00370037 00350038 <span class="string">&#x27;5.5.0.2.7.7.8.5.&#x27;</span></span><br><span class="line">  0x00000020: 00340030 00000031                   <span class="string">&#x27;0.4.1...        &#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>把里面的有效内容提取出来就是 IMEI 了，比如这里的是 <code>860955027785041</code>。</p>
<p>参考：<a href="http://stackoverflow.com/questions/27002663/adb-shell-dumpsys-iphonesubinfo-not-working-since-android-5-0-lollipop">adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop</a></p>
<h3 id="Android-系统版本"><a href="#Android-系统版本" class="headerlink" title="Android 系统版本"></a>Android 系统版本</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.build.version.release</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">5.0.2</span><br></pre></td></tr></table></figure>

<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell ifconfig | grep Mask</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">inet addr:10.130.245.230  Mask:255.255.255.252</span><br><span class="line">inet addr:127.0.0.1  Mask:255.0.0.0</span><br></pre></td></tr></table></figure>

<p>那么 <code>10.130.245.230</code> 就是设备 IP 地址。</p>
<p>在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell ifconfig wlan0</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast]</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wlan0     Link encap:UNSPEC</span><br><span class="line">          inet addr:10.129.168.57  Bcast:10.129.175.255  Mask:255.255.240.0</span><br><span class="line">          inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:496520 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:3000</span><br><span class="line">          RX bytes:116266821 TX bytes:8311736</span><br></pre></td></tr></table></figure>

<p>如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell netcfg</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wlan0    UP                               10.129.160.99/20  0x00001043 f8:a9:d0:17:42:4d</span><br><span class="line">lo       UP                                   127.0.0.1/8   0x00000049 00:00:00:00:00:00</span><br><span class="line">p2p0     UP                                     0.0.0.0/0   0x00001003 fa:a9:d0:17:42:4d</span><br><span class="line">sit0     DOWN                                   0.0.0.0/0   0x00000080 00:00:00:00:00:00</span><br><span class="line">rmnet0   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet1   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet3   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet2   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet4   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet6   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet5   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet7   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rev_rmnet3 DOWN                                   0.0.0.0/0   0x00001002 4e:b7:e4:2e:17:58</span><br><span class="line">rev_rmnet2 DOWN                                   0.0.0.0/0   0x00001002 4e:f0:c8:bf:7a:cf</span><br><span class="line">rev_rmnet4 DOWN                                   0.0.0.0/0   0x00001002 a6:c0:3b:6b:c4:1f</span><br><span class="line">rev_rmnet6 DOWN                                   0.0.0.0/0   0x00001002 66:bb:5d:64:2e:e9</span><br><span class="line">rev_rmnet5 DOWN                                   0.0.0.0/0   0x00001002 0e:1b:eb:b9:23:a0</span><br><span class="line">rev_rmnet7 DOWN                                   0.0.0.0/0   0x00001002 7a:d9:f6:81:40:5a</span><br><span class="line">rev_rmnet8 DOWN                                   0.0.0.0/0   0x00001002 4e:e2:a9:bb:d0:1b</span><br><span class="line">rev_rmnet0 DOWN                                   0.0.0.0/0   0x00001002 fe:65:d0:ca:82:a9</span><br><span class="line">rev_rmnet1 DOWN                                   0.0.0.0/0   0x00001002 da:d8:e8:4f:2e:fe</span><br></pre></td></tr></table></figure>

<p>可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。</p>
<h3 id="Mac-地址"><a href="#Mac-地址" class="headerlink" title="Mac 地址"></a>Mac 地址</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell <span class="built_in">cat</span> /sys/class/net/wlan0/address</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">f8:a9:d0:17:42:4d</span><br></pre></td></tr></table></figure>

<p>这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 <code>adb shell netcfg</code> 命令来查看。</p>
<h3 id="CPU-信息"><a href="#CPU-信息" class="headerlink" title="CPU 信息"></a>CPU 信息</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell <span class="built_in">cat</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Processor       : ARMv7 Processor rev 0 (v7l)</span><br><span class="line">processor       : 0</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">processor       : 1</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">processor       : 2</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">processor       : 3</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">Features        : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt</span><br><span class="line">CPU implementer : 0x51</span><br><span class="line">CPU architecture: 7</span><br><span class="line">CPU variant     : 0x2</span><br><span class="line">CPU part        : 0x06f</span><br><span class="line">CPU revision    : 0</span><br><span class="line"></span><br><span class="line">Hardware        : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)</span><br><span class="line">Revision        : 000b</span><br><span class="line">Serial          : 0000000000000000</span><br></pre></td></tr></table></figure>

<p>这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 <code>Qualcomm MSM 8974</code>，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 <code>ARMv7 Processor rev 0 (v71)</code>。</p>
<h3 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell <span class="built_in">cat</span> /proc/meminfo</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MemTotal:        1027424 kB</span><br><span class="line">MemFree:          486564 kB</span><br><span class="line">Buffers:           15224 kB</span><br><span class="line">Cached:            72464 kB</span><br><span class="line">SwapCached:        24152 kB</span><br><span class="line">Active:           110572 kB</span><br><span class="line">Inactive:         259060 kB</span><br><span class="line">Active(anon):      79176 kB</span><br><span class="line">Inactive(anon):   207736 kB</span><br><span class="line">Active(file):      31396 kB</span><br><span class="line">Inactive(file):    51324 kB</span><br><span class="line">Unevictable:        3948 kB</span><br><span class="line">Mlocked:               0 kB</span><br><span class="line">HighTotal:        409600 kB</span><br><span class="line">HighFree:         132612 kB</span><br><span class="line">LowTotal:         617824 kB</span><br><span class="line">LowFree:          353952 kB</span><br><span class="line">SwapTotal:        262140 kB</span><br><span class="line">SwapFree:         207572 kB</span><br><span class="line">Dirty:                 0 kB</span><br><span class="line">Writeback:             0 kB</span><br><span class="line">AnonPages:        265324 kB</span><br><span class="line">Mapped:            47072 kB</span><br><span class="line">Shmem:              1020 kB</span><br><span class="line">Slab:              57372 kB</span><br><span class="line">SReclaimable:       7692 kB</span><br><span class="line">SUnreclaim:        49680 kB</span><br><span class="line">KernelStack:        4512 kB</span><br><span class="line">PageTables:         5912 kB</span><br><span class="line">NFS_Unstable:          0 kB</span><br><span class="line">Bounce:                0 kB</span><br><span class="line">WritebackTmp:          0 kB</span><br><span class="line">CommitLimit:      775852 kB</span><br><span class="line">Committed_AS:   13520632 kB</span><br><span class="line">VmallocTotal:     385024 kB</span><br><span class="line">VmallocUsed:       61004 kB</span><br><span class="line">VmallocChunk:     209668 kB</span><br></pre></td></tr></table></figure>

<p>其中，<code>MemTotal</code> 就是设备的总内存，<code>MemFree</code> 是当前空闲内存。</p>
<h3 id="更多硬件与系统属性"><a href="#更多硬件与系统属性" class="headerlink" title="更多硬件与系统属性"></a>更多硬件与系统属性</h3><p>设备的更多硬件与系统属性可以通过如下命令查看：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell <span class="built_in">cat</span> /system/build.prop</span><br></pre></td></tr></table></figure>

<p>这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。</p>
<p>输出里还包括一些其它有用的信息，它们也可通过 <code>adb shell getprop &lt;属性名&gt;</code> 命令单独查看，列举一部分属性如下：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ro.build.version.sdk</td>
<td>SDK 版本</td>
</tr>
<tr>
<td>ro.build.version.release</td>
<td>Android 系统版本</td>
</tr>
<tr>
<td>ro.build.version.security_patch</td>
<td>Android 安全补丁程序级别</td>
</tr>
<tr>
<td>ro.product.model</td>
<td>型号</td>
</tr>
<tr>
<td>ro.product.brand</td>
<td>品牌</td>
</tr>
<tr>
<td>ro.product.name</td>
<td>设备名</td>
</tr>
<tr>
<td>ro.product.board</td>
<td>处理器型号</td>
</tr>
<tr>
<td>ro.product.cpu.abilist</td>
<td>CPU 支持的 abi 列表[<em>节注一</em>]</td>
</tr>
<tr>
<td>persist.sys.isUsbOtgEnabled</td>
<td>是否支持 OTG</td>
</tr>
<tr>
<td>dalvik.vm.heapsize</td>
<td>每个应用程序的内存上限</td>
</tr>
<tr>
<td>ro.sf.lcd_density</td>
<td>屏幕密度</td>
</tr>
</tbody></table>
<p><em>节注一：</em></p>
<p>一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 <code>ro.product.cpu.abilist</code> 属性名查找不到，可以这样试试：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell <span class="built_in">cat</span> /system/build.prop | grep ro.product.cpu.abi</span><br></pre></td></tr></table></figure>

<p>示例输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ro.product.cpu.abi=armeabi-v7a</span><br><span class="line">ro.product.cpu.abi2=armeabi</span><br></pre></td></tr></table></figure>

<h2 id="修改设置"><a href="#修改设置" class="headerlink" title="修改设置"></a>修改设置</h2><p><strong>注：</strong> 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 <code>adb reboot</code> 重启设备，或手动重启。</p>
<p>修改设置的原理主要是通过 settings 命令修改 &#x2F;data&#x2F;data&#x2F;com.android.providers.settings&#x2F;databases&#x2F;settings.db 里存放的设置值。</p>
<h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm size 480x1024</span><br></pre></td></tr></table></figure>

<p>表示将分辨率修改为 480px * 1024px。</p>
<p>恢复原分辨率命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm size reset</span><br></pre></td></tr></table></figure>

<h3 id="屏幕密度-1"><a href="#屏幕密度-1" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm density 160</span><br></pre></td></tr></table></figure>

<p>表示将屏幕密度修改为 160dpi。</p>
<p>恢复原屏幕密度命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm density reset</span><br></pre></td></tr></table></figure>

<h3 id="显示区域"><a href="#显示区域" class="headerlink" title="显示区域"></a>显示区域</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm overscan 0,0,0,200</span><br></pre></td></tr></table></figure>

<p>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。</p>
<p>恢复原显示区域命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm overscan reset</span><br></pre></td></tr></table></figure>

<h3 id="关闭-USB-调试模式"><a href="#关闭-USB-调试模式" class="headerlink" title="关闭 USB 调试模式"></a>关闭 USB 调试模式</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings put global adb_enabled 0</span><br></pre></td></tr></table></figure>

<p>恢复：</p>
<p>用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。</p>
<p>去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p>
<h3 id="允许-x2F-禁止访问非-SDK-API"><a href="#允许-x2F-禁止访问非-SDK-API" class="headerlink" title="允许&#x2F;禁止访问非 SDK API"></a>允许&#x2F;禁止访问非 SDK API</h3><p>允许访问非 SDK API：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings put global hidden_api_policy_pre_p_apps 1</span><br><span class="line">adb shell settings put global hidden_api_policy_p_apps 1</span><br></pre></td></tr></table></figure>

<p>禁止访问非 SDK API：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings delete global hidden_api_policy_pre_p_apps</span><br><span class="line">adb shell settings delete global hidden_api_policy_p_apps</span><br></pre></td></tr></table></figure>

<p>不需要设备获得 Root 权限。</p>
<p>命令最后的数字的含义：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。</td>
</tr>
<tr>
<td>1</td>
<td>仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。</td>
</tr>
<tr>
<td>2</td>
<td>禁止调用深灰名单和黑名单中的接口。</td>
</tr>
<tr>
<td>3</td>
<td>禁止调用黑名单中的接口，但允许调用深灰名单中的接口。</td>
</tr>
</tbody></table>
<h3 id="状态栏和导航栏的显示隐藏"><a href="#状态栏和导航栏的显示隐藏" class="headerlink" title="状态栏和导航栏的显示隐藏"></a>状态栏和导航栏的显示隐藏</h3><p>本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings put global policy_control &lt;key-values&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;key-values&gt;</code> 可由如下几种键及其对应的值组成，格式为 <code>&lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;</code>。</p>
<table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>immersive.full</td>
<td>同时隐藏</td>
</tr>
<tr>
<td>immersive.status</td>
<td>隐藏状态栏</td>
</tr>
<tr>
<td>immersive.navigation</td>
<td>隐藏导航栏</td>
</tr>
<tr>
<td>immersive.preconfirms</td>
<td>?</td>
</tr>
</tbody></table>
<p>这些键对应的值可则如下值用逗号组合：</p>
<table>
<thead>
<tr>
<th>value</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>apps</code></td>
<td>所有应用</td>
</tr>
<tr>
<td><code>*</code></td>
<td>所有界面</td>
</tr>
<tr>
<td><code>packagename</code></td>
<td>指定应用</td>
</tr>
<tr>
<td><code>-packagename</code></td>
<td>排除指定应用</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings put global policy_control immersive.full=*</span><br></pre></td></tr></table></figure>

<p>表示设置在所有界面下都同时隐藏状态栏和导航栏。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3</span><br></pre></td></tr></table></figure>

<p>表示设置在包名为 <code>com.package1</code> 和 <code>com.package2</code> 的应用里隐藏状态栏，在除了包名为 <code>com.package3</code> 的所有应用里隐藏导航栏。</p>
<h2 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h2><h3 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h3><p>截图保存到电脑：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb exec-out screencap -p &gt; sc.png</span><br></pre></td></tr></table></figure>

<p>如果 adb 版本较老，无法使用 <code>exec-out</code> 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法：</p>
<p>先截图保存到设备里：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/sc.png</span><br></pre></td></tr></table></figure>

<p>然后将 png 文件导出到电脑：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/sc.png</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>adb shell screencap -h</code> 查看 <code>screencap</code> 命令的帮助信息，下面是两个有意义的参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>指定保存文件为 png 格式</td>
</tr>
<tr>
<td>-d display-id</td>
<td>指定截图的显示屏编号（有多显示屏的情况下）</td>
</tr>
</tbody></table>
<p>实测如果指定文件名以 <code>.png</code> 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。</p>
<p>另外一种一行命令截图并保存到电脑的方法：</p>
<p><em>Linux 和 Windows</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p | sed <span class="string">&quot;s/\r$//&quot;</span> &gt; sc.png</span><br></pre></td></tr></table></figure>

<p><em>Mac OS X</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p | gsed <span class="string">&quot;s/\r$//&quot;</span> &gt; sc.png</span><br></pre></td></tr></table></figure>

<p>这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 <a href="http://gnuwin32.sourceforge.net/packages/sed.htm">sed for Windows</a> 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。</p>
<p>而在 Mac 下使用系统自带的 sed 命令会报错：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed: RE error: illegal byte sequence</span><br></pre></td></tr></table></figure>

<p>需要安装 gnu-sed，然后使用 gsed 命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install gnu-sed</span><br></pre></td></tr></table></figure>

<h3 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h3><p>录制屏幕以 mp4 格式保存到 &#x2F;sdcard：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell screenrecord /sdcard/filename.mp4</span><br></pre></td></tr></table></figure>

<p>需要停止时按 <kbd>Ctrl-C</kbd>，默认录制时间和最长录制时间都是 180 秒。</p>
<p>如果需要导出到电脑：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/filename.mp4</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>adb shell screenrecord --help</code> 查看 <code>screenrecord</code> 命令的帮助信息，下面是常见参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>–size WIDTHxHEIGHT</td>
<td>视频的尺寸，比如 <code>1280x720</code>，默认是屏幕分辨率。</td>
</tr>
<tr>
<td>–bit-rate RATE</td>
<td>视频的比特率，默认是 4Mbps。</td>
</tr>
<tr>
<td>–time-limit TIME</td>
<td>录制时长，单位秒。</td>
</tr>
<tr>
<td>–verbose</td>
<td>输出更多信息。</td>
</tr>
</tbody></table>
<h3 id="重新挂载-system-分区为可写"><a href="#重新挂载-system-分区为可写" class="headerlink" title="重新挂载 system 分区为可写"></a>重新挂载 system 分区为可写</h3><p><strong>注：需要 root 权限。</strong></p>
<p>&#x2F;system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 &#x2F;system 进行写操作，所以需要重新挂载它为可读写。</p>
<p>步骤：</p>
<ol>
<li><p>进入 shell 并切换到 root 用户权限。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前分区挂载情况。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mount</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rootfs / rootfs ro,relatime 0 0</span><br><span class="line">tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0</span><br><span class="line">devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0</span><br><span class="line">proc /proc proc rw,relatime 0 0</span><br><span class="line">sysfs /sys sysfs rw,seclabel,relatime 0 0</span><br><span class="line">selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0</span><br><span class="line">debugfs /sys/kernel/debug debugfs rw,relatime 0 0</span><br><span class="line">none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0</span><br><span class="line">none /acct cgroup rw,relatime,cpuacct 0 0</span><br><span class="line">none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0</span><br><span class="line">none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0</span><br><span class="line">tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0</span><br><span class="line">tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0</span><br><span class="line">none /dev/memcg cgroup rw,relatime,memory 0 0</span><br><span class="line">none /dev/cpuctl cgroup rw,relatime,cpu 0 0</span><br><span class="line">none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0</span><br><span class="line">none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0</span><br><span class="line">none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0</span><br><span class="line">/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</span><br><span class="line">/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</span><br></pre></td></tr></table></figure>

<p>找到其中我们关注的带 &#x2F;system 的那一行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新挂载。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system</span><br></pre></td></tr></table></figure>

<p>这里的 <code>/dev/block/platform/msm_sdcc.1/by-name/system</code> 就是我们从上一步的输出里得到的文件路径。</p>
</li>
</ol>
<p>如果输出没有提示错误的话，操作就成功了，可以对 &#x2F;system 下的文件为所欲为了。</p>
<h3 id="查看连接过的-WiFi-密码"><a href="#查看连接过的-WiFi-密码" class="headerlink" title="查看连接过的 WiFi 密码"></a>查看连接过的 WiFi 密码</h3><p><strong>注：需要 root 权限。</strong></p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line"><span class="built_in">cat</span> /data/misc/wifi/*.conf</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">network=&#123;</span><br><span class="line">	ssid=<span class="string">&quot;TP-LINK_9DFC&quot;</span></span><br><span class="line">	scan_ssid=1</span><br><span class="line">	psk=<span class="string">&quot;123456789&quot;</span></span><br><span class="line">	key_mgmt=WPA-PSK</span><br><span class="line">	group=CCMP TKIP</span><br><span class="line">	auth_alg=OPEN</span><br><span class="line">	sim_num=1</span><br><span class="line">	priority=13893</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">	ssid=<span class="string">&quot;TP-LINK_F11E&quot;</span></span><br><span class="line">	psk=<span class="string">&quot;987654321&quot;</span></span><br><span class="line">	key_mgmt=WPA-PSK</span><br><span class="line">	sim_num=1</span><br><span class="line">	priority=17293</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ssid</code> 即为我们在 WLAN 设置里看到的名称，<code>psk</code> 为密码，<code>key_mgmt</code> 为安全加密方式。</p>
<h3 id="设置系统日期和时间"><a href="#设置系统日期和时间" class="headerlink" title="设置系统日期和时间"></a>设置系统日期和时间</h3><p><strong>注：需要 root 权限。</strong></p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line"><span class="built_in">date</span> -s 20160823.131500</span><br></pre></td></tr></table></figure>

<p>表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。</p>
<h3 id="重启手机"><a href="#重启手机" class="headerlink" title="重启手机"></a>重启手机</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure>

<h3 id="检测设备是否已-root"><a href="#检测设备是否已-root" class="headerlink" title="检测设备是否已 root"></a>检测设备是否已 root</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br></pre></td></tr></table></figure>

<p>此时命令行提示符是 <code>$</code> 则表示没有 root 权限，是 <code>#</code> 则表示已 root。</p>
<h3 id="使用-Monkey-进行压力测试"><a href="#使用-Monkey-进行压力测试" class="headerlink" title="使用 Monkey 进行压力测试"></a>使用 Monkey 进行压力测试</h3><p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p>
<p>简单用法：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell monkey -p &lt;packagename&gt; -v 500</span><br></pre></td></tr></table></figure>

<p>表示向 <code>&lt;packagename&gt;</code> 指定的应用程序发送 500 个伪随机事件。</p>
<p>Monkey 的详细用法参考 <a href="https://developer.android.com/studio/test/monkey.html">官方文档</a>。</p>
<h3 id="开启-x2F-关闭-WiFi"><a href="#开启-x2F-关闭-WiFi" class="headerlink" title="开启&#x2F;关闭 WiFi"></a>开启&#x2F;关闭 WiFi</h3><p><strong>注：需要 root 权限。</strong></p>
<p>有时需要控制设备的 WiFi 状态，可以用以下指令完成。</p>
<p>开启 WiFi：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell svc wifi <span class="built_in">enable</span></span><br></pre></td></tr></table></figure>

<p>关闭 WiFi：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell svc wifi <span class="built_in">disable</span></span><br></pre></td></tr></table></figure>

<p>若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 <code>Killed</code>。</p>
<h2 id="刷机相关命令"><a href="#刷机相关命令" class="headerlink" title="刷机相关命令"></a>刷机相关命令</h2><h3 id="重启到-Recovery-模式"><a href="#重启到-Recovery-模式" class="headerlink" title="重启到 Recovery 模式"></a>重启到 Recovery 模式</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure>

<h3 id="从-Recovery-重启到-Android"><a href="#从-Recovery-重启到-Android" class="headerlink" title="从 Recovery 重启到 Android"></a>从 Recovery 重启到 Android</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure>

<h3 id="重启到-Fastboot-模式"><a href="#重启到-Fastboot-模式" class="headerlink" title="重启到 Fastboot 模式"></a>重启到 Fastboot 模式</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure>

<h3 id="通过-sideload-更新系统"><a href="#通过-sideload-更新系统" class="headerlink" title="通过 sideload 更新系统"></a>通过 sideload 更新系统</h3><p>如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。</p>
<p>以 Recovery 模式下更新为例：</p>
<ol>
<li><p>重启到 Recovery 模式。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure>
</li>
<li><p>在设备的 Recovery 界面上操作进入 <code>Apply update</code>-<code>Apply from ADB</code>。</p>
<p>注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 <code>Apply update from ADB</code>。</p>
</li>
<li><p>通过 adb 上传和更新系统。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb sideload &lt;path-to-update.zip&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安全相关命令"><a href="#安全相关命令" class="headerlink" title="安全相关命令"></a>安全相关命令</h2><h3 id="启用-x2F-禁用-SELinux"><a href="#启用-x2F-禁用-SELinux" class="headerlink" title="启用&#x2F;禁用 SELinux"></a>启用&#x2F;禁用 SELinux</h3><p>启用 SELinux</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setenforce 1</span><br></pre></td></tr></table></figure>

<p>禁用 SELinux</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setenforce 0</span><br></pre></td></tr></table></figure>

<h3 id="启用-x2F-禁用-dm-verity"><a href="#启用-x2F-禁用-dm-verity" class="headerlink" title="启用&#x2F;禁用 dm_verity"></a>启用&#x2F;禁用 dm_verity</h3><p>启用 dm_verity</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb enable-verity</span><br></pre></td></tr></table></figure>

<p>禁用 dm_verity</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb disable-verity</span><br></pre></td></tr></table></figure>

<h2 id="更多-adb-shell-命令"><a href="#更多-adb-shell-命令" class="headerlink" title="更多 adb shell 命令"></a>更多 adb shell 命令</h2><p>Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 <code>adb shell</code> 里可以调用。本文档前面的部分内容已经用到了 <code>adb shell</code> 命令。</p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell ps</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">USER     PID   PPID  VSIZE  RSS     WCHAN    PC        NAME</span><br><span class="line">root      1     0     8904   788   ffffffff 00000000 S /init</span><br><span class="line">root      2     0     0      0     ffffffff 00000000 S kthreadd</span><br><span class="line">...</span><br><span class="line">u0_a71    7779  5926  1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classic</span><br><span class="line">u0_a58    7963  5926  1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure</span><br><span class="line">...</span><br><span class="line">shell     8750  217   10640  740   00000000 b6f28340 R ps</span><br></pre></td></tr></table></figure>

<p>各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>USER</td>
<td>所属用户</td>
</tr>
<tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody></table>
<h3 id="查看实时资源占用情况"><a href="#查看实时资源占用情况" class="headerlink" title="查看实时资源占用情况"></a>查看实时资源占用情况</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell top</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">User 0%, System 6%, IOW 0%, IRQ 0%</span><br><span class="line">User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307</span><br><span class="line"></span><br><span class="line">  PID PR CPU% S  <span class="comment">#THR     VSS     RSS PCY UID      Name</span></span><br><span class="line"> 8763  0   3% R     1  10640K   1064K  <span class="built_in">fg</span> shell    top</span><br><span class="line">  131  0   3% S     1      0K      0K  <span class="built_in">fg</span> root     dhd_dpc</span><br><span class="line"> 6144  0   0% S   115 1682004K 115916K  <span class="built_in">fg</span> system   system_server</span><br><span class="line">  132  0   0% S     1      0K      0K  <span class="built_in">fg</span> root     dhd_rxf</span><br><span class="line"> 1731  0   0% S     6  20288K    788K  <span class="built_in">fg</span> root     /system/bin/mpdecision</span><br><span class="line">  217  0   0% S     6  18008K    356K  <span class="built_in">fg</span> shell    /sbin/adbd</span><br><span class="line"> ...</span><br><span class="line"> 7779  2   0% S    19 1538748K  48896K  <span class="built_in">bg</span> u0_a71   com.sohu.inputmethod.sogou:classic</span><br><span class="line"> 7963  0   0% S    18 1561916K  59568K  <span class="built_in">fg</span> u0_a58   org.mazhuang.boottimemeasure</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PR</td>
<td>优先级</td>
</tr>
<tr>
<td>CPU%</td>
<td>当前瞬间占用 CPU 百分比</td>
</tr>
<tr>
<td>S</td>
<td>进程状态（R&#x3D;运行，S&#x3D;睡眠，T&#x3D;跟踪&#x2F;停止，Z&#x3D;僵尸进程）</td>
</tr>
<tr>
<td>#THR</td>
<td>线程数</td>
</tr>
<tr>
<td>VSS</td>
<td>Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>RSS</td>
<td>Resident Set Size 实际使用物理内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>PCY</td>
<td>调度策略优先级，SP_BACKGROUND&#x2F;SPFOREGROUND</td>
</tr>
<tr>
<td>UID</td>
<td>进程所有者的用户 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody></table>
<p><code>top</code> 命令还支持一些命令行参数，详细用法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ]</span><br><span class="line">    -m num  最多显示多少个进程</span><br><span class="line">    -n num  刷新多少次后退出</span><br><span class="line">    -d num  刷新时间间隔（单位秒，默认值 5）</span><br><span class="line">    -s col  按某列排序（可用 col 值：cpu, vss, rss, thr）</span><br><span class="line">    -t      显示线程信息</span><br><span class="line">    -h      显示帮助文档</span><br></pre></td></tr></table></figure>

<h3 id="查看进程-UID"><a href="#查看进程-UID" class="headerlink" title="查看进程 UID"></a>查看进程 UID</h3><p>有两种方案：</p>
<ol>
<li><p><code>adb shell dumpsys package &lt;packagename&gt; | grep userId=</code></p>
<p>如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ adb shell dumpsys package org.mazhuang.guanggoo | grep userId=</span><br><span class="line">   userId=10394</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 ps 命令找到对应进程的 pid 之后 <code>adb shell cat /proc/&lt;pid&gt;/status | grep Uid</code></p>
<p>如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ adb shell</span><br><span class="line">gemini:/ $ ps | grep org.mazhuang.guanggoo</span><br><span class="line">u0_a394   28635 770   1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoo</span><br><span class="line">gemini:/ $ <span class="built_in">cat</span> /proc/28635/status | grep Uid</span><br><span class="line">Uid:    10394   10394   10394   10394</span><br><span class="line">gemini:/ $</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>cat</td>
<td>显示文件内容</td>
</tr>
<tr>
<td>cd</td>
<td>切换目录</td>
</tr>
<tr>
<td>chmod</td>
<td>改变文件的存取模式&#x2F;访问权限</td>
</tr>
<tr>
<td>df</td>
<td>查看磁盘空间使用情况</td>
</tr>
<tr>
<td>grep</td>
<td>过滤输出</td>
</tr>
<tr>
<td>kill</td>
<td>杀死指定 PID 的进程</td>
</tr>
<tr>
<td>ls</td>
<td>列举目录内容</td>
</tr>
<tr>
<td>mount</td>
<td>挂载目录的查看和管理</td>
</tr>
<tr>
<td>mv</td>
<td>移动或重命名文件</td>
</tr>
<tr>
<td>ps</td>
<td>查看正在运行的进程</td>
</tr>
<tr>
<td>rm</td>
<td>删除文件</td>
</tr>
<tr>
<td>top</td>
<td>查看进程的资源占用情况</td>
</tr>
</tbody></table>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="启动-adb-server-失败"><a href="#启动-adb-server-失败" class="headerlink" title="启动 adb server 失败"></a>启动 adb server 失败</h3><p><strong>出错提示</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">error: protocol fault (couldn<span class="string">&#x27;t read status): No error</span></span><br></pre></td></tr></table></figure>

<p><strong>可能原因</strong></p>
<p>adb server 进程想使用的 5037 端口被占用。</p>
<p><strong>解决方案</strong></p>
<p>找到占用 5037 端口的进程，然后终止它。以 Windows 下为例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr LISTENING</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">TCP    0.0.0.0:5037           0.0.0.0:0              LISTENING       1548</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里 1548 即为进程 ID，用命令结束该进程：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">taskkill /PID 1548</span><br></pre></td></tr></table></figure>

<p>然后再启动 adb 就没问题了。</p>
<h3 id="com-android-ddmlib-AdbCommandRejectedException"><a href="#com-android-ddmlib-AdbCommandRejectedException" class="headerlink" title="com.android.ddmlib.AdbCommandRejectedException"></a>com.android.ddmlib.AdbCommandRejectedException</h3><p>在 Android Studio 里新建一个模拟器，但是用 adb 一直连接不上，提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.android.ddmlib.AdbCommandRejectedException: device unauthorized.</span><br><span class="line">This adb server&#x27;s $ADB_VENDOR_KEYS is not set</span><br><span class="line">Try &#x27;adb kill-server&#x27; if that seems wrong.</span><br><span class="line">Otherwise check for a confirmation dialog on your device.</span><br></pre></td></tr></table></figure>

<p>在手机上安装一个终端然后执行 su 提示没有该命令，这不正常。</p>
<p>于是删除该模拟器后重新下载安装一次，这次就正常了。</p>
<h2 id="adb-的非官方实现"><a href="#adb-的非官方实现" class="headerlink" title="adb 的非官方实现"></a>adb 的非官方实现</h2><ul>
<li><a href="https://github.com/facebook/fb-adb">fb-adb</a> - A better shell for Android devices (for Mac).</li>
</ul>
<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><ul>
<li><a href="./related/aapt.md">aapt</a></li>
<li><a href="./related/am.md">am</a></li>
<li><a href="./related/dumpsys.md">dumsys</a></li>
<li><a href="./related/pm.md">pm</a></li>
<li><a href="./related/uiautomator.md">uiautomator</a></li>
</ul>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢朋友们无私的分享与补充（排名不分先后）。</p>
<p><a href="https://github.com/zxning">zxning</a>，<a href="https://github.com/linhua55">linhua55</a>，<a href="https://github.com/codeskyblue">codeskyblue</a>，<a href="https://github.com/seasonyuu">seasonyuu</a>，<a href="https://github.com/fan123199">fan123199</a>，<a href="https://github.com/zhEdward">zhEdward</a>，<a href="https://github.com/0x8BADFOOD">0x8BADFOOD</a>，<a href="https://github.com/keith666666">keith666666</a>，<a href="https://github.com/shawnlinboy">shawnlinboy</a>，<a href="https://github.com/s-xq">s-xq</a>，<br><a href="https://github.com/lucky9322">lucky9322</a>。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://developer.android.com/studio/command-line/adb.html">Android Debug Bridge</a></li>
<li><a href="https://developer.android.com/studio/command-line/shell.html">ADB Shell Commands</a></li>
<li><a href="https://developer.android.com/studio/command-line/logcat.html">logcat Command-line Tool</a></li>
<li><a href="http://zmywly8866.github.io/2015/01/24/all-adb-command.html">Android ADB命令大全</a></li>
<li><a href="https://github.com/ZQiang94/StudyRecords/blob/master/other/src/main/java/com/other/adb%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.md">adb 命令行的使用记录</a></li>
<li><a href="http://www.jianshu.com/p/860bc2bf1a6a">Android ADB命令大全(通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等)</a></li>
<li><a href="http://yifeiyuan.me/2016/06/30/ADB%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/">那些做Android开发必须知道的ADB命令</a></li>
<li><a href="http://blog.csdn.net/kittyboy0001/article/details/38562515">adb shell top</a></li>
<li><a href="http://cabins.github.io/2016/03/25/UseAdbLikeAPro-2/">像高手一样使用ADB命令行（2）</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title>dexsim浅析</title>
    <url>/2020/02/16/dexsim%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#dexsim%E7%AE%80%E4%BB%8B">dexsim简介</a><ul>
<li><a href="#dexsim-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90">dexsim 源码浅析</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="dexsim简介"><a href="#dexsim简介" class="headerlink" title="dexsim简介"></a>dexsim简介</h1><p><a href="https://github.com/mikusjelly/dexsim">dexsim</a> 是利用动态调用实现字符串解密的工具，需要配合 <a href="https://github.com/mikusjelly/DSS">DSS</a> 使用。作者为 <code>mikusjelly</code> 。</p>
<h2 id="dexsim-源码浅析"><a href="#dexsim-源码浅析" class="headerlink" title="dexsim 源码浅析"></a>dexsim 源码浅析</h2><p><code>dexsim</code> 源码结构如下图所示，</p>
<img src="/2020/02/16/dexsim%E6%B5%85%E6%9E%90/2020-02-16-13-59-53.png" class="">

<p>其中关键解密方法在 <code>dexsim/Plugins</code> 中，当我们需要添加一个解密方法时直接在该目录中添加对应插件既可。</p>
<p>首先来看 <code>main</code> 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    parser = argparse.ArgumentParser(prog=&#x27;dexsim&#x27;, description=&#x27;&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;f&#x27;, help=&#x27;APK 文件&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;-i&#x27;, &#x27;--includes&#x27;, nargs=&#x27;*&#x27;,</span><br><span class="line">                        help=&#x27;仅解密包含的类，如abc, a.b.c&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;-o&#x27;, help=&#x27;output file path&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;-d&#x27;, &#x27;--debug&#x27;, action=&#x27;store_true&#x27;, help=&#x27;开启调试模式&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;-s&#x27;, required=False, help=&#x27;指定smali目录&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;-p&#x27;, &#x27;--pname&#x27;, required=False, help=&#x27;加载指定插件，根据插件名字&#x27;)</span><br><span class="line">    # TODO parser.add_argument(&#x27;-b&#x27;, action=&#x27;store_true&#x27;, help=&#x27;开启STEP_BY_STEP插件&#x27;)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    main(args)</span><br><span class="line">    finish = time.time()</span><br><span class="line">    print(&#x27;\n%fs&#x27; % (finish - start))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该方法主要是解析参数</p>
<ul>
<li>-i 仅解密包含的类 参数格式为 <code>a.b.c</code> <code>a.b</code>， 后面会将其转换为 <code>a/b/c.smali</code> <code>a/b.smali</code> 。</li>
<li>-o 解密后输出文件的路径</li>
<li>-s 指定smali目录</li>
<li>-p 加载指定插件，根据插件名字</li>
</ul>
<p>在 <code>main()</code> 方法中，将 apk 中的多个 dex 合并为一个名为 <code>new.dex</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ptn = re.compile(r&#x27;classes\d*.dex&#x27;)</span><br><span class="line"></span><br><span class="line">zipFile = zipfile.ZipFile(apk_path)</span><br><span class="line">for item in zipFile.namelist():</span><br><span class="line">    if ptn.match(item):</span><br><span class="line">        output_path = zipFile.extract(item, tempdir)</span><br><span class="line">        baksmali(output_path, smali_dir)</span><br><span class="line">zipFile.close()</span><br><span class="line"></span><br><span class="line">dex_file = os.path.join(tempdir, &#x27;new.dex&#x27;)</span><br></pre></td></tr></table></figure>
<p>然后在使用 <code>smali</code> 将合并的 <code>dex</code> 转为 <code>samli</code> 文件, 并进一步解析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smali(smali_dir, dex_file)</span><br><span class="line">dexsim_apk(args.f, smali_dir, includes, output_dex)</span><br></pre></td></tr></table></figure>
<p>上面的方法可以进行一下优化，没有必要将合并的 <code>dex</code> 进行反编译为 <code>smali</code> 文件,并且只能针对 <code>apk</code> 文件进行解密，可以增加对 <code>dex</code> 文件的解密。</p>
<p>接着看 <code>dexsim_apk</code> 方法.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dexsim(apk_file, smali_dir, includes)</span><br><span class="line">if output_dex:</span><br><span class="line">    smali(smali_dir, output_dex)</span><br><span class="line">else:</span><br><span class="line">    smali(smali_dir,</span><br><span class="line">          os.path.splitext(os.path.basename(apk_file))[0] + &#x27;.sim.dex&#x27;)</span><br></pre></td></tr></table></figure>
<p>发现该方法直接调用 <code>dexsim</code> 方法，然后解密完成，那么关键方法为 <code>dexsim</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def dexsim(apk_file, smali_dir, includes):</span><br><span class="line">    &quot;&quot;&quot;推送到手机/模拟器，动态解密</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">        apk_file (TYPE): Description</span><br><span class="line">        smali_dir (TYPE): Description</span><br><span class="line">        includes (TYPE): Description</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    driver = Driver()</span><br><span class="line">    driver.push_to_dss(apk_file)</span><br><span class="line"></span><br><span class="line">    oracle = Oracle(smali_dir, driver, includes)</span><br><span class="line">    oracle.divine()</span><br></pre></td></tr></table></figure>
<p>在该方法中将 <code>dex</code> 文件推送到手机中，然后调用创建 <code>Oracle</code> 对象向，调用该对象的 <code>divine</code> 进行解密.</p>
<p>接下来看 Oracle 对象的 <code>__init__</code> 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def __init__(self, smali_dir, driver, includes):</span><br><span class="line">     &#x27;&#x27;&#x27;</span><br><span class="line">     &#x27;&#x27;&#x27;</span><br><span class="line">     self.driver = driver</span><br><span class="line">     # 下面一段代码可以删除，因为我们传的includes参数已经去掉了 L</span><br><span class="line">     paths = []</span><br><span class="line">     if includes:</span><br><span class="line">         for item in includes:</span><br><span class="line">             paths.append(item[1:].split(&#x27;;&#x27;)[0])</span><br><span class="line"></span><br><span class="line">     self.smalidir = SmaliDir(smali_dir, include=paths, exclude=FILTERS)</span><br><span class="line">     self.plugin_manager = PluginManager(self.driver, self.smalidir)</span><br></pre></td></tr></table></figure>
<p>调用 <code>SmaliDir</code> 读取 smali 代码， 然后调用 <code>PluginManager</code> 加载插件。</p>
<p>接下来看看 <code>PluginManager</code> 如何加载所有插件的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def __init__plugins(self):</span><br><span class="line">    for path in sys.path:</span><br><span class="line">        if path and path in __file__:</span><br><span class="line">            pkg = __file__.replace(path, &#x27;&#x27;)</span><br><span class="line">            break</span><br><span class="line">    module_path = os.path.dirname(pkg)[1:].replace(</span><br><span class="line">        os.sep, &#x27;.&#x27;) + &#x27;.&#x27; + self.plugin_dir + &#x27;.&#x27;</span><br><span class="line"></span><br><span class="line">    tmp = [None] * len(self.plugin_filenames)</span><br><span class="line">    # 开始加载所有插件</span><br><span class="line">    for name in self.plugin_filenames:</span><br><span class="line">        spec = importlib.util.find_spec(module_path + name)</span><br><span class="line">        mod = spec.loader.load_module()</span><br><span class="line">        clazz = getattr(mod, mod.PLUGIN_CLASS_NAME)</span><br><span class="line">        if not issubclass(clazz, Plugin):</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        if not clazz.enabled:</span><br><span class="line">            print(&quot;Don&#x27;t load plugin&quot;, clazz.name)</span><br><span class="line">            continue</span><br><span class="line">        tmp[clazz.index] = clazz(self.driver, self.smalidir)</span><br><span class="line"></span><br><span class="line">    for item in tmp:</span><br><span class="line">        if item:</span><br><span class="line">            self.__plugins.append(item)</span><br></pre></td></tr></table></figure>
<p>首先获取插件名，然后调用 <code>importlib.util.find_spec(module_path + name)</code> 加载插件，完成插件的加载。</p>
<p>接下来回到 <code>oracle.divine()</code> 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def divine(self):</span><br><span class="line">    plugins = self.plugin_manager.get_plugins()</span><br><span class="line"></span><br><span class="line">    flag = True</span><br><span class="line">    smali_mtds = set()  # 存放已被修改的smali方法</span><br><span class="line">    while flag:</span><br><span class="line">        flag = False</span><br><span class="line">        for plugin in plugins:</span><br><span class="line">            # 调用插件的run方法</span><br><span class="line">            plugin.run()</span><br><span class="line">            # 更新smali_mtds 文件</span><br><span class="line">            smali_mtds = smali_mtds.union(plugin.smali_mtd_updated_set)</span><br><span class="line">            print(plugin.make_changes)</span><br><span class="line">            flag = flag | plugin.make_changes</span><br><span class="line">            plugin.make_changes = False</span><br><span class="line"></span><br><span class="line">    self.driver.adb.run_shell_cmd([&#x27;rm&#x27;, DSS_APK_PATH])</span><br></pre></td></tr></table></figure>
<p>关键的加密方法还是要看插件。</p>
<p>接下来看 Plugin 类，该类是所有插件的基类。先看看两个关键的成员变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># [&#123;&#x27;className&#x27;:&#x27;&#x27;, &#x27;methodName&#x27;:&#x27;&#x27;, &#x27;arguments&#x27;:&#x27;&#x27;, &#x27;id&#x27;:&#x27;&#x27;&#125;, ..., ]</span><br><span class="line">json_list = []  # 存放解密对象</span><br><span class="line"></span><br><span class="line"># [(mtd, old_content, new_content), ..., ]</span><br><span class="line"># [(方法体， 原始的内容，解密后的内容)，...,]</span><br><span class="line">target_contexts = &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>json_list 存放解密对象，将转成文件推送到手机中让 DSS 解析并动态执行，其格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">		&quot;className&quot;: &quot;othn.iclauncher&quot;,</span><br><span class="line">		&quot;methodName&quot;: &quot;Ez&quot;,</span><br><span class="line">		&quot;arguments&quot;: [&quot;java.lang.String:FK9FD0004670751372201EA6&quot;],</span><br><span class="line">		&quot;id&quot;: &quot;a439b0d815c9a0a972c6b0dc69ec7bee5663ae9b65294b2828fbb8aaa098ce70&quot;</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		&quot;className&quot;: &quot;othn.iclauncher&quot;,</span><br><span class="line">		&quot;methodName&quot;: &quot;EA&quot;,</span><br><span class="line">		&quot;arguments&quot;: [&quot;java.lang.String:FKBEFCC3DA309EDA1B6FC62DF7E3EBECB5&quot;],</span><br><span class="line">		&quot;id&quot;: &quot;cdfcbfd5a872408ba4cc06b6f5a1fb48f1c5e18d5c36deb6e6fe41bd6b3d5c8c&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>target_contexts 存放解密前后的代码和方法体，方便后续替换。</p>
<p>几个关键的成员变量高清楚之后，剩下的东西也比较好理解，所以就不多说了，最后就是看看替换方法体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for key, value in outputs.items():</span><br><span class="line">    if key not in self.target_contexts:</span><br><span class="line">        print(key, value, &quot;not in&quot;)</span><br><span class="line">        continue</span><br><span class="line">    for mtd, old_content, new_content in self.target_contexts[key]:</span><br><span class="line">        old_body = mtd.get_body()</span><br><span class="line">        new_content = old_content + &quot;\n&quot; + new_content.format(value[0])</span><br><span class="line">        body = old_body.replace(old_content, new_content)</span><br><span class="line">        mtd.set_body(body)</span><br><span class="line">        self.make_changes = True</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">self.smali_files_update()</span><br></pre></td></tr></table></figure>
<p>outputs 为动态执行后的结果，主要格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;7b842f01264dc1d1a5089da9e86f531e90f5affe9ef36ecade2e2878a306ae7a&quot;: [&quot;sender&quot;],</span><br><span class="line">	&quot;5f0edfa5e4249ff38f5918e9b27197aec7aaeeed6c7c604a109bdfb21d9b7dc5&quot;: [&quot;ss&quot;],</span><br><span class="line">	&quot;642ed422a84d5ccab9e8fb27813c17d80b346af15295ffdc72dbd09d8662e34c&quot;: [&quot;raw_data&quot;],</span><br><span class="line">	&quot;e19e1215be04291d5a0c61232a7ae933a3ad6c6e760e7b86ccc2800f0350730a&quot;: [&quot;SUCCEED&quot;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过相同的key进行替换，上面为了避免回编译为dex文件的时报错，直接使用的追加方式。</p>
<p>整个代码的原理大概就是这样，关键就是写插件，这一块就不详细说了，有兴趣可以看看 <code>Plugin</code> 目录中的插件.</p>
<p>最后看看解密后的效果吧。</p>
<p>解密前</p>
<img src="/2020/02/16/dexsim%E6%B5%85%E6%9E%90/2020-02-16-15-17-58.png" class="">

<p>解密后</p>
<img src="/2020/02/16/dexsim%E6%B5%85%E6%9E%90/2020-02-16-15-17-13.png" class="">


]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>dex字符串解密</tag>
      </tags>
  </entry>
  <entry>
    <title>github项目搜索技巧</title>
    <url>/2020/03/05/github%E9%A1%B9%E7%9B%AE%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#github-%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7">github 搜索技巧</a><ul>
<li><a href="#%E6%A1%88%E4%BE%8B">案例</a><ul>
<li><a href="#%E6%99%AE%E9%80%9A%E6%90%9C">普通搜</a></li>
</ul>
</li>
<li><a href="#%E6%90%AD%E9%85%8D%E6%8A%80%E5%B7%A7%E6%90%9C">搭配技巧搜</a></li>
<li><a href="#%E9%99%90%E5%AE%9A%E8%AF%8D">限定词</a><ul>
<li><a href="#%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E7%94%A8%E6%88%B7%E6%88%96%E7%BB%84%E7%BB%87%E7%9A%84%E9%A1%B9%E7%9B%AE">查找某个用户或组织的项目</a></li>
</ul>
</li>
<li><a href="#%E8%BE%85%E5%8A%A9%E9%99%90%E5%AE%9A%E8%AF%8D">辅助限定词</a></li>
<li><a href="#%E8%BF%98%E6%B2%A1%E6%90%9E%E6%87%82%E7%9A%84%E5%85%B3%E4%BA%8E-forksmirrorissues">还没搞懂的（关于 forks、mirror、issues）</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F%E6%94%BE%E7%9A%84%E6%98%AF%E5%AE%98%E7%BD%91%E7%9A%84%E9%93%BE%E6%8E%A5">排序（放的是官网的链接）</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97">使用指南</a><ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E6%A1%88%E4%BE%8B">练习案例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="github-搜索技巧"><a href="#github-搜索技巧" class="headerlink" title="github 搜索技巧"></a>github 搜索技巧</h1><p>参考自 B站 up 主 CodeSheep 的视频【<a href="https://www.bilibili.com/video/av75587104">如何高效地在网上找开源项目做！在职程序员实际演示一波视频教程操作</a>】，然后写着写着一好奇就去看文档了</p>
<p>现在这篇博客相当于官方文档的翻译版😂</p>
<p>当然，你也可以去看【<a href="https://help.github.com/en/github/searching-for-information-on-github/searching-on-github">官方文档</a>】体验原汁原味的教程</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="普通搜"><a href="#普通搜" class="headerlink" title="普通搜"></a>普通搜</h3><p>关键词：<code>python</code></p>
<img src="/2020/03/05/github%E9%A1%B9%E7%9B%AE%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/2020-03-05-21-48-14.png" class="">

<h2 id="搭配技巧搜"><a href="#搭配技巧搜" class="headerlink" title="搭配技巧搜"></a>搭配技巧搜</h2><p>搜索 github 中，项目描述（description）中有 python 并且 2019-12-20 号之后有更新过的项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">in:description python pushed:&gt;2019-12-20</span><br></pre></td></tr></table></figure>
<p>效果：加了限制条件后，查出来的项目数有了明显的减少</p>
<img src="/2020/03/05/github%E9%A1%B9%E7%9B%AE%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/2020-03-05-21-49-11.png" class="">

<h2 id="限定词"><a href="#限定词" class="headerlink" title="限定词"></a>限定词</h2><p>可通过指定 仓库名(repository name)、项目描述(description)、内容(contents)、说明文件(readme.md) 来搜索项目</p>
<table>
<thead>
<tr>
<th>限定词</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td><code>in:name</code></td>
<td><code>in:name python</code> 查出仓库名中有 python 的项目（python in:name 也是一样的）</td>
</tr>
<tr>
<td><code>in:description</code></td>
<td><code>in:name,description python</code> 查出仓库名或者项目描述中有 python 的项目</td>
</tr>
<tr>
<td><code>in:readme</code></td>
<td><code>in:readme python</code> 查出 <code>readme.md</code> 文件里有 python 的项目</td>
</tr>
<tr>
<td><code>repo:owner/name</code></td>
<td><code>repo:octocat/hello-world</code> 查出 octocat 的 hello-world 项目（指定了某个人的某个项目）</td>
</tr>
</tbody></table>
<p>其他骚操作？自己看官方文档（感觉用不到，就不整理了吧）：【<a href="https://help.github.com/en/github/searching-for-information-on-github/finding-files-on-github">找仓库中的某个文件</a>】、【<a href="https://help.github.com/en/github/searching-for-information-on-github/searching-code">在 github 上查找代码片段</a>】</p>
<h3 id="查找某个用户或组织的项目"><a href="#查找某个用户或组织的项目" class="headerlink" title="查找某个用户或组织的项目"></a>查找某个用户或组织的项目</h3><table>
<thead>
<tr>
<th>限定词</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td><code>user:USERNAME</code></td>
<td><code>user:1335951413 stars:&lt;10</code> 查出用户 1335951413 名下 stars 少于 10 的项目</td>
</tr>
<tr>
<td><code>org:ORGNAME</code></td>
<td><code>org:github</code> 查出 github 名下的项目</td>
</tr>
</tbody></table>
<h2 id="辅助限定词"><a href="#辅助限定词" class="headerlink" title="辅助限定词"></a>辅助限定词</h2><p>可以通过限制 项目大小(size)、拥护者数(followers)、fork数(forks)、stars数(stars)、创建时间(created)、更新时间(pushed)、项目所用语言(language)、topic标签(topic)、topic标签数(topics)… 来筛选项目</p>
<p>辅助限定词可以多个并用，用空格隔开就行，可以搭配限定词使用，也可单独使用</p>
<p>（关于项目是否被 fork 这个点我不是很懂，就不写案例了）</p>
<ul>
<li><p><code>in:name python size:&lt;=1000</code> 查出项目名字中有 python 且小于 1MB 的项目</p>
</li>
<li><p><code>size:&lt;=1000</code> 查出项目大小小于 1MB 的项目</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>限定词</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td><code>stars:n</code></td>
<td><code>stars:&gt;=5</code> 查出 star数大于等于 5 个 的项目（支持大于小于区间等）</td>
</tr>
<tr>
<td><code>pushed:YYYY-MM-DD</code></td>
<td><code>css pushed:&gt;2013-02-01</code> 查出仓库中包含 css 关键字，并且在 2013年1月 之后更新过的项目</td>
</tr>
<tr>
<td><code>language:LANGUAGE</code></td>
<td><code>rails language:javascript</code> 查出仓库包含 rails 关键字，并且使用 javscript 语言的项目</td>
</tr>
<tr>
<td><code>created:YYYY-MM-DD</code></td>
<td><code>webos created:&lt;2011-01-01</code> 查出仓库中包含 webos 关键字并且是在 2011 年之前创建的项目（也支持时分秒，支持大于小于区间等）</td>
</tr>
<tr>
<td><code>size:n</code></td>
<td><code>size:1000</code> 查出仓库大小等于 1MB 的项目, <code>size:&gt;=30000</code> 查出仓库大小至少大于 30MB 的项目, <code>size:50..120</code> 查出仓库大小在 50KB 至 120KB 之间的项目</td>
</tr>
<tr>
<td><code>followers:n</code></td>
<td><code>followers:1000</code> 查出有 1000 个拥护者（followers） 的项目（支持大于小于区间等）</td>
</tr>
<tr>
<td><code>forks:n</code></td>
<td><code>forks:5</code> 查出有 5 个 forks 的项目（支持大于小于区间等）</td>
</tr>
<tr>
<td><code>topic:TOPIC</code></td>
<td><code>topic:jekyll</code> 查出含有 jekyll 这个 topic 的项目（项目描述下面的东西，相当于标签、分类）</td>
</tr>
<tr>
<td><code>topics:n</code></td>
<td><code>topics:&gt;5</code> 查出有 5 个以上 topic 的项目（支持大于小于区间等）</td>
</tr>
<tr>
<td><code>archived:true/false</code></td>
<td><code>archived:true GNOME</code> 查出已经封存了并且含有 GNOME 关键字的项目（已经不再维护了的项目）</td>
</tr>
<tr>
<td><code>is:public/private</code></td>
<td><code>is:public org:github</code> 查出仓库所有组织是 github 并且公开的项目</td>
</tr>
<tr>
<td><code>is:private github</code> 查出含有 github 关键字并且是私有的项目（私有的别人看不到，所以这个是用来搜索自己的私有项目的）</td>
<td></td>
</tr>
<tr>
<td><code>license:LICENSE_KEYWORD</code></td>
<td><code>license:apache-2.0</code> 查出仓库的开源协议是 apache-2.0 的</td>
</tr>
</tbody></table>
<h2 id="还没搞懂的（关于-forks、mirror、issues）"><a href="#还没搞懂的（关于-forks、mirror、issues）" class="headerlink" title="还没搞懂的（关于 forks、mirror、issues）"></a>还没搞懂的（关于 forks、mirror、issues）</h2><p><a href="https://github.com/search?q=stars:%3E=500+fork:true+language:php&type=Repositories">stars:&gt;&#x3D;500 fork:true language:php</a> matches repositories with the at least 500 stars, including forked ones, that are written in PHP.</p>
<p><a href="https://github.com/search?q=case+pushed:%3E=2013-03-06+fork:only&type=Repositories">case pushed:&gt;&#x3D;2013-03-06 fork:only</a> matches repositories with the word “case” that were pushed to on or after March 6th, 2013, and that are forks.<br><a href="https://github.com/search?utf8=%E2%9C%93&q=mirror:true+GNOME&type=">mirror:true GNOME</a> matches repositories that are mirrors and contain the word “GNOME.” 查出是镜像并且包含 GNOME 关键字的项目（github 上 mirror 啥意思不太懂）<br><a href="https://github.com/search?utf8=%E2%9C%93&q=mirror:false+GNOME&type=">mirror:false GNOME</a> matches repositories that are not mirrors and contain the word “GNOME.”<br><a href="https://github.com/search?utf8=%E2%9C%93&q=javascript+good-first-issues:%3E2&type=">good-first-issues:&gt;2 javascript</a> matches repositories with more than two issues labeled good-first-issue and that contain the word “javascript.”<br><a href="https://github.com/search?utf8=%E2%9C%93&q=react+help-wanted-issues:%3E4&type=">help-wanted-issues:&gt;4 react</a> matches repositories with more than four issues labeled help-wanted and that contain the word “React.”</p>
<h2 id="排序（放的是官网的链接）"><a href="#排序（放的是官网的链接）" class="headerlink" title="排序（放的是官网的链接）"></a>排序（放的是官网的链接）</h2><p>推荐直接在页面上的搜索结果点击排序，何必再去学一手呢？</p>
<p>官网文档：【<a href="https://help.github.com/en/github/searching-for-information-on-github/sorting-search-results">给你的查询结果排序</a>】</p>
<img src="/2020/03/05/github%E9%A1%B9%E7%9B%AE%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/2020-03-05-21-59-49.png" class="">


<h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><p>自己灵活的使用限定词和辅助限定词写出一套规则即可查出你想要的项目</p>
<p>他们的位置先后、数量都无所谓，加上只是多了一个条件</p>
<h3 id="练习案例"><a href="#练习案例" class="headerlink" title="练习案例"></a>练习案例</h3><p>常用到的其实有就是这些，上面的还是太多了，你有那个需求，又找不到方式的时候可以查查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 项目名字(name)里有 python 的</span><br><span class="line">in:name python</span><br><span class="line"></span><br><span class="line"># 名字(name)里有 python 的并且 stars 大于 3000 的</span><br><span class="line">in:name python starts:&gt;3000</span><br><span class="line"></span><br><span class="line"># 名字(name)里有 python 的并且 stars 大于 3000 、forks 大于 200 的</span><br><span class="line">in:name python starts:&gt;3000 forks:&gt;200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 详情(readme)里面有 python 的并且 stars 大于 3000 的</span><br><span class="line">in:readme python starts:&gt;3000</span><br><span class="line"></span><br><span class="line"># 描述(description)里面有 python 的并且 stars 大于 3000 的</span><br><span class="line">in:description python starts:&gt;3000</span><br><span class="line"></span><br><span class="line"># 描述(description)里面有 python 的并且是 python 语言的</span><br><span class="line">in:description python language:python</span><br><span class="line"></span><br><span class="line"># 描述(description)里面有 python 的并且 2019-12-20 号之后有更新过的</span><br><span class="line">in:description python pushed:&gt;2019-12-20</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用记录</title>
    <url>/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>本文主要记录 git 使用过程中需要搜索的一些命令。</p>
<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="配置-git-用户名和邮箱"><a href="#配置-git-用户名和邮箱" class="headerlink" title="配置 git 用户名和邮箱"></a>配置 git 用户名和邮箱</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的名字&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global user.email “邮箱@邮箱.com”</span><br></pre></td></tr></table></figure>

<p>这里的名字和邮箱决定了你在创建 <code>commit</code> 时的作者信息，与 <code>git</code> 托管平台的账号和邮箱没有关系。github 只认邮箱，也就是说 <code>user.email</code> 决定了在 github 的网页上要显示谁的用户名和头像。</p>
<p>你可以把上面的 <code>global</code> 改成 <code>local</code> 来为所在仓库指定默认作者，<code>global</code> 代表针对所有仓库的全局变量</p>
<h2 id="常用命令的介绍"><a href="#常用命令的介绍" class="headerlink" title="常用命令的介绍"></a>常用命令的介绍</h2><ul>
<li><p><code>git clone</code> 其作用是把一个远程仓库下载到本地, 用法如下：</p>
<ul>
<li>使用 <code>git clone &lt;仓库地址&gt;</code> 来克隆一个仓库的默认分支</li>
<li>使用 <code>git clone &lt;地址&gt; -b &lt;分支名/TAG 名&gt;</code> 来克隆指定分支&#x2F;tag</li>
<li>使用 <code>git clone &lt;地址&gt; &lt;目录名&gt;</code> 来克隆到一个指定目录（当然还可以和上面的<code>-b</code> 结合·一下）</li>
<li>使用 <code>git clone &lt;地址&gt; --depth=1</code> 来克隆最小仓库</li>
</ul>
</li>
<li><p><code>git add</code> 用来往缓冲区中增加文件，用法如下：</p>
<ul>
<li><code>git add &lt;文件名/目录&gt;</code>，来把一个文件加入缓冲区</li>
<li>也可以使用 <code>git add *</code> 来把所有修改都加入缓冲区（隐藏文件除外）</li>
</ul>
</li>
<li><p><code>git commit</code> 是把缓冲区中的修改，作为一个新的 commit(提交)，用法如下：</p>
<ul>
<li><code>git commit -m &quot;我是提交的内容&quot;</code> 直接创建 commit message</li>
<li><code>git commit -a</code> 来省去 <code>git add</code> 的过程，直接把所有的修改创建为一个新提交</li>
</ul>
</li>
<li><p><code>git status</code> 用来查看当前仓库的状态，包括被修改的文件以及未追踪的文件等。</p>
</li>
<li><p><code>git diff</code> 用来查看文件的修改内容，用法如下：</p>
<ul>
<li><code>git diff</code> 来查看当前已经被修改，但尚未加入缓冲区的文件的修改内容</li>
<li><code>git diff &lt;文件名&gt;</code> 查看单独文件的修改</li>
</ul>
</li>
<li><p><code>git checkout</code> 这个命令翻译过来应该叫做“检出”，没法一句话概括“检出”的含义，直接来看用法吧</p>
<ul>
<li>在你 <code>git add</code> 了一个文件后，你想反向 <code>add</code>（从缓冲区删除），你可以使用 <code>git checkout &lt;文件名&gt;</code></li>
<li>当你想要切换分支时，可以使用 <code>git checkout &lt;分支名&gt;</code> 来切换到另一个已经存在的分支</li>
<li>当你想要创建新分支时，可以使用 <code>git checkout -b &lt;新分支名&gt;</code>来切换到一个新分支</li>
<li>当你想要把一个文件的内容，用它在另一个分支里的内容覆盖时，可以使用 <code>git checkout &lt;分支名&gt; &lt;文件名&gt;</code></li>
</ul>
</li>
<li><p><code>git log</code> 这是最重要的命令之一，查看当前仓库的“提交历史记录”，使用方式：</p>
<ul>
<li><code>git log</code> 打开日志界面，按 Q 退出</li>
<li><code>git log --oneline</code> 打开简洁版历史界面，按 Q 退出</li>
<li><code>git log &lt;本地分支名&gt;</code> 来查看某一分支的日志</li>
<li><code>git log &lt;文件/目录名&gt;</code> 来查看某一文件&#x2F;目录的日志</li>
</ul>
</li>
<li><p><code>git reset</code> 这个命令是用来改变头指针的位置的，头指针可以理解为，把当前的仓库内容状态，与哪个提交进行比较，那个提交就是头指针。用法如下。</p>
<ul>
<li><code>git reset &lt;sha1&gt;</code>并不会改变仓库的文件内容， 仓库里的文件还在原来的状态，只是它们所在的提交都消失了，因此那些文件都变成了尚未加入缓冲区的状态。</li>
<li>使用 <code>git reset --hard &lt;sha1&gt;</code> 来把当前分支还原到指定提交时的状态，即使是当时未追踪的文件也会消失。</li>
</ul>
</li>
<li><p><code>git revert</code> 反转一个提交，就是把指定提交的内容倒着做一遍，比如上个提交加了文件，反转之后就是把那个文件删了，它和 <code>git reset --hard</code> 并不一样，那个是重置仓库的状态，这个是反转指定的内容并作为一个新的提交创建。不过 它们两个其实可以达到相同的目的 那就是干掉导致问题的提交，使用方法：</p>
<ul>
<li><code>git revert &lt;sha1&gt;</code>来反转一个提交</li>
</ul>
</li>
<li><p><code>git cherry-pick</code> 用来为当前分支应用指定的提交的，使用方法</p>
<ul>
<li><code>git cherry-pick &lt;sha1&gt;</code> 把指定提交打到当前分支上</li>
<li><code>git cherry-pick &lt;头&gt;^..&lt;尾&gt;</code> 把连续多个提交打到当前分支上（包含头尾</li>
<li>连续 <code>pick</code> 在冲突解决完后 执行 <code>git cherry-pick --continue</code> 即可继续 <code>pick</code></li>
</ul>
</li>
<li><p><code>git branch</code> 就是查看已存在的分支的命令了</p>
<ul>
<li><code>git branch</code> 来查看本地的所有分支</li>
<li><code>git branch -r</code> 查看远程服务器上的所有分支</li>
<li><code>git branch -D &lt;本地分支名&gt;</code> 使用前提时你当前不在这个被删除的分支上（先切换到别的分支）</li>
</ul>
</li>
<li><p><code>git remote</code> 这个命令和远程服务器相关</p>
<ul>
<li><code>git remote</code> 来查看本地已保存的全部远程服务器</li>
<li><code>git remote get-url &lt;远程服务器名称&gt;</code>来查看一个远程服务器的地址</li>
<li><code>git remote add &lt;服务器名称&gt; &lt;地址&gt;</code>来新增远程服务器</li>
<li><code>git remote remove &lt;名称&gt;</code>来删除远程服务器</li>
</ul>
</li>
<li><p><code>git push</code> 这个命令用来将本地修改推送到远程服务器</p>
<ul>
<li><code>git push</code> 来推送修改到与当前分支绑定的远程分支</li>
<li><code>git push --set-upstream &lt;远程服务器名&gt; &lt;本地分支名&gt;</code> 来创建上述绑定。注意！这个命令是将本地分支设为追踪同名远程分支，如果想追踪名字不同的远程分支，<code>请使用 git push --set-upstream &lt;远程服务器名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></li>
<li><code>git push &lt;远程服务器名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code> 来把指定的本地分支推送到指定的远程分支（是否绑定无所谓）</li>
<li>git push -f 这适用于强制覆盖，就是在提交历史被修改&#x2F;本地分支落后于远程分支等情况下，强制更新远程分支 （比如 git reset –hard 之后）</li>
<li><code>git push --delete &lt;远程服务器名&gt; &lt;远程分支名&gt;</code> 删除服务器上的分支</li>
</ul>
</li>
<li><p><code>git fetch</code> 在 <code>git</code> 仓库已经存在的情况下，想要在当前仓库中获取别的仓库&#x2F;分支的内容时使用，使用方式：</p>
<ul>
<li><code>git fetch &lt;远程地址/远程服务器名称&gt;</code> 把指定的远程服务器的默认分支，下载到本地的一个叫做 <code>FETCH_HEAD</code> 的临时分支里（你可以这么理解）（一般临时使用远程仓库时才会这么用，比如 <code>merge/cherry-pick</code>）</li>
<li><code>git fetch &lt;远程地址/服务器名称&gt; &lt;远程分支名&gt;</code> 把指定远程服务器的指定分支下载到 <code>FETCH_HEAD</code> 中</li>
<li><code>git fetch &lt;远程地址/服务器名称&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code> 把远程服务器的指定分支下载到本地的指定分支</li>
</ul>
</li>
<li><p><code>git merge</code> 合并分支，使用方式：</p>
<ul>
<li><code>git merge &lt;本地分支名/FETCH_HEAD&gt;</code>来合并一个分支（可能会有冲突）</li>
</ul>
</li>
<li><p><code>git pull</code> 可以把这个命令理解为 <code>git fetch &lt;绑定的远程服务器&gt; &lt;绑定的分支&gt; &amp;&amp; git merge FETCH_HEAD</code></p>
</li>
</ul>
<h2 id="新建数据库"><a href="#新建数据库" class="headerlink" title="新建数据库"></a>新建数据库</h2><p>创建一个目录 <code>basis</code> ，进入目录中右键打开 Git Bash Here ，执行 <code>git init</code> 命令即可新建数据库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /basis/.git/</span><br></pre></td></tr></table></figure>

<p>创建成功后，basis 目录中将会出现一个 <code>.git</code> 的目录。</p>
<h2 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h2><p>在 <code>basis</code> 目录中新建一个名为 <code>sample.txt</code> 的文本文件，并输入下列内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">连猴子都懂的Git命令</span><br></pre></td></tr></table></figure>

<p>使用 <code>git status</code> 命令确认工作树和索引的状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        sample.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure>

<p>使用 <code>git add</code> 命令将 <code>sample.txt</code> 文件加入到索引。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add sample.txt</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        new file:   sample.txt</span><br></pre></td></tr></table></figure>

<p>指定参数 <code>.</code> ，可以把当前目录下所有的文件加入到索引。</p>
<p>执行 <code>git commit</code> 命令之后确认状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m<span class="string">&quot;first commit&quot;</span></span><br><span class="line">[master (root-commit) 90fd96a] first commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 sample.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>使用 <code>git log</code> 命令，我们可以在数据库的提交记录看到新的提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 90fd96aa3edba60e1ef8d1c07a431612c29a9e86 (HEAD -&gt; master)</span><br><span class="line">Author: CKCat &lt;ckcatck@qq.com&gt;</span><br><span class="line">Date:   Wed Jun 22 20:41:42 2022 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>

<h2 id="push-到远程数据库"><a href="#push-到远程数据库" class="headerlink" title="push 到远程数据库"></a>push 到远程数据库</h2><p>使用 <code>git remote</code> 指令添加远程数据库，并且使用 <code>push</code> 命令向数据库推送更改内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add origin https://github.com/CKCat/git-tutorial.git</span><br><span class="line">$ git branch -M main</span><br><span class="line">$ git push -u origin main</span><br><span class="line">Enumerating objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 236 bytes | 236.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To https://github.com/CKCat/git-tutorial</span><br><span class="line"> * [new branch]      main -&gt; main</span><br><span class="line">branch <span class="string">&#x27;main&#x27;</span> <span class="built_in">set</span> up to track <span class="string">&#x27;origin/main&#x27;</span>.</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>git remote add &lt;name&gt; &lt;url&gt;</code></p>
<ul>
<li><code>name</code> : 远程数据库名称，默认名称为 <code>origin</code></li>
<li><code>url</code> : 远程数据库的 <code>URL</code></li>
</ul>
</li>
<li><p><code>git push &lt;repository&gt; &lt;refspec&gt;</code></p>
<ul>
<li><code>repository</code> : 目标地址</li>
<li><code>refspec</code> : 推送的分支。如果指定了 <code>-u</code> 选项，那么下一次推送时就可以省略分支名称了。&#96;</li>
</ul>
</li>
</ul>
<p>通过 github.com 网站上修改 <code>sample.txt</code> 文件内容如下， 在 <code>commit</code> 消息中输入 <code>添加 add 的说明</code> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">连猴子都懂的Git命令</span><br><span class="line">add 把变更录入到索引中</span><br></pre></td></tr></table></figure>

<p>使用 <code>git pull</code> 指令进行拉取操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Enumerating objects: 5, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), 696 bytes | 49.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/CKCat/git-tutorial</span><br><span class="line">   90fd96a..c9a9b2d  main       -&gt; origin/main</span><br><span class="line">Updating 90fd96a..c9a9b2d</span><br><span class="line">Fast-forward</span><br><span class="line"> sample.txt | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>git pull &lt;repository&gt; &lt;refspec&gt;</code><ul>
<li><code>repository</code> : 数据库名称，默认为 origin；</li>
<li><code>refspec</code> : 分支。</li>
</ul>
</li>
</ul>
<p>使用 <code>git log</code> 指令来确认历史记录是否已更新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 83e0241f23bb8a18870a34fd2d0bca67a5a59e86 (HEAD -&gt; main, origin/main)</span><br><span class="line">Author: CKCat &lt;844045574@qq.com&gt;</span><br><span class="line">Date:   Wed Jun 22 21:05:20 2022 +0800</span><br><span class="line"></span><br><span class="line">    添加add的说明</span><br><span class="line"></span><br><span class="line">commit 90fd96aa3edba60e1ef8d1c07a431612c29a9e86</span><br><span class="line">Author: CKCat &lt;ckcatck@qq.com&gt;</span><br><span class="line">Date:   Wed Jun 22 20:41:42 2022 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>

<h2 id="合并修改记录"><a href="#合并修改记录" class="headerlink" title="合并修改记录"></a>合并修改记录</h2><p>在 github 网站上修改文件内容并 <code>commit</code> 提交，修改内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">连猴子都懂的Git命令</span><br><span class="line">add 把变更录入到索引中</span><br><span class="line">github 远程修改内容</span><br></pre></td></tr></table></figure>

<p>随后在修改本地仓库的文件内容并 <code>commit</code> 提交，修改内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> sample.txt</span><br><span class="line">连猴子都懂的Git命令</span><br><span class="line">add 把变更录入到索引中</span><br><span class="line">本地修改内容</span><br><span class="line"></span><br><span class="line">$ git add sample.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m<span class="string">&quot;本地修改&quot;</span></span><br><span class="line">[main 844aa9c] 本地修改</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>最后将本地仓库提交到远程仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin main</span><br><span class="line">To https://github.com/CKCat/git-tutorial</span><br><span class="line"> ! [rejected]        main -&gt; main (fetch first)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;https://github.com/CKCat/git-tutorial&#x27;</span></span><br><span class="line">hint: Updates were rejected because the remote contains work that you <span class="keyword">do</span></span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., <span class="string">&#x27;git pull ...&#x27;</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">&#x27;Note about fast-forwards&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<p>可以看到发生了错误，推送被拒绝（rejected）了。</p>
<p>为了把变更内容推送到远程数据库，我们必须手动解决冲突。首先请运行 <code>git pull</code>，以从远程数据库取得最新的变更记录吧。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Enumerating objects: 5, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (5/5), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (2/2), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), 720 bytes | 32.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/CKCat/git-tutorial</span><br><span class="line">   83e0241..2f6ac56  main       -&gt; origin/main</span><br><span class="line">Auto-merging sample.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> sample.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>

<p>打开 <code>sample.txt</code> 文件，我们看到 Git 已添加标示以显示冲突部分。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> sample.txt</span><br><span class="line">连猴子都懂的Git命令</span><br><span class="line">add 把变更录入到索引中</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">本地修改内容</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">github 远程修改内容</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2f6ac56c9bc7e2d95b48f28ba77607ebb6b98c97</span></span><br></pre></td></tr></table></figure>

<p>导入两方的修改，并删除多余的标示行以解决冲突。文件的内容发生了修改，所以需要进行提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> sample.txt</span><br><span class="line">连猴子都懂的Git命令</span><br><span class="line">add 把变更录入到索引中</span><br><span class="line">github 远程修改内容</span><br><span class="line">本地修改内容</span><br><span class="line"></span><br><span class="line">$ git add sample.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m<span class="string">&quot;合并&quot;</span></span><br><span class="line">[main 94d7787] 合并</span><br></pre></td></tr></table></figure>

<p>用 <code>git log</code> 命令来确认数据库的历史记录是否准确。指定 <code>--graph</code> 选项，能以文本形式显示更新记录的流程图。指定 <code>--oneline</code> 选项，能在一行中显示提交的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --oneline</span><br><span class="line">*   94d7787 (HEAD -&gt; main) 合并</span><br><span class="line">|\</span><br><span class="line">| * 2f6ac56 (origin/main) github 远程修改</span><br><span class="line">* | 844aa9c 本地修改</span><br><span class="line">|/</span><br><span class="line">* 83e0241 添加add的说明</span><br><span class="line">* 90fd96a first commit</span><br></pre></td></tr></table></figure>

<p>最终就可以 <code>git push</code> 至远程仓库了。</p>
<h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="分支概念"><a href="#分支概念" class="headerlink" title="分支概念"></a>分支概念</h2><p>分支是为了将修改记录的整体流程分叉保存。分叉后的分支不受其他分支的影响，所以在同一个数据库里可以同时进行多个修改。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/%E5%88%86%E6%94%AF.png" class="">

<p>在数据库进行最初的提交后, Git 会创建一个名为 master 的分支。</p>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>HEAD 指向的是现在使用中的分支的最后一次更新。通常默认指向 master 分支的最后一次更新。通过移动 HEAD，就可以变更使用的分支。提交时使用 <code>~</code> 和 <code>^</code> 就可以指定某个提交的相对位置。HEAD 后面加上 <code>~</code> 可以指定 HEAD 之前的提交记录。<code>^</code> 来指定使用哪个为根节点。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/HEAD.png" class="">

<h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><p>还未提交的修改内容以及新添加的文件，留在索引区域或工作树的情况下切换到其他的分支时，修改内容会从原来的分支移动到目标分支。</p>
<p>但是如果在 checkout 的目标分支中相同的文件也有修改，checkout 会失败的。这时要么先提交修改内容，要么用 stash 暂时保存修改内容后再 checkout。</p>
<p>stash 是临时保存文件修改内容的区域。stash 可以暂时保存工作树和索引里还没提交的修改内容，您可以事后再取出暂存的修改，应用到原先的分支或其他的分支上。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/stash.png" class="">

<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>merge 合并保持修改内容的历史记录，但是历史记录会很复杂。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/fast-forward%E5%92%8Cnon-fast-forward%E5%90%88%E5%B9%B6.png" class="">

<h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>rebase 合并历史记录简单，是在原有提交的基础上将差异内容反映进去。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/rebase%E5%90%88%E5%B9%B6.png" class="">

<h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="建立分支"><a href="#建立分支" class="headerlink" title="建立分支"></a>建立分支</h3><p>可以通过 branch 命令来创建分支。不指定参数直接执行 branch 命令的话，可以显示分支列表。 前面有 <code>*</code> 的就是现在的分支。</p>
<p>创建名为 issue1 的分支，并显示分支列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch issue1</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">  issue1</span><br><span class="line">* main</span><br></pre></td></tr></table></figure>

<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>可以执行 checkout 命令切换分支，在 checkout 命令指定 <code>-b</code> 选项执行，可以创建分支并进行切换。</p>
<p>切换到 issue1 分支的状态下，修改文件内容并提交，历史记录会被记录到 issue1 分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout issue1</span><br><span class="line">Switched to branch <span class="string">&#x27;issue1&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git add sample.txt</span><br><span class="line">$ git commit -m<span class="string">&quot;issue1分支添加&quot;</span></span><br><span class="line">[issue1 b68b7e0] issue1分支添加</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line"> $ git <span class="built_in">log</span> --graph --oneline</span><br><span class="line">* b68b7e0 (HEAD -&gt; issue1) issue1分支添加</span><br><span class="line">*   94d7787 (origin/main, main) 合并</span><br><span class="line">|\</span><br><span class="line">| * 2f6ac56 github 远程修改</span><br><span class="line">* | 844aa9c 本地修改</span><br><span class="line">|/</span><br><span class="line">* 83e0241 添加add的说明</span><br><span class="line">* 90fd96a first commit</span><br></pre></td></tr></table></figure>

<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>执行 merge 命令以合并分支。该命令将指定分支导入到 HEAD 指定的分支。</p>
<p>执行 merge 命令命令，将 issue1 分支合并至 main 分支，这个是 fast-forward（快进）合并。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> $ git checkout main</span><br><span class="line">Switched to branch <span class="string">&#x27;main&#x27;</span></span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">&#x27;origin/main&#x27;</span>.</span><br><span class="line"></span><br><span class="line">(base) $ git merge issue1</span><br><span class="line">Updating 94d7787..b68b7e0</span><br><span class="line">Fast-forward</span><br><span class="line"> sample.txt | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">(base) $ git <span class="built_in">log</span> --graph --oneline</span><br><span class="line">* b68b7e0 (HEAD -&gt; main, issue1) issue1分支添加</span><br><span class="line">*   94d7787 (origin/main) 合并</span><br><span class="line">|\</span><br><span class="line">| * 2f6ac56 github 远程修改</span><br><span class="line">* | 844aa9c 本地修改</span><br><span class="line">|/</span><br><span class="line">* 83e0241 添加add的说明</span><br><span class="line">* 90fd96a first commit</span><br></pre></td></tr></table></figure>

<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>在 branch 命令指定 <code>-d</code> 选项执行，以删除分支。</p>
<p>删除 issue1 分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d issue1</span><br><span class="line">Deleted branch issue1 (was b68b7e0).</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* main</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline</span><br><span class="line">* b68b7e0 (HEAD -&gt; main) issue1分支添加</span><br><span class="line">*   94d7787 (origin/main) 合并</span><br><span class="line">|\</span><br><span class="line">| * 2f6ac56 github 远程修改</span><br><span class="line">* | 844aa9c 本地修改</span><br><span class="line">|/</span><br><span class="line">* 83e0241 添加add的说明</span><br><span class="line">* 90fd96a first commit</span><br></pre></td></tr></table></figure>

<h3 id="并行操作"><a href="#并行操作" class="headerlink" title="并行操作"></a>并行操作</h3><p>首先创建 issue2 分支和 issue3 分支，并切换到 issue2 分支，在 issue2 分支的 <code>sample.txt</code> 添加 commit 命令的说明后提交。然后切换到 issue3 分支，在 issue3 分支的 <code>sample.txt</code> 添加 commit 命令的说明后提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch issue2</span><br><span class="line">$ git branch issue3</span><br><span class="line"></span><br><span class="line">$ git checkout issue2</span><br><span class="line">Switched to branch <span class="string">&#x27;issue2&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* issue2</span><br><span class="line">  issue3</span><br><span class="line">  main</span><br><span class="line"></span><br><span class="line">$ git add sample.txt</span><br><span class="line">$ git commit -m<span class="string">&quot;issue2操作&quot;</span></span><br><span class="line">[issue2 e0cb521] issue2操作</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline</span><br><span class="line">* e0cb521 (HEAD -&gt; issue2) issue2操作</span><br><span class="line">* b68b7e0 (main, issue3) issue1分支添加</span><br><span class="line">*   94d7787 (origin/main) 合并</span><br><span class="line">|\</span><br><span class="line">| * 2f6ac56 github 远程修改</span><br><span class="line">* | 844aa9c 本地修改</span><br><span class="line">|/</span><br><span class="line">* 83e0241 添加add的说明</span><br><span class="line">* 90fd96a first commit</span><br><span class="line"></span><br><span class="line">$ git checkout issue3</span><br><span class="line">Switched to branch <span class="string">&#x27;issue3&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">  issue2</span><br><span class="line">* issue3</span><br><span class="line">  main</span><br><span class="line"></span><br><span class="line">$ git add sample.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m<span class="string">&quot;issue3操作&quot;</span></span><br><span class="line">[issue3 57b6972] issue3操作</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline</span><br><span class="line">* 57b6972 (HEAD -&gt; issue3) issue3操作</span><br><span class="line">* b68b7e0 (main) issue1分支添加</span><br><span class="line">*   94d7787 (origin/main) 合并</span><br><span class="line">|\</span><br><span class="line">| * 2f6ac56 github 远程修改</span><br><span class="line">* | 844aa9c 本地修改</span><br><span class="line">|/</span><br><span class="line">* 83e0241 添加add的说明</span><br><span class="line">* 90fd96a first commit</span><br></pre></td></tr></table></figure>

<p>这样，添加 commit 的说明的操作，和添加 pull 的说明的操作就并行进行了。</p>
<h3 id="解决合并的冲突"><a href="#解决合并的冲突" class="headerlink" title="解决合并的冲突"></a>解决合并的冲突</h3><p>把 issue2 分支和 issue3 分支的修改合并到 master。</p>
<p>切换 master 分支后，与 issue2 分支合并，将执行 fast-forward（快进）合并。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout main</span><br><span class="line">Switched to branch <span class="string">&#x27;main&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/main&#x27;</span> by 1 commit.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git merge issue2</span><br><span class="line">Updating b68b7e0..e0cb521</span><br><span class="line">Fast-forward</span><br><span class="line"> sample.txt | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/graph.png" class="">

<p>接着合并 issue3 分支，由于在同一行进行了修改，所以产生了冲突，自动合并失败</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge issue3</span><br><span class="line">Auto-merging sample.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> sample.txt</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> sample.txt</span><br><span class="line">连猴子都懂的Git命令</span><br><span class="line">add 把变更录入到索引中</span><br><span class="line">github 远程修改内容</span><br><span class="line">本地修改内容</span><br><span class="line">在 issue1 分支下添加的内容</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">在 issue2 分支下添加的内容</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">在 issue3 分支下添加的内容</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; issue3</span></span><br></pre></td></tr></table></figure>

<p>修改冲突的部分，重新提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add sample.txt</span><br><span class="line">$ git commit -m<span class="string">&quot;合并issue3分支&quot;</span></span><br><span class="line">[main e6d1f77] 合并issue3分支</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline</span><br><span class="line">*   e6d1f77 (HEAD -&gt; main) 合并issue3分支</span><br><span class="line">|\</span><br><span class="line">| * 57b6972 (issue3) issue3操作</span><br><span class="line">* | e0cb521 (issue2) issue2操作</span><br><span class="line">|/</span><br><span class="line">* b68b7e0 issue1分支添加</span><br><span class="line">*   94d7787 (origin/main) 合并</span><br><span class="line">|\</span><br><span class="line">| * 2f6ac56 github 远程修改</span><br><span class="line">* | 844aa9c 本地修改</span><br><span class="line">|/</span><br><span class="line">* 83e0241 添加add的说明</span><br><span class="line">* 90fd96a first commit</span><br></pre></td></tr></table></figure>

<h3 id="用-rebase-合并"><a href="#用-rebase-合并" class="headerlink" title="用 rebase 合并"></a>用 rebase 合并</h3><p>合并 issue3 分支的时候，使用 rebase 可以使提交的历史记录显得更简洁。</p>
<p>现在暂时取消刚才的合并。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD~</span><br><span class="line">HEAD is now at e0cb521 issue2操作</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline</span><br><span class="line">* e0cb521 (HEAD -&gt; main, issue2) issue2操作</span><br><span class="line">* b68b7e0 issue1分支添加</span><br><span class="line">*   94d7787 (origin/main) 合并</span><br><span class="line">|\</span><br><span class="line">| * 2f6ac56 github 远程修改</span><br><span class="line">* | 844aa9c 本地修改</span><br><span class="line">|/</span><br><span class="line">* 83e0241 添加add的说明</span><br><span class="line">* 90fd96a first commit</span><br></pre></td></tr></table></figure>

<p>切换到 issue3 分支后，对 main 执行 rebase。和 merge 时的操作相同，修改在 <code>sample.txt</code> 发生冲突的部分。</p>
<p>rebase 的时候，修改冲突后的提交不是使用 commit 命令，而是执行 rebase 命令指定 <code>--continue</code> 选项。若要取消 rebase，指定 <code>--abort</code> 选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout issue3</span><br><span class="line">Switched to branch <span class="string">&#x27;issue3&#x27;</span></span><br><span class="line">$ git rebase main</span><br><span class="line"></span><br><span class="line">$ git add sample.txt</span><br><span class="line">$ git rebase --<span class="built_in">continue</span></span><br><span class="line">[detached HEAD babe974] issue3操作</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line">Successfully rebased and updated refs/heads/issue3.</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline</span><br><span class="line">* babe974 (HEAD -&gt; issue3) issue3操作</span><br><span class="line">* e0cb521 (main, issue2) issue2操作</span><br><span class="line">* b68b7e0 issue1分支添加</span><br><span class="line">*   94d7787 (origin/main) 合并</span><br><span class="line">|\</span><br><span class="line">| * 2f6ac56 github 远程修改</span><br><span class="line">* | 844aa9c 本地修改</span><br><span class="line">|/</span><br><span class="line">* 83e0241 添加add的说明</span><br><span class="line">* 90fd96a first commit</span><br></pre></td></tr></table></figure>

<p>这样，在 main 分支的 issue3 分支就可以 fast-forward 合并了。切换到 main 分支后执行合并。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout main</span><br><span class="line">Switched to branch <span class="string">&#x27;main&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/main&#x27;</span> by 2 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line"></span><br><span class="line">$ git merge issue3</span><br><span class="line">Updating e0cb521..babe974</span><br><span class="line">Fast-forward</span><br><span class="line"> sample.txt | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline</span><br><span class="line">* babe974 (HEAD -&gt; main, issue3) issue3操作</span><br><span class="line">* e0cb521 (issue2) issue2操作</span><br><span class="line">* b68b7e0 issue1分支添加</span><br><span class="line">*   94d7787 (origin/main) 合并</span><br><span class="line">|\</span><br><span class="line">| * 2f6ac56 github 远程修改</span><br><span class="line">* | 844aa9c 本地修改</span><br><span class="line">|/</span><br><span class="line">* 83e0241 添加add的说明</span><br><span class="line">* 90fd96a first commit</span><br></pre></td></tr></table></figure>

<h2 id="远端数据库"><a href="#远端数据库" class="headerlink" title="远端数据库"></a>远端数据库</h2><h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><p>执行 pull 可以取得远程数据库的历史记录。</p>
<p>本地数据库分支没有任何的更改将执行 fast-forward 合并。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/pull-fast-forward%E5%90%88%E5%B9%B6.png" class="">
<p>图中的 master 是本地数据库的 master 分支，<code>origin/master</code> 是远程数据库的 origin 的 master 分支。</p>
<p>如果本地数据库的 master 分支有新的历史记录，就需要合并双方的修改。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/pull-non-fast-forward%E5%90%88%E5%B9%B6.png" class="">

<h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>执行 pull，远程数据库的内容就会自动合并。但是，有时只是想确认本地数据库的内容而不想合并。这种情况下，请使用 fetch。</p>
<p>执行 fetch 就可以取得远程数据库的最新历史记录。取得的提交会导入到没有名字的分支，这个分支可以从名为 FETCH_HEAD 的退出。</p>
<p>例如，在本地数据库和远程数据库的 origin，如果在从 B 进行提交的状态下执行 fetch，就会形成如下图所示的历史记录。</p>
<p>在这个状态下，若要把远程数据库的内容合并到本地数据库，可以合并 FETCH_HEAD，或者重新执行 pull。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/fetch.png" class="">

<blockquote>
<p>合并后，历史记录会和 pull 相同。<strong>实际上 pull 的内容是 fetch + merge 组成的。</strong></p>
</blockquote>
<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>从本地数据库 push 到远程数据库时，要 fast-forward 合并 push 的分支。如果发生冲突，push 会被拒绝的。</p>
<p>若要共享在本地数据库创建的分支，需要明确的 push。因此，没有执行 push 就不会给远程数据库带来影响，因而可以自由的创建自己的分支。</p>
<blockquote>
<p>基本上，远程数据库共享的提交是不能修改的。如果修改的话，跟远程数据库同步的其他数据库的历史记录会变得很奇怪的。</p>
</blockquote>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签是为了更方便地参考提交而给它标上易懂的名称。</p>
<p>Git 可以使用 2 种标签：轻标签和注解标签。打上的标签是固定的，不能像分支那样可以移动位置。</p>
<p>轻标签</p>
<ul>
<li>添加名称</li>
</ul>
<p>注解标签</p>
<ul>
<li>添加名称</li>
<li>添加注解</li>
<li>添加签名</li>
</ul>
<p>一般情况下，发布标签是采用注解标签来添加注解或签名的。轻标签是为了在本地暂时使用或一次性使用。</p>
<h3 id="添加轻标签"><a href="#添加轻标签" class="headerlink" title="添加轻标签"></a>添加轻标签</h3><p>使用<code> git tag &lt;tagname&gt;</code> 命令来添加标签，在 <code>&lt;tagname&gt;</code> 执行标签的名称。</p>
<p>如果没有使用参数而执行 tag ，可以显示标签列表。</p>
<p>如果在 log 命令添加 <code>--decorate</code> 选项执行，可以显示包含标签资料的历史记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag apple</span><br><span class="line">$ git tag</span><br><span class="line">apple</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --decorate</span><br><span class="line">commit babe9740fda8df3cb2fffb71efba89510561bc68 (HEAD -&gt; main, tag: apple, issue3)</span><br><span class="line">Author: CKCat &lt;ckcatck@qq.com&gt;</span><br><span class="line">Date:   Thu Jun 23 15:44:26 2022 +0800</span><br><span class="line"></span><br><span class="line">    issue3操作</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h3 id="添加注解标签"><a href="#添加注解标签" class="headerlink" title="添加注解标签"></a>添加注解标签</h3><p>若要添加注解标签，可以在 tag 命令指定 <code>-a</code> 选项执行。执行后会启动编辑区，请输入注解，也可以指定 <code>-m</code> 选项来添加注解。</p>
<p>如果在 tag 命令指定 <code>-n</code> 选项执行，可以显示标签的列表和注解。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -am<span class="string">&quot;添加注解标签&quot;</span> banana</span><br><span class="line"></span><br><span class="line">$ git tag -n</span><br><span class="line">apple           issue3操作</span><br><span class="line">banana          添加注解标签</span><br></pre></td></tr></table></figure>

<h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p>执行 <code>git tag -d &lt;tagname&gt;</code> 删除标签。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -d banana</span><br><span class="line">Deleted tag <span class="string">&#x27;banana&#x27;</span> (was 32445a9)</span><br><span class="line"></span><br><span class="line">$ git tag -n</span><br><span class="line">apple           issue3操作</span><br></pre></td></tr></table></figure>

<h2 id="改写提交"><a href="#改写提交" class="headerlink" title="改写提交"></a>改写提交</h2><h3 id="修改最近的提交"><a href="#修改最近的提交" class="headerlink" title="修改最近的提交"></a>修改最近的提交</h3><p><code>commit --amend</code> 执行提交的话，可以修改同一个分支最近的提交内容和注解。</p>
<p>主要使用的场合：</p>
<ul>
<li>添加最近提交时漏掉的档案</li>
<li>修改最近提交的注解</li>
</ul>
<p>修改文件后执行 <code>commit --amend</code> 操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 47b5320e7093bf243fed1385e777fd77621ce920 (HEAD -&gt; main)</span><br><span class="line">Author: CKCat &lt;ckcatck@qq.com&gt;</span><br><span class="line">Date:   Thu Jun 23 15:44:26 2022 +0800</span><br><span class="line"></span><br><span class="line">    操作issue3操作</span><br><span class="line">$ git add sample.txt</span><br><span class="line">$ git commit --amend</span><br><span class="line">[main d2ed9d0] 执行commit --amend操作issue3操作</span><br><span class="line"> Date: Thu Jun 23 15:44:26 2022 +0800</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">E:\Study\NoteCode\git-tutorial(main -&gt; origin)</span><br><span class="line">(base) $ git <span class="built_in">log</span></span><br><span class="line">commit d2ed9d04cf81048ad711a595eab49dab90258ca2 (HEAD -&gt; main)</span><br><span class="line">Author: CKCat &lt;ckcatck@qq.com&gt;</span><br><span class="line">Date:   Thu Jun 23 15:44:26 2022 +0800</span><br><span class="line"></span><br><span class="line">    执行commit --amend操作issue3操作</span><br></pre></td></tr></table></figure>

<h3 id="取消过去的提交"><a href="#取消过去的提交" class="headerlink" title="取消过去的提交"></a>取消过去的提交</h3><p>revert 可以取消指定的提交内容。使用后面要提到的 rebase -i 或 reset 也可以删除提交。但是，不能随便删除已经发布的提交，这时需要通过 revert 创建要否定的提交。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/%E5%8F%96%E6%B6%88%E8%BF%87%E5%8E%BB%E7%9A%84%E6%8F%90%E4%BA%A4.png" class="">

<p>主要使用的场合：</p>
<ul>
<li>安全地取消过去发布的提交</li>
</ul>
<p>用 log 命令确认历史记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit ca7dd5e0e3ecc86a7d4858a43583dfdb6b85357f (HEAD -&gt; issue3)</span><br><span class="line">Author: CKCat &lt;ckcatck@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 24 09:00:30 2022 +0800</span><br><span class="line"></span><br><span class="line">    revert测试</span><br><span class="line"></span><br><span class="line">commit babe9740fda8df3cb2fffb71efba89510561bc68 (tag: apple)</span><br><span class="line">Author: CKCat &lt;ckcatck@qq.com&gt;</span><br><span class="line">Date:   Thu Jun 23 15:44:26 2022 +0800</span><br><span class="line"></span><br><span class="line">    issue3操作</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">$ git revert HEAD</span><br><span class="line">[issue3 ea92671] Revert <span class="string">&quot;取消revert&quot;</span></span><br><span class="line"> 1 file changed, 1 insertion(+), 2 deletions(-)</span><br><span class="line"></span><br><span class="line"> $ git <span class="built_in">log</span></span><br><span class="line">commit ea926713db229d11e91eaabab384c8e54376e7f4 (HEAD -&gt; issue3)</span><br><span class="line">Author: CKCat &lt;ckcatck@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 24 09:01:40 2022 +0800</span><br><span class="line"></span><br><span class="line">    Revert <span class="string">&quot;取消revert&quot;</span></span><br><span class="line"></span><br><span class="line">    This reverts commit ca7dd5e0e3ecc86a7d4858a43583dfdb6b85357f.</span><br><span class="line"></span><br><span class="line">commit ca7dd5e0e3ecc86a7d4858a43583dfdb6b85357f</span><br><span class="line">Author: CKCat &lt;ckcatck@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 24 09:00:30 2022 +0800</span><br><span class="line"></span><br><span class="line">    revert测试</span><br><span class="line"></span><br><span class="line">commit babe9740fda8df3cb2fffb71efba89510561bc68 (tag: apple)</span><br><span class="line">Author: CKCat &lt;ckcatck@qq.com&gt;</span><br><span class="line">Date:   Thu Jun 23 15:44:26 2022 +0800</span><br><span class="line"></span><br><span class="line">    issue3操作</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/revert.png" class="">

<h3 id="遗弃提交"><a href="#遗弃提交" class="headerlink" title="遗弃提交"></a>遗弃提交</h3><p>reset 可以遗弃不再使用的提交。执行遗弃时，需要根据影响的范围而指定不同的模式，可以指定是否复原索引或工作树的内容。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/%E9%81%97%E5%BC%83%E6%8F%90%E4%BA%A4.png" class="">

<table>
<thead>
<tr>
<th>模式名称</th>
<th>HEAD 的位置</th>
<th>索引</th>
<th>工作树</th>
</tr>
</thead>
<tbody><tr>
<td>soft</td>
<td>修改</td>
<td>不修改</td>
<td>不修改</td>
</tr>
<tr>
<td>mixed(默认)</td>
<td>修改</td>
<td>修改</td>
<td>不修改</td>
</tr>
<tr>
<td>hard</td>
<td>修改</td>
<td>修改</td>
<td>修改</td>
</tr>
</tbody></table>
<p>主要使用的场合：</p>
<ul>
<li>复原修改过的索引的状态(mixed)</li>
<li>彻底取消最近的提交(hard)</li>
<li>只取消提交(soft)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit ea926713db229d11e91eaabab384c8e54376e7f4 (HEAD -&gt; issue3)</span><br><span class="line">Author: CKCat &lt;ckcatck@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 24 09:01:40 2022 +0800</span><br><span class="line"></span><br><span class="line">    Revert <span class="string">&quot;取消revert&quot;</span></span><br><span class="line"></span><br><span class="line">    This reverts commit ca7dd5e0e3ecc86a7d4858a43583dfdb6b85357f.</span><br><span class="line"></span><br><span class="line">commit ca7dd5e0e3ecc86a7d4858a43583dfdb6b85357f</span><br><span class="line">Author: CKCat &lt;ckcatck@qq.com&gt;</span><br><span class="line">Date:   Fri Jun 24 09:00:30 2022 +0800</span><br><span class="line"></span><br><span class="line">    revert测试</span><br><span class="line"></span><br><span class="line">commit babe9740fda8df3cb2fffb71efba89510561bc68 (tag: apple)</span><br><span class="line">Author: CKCat &lt;ckcatck@qq.com&gt;</span><br><span class="line">Date:   Thu Jun 23 15:44:26 2022 +0800</span><br><span class="line"></span><br><span class="line">    issue3操作</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">$ git reset --hard HEAD~~</span><br><span class="line">HEAD is now at babe974 issue3操作</span><br><span class="line"></span><br><span class="line"> $ git <span class="built_in">log</span></span><br><span class="line">commit babe9740fda8df3cb2fffb71efba89510561bc68 (HEAD -&gt; issue3, tag: apple)</span><br><span class="line">Author: CKCat &lt;ckcatck@qq.com&gt;</span><br><span class="line">Date:   Thu Jun 23 15:44:26 2022 +0800</span><br><span class="line"></span><br><span class="line">    issue3操作</span><br><span class="line"></span><br><span class="line">commit e0cb521f5947288c8452b28f05524b1bc71cbb23 (issue2)</span><br><span class="line">Author: CKCat &lt;ckcatck@qq.com&gt;</span><br><span class="line">Date:   Thu Jun 23 15:42:11 2022 +0800</span><br><span class="line"></span><br><span class="line">    issue2操作</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/reset.png" class="">

<blockquote>
<p>在 reset 之前的提交可以参照 ORIG_HEAD。Reset 错误的时候，执行<code> git reset --hard ORIG_HEAD</code> 就可以还原到 reset 前的状态。</p>
</blockquote>
<h3 id="提取提交"><a href="#提取提交" class="headerlink" title="提取提交"></a>提取提交</h3><p>cherry-pick 您可以从其他分支复制指定的提交，然后导入到现在的分支。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/%E6%8F%90%E5%8F%96%E6%8F%90%E4%BA%A4.png" class="">

<p>主要使用的场合：</p>
<ul>
<li>把弄错分支的提交移动到正确的地方</li>
<li>把其他分支的提交添加到现在的分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --oneline</span><br><span class="line">* 40b4d95 (HEAD -&gt; main) cherry-pick</span><br><span class="line">* d2ed9d0 (origin/main) 执行commit --amend操作issue3操作</span><br><span class="line">* e0cb521 (issue2) issue2操作</span><br><span class="line">* b68b7e0 issue1分支添加</span><br><span class="line">*   94d7787 合并</span><br><span class="line">|\</span><br><span class="line">| * 2f6ac56 github 远程修改</span><br><span class="line">* | 844aa9c 本地修改</span><br><span class="line">|/</span><br><span class="line">* 83e0241 添加add的说明</span><br><span class="line">* 90fd96a first commit</span><br><span class="line"></span><br><span class="line">$ git checkout bugfix</span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline</span><br><span class="line">* 4d8800f (HEAD -&gt; bugfix) 修复bug2</span><br><span class="line">* d711099 修复bug1</span><br><span class="line">* babe974 (tag: apple, issue3) issue3操作</span><br><span class="line">* e0cb521 (issue2) issue2操作</span><br><span class="line">* b68b7e0 issue1分支添加</span><br><span class="line">*   94d7787 合并</span><br><span class="line">|\</span><br><span class="line">| * 2f6ac56 github 远程修改</span><br><span class="line">* | 844aa9c 本地修改</span><br><span class="line">|/</span><br><span class="line">* 83e0241 添加add的说明</span><br><span class="line">* 90fd96a first commit</span><br><span class="line"></span><br><span class="line">$ git checkout main</span><br><span class="line">Already on <span class="string">&#x27;main&#x27;</span></span><br><span class="line">Your branch is ahead of <span class="string">&#x27;origin/main&#x27;</span> by 2 commits.</span><br><span class="line">  (use <span class="string">&quot;git push&quot;</span> to publish your <span class="built_in">local</span> commits)</span><br><span class="line">$ git cherry-pick d711099</span><br><span class="line">$ git add sample.txt</span><br><span class="line">$ git commit</span><br><span class="line">[main 99db644] 修复bug1</span><br><span class="line"> Date: Fri Jun 24 09:17:21 2022 +0800</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">log</span> --graph --oneline</span><br><span class="line">* 99db644 (HEAD -&gt; main) 修复bug1</span><br><span class="line">* 40b4d95 cherry-pick</span><br><span class="line">* d2ed9d0 (origin/main) 执行commit --amend操作issue3操作</span><br><span class="line">* e0cb521 (issue2) issue2操作</span><br><span class="line">* b68b7e0 issue1分支添加</span><br><span class="line">*   94d7787 合并</span><br><span class="line">|\</span><br><span class="line">| * 2f6ac56 github 远程修改</span><br><span class="line">* | 844aa9c 本地修改</span><br><span class="line">|/</span><br><span class="line">* 83e0241 添加add的说明</span><br><span class="line">* 90fd96a first commit</span><br></pre></td></tr></table></figure>

<h3 id="改写提交的历史记录"><a href="#改写提交的历史记录" class="headerlink" title="改写提交的历史记录"></a>改写提交的历史记录</h3><p>在 rebase 指定 i 选项，您可以改写、替换、删除或合并提交。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/%E6%94%B9%E5%86%99%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95.png" class="">

<p>主要使用的场合：</p>
<ul>
<li>在 push 之前，重新输入正确的提交注解。</li>
<li>清楚地汇合内容含义相同的提交。</li>
<li>添加最近提交时漏掉的档案。</li>
</ul>
<h4 id="用-rebase-i-汇合提交"><a href="#用-rebase-i-汇合提交" class="headerlink" title="用 rebase -i 汇合提交"></a>用 rebase -i 汇合提交</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase -i HEAD~~</span><br><span class="line"></span><br><span class="line">pick 40b4d95 cherry-pick</span><br><span class="line">pick 99db644 修复bug1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase d2ed9d0..99db644 onto d2ed9d0 (2 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup [-C | -c] &lt;commit&gt; = like &quot;squash&quot; but keep only the previous</span></span><br><span class="line"><span class="comment">#                    commit&#x27;s log message, unless -C is used, in which case</span></span><br><span class="line"><span class="comment">#                    keep only this commit&#x27;s message; -c is same as -C but</span></span><br><span class="line"><span class="comment">#                    opens the editor</span></span><br><span class="line"><span class="comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span></span><br><span class="line"><span class="comment"># d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="comment"># l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="comment"># t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="line"><span class="comment"># .       create a merge commit using the original merge commit&#x27;s</span></span><br><span class="line"><span class="comment"># .       message (or the oneline, if no original merge commit was</span></span><br><span class="line"><span class="comment"># .       specified); use -c &lt;commit&gt; to reword the commit message</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>将第二行的 <code>pick</code> 改成 <code>squash</code>，然后保存并退出。由于合并后要提交，所以接着会显示提交信息的编辑器，请编辑信息后保存并退出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> $ git <span class="built_in">log</span> --graph --oneline</span><br><span class="line">* 6d58763 (HEAD -&gt; main) cherry-pick</span><br><span class="line">* d2ed9d0 (origin/main) 执行commit --amend操作issue3操作</span><br><span class="line">* e0cb521 (issue2) issue2操作</span><br><span class="line">* b68b7e0 issue1分支添加</span><br><span class="line">*   94d7787 合并</span><br><span class="line">|\</span><br><span class="line">| * 2f6ac56 github 远程修改</span><br><span class="line">* | 844aa9c 本地修改</span><br><span class="line">|/</span><br><span class="line">* 83e0241 添加add的说明</span><br><span class="line">* 90fd96a first commit</span><br></pre></td></tr></table></figure>

<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/rebase.png" class="">

<h4 id="用-rebase-i-修改提交"><a href="#用-rebase-i-修改提交" class="headerlink" title="用 rebase -i 修改提交"></a>用 rebase -i 修改提交</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase -i HEAD~~</span><br><span class="line"></span><br><span class="line"><span class="comment"># Rebase e0cb521..6d58763 onto e0cb521 (2 commands)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment"># p, pick &lt;commit&gt; = use commit</span></span><br><span class="line"><span class="comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span></span><br><span class="line"><span class="comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span></span><br><span class="line"><span class="comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span></span><br><span class="line"><span class="comment"># f, fixup [-C | -c] &lt;commit&gt; = like &quot;squash&quot; but keep only the previous</span></span><br><span class="line"><span class="comment">#                    commit&#x27;s log message, unless -C is used, in which case</span></span><br><span class="line"><span class="comment">#                    keep only this commit&#x27;s message; -c is same as -C but</span></span><br><span class="line"><span class="comment">#                    opens the editor</span></span><br><span class="line"><span class="comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="comment"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span></span><br><span class="line"><span class="comment"># d, drop &lt;commit&gt; = remove commit</span></span><br><span class="line"><span class="comment"># l, label &lt;label&gt; = label current HEAD with a name</span></span><br><span class="line"><span class="comment"># t, reset &lt;label&gt; = reset HEAD to a label</span></span><br><span class="line"><span class="comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span></span><br><span class="line"><span class="comment"># .       create a merge commit using the original merge commit&#x27;s</span></span><br><span class="line"><span class="comment"># .       message (or the oneline, if no original merge commit was</span></span><br><span class="line"><span class="comment"># .       specified); use -c &lt;commit&gt; to reword the commit message</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>将第一行的 <code>pick</code> 改成 <code>edit</code> ，然后保存并退出。将会显示以下内容，修改过的提交呈现退出状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Stopped at d2ed9d0...  执行commit --amend操作issue3操作</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">  git commit --amend</span><br><span class="line"></span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">  git rebase --<span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line">pick d2ed9d0 执行commit --amend操作issue3操作</span><br><span class="line">pick 6d58763 cherry-pick</span><br></pre></td></tr></table></figure>

<p>打开 <code>sample.txt</code>，适当地修改，用 <code>commit --amend</code> 保存修改。</p>
<p>现在已经 commit，但是 rebase 操作还没结束。若要通知这个提交的操作已经结束，请指定 <code>--continue</code> 选项执行 rebase。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add sample.txt</span><br><span class="line">$ git commit --amend</span><br><span class="line">[detached HEAD 1c5abb5] rebase 提交修改 执行commit --amend操作issue3操作</span><br><span class="line"> Date: Thu Jun 23 15:44:26 2022 +0800</span><br><span class="line"> 1 file changed, 4 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">$ git rebase --<span class="built_in">continue</span></span><br><span class="line">Auto-merging sample.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> sample.txt</span><br><span class="line">error: could not apply 6d58763... cherry-pick</span><br><span class="line">hint: Resolve all conflicts manually, mark them as resolved with</span><br><span class="line">hint: <span class="string">&quot;git add/rm &lt;conflicted_files&gt;&quot;</span>, <span class="keyword">then</span> run <span class="string">&quot;git rebase --continue&quot;</span>.</span><br><span class="line">hint: You can instead skip this commit: run <span class="string">&quot;git rebase --skip&quot;</span>.</span><br><span class="line">hint: To abort and get back to the state before <span class="string">&quot;git rebase&quot;</span>, run <span class="string">&quot;git rebase --abort&quot;</span>.</span><br><span class="line">Could not apply 6d58763... cherry-pick</span><br><span class="line"></span><br><span class="line">$ git add sample.txt</span><br><span class="line"></span><br><span class="line">$ git rebase --<span class="built_in">continue</span></span><br><span class="line">[detached HEAD f3082c9] cherry-pick</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line">Successfully rebased and updated refs/heads/main.</span><br></pre></td></tr></table></figure>

<p>提示发生冲突, 修改冲突部分后再执行 add 和 rebase –continue 即可，不需要 commit 操作。</p>
<p>如果在中途要停止 rebase 操作，请在 rebase 指定 <code>--abort</code> 选项执行，这样就可以抹去并停止在 rebase 的操作。</p>
<p>如果要把多个提交修改成 edit，下一个要修改的提交会退出，请执行同样的修改。</p>
<blockquote>
<p>实际上，在 rebase 之前的提交会以 ORIG_HEAD 之名存留。如果 rebase 之后无法复原到原先的状态，可以用 git reset –hard ORIG_HEAD 复原到 rebase 之前的状态。</p>
</blockquote>
<h3 id="汇合分支上的提交，然后一同合并到分支"><a href="#汇合分支上的提交，然后一同合并到分支" class="headerlink" title="汇合分支上的提交，然后一同合并到分支"></a>汇合分支上的提交，然后一同合并到分支</h3><p>merge 的特殊选项 squash 用这个选项指定分支的合并，就可以把所有汇合的提交添加到分支上。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/%E6%B1%87%E5%90%88%E5%88%86%E6%94%AF%E4%B8%8A%E7%9A%84%E6%8F%90%E4%BA%A4.png" class="">

<p>主要使用的场合：</p>
<ul>
<li>汇合主题分支的提交，然后合并提交到目标分支。</li>
</ul>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/merge-before.png" class="">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge --squash issue3</span><br><span class="line">Auto-merging sample.txt</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> sample.txt</span><br><span class="line">Squash commit -- not updating HEAD</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line"></span><br><span class="line">$ git add sample.txt</span><br><span class="line">$ git commit</span><br><span class="line">[main feca35d] Squashed commit of the following:</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>issue3 分支上所有的提交都汇合并添加到 main 分支了。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/marge-after.png" class="">

<h1 id="风格指南"><a href="#风格指南" class="headerlink" title="风格指南"></a>风格指南</h1><p>下列内容主要来自：<a href="https://github.com/aseaday/git-style-guide">https://github.com/aseaday/git-style-guide</a></p>
<p>这份风格指南受到 <a href="https://www.kernel.org/doc/Documentation/SubmittingPatches"><em>How to Get Your Change Into the Linux Kernel</em></a>，<a href="http://git-scm.com/doc">git man pages</a> 和大量社区通用实践的启发。</p>
<ol>
<li><a href="#branches">分支</a></li>
<li><a href="#commits">提交</a></li>
<li><a href="#messages">消息</a></li>
<li><a href="#merging">合并</a></li>
<li><a href="#misc">杂项</a></li>
</ol>
<h2 id="Branches"><a href="#Branches" class="headerlink" title="Branches"></a>Branches</h2><ul>
<li><p>选择<em>简短</em>和<em>具有描述性</em>的名字来命名分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">好</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b oauth-migration</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不好，过于模糊</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b login_fix</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>来自外部的标识符也适合用作分支的名字，例如来自 Github 的 Issue 序号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">GitHub issue <span class="comment">#15</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b issue-15</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用破折号分割单词。</p>
</li>
<li><p>当不同的人围绕同一个特性开发时，维护整个团队的特性分支与每个人的独立分支是比较方便的做法。使用如下的命名方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b feature-a/master <span class="comment"># team-wide branch</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b feature-a/maria <span class="comment"># Maria&#x27;s branch</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b feature-a/nick <span class="comment"># Nick&#x27;s branch</span></span></span><br></pre></td></tr></table></figure>

<p>合并时，由每个人的独立分支向全队的功能分支合并，最后合并到主分支。见<a href="#merging">合并</a> 。</p>
</li>
<li><p>合并之后，除非有特殊原因要求不删，否则从上游仓库中删除你的分支。使用如下命令查看已合并的分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --merged | grep -v <span class="string">&quot;\*&quot;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Commits"><a href="#Commits" class="headerlink" title="Commits"></a>Commits</h2><ul>
<li>每个提交应当只包含一个简单的逻辑改动，不要在一个提交里包含多个逻辑改动。比如，如果一个补丁修复了一个 Bug，又优化了一个特性的性能，就将其拆分。</li>
<li>不要将一个逻辑改动拆分提交。例如一个功能的实现及其对应的测试应当一并提交。</li>
<li>尽早、尽快提交。出问题时，短小、完整的提交更容易发现并修正。</li>
<li>提交应当依<em>逻辑</em>排序。例如，如果 X 提交依赖于 Y，那么 Y 提交应该在 X 前面。</li>
</ul>
<h3 id="Messages"><a href="#Messages" class="headerlink" title="Messages"></a>Messages</h3><ul>
<li><p>使用编辑器编写提交信息，而非命令行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">好</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不好</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;Quick fix&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>使用命令行会鼓励试图用一行概括提交內容的风气，而这会令提交信息难以理解。</p>
</li>
<li><p>概要行（即第一行）应当简明扼要。它最好不超过 50 个字符，首字母大写，使用现在时祈使语气。不要以句号结尾, 因为它相当于<em>标题</em>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">好</span></span><br><span class="line">Mark huge records as obsolete when clearing hinting faults</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不好</span></span><br><span class="line">fixed ActiveModel::Errors deprecation messages failing when AR was used outside of Rails.</span><br></pre></td></tr></table></figure>
</li>
<li><p>在那之后空一行，然后填写详细描述。每行不超过 _72 字符_，解释<em>为什么</em>需要改动, <em>如何</em>解决了这个 issue 以及它有什么<em>副作用</em>。</p>
<p>最好提供相关资源的链接，例如 bug tracker 的 issue 编号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Short (50 chars or fewer) summary of changes</span><br><span class="line"></span><br><span class="line">More detailed explanatory text, if necessary. Wrap it to</span><br><span class="line">72 characters. In some contexts, the first</span><br><span class="line">line is treated as the subject of an email and the rest of</span><br><span class="line">the text as the body.  The blank line separating the</span><br><span class="line">summary from the body is critical (unless you omit the body</span><br><span class="line">entirely); tools like rebase can get confused if you run</span><br><span class="line">the two together.</span><br><span class="line"></span><br><span class="line">Further paragraphs come after blank lines.</span><br><span class="line"></span><br><span class="line">- Bullet points are okay, too</span><br><span class="line"></span><br><span class="line">- Use a hyphen or an asterisk for the bullet,</span><br><span class="line">  followed by a single space, with blank lines in</span><br><span class="line">  between</span><br><span class="line"></span><br><span class="line">Source http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html</span><br></pre></td></tr></table></figure>

<p>最后，编写提交信息时，设想一下你一年以后再看这段提交信息时，希望获取什么信息。</p>
</li>
<li><p>如果 <em>提交 A</em> 依赖于另一个 <em>提交 B</em> ，在前者的 commit message 中应当指明。援引对应提交的 Hash。</p>
<p>同理，如果 <em>提交 A</em> 解决了 <em>提交 B</em> 引入的 bug，这应当也被在 <em>提交 A</em> 提及。</p>
</li>
<li><p>如果将一个提交 squash 到另一个提交，分别使用 <code>--squash</code> 和 <code>--fixup</code> 来强调目的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --squash f387cab2</span></span><br></pre></td></tr></table></figure>
<p><em>（Rebase 时使用 <code>--autosquash</code> 参数，标记的提交就会自动 squash。）</em></p>
</li>
</ul>
<h2 id="Merging"><a href="#Merging" class="headerlink" title="Merging"></a>Merging</h2><ul>
<li><p><strong>不要篡改提交历史</strong>。仓库的历史本身就很宝贵，重要的是它能够还原<em>实际发生了什么</em>。对任何参与项目的人来说，修改历史是万恶之源。</p>
</li>
<li><p>尽管如此，有些时候还是可以重写历史，例如：</p>
<ul>
<li>你一个人孤军奋战，而且你的代码不会被人看到。</li>
<li>你希望整理分支（例如使用 squash），以便日后合并。<br>最重要的，<em>不要重写你的 master 分支历史</em> 或者任何有特殊意义的分支（例如发布分支或 CI 分支）。</li>
</ul>
</li>
<li><p>保持你的提交历史<em>干净</em>、<em>简单_。_在你 merge</em> 你的分支之前：</p>
<ol>
<li>确保它符合风格指南，如果不符合就执行相应操作，比如 squash 或重写提交信息。</li>
<li>将其 rebase 到目标分支：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[my-branch] $ git fetch</span><br><span class="line">[my-branch] $ git rebase origin/master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">then</span> merge</span></span><br></pre></td></tr></table></figure>
这样会在 master 后直接添加一个新版本，令提交历史更简洁。</li>
</ol>
<p><em>（这个策略更适合较短生命周期的分支，否则还是最好经常合并而不是 rebase。）</em></p>
</li>
<li><p>如果你的分支包含多个 commmit , 不要使用快进模式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">好；注意添加合并信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff my-branch</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不好</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge my-branch</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc."></a>Misc.</h2><ul>
<li><p>有许多工作流，每一个都有好有坏。一个工作流是否符合你的情况，取决于你的团队，项目，和你的开发规律。</p>
<p>也就是说，重要的是认真 <em>选择</em> 合适的工作流并且坚持。</p>
</li>
<li><p>_保持统一_， 这涉及到从工作流到你的提交信息，分支名还有标签。 在整个 Repository 中保持统一的命名风格有助于辨认工作进度。</p>
</li>
<li><p>_push 前测试_， 不要提交未完成的工作。</p>
</li>
<li><p>使用 <a href="http://git-scm.com/book/en/v2/Git-Basics-Tagging#Annotated-Tags">annotated tags</a> 标记发布版本或者其他重要的时间点。</p>
<p>个人开发可以使用 <a href="http://git-scm.com/book/en/v2/Git-Basics-Tagging#Lightweight-Tags">lightweight tags</a>，例如为以后参考做标记。</p>
</li>
<li><p>定期维护，保证你的仓库状态良好，包括本地还有远程的仓库。</p>
<ul>
<li><a href="http://git-scm.com/docs/git-gc"><code>git-gc(1)</code></a></li>
<li><a href="http://git-scm.com/docs/git-prune"><code>git-prune(1)</code></a></li>
<li><a href="http://git-scm.com/docs/git-fsck"><code>git-fsck(1)</code></a></li>
</ul>
</li>
</ul>
<h3 id="如何恢复初始的-git-提交。"><a href="#如何恢复初始的-git-提交。" class="headerlink" title="如何恢复初始的 git 提交。"></a>如何恢复初始的 git 提交。</h3><p>您可以删除 HEAD 并将存储库还原到新的状态，在该状态下可以创建一个新的初始提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git update-ref -d HEAD</span><br></pre></td></tr></table></figure>

<p>创建新提交之后，如果您已经将其推入远程，则需要强制将其发送到远程，以便覆盖先前的初始提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --force origin</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不要使用 <code>rm -rf .git</code> 或者像这样的任何操作，这样都会彻底清除整个存储库，包括所有其他分支，以及您试图重置的分支。</p>
</blockquote>
<h3 id="撤销-git-add-和-commit-操作"><a href="#撤销-git-add-和-commit-操作" class="headerlink" title="撤销 git add 和 commit 操作"></a>撤销 git add 和 commit 操作</h3><p>还没有 push 的时候使用 reset 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --mixed commit_id    <span class="comment">#不删除工作空间改动代码，撤销 commit ，并且撤销 git add . 操作，默认操作。</span></span><br><span class="line">git reset --soft  commit_id    <span class="comment"># 不删除工作空间改动代码，撤销 commit ，不撤销 git add .  。</span></span><br><span class="line">git reset --hard commit_id     <span class="comment"># 删除工作空间改动代码，撤销 commit ，撤销 git add . 慎用这个命令。</span></span><br><span class="line">git reset –hard origin/master  <span class="comment"># 将本地的状态回退到和远程的一样</span></span><br><span class="line">git commit --amend             <span class="comment"># 只是改一下注释</span></span><br></pre></td></tr></table></figure>

<p>已经 push 了，可以使用 git revert 还原已经提交的修改 ，此次操作之前和之后的 commit 和 history 都会保留，并且把这次撤销作为一次最新的提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git revert HEAD          <span class="comment"># 撤销前一次 commit 。</span></span><br><span class="line">git revert HEAD~n        <span class="comment"># 撤销前n次 commit 。</span></span><br><span class="line">git revert commit-id     <span class="comment"># 撤销指定的版本，撤销也会作为一次提交进行保存。</span></span><br><span class="line">git reset HEAD^ file     <span class="comment"># 回退 flie 这个文件的版本到上一个版本</span></span><br></pre></td></tr></table></figure>

<h3 id="解决-Git-更新本地冲突：commit-your-changes-or-stash-them-before-you-can-merge"><a href="#解决-Git-更新本地冲突：commit-your-changes-or-stash-them-before-you-can-merge" class="headerlink" title="解决 Git 更新本地冲突：commit your changes or stash them before you can merge"></a>解决 Git 更新本地冲突：commit your changes or stash them before you can merge</h3><p>方法一：stash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash               让工作区内容保证与上一次提交内容相同，同时备份当前修改的内容</span><br><span class="line">git pull                 拉取仓库的最新内容</span><br><span class="line">git stash pop       在仓库最新内容的基础上添加当前修改的内容</span><br></pre></td></tr></table></figure>

<p>方法二：直接完全覆盖本地修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h3 id="如何清洗-Github-提交历史"><a href="#如何清洗-Github-提交历史" class="headerlink" title="如何清洗 Github 提交历史"></a>如何清洗 Github 提交历史</h3><p>当 Github 的 Repo 变得日益臃肿、或者上传了敏感内容时，常见的方法时清理相关文件的所有历史提交记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git filter-branch --force --index-filter <span class="string">&#x27;git rm --cached --ignore-unmatch $&#123;FILEPATH&#125;&#x27;</span> --prune-empty --tag-name-filter <span class="built_in">cat</span> -- --all</span><br><span class="line">git push origin master --force</span><br><span class="line"><span class="built_in">rm</span> -rf .git/refs/original/</span><br><span class="line">git reflog expire --expire=now --all</span><br><span class="line">git gc --prune=now</span><br><span class="line">git gc --aggressive --prune=now</span><br></pre></td></tr></table></figure>

<p>但若这类文件非常多的时候，一个可选的方法时直接清空所有历史记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .git</span><br><span class="line">git init git</span><br><span class="line">add -A</span><br><span class="line">git commit -m <span class="string">&quot;clear history&quot;</span></span><br><span class="line">git remote add origin <span class="variable">$&#123;GITHUB_REPO_URL&#125;</span></span><br><span class="line">git push -f -u origin master</span><br></pre></td></tr></table></figure>

<p>参考链接: <a href="https://exp-blog.com/scm/qing-xi-github-ti-jiao-li-shi/">https://exp-blog.com/scm/qing-xi-github-ti-jiao-li-shi/</a></p>
<h3 id="ssh-方式及免密码配置"><a href="#ssh-方式及免密码配置" class="headerlink" title="ssh 方式及免密码配置"></a>ssh 方式及免密码配置</h3><p>git ssh 方式免密提交方式需要将 ssh-keygen 生成的公钥放到服务器上</p>
<p>全局用户名密码配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;CKCat&quot;</span><br><span class="line">git config --global user.email &quot;ckcatck@qq.com&quot;</span><br></pre></td></tr></table></figure>

<p>生成公钥和私钥</p>
<p>1、首先需要检查你电脑是否已经有 SSH key</p>
<p>运行 git Bash 客户端，检查本机的 ssh 密钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br><span class="line">$ <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>如果不是第一次使用，已经存在 <code>id_rsa.pub</code> 或 <code>id_dsa.pub</code> 文件。请执行下面的操作，清理原有 ssh 密钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> key_backup</span><br><span class="line">$ <span class="built_in">cp</span> id_rsa* key_backup</span><br><span class="line">$ <span class="built_in">rm</span> id_rsa*</span><br></pre></td></tr></table></figure>

<p>2、执行生成公钥和私钥的命令，生成新的密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;CKCat&quot;</span></span><br></pre></td></tr></table></figure>

<p>代码参数：</p>
<p><code>-t</code> 指定密钥类型，默认是 rsa ，可以省略。</p>
<p><code>-C</code> 设置注释文字，比如邮箱。</p>
<p>执行命令时会提示要求输入邮箱密码，这个密码会在提交时使用，如果为空的话提交时则不用输入。这个设置是防止别人往你的项目里提交内容。我们自己的电脑，自己本机使用，当然不用密码了。</p>
<p>按默认为空，直接按回车 3 下，生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个秘钥文件。</p>
<p>执行查看公钥信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>Windows 系统，位置在用户目录下 <code>.ssh</code>文件夹中。<code>%USERPROFILE%</code></p>
<p>3、复制公钥信息，打开 github，我的账户 -&gt; setting -&gt; SSH and GPG keys，如下图所示，把公钥粘贴到公钥文本框中，标题自己定义，然后点击确定按键，输入密码。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2021-06-14-18-15-01.png" class="">

<p>然后，提交时就不再需要用户名和密码了。</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="https://backlog.com/git-tutorial/cn/">https://backlog.com/git-tutorial/cn/</a></p>
<p><a href="https://github.com/aseaday/git-style-guide">https://github.com/aseaday/git-style-guide</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>gnu-linux-proc-pid-intro</title>
    <url>/2021/05/13/gnu-linux-proc-pid-intro/</url>
    <content><![CDATA[<blockquote>
<p>转载：<a href="https://github.com/NanXiao/gnu-linux-proc-pid-intro">https://github.com/NanXiao/gnu-linux-proc-pid-intro</a></p>
</blockquote>
<p><a href="#auxv">&#x2F;proc&#x2F;[pid]&#x2F;auxv</a><br><a href="#cmdline">&#x2F;proc&#x2F;[pid]&#x2F;cmdline</a><br><a href="#comm">&#x2F;proc&#x2F;[pid]&#x2F;comm</a><br><a href="#cwd">&#x2F;proc&#x2F;[pid]&#x2F;cwd</a><br><a href="#environ">&#x2F;proc&#x2F;[pid]&#x2F;environ</a><br><a href="#exe">&#x2F;proc&#x2F;[pid]&#x2F;exe</a><br><a href="#fd">&#x2F;proc&#x2F;[pid]&#x2F;fd</a><br><a href="#latency">&#x2F;proc&#x2F;[pid]&#x2F;latency</a><br><a href="#limits">&#x2F;proc&#x2F;[pid]&#x2F;limits</a><br><a href="#maps">&#x2F;proc&#x2F;[pid]&#x2F;maps</a><br><a href="#root">&#x2F;proc&#x2F;[pid]&#x2F;root</a><br><a href="#stack">&#x2F;proc&#x2F;[pid]&#x2F;stack</a><br><a href="#statm">&#x2F;proc&#x2F;[pid]&#x2F;statm</a><br><a href="#status">&#x2F;proc&#x2F;[pid]&#x2F;status</a><br><a href="#syscall">&#x2F;proc&#x2F;[pid]&#x2F;syscall</a><br><a href="#wchan">&#x2F;proc&#x2F;[pid]&#x2F;wchan</a>  </p>
<h2 id="auxv"><a href="#auxv" class="headerlink" title="auxv"></a>auxv</h2><p><code>/proc/[pid]/auxv</code>包含传递给进程的<code>ELF</code>解释器信息，格式是每一项都是一个<code>unsigned long</code>长度的<code>ID</code>加上一个<code>unsigned long</code>长度的值。最后一项以连续的两个<code>0x00</code>开头。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexdump -x /proc/2948/auxv</span></span><br><span class="line">0000000    0021    0000    0000    0000    0000    1a82    7ffd    0000</span><br><span class="line">0000010    0010    0000    0000    0000    dbf5    1fc9    0000    0000</span><br><span class="line">0000020    0006    0000    0000    0000    1000    0000    0000    0000</span><br><span class="line">0000030    0011    0000    0000    0000    0064    0000    0000    0000</span><br><span class="line">0000040    0003    0000    0000    0000    2040    4326    7f4a    0000</span><br><span class="line">0000050    0004    0000    0000    0000    0038    0000    0000    0000</span><br><span class="line">0000060    0005    0000    0000    0000    0009    0000    0000    0000</span><br><span class="line">0000070    0007    0000    0000    0000    f000    4303    7f4a    0000</span><br><span class="line">0000080    0008    0000    0000    0000    0000    0000    0000    0000</span><br><span class="line">0000090    0009    0000    0000    0000    8e67    4327    7f4a    0000</span><br><span class="line">00000a0    000b    0000    0000    0000    0000    0000    0000    0000</span><br><span class="line">00000b0    000c    0000    0000    0000    0000    0000    0000    0000</span><br><span class="line">00000c0    000d    0000    0000    0000    0000    0000    0000    0000</span><br><span class="line">00000d0    000e    0000    0000    0000    0000    0000    0000    0000</span><br><span class="line">00000e0    0017    0000    0000    0000    0000    0000    0000    0000</span><br><span class="line">00000f0    0019    0000    0000    0000    3de9    1a80    7ffd    0000</span><br><span class="line">0000100    001f    0000    0000    0000    4fe5    1a80    7ffd    0000</span><br><span class="line">0000110    000f    0000    0000    0000    3df9    1a80    7ffd    0000</span><br><span class="line">0000120    0000    0000    0000    0000    0000    0000    0000    0000</span><br><span class="line">0000130</span><br></pre></td></tr></table></figure>
<p>解析这个文件可以参考这段<a href="http://www.wienand.org/junkcode/linux/read-auxv.c">代码</a>。</p>
<h2 id="cmdline"><a href="#cmdline" class="headerlink" title="cmdline"></a>cmdline</h2><p><code>/proc/[pid]/cmdline</code>是一个只读文件，包含进程的完整命令行信息。如果这个进程是<code>zombie</code>进程，则这个文件没有任何内容。举例如下：    </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ps -ef | grep 2948</span></span><br><span class="line">root       2948      1  0 Nov05 ?        00:00:04 /usr/sbin/libvirtd --listen</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /proc/2948/cmdline</span></span><br><span class="line">/usr/sbin/libvirtd--listen</span><br></pre></td></tr></table></figure>

<h2 id="comm"><a href="#comm" class="headerlink" title="comm"></a>comm</h2><p><code>/proc/[pid]/comm</code>包含进程的命令名。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/comm</span></span><br><span class="line">libvirtd</span><br></pre></td></tr></table></figure>

<h2 id="cwd"><a href="#cwd" class="headerlink" title="cwd"></a>cwd</h2><p><code>/proc/[pid]/cwd</code>是进程当前工作目录的符号链接。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls -lt /proc/2948/cwd</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Nov  9 12:14 /proc/2948/cwd -&gt; /</span><br></pre></td></tr></table></figure>

<h2 id="environ"><a href="#environ" class="headerlink" title="environ"></a>environ</h2><p><code>/proc/[pid]/environ</code>显示进程的环境变量。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># strings /proc/2948/environ</span></span><br><span class="line">LANG=POSIX</span><br><span class="line">LC_CTYPE=en_US.UTF-8</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">NOTIFY_SOCKET=@/org/freedesktop/systemd1/notify</span><br><span class="line">LIBVIRTD_CONFIG=/etc/libvirt/libvirtd.conf</span><br><span class="line">LIBVIRTD_ARGS=--listen</span><br><span class="line">LIBVIRTD_NOFILES_LIMIT=2048</span><br></pre></td></tr></table></figure>


<h2 id="exe"><a href="#exe" class="headerlink" title="exe"></a>exe</h2><p><code>/proc/[pid]/exe</code>为实际运行程序的符号链接。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls -lt /proc/2948/exe</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Nov  5 13:04 /proc/2948/exe -&gt; /usr/sbin/libvirtd</span><br></pre></td></tr></table></figure>


<h2 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h2><p><code>/proc/[pid]/fd</code>是一个目录，包含进程打开文件的情况。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls -lt /proc/3801/fd</span></span><br><span class="line">total 0</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 0 -&gt; socket:[37445]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 1 -&gt; socket:[37446]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 10 -&gt; socket:[31729]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 11 -&gt; socket:[34562]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 12 -&gt; socket:[39978]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 13 -&gt; socket:[34574]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 14 -&gt; socket:[39137]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 15 -&gt; socket:[39208]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 16 -&gt; socket:[39221]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 17 -&gt; socket:[41080]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 18 -&gt; socket:[40014]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 19 -&gt; socket:[34617]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 20 -&gt; socket:[34620]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 23 -&gt; socket:[42357]</span><br><span class="line">lr-x------. 1 root root 64 Apr 18 16:51 3 -&gt; /dev/urandom</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 4 -&gt; socket:[37468]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 5 -&gt; socket:[37471]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 6 -&gt; socket:[289532]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 7 -&gt; socket:[31728]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 8 -&gt; socket:[37450]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 9 -&gt; socket:[37451]</span><br><span class="line">l-wx------. 1 root root 64 Apr 13 16:35 2 -&gt; /root/.vnc/localhost.localdomain:1.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>目录中的每一项都是一个符号链接，指向打开的文件，数字则代表文件描述符。  </p>
<h2 id="latency"><a href="#latency" class="headerlink" title="latency"></a>latency</h2><p><code>/proc/[pid]/latency</code>显示哪些代码造成的延时比较大（使用这个<code>feature</code>，需要执行“<code>echo 1 &gt; /proc/sys/kernel/latencytop</code>”）。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/latency</span></span><br><span class="line">Latency Top version : v0.1</span><br><span class="line">30667 10650491 4891 poll_schedule_timeout do_sys_poll SyS_poll system_call_fastpath 0x7f636573dc1d</span><br><span class="line">8 105 44 futex_wait_queue_me futex_wait do_futex SyS_futex system_call_fastpath 0x7f6365a167bc</span><br></pre></td></tr></table></figure>

<p>每一行前三个数字分别是后面代码执行的次数，总共执行延迟时间（单位是微秒）和最长执行延迟时间（单位是微秒），后面则是代码完整的调用栈。</p>
<h2 id="limits"><a href="#limits" class="headerlink" title="limits"></a>limits</h2><p><code>/proc/[pid]/limits</code>显示当前进程的资源限制。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/limits</span></span><br><span class="line">Limit                     Soft Limit           Hard Limit           Units</span><br><span class="line">Max cpu time              unlimited            unlimited            seconds</span><br><span class="line">Max file size             unlimited            unlimited            bytes</span><br><span class="line">Max data size             unlimited            unlimited            bytes</span><br><span class="line">Max stack size            8388608              unlimited            bytes</span><br><span class="line">Max core file size        0                    unlimited            bytes</span><br><span class="line">Max resident <span class="built_in">set</span>          unlimited            unlimited            bytes</span><br><span class="line">Max processes             6409                 6409                 processes</span><br><span class="line">Max open files            1024                 4096                 files</span><br><span class="line">Max locked memory         65536                65536                bytes</span><br><span class="line">Max address space         unlimited            unlimited            bytes</span><br><span class="line">Max file locks            unlimited            unlimited            locks</span><br><span class="line">Max pending signals       6409                 6409                 signals</span><br><span class="line">Max msgqueue size         819200               819200               bytes</span><br><span class="line">Max <span class="built_in">nice</span> priority         0                    0</span><br><span class="line">Max realtime priority     0                    0</span><br><span class="line">Max realtime <span class="built_in">timeout</span>      unlimited            unlimited            us</span><br></pre></td></tr></table></figure>

<p><code>Soft Limit</code>表示<code>kernel</code>设置给资源的值，<code>Hard Limit</code>表示<code>Soft Limit</code>的上限，而<code>Units</code>则为计量单元。</p>
<h2 id="maps"><a href="#maps" class="headerlink" title="maps"></a>maps</h2><p><code>/proc/[pid]/maps</code>显示进程的内存区域映射信息。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/maps</span></span><br><span class="line">......</span><br><span class="line">address                   perms offset  dev   inode                      pathname</span><br><span class="line">7f4a2e2ad000-7f4a2e2ae000 rw-p 00006000 08:14 6505977                    /usr/lib64/sasl2/libsasldb.so.3.0.0</span><br><span class="line">7f4a2e2ae000-7f4a2e2af000 ---p 00000000 00:00 0</span><br><span class="line">7f4a2e2af000-7f4a2eaaf000 rw-p 00000000 00:00 0                          [stack:94671]</span><br><span class="line">7f4a2eaaf000-7f4a2eab0000 ---p 00000000 00:00 0</span><br><span class="line">7f4a2eab0000-7f4a2f2b0000 rw-p 00000000 00:00 0                          [stack:94670]</span><br><span class="line">......</span><br><span class="line">7f4a434d0000-7f4a434d5000 rw-p 0006e000 08:14 4292988                    /usr/sbin/libvirtd</span><br><span class="line">7f4a4520a000-7f4a452f7000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">7ffd1a7e4000-7ffd1a805000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffd1a820000-7ffd1a821000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure>
<p>其中注意的一点是<code>[stack:&lt;tid&gt;]</code>是线程的堆栈信息，对应于<code>/proc/[pid]/task/[tid]/</code>路径。  </p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p><code>/proc/[pid]/root</code>是进程根目录的符号链接。举例如下： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls -lt /proc/2948/root</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Nov  9 12:14 /proc/2948/root -&gt; /</span><br></pre></td></tr></table></figure>

<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p><code>/proc/[pid]/stack</code>显示当前进程的内核调用栈信息，只有内核编译时打开了<code>CONFIG_STACKTRACE</code>编译选项，才会生成这个文件。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/stack</span></span><br><span class="line">[&lt;ffffffff80168375&gt;] poll_schedule_timeout+0x45/0x60</span><br><span class="line">[&lt;ffffffff8016994d&gt;] do_sys_poll+0x49d/0x550</span><br><span class="line">[&lt;ffffffff80169abd&gt;] SyS_poll+0x5d/0xf0</span><br><span class="line">[&lt;ffffffff804c16e7&gt;] system_call_fastpath+0x16/0x1b</span><br><span class="line">[&lt;00007f4a41ff2c1d&gt;] 0x7f4a41ff2c1d</span><br><span class="line">[&lt;ffffffffffffffff&gt;] 0xffffffffffffffff</span><br></pre></td></tr></table></figure>

<h2 id="statm"><a href="#statm" class="headerlink" title="statm"></a>statm</h2><p><code>/proc/[pid]/statm</code>显示进程所占用内存大小的统计信息，包含七个值，度量单位是<code>page</code>（<code>page</code>大小可通过<code>getconf PAGESIZE</code>得到）。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/statm  </span></span><br><span class="line">72362 12945 4876 569 0 24665 0</span><br></pre></td></tr></table></figure>


<p>各个值含义：<br>    a）进程占用的总的内存；<br>    b）进程当前时刻占用的物理内存；<br>    c）同其它进程共享的内存；<br>    d）进程的代码段；<br>    e）共享库（从<code>2.6</code>版本起，这个值为<code>0</code>）；<br>    f）进程的堆栈；<br>    g）<code>dirty pages</code>（从<code>2.6</code>版本起，这个值为<code>0</code>）。  </p>
<h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p><code>/proc/[pid]/status</code>包含进程的状态信息。其很多内容与<code>/proc/[pid]/stat</code>和<code>/proc/[pid]/statm</code>，但是却是以一种更清晰地方式展现出来。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/$$/status</span></span><br><span class="line">Name:   bash</span><br><span class="line">Umask:  0022</span><br><span class="line">State:  S (sleeping)</span><br><span class="line">Tgid:   15694</span><br><span class="line">Ngid:   0</span><br><span class="line">Pid:    15694</span><br><span class="line">PPid:   15692</span><br><span class="line">TracerPid:      0</span><br><span class="line">Uid:    0       0       0       0</span><br><span class="line">Gid:    0       0       0       0</span><br><span class="line">FDSize: 256</span><br><span class="line">Groups: 0 1 2 3 4 6 10 19</span><br><span class="line">NStgid: 15694</span><br><span class="line">NSpid:  15694</span><br><span class="line">NSpgid: 15694</span><br><span class="line">NSsid:  15694</span><br><span class="line">VmPeak:    26040 kB</span><br><span class="line">VmSize:    26040 kB</span><br><span class="line">VmLck:         0 kB</span><br><span class="line">VmPin:         0 kB</span><br><span class="line">VmHWM:      5412 kB</span><br><span class="line">VmRSS:      5412 kB</span><br><span class="line">RssAnon:            2272 kB</span><br><span class="line">RssFile:            3140 kB</span><br><span class="line">RssShmem:              0 kB</span><br><span class="line">VmData:     2244 kB</span><br><span class="line">VmStk:       132 kB</span><br><span class="line">VmExe:       792 kB</span><br><span class="line">VmLib:      2732 kB</span><br><span class="line">VmPTE:        68 kB</span><br><span class="line">VmPMD:        12 kB</span><br><span class="line">VmSwap:        0 kB</span><br><span class="line">HugetlbPages:          0 kB</span><br><span class="line">Threads:        1</span><br><span class="line">SigQ:   0/11753</span><br><span class="line">SigPnd: 0000000000000000</span><br><span class="line">ShdPnd: 0000000000000000</span><br><span class="line">SigBlk: 0000000000010000</span><br><span class="line">SigIgn: 0000000000380004</span><br><span class="line">SigCgt: 000000004b817efb</span><br><span class="line">CapInh: 0000000000000000</span><br><span class="line">CapPrm: 0000003fffffffff</span><br><span class="line">CapEff: 0000003fffffffff</span><br><span class="line">CapBnd: 0000003fffffffff</span><br><span class="line">CapAmb: 0000000000000000</span><br><span class="line">NoNewPrivs:     0</span><br><span class="line">Seccomp:        0</span><br><span class="line">Cpus_allowed:   f</span><br><span class="line">Cpus_allowed_list:      0-3</span><br><span class="line">Mems_allowed:   00000000,00000001</span><br><span class="line">Mems_allowed_list:      0</span><br><span class="line">voluntary_ctxt_switches:        1045</span><br><span class="line">nonvoluntary_ctxt_switches:     30</span><br></pre></td></tr></table></figure>
<p>关于信号（<code>signal</code>）的信息：<code>SigQ</code>分为两部分（例如<code>0/11753</code>），前面表示当前处在队列中的信号（<code>0</code>），后面则表示队列一共可以存储多少信号（<code>11753</code>）；<code>SigPnd</code>表示当前线程<code>pending</code>的信号，而<code>ShdPnd</code>则表示整个进程<code>pending</code>的信号；<code>SigBlk</code>、<code>SigIgn</code>和<code>SigCgt</code>分别表示对信号的处理是阻塞，忽略，还是捕获。（关于<code>Unix</code>信号的相关知识，可以参考<a href="https://www.networkworld.com/article/3211296/linux/unix-dealing-with-signals.html">Unix: Dealing with signals</a>）。</p>
<h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><p><code>/proc/[pid]/syscall</code>显示当前进程正在执行的系统调用。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/syscall</span></span><br><span class="line">7 0x7f4a452cbe70 0xb 0x1388 0xffffffffffdff000 0x7f4a4274a750 0x0 0x7ffd1a8033f0 0x7f4a41ff2c1d</span><br></pre></td></tr></table></figure>

<p>第一个值是系统调用号（<code>7</code>代表<code>poll</code>），后面跟着<code>6</code>个系统调用的参数值（位于寄存器中），最后两个值依次是堆栈指针和指令计数器的值。如果当前进程虽然阻塞，但阻塞函数并不是系统调用，则系统调用号的值为<code>-1</code>，后面只有堆栈指针和指令计数器的值。如果进程没有阻塞，则这个文件只有一个“<code>running</code>”的字符串。</p>
<p>内核编译时打开了<code>CONFIG_HAVE_ARCH_TRACEHOOK</code>编译选项，才会生成这个文件。  </p>
<h2 id="wchan"><a href="#wchan" class="headerlink" title="wchan"></a>wchan</h2><p><code>/proc/[pid]/wchan</code>显示当进程<code>sleep</code>时，<code>kernel</code>当前运行的函数。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/wchan</span></span><br><span class="line">kauditd_thread</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle学习</title>
    <url>/2019/11/20/gradle%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#1-%E5%AE%89%E8%A3%85gradle">1. 安装<code>gradle</code></a></li>
<li><a href="#2-%E5%85%A5%E9%97%A8%E5%89%8D%E5%A5%8F">2. 入门前奏</a><ul>
<li><a href="#21-%E5%AE%9E%E7%8E%B0-hello-world">2.1. 实现 <code>hello world</code></a></li>
<li><a href="#22-gradle-%E7%9A%84%E4%BB%BB%E5%8A%A1">2.2. <code>gradle</code> 的任务</a><ul>
<li><a href="#221-%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1">2.2.1. 创建任务</a><ul>
<li><a href="#2211-%E7%9B%B4%E6%8E%A5%E7%94%A8%E4%BB%BB%E5%8A%A1%E5%90%8D%E7%A7%B0%E5%88%9B%E5%BB%BA">2.2.1.1. 直接用任务名称创建</a></li>
<li><a href="#2212-%E4%BB%BB%E5%8A%A1%E5%90%8D%E7%A7%B0%E4%BB%BB%E5%8A%A1%E9%85%8D%E7%BD%AE%E5%88%9B%E5%BB%BA">2.2.1.2. 任务名称+任务配置创建</a></li>
<li><a href="#2213-taskcontainer%E7%9A%84create%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA">2.2.1.3. TaskContainer的create方法创建</a></li>
</ul>
</li>
<li><a href="#222-%E4%BB%BB%E5%8A%A1%E4%BE%9D%E8%B5%96">2.2.2. 任务依赖</a><ul>
<li><a href="#2221-%E5%8A%A8%E6%80%81%E5%AE%9A%E4%B9%89%E4%BB%BB%E5%8A%A1">2.2.2.1. 动态定义任务</a></li>
</ul>
</li>
<li><a href="#223-%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%86%E7%BB%84%E5%92%8C%E6%8F%8F%E8%BF%B0">2.2.3. 任务的分组和描述</a></li>
</ul>
</li>
<li><a href="#23-gradle-%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB">2.3. <code>Gradle</code> 日志级别</a></li>
<li><a href="#24-gradle-%E5%91%BD%E4%BB%A4%E8%A1%8C">2.4. <code>Gradle</code> 命令行</a><ul>
<li><a href="#241-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF">2.4.1. 获取所有任务信息</a></li>
<li><a href="#242-%E6%8E%92%E9%99%A4%E4%BB%BB%E5%8A%A1">2.4.2. 排除任务</a></li>
<li><a href="#243-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E7%94%A8">2.4.3. 多任务调用</a></li>
<li><a href="#244-%E4%BB%BB%E5%8A%A1%E5%90%8D%E7%A7%B0%E7%BC%A9%E5%86%99">2.4.4. 任务名称缩写</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-groovy-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97">3. Groovy 快速入门指南</a><ul>
<li><a href="#groovy-%E6%A6%82%E8%BF%B0">Groovy 概述</a></li>
<li><a href="#groovy%E7%BC%96%E5%86%99%E5%92%8C%E8%B0%83%E8%AF%95">Groovy编写和调试</a></li>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E6%96%B9%E6%B3%95">方法</a></li>
<li><a href="#%E7%B1%BB">类</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->


<h1 id="1-安装gradle"><a href="#1-安装gradle" class="headerlink" title="1. 安装gradle"></a>1. 安装<code>gradle</code></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo apt install gradle</span><br><span class="line"></span><br><span class="line">➜  ~ gradle -v</span><br><span class="line">WARNING: An illegal reflective access operation has occurred</span><br><span class="line">WARNING: Illegal reflective access by org.codehaus.groovy.reflection.CachedClass (file:/usr/share/java/groovy-all.jar) to method java.lang.Object.finalize()</span><br><span class="line">WARNING: Please consider reporting this to the maintainers of org.codehaus.groovy.reflection.CachedClass</span><br><span class="line">WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations</span><br><span class="line">WARNING: All illegal access operations will be denied in a future release</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 4.4.1</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build time:   2012-12-21 00:00:00 UTC</span><br><span class="line">Revision:     none</span><br><span class="line"></span><br><span class="line">Groovy:       2.4.16</span><br><span class="line">Ant:          Apache Ant(TM) version 1.10.5 compiled on March 28 2019</span><br><span class="line">JVM:          11.0.4 (Ubuntu 11.0.4+11-post-Ubuntu-1ubuntu218.04.3)</span><br><span class="line">OS:           Linux 5.0.0-36-generic amd64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-入门前奏"><a href="#2-入门前奏" class="headerlink" title="2. 入门前奏"></a>2. 入门前奏</h1><h2 id="2-1-实现-hello-world"><a href="#2-1-实现-hello-world" class="headerlink" title="2.1. 实现 hello world"></a>2.1. 实现 <code>hello world</code></h2><p>新建一个目录，例如 <code>gradle01</code> ,在这个目录中新建一个 <code>build.gradle</code> 文件，输入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    doLast&#123;</span><br><span class="line">        println &quot;hello world&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>gradle -q hello</code> 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle -q hello</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p> <code>task</code> （任务）和action(动作)是 <code>Gradle</code> 的重要元素。上面的代码中， <code>task</code> 代表一个独立的原子性操作，比如复制一个文件，编译一次Java代码，这里我们简单的定义一个名为 <code>hello</code> 的任务。 <code>doLast</code> 代表<code>task</code> 执行的最后一个 <code>action</code>，通俗来讲就是 <code>task</code> 执行完毕后会回调 <code>doLast</code> 中的代码，在上面这个例子中就会打印 <code>Hello world!</code> 。</p>
<p>上面的例子可以写的更简洁一些：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println &quot;Hello world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-gradle-的任务"><a href="#2-2-gradle-的任务" class="headerlink" title="2.2. gradle 的任务"></a>2.2. <code>gradle</code> 的任务</h2><p>为了更好的讲解后面的Gradle 命令行，这里简单的介绍下Gradle的任务，包括创建任务、任务依赖、 动态定义任务和任务的分组和描述。</p>
<h3 id="2-2-1-创建任务"><a href="#2-2-1-创建任务" class="headerlink" title="2.2.1. 创建任务"></a>2.2.1. 创建任务</h3><p>除了前面实现 <code>Hello World</code> 的例子采用的创建任务方式，还有其他的3种创建任务方式。</p>
<h4 id="2-2-1-1-直接用任务名称创建"><a href="#2-2-1-1-直接用任务名称创建" class="headerlink" title="2.2.1.1. 直接用任务名称创建"></a>2.2.1.1. 直接用任务名称创建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def Task hello = task(hello)</span><br><span class="line">hello.doLast&#123;</span><br><span class="line">    println &quot;hello world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-2-任务名称-任务配置创建"><a href="#2-2-1-2-任务名称-任务配置创建" class="headerlink" title="2.2.1.2. 任务名称+任务配置创建"></a>2.2.1.2. 任务名称+任务配置创建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def Task hello =  task(hello, group:BasePlugin.BUILD_GROUP)</span><br><span class="line">hello.doLast&#123;</span><br><span class="line">    println &quot;hello world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>group</code> 为任务配置项，它代表了分组。</p>
<h4 id="2-2-1-3-TaskContainer的create方法创建"><a href="#2-2-1-3-TaskContainer的create方法创建" class="headerlink" title="2.2.1.3. TaskContainer的create方法创建"></a>2.2.1.3. TaskContainer的create方法创建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasks.create(name: &quot;hello&quot;) &lt;&lt; &#123;</span><br><span class="line">    println &quot;hello world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-任务依赖"><a href="#2-2-2-任务依赖" class="headerlink" title="2.2.2. 任务依赖"></a>2.2.2. 任务依赖</h3><p>任务依赖会决定任务运行的先后顺序，被依赖的任务会在定义依赖的任务之前执行。创建任务间的依赖关系如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println &quot;hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task go(dependsOn: hello) &lt;&lt; &#123;</span><br><span class="line">    println &quot;go for it&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>hello</code> 任务的基础上增加了一个名为 <code>go</code> 的任务，通过 <code>dependsOn</code> 来指定依赖的任务为 <code>hello</code> ，因此 <code>go</code> 任务运行在 <code>hello</code> 之后。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle -q go   </span><br><span class="line">hello world</span><br><span class="line">go for it</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-1-动态定义任务"><a href="#2-2-2-1-动态定义任务" class="headerlink" title="2.2.2.1. 动态定义任务"></a>2.2.2.1. 动态定义任务</h4><p>动态定义任务指的是在运行时来定义任务的名称，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.times&#123;</span><br><span class="line">    number-&gt;task &quot;task$number&quot; &lt;&lt; &#123;</span><br><span class="line">        println &quot;task$number&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用到了 <code>Groovy</code> 语法，关于 <code>Groovy</code> 语法会在本系列后续的文章进行介绍。<code>times</code> 是 <code>Groovy</code> 在 <code>java.lang.Number</code> 中拓展的方法，是一个定时器。<code>3.times</code> 中循环创建了三个新任务，隐式变量 <code>number</code> 的值为 <code>0，1，2</code> ，任务的名称由 <code>task</code> 加上 <code>number</code> 的值组成，达到了动态定义任务的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle -q task0</span><br><span class="line">task0</span><br><span class="line">➜  gradle01 gradle -q task1</span><br><span class="line">task1</span><br><span class="line">➜  gradle01 gradle -q task2</span><br><span class="line">task2</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-任务的分组和描述"><a href="#2-2-3-任务的分组和描述" class="headerlink" title="2.2.3. 任务的分组和描述"></a>2.2.3. 任务的分组和描述</h3><p><code>Gradle</code> 有任务组的概念，可以为任务配置分组和描述，以便于更好的管理任务，拥有良好的可读性。改造前面的例子，为 <code>hello</code> 任务添加分组和描述。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    group = &quot;build&quot;</span><br><span class="line">    description = &quot;hello world&quot;</span><br><span class="line">    doLast&#123;</span><br><span class="line">        println &quot;任务分组： $&#123;group&#125;&quot;</span><br><span class="line">        println &quot;任务描述： $&#123;description&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task go(dependsOn: hello) &lt;&lt; &#123;</span><br><span class="line">    println &quot;go for it&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者采用创建任务的方式来为任务添加分组和描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def Task hello = task(hello)</span><br><span class="line">hello.description = &quot;hello world&quot;</span><br><span class="line">hello.group = BasePlugin.BUILD_GROUP</span><br><span class="line">hello.doLast&#123;</span><br><span class="line">    println &quot;任务分组: $&#123;group&#125;&quot;</span><br><span class="line">    println &quot;任务描述: $&#123;description&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task go(dependsOn: hello)&#123;</span><br><span class="line">    println &quot;go for it&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终执行结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle -q go</span><br><span class="line">go for it</span><br><span class="line">任务分组: build</span><br><span class="line">任务描述: hello world</span><br></pre></td></tr></table></figure>

<h2 id="2-3-Gradle-日志级别"><a href="#2-3-Gradle-日志级别" class="headerlink" title="2.3. Gradle 日志级别"></a>2.3. <code>Gradle</code> 日志级别</h2><p>和Android一样，Gradle也定义了日志级别。</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>用于</th>
</tr>
</thead>
<tbody><tr>
<td>ERROR</td>
<td>错误消息</td>
</tr>
<tr>
<td>QUIET</td>
<td>重要的信息消息</td>
</tr>
<tr>
<td>WARNING</td>
<td>警告消息</td>
</tr>
<tr>
<td>LIFECYCLE</td>
<td>进度信息消息</td>
</tr>
<tr>
<td>INFO</td>
<td>信息性消息</td>
</tr>
<tr>
<td>DEBUG</td>
<td>调试消息</td>
</tr>
</tbody></table>
<p>前面我们通过 <code>gradle -q</code> + 任务名称来运行一个指定的 <code>task</code> ，这个 <code>q</code> 是命令行开关选项，通过开关选项可以控制输出的日志级别。</p>
<table>
<thead>
<tr>
<th>开关选项</th>
<th>输出日志级别</th>
</tr>
</thead>
<tbody><tr>
<td>无日志选项</td>
<td>LIFECYCLE及更高级别</td>
</tr>
<tr>
<td>-q或者 –quiet</td>
<td>QUIET及更高级别</td>
</tr>
<tr>
<td>-i或者 –info</td>
<td>INFO及更高级别</td>
</tr>
<tr>
<td>-d或者 –debug</td>
<td>DEBUG及更高级别</td>
</tr>
</tbody></table>
<h2 id="2-4-Gradle-命令行"><a href="#2-4-Gradle-命令行" class="headerlink" title="2.4. Gradle 命令行"></a>2.4. <code>Gradle</code> 命令行</h2><h3 id="2-4-1-获取所有任务信息"><a href="#2-4-1-获取所有任务信息" class="headerlink" title="2.4.1. 获取所有任务信息"></a>2.4.1. 获取所有任务信息</h3><p>这一节的命令行前面<a href="#223-%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%86%E7%BB%84%E5%92%8C%E6%8F%8F%E8%BF%B0">2.2.3. 任务的分组和描述</a>的代码为例，此前我们通过 <code>gradle -q +</code> 任务名称来运行一个指定的任务，如果不知道任务的名称，可以通过运行 <code>gradle -q tasks</code> 命令来获取所有的任务信息，这样就不需要打开源码了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle -a tasks</span><br><span class="line">--no-rebuild/-a has been deprecated and is scheduled to be removed in Gradle 5.0.</span><br><span class="line"></span><br><span class="line">&gt; Configure project : </span><br><span class="line">go for it</span><br><span class="line"></span><br><span class="line">&gt; Task :tasks </span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">All tasks runnable from root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build tasks</span><br><span class="line">-----------</span><br><span class="line">hello - hello world</span><br><span class="line"></span><br><span class="line">Build Setup tasks</span><br><span class="line">-----------------</span><br><span class="line">init - Initializes a new Gradle build.</span><br><span class="line">wrapper - Generates Gradle wrapper files.</span><br><span class="line"></span><br><span class="line">Help tasks</span><br><span class="line">----------</span><br><span class="line">buildEnvironment - Displays all buildscript dependencies declared in root project &#x27;gradle01&#x27;.</span><br><span class="line">components - Displays the components produced by root project &#x27;gradle01&#x27;. [incubating]</span><br><span class="line">dependencies - Displays all dependencies declared in root project &#x27;gradle01&#x27;.</span><br><span class="line">dependencyInsight - Displays the insight into a specific dependency in root project &#x27;gradle01&#x27;.</span><br><span class="line">dependentComponents - Displays the dependent components of components in root project &#x27;gradle01&#x27;. [incubating]</span><br><span class="line">help - Displays a help message.</span><br><span class="line">model - Displays the configuration model of root project &#x27;gradle01&#x27;. [incubating]</span><br><span class="line">projects - Displays the sub-projects of root project &#x27;gradle01&#x27;.</span><br><span class="line">properties - Displays the properties of root project &#x27;gradle01&#x27;.</span><br><span class="line">tasks - Displays the tasks runnable from root project &#x27;gradle01&#x27;.</span><br><span class="line"></span><br><span class="line">To see all tasks and more detail, run gradle tasks --all</span><br><span class="line"></span><br><span class="line">To see more detail about a task, run gradle help --task &lt;task&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 0s</span><br><span class="line">1 actionable task: 1 executed</span><br></pre></td></tr></table></figure>
<p>默认情况下，只会显示那些被分组的任务的名称和描述。比如 <code>Build tasks</code> （<code>Build</code> 任务组）中有我们定义的 <code>hello</code> 任务，<code>Build Setup tasks</code> 中有 <code>init</code> 和 <code>wrapper</code> ，<code>Help tasks</code> 有<code>buildEnvironment</code> 和 <code>components</code> 等等。</p>
<h3 id="2-4-2-排除任务"><a href="#2-4-2-排除任务" class="headerlink" title="2.4.2. 排除任务"></a>2.4.2. 排除任务</h3><p>如果我们不想运行go任务，可以运行 <code>gradle hello -x go</code> 命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle hello -x go</span><br><span class="line"></span><br><span class="line">&gt; Configure project : </span><br><span class="line">go for it</span><br><span class="line"></span><br><span class="line">&gt; Task :hello </span><br><span class="line">任务分组: build</span><br><span class="line">任务描述: hello world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 0s</span><br><span class="line">1 actionable task: 1 executed</span><br></pre></td></tr></table></figure>

<p>获取任务帮助信息</p>
<p>通过运行 <code>gradle -q help --task hello</code> 命令来显示 <code>hello</code> 任务的帮助信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle -q help --task hello</span><br><span class="line">go for it</span><br><span class="line">Detailed task information for hello</span><br><span class="line"></span><br><span class="line">Path</span><br><span class="line">     :hello</span><br><span class="line"></span><br><span class="line">Type</span><br><span class="line">     Task (org.gradle.api.Task)</span><br><span class="line"></span><br><span class="line">Description</span><br><span class="line">     hello world</span><br><span class="line"></span><br><span class="line">Group</span><br><span class="line">     build</span><br></pre></td></tr></table></figure>
<p>可以看到hello任务的路径、类型、描述和分组。</p>
<h3 id="2-4-3-多任务调用"><a href="#2-4-3-多任务调用" class="headerlink" title="2.4.3. 多任务调用"></a>2.4.3. 多任务调用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task helloworld &lt;&lt;&#123;</span><br><span class="line">    println &quot;hello world!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task goforit &lt;&lt; &#123;</span><br><span class="line">    println &quot;go for it!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过命令行一次执行多个任务，每个任务通常只会执行一次，无论是在命令行中指定任务还是任务依赖。上面的例子我们运行 <code>gradle helloWorld goForit</code> ，会先执行<code>helloWorld</code> 任务后执行 <code>goforit</code> 任务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle helloworld goforit</span><br><span class="line"></span><br><span class="line">&gt; Configure project : </span><br><span class="line">The Task.leftShift(Closure) method has been deprecated and is scheduled to be removed in Gradle 5.0. Please use Task.doLast(Action) instead.</span><br><span class="line"></span><br><span class="line">&gt; Task :helloworld </span><br><span class="line">hello world!</span><br><span class="line"></span><br><span class="line">&gt; Task :goforit </span><br><span class="line">go for it!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 0s</span><br><span class="line">2 actionable tasks: 2 executed</span><br></pre></td></tr></table></figure>
<h3 id="2-4-4-任务名称缩写"><a href="#2-4-4-任务名称缩写" class="headerlink" title="2.4.4. 任务名称缩写"></a>2.4.4. 任务名称缩写</h3><p>可以对使用驼峰命名的任务进行缩写，对于名称特别长的任务这个特性非常有用，比如<a href="#243-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E7%94%A8">2.4.3. 多任务调用</a>中的例子只需要执行<code>gradle hW gF</code> 就可以了，不过需要注意一点，那就是任务名称的缩写必须是唯一的，如果<a href="#243-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E7%94%A8">2.4.3. 多任务调用</a>中第二个任务的名称为<code>helloWangshu</code>，那么就会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle hW gF</span><br><span class="line"></span><br><span class="line">&gt; Configure project : </span><br><span class="line">The Task.leftShift(Closure) method has been deprecated and is scheduled to be removed in Gradle 5.0. Please use Task.doLast(Action) instead.</span><br><span class="line"></span><br><span class="line">&gt; Task :helloworld </span><br><span class="line">hello world!</span><br><span class="line"></span><br><span class="line">&gt; Task :goforit </span><br><span class="line">go for it!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 0s</span><br><span class="line">2 actionable tasks: 2 executed</span><br></pre></td></tr></table></figure>

<h1 id="3-Groovy-快速入门指南"><a href="#3-Groovy-快速入门指南" class="headerlink" title="3. Groovy 快速入门指南"></a>3. Groovy 快速入门指南</h1><h2 id="Groovy-概述"><a href="#Groovy-概述" class="headerlink" title="Groovy 概述"></a>Groovy 概述</h2><p><code>Groovy</code> 是 <code>Apache</code> 旗下的一种基于 <code>JVM</code> 的面向对象编程语言，既可以用于面向对象编程，也可以用作纯粹的脚本语言。在语言的设计上它吸纳了<code>Python</code> 、<code>Ruby</code> 和 <code>Smalltalk</code> 语言的优秀特性，比如动态类型转换、闭包和元编程支持。<br><code>Groovy</code> 与 <code>Java</code> 可以很好的互相调用并结合编程 ，比如在写 <code>Groovy</code> 的时候忘记了语法可以直接按 <code>Java</code> 的语法继续写，也可以在 <code>Java</code>  中调用 <code>Groovy</code>  脚本。比起<code>Java</code>，<code>Groovy</code> 语法更加的灵活和简洁，可以用更少的代码来实现 <code>Java</code> 实现的同样功能。</p>
<h2 id="Groovy编写和调试"><a href="#Groovy编写和调试" class="headerlink" title="Groovy编写和调试"></a>Groovy编写和调试</h2><p><code>Groovy</code> 的代码可以在 <code>Android Studio</code> 和 <code>IntelliJ IDEA</code> 等 <code>IDE</code> 中进行编写和调试，缺点是需要配置环境，这里推荐在文本中编写代码并结合命令行进行调试（文本推荐使用<code>VSCode</code>）。关于命令行请查看<a href="#2-%E5%85%A5%E9%97%A8%E5%89%8D%E5%A5%8F">2. 入门前奏</a>。</p>
<p>具体的操作步骤就是：在一个目录中新建 <code>build.gradle</code> 文件，在 <code>build.gradle</code> 中新建一个 <code>task</code> ，在 <code>task</code> 中编写 <code>Groovy</code> 代码，用命令行进入这个 <code>build.gradle</code> 文件所在的目录，运行 <code>gradle task</code> 名称 等命令行对代码进行调试，本文中的例子都是这样编写和调试的。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><code>Groovy</code> 中用 <code>def</code> 关键字来定义变量，可以不指定变量的类型，默认访问修饰符是 <code>public</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def a = 1;</span><br><span class="line">def int b = 1;</span><br><span class="line">def c = &quot;hello world&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法使用返回类型或 <code>def</code> 关键字定义，方法可以接收任意数量的参数，这些参数可以不申明类型，如果不提供可见性修饰符，则该方法为 <code>public</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task method &lt;&lt;&#123;</span><br><span class="line">    add(1, 2)</span><br><span class="line">    minus 1, 2  //语句后面的可以省略，方法的括号可以省略。</span><br><span class="line">    def n = mul 1, 2</span><br><span class="line">    println n</span><br><span class="line">    def f = div 2.0, 3</span><br><span class="line">    println f</span><br><span class="line">&#125;</span><br><span class="line">//用def关键字定义方法。</span><br><span class="line">def add(int a, int b)&#123;</span><br><span class="line">    println a + b</span><br><span class="line">&#125;</span><br><span class="line">def minus(a, b)&#123;//参数类型可以省略</span><br><span class="line">    println a - b</span><br><span class="line">&#125;</span><br><span class="line">//指定了方法返回类型，可以不需要def关键字来定义方法。</span><br><span class="line">int mul(a, b)&#123;</span><br><span class="line">    return a * b</span><br><span class="line">&#125;</span><br><span class="line">//如果不使用return ，方法的返回值为最后一行代码的执行结果。</span><br><span class="line">double div(a, b)&#123;//return可以省略掉</span><br><span class="line">    a/b </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle -q method</span><br><span class="line">3</span><br><span class="line">-1</span><br><span class="line">2</span><br><span class="line">0.6666666667</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><code>Groovy</code> 类非常类似于 <code>Java</code> 类。</p>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake的使用记录</title>
    <url>/2020/06/11/learn-CMake/</url>
    <content><![CDATA[<h1 id="什么是-CMake"><a href="#什么是-CMake" class="headerlink" title="什么是 CMake"></a>什么是 CMake</h1><p><a href="https://cmake.org/">CMake</a> 是一个开源、跨平台的工具系列，可用于构建、测试和打包软件。它通过一个名为 <code>CMakeLists.txt</code> 的配置文件来管理软件的编译流程，并根据用户所选择的目标平台生成构建软件所需的本地化 makefile 或 workspace。通俗来讲，使用 CMake 可以生成 UNIX-like 上构建软件所需的 Makefile 和 Windows 上构建软件所需的 vcxproj，而无需为它们单独写一份 <code>Makefile/vcxproj</code> 。</p>
<p><a href="https://cmake.org/documentation/">CMake 官方文档</a>中有详细的使用手册，可以帮助用户更深入地了解 CMake。另外，还有一个详细的使用教程：<a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">CMake Tutorial</a>。</p>
<h1 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h1><h2 id="单个源文件"><a href="#单个源文件" class="headerlink" title="单个源文件"></a>单个源文件</h2><p>对于简单的项目，只需要写几行代码就可以了。例如，假设现在我们的项目中只有一个源文件 <code>main.cc</code> ，该程序的用途是计算一个数的指数幂。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * power - Calculate the power of number.</span></span><br><span class="line"><span class="comment"> * @param base: Base value.</span></span><br><span class="line"><span class="comment"> * @param exponent: Exponent value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return base raised to the power exponent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> result = base;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; exponent; ++i)</span><br><span class="line">        result = result * base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s base exponent \n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> base = <span class="built_in">atof</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> exponent = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">double</span> result = <span class="built_in">power</span>(base, exponent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%g ^ %d is %g\n&quot;</span>, base, exponent, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编写-CMakeLists-txt"><a href="#编写-CMakeLists-txt" class="headerlink" title="编写 CMakeLists.txt"></a>编写 CMakeLists.txt</h3><p>首先编写 <code>CMakeLists.txt</code> 文件，并保存在与 <code>main.cc</code> 源文件同个目录下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cc)</span><br></pre></td></tr></table></figure>

<p><code>CMakeLists.txt</code> 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 <code>#</code> 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。</p>
<p>对于上面的 <code>CMakeLists.txt</code> 文件，依次出现了几个命令：</p>
<ol>
<li><code>cmake_minimum_required</code>：指定运行此配置文件所需的 CMake 的最低版本；</li>
<li><code>project</code>：参数值是 <code>Demo1</code>，该命令表示项目的名称是 <code>Demo1</code> 。</li>
<li><code>add_executable</code>： 将名为 <code>main.cc</code> 的源文件编译成一个名称为 Demo 的可执行文件。</li>
</ol>
<h3 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h3><p>之后，在当前目录下创建 build 目录，并进入 build 目录，然后执行 <code>cmake ..</code> 命令 ，最后执行 <code>cmake --build .</code> 命令编译得到 Demo1 可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ cmake ..</span><br><span class="line">-- Building <span class="keyword">for</span>: Visual Studio 16 2019</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">-- Configuring <span class="keyword">done</span> (9.4s)</span><br><span class="line">-- Generating <span class="keyword">done</span> (0.0s)</span><br><span class="line">-- Build files have been written to: D:/src/01/build</span><br><span class="line"></span><br><span class="line">$ cmake --build .</span><br><span class="line">用于 .NET Framework 的 Microsoft (R) 生成引擎版本 16.11.2+f32259642</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">  1&gt;Checking Build System</span><br><span class="line">  Building Custom Rule D:/src/01/CMakeLists.txt</span><br><span class="line">  main.cc</span><br><span class="line">  Demo.vcxproj -&gt; D:\src\01\build\Debug\Demo.exe</span><br><span class="line">  <span class="string">&#x27;pwsh.exe&#x27;</span> 不是内部或外部命令，也不是可运行的程序</span><br><span class="line">  或批处理文件。</span><br><span class="line">  Building Custom Rule D:/src/01/CMakeLists.txt</span><br><span class="line"></span><br><span class="line">$ ./Debug/Demo.exe 4, 5</span><br><span class="line">4 ^ 5 is 1024</span><br><span class="line"></span><br><span class="line">$ ./Debug/Demo.exe 2, 10</span><br><span class="line">2 ^ 10 is 1024</span><br></pre></td></tr></table></figure>

<h2 id="多个源文件"><a href="#多个源文件" class="headerlink" title="多个源文件"></a>多个源文件</h2><h3 id="同一目录，多个源文件"><a href="#同一目录，多个源文件" class="headerlink" title="同一目录，多个源文件"></a>同一目录，多个源文件</h3><p>上面的例子只有单个源文件。现在假如把 <code>power</code> 函数单独写进一个名为 <code>MathFunctions.cc</code> 的源文件里，使得这个工程变成如下的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./Demo2</span><br><span class="line">    |</span><br><span class="line">    +--- main.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.h</span><br></pre></td></tr></table></figure>

<p>这个时候，<code>CMakeLists.txt</code> 可以改成如下的形式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cc MathFunctions.cc)</span><br></pre></td></tr></table></figure>

<p>唯一的改动只是在 <code>add_executable</code> 命令中增加了一个 <code>MathFunctions.cc</code> 源文件。这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用 <code>aux_source_directory</code> 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure>

<p>因此，可以修改 CMakeLists.txt 如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>这样，CMake 会将当前目录所有源文件的文件名赋值给变量 <code>DIR_SRCS</code> ，再指示变量 <code>DIR_SRCS</code> 中的源文件需要编译成一个名称为 Demo 的可执行文件。</p>
<h3 id="多个目录，多个源文件"><a href="#多个目录，多个源文件" class="headerlink" title="多个目录，多个源文件"></a>多个目录，多个源文件</h3><p>现在进一步将 <code>MathFunctions.h</code> 和 <code>MathFunctions.cc</code> 文件移动到 math 目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./Demo3</span><br><span class="line">    |</span><br><span class="line">    +--- main.cc</span><br><span class="line">    |</span><br><span class="line">    +--- math/</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.cc</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.h</span><br></pre></td></tr></table></figure>

<p>对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 <code>CMakeLists.txt</code> 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。</p>
<p>根目录中的 <code>CMakeLists.txt</code> ：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 math 子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">math</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Demo MathFunctions)</span><br></pre></td></tr></table></figure>

<p>该文件添加了下面的内容: 第 3 行，使用命令 <code>add_subdirectory</code> 指明本项目包含一个子目录 math，这样 math 目录下的 <code>CMakeLists.txt</code> 文件和源代码也会被处理 。第 6 行，使用命令 <code>target_link_libraries</code> 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。</p>
<p>子目录中的 <code>CMakeLists.txt</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_LIB_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成链接库</span></span><br><span class="line"><span class="keyword">add_library</span> (MathFunctions <span class="variable">$&#123;DIR_LIB_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>在该文件中使用命令 <code>add_library</code> 将 src 目录中的源文件编译为静态链接库。</p>
<h2 id="自定义编译选项"><a href="#自定义编译选项" class="headerlink" title="自定义编译选项"></a>自定义编译选项</h2><p>CMake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。</p>
<p>例如，可以将 MathFunctions 库设为一个可选的库，如果该选项为 <code>ON</code> ，就使用该库定义的数学函数来进行运算。否则就调用标准库中的数学函数库。</p>
<p>我们要做的第一步是在顶层的 <code>CMakeLists.txt</code> 文件中添加该选项：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入一个配置头文件，用于处理 CMake 对源码的设置</span></span><br><span class="line"><span class="keyword">configure_file</span> (</span><br><span class="line">  <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/config.h.in&quot;</span></span><br><span class="line">  <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/config.h&quot;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否使用自己的 MathFunctions 库</span></span><br><span class="line"><span class="keyword">option</span> (USE_MYMATH</span><br><span class="line">       <span class="string">&quot;Use provided math implementation&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否加入 MathFunctions 库</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line">  <span class="keyword">include_directories</span> (<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/math&quot;</span>)</span><br><span class="line">  <span class="keyword">add_subdirectory</span> (<span class="keyword">math</span>)</span><br><span class="line">  <span class="keyword">set</span> (EXTRA_LIBS <span class="variable">$&#123;EXTRA_LIBS&#125;</span> MathFunctions)</span><br><span class="line"><span class="keyword">endif</span> (USE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span> (Demo  <span class="variable">$&#123;EXTRA_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ol>
<li>第 7 行的 <code>configure_file</code> 命令用于加入一个配置头文件 <code>config.h</code> ，这个文件由 CMake 从 <code>config.h.in</code> 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。</li>
<li>第 13 行的 <code>option</code> 命令添加了一个 <code>USE_MYMATH</code> 选项，并且默认值为 <code>ON</code> 。</li>
<li>第 17 行根据 <code>USE_MYMATH</code> 变量的值来决定是否使用我们自己编写的 MathFunctions 库。</li>
</ol>
<p>之后修改 <code>main.cc</code> 文件，让其根据 <code>USE_MYMATH</code> 的预定义值来决定是否调用标准库还是 MathFunctions 库：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math/MathFunctions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s base exponent \n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> base = atof(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> exponent = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we use our own Math library. \n&quot;</span>);</span><br><span class="line">    <span class="type">double</span> result = power(base, exponent);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we use the standard library. \n&quot;</span>);</span><br><span class="line">    <span class="type">double</span> result = <span class="built_in">pow</span>(base, exponent);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%g ^ %d is %g\n&quot;</span>, base, exponent, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序值得注意的是第 2 行，这里引用了一个 <code>config.h</code> 文件，这个文件预定义了 <code>USE_MYMATH</code> 的值。但我们并不直接编写这个文件，为了方便从 <code>CMakeLists.txt</code> 中导入配置，我们编写一个 <code>config.h.in</code> 文件，内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#cmakedefine USE_MYMATH</span></span><br></pre></td></tr></table></figure>

<p>这样 CMake 会自动根据 CMakeLists 配置文件中的设置自动生成 <code>config.h</code> 文件。</p>
<p>现在编译一下这个项目，为了便于交互式的选择该变量的值，可以使用 <code>cmake -D</code> 命令。</p>
<p>USE_MYMATH 为 ON 运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cmake .. -DUSE_MYMATH=ON</span><br><span class="line">-- Building <span class="keyword">for</span>: Visual Studio 16 2019</span><br><span class="line">...</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">-- Configuring <span class="keyword">done</span> (11.7s)</span><br><span class="line">-- Generating <span class="keyword">done</span> (0.1s)</span><br><span class="line">-- Build files have been written to: D:/src/04/build</span><br><span class="line"></span><br><span class="line">$ cmake --build .</span><br><span class="line">用于 .NET Framework 的 Microsoft (R) 生成引擎版本 16.11.2+f32259642</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">  1&gt;Checking Build System</span><br><span class="line">  Building Custom Rule D:/src/04/math/CMakeLists.txt</span><br><span class="line">  MathFunctions.cc</span><br><span class="line">  MathFunctions.vcxproj -&gt; D:\src\04\build\math\Debug\MathFunctions.lib</span><br><span class="line">  Building Custom Rule D:/src/04/CMakeLists.txt</span><br><span class="line">  main.cc</span><br><span class="line">  Demo.vcxproj -&gt; D:\src\04\build\Debug\Demo.exe</span><br><span class="line">  <span class="string">&#x27;pwsh.exe&#x27;</span> 不是内部或外部命令，也不是可运行的程序</span><br><span class="line">  或批处理文件。</span><br><span class="line">  Building Custom Rule D:/src/04/CMakeLists.txt</span><br><span class="line"></span><br><span class="line">$ ./Debug/Demo.exe 2, 10</span><br><span class="line">Now we use our own Math library.</span><br><span class="line">2 ^ 10 is 1024</span><br></pre></td></tr></table></figure>

<p>此时 <code>config.h</code> 的内容为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USE_MYMATH</span></span><br></pre></td></tr></table></figure>

<p>USE_MYMATH 为 OFF 运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ehome@xman Demo4]$ ./Demo</span><br><span class="line">Now we use the standard library.</span><br><span class="line"> 7 ^ 3 = 343.000000</span><br><span class="line"> 10 ^ 5 = 100000.000000</span><br><span class="line"> 2 ^ 10 = 1024.000000</span><br></pre></td></tr></table></figure>

<p>此时 <code>config.h</code> 的内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* #undef USE_MYMATH */</span><br></pre></td></tr></table></figure>

<h2 id="安装和测试"><a href="#安装和测试" class="headerlink" title="安装和测试"></a>安装和测试</h2><p>CMake 也可以指定安装规则，以及添加测试。这两个功能分别可以通过在产生 Makefile 后使用 <code>make install</code> 和 <code>make test</code> 来执行。在以前的 GNU Makefile 里，你可能需要为此编写 <code>install</code> 和 <code>test</code> 两个伪目标和相应的规则，但在 CMake 里，这样的工作同样只需要简单的调用几条命令。</p>
<h3 id="定制安装规则"><a href="#定制安装规则" class="headerlink" title="定制安装规则"></a>定制安装规则</h3><p>首先先在 <code>math/CMakeLists.txt</code> 文件里添加下面两行：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定 MathFunctions 库的安装路径</span></span><br><span class="line"><span class="keyword">install</span> (TARGETS MathFunctions DESTINATION bin)</span><br><span class="line"><span class="keyword">install</span> (FILES MathFunctions.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<p>指明 MathFunctions 库的安装路径。之后同样修改根目录的 CMakeLists 文件，在末尾添加下面几行：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定安装路径</span></span><br><span class="line"><span class="keyword">install</span> (TARGETS Demo DESTINATION bin)</span><br><span class="line"><span class="keyword">install</span> (FILES <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/config.h&quot;</span></span><br><span class="line">         DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<p>通过上面的定制，生成的 Demo 文件和 MathFunctions 函数库 libMathFunctions.o 文件将会被复制到 <code>/usr/local/bin</code> 中，而 MathFunctions.h 和生成的 config.h 文件则会被复制到 <code>/usr/local/include</code> 中。我们可以验证一下（顺带一提的是，这里的 <code>/usr/local/</code> 是默认安装到的根目录，可以通过修改 <code>CMAKE_INSTALL_PREFIX</code> 变量的值来指定这些文件应该拷贝到哪个根目录）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ehome@xman Demo5]$ sudo make install</span><br><span class="line">[ 50%] Built target MathFunctions</span><br><span class="line">[100%] Built target Demo</span><br><span class="line">Install the project...</span><br><span class="line">-- Install configuration: &quot;&quot;</span><br><span class="line">-- Installing: /usr/local/bin/Demo</span><br><span class="line">-- Installing: /usr/local/include/config.h</span><br><span class="line">-- Installing: /usr/local/bin/libMathFunctions.a</span><br><span class="line">-- Up-to-date: /usr/local/include/MathFunctions.h</span><br><span class="line">[ehome@xman Demo5]$ ls /usr/local/bin</span><br><span class="line">Demo  libMathFunctions.a</span><br><span class="line">[ehome@xman Demo5]$ ls /usr/local/include</span><br><span class="line">config.h  MathFunctions.h</span><br></pre></td></tr></table></figure>

<h3 id="为工程添加测试"><a href="#为工程添加测试" class="headerlink" title="为工程添加测试"></a>为工程添加测试</h3><p>添加测试同样很简单。CMake 提供了一个称为 CTest 的测试工具。我们要做的只是在项目根目录的 CMakeLists 文件中调用一系列的 <code>add_test</code> 命令。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用测试</span></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试程序是否成功运行</span></span><br><span class="line"><span class="keyword">add_test</span> (test_run Demo <span class="number">5</span> <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试帮助信息是否可以正常提示</span></span><br><span class="line"><span class="keyword">add_test</span> (test_usage Demo)</span><br><span class="line"><span class="keyword">set_tests_properties</span> (test_usage</span><br><span class="line">  PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">&quot;Usage: .* base exponent&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试 5 的平方</span></span><br><span class="line"><span class="keyword">add_test</span> (test_5_2 Demo <span class="number">5</span> <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_tests_properties</span> (test_5_2</span><br><span class="line"> PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">&quot;is 25&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试 10 的 5 次方</span></span><br><span class="line"><span class="keyword">add_test</span> (test_10_5 Demo <span class="number">10</span> <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_tests_properties</span> (test_10_5</span><br><span class="line"> PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">&quot;is 100000&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试 2 的 10 次方</span></span><br><span class="line"><span class="keyword">add_test</span> (test_2_10 Demo <span class="number">2</span> <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_tests_properties</span> (test_2_10</span><br><span class="line"> PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">&quot;is 1024&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码包含了四个测试。第一个测试 <code>test_run</code> 用来测试程序是否成功运行并返回 0 值。剩下的三个测试分别用来测试 5 的 平方、10 的 5 次方、2 的 10 次方是否都能得到正确的结果。其中 <code>PASS_REGULAR_EXPRESSION</code> 用来测试输出是否包含后面跟着的字符串。</p>
<p>让我们看看测试的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ehome@xman Demo5]$ make test</span><br><span class="line">Running tests...</span><br><span class="line">Test project /home/ehome/Documents/programming/C/power/Demo5</span><br><span class="line">    Start 1: test_run</span><br><span class="line">1/4 Test</span><br><span class="line">    Start 2: test_5_2</span><br><span class="line">2/4 Test</span><br><span class="line">    Start 3: test_10_5</span><br><span class="line">3/4 Test</span><br><span class="line">    Start 4: test_2_10</span><br><span class="line">4/4 Test</span><br><span class="line"></span><br><span class="line">100% tests passed, 0 tests failed out of 4</span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.01 sec</span><br></pre></td></tr></table></figure>

<p>如果要测试更多的输入数据，像上面那样一个个写测试用例未免太繁琐。这时可以通过编写宏来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">macro (do_test arg1 arg2 result)</span><br><span class="line">  add_test (test_$&#123;arg1&#125;_$&#123;arg2&#125; Demo $&#123;arg1&#125; $&#123;arg2&#125;)</span><br><span class="line">  set_tests_properties (test_$&#123;arg1&#125;_$&#123;arg2&#125;</span><br><span class="line">    PROPERTIES PASS_REGULAR_EXPRESSION $&#123;result&#125;)</span><br><span class="line">endmacro (do_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">do_test (5 2 &quot;is 25&quot;)</span><br><span class="line">do_test (10 5 &quot;is 100000&quot;)</span><br><span class="line">do_test (2 10 &quot;is 1024&quot;)</span><br></pre></td></tr></table></figure>

<p>关于 CTest 的更详细的用法可以通过 <code>man 1 ctest</code> 参考 CTest 的文档。</p>
<h2 id="支持-gdb"><a href="#支持-gdb" class="headerlink" title="支持 gdb"></a>支持 gdb</h2><p>让 CMake 支持 gdb 的设置也很容易，只需要指定 <code>Debug</code> 模式下开启 <code>-g</code> 选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(CMAKE_BUILD_TYPE &quot;Debug&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;)</span><br></pre></td></tr></table></figure>

<p>之后可以直接对生成的程序使用 gdb 来调试。</p>
<h2 id="添加环境检查"><a href="#添加环境检查" class="headerlink" title="添加环境检查"></a>添加环境检查</h2><p>有时候可能要对系统环境做点检查，例如要使用一个平台相关的特性的时候。在这个例子中，我们检查系统是否自带 pow 函数。如果带有 pow 函数，就使用它；否则使用我们定义的 power 函数。</p>
<h4 id="添加-CheckFunctionExists-宏"><a href="#添加-CheckFunctionExists-宏" class="headerlink" title="添加 CheckFunctionExists 宏"></a>添加 CheckFunctionExists 宏</h4><p>首先在顶层 CMakeLists 文件中添加 CheckFunctionExists.cmake 宏，并调用 <code>check_function_exists</code> 命令测试链接器是否能够在链接阶段找到 <code>pow</code> 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 检查系统是否支持 pow 函数</span><br><span class="line">include ($&#123;CMAKE_ROOT&#125;/Modules/CheckFunctionExists.cmake)</span><br><span class="line">check_function_exists (pow HAVE_POW)</span><br></pre></td></tr></table></figure>

<p>将上面这段代码放在 <code>configure_file</code> 命令前。</p>
<p>接下来修改 <code>config.h.in</code> 文件，预定义相关的宏变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#cmakedefine HAVE_POW</span></span><br></pre></td></tr></table></figure>

<p>最后一步是修改 <code>main.cc</code> ，在代码中使用宏和函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_POW</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we use the standard library. \n&quot;</span>);</span><br><span class="line">    <span class="type">double</span> result = <span class="built_in">pow</span>(base, exponent);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we use our own Math library. \n&quot;</span>);</span><br><span class="line">    <span class="type">double</span> result = power(base, exponent);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="添加版本号"><a href="#添加版本号" class="headerlink" title="添加版本号"></a>添加版本号</h2><p>给项目添加和维护版本号是一个好习惯，这样有利于用户了解每个版本的维护情况，并及时了解当前所用的版本是否过时，或是否可能出现不兼容的情况。</p>
<p>首先修改顶层 CMakeLists 文件，在 <code>project</code> 命令之后加入如下两行：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> (Demo_VERSION_MAJOR <span class="number">1</span>)</span><br><span class="line"><span class="keyword">set</span> (Demo_VERSION_MINOR <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>分别指定当前的项目的主版本号和副版本号。</p>
<p>之后，为了在代码中获取版本信息，我们可以修改 <code>config.h.in</code> 文件，添加两个预定义变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the configured options and settings for Tutorial</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Demo_VERSION_MAJOR @Demo_VERSION_MAJOR@</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Demo_VERSION_MINOR @Demo_VERSION_MINOR@</span></span><br></pre></td></tr></table></figure>

<p>这样就可以直接在代码中打印版本信息了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math/MathFunctions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s Version %d.%d\n&quot;</span>,</span><br><span class="line">            argv[<span class="number">0</span>],</span><br><span class="line">            Demo_VERSION_MAJOR,</span><br><span class="line">            Demo_VERSION_MINOR);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s base exponent \n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> base = atof(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> exponent = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (HAVE_POW)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we use the standard library. \n&quot;</span>);</span><br><span class="line">    <span class="type">double</span> result = <span class="built_in">pow</span>(base, exponent);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now we use our own Math library. \n&quot;</span>);</span><br><span class="line">    <span class="type">double</span> result = power(base, exponent);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%g ^ %d is %g\n&quot;</span>, base, exponent, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成安装包"><a href="#生成安装包" class="headerlink" title="生成安装包"></a>生成安装包</h2><p>本节将学习如何配置生成各种平台上的安装包，包括二进制安装包和源码安装包。为了完成这个任务，我们需要用到 CPack ，它同样也是由 CMake 提供的一个工具，专门用于打包。</p>
<p>首先在顶层的 <code>CMakeLists.txt</code> 文件尾部添加下面几行：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建一个 CPack 安装包</span></span><br><span class="line"><span class="keyword">include</span> (InstallRequiredSystemLibraries)</span><br><span class="line"><span class="keyword">set</span> (CPACK_RESOURCE_FILE_LICENSE</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/License.txt&quot;</span>)</span><br><span class="line"><span class="keyword">set</span> (CPACK_PACKAGE_VERSION_MAJOR <span class="string">&quot;$&#123;Demo_VERSION_MAJOR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span> (CPACK_PACKAGE_VERSION_MINOR <span class="string">&quot;$&#123;Demo_VERSION_MINOR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">include</span> (CPack)</span><br></pre></td></tr></table></figure>

<p>上面的代码做了以下几个工作：</p>
<ol>
<li>导入 InstallRequiredSystemLibraries 模块，以便之后导入 CPack 模块；</li>
<li>设置一些 CPack 相关变量，包括版权信息和版本信息，其中版本信息用了上一节定义的版本号；</li>
<li>导入 CPack 模块。</li>
</ol>
<p>接下来的工作是像往常一样构建工程，并执行 <code>cpack</code> 命令。</p>
<ul>
<li>生成二进制安装包：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpack -C CPackConfig.cmake</span><br></pre></td></tr></table></figure>

<ul>
<li>生成源码安装包</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpack -C CPackSourceConfig.cmake</span><br></pre></td></tr></table></figure>

<p>我们可以试一下。在生成项目后，执行 <code>cpack -C CPackConfig.cmake</code> 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ehome@xman Demo8]$ cpack -C CPackSourceConfig.cmake</span><br><span class="line">CPack: Create package using STGZ</span><br><span class="line">CPack: Install projects</span><br><span class="line">CPack: - Run preinstall target for: Demo8</span><br><span class="line">CPack: - Install project: Demo8</span><br><span class="line">CPack: Create package</span><br><span class="line">CPack: - package: /home/ehome/Documents/programming/C/power/Demo8/Demo8-1.0.1-Linux.sh generated.</span><br><span class="line">CPack: Create package using TGZ</span><br><span class="line">CPack: Install projects</span><br><span class="line">CPack: - Run preinstall target for: Demo8</span><br><span class="line">CPack: - Install project: Demo8</span><br><span class="line">CPack: Create package</span><br><span class="line">CPack: - package: /home/ehome/Documents/programming/C/power/Demo8/Demo8-1.0.1-Linux.tar.gz generated.</span><br><span class="line">CPack: Create package using TZ</span><br><span class="line">CPack: Install projects</span><br><span class="line">CPack: - Run preinstall target for: Demo8</span><br><span class="line">CPack: - Install project: Demo8</span><br><span class="line">CPack: Create package</span><br><span class="line">CPack: - package: /home/ehome/Documents/programming/C/power/Demo8/Demo8-1.0.1-Linux.tar.Z generated.</span><br></pre></td></tr></table></figure>

<p>此时会在该目录下创建 3 个不同格式的二进制包文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ehome@xman Demo8]$ ls Demo8-*</span><br><span class="line">Demo8-1.0.1-Linux.sh  Demo8-1.0.1-Linux.tar.gz  Demo8-1.0.1-Linux.tar.Z</span><br></pre></td></tr></table></figure>

<p>这 3 个二进制包文件所包含的内容是完全相同的。我们可以执行其中一个。此时会出现一个由 CPack 自动生成的交互式安装界面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ehome@xman Demo8]$ sh Demo8-1.0.1-Linux.sh</span><br><span class="line">Demo8 Installer Version: 1.0.1, Copyright (c) Humanity</span><br><span class="line">This is a self-extracting archive.</span><br><span class="line">The archive will be extracted to: /home/ehome/Documents/programming/C/power/Demo8</span><br><span class="line"></span><br><span class="line">If you want to stop extracting, please press &lt;ctrl-C&gt;.</span><br><span class="line">The MIT License (MIT)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2013 Joseph Pan(http://hahack.com)</span><br><span class="line"></span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy of</span><br><span class="line">this software and associated documentation files (the &quot;Software&quot;), to deal in</span><br><span class="line">the Software without restriction, including without limitation the rights to</span><br><span class="line">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of</span><br><span class="line">the Software, and to permit persons to whom the Software is furnished to do so,</span><br><span class="line">subject to the following conditions:</span><br><span class="line"></span><br><span class="line">The above copyright notice and this permission notice shall be included in all</span><br><span class="line">copies or substantial portions of the Software.</span><br><span class="line"></span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><br><span class="line">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS</span><br><span class="line">FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR</span><br><span class="line">COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER</span><br><span class="line">IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</span><br><span class="line">CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Do you accept the license? [yN]:</span><br><span class="line">y</span><br><span class="line">By default the Demo8 will be installed in:</span><br><span class="line">  &quot;/home/ehome/Documents/programming/C/power/Demo8/Demo8-1.0.1-Linux&quot;</span><br><span class="line">Do you want to include the subdirectory Demo8-1.0.1-Linux?</span><br><span class="line">Saying no will install in: &quot;/home/ehome/Documents/programming/C/power/Demo8&quot; [Yn]:</span><br><span class="line">y</span><br><span class="line"></span><br><span class="line">Using target directory: /home/ehome/Documents/programming/C/power/Demo8/Demo8-1.0.1-Linux</span><br><span class="line">Extracting, please wait...</span><br><span class="line"></span><br><span class="line">Unpacking finished successfully</span><br></pre></td></tr></table></figure>

<p>完成后提示安装到了 Demo8-1.0.1-Linux 子目录中，我们可以进去执行该程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ehome@xman Demo8]$ ./Demo8-1.0.1-Linux/bin/Demo 5 2</span><br><span class="line">Now we use our own Math library.</span><br><span class="line">5 ^ 2 is 25</span><br></pre></td></tr></table></figure>

<p>关于 CPack 的更详细的用法可以通过 <code>man 1 cpack</code> 参考 CPack 的文档。</p>
<h1 id="常用-CMake-命令"><a href="#常用-CMake-命令" class="headerlink" title="常用 CMake 命令"></a>常用 CMake 命令</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>CMake 使用 <code>#</code> 进行行注释，可以放在任何位置。 使用 <code>#[[ ]]</code> 形式进行块注释。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个 CMakeLists.txt 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[[ 这是一个 CMakeLists.txt 文件。</span></span><br><span class="line"><span class="comment">这是一个 CMakeLists.txt 文件</span></span><br><span class="line"><span class="comment">这是一个 CMakeLists.txt 文件]]</span></span><br></pre></td></tr></table></figure>

<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>使用 <code>set</code> 命令显式定义及赋值, 在非 <code>if</code> 语句中, 使用 <code>$&#123;&#125;</code> 引用变量, <code>if</code> 中直接使用变量名引用; 后续的 <code>set</code> 命令会清理变量原来的值, 例如</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SET 指令的语法是：</span></span><br><span class="line"><span class="comment"># [] 中的参数为可选项, 如不需要可以不写</span></span><br><span class="line"><span class="keyword">SET</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义变量 var 并赋值为 a;b;c 这样一个 string list</span></span><br><span class="line"><span class="keyword">set</span>(var a;b;c) &lt;=&gt; <span class="keyword">set</span>(var a b c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(var a) <span class="comment"># 赋值var变量的值为a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;var&#125;</span>) &lt;=&gt; <span class="keyword">add_executable</span>(a b c)   <span class="comment"># 变量使用 $&#123;xxx&#125; 引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定使用的C++标准</span></span><br><span class="line"><span class="comment"># 增加-std=c++11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment"># 增加-std=c++14</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="comment"># 增加-std=c++17</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定可执行程序输出的路径</span></span><br><span class="line"><span class="keyword">set</span>(HOME /home/robin/Linux/bin)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>cmake 中的流程判断相对简单，与 c 语言接近。形式如下:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(expression)</span><br><span class="line">  <span class="comment"># then section.</span></span><br><span class="line">  COMMAND1(ARGS ...)</span><br><span class="line">  COMMAND2(ARGS ...)</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line"><span class="keyword">elseif</span>(expression2)</span><br><span class="line">  <span class="comment"># elseif section.</span></span><br><span class="line">  COMMAND1(ARGS ...)</span><br><span class="line">  COMMAND2(ARGS ...)</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line"><span class="keyword">else</span>(expression)</span><br><span class="line">  <span class="comment"># else section.</span></span><br><span class="line">  COMMAND1(ARGS ...)</span><br><span class="line">  COMMAND2(ARGS ...)</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line"><span class="keyword">endif</span>(expression)</span><br></pre></td></tr></table></figure>

<p>其中 else 和 endif 中的表达式是可以省略的。</p>
<p>if 表达式可以用长表达式，优先级顺序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXISTS, COMMAND, DEFINED</span><br><span class="line">EQUAL, LESS, LESS_EQUAL, GREATER, GREATER_EQUAL, STREQUAL, STRLESS, STRLESS_EQUAL, STRGREATER, STRGREATER_EQUAL, VERSION_EQUAL, VERSION_LESS, VERSION_LESS_EQUAL, VERSION_GREATER, VERSION_GREATER_EQUAL, MATCHES</span><br><span class="line">NOT,AND,OR</span><br></pre></td></tr></table></figure>

<p>表达式为 true 的情况：</p>
<ul>
<li>1, ON, YES, TRUE, Y,或者是非 0 数字。</li>
</ul>
<p>表达式为 false 的情况：</p>
<ul>
<li>0, OFF, NO, FALSE, N, IGNORE, NOTFOUND，空字符串,或者带 <code>-NOTFOUND</code> 后缀。</li>
</ul>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foreach(loop_var arg1 arg2 ...)</span><br><span class="line">  COMMAND1(ARGS ...)</span><br><span class="line">  COMMAND2(ARGS ...)</span><br><span class="line">  ...</span><br><span class="line">endforeach(loop_var)</span><br><span class="line"></span><br><span class="line">foreach(loop_var RANGE total)</span><br><span class="line"></span><br><span class="line">foreach(loop_var RANGE start stop [step])</span><br><span class="line"></span><br><span class="line">foreach(loop_var IN [LISTS [list1 [...]]]</span><br><span class="line">                    [ITEMS [item1 [...]]])</span><br><span class="line"></span><br><span class="line">while(condition)</span><br><span class="line">  COMMAND1(ARGS ...)</span><br><span class="line">  COMMAND2(ARGS ...)</span><br><span class="line">  ...</span><br><span class="line">endwhile(condition)</span><br></pre></td></tr></table></figure>

<p>在 while 和 foreach 循环中，取变量的值请用 <code>$&#123;var&#125;</code>。break 和 continue 的用法基本与 c 一样，放心使用。</p>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p><code>message()</code> 命令用于在 CMake 运行时向用户显示消息。它接受一个或多个参数，作为要显示的消息。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message(&quot;Hello, world!&quot;)</span><br><span class="line">set(SRC_FILES main.cpp)</span><br><span class="line">message(&quot;Source files: $&#123;SRC_FILES&#125;&quot;)</span><br></pre></td></tr></table></figure>

<p><code>message</code> 命令还有其他用途，</p>
<ul>
<li>输出警告信息：<code>message(WARNING &quot;This is a warning message&quot;)</code></li>
<li>输出错误信息：<code>message(FATAL_ERROR &quot;This is an error message&quot;)</code></li>
<li>输出调试信息：<code>message(STATUS &quot;This is a status message&quot;)</code></li>
</ul>
<h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><p>下面的列表中为大家整理了一些 <code>CMake</code> 中常用的宏：</p>
<ul>
<li><code>PROJECT_SOURCE_DIR</code> ：使用 cmake 命令后紧跟的目录，一般是工程的根目录。</li>
<li><code>PROJECT_BINARY_DIR</code> ：执行 cmake 命令的目录。</li>
<li><code>CMAKE_CURRENT_SOURCE_DIR</code> ：当前处理的 <code>CMakeLists.txt</code> 所在的路径。</li>
<li><code>CMAKE_CURRENT_BINARY_DIR</code> ：target 编译目录。</li>
<li><code>EXECUTABLE_OUTPUT_PATH</code> ：目标二进制可执行文件的存放位置。</li>
<li><code>LIBRARY_OUTPUT_PATH</code> ：目标链接库文件的存放位置。</li>
<li><code>PROJECT_NAME</code> ：返回通过 PROJECT 指令定义的项目名称。</li>
<li><code>CMAKE_BINARY_DIR</code> ：项目实际构建路径，假设在 <code>build</code> 目录进行的构建，那么得到的就是这个目录的路径。</li>
<li><code>CMAKE_C_COMPILER</code> ：指定 C 编译器。</li>
<li><code>CMAKE_CXX_COMPILER</code> ：指定 C++编译器</li>
<li><code>CMAKE_C_FLAGS</code> ：编译 C 文件时的选项，如 <code>-g</code> , 也可以通过 <code>add_definitions</code> ：添加编译选项。</li>
<li><code>CMAKE_BUILD_TYPE</code> ：<code>build</code> 类型(Debug, Release, …)，可以通过 cmake 命令指定，如 <code>cmake -DCMAKE_BUILD_TYPE=Debug</code> 。</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><code>list()</code> 命令用于处理列表类型的变量。它可以接受多种子命令：</p>
<p><code>LENGTH</code> ：子命令 LENGTH 用于读取列表长度。<br><code>APPEND</code> ：在列表尾部添加元素。<br><code>INSERT</code> ：在指定位置插入元素。<br><code>REMOVE_ITEM</code> ：删除指定的元素。<br><code>JOIN</code> : 将列表中的元素用连接符（字符串）连接起来组成一个字符串。</p>
<h3 id="aux-source-directory"><a href="#aux-source-directory" class="headerlink" title="aux_source_directory"></a>aux_source_directory</h3><p><code>aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</code> 将 dir 中所有源文件（不包括头文件）保存到变量 variable 中。</p>
<h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p><code>file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</code></p>
<p><code>GLOB</code>: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。<br><code>GLOB_RECURSE</code>：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</p>
<p>例子，搜索当前目录的 src 目录下所有的源文件，并存储到变量中：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br></pre></td></tr></table></figure>

<h3 id="project"><a href="#project" class="headerlink" title="project"></a>project</h3><p>project 命令指定项目编译目标。</p>
<h3 id="include-directories"><a href="#include-directories" class="headerlink" title="include_directories"></a>include_directories</h3><p><code>include_directories(headpath)</code> 指定头文件路径。</p>
<h3 id="add-library"><a href="#add-library" class="headerlink" title="add_library"></a>add_library</h3><p><code>add_library</code> 命令用于定义一个库目标。它至少需要两个参数：库的名称和源文件。</p>
<p>CMake 支持创建静态库和动态库。默认情况下，<code>add_library()</code> 命令会创建一个静态库，也可以显示使用 <code>STATIC</code> 参数创建静态库。如果你想要创建一个动态库，你需要在命令中添加 <code>SHARED</code> 参数。</p>
<h3 id="find-library"><a href="#find-library" class="headerlink" title="find_library"></a>find_library</h3><p><code>find_library</code> 命令用于查找并定位系统上的库文件。你需要提供一个变量名（用于存储找到的库的路径）和库的名称。</p>
<h3 id="target-include-directories"><a href="#target-include-directories" class="headerlink" title="target_include_directories"></a>target_include_directories</h3><p><code>target_include_directories()</code> 命令用于为指定的目标添加包含目录。这个命令需要至少两个参数：目标名称和要添加的目录。</p>
<h3 id="target-compile-options"><a href="#target-compile-options" class="headerlink" title="target_compile_options"></a>target_compile_options</h3><p><code>target_compile_options()</code> 命令用于为指定的目标设置编译选项。这个命令至少需要两个参数：目标名称和编译选项。</p>
<h3 id="target-link-libraries"><a href="#target-link-libraries" class="headerlink" title="target_link_libraries"></a>target_link_libraries</h3><p><code>target_link_libraries()</code> 命令用于将指定的库链接到目标。这个命令至少需要两个参数：目标名称和库名称。</p>
<h3 id="link-libraries"><a href="#link-libraries" class="headerlink" title="link_libraries"></a>link_libraries</h3><p><code>link_libraries(&lt;static lib&gt; [&lt;static lib&gt;...])</code> 包含库路径。</p>
<h3 id="link-directories"><a href="#link-directories" class="headerlink" title="link_directories"></a>link_directories</h3><p>指定库文件路径，<code>link_directories</code> 仅对其后面的 targets 起作用</p>
<h3 id="add-definitions"><a href="#add-definitions" class="headerlink" title="add_definitions"></a>add_definitions</h3><p>添加编译宏定义。</p>
<h3 id="add-dependencies"><a href="#add-dependencies" class="headerlink" title="add_dependencies"></a>add_dependencies</h3><p>添加编译依赖项用于确保编译目标项目前依赖项必须先构建好。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.hahack.com/codes/cmake/">https://www.hahack.com/codes/cmake/</a></p>
<p><a href="https://www.zybuluo.com/khan-lau/note/254724">https://www.zybuluo.com/khan-lau/note/254724</a></p>
<p><a href="https://subingwen.cn/cmake/CMake-primer/index.html">https://subingwen.cn/cmake/CMake-primer/index.html</a></p>
<p><a href="https://juejin.cn/post/6844903565207535630">https://juejin.cn/post/6844903565207535630</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask简单学习</title>
    <url>/2020/01/29/learn-Flask/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>由于是学习，所以直接在django的虚拟环境中安装Flask。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定Flask版本安装</span><br><span class="line">$ pip install flask==0.10.1</span><br></pre></td></tr></table></figure>

<h1 id="从-Hello-World-开始"><a href="#从-Hello-World-开始" class="headerlink" title="从 Hello World 开始"></a>从 Hello World 开始</h1><h2 id="Flask程序运行过程："><a href="#Flask程序运行过程：" class="headerlink" title="Flask程序运行过程："></a>Flask程序运行过程：</h2><p>所有Flask程序必须有一个程序实例。</p>
<p>Flask调用视图函数后，会将视图函数的返回值作为响应的内容，返回给客户端。一般情况下，响应内容主要是字符串和状态码。</p>
<p>当客户端想要获取资源时，一般会通过浏览器发起HTTP请求。此时，Web服务器使用WSGI（Web Server Gateway Interface）协议，把来自客户端的所有请求都交给Flask程序实例。WSGI是为 Python 语言定义的Web服务器和Web应用程序之间的一种简单而通用的接口，它封装了接受HTTP请求、解析HTTP请求、发送HTTP，响应等等的这些底层的代码和操作，使开发者可以高效的编写Web应用。</p>
<p>程序实例使用Werkzeug来做路由分发（URL请求和视图函数之间的对应关系）。根据每个URL请求，找到具体的视图函数。 在Flask程序中，路由的实现一般是通过程序实例的route装饰器实现。route装饰器内部会调用add_url_route()方法实现路由注册。</p>
<p>调用视图函数，获取响应数据后，把数据传入HTML模板文件中，模板引擎负责渲染响应数据，然后由Flask返回响应数据给浏览器，最后浏览器处理返回的结果显示给客户端。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>learn-css</title>
    <url>/2023/09/22/learn-css/</url>
    <content><![CDATA[<p>占坑 <a href="https://www.runoob.com/css/css-tutorial.html">https://www.runoob.com/css/css-tutorial.html</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>learn-cpp</title>
    <url>/2019/12/20/learn-cpp/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="const、引用和函数默认参数的使用及注意事项"><a href="#const、引用和函数默认参数的使用及注意事项" class="headerlink" title="const、引用和函数默认参数的使用及注意事项"></a><code>const</code>、引用和函数默认参数的使用及注意事项</h2><ol>
<li><code>const</code> 的作用<ul>
<li>取代无参宏，增加类型检查功能。</li>
<li>对指针类型做一些限定。</li>
</ul>
</li>
</ol>
<p><code>const</code> 主要是语法层面的限定，实际上可以通过内存修改 <code>const</code> 变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PI: %f\r\n&quot;</span>, PI);   <span class="comment">// 3.140000</span></span><br><span class="line">    <span class="comment">// const 取代无参宏，方便调试，增加类型检查。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> CPI = <span class="number">3.14f</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPI: %f\r\n&quot;</span>, CPI);  <span class="comment">// 3.140000</span></span><br><span class="line">    *(<span class="type">float</span>*)&amp;CPI = <span class="number">2.14f</span>;</span><br><span class="line">    <span class="comment">// 编译中直接替换为常量了，所以修改了CPI的值输出也是3.140000。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPI: %f\r\n&quot;</span>, CPI);  <span class="comment">// 3.140000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 指针</span></span><br><span class="line">    <span class="comment">// const 在 * 前面，则指针指向的内容无法修改。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pbuffer = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    pbuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// pbuffer[0] = &#x27;H&#x27;;  这条语句会出错，表达式必须是可修改的左值。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 在 * 后面，则指针变量的值无法修改。</span></span><br><span class="line">    <span class="type">char</span> szBuffer[] = <span class="string">&quot;world&quot;</span>;  <span class="comment">// 等价于  char * const szBuffer = &quot;hello&quot;</span></span><br><span class="line">    <span class="type">char</span>* <span class="type">const</span> cbuffer = szBuffer;</span><br><span class="line">    <span class="comment">// cbuffer = NULL; 表达式必须是可修改的左值。</span></span><br><span class="line">    cbuffer[<span class="number">0</span>] = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 在 * 前后都有，则指向的内容和指针的值都无法修改。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> ccbuffer = szBuffer;</span><br><span class="line">    <span class="comment">// ccbuffer = NULL; 表达式必须是可修改的左值。</span></span><br><span class="line">    <span class="comment">// ccbuffer[0] = &#x27;h&#x27;;表达式必须是可修改的左值。</span></span><br><span class="line">    szBuffer[<span class="number">1</span>] = <span class="string">&#x27;O&#x27;</span>; <span class="comment">// 语法上不可修改，实际上可以通过内存修改</span></span><br><span class="line">    <span class="comment">// printf(&quot;pbuffer: %s\r\n&quot;, pbuffer);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cbuffer: %s\r\n&quot;</span>, cbuffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ccbuffer: %s\r\n&quot;</span>, ccbuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 const 和非 const 指针转换问题如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> TYPE * = TYPE *;    <span class="comment">// 正确</span></span><br><span class="line">TYPE* = <span class="type">const</span> TYPE*;      <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>引用注意事项<ul>
<li>引用必须初始化。</li>
<li>引用不能初始化为常量(存在特例)。</li>
<li>没有二级引用。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_point</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_ref</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 引用必须初始化</span></span><br><span class="line">    <span class="type">int</span>&amp; ref_a = a;</span><br><span class="line">    <span class="type">int</span>&amp; ref_b = b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ref_a = %d, ref_b= %d\r\n&quot;</span>, ref_a, ref_b);</span><br><span class="line">    <span class="built_in">swap_point</span>(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b= %d\r\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ref_a = %d, ref_b= %d\r\n&quot;</span>, ref_a, ref_b);</span><br><span class="line">    <span class="built_in">swap_ref</span>(ref_a, ref_b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b= %d\r\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ref_a = %d, ref_b= %d\r\n&quot;</span>, ref_a, ref_b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int&amp; const_value = 1;   // error C2440: &#x27;initializing&#x27;: cannot convert from &#x27;int&#x27; to &#x27;int &amp;&#x27;</span></span><br><span class="line">    <span class="comment">// int&amp;&amp; n = ref_a;        // error C2440: &#x27;initializing&#x27;: cannot convert from &#x27;int&#x27; to &#x27;int &amp;&amp;&#x27;</span></span><br><span class="line">    <span class="comment">// 下面相当于 int tmp = 2; const int &amp;c_ref = tmp;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; c_ref = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address: %p\r\n&quot;</span>, &amp;c_ref);  <span class="comment">// 这里可以发现输出的为栈地址。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用与指针无本质区别，只是语法上的区别，下列为 IDA 中反汇编后的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     [ebp+a], 1</span><br><span class="line">mov     [ebp+b], 2</span><br><span class="line">lea     eax, [ebp+a]</span><br><span class="line">mov     [ebp+ref_a], eax</span><br><span class="line">lea     eax, [ebp+b]</span><br><span class="line">mov     [ebp+ref_b], eax</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>默认参数注意事项<ul>
<li>缺省参数只能放在最右边。</li>
<li>声明和实现不能同时定义缺省，只能写一个。</li>
<li>缺省参数通常放在声明文件中。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, sum);</span><br><span class="line">    sum = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol>
<li><code>class</code> 类默认 <code>private</code>；<code>struct</code> 类和 <code>union</code> 类默认公有，其中 <code>union</code> 类内存共享。</li>
<li>不同的对象，数据成员内存地址不一样。</li>
<li>调用成员函数时会隐藏传递 <code>this</code> 指针，默认会用寄存器（ECX）传递。</li>
<li>使用 <code>__stdcall</code> 方式的函数调用时， <code>this</code> 指针直接入栈传递。</li>
<li>类的声明一般定义在头文件中，实现在另外的 cpp 文件中。</li>
</ol>
<h3 id="内联-inline"><a href="#内联-inline" class="headerlink" title="内联 inline"></a>内联 inline</h3><p>在 C++中使用 inline 函数也是直接替换内容，而且有参数类型检查，就解决了宏的类型检查问题，可以在编译期间就避免类型不一致的错误。</p>
<p>内联的一些情况:</p>
<ul>
<li>debug 版不内联。</li>
<li>release 版才会内联，inline 告诉编译器需要内联，编译器会根据函数的复杂度来确定是否直接替换。</li>
<li>直接在类中定义并实现的函数默认内联。</li>
</ul>
<p><strong>类成员函数内联的定义和实现一般都是写在同一个文件中，主要是为了防止重复定义以及避免编译器在链接过程中直接替换函数时找不到函数定义。</strong></p>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CInline.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CInline</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CInline.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CInline.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CInline::add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CInline.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    CInline clinne;</span><br><span class="line">    <span class="type">int</span> sum = clinne.<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就会出现下列错误，将 <code>CInline::add</code> 的实现写到 <code>CInline.h</code> 中就可以编译通过了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error LNK2019: unresolved external symbol <span class="string">&quot;public: int __thiscall CInline::add(int,int)&quot;</span> (?add@CInline@@QAEHHH@Z) referenced <span class="keyword">in</span> <span class="keyword">function</span> _main</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>重载实现编译器期的多态。</p>
<p>重载的定义：函数名相同，参数个数不同 或 参数类型不同 或 参数顺序不同即可构成重载。</p>
<p>注意点：</p>
<ul>
<li>返回值不作参考，即返回值不同也不构成重载。</li>
<li><code>TYPE</code> 和 <code>const TPYE</code> 不构成重载，如 <code>add(int)</code> 和 <code>add(const int)</code> 不构成重载。</li>
<li><code>TYPE*</code> 和 <code>const TPYE*</code> 可以重载，如 <code>add(int*)</code> 和 <code>add(const int*)</code> 构成重载。</li>
<li>引用可以重载，如 <code>add(int)</code> 和 <code>add(int&amp;)</code> 构成重载。</li>
<li><code>typedef</code> 无效，如 <code>typedef int T;</code> <code>add(T)</code> 和 <code>add(int)</code> 不构成重载。</li>
</ul>
<h3 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h3><p>构造函数是一个特殊的成员函数，主要作用是初始化，申请资源；其注意点如下：</p>
<ul>
<li>不能显示调用，即使用者不能调用。</li>
<li>没有返回值。</li>
<li>可以重载。</li>
</ul>
<p>析构函数也是特殊的成员函数，主要作用是释放资源；其注意点如下：</p>
<ul>
<li>可以显示调用。</li>
<li>没有返回值。</li>
<li>不能有参数，所以不能重载。</li>
</ul>
<p>编译器一般会自动为一个类生成六个特殊的成员函数，</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>class C 对应的形式</th>
</tr>
</thead>
<tbody><tr>
<td>默认构造函数</td>
<td>C::C();</td>
</tr>
<tr>
<td>析构函数</td>
<td>C::~C();</td>
</tr>
<tr>
<td>复制构造函数</td>
<td>C::C (const C&amp;);</td>
</tr>
<tr>
<td>复制赋值运算符</td>
<td>C&amp; operator&#x3D; (const C&amp;);</td>
</tr>
<tr>
<td>移动构造函数（C++11）</td>
<td>C::C (C&amp;&amp;);</td>
</tr>
<tr>
<td>移动赋值运算符（C++11）</td>
<td>C&amp; operator&#x3D; (C&amp;&amp;);</td>
</tr>
</tbody></table>
<p>以上六个成员函数如果不用，最好用 <code>delete</code> 标记一下，避免出现非预期结果。</p>
<p>复制构造函数和复制赋值运算符默认情况下直接将对象进行整体复制，如果对象数据成员有指针变量时，就会复制指针变量而不是指针对应的数据，就造成了两个对象中的指针变量指向了同一个地址，与预期的结果是不一样的，还有一个问题就是析构函数会两次释放资源，造成错误。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Copy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Number;</span><br><span class="line">    <span class="type">char</span>* m_pszBuff;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Copy</span>(<span class="type">int</span> number, <span class="type">const</span> <span class="type">char</span>* szbuf = <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(number, szbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Copy</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pszBuff)&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_pszBuff;</span><br><span class="line">            m_pszBuff = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> number, <span class="type">const</span> <span class="type">char</span>* szbuf)</span> </span>&#123;</span><br><span class="line">        m_Number = number;</span><br><span class="line">        <span class="keyword">if</span> (szbuf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_pszBuff = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m_pszBuff = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(szbuf) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(m_pszBuff, szbuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function">Copy <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    Copy p2 = p1;</span><br><span class="line">    <span class="function">Copy <span class="title">p3</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1.m_Number address: %p, p1.m_pszBuff address: %p\r\n&quot;</span>, &amp;p1.m_Number, p1.m_pszBuff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2.m_Number address: %p, p2.m_pszBuff address: %p\r\n&quot;</span>, &amp;p2.m_Number, p2.m_pszBuff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p3.m_Number address: %p, p3.m_pszBuff address: %p\r\n&quot;</span>, &amp;p3.m_Number, p3.m_pszBuff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码运行后可以发现 m_pszBuff 的内存地址为同一个值，然后析构函数会多次释放内存导致错误。</p>
<p>函数参数尽量使用引用作为参数，应为如果使用对象作为参数，将会多执行一次拷贝构造和一次析构，导致性能损失。</p>
<p>一个类的成员包含另一个类的析构和构造函数调用情况：</p>
<ul>
<li>构造顺序：先根据定义的顺序构造成员对象，再构造自己。</li>
<li>析构顺序与析构顺序相反：先析构自己，再根据定义的顺序反向析构成员对象。</li>
</ul>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassA</span>(<span class="type">int</span> count = <span class="number">0</span>)&#123;</span><br><span class="line">        mCount = count;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ClassA() &quot;</span> &lt;&lt; mCount &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ClassA</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~ClassA() &quot;</span> &lt;&lt; mCount &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ClassA d1;</span><br><span class="line">    ClassA d2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassB</span>():<span class="built_in">d1</span>(<span class="number">1</span>), <span class="built_in">d2</span>(<span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ClassB() &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ClassB</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ClassB() &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ClassB b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ClassA() 1</span><br><span class="line">ClassA() 2</span><br><span class="line">ClassB()</span><br><span class="line">ClassB()</span><br><span class="line">~ClassA() 2</span><br><span class="line">~ClassA() 1</span><br></pre></td></tr></table></figure>

<h2 id="static-和-const"><a href="#static-和-const" class="headerlink" title="static 和 const"></a>static 和 const</h2><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><ul>
<li>命名空间也是为了解决访问权限和命名重复的问题。</li>
<li>当两个命名空间名是一样的就会合并为一个。</li>
<li>命名空间尽量确保唯一性。</li>
<li>可以嵌套使用类名空间，但是尽量不要这样使用。</li>
</ul>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Mystring&#123;</span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *strDestination, <span class="type">const</span> <span class="type">char</span> *strSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g_nCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_nCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> szText[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> g_nCount = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//strcpy(szText, &quot;hello&quot;);          //error，因为不知道用标准库函数还是用Mystring中的函数</span></span><br><span class="line">    Mystring::<span class="built_in">strcpy</span>(szText, <span class="string">&quot;hello&quot;</span>);  <span class="comment">//调用的是Mystring里面的strcpy</span></span><br><span class="line">    Mystring::g_nCount = <span class="number">1</span>;             <span class="comment">//调用的是Mystring里面的strcpy</span></span><br><span class="line">    ::<span class="built_in">strcpy</span>(szText, <span class="string">&quot;hello&quot;</span>);          <span class="comment">//调用的是全局strcpy, ::前面没有命名空间表示全局的</span></span><br><span class="line">    g_nCount = <span class="number">10</span>;                      <span class="comment">//调用的是main函数中的g_nCount</span></span><br><span class="line">    ::g_nCount = <span class="number">20</span>;                    <span class="comment">//调用全局的g_nCount</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol>
<li>静态成员变量</li>
</ol>
<ul>
<li>静态成员变量只限于类里面访问，并且不同的类可以定义相同的变量名，可以避免全局变量的权限范围过大以及命名空间问题。</li>
<li>静态成员变量和普通成员变量的定义方式是一样的，并且不占用对象空间。</li>
<li>静态数据成员使用前必须要先初始化，初始化方式：类名::static 数据成员名 &#x3D; 0;</li>
</ul>
<ol start="2">
<li>静态成员函数</li>
</ol>
<ul>
<li>静态成员函数出现的原因和静态成员函数出现的原因一样，也是因为权限和命名空间的问题。</li>
<li>静态成员函数中不含 this 指针，所以不能访问普通数据成员，只能访问静态数据成员。</li>
<li>调用方式：类名::静态成员函数名 或者 对象.静态成员函数名。</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTestStatic</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mNumber;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> mCount;    <span class="comment">//不占用对象的空间</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CTestStatic</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        mNumber = <span class="number">0</span>;</span><br><span class="line">        mCount++;         <span class="comment">//每个对象修改的都是同一个m_nCount</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CTestStatic() mCount = &quot;</span> &lt;&lt; mCount &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CTestStatic</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~CTestStatic() mCount = &quot;</span> &lt;&lt; mCount&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//因为静态成员函数没有传递this指针，不能访问普通数据成员</span></span><br><span class="line">        <span class="comment">//只能访问静态数据成员</span></span><br><span class="line">        <span class="keyword">return</span> mCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> CTestStatic::mCount = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;CTestStatic size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(CTestStatic) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    CTestStatic t1;</span><br><span class="line">    CTestStatic t2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mCount = &quot;</span> &lt;&lt; t1.<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mCount = &quot;</span> &lt;&lt; t2.<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mCount = &quot;</span> &lt;&lt; CTestStatic::<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cosnt"><a href="#cosnt" class="headerlink" title="cosnt"></a>cosnt</h3><ol>
<li><p>cosnt 数据成员<br>cosnt 数据成员的定义和普通 const 变量的定义是一样的，但是由于在类里面定义数据成员是不支持定义的同时初始化的，只能通过构造函数使用初始化表来初始化。</p>
</li>
<li><p>const 成员函数<br>cosnt 成员函数的使用方法在普通成员函数后面加上 const 即可，本质是改变了 this 指针的属性。主要是为了防止在对象调用成员函数是修改了数据成员，还有就是 const 对象只能调用 const 成员函数，如果没有 const 成员函数，const 对象什么事都干不了。</p>
</li>
</ol>
<h3 id="friend"><a href="#friend" class="headerlink" title="friend"></a>friend</h3><p>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。</p>
<p>在类定义中，使用 <code>friend</code> 关键字和非成员函数或其他类的名称，以允许其访问类的私有和受保护成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Retangle</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Retangle</span>() &#123; width = height = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">Retangle</span>(<span class="type">int</span> x, <span class="type">int</span> y) :<span class="built_in">width</span>(x), <span class="built_in">height</span>(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> width * height; &#125;</span><br><span class="line">    <span class="comment">// 友元函数可以访问 Retangle 私有和受保护的成员。</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Retangle <span class="title">duplicate</span><span class="params">(<span class="type">const</span> Retangle&amp; param)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">convert</span><span class="params">(Square a)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Test&amp; t)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="comment">// 友元类，其成员可以访问 Square 的私有或受保护成员。</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Retangle</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> side;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Square</span>(<span class="type">int</span> a) :<span class="built_in">side</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 友元类成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Retangle::fun</span><span class="params">(Test&amp; t)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Retangle <span class="title">duplicate</span><span class="params">(<span class="type">const</span> Retangle&amp; param)</span> </span>&#123;</span><br><span class="line">    Retangle res;</span><br><span class="line">    res.width = param.width;</span><br><span class="line">    res.height = param.height;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Retangle::convert</span><span class="params">(Square a)</span> </span>&#123;</span><br><span class="line">    width = a.side;</span><br><span class="line">    height = a.side;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Retangle::fun</span><span class="params">(Test&amp; t)</span> </span>&#123;</span><br><span class="line">    t.t = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  Rectangle rect;</span><br><span class="line">  <span class="function">Square <span class="title">sqr</span> <span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">  rect.<span class="built_in">convert</span>(sqr);</span><br><span class="line">  cout &lt;&lt; rect.<span class="built_in">area</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友元一般用作设计，因为友元后能访问私有成员，破坏封装性，不推荐使用。</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>操作符</th>
<th>成员函数</th>
<th>非成员函数</th>
</tr>
</thead>
<tbody><tr>
<td><code>@a</code></td>
<td><code>+</code> <code>-</code> <code>*</code> <code>&amp;</code> <code>!</code> <code>~</code> <code>++</code> <code>--</code></td>
<td><code>A::operator@()</code></td>
<td><code>operator@(A)</code></td>
</tr>
<tr>
<td><code>a@</code></td>
<td><code>++</code> <code>--</code></td>
<td><code>A::operator@(int)</code></td>
<td><code>operator@(A,int)</code></td>
</tr>
<tr>
<td><code>a@b</code></td>
<td><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> <code>^</code> <code>&amp;</code> <code>|</code> <code>&lt;</code> <code>&gt;</code> <code>==</code> <code>!=</code> <code>&lt;=</code> <code>&gt;=</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&amp;&amp;</code> <code>||</code> <code>,</code></td>
<td><code>A::operator@(B)</code></td>
<td><code>operator@(A,B)</code></td>
</tr>
<tr>
<td><code>a@b</code></td>
<td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>^=</code> <code>&amp;=</code> <code>| =</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>[]</code></td>
<td><code>A::operator@(B)</code></td>
<td>-</td>
</tr>
<tr>
<td><code>a(b,c...)</code></td>
<td><code>()</code></td>
<td><code>A::operator()(B,C...)</code></td>
<td>-</td>
</tr>
<tr>
<td><code>a-&gt;b</code></td>
<td><code>-&gt;</code></td>
<td><code>A::operator-&gt;()</code></td>
<td>-</td>
</tr>
<tr>
<td><code>(TYPE) a</code></td>
<td><code>TYPE</code></td>
<td><code>A::operator TYPE()</code></td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="继承和虚函数"><a href="#继承和虚函数" class="headerlink" title="继承和虚函数"></a>继承和虚函数</h2><h3 id="继承的基本知识"><a href="#继承的基本知识" class="headerlink" title="继承的基本知识"></a>继承的基本知识</h3><ul>
<li>构造函数的调用顺序：构造基类 &#x3D;&#x3D;&gt; 构造成员对象(按定义顺序) &#x3D;&#x3D;&gt; 自己构造</li>
<li>析构函数调用顺序：析构自己 &#x3D;&#x3D;&gt; 析构成员对象(按定义顺序反向) &#x3D;&#x3D;&gt; 析构基类</li>
</ul>
<p><strong>派生类可以在构造函数使用初始化列表指定基类的构造函数显示的调用。</strong></p>
<p>继承的内存布局：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">基类数据成员</span><br><span class="line">派生类数据成员</span><br></pre></td></tr></table></figure>

<ul>
<li>派生类和基类的首地址指向同一块内存空间。</li>
<li>派生类指针转换成基类的指针是安全的，不可能越界访问。</li>
<li>基类指针转换成派生类指针是不安全的，可能会产生溢出。</li>
</ul>
<h3 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数指针的定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__cdecl *FUNTYPE)</span><span class="params">()</span></span>;  <span class="comment">//typedef 方便以后使用</span></span><br><span class="line"></span><br><span class="line">FUNTYPE pfnfun = fun;   <span class="comment">//指针函数的定义</span></span><br><span class="line"><span class="built_in">pfnfun</span>();   <span class="comment">//指针函数的是用 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数指针定义与使用</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(A::*CFUNTYPE)</span><span class="params">()</span></span>;</span><br><span class="line">CFUNTYPE cpfnFun = &amp;A::fun; <span class="comment">//成员函数指针的定义与赋值</span></span><br><span class="line"></span><br><span class="line">A theA;</span><br><span class="line">A *pA = &amp;theA;</span><br><span class="line">(theA.*cpfnFun)();  <span class="comment">//成员函数指针的调用</span></span><br><span class="line"></span><br><span class="line">pfnFun2 = A::fun2;</span><br><span class="line">(pA-&gt;*cpfnFun)();  <span class="comment">//成员函数指针的调用</span></span><br></pre></td></tr></table></figure>

<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数的定义就是在函数前加上关键字 <code>virtual</code>，虚函数的特性：运行时多态。</p>
<p>析构函数必须是虚函数，可以防止一些资源未被释放的问题。</p>
<h3 id="重载、隐藏和覆盖"><a href="#重载、隐藏和覆盖" class="headerlink" title="重载、隐藏和覆盖"></a>重载、隐藏和覆盖</h3><ol>
<li>重载：</li>
</ol>
<ul>
<li>作用域相同。</li>
<li>函数名相同，参数个数，参数类型，参数顺序不同构成重载。</li>
<li>返回值不做参考。</li>
</ul>
<ol start="2">
<li>覆盖：</li>
</ol>
<ul>
<li>不同作用域(基类和派生类)</li>
<li>函数名相同</li>
<li>参数个数，参数类型，参数顺序都要相同</li>
<li>返回值相同</li>
<li>基类函数是虚函数</li>
</ul>
<ol start="3">
<li>隐藏(除了覆盖就是隐藏)：</li>
</ol>
<ul>
<li>作用域不同(基类和派生类)。</li>
<li>函数名相同</li>
</ul>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><ul>
<li>在基类的构造函数中拷贝基类的虚表指针到对象的首地址。</li>
<li>在派生类的构造函数中拷贝派生类的虚表指针到对象首地址。<ul>
<li>有覆盖先覆盖</li>
<li>新增加的虚函数地址加在虚表后面</li>
</ul>
</li>
</ul>
<h3 id="虚表函数的特性"><a href="#虚表函数的特性" class="headerlink" title="虚表函数的特性"></a>虚表函数的特性</h3><ol>
<li>如果一个类至少有一个虚表函数，那么这个类就有一个虚表指针。</li>
<li>虚表存放在全局数据区，即没实例化对象虚表也存在。</li>
<li>相同的类，不同的对象共享虚表，即虚表指针指向同一个位置。</li>
<li>虚表指针存放在对象的首地址处。</li>
<li>虚表项存放成员函数指针(数组)，通常按虚函数的定义顺序排列。</li>
<li>虚表不一定以 NULL 结尾。</li>
<li>不同的类虚表不同。</li>
<li>构造时初始化虚表指针。</li>
</ol>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>写法 virtual fun() &#x3D; 0;</p>
<p>注意事项</p>
<ol>
<li>如果一个类至少有一个纯虚函数，那么这个类就是一个抽象类。</li>
<li>抽象类不能实例化对象。</li>
<li>如果派生类没有覆盖全部纯虚函数，那么派生类也是抽象类。</li>
</ol>
<p>在 VC6.0 中，纯虚析构函数必须实现。</p>
<p>显示调用析构函数，无多态性。</p>
<p>用途</p>
<ol>
<li>有些类很抽象，无法实现，例如(图形，动物)。</li>
<li>强制要求派生类实现虚函数。</li>
<li>给派生类规范了接口(常用)。</li>
</ol>
<h3 id="普通多重继承"><a href="#普通多重继承" class="headerlink" title="普通多重继承"></a>普通多重继承</h3><p>构造顺序</p>
<ol>
<li>先构造基类(按继承顺序)</li>
<li>对象成员构造函数(定义顺序)</li>
<li>最后执行自己构造函数</li>
</ol>
<p>析构顺序</p>
<ol>
<li>先执行自己的析构函数</li>
<li>再执行对象成员析构函数(按定义顺序反向执行)</li>
<li>最后执行基类的析构函数(按继承顺序反向执行)</li>
</ol>
<p>数据成员在内存中的结构</p>
<ol>
<li>基类数据成员(按继承顺序排列)</li>
<li>自己的数据成员</li>
</ol>
<p>多重继承中的基类的函数和数据成员有可能出现同名的情况，使用派生类实例化的对像调用同名函数或使用同名数据成员时，就会出现二义性，此时编译器不知道到底调用哪个基类的，就会报错。如果要调用同名函数或使用同名数据成员时，只要加上作用域就可以使用了。</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承后派生类多了一个指针变量，存放的是基类数据成员的偏移量表，这样的存储方式使得派生类中继承基类的数据成员只存一份，如果要访问直接通过偏移量表来访问就可以了。</p>
<p>构造顺序:</p>
<p>A. 构造基类(先虚基类，普通基类按继承顺序)</p>
<p>B. 对象成员构造</p>
<p>C. 构造自己</p>
<p>析构顺序:与构造顺序相反。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常处理程序是在 <code>try</code> 块的右大括号后立即使用 <code>catch</code> 关键字声明的。 <code>catch</code> 的语法类似于具有一个参数的常规函数 ​​。此参数的类型非常重要，因为会根据它检查 <code>throw</code> 表达式传递的参数类型，只有在它们匹配的情况下，异常才会被该处理程序捕获。</p>
<p><code>try catch</code> 可以嵌套处理。<br>也可以自定义自己的异常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myexcepton</span>:<span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myexcepton</span>() &#123;&#125;;</span><br><span class="line">    ~<span class="built_in">myexcepton</span>() &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;my exception happened.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 嵌套</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 抛出自定义异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">myexcepton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">int</span> n)&#123;</span><br><span class="line">            <span class="keyword">throw</span>; <span class="comment">// 将异常转发给外部try catch.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e)&#123; <span class="comment">// exception将会捕获所有子类异常</span></span><br><span class="line">            cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">throw</span> <span class="number">3</span>; <span class="comment">// 抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> e)&#123; <span class="comment">// 捕获 int 类型的异常</span></span><br><span class="line">        cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">char</span> e) &#123; <span class="comment">// 捕获 char 类型的异常</span></span><br><span class="line">        cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;    <span class="comment">// 捕获其他的所有类型的异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="c-11-新特性"><a href="#c-11-新特性" class="headerlink" title="c++11 新特性"></a>c++11 新特性</h1><blockquote>
<p><a href="https://mp.weixin.qq.com/s/sWEBZzm6qmW2-LEw6Rdz3Q">https://mp.weixin.qq.com/s/sWEBZzm6qmW2-LEw6Rdz3Q</a></p>
</blockquote>
<h2 id="auto-amp-decltype"><a href="#auto-amp-decltype" class="headerlink" title="auto &amp; decltype"></a>auto &amp; decltype</h2><p>关于 C++11 新特性，最先提到的肯定是类型推导，C++11 引入了 <code>auto</code> 和 <code>decltype</code> 关键字，使用他们可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。</p>
<ul>
<li><code>auto</code>：让编译器在编译器就推导出变量的类型，可以通过&#x3D;右边的类型推导出变量的类型。</li>
<li><code>decltype</code>：相对于 auto 用于推导变量类型，而 <code>decltype</code> 则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">10</span>; <span class="comment">// 10 是 int 型，可以自动推导出 a 是 int</span></span><br><span class="line"></span><br><span class="line">cont <span class="type">int</span> &amp;i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) b = <span class="number">2</span>; <span class="comment">// b 是 const int&amp;</span></span><br></pre></td></tr></table></figure>

<h2 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h2><p>众所周知 C++11 新增了右值引用，这里涉及到很多概念：</p>
<ul>
<li>左值：可以取地址并且有名字的东西就是左值。</li>
<li>右值：不能取地址的没有名字的东西就是右值。</li>
<li>纯右值：运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、<code>lambda</code> 表达式等都是纯右值。</li>
<li>将亡值：可以理解为即将要销毁的值。</li>
<li>左值引用：对左值进行引用的类型。</li>
<li>右值引用：对右值进行引用的类型。</li>
<li>移动语义：转移资源所有权，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用。</li>
<li>完美转发：可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参。</li>
<li>返回值优化：当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。</li>
</ul>
<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>在 C++11 中可以直接在变量名后面加上初始化列表来进行对象的初始化。</p>
<h2 id="std-function-amp-std-bind-amp-lambda-表达式"><a href="#std-function-amp-std-bind-amp-lambda-表达式" class="headerlink" title="std::function &amp; std::bind &amp; lambda 表达式"></a>std::function &amp; std::bind &amp; lambda 表达式</h2><p>c++11 新增了 std::function、std::bind、lambda 表达式等封装使函数调用更加方便。</p>
<h2 id="模板的改进"><a href="#模板的改进" class="headerlink" title="模板的改进"></a>模板的改进</h2><p>C++11 关于模板有一些细节的改进：</p>
<ul>
<li>模板的右尖括号</li>
<li>模板的别名</li>
<li>函数模板的默认模板参数</li>
</ul>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>c++11 关于并发引入了好多好东西，有：</p>
<ul>
<li><code>std::thread</code> 相关</li>
<li><code>std::mutex</code> 相关</li>
<li><code>std::lock</code> 相关</li>
<li><code>std::atomic</code> 相关</li>
<li><code>std::call_once</code> 相关</li>
<li><code>volatile</code> 相关</li>
<li><code>std::condition_variable</code> 相关</li>
<li><code>std::future</code> 相关</li>
<li><code>async</code> 相关</li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>c++11 引入了三种智能指针：</p>
<ul>
<li><code>std::shared_ptr</code></li>
<li><code>std::weak_ptr</code></li>
<li><code>std::unique_ptr</code></li>
</ul>
<h2 id="基于范围的-for-循环"><a href="#基于范围的-for-循环" class="headerlink" title="基于范围的 for 循环"></a>基于范围的 for 循环</h2><p>直接看代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = vec.<span class="built_in">begin</span>(); iter != vec.<span class="built_in">end</span>(); iter++) &#123; <span class="comment">// before c++11</span></span><br><span class="line">   cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : vec) &#123; <span class="comment">// c++11基于范围的for循环</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><p>委托构造函数允许在同一个类中一个构造函数调用另外一个构造函数，可以在变量初始化时简化操作，通过代码来感受下委托构造函数的妙处吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> a) &#123; a_ = a; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">A</span>(a) &#123; b_ = b; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">A</span>(a, b) &#123; c_ = c; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> a_;</span><br><span class="line">   <span class="type">int</span> b_;</span><br><span class="line">   <span class="type">int</span> c_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化变量是不是方便了许多。</p>
<h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>继承构造函数可以让派生类直接使用基类的构造函数，如果有一个派生类，我们希望派生类采用和基类一样的构造方式，可以直接使用基类的构造函数，而不是再重新写一遍构造函数，老规矩，看代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">   <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">   <span class="built_in">Base</span>(<span class="type">int</span> a) &#123; a_ = a; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">Base</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">Base</span>(a) &#123; b_ = b; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">Base</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">Base</span>(a, b) &#123; c_ = c; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> a_;</span><br><span class="line">   <span class="type">int</span> b_;</span><br><span class="line">   <span class="type">int</span> c_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">   <span class="keyword">using</span> Base::Base;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="function">Derived <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要使用 <code>using Base::Base</code> 继承构造函数，就免去了很多重写代码的麻烦。</p>
<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p><code>nullptr</code> 是 c++11 用来表示空指针新引入的常量值，在 c++中如果表示空指针语义时建议使用 <code>nullptr</code> 而不要使用 <code>NULL</code>，因为 <code>NULL</code> 本质上是个 <code>int</code> 型的 0，其实不是个指针。举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;func ptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;func i&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">func</span>(<span class="literal">NULL</span>); <span class="comment">// 编译失败，会产生二义性</span></span><br><span class="line">   <span class="built_in">func</span>(<span class="literal">nullptr</span>); <span class="comment">// 输出func ptr</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="final-amp-override"><a href="#final-amp-override" class="headerlink" title="final &amp; override"></a>final &amp; override</h2><p>c++11 关于继承新增了两个关键字，<code>final</code> 用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载，<code>override</code> 用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了 <code>override</code> 但父类却没有这个虚函数，编译报错，使用 <code>override</code> 关键字可以避免开发者在重写基类函数时无意产生的错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;base&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 确保func被重写</span></span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">fu</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// error，基类没有fu()，不可以被重写</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> <span class="keyword">final</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;base&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123; <span class="comment">// 编译失败，final修饰的类不可以被继承</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p>c++11 引入 <code>default</code> 特性，多数时候用于声明构造函数为默认构造函数，如果类中有了自定义的构造函数，编译器就不会隐式生成默认构造函数，而通过 <code>default</code>，程序员只需在函数声明后加上<code>=default;</code>，就可将该函数声明为 <code>defaulted</code> 函数，编译器将为显式声明的 <code>defaulted</code> 函数自动生成函数体，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> i) &#123; a = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   A a;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>c++中，如果开发人员没有定义特殊成员函数，那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，例如拷贝构造函数或者拷贝赋值操作符，而我们有时候想禁止对象的拷贝与赋值，可以使用 <code>delete</code> 修饰，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">const</span> A&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">   A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> i) &#123; a = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   A a1;</span><br><span class="line">   A a2 = a1;  <span class="comment">// 错误，拷贝构造函数被禁用</span></span><br><span class="line">   A a3;</span><br><span class="line">   a3 = a1;  <span class="comment">// 错误，拷贝赋值操作符被禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>delele</code> 函数在 c++11 中很常用，<code>std::unique_ptr</code> 就是通过 <code>delete</code> 修饰来禁止对象的拷贝的。</p>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p><code>explicit</code> 专用于修饰构造函数，表示只能显式构造，不可以被隐式转换，根据代码看 <code>explicit</code> 的作用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">structA &#123;</span><br><span class="line"><span class="built_in">explicitA</span>(<span class="type">int</span> value)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">intmain</span>()&#123;</span><br><span class="line">A a = <span class="number">1</span>; <span class="comment">// error，不可以隐式转换</span></span><br><span class="line"><span class="function">A <span class="title">aa</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// ok</span></span><br><span class="line">return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>因为要讲后面的 <code>constexpr</code>，所以这里简单介绍下 <code>const</code>。</p>
<p><code>const</code> 字面意思为只读，可用于定义变量，表示变量是只读的，不可以更改，如果更改，编译期间就会报错。</p>
<p>主要用法如下：</p>
<ul>
<li>用于定义常量，<code>const</code> 的修饰的变量不可更改。</li>
<li>指针也可以使用 <code>const</code>，这里有个小技巧，从右向左读，即可知道 <code>const</code> 究竟修饰的是指针还是指针所指向的内容。</li>
<li>在函数参数中使用 <code>const</code>，一般会传递类对象时会传递一个 <code>const</code> 的引用或者指针，这样可以避免对象的拷贝，也可以防止对象被修改。</li>
<li><code>const</code> 修饰类的成员变量，表示是成员常量，不能被修改，可以在初始化列表中被赋值。</li>
<li>修饰类成员函数，表示在该函数内不可以修改该类的成员变量。</li>
<li>修饰类对象，类对象只能调用该对象的 <code>const</code> 成员函数。</li>
</ul>
<h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><p><code>constexpr</code> 是 c++11 新引入的关键字，用于编译时的常量和常量函数，这里直接介绍 <code>constexpr</code> 和 <code>const</code> 的区别：</p>
<p>两者都代表可读，<code>const</code> 只表示 read only 的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而 <code>constexpr</code> 修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，<code>constexpr</code> 可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。</p>
<h2 id="enum-class"><a href="#enum-class" class="headerlink" title="enum class"></a>enum class</h2><p>c++11 新增有作用域的枚举类型，不带作用域的枚举类型可以自动转换成整形，且不同的枚举可以相互比较；带作用域的枚举类型可以选择底层类型，默认是 <code>int</code>，可以改成 <code>char</code> 等别的类型。</p>
<p>我们平时编程过程中使用枚举，一定要使用有作用域的枚举取代传统的枚举。</p>
<h2 id="非受限联合体"><a href="#非受限联合体" class="headerlink" title="非受限联合体"></a>非受限联合体</h2><p>c++11 之前 <code>union</code> 中数据成员的类型不允许有非 POD 类型，而这个限制在 c++11 被取消，允许数据成员类型有非 POD 类型。</p>
<p>对于什么是 POD 类型，大家可以自行查下资料，大体上可以理解为对象可以直接 <code>memcpy</code> 的类型。</p>
<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>c++11 中 <code>sizeof</code> 可以用的类的数据成员上，想知道类中数据成员的大小在 c++11 中方便了许多，而不需要定义一个对象，在计算对象的成员大小。</p>
<h2 id="assertion"><a href="#assertion" class="headerlink" title="assertion"></a>assertion</h2><p>c++11 引入 <code>static_assert</code> 声明，用于在编译期间检查，如果第一个参数值为 <code>false</code>，则打印 <code>message</code>，编译失败。</p>
<h2 id="自定义字面量"><a href="#自定义字面量" class="headerlink" title="自定义字面量"></a>自定义字面量</h2><p>c++11 可以自定义字面量。</p>
<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>什么是内存对齐</p>
<p>理论上计算机对于任何变量的访问都可以从任意位置开始，然而实际上系统会对这些变量的存放地址有限制，通常将变量首地址设为某个数 N 的倍数，这就是内存对齐。</p>
<p>为什么要内存对齐</p>
<p>硬件平台限制，内存以字节为单位，不同硬件平台不一定支持任何内存地址的存取，一般可能以双字节、4 字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐。<br>提高 CPU 内存访问速度，一般处理器的内存存取粒度都是 N 的整数倍，假如访问 N 大小的数据，没有进行内存对齐，有可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次性把数据全部读取出来，提高效率。</p>
<h2 id="thread-local"><a href="#thread-local" class="headerlink" title="thread_local"></a>thread_local</h2><p>c++11 引入 <code>thread_local</code>，用 <code>thread_local</code> 修饰的变量具有 <code>thread</code> 周期，每一个线程都拥有并只拥有一个该变量的独立实例，一般用于需要保证线程安全的函数中。</p>
<h2 id="基础数值类型"><a href="#基础数值类型" class="headerlink" title="基础数值类型"></a>基础数值类型</h2><p>c++11 新增了几种数据类型：<code>long long</code>、<code>char16_t</code>、<code>char32_t</code> 等</p>
<h2 id="随机数功能"><a href="#随机数功能" class="headerlink" title="随机数功能"></a>随机数功能</h2><p>c++11 关于随机数功能则较之前丰富了很多，典型的可以选择概率分布类型。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>c++11 引入了 regex 库更好的支持正则表达式。</p>
<h2 id="chrono"><a href="#chrono" class="headerlink" title="chrono"></a>chrono</h2><p>c++11 关于时间引入了 <code>chrono</code> 库，源于 boost，功能强大，<code>chrono</code> 主要有三个点：</p>
<ul>
<li>duration: 表示一段时间，常见的单位有 s、ms 等</li>
<li>time_point: 表示一个具体时间点，如 2020 年 5 月 10 日 10 点 10 分 10 秒</li>
<li>clocks:时钟，chrono 里面提供了三种时钟：<ul>
<li>steady_clock: 稳定的时间间隔，表示相对时间，相对于系统开机启动的时间，无论系统时间如何被更改，后一次调用 now()肯定比前一次调用 now()的数值大，可用于计时。</li>
<li>system_clock: 表示当前的系统时钟，可以用于获取当前时间。</li>
<li>high_resolution_clock: 表示系统可用的最高精度的时钟。</li>
</ul>
</li>
</ul>
<h2 id="新增数据结构"><a href="#新增数据结构" class="headerlink" title="新增数据结构"></a>新增数据结构</h2><ul>
<li><code>std::forward_list</code>：单向链表，只可以前进，在特定场景下使用，相比于 std::list 节省了内存，提高了性能</li>
<li><code>std::unordered_set</code>：基于 hash 表实现的 set，内部不会排序，使用方法和 set 类似</li>
<li><code>std::unordered_map</code>：基于 hash 表实现的 map，内部不会排序，使用方法和 set 类似</li>
<li><code>std::array</code>：数组，在越界访问时抛出异常，建议使用 std::array 替代普通的数组</li>
<li><code>std::tuple</code>：元组类型，类似 pair，但比 pair 扩展性好</li>
</ul>
<h2 id="新增算法"><a href="#新增算法" class="headerlink" title="新增算法"></a>新增算法</h2><ul>
<li><code>all_of</code>：检测表达式是否对范围 <code>[first, last)</code> 中所有元素都返回 true，如果都满足，则返回 true</li>
<li><code>any_of</code>：检测表达式是否对范围 <code>[first, last)</code> 中至少一个元素返回 true，如果满足，则返回 true，否则返回 false，用法和上面一样</li>
<li><code>none_of</code>：检测表达式是否对范围 <code>[first, last)</code> 中所有元素都不返回 true，如果都不满足，则返回 true，否则返回 false，用法和上面一样</li>
<li><code>find_if_not</code>：找到第一个不符合要求的元素迭代器，和 find_if 相反</li>
<li><code>copy_if</code>：复制满足条件的元素</li>
<li><code>itoa</code>：对容器内的元素按序递增</li>
<li><code>minmax_element</code>：返回容器内最大元素和最小元素位置</li>
<li><code>is_sorted</code>、<code>is_sorted_until</code>：返回容器内元素是否已经排好序。</li>
</ul>
<h1 id="C-14-新特性"><a href="#C-14-新特性" class="headerlink" title="C++14 新特性"></a>C++14 新特性</h1><h2 id="函数返回值类型推导"><a href="#函数返回值类型推导" class="headerlink" title="函数返回值类型推导"></a>函数返回值类型推导</h2><p>C++14 对函数返回类型推导规则做了优化，返回值类型推导也可以用在模板中。</p>
<h2 id="lambda-参数-auto"><a href="#lambda-参数-auto" class="headerlink" title="lambda 参数 auto"></a>lambda 参数 auto</h2><h2 id="变量模板"><a href="#变量模板" class="headerlink" title="变量模板"></a>变量模板</h2><h2 id="别名模板"><a href="#别名模板" class="headerlink" title="别名模板"></a>别名模板</h2><h2 id="deprecated-标记"><a href="#deprecated-标记" class="headerlink" title="[[deprecated]]标记"></a><code>[[deprecated]]</code>标记</h2><p>C++14 中增加了 deprecated 标记，修饰类、变、函数等，当程序中使用到了被其修饰的代码时，编译时被产生警告，用户提示开发者该标记修饰的内容将来可能会被丢弃，尽量不要使用。</p>
<h2 id="二进制字面量与整形字面量分隔符"><a href="#二进制字面量与整形字面量分隔符" class="headerlink" title="二进制字面量与整形字面量分隔符"></a>二进制字面量与整形字面量分隔符</h2><h2 id="新增下列标准函数："><a href="#新增下列标准函数：" class="headerlink" title="新增下列标准函数："></a>新增下列标准函数：</h2><ul>
<li><code>std::make_unique</code></li>
<li><code>std::shared_timed_mutex</code> 与 <code>std::shared_lock</code></li>
<li><code>std::integer_sequence</code></li>
<li><code>std::exchange</code></li>
<li><code>std::quoted</code></li>
</ul>
<h1 id="C-17-新特性"><a href="#C-17-新特性" class="headerlink" title="C++17 新特性"></a>C++17 新特性</h1><h2 id="构造函数模板推导"><a href="#构造函数模板推导" class="headerlink" title="构造函数模板推导"></a>构造函数模板推导</h2><p>C++17 就不需要构造一个模板类对象需要指明类型，直接可以推导出类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">pair <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2.2</span>)</span></span>; <span class="comment">// c++17 自动推导</span></span><br><span class="line">vector v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// c++17</span></span><br></pre></td></tr></table></figure>

<h2 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h2><p>通过结构化绑定，对于 tuple、map 等类型，获取相应值会方便很多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::pair <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2.3f</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span>[i, f] = a;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; m = &#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;[i, s] : m) &#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="if-switch-语句初始化"><a href="#if-switch-语句初始化" class="headerlink" title="if-switch 语句初始化"></a>if-switch 语句初始化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if (init; condition)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="type">int</span> a = <span class="built_in">GetValue</span>()); a &lt; <span class="number">101</span>) &#123;</span><br><span class="line">   cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string str = <span class="string">&quot;Hi World&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> [pos, size] = <span class="built_in">pair</span>(str.<span class="built_in">find</span>(<span class="string">&quot;Hi&quot;</span>), str.<span class="built_in">size</span>()); pos != string::npos) &#123;</span><br><span class="line">   std::cout &lt;&lt; pos &lt;&lt; <span class="string">&quot; Hello, size is &quot;</span> &lt;&lt; size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种方式可以尽可能约束作用域，让代码更简洁，但是可读性略有下降。</p>
<h2 id="内联变量"><a href="#内联变量" class="headerlink" title="内联变量"></a>内联变量</h2><p>C++17 前只有内联函数，现在有了内联变量，我们印象中 C++类的静态成员变量在头文件中是不能初始化的，但是有了内联变量，就可以达到此目的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// header file</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="type">const</span> A::value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==========或者========</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h2><p>C++17 引入了折叠表达式使可变参数模板编程更方便：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Ts ... ts)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (ts + ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a &#123;<span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)&#125;; <span class="comment">// 15</span></span><br><span class="line">std::string a&#123;<span class="string">&quot;hello &quot;</span>&#125;;</span><br><span class="line">std::string b&#123;<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sum</span>(a, b) &lt;&lt; endl; <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<h2 id="constexpr-lambda-表达式"><a href="#constexpr-lambda-表达式" class="headerlink" title="constexpr lambda 表达式"></a>constexpr lambda 表达式</h2><p>C++17 前 lambda 表达式只能在运行时使用，C++17 引入了 constexpr lambda 表达式，可以用于在编译期进行计算。</p>
<h2 id="namespace-嵌套"><a href="#namespace-嵌套" class="headerlink" title="namespace 嵌套"></a>namespace 嵌套</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">   <span class="keyword">namespace</span> B &#123;</span><br><span class="line">       <span class="keyword">namespace</span> C &#123;</span><br><span class="line">           <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c++17，更方便更舒适</span></span><br><span class="line"><span class="keyword">namespace</span> A::B::C &#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="has-include-预处理表达式"><a href="#has-include-预处理表达式" class="headerlink" title="__has_include 预处理表达式"></a><code>__has_include</code> 预处理表达式</h2><p><code>__has_include</code> 预处理表达式可以判断是否有某个头文件，代码可能会在不同编译器下工作，不同编译器的可用头文件有可能不同，所以可以使用此来判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined __has_include</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&lt;charconv&gt;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> has_charconv 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;charconv&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">ConvertToInt</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> value&#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> has_charconv</span></span><br><span class="line">   <span class="type">const</span> <span class="keyword">auto</span> last = str.<span class="built_in">data</span>() + str.<span class="built_in">size</span>();</span><br><span class="line">   <span class="type">const</span> <span class="keyword">auto</span> res = std::<span class="built_in">from_chars</span>(str.<span class="built_in">data</span>(), last, value);</span><br><span class="line">   <span class="keyword">if</span> (res.ec == std::errc&#123;&#125; &amp;&amp; res.ptr == last) <span class="keyword">return</span> value;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">   <span class="comment">// alternative implementation...</span></span><br><span class="line">   其它方式实现</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在-lambda-表达式用-this-捕获对象副本"><a href="#在-lambda-表达式用-this-捕获对象副本" class="headerlink" title="在 lambda 表达式用 *this 捕获对象副本"></a>在 lambda 表达式用 <code>*this</code> 捕获对象副本</h2><p>正常情况下，lambda 表达式中访问类的对象成员变量需要捕获 this，但是这里捕获的是 this 指针，指向的是对象的引用，正常情况下可能没问题，但是如果多线程情况下，函数的作用域超过了对象的作用域，对象已经被析构了，还访问了成员变量，就会有问题。</p>
<p>所以 C++17 增加了新特性，捕获*this，不持有 this 指针，而是持有对象的拷贝，这样生命周期就与对象的生命周期不相关啦。</p>
<h2 id="新增-Attribute"><a href="#新增-Attribute" class="headerlink" title="新增 Attribute"></a>新增 Attribute</h2><p>我们可能平时在项目中见过 <code>__declspec__</code> , <code>__attribute__</code> , <code>#pragma</code> 指示符，使用它们来给编译器提供一些额外的信息，来产生一些优化或特定的代码，也可以给其它开发者一些提示信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">short</span> f[<span class="number">3</span>]; &#125; __attribute__((<span class="built_in">aligned</span>(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fatal</span><span class="params">()</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;</span><br></pre></td></tr></table></figure>

<p>在 C++11 和 C++14 中有更方便的方法：</p>
<ul>
<li><code>[[carries_dependency]]</code> 让编译期跳过不必要的内存栅栏指令</li>
<li><code>[[noreturn]]</code> 函数不会返回</li>
<li><code>[[deprecated]]</code> 函数将弃用的警告</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[[noreturn]] <span class="function"><span class="type">void</span> <span class="title">terminate</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">[[<span class="built_in">deprecated</span>(<span class="string">&quot;use new func instead&quot;</span>)]] <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[[fallthrough]]</code>：用在 switch 中提示可以直接落下去，不需要 break，让编译期忽略警告</li>
<li><code>[[nodiscard]]</code> ：表示修饰的内容不能被忽略，可用于修饰函数，标明返回值一定要被处理</li>
<li><code>[[maybe_unused]]</code> ：提示编译器修饰的内容可能暂时没有使用，避免产生警告</li>
</ul>
<h2 id="新增下列标准"><a href="#新增下列标准" class="headerlink" title="新增下列标准"></a>新增下列标准</h2><p><code>file_system</code><br><code>std::variant</code><br><code>std::optional</code><br><code>std::any</code><br><code>std::apply</code><br><code>std::make_from_tuple</code><br><code>as_const</code><br><code>std::string_view</code><br><code>std::shared_mutex</code></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="C-名称粉碎使用-C-filt-工具恢复"><a href="#C-名称粉碎使用-C-filt-工具恢复" class="headerlink" title="C++ 名称粉碎使用 C++filt 工具恢复"></a><code>C++</code> 名称粉碎使用 <code>C++filt</code> 工具恢复</h2><p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ c++filt _Z3addii</span><br><span class="line">add(int, int)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="判断编译平台宏定义"><a href="#判断编译平台宏定义" class="headerlink" title="判断编译平台宏定义"></a>判断编译平台宏定义</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">   <span class="comment">//define something for Windows (32-bit and 64-bit, this part is common)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">      <span class="comment">//define something for Windows (64-bit only)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="comment">//define something for Windows (32-bit only)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __APPLE__</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TargetConditionals.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">         <span class="comment">// iOS Simulator</span></span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> TARGET_OS_IPHONE</span></span><br><span class="line">        <span class="comment">// iOS device</span></span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> TARGET_OS_MAC</span></span><br><span class="line">        <span class="comment">// Other kinds of Mac OS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#   <span class="keyword">error</span> <span class="string">&quot;Unknown Apple platform&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __ANDROID__</span></span><br><span class="line">    <span class="comment">// android</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line">    <span class="comment">// linux</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __unix__ <span class="comment">// all unices not caught above</span></span></span><br><span class="line">    <span class="comment">// Unix</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_POSIX_VERSION)</span></span><br><span class="line">    <span class="comment">// POSIX</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">error</span> <span class="string">&quot;Unknown compiler&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="error-C2027-use-of-undefined-type"><a href="#error-C2027-use-of-undefined-type" class="headerlink" title="error C2027: use of undefined type"></a>error C2027: use of undefined type</h2><p>当遇到这种问题时， 将实现写到 cpp 文件中。</p>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># builder.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Burger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BurgerBuilder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">float</span> size;</span><br><span class="line">	<span class="type">bool</span> cheese = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> pepperoni = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> lettuce = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> tomato = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">BurgerBuilder</span>(<span class="type">float</span> size) : <span class="built_in">size</span>(size) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Burger* <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 将下列的实现代码写到 cpp 文件中，否则会报 error C2027: use of undefined type 错误。</span></span><br><span class="line">	<span class="comment">// &#123;</span></span><br><span class="line">	<span class="comment">// 	return new Burger(this);</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Burger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">float</span> size;</span><br><span class="line">	<span class="type">bool</span> cheese = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> pepperoni = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> lettuce = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> tomato = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Burger</span>(BurgerBuilder* builder) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;size = builder-&gt;size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cheese = builder-&gt;cheese;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pepperoni = builder-&gt;pepperoni;</span><br><span class="line">		<span class="keyword">this</span>-&gt;lettuce = builder-&gt;lettuce;</span><br><span class="line">		<span class="keyword">this</span>-&gt;tomato = builder-&gt;tomato;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// builder.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Builder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Burger* <span class="title">BurgerBuilder::build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Burger</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="https://stackoverflow.com/questions/33964994/error-c2027-use-of-undefined-type-how-to-declare-class">https://stackoverflow.com/questions/33964994/error-c2027-use-of-undefined-type-how-to-declare-class</a></p>
</blockquote>
<h2 id="jupyter-notebook-for-C"><a href="#jupyter-notebook-for-C" class="headerlink" title="jupyter notebook for C++"></a>jupyter notebook for C++</h2><p>这里可以使用 <a href="https://github.com/jupyter-xeus/xeus-cling">xeus-cling</a> 搭建一个 Jupyter kernel 环境，方便边做笔记边测试。</p>
<p>首先安装 <a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">Miniconda</a> 并创建一个新的环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda create -n cling python=3.9</span><br></pre></td></tr></table></figure>

<p>然后安装<a href="https://github.com/jupyter-xeus/xeus-cling">xeus-cling</a> 和 <a href="https://jupyter.org/install">Jupyter Notebook</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda install jupyter notebook</span><br><span class="line">$ conda install xeus-cling -c conda-forge</span><br></pre></td></tr></table></figure>

<p>安装好了之后，运行 <code>jupyter kernelspec list</code> 将会出现下列内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jupyter kernelspec list</span><br><span class="line">Available kernels:</span><br><span class="line">  python3    /home/ckcat/miniconda3/envs/cling/share/jupyter/kernels/python3</span><br><span class="line">  xcpp11     /home/ckcat/miniconda3/envs/cling/share/jupyter/kernels/xcpp11</span><br><span class="line">  xcpp14     /home/ckcat/miniconda3/envs/cling/share/jupyter/kernels/xcpp14</span><br><span class="line">  xcpp17     /home/ckcat/miniconda3/envs/cling/share/jupyter/kernels/xcpp17</span><br></pre></td></tr></table></figure>

<p>之后运行 <code>jupyter notebook --allow-root --ip=0.0.0.0 --port=2233</code> 命令即可。</p>
<ul>
<li><code>--ip=0.0.0.0</code> 作用是允许外部试用。</li>
<li><code>--port=2233</code> 表示运行的端口。</li>
</ul>
<p>后面就可以通过本地浏览器写笔记和代码。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>learn-ebpf</title>
    <url>/2023/09/22/learn-ebpf/</url>
    <content><![CDATA[<p>占坑 <a href="https://github.com/eunomia-bpf/bpf-developer-tutorial">https://github.com/eunomia-bpf/bpf-developer-tutorial</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ebpf</tag>
      </tags>
  </entry>
  <entry>
    <title>frida环境配置</title>
    <url>/2020/01/19/learn-frida/</url>
    <content><![CDATA[<p>Frida 源码地址：<a href="https://github.com/frida/frida">https://github.com/frida/frida</a></p>
<p>Frida 官网：<a href="https://frida.re/">https://frida.re/</a></p>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="安装-Frida"><a href="#安装-Frida" class="headerlink" title="安装 Frida"></a>安装 Frida</h2><p>在安装 <code>Frida</code> 之前最好创建一个 <code>python</code> 虚拟环境，这样可以避免与其他环境产生干扰</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda create -n frida_12.8.7 python=3.9 <span class="comment"># miniconda 创建虚拟环境</span></span><br></pre></td></tr></table></figure>

<p>荐使用 miniconda 创建虚拟环境，接下来就可以安装 <a href="https://github.com/frida/frida">Frida</a> 了。</p>
<ol>
<li><p><strong>安装最新版 Frida</strong></p>
<p>进入虚拟环境，直接运行下来命令即可安装完成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda activate frida_12.8.7</span><br><span class="line">$ pip install frida-tools <span class="comment"># CLI tools</span></span><br><span class="line">$ pip install frida       <span class="comment"># Python bindings</span></span><br></pre></td></tr></table></figure>

<p>安装完成后，运行 <code>frida --version</code> 查看 frida 的版本</p>
<img src="/2020/01/19/learn-frida/2020-01-19-16-20-36.png" class="">
</li>
<li><p><strong>安装特定版本的 Frida</strong></p>
<p>通过 <a href="https://github.com/frida/frida/releases">Frida Releases</a> 页面找到需要安装的 <code>frida-tools</code> 版本，使用 <code>pip</code> 指定版本安装，这里以 <code>Frida 12.11.18</code> 为例。</p>
<p>首先找到 <code>frida-tools</code> 版本。</p>
<img src="/2020/01/19/learn-frida/2021-09-02-16-47-25.png" class="">

<p>然后使用 <code>pip</code> 安装对应的版本，下面为完整安装命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pip install frida==12.11.18</span><br><span class="line">$ pip install frida-tools==8.2.0</span><br></pre></td></tr></table></figure></li>
</ol>
<p>安装完成后，根据 <code>Frida</code> 的版本去<a href="https://github.com/frida/frida/releases">下载</a>对应的 <code>frida-server</code>。</p>
<p>最后将 <code>frida-server push</code> 进 <code>data/local/tmp</code> 目录，并给予其运行权限，使用 <code>root</code> 用户启动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb push frida-server data/local/tmp/</span><br><span class="line">$ adb shell</span><br><span class="line">sailfish:/ $ su</span><br><span class="line">sailfish:/ <span class="comment"># chmod +x data/local/tmp/frida-server</span></span><br><span class="line">sailfish:/ <span class="comment"># data/local/tmp//frida-server &amp;</span></span><br></pre></td></tr></table></figure>

<p>执行 <code>frida-ps -U</code> ,出现以下信息则表明安装成功。</p>
<img src="/2020/01/19/learn-frida/2020-01-19-16-31-30.png" class="">

<p>如果遇到分析的样本有反调试，可以试试下面的 frida-server 版本：</p>
<p><a href="https://github.com/Ylarod/Florida/releases">https://github.com/Ylarod/Florida/releases</a></p>
<h2 id="配置开发环境"><a href="#配置开发环境" class="headerlink" title="配置开发环境"></a>配置开发环境</h2><p>为了在开发 Frida 脚本时有代码补全提示，我们可以使用下面两种方式进行环境配置。</p>
<ol>
<li><p><strong>使用 <code>TypeScript</code>（推荐）</strong></p>
<p>使用 <code>Frida</code> 官方提供的开发环境 <a href="https://github.com/oleavr/frida-agent-example">frida-agent-example</a> ，该环境需要使用 <code>TypeScript</code> 开发。</p>
<p>构建开发环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/oleavr/frida-agent-example.git</span><br><span class="line">$ <span class="built_in">cd</span> frida-agent-example/</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>启用实时编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm run watch</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ frida-compile agent/index.ts -o _agent.js -w</span><br></pre></td></tr></table></figure>

<p>后续直接使用 <code>index.ts</code> 开发即可实现代码补全提示。</p>
</li>
<li><p><strong>引用 <code>frida-gum.d.ts</code></strong></p>
<p>在 <code>Frida</code> 源码中获取 <a href="https://github.com/frida/frida-gum/tree/6e36eebe1aad51c37329242cf07ac169fc4a62c4/bindings/gumjs/types/frida-gum">frida-gum.d.ts</a> 文件，该文件包含了所有的 API 。</p>
<p>在我们开发的 <code>js</code> 脚本首行中引用 <code>frida-gum.d.ts</code> 文件，即可实现代码补全提示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">`///&lt;reference path=&#x27;./frida-gum.d.ts&#x27;/&gt;`</span>;</span><br></pre></td></tr></table></figure>

<img src="/2020/01/19/learn-frida/2020-01-19-16-50-57.png" class="">

<p>其他方式获取 <code>frida-gum.d.ts</code> 文件：</p>
<blockquote>
<p><a href="https://www.npmjs.com/package/@types/frida-gum">https://www.npmjs.com/package/@types/frida-gum</a></p>
</blockquote>
</li>
</ol>
<h2 id="配置调试环境"><a href="#配置调试环境" class="headerlink" title="配置调试环境"></a>配置调试环境</h2><p>这里主要使用 <code>chrome</code> 和 <code>pycharm</code> 两种方式进行调试。</p>
<p>首先使用 <code>Frida</code> 命令或者 <code>python</code> 脚本以调试模式加载 <code>js</code> 脚本。</p>
<ol>
<li><p><strong>Frida 命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ frida -U com.example.android -l _agent.js --debug --runtime=v8 &lt;port/name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>python 脚本:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">session = dev.attach(app.pid)</span><br><span class="line">script = session.create_script(jscode, runtime=<span class="string">&quot;v8&quot;</span>)</span><br><span class="line">session.enable_debugger()</span><br></pre></td></tr></table></figure></li>
</ol>
<p>启动后会回显 <code>Inspector</code> 正在监听 <code>9229</code> 默认端口，下面就可以使用 chome 或 pycharm 进行调试了。</p>
<ol>
<li><p><strong>chome 调试</strong><br>打开 <code>chrome://inspect</code> 页面, 点击 <code>Open dedicated DevTools for Node</code> 。</p>
<img src="/2020/01/19/learn-frida/2021-09-07-17-53-36.png" class="">

<p>此时 <code>debug</code> 已经连接，切换至 <code>Sources</code> ，按 <code>Command + P</code> 加载要调试的脚本，即可下断调试了。</p>
<img src="/2020/01/19/learn-frida/2021-09-07-17-56-47.png" class="">
</li>
<li><p><strong>pycharm 调试</strong><br>首先安装 <code>Node.js</code> 插件，重启。然后添加调试器 <code>Attaching to Node.js/Chrome</code>，端口默认即可。</p>
<img src="/2020/01/19/learn-frida/2021-09-08-14-51-43.png" class="">

<blockquote>
<p>我这里使用的 <code>node</code> 版本为 12.21.0 。</p>
</blockquote>
<p>在 <code>ts</code> 文件中设置好断点，执行 pycharm 调试功能即可。</p>
<img src="/2020/01/19/learn-frida/2021-09-08-14-56-07.png" class="">

<blockquote>
<p>如果调试 <code>js</code> 脚本， 触发断点需要在 <code>debug</code> 窗口切换到 <code>script</code> 选项卡，右键要调试的脚本，选择 <code>Open Actual Source</code>，在新打开的 <code>Actual Source</code> 窗口设置好断点后，需要再取消&#x2F;启用一次所有断点作为激活，发现断点上打上对勾才真正可用了。（未测试）</p>
</blockquote>
</li>
</ol>
<p>参考：<a href="https://bbs.pediy.com/thread-265160-1.htm">https://bbs.pediy.com/thread-265160-1.htm</a></p>
<h1 id="Frida-使用"><a href="#Frida-使用" class="headerlink" title="Frida 使用"></a>Frida 使用</h1><h2 id="执行-Frida-脚本"><a href="#执行-Frida-脚本" class="headerlink" title="执行 Frida 脚本"></a>执行 Frida 脚本</h2><p>通过运行 <code>frida -h</code> 可以查看 frida 支持的命令，其中可以使用 attach 和 spawn 两种方式执行 frida 脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ frida -h</span><br><span class="line">usage: frida [options] target</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  args                  extra arguments and/or target</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -D ID, --device ID    connect to device with the given ID</span><br><span class="line">  -U, --usb             connect to USB device</span><br><span class="line">  -R, --remote          connect to remote frida-server</span><br><span class="line">  -H HOST, --host HOST  connect to remote frida-server on HOST</span><br><span class="line">  --certificate CERTIFICATE</span><br><span class="line">                        speak TLS with HOST, expecting CERTIFICATE</span><br><span class="line">  --origin ORIGIN       connect to remote server with “Origin” header <span class="built_in">set</span> to</span><br><span class="line">                        ORIGIN</span><br><span class="line">  --token TOKEN         authenticate with HOST using TOKEN</span><br><span class="line">  --keepalive-interval INTERVAL</span><br><span class="line">                        <span class="built_in">set</span> keepalive interval <span class="keyword">in</span> seconds, or 0 to <span class="built_in">disable</span></span><br><span class="line">                        (defaults to -1 to auto-select based on transport)</span><br><span class="line">  --p2p                 establish a peer-to-peer connection with target</span><br><span class="line">  --stun-server ADDRESS</span><br><span class="line">                        <span class="built_in">set</span> STUN server ADDRESS to use with --p2p</span><br><span class="line">  --relay address,username,password,turn-&#123;udp,tcp,tls&#125;</span><br><span class="line">                        add relay to use with --p2p</span><br><span class="line">  -f TARGET, --file TARGET</span><br><span class="line">                        spawn FILE</span><br><span class="line">  -F, --attach-frontmost</span><br><span class="line">                        attach to frontmost application</span><br><span class="line">  -n NAME, --attach-name NAME</span><br><span class="line">                        attach to NAME</span><br><span class="line">  -N IDENTIFIER, --attach-identifier IDENTIFIER</span><br><span class="line">                        attach to IDENTIFIER</span><br><span class="line">  -p PID, --attach-pid PID</span><br><span class="line">                        attach to PID</span><br><span class="line">  -W PATTERN, --await PATTERN</span><br><span class="line">                        await spawn matching PATTERN</span><br><span class="line">  --stdio &#123;inherit,pipe&#125;</span><br><span class="line">                        stdio behavior when spawning (defaults to “inherit”)</span><br><span class="line">  --aux option          <span class="built_in">set</span> aux option when spawning, such as “uid=(int)42”</span><br><span class="line">                        (supported types are: string, bool, int)</span><br><span class="line">  --realm &#123;native,emulated&#125;</span><br><span class="line">                        realm to attach <span class="keyword">in</span></span><br><span class="line">  --runtime &#123;qjs,v8&#125;    script runtime to use</span><br><span class="line">  --debug               <span class="built_in">enable</span> the Node.js compatible script debugger</span><br><span class="line">  --squelch-crash       <span class="keyword">if</span> enabled, will not dump crash report to console</span><br><span class="line">  -O FILE, --options-file FILE</span><br><span class="line">                        text file containing additional <span class="built_in">command</span> line options</span><br><span class="line">  --version             show program<span class="string">&#x27;s version number and exit</span></span><br><span class="line"><span class="string">  -l SCRIPT, --load SCRIPT</span></span><br><span class="line"><span class="string">                        load SCRIPT</span></span><br><span class="line"><span class="string">  -P PARAMETERS_JSON, --parameters PARAMETERS_JSON</span></span><br><span class="line"><span class="string">                        parameters as JSON, same as Gadget</span></span><br><span class="line"><span class="string">  -C USER_CMODULE, --cmodule USER_CMODULE</span></span><br><span class="line"><span class="string">                        load CMODULE</span></span><br><span class="line"><span class="string">  --toolchain &#123;any,internal,external&#125;</span></span><br><span class="line"><span class="string">                        CModule toolchain to use when compiling from source</span></span><br><span class="line"><span class="string">                        code</span></span><br><span class="line"><span class="string">  -c CODESHARE_URI, --codeshare CODESHARE_URI</span></span><br><span class="line"><span class="string">                        load CODESHARE_URI</span></span><br><span class="line"><span class="string">  -e CODE, --eval CODE  evaluate CODE</span></span><br><span class="line"><span class="string">  -q                    quiet mode (no prompt) and quit after -l and -e</span></span><br><span class="line"><span class="string">  -t TIMEOUT, --timeout TIMEOUT</span></span><br><span class="line"><span class="string">                        seconds to wait before terminating in quiet mode</span></span><br><span class="line"><span class="string">  --pause               leave main thread paused after spawning program</span></span><br><span class="line"><span class="string">  -o LOGFILE, --output LOGFILE</span></span><br><span class="line"><span class="string">                        output to log file</span></span><br><span class="line"><span class="string">  --eternalize          eternalize the script before exit</span></span><br><span class="line"><span class="string">  --exit-on-error       exit with code 1 after encountering any exception in</span></span><br><span class="line"><span class="string">                        the SCRIPT</span></span><br><span class="line"><span class="string">  --kill-on-exit        kill the spawned program when Frida exits</span></span><br><span class="line"><span class="string">  --auto-perform        wrap entered code with Java.perform</span></span><br><span class="line"><span class="string">  --auto-reload         Enable auto reload of provided scripts and c module</span></span><br><span class="line"><span class="string">                        (on by default, will be required in the future)</span></span><br><span class="line"><span class="string">  --no-auto-reload      Disable auto reload of provided scripts and c module</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>attach 方式</strong></p>
<p><code>attach</code> 到已经存在的进程，核心原理是 <code>ptrace</code> 修改进程内存，如果进程处于调试状态（ <code>traceid</code> 不等于 <code>0</code> ），则 <code>attach</code> 失败。启动命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ frida -UN com.example.android -l _agent.js</span><br></pre></td></tr></table></figure>

<p>以上命令对应的 <code>python</code> 脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">message,data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;message&quot;</span>,message)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data&quot;</span>,data)</span><br><span class="line"></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line">session = device.attach(<span class="string">&quot;com.example.android&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;_agent.js&quot;</span>,<span class="string">&quot;r&quot;</span>, encoding = <span class="string">&quot;utf8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    script = session.create_script(f.read())</span><br><span class="line"></span><br><span class="line">script.on(<span class="string">&quot;message&quot;</span>,on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure>
</li>
<li><p>spawn 方式</p>
<p>启动一个新的进程并挂起，在启动的同时注入 <code>frida</code> 代码，适用于在进程启动前的一些 <code>hook</code> ，如 <code>hook RegisterNative</code> 等，注入完成后调用 <code>resume</code> 恢复进程。启动命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frida -U -f com.example.android -l _agent.js</span><br></pre></td></tr></table></figure>

<p>对应的 <code>python</code> 脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">message,data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;message&quot;</span>,message)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data&quot;</span>,data)</span><br><span class="line"></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line">pid = device.spawn([<span class="string">&quot;com.example.android&quot;</span>])</span><br><span class="line">device.resume(pid)</span><br><span class="line">session = device.attach(pid)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;_agent.js&quot;</span>,<span class="string">&#x27;r&#x27;</span>, encoding = <span class="string">&quot;utf8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    script = session.create_script(f.read())</span><br><span class="line"></span><br><span class="line">script.on(<span class="string">&quot;message&quot;</span>,on_message)</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Frida-自定义端口"><a href="#Frida-自定义端口" class="headerlink" title="Frida 自定义端口"></a>Frida 自定义端口</h2><p>默认情况下启动 <code>frida-server</code> 将会开启 <code>27042</code> 端口，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sailfish:/ <span class="comment"># netstat -tunlp |grep frida</span></span><br><span class="line">tcp        0      0 127.0.0.1:27042         0.0.0.0:*               LISTEN      5038/frida-server-14.2.18-android-arm64</span><br><span class="line">tcp        0      0 127.0.0.1:27042         127.0.0.1:46075         ESTABLISHED 5038/frida-server-14.2.18-android-arm64</span><br><span class="line">tcp6       0      0 :::49039                :::*                    LISTEN      5038/frida-server-14.2.18-android-arm64</span><br></pre></td></tr></table></figure>

<p>如果该端口被占用，启动 <code>frida-server</code> 将会失败，我们可以使用 <code>-l</code> 参数自定义端口，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sailfish:/ <span class="comment"># /data/local/tmp/frida-server-14.2.18-android-arm64 -l 0.0.0.0:6666 &amp;</span></span><br></pre></td></tr></table></figure>

<p>对应的 <code>Frida</code> 启动方式也需要作相应的改变，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb forward tcp:6666 tcp:6666</span><br><span class="line">6666</span><br><span class="line">$ frida -H 127.0.0.1:6666 com.example.android -l _agent.js</span><br></pre></td></tr></table></figure>

<p>对应的 <code>python</code> 脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> frida, sys</span><br><span class="line"></span><br><span class="line">jsCode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">console.log(&quot;test&quot;);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message</span>(<span class="params">message, data</span>):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] <span class="subst">&#123;message[<span class="string">&#x27;payload&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">				<span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_device_manager().add_remote_device(<span class="string">&#x27;127.0.0.1:6666&#x27;</span>).attach(<span class="string">&#x27;com.example.android&#x27;</span>)</span><br><span class="line">script = process.create_script(jsCode)</span><br><span class="line">script.on(<span class="string">&quot;message&quot;</span>,message)</span><br><span class="line">script.load()</span><br><span class="line"><span class="built_in">input</span>()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用无线 <code>adb</code> 连接，则需要改变对应的 <code>IP</code> 为 <a href="https://github.com/RikkaApps/WADB">WADB</a> 显示的 <code>IP</code> 即可。</p>
</blockquote>
<h1 id="Frida-Hook-Java"><a href="#Frida-Hook-Java" class="headerlink" title="Frida Hook Java"></a>Frida Hook Java</h1><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="Java-perform"><a href="#Java-perform" class="headerlink" title="Java.perform"></a>Java.perform</h3><p>该方法相当于 C 语言的 <code>main()</code> 函数，Java 层的 Hook 都是从 <code>Java.perform</code> 开始的。具体用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//在这里面写Hook的代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Java-choose"><a href="#Java-choose" class="headerlink" title="Java.choose"></a>Java.choose</h3><p>用于查找堆中指定类的实例。获得实例后可以调用实例的函数。具体用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.example.android.Dog&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//onMatch回调会在找到类的实例后调用，也就是说内存中有多少实例，就会调用多少次</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//onComplete回调会在所有onMatch完成后调用</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Frida Hook Start.&quot;</span>);</span><br><span class="line">    <span class="comment">// Hook 对象</span></span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.example.android.Dog&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">instance</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hook 对象 <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(instance)&#125;</span>`</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hook 对象 name: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(instance.name.value)&#125;</span>`</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hook 对象 onComplete&quot;</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Java-available"><a href="#Java-available" class="headerlink" title="Java.available"></a>Java.available</h3><p>确认当前进程的 java 虚拟机是否已经启动，虚拟机包括 Dalbik 或者 ART 等。虚拟机没有启动的情况下不要唤醒其他 java 的属性或者方法。返回值是一个 <code>boolean</code> 。</p>
<h3 id="Java-enumerateLoadedClasses"><a href="#Java-enumerateLoadedClasses" class="headerlink" title="Java.enumerateLoadedClasses"></a>Java.enumerateLoadedClasses</h3><p>列出当前已经加载的类，用回调函数处理。声明为：<code>Java.enumerateLoadedClasses(callbacks)</code> 。用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">enumerateLoadedClasses</span>(&#123;</span><br><span class="line">  <span class="attr">onMacth</span>: <span class="keyword">function</span> (<span class="params">className</span>) &#123;</span><br><span class="line">    <span class="comment">//className就是类的名称</span></span><br><span class="line">    <span class="comment">//找到加载的每个类的时候被调用，参数就是类的名字，这个参数可以传给java.use()来获得一个js类包</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//查找完毕所有类之后调用，主要用于扫尾工作</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Java-enumerateClassLoaders"><a href="#Java-enumerateClassLoaders" class="headerlink" title="Java.enumerateClassLoaders"></a>Java.enumerateClassLoaders</h3><p>主要用于列出 Java JVM 中存在的类加载器。声明为：<code>Java.enumerateClassLoaders(callbacks)</code> 。用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">enumerateClassLoaders</span>(&#123;</span><br><span class="line">  <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">loader</span>) &#123;</span><br><span class="line">    <span class="comment">//loader就是类加载器</span></span><br><span class="line">    <span class="comment">//每找到一个就回调一次onMatch方法</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//在所有类加载器找出之后回调</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Java-registerClass"><a href="#Java-registerClass" class="headerlink" title="Java.registerClass"></a>Java.registerClass</h3><p>用于注册一个类到内存，这个类可以是我们自己定义的，也就是说我们可以通过这个方式来自定义类加入到内存中，也可以是已经存在的类。声明为：<code>Java.registerClass(callbacks)</code> 。用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Java</span>.<span class="title function_">registerClass</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;com.example.android.Dog&quot;</span>, <span class="comment">//类的全限定名.必传</span></span><br><span class="line">  <span class="attr">superClass</span>: <span class="string">&quot;xxx&quot;</span>, <span class="comment">//父类的全限定类名，可选</span></span><br><span class="line">  <span class="attr">implements</span>: <span class="string">&quot;xxx&quot;</span>, <span class="comment">//该类实现的接口全限定名，可选</span></span><br><span class="line">  <span class="attr">fields</span>: &#123; 属性名: <span class="string">&quot;类型&quot;</span> &#125;, <span class="comment">//该类的属性集，可选</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;&#125;, <span class="comment">//该类的方法集，可选</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取目标进程的SomeBaseClass类</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">SomeBaseClass</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.SomeBaseClass&quot;</span>);</span><br><span class="line"><span class="comment">//获取目标进程的X509TrustManager类</span></span><br><span class="line"><span class="keyword">let</span> X509TrustManager = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;javax.net.ssl.X509TrustManager&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">MyWeirdTrustManager</span> = <span class="title class_">Java</span>.<span class="title function_">registerClass</span>(&#123;</span><br><span class="line">  <span class="comment">//注册一个类是进程中的MyWeirdTrustManager类</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;com.example.MyWeirdTrustManager&quot;</span>,</span><br><span class="line">  <span class="comment">//父类是SomeBaseClass类</span></span><br><span class="line">  <span class="attr">superClass</span>: <span class="title class_">SomeBaseClass</span>,</span><br><span class="line">  <span class="comment">//实现了MyWeirdTrustManager接口类</span></span><br><span class="line">  <span class="attr">implements</span>: [X509TrustManager],</span><br><span class="line">  <span class="comment">//类中的属性</span></span><br><span class="line">  <span class="attr">fields</span>: &#123;</span><br><span class="line">    <span class="attr">description</span>: <span class="string">&quot;java.lang.String&quot;</span>,</span><br><span class="line">    <span class="attr">limit</span>: <span class="string">&quot;int&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//定义的方法</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">//类的构造函数</span></span><br><span class="line">    <span class="attr">$init</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Constructor called&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//X509TrustManager接口中方法之一，该方法作用是检查客户端的证书</span></span><br><span class="line">    <span class="attr">checkClientTrusted</span>: <span class="keyword">function</span> (<span class="params">chain, authType</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;checkClientTrusted&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//该方法检查服务器的证书，不信任时。在这里通过自己实现该方法，可以使之信任我们指定的任何证书。在实现该方法时，也可以简单的不做任何处理，即一个空的函数体，由于不会抛出异常，它就会信任任何证书。</span></span><br><span class="line">    <span class="attr">checkServerTrusted</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//返回值类型</span></span><br><span class="line">        <span class="attr">returnType</span>: <span class="string">&quot;void&quot;</span>,</span><br><span class="line">        <span class="comment">//参数列表</span></span><br><span class="line">        <span class="attr">argumentTypes</span>: [</span><br><span class="line">          <span class="string">&quot;[Ljava.security.cert.X509Certificate;&quot;</span>,</span><br><span class="line">          <span class="string">&quot;java.lang.String&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">//实现方法</span></span><br><span class="line">        <span class="attr">implementation</span>: <span class="keyword">function</span> (<span class="params">chain, authType</span>) &#123;</span><br><span class="line">          <span class="comment">//输出</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;checkServerTrusted A&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">returnType</span>: <span class="string">&quot;java.util.List&quot;</span>,</span><br><span class="line">        <span class="attr">argumentTypes</span>: [</span><br><span class="line">          <span class="string">&quot;[Ljava.security.cert.X509Certificate;&quot;</span>,</span><br><span class="line">          <span class="string">&quot;java.lang.String&quot;</span>,</span><br><span class="line">          <span class="string">&quot;java.lang.String&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">implementation</span>: <span class="keyword">function</span> (<span class="params">chain, authType, host</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;checkServerTrusted B&quot;</span>);</span><br><span class="line">          <span class="comment">//返回null会信任所有证书</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">//　返回受信任的X509证书数组。</span></span><br><span class="line">    <span class="attr">getAcceptedIssuers</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getAcceptedIssuers&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Java-use"><a href="#Java-use" class="headerlink" title="Java.use"></a>Java.use</h3><p>在 Frida 中通过 <code>Java.use(className)</code> 来加载类，相当于 Java 的 <code>Class.forName()</code> 。用法如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载String类</span></span><br><span class="line"><span class="keyword">let</span> jString = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>加载类后，可以使用 <code>$new()</code> 来创建一个对象，例如创建一个 <code>String</code> 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jStringClass = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> jString = jStringClass.$new(<span class="string">&quot;字符串&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Java-array"><a href="#Java-array" class="headerlink" title="Java.array"></a>Java.array</h3><p>通过 <code>Java.array()</code> 可以在 Frida 中创建任意类型的数组。用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&quot;type&quot;</span>, [value1, value2, value3]);</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标准写法：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//标准写法：</span></span><br><span class="line">    <span class="keyword">let</span> myCharArr = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&quot;char&quot;</span>, [<span class="string">&quot;H&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;o&quot;</span>]);</span><br><span class="line">    <span class="keyword">let</span> myStringArr = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&quot;Ljava.lang.String;&quot;</span>, [</span><br><span class="line">      <span class="string">&quot;W&quot;</span>,</span><br><span class="line">      <span class="string">&quot;o&quot;</span>,</span><br><span class="line">      <span class="string">&quot;r&quot;</span>,</span><br><span class="line">      <span class="string">&quot;l&quot;</span>,</span><br><span class="line">      <span class="string">&quot;d&quot;</span>,</span><br><span class="line">    ]);</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">ArrayClass</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.util.Arrays&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ArrayClass</span>.<span class="title function_">toString</span>(myCharArr));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ArrayClass</span>.<span class="title function_">toString</span>(myStringArr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偷懒写法</span></span><br><span class="line">    <span class="keyword">let</span> charArr = [<span class="string">&quot;你&quot;</span>, <span class="string">&quot;好&quot;</span>, <span class="string">&quot;!&quot;</span>];</span><br><span class="line">    <span class="keyword">let</span> strArr = [<span class="string">&quot;你&quot;</span>, <span class="string">&quot;好&quot;</span>, <span class="string">&quot;!&quot;</span>];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ArrayClass</span>.<span class="title function_">toString</span>(charArr));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ArrayClass</span>.<span class="title function_">toString</span>(strArr));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Java-cast"><a href="#Java-cast" class="headerlink" title="Java.cast"></a>Java.cast</h3><p>在 Frida 中使用 <code>Java.cast()</code> 来强转类型。例如我想获取某个对象的 <code>Class</code> ，那么就可以如下写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> clazz = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Class&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> cls = <span class="title class_">Java</span>.<span class="title function_">cast</span>(obj.<span class="title function_">getClass</span>(), clazz); <span class="comment">//先获取obj的Class，然后再强转成Class类型。</span></span><br></pre></td></tr></table></figure>

<h3 id="Frida-中数据类型定义"><a href="#Frida-中数据类型定义" class="headerlink" title="Frida 中数据类型定义"></a>Frida 中数据类型定义</h3><p><strong>基本数据类型：</strong></p>
<table>
<thead>
<tr>
<th>Frida 中的基本类型全名</th>
<th>Frida 中的基本类型缩写(定义数组时使用)</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Z</td>
</tr>
<tr>
<td>byte</td>
<td>B</td>
</tr>
<tr>
<td>char</td>
<td>C</td>
</tr>
<tr>
<td>double</td>
<td>D</td>
</tr>
<tr>
<td>float</td>
<td>F</td>
</tr>
<tr>
<td>int</td>
<td>I</td>
</tr>
<tr>
<td>long</td>
<td>J</td>
</tr>
<tr>
<td>short</td>
<td>S</td>
</tr>
</tbody></table>
<p><strong>数组类型</strong></p>
<p>在 Frida 中用 <code>[</code> 表示数组，和 java 中的的表示方法一致。</p>
<p>例如是 <code>int</code> 类型的数组，写法为：<code>[I</code> ，如果是 <code>String</code> 类型的数组，则写法为:<code>[java.lang.String;</code> 。</p>
<h3 id="反射调用"><a href="#反射调用" class="headerlink" title="反射调用"></a>反射调用</h3><p>反射调用效率比较低，一般情况下不要使用。</p>
<p><strong>获取方法及使用。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> clazz = <span class="title class_">Java</span>.<span class="title function_">use</span>(className);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造方法</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Constructor</span>  = jString.<span class="property">class</span>.<span class="title function_">getConstructor</span>([<span class="title class_">Type</span>.<span class="property">class</span>, <span class="title class_">Type</span>.<span class="property">class</span>...]);</span><br><span class="line"><span class="comment">// 设置访问属性</span></span><br><span class="line"><span class="title class_">Constructor</span>.<span class="title function_">setAccessible</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 调用构造方法</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Constructor</span>.<span class="title function_">newInstance</span>([<span class="title class_">Type</span>.<span class="property">obj</span>, <span class="title class_">Type</span>.<span class="property">obj</span>...]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取该类的所有公共方法(包含父类的)，得到的是一个数组</span></span><br><span class="line"><span class="keyword">let</span> methods = jString.<span class="property">class</span>.<span class="title function_">getMethods</span>();</span><br><span class="line"><span class="comment">//获取该类所有的私有方法(不包含父类)，得到的是一个数组</span></span><br><span class="line"><span class="keyword">let</span> methods = jString.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过名称获取该类的公共方法</span></span><br><span class="line"><span class="keyword">let</span> method = jString.<span class="property">class</span>.<span class="title function_">getMethod</span>(<span class="string">&quot;methodName&quot;</span>, [<span class="title class_">Type</span>.<span class="property">class</span>, <span class="title class_">Type</span>.<span class="property">class</span>...])</span><br><span class="line"><span class="comment">// 设置访问属性</span></span><br><span class="line">method.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">method.<span class="title function_">invoke</span>(obj, [<span class="title class_">Type</span>.<span class="property">obj</span>, <span class="title class_">Type</span>.<span class="property">obj</span>...]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过名称获取该类的私有方法</span></span><br><span class="line"><span class="keyword">let</span> method = jString.<span class="property">class</span>.<span class="title function_">getDeclaredMethod</span>(<span class="string">&quot;methodName&quot;</span>, [<span class="title class_">Type</span>.<span class="property">class</span>, <span class="title class_">Type</span>.<span class="property">class</span>...])</span><br><span class="line"><span class="comment">// 设置访问属性</span></span><br><span class="line">method.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">method.<span class="title function_">invoke</span>(obj, [<span class="title class_">Type</span>.<span class="property">obj</span>, <span class="title class_">Type</span>.<span class="property">obj</span>...]);</span><br></pre></td></tr></table></figure>

<p><strong>获取属性值和设置属性值。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jString = <span class="title class_">Java</span>.<span class="title function_">use</span>(className);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取该类的所有公共属性(包含父类的)，得到的是一个数组</span></span><br><span class="line"><span class="keyword">let</span> fields = jString.<span class="property">class</span>.<span class="title function_">getFields</span>();</span><br><span class="line"><span class="comment">//获取该类所有的私有属性(不包含父类)，得到的是一个数组</span></span><br><span class="line"><span class="keyword">let</span> fields = jString.<span class="property">class</span>.<span class="title function_">getDeclaredFields</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过名称获取该类的公共属性</span></span><br><span class="line"><span class="keyword">let</span> field = jString.<span class="property">class</span>.<span class="title function_">getField</span>(fieldName);</span><br><span class="line"></span><br><span class="line">field.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">let</span> field = nameField.<span class="title function_">get</span>(obj);</span><br><span class="line">field.<span class="title function_">set</span>(user, value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过名称获取该类的私有属性</span></span><br><span class="line"><span class="keyword">let</span> field = jString.<span class="property">class</span>.<span class="title function_">getDeclaredField</span>(fieldName);</span><br><span class="line">field.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">let</span> field = nameField.<span class="title function_">get</span>(obj);</span><br><span class="line">field.<span class="title function_">set</span>(user, value);</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Frida Hook Start.&quot;</span>);</span><br><span class="line">    <span class="comment">// 实例化对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Dog</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.Dog&quot;</span>);</span><br><span class="line">    <span class="comment">// 反射获取所有的方法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Methods</span> = <span class="title class_">Dog</span>.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> method <span class="keyword">of</span> <span class="title class_">Methods</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Dog DeclaredMethods: &quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(method.<span class="title function_">toString</span>()));</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;--------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">String</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Integer</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Integer&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取 int.class , 目前只找到这种方法，后续如果有更好的方法再进行更新</span></span><br><span class="line">    <span class="keyword">let</span> int = <span class="title class_">Integer</span>.<span class="property">class</span>.<span class="title function_">getField</span>(<span class="string">&quot;TYPE&quot;</span>).<span class="title function_">get</span>(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Constructor</span> = <span class="title class_">Dog</span>.<span class="property">class</span>.<span class="title function_">getConstructor</span>([<span class="title class_">String</span>.<span class="property">class</span>, int]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title class_">Constructor</span>));</span><br><span class="line">    <span class="keyword">let</span> dog = <span class="title class_">Constructor</span>.<span class="title function_">newInstance</span>([<span class="title class_">String</span>.$new(<span class="string">&quot;小白&quot;</span>), <span class="title class_">Integer</span>.$new(<span class="number">2</span>)]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射调用 sleep 方法</span></span><br><span class="line">    <span class="keyword">let</span> sleep = <span class="title class_">Dog</span>.<span class="property">class</span>.<span class="title function_">getDeclaredMethod</span>(<span class="string">&quot;sleep&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    sleep.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line">    sleep.<span class="title function_">invoke</span>(dog, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> _sleep = <span class="title class_">Dog</span>.<span class="property">class</span>.<span class="title function_">getDeclaredMethod</span>(<span class="string">&quot;sleep&quot;</span>, [<span class="title class_">String</span>.<span class="property">class</span>]);</span><br><span class="line">    _sleep.<span class="title function_">invoke</span>(dog, [<span class="title class_">String</span>.$new(<span class="string">&quot;狗窝&quot;</span>)]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射获取字段</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> fields = <span class="title class_">Dog</span>.<span class="property">class</span>.<span class="title function_">getDeclaredFields</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> field <span class="keyword">of</span> fields) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Filed: &quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(field.<span class="title function_">toString</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;============================================&quot;</span>);</span><br><span class="line">    <span class="comment">// 静态字段</span></span><br><span class="line">    <span class="keyword">let</span> reflect_TAG = <span class="title class_">Dog</span>.<span class="property">class</span>.<span class="title function_">getDeclaredField</span>(<span class="string">&quot;TAG&quot;</span>);</span><br><span class="line">    reflect_TAG.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;TAG: &quot;</span> + reflect_TAG.<span class="title function_">get</span>(<span class="literal">null</span>));</span><br><span class="line">    reflect_TAG.<span class="title function_">set</span>(<span class="literal">null</span>, <span class="string">&quot;HOOK OK&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;TAG: &quot;</span> + reflect_TAG.<span class="title function_">get</span>(<span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通字段</span></span><br><span class="line">    <span class="keyword">let</span> reflect_name = <span class="title class_">Dog</span>.<span class="property">class</span>.<span class="title function_">getField</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    reflect_name.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Animal</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.Animal&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name: &quot;</span> + reflect_name.<span class="title function_">get</span>(dog));</span><br><span class="line">    reflect_name.<span class="title function_">set</span>(dog, <span class="string">&quot;小黑&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name: &quot;</span> + reflect_name.<span class="title function_">get</span>(dog));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Frida Hook Start.&quot;</span>);</span><br><span class="line">    <span class="comment">// 实例化对象</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Dog</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.Dog&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> dog = <span class="title class_">Dog</span>.$new(<span class="string">&quot;小白&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;实例化对象&quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(dog));</span><br><span class="line">    dog.<span class="title function_">eat</span>(<span class="string">&quot;狗粮&quot;</span>);</span><br><span class="line">    dog.<span class="title function_">sleep</span>();</span><br><span class="line">    dog.<span class="title function_">sleep</span>(<span class="string">&quot;狗窝&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h2 id="Hook-操作"><a href="#Hook-操作" class="headerlink" title="Hook 操作"></a>Hook 操作</h2><h3 id="hook-普通方法"><a href="#hook-普通方法" class="headerlink" title="hook 普通方法"></a>hook 普通方法</h3><p>直接使用 <code>类.方法名.implementation =function()&#123;&#125;</code> 来对一个方法进行 Hook 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Frida Hook Start.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">MainActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity&quot;</span>);</span><br><span class="line">    <span class="comment">// hook 普通方法</span></span><br><span class="line">    <span class="title class_">MainActivity</span>.<span class="property">add</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">a: number, b: number</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`add params a: <span class="subst">$&#123;a&#125;</span>, b: <span class="subst">$&#123;b&#125;</span>`</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">        <span class="string">`add params arguments[0]: <span class="subst">$&#123;<span class="variable language_">arguments</span>[<span class="number">0</span>]&#125;</span>, arguments[1]: <span class="subst">$&#123;<span class="variable language_">arguments</span>[<span class="number">1</span>]&#125;</span>`</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="comment">//修改返回值</span></span><br><span class="line">      <span class="keyword">return</span> a * <span class="number">2</span> + b * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-重载方法"><a href="#Hook-重载方法" class="headerlink" title="Hook 重载方法"></a>Hook 重载方法</h3><p>使用 <code>类.方法名.overload(参数).implementation =function()&#123;&#125;</code> 进行 Hook ，其中参数为重载的类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Frida Hook Start.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Dog</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.Dog&quot;</span>);</span><br><span class="line">    <span class="comment">// Hook 重载方法</span></span><br><span class="line">    <span class="title class_">Dog</span>.<span class="property">sleep</span>.<span class="title function_">overload</span>().<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook 重载方法 sleep .&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title class_">Dog</span>.<span class="property">sleep</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.String&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">      str: string</span></span><br><span class="line"><span class="params">    </span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook 重载方法 sleep(String) &quot;</span> + str);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-构造方法"><a href="#Hook-构造方法" class="headerlink" title="Hook 构造方法"></a>Hook 构造方法</h3><p>如果没有重载，直接使用 <code>类.$init.implementation =function()&#123;&#125;</code> 进行 Hook 。</p>
<p>如果存在重载，则使用 <code>类.$init.overload(参数).implementation =function()&#123;&#125;</code> 进行 Hook 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Frida Hook Start.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Dog</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.Dog&quot;</span>);</span><br><span class="line">    <span class="comment">// Hook 构造方法</span></span><br><span class="line">    <span class="title class_">Dog</span>.<span class="property">$init</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">name: string, age: number</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">        <span class="string">&quot;hook Dog 构造函数，原始参数为 name : &quot;</span> + name + <span class="string">&quot;; age: &quot;</span> + age</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// 修改参数</span></span><br><span class="line">      <span class="variable language_">this</span>.$init(<span class="string">&quot;土狗&quot;</span>, <span class="number">10</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">        <span class="string">&quot;hook Dog 构造函数，修改参数为 name : &quot;</span> +</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">name</span>.<span class="property">value</span> +</span><br><span class="line">          <span class="string">&quot;; age: &quot;</span> +</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">age</span>.<span class="property">value</span></span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-成员变量"><a href="#Hook-成员变量" class="headerlink" title="Hook 成员变量"></a>Hook 成员变量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Frida Hook Start.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">MainActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity&quot;</span>);</span><br><span class="line">    <span class="comment">// Hook 静态成员，直接通过类获取静态成员变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable constant_">TAG</span> = <span class="title class_">MainActivity</span>.<span class="property">TAG</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;static value TAG:&quot;</span> + <span class="variable constant_">TAG</span>.<span class="property">value</span>);</span><br><span class="line">    <span class="comment">// 修改静态成员</span></span><br><span class="line">    <span class="variable constant_">TAG</span>.<span class="property">value</span> = <span class="string">&quot;HOOK OK&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook 普通成员</span></span><br><span class="line">    <span class="title class_">MainActivity</span>.<span class="property">onCreate</span>.<span class="title function_">overload</span>(<span class="string">&quot;android.os.Bundle&quot;</span>).<span class="property">implementation</span> =</span><br><span class="line">      <span class="keyword">function</span> (<span class="params">bundle: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">        <span class="comment">// 普通成员变量只能通过实例对象获取</span></span><br><span class="line">        <span class="comment">// 当对象的成员变量和成员方法名重复时,成员属性前加 `_` 进行区分</span></span><br><span class="line">        <span class="keyword">let</span> add = <span class="variable language_">this</span>.<span class="property">_add</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;add value : &quot;</span> + add.<span class="property">value</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;static value TAG:&quot;</span> + <span class="variable constant_">TAG</span>.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">onCreate</span>(bundle);</span><br><span class="line">        add.<span class="property">value</span> = <span class="number">11</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-内部类"><a href="#Hook-内部类" class="headerlink" title="Hook 内部类"></a>Hook 内部类</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Frida Hook Start.&quot;</span>);</span><br><span class="line">    <span class="comment">// Hook 内部类</span></span><br><span class="line">    <span class="keyword">let</span> innerClass = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity$innerClass&quot;</span>);</span><br><span class="line">    innerClass.<span class="property">setNum</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">num: number</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;innerClass setNum num value: &quot;</span> + num);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 修改 num</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setNum</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-匿名类"><a href="#Hook-匿名类" class="headerlink" title="Hook 匿名类"></a>Hook 匿名类</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Frida Hook Start.&quot;</span>);</span><br><span class="line">    <span class="comment">// Hook 内部类</span></span><br><span class="line">    <span class="keyword">let</span> cat = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity$1$1&quot;</span>);</span><br><span class="line">    cat.<span class="property">eat</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">food: string</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="title function_">getName</span>() + <span class="string">&quot; eat &quot;</span> + food);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">eat</span>(<span class="string">&quot;鱼&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> callback = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity$1$2&quot;</span>);</span><br><span class="line">    callback.<span class="property">finsh</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">msg: string</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback finsh: &quot;</span> + msg);</span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">finsh</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-参数为数组的方法"><a href="#Hook-参数为数组的方法" class="headerlink" title="Hook 参数为数组的方法"></a>Hook 参数为数组的方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Frida Hook Start.&quot;</span>);</span><br><span class="line">    <span class="comment">// Hook 参数为数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">MainActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> innerClass = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity$innerClass&quot;</span>);</span><br><span class="line">    <span class="title class_">MainActivity</span>.<span class="property">printArray</span>.<span class="title function_">overload</span>(</span><br><span class="line">      <span class="string">&quot;[Lcom.example.android.MainActivity$innerClass;&quot;</span></span><br><span class="line">    ).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arr: any</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">getNum</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 修改参数</span></span><br><span class="line">      <span class="keyword">let</span> a = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&quot;Lcom.example.android.MainActivity$innerClass;&quot;</span>, [</span><br><span class="line">        innerClass.$new(<span class="variable language_">this</span>, <span class="number">111</span>),</span><br><span class="line">        innerClass.$new(<span class="variable language_">this</span>, <span class="number">222</span>),</span><br><span class="line">        innerClass.$new(<span class="variable language_">this</span>, <span class="number">333</span>),</span><br><span class="line">      ]);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">printArray</span>(a);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="打印调用栈"><a href="#打印调用栈" class="headerlink" title="打印调用栈"></a>打印调用栈</h3><p>在逆向中我们可以通过打印调用栈获取关键方法的调用关系。相关代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">stackTraceHere</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.util.Log&quot;</span>).<span class="title function_">getStackTraceString</span>(</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Exception&quot;</span>).$new()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Frida Hook Start.&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">MainActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity&quot;</span>);</span><br><span class="line">    <span class="title class_">MainActivity</span>.<span class="property">add</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">a: number, b: number</span>) &#123;</span><br><span class="line">      <span class="comment">// 打印堆栈信息</span></span><br><span class="line">      <span class="keyword">let</span> stack = <span class="title function_">stackTraceHere</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(stack);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">add</span>(a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-指定类的所有方法"><a href="#Hook-指定类的所有方法" class="headerlink" title="Hook 指定类的所有方法"></a>Hook 指定类的所有方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 枚举所有的类</span></span><br><span class="line">    <span class="keyword">let</span> classList = <span class="title class_">Java</span>.<span class="title function_">enumerateLoadedClassesSync</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> className <span class="keyword">of</span> classList) &#123;</span><br><span class="line">      <span class="comment">// 2. 选择需要 Hook 的类</span></span><br><span class="line">      <span class="keyword">if</span> (className.<span class="title function_">indexOf</span>(<span class="string">&quot;com.example.android.Dog&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. 获取该类的所有方法</span></span><br><span class="line">        <span class="keyword">let</span> declaredMethods = <span class="title class_">Java</span>.<span class="title function_">use</span>(className).<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> method <span class="keyword">of</span> declaredMethods) &#123;</span><br><span class="line">          <span class="comment">// 4. 获取函数名</span></span><br><span class="line">          <span class="keyword">let</span> methodName = method.<span class="title function_">getName</span>();</span><br><span class="line">          <span class="keyword">let</span> hookClass = <span class="title class_">Java</span>.<span class="title function_">use</span>(className);</span><br><span class="line">          <span class="comment">// 5. 开始 hook</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> overloads_md <span class="keyword">of</span> hookClass[methodName].<span class="property">overloads</span>) &#123;</span><br><span class="line">            overloads_md.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">                  <span class="string">`<span class="subst">$&#123;methodName&#125;</span> -&gt; argType: [<span class="subst">$&#123;<span class="keyword">typeof</span> arg&#125;</span>] ;argValue: [<span class="subst">$&#123;arg&#125;</span>] .`</span></span><br><span class="line">                );</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="variable language_">this</span>[methodName].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-动态加载的-dex"><a href="#Hook-动态加载的-dex" class="headerlink" title="Hook 动态加载的 dex"></a>Hook 动态加载的 dex</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">enumerateClassLoaders</span>(&#123;</span><br><span class="line">      <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">loader</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">          <span class="string">`Java.classFactory.loader :<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(</span></span></span><br><span class="line"><span class="subst"><span class="string">            Java.classFactory.loader</span></span></span><br><span class="line"><span class="subst"><span class="string">          )&#125;</span>`</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 获取动态加载的类</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> className = <span class="string">&quot;com.example.Dynamic.Fibonacci&quot;</span>;</span><br><span class="line">          <span class="keyword">if</span> (loader.<span class="title function_">loadClass</span>(className)) &#123;</span><br><span class="line">            <span class="title class_">Java</span>.<span class="property">classFactory</span>.<span class="property">loader</span> = loader;</span><br><span class="line">            <span class="keyword">let</span> <span class="title class_">Fibonacci</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(className);</span><br><span class="line">            <span class="comment">// 调用 dex 中的方法</span></span><br><span class="line">            <span class="keyword">let</span> ret = <span class="title class_">Fibonacci</span>.<span class="title function_">fibonacci</span>(<span class="number">20</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ret: &quot;</span> + ret);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onComplete!!!&quot;</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-打印-non-ascii-和特殊字符"><a href="#Hook-打印-non-ascii-和特殊字符" class="headerlink" title="Hook 打印 non-ascii 和特殊字符"></a>Hook 打印 non-ascii 和特殊字符</h3><p>一些特殊字符和不可见字符, 可以先通过编码再解码的方式进行 hook 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ֏(<span class="type">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对上面的 <code>֏</code> , 直接用 <code>js</code> 编码, 在通过类名 <code>[js解码的方法名]</code> 进行 <code>implementation</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> <span class="title function_">x</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> targetClass = <span class="string">&quot;com.example.hooktest.MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> hookCls = <span class="title class_">Java</span>.<span class="title function_">use</span>(targetClass);</span><br><span class="line">  <span class="keyword">var</span> methods = hookCls.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> methods) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(methods[i].<span class="title function_">toString</span>());</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">      <span class="built_in">encodeURIComponent</span>(</span><br><span class="line">        methods[i].<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="regexp">/^.*?\.([^\s\.\(\)]+)\(.*?$/</span>, <span class="string">&quot;$1&quot;</span>)</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hookCls[<span class="built_in">decodeURIComponent</span>(<span class="string">&quot;%D6%8F&quot;</span>)].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;original call: fun(&quot;</span> + x + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">this</span>[<span class="built_in">decodeURIComponent</span>(<span class="string">&quot;%D6%8F&quot;</span>)](<span class="number">900</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="write-ups-2015"><a href="#write-ups-2015" class="headerlink" title="write-ups-2015"></a>write-ups-2015</h3><p>首先我们根据 Frida 官网给的<a href="https://github.com/ctfs/write-ups-2015/tree/master/seccon-quals-ctf-2015/binary/reverse-engineering-android-apk-1">测试用例</a>简单的熟悉一下 Frida 的使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取需要 hook 方法的类</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">MainActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(</span><br><span class="line">      <span class="string">&quot;com.example.seccon2015.rock_paper_scissors.MainActivity&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="title class_">MainActivity</span>.<span class="property">onClick</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">v: any</span>) &#123;</span><br><span class="line">      <span class="comment">// 调用原始函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">onClick</span>(v);</span><br><span class="line">      <span class="comment">// 原始函数调用完成后，修改相应的变量</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">m</span>.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">n</span>.<span class="property">value</span> = <span class="number">1</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cnt</span>.<span class="property">value</span> = <span class="number">999</span>;</span><br><span class="line">      <span class="comment">// 主动调用获取 flag</span></span><br><span class="line">      <span class="keyword">let</span> flag = <span class="string">`SECCON&#123;<span class="subst">$&#123;(<span class="number">1000</span> + <span class="variable language_">this</span>.calc()) * <span class="number">107</span>&#125;</span>&#125;`</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;flag: &quot;</span> + flag);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">TextView</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.widget.TextView&quot;</span>);</span><br><span class="line">    <span class="title class_">TextView</span>.<span class="property">setText</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.CharSequence&quot;</span>).<span class="property">implementation</span> =</span><br><span class="line">      <span class="keyword">function</span> (<span class="params">str: string</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过 setText 获取 flag</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">getId</span>().<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">toUpperCase</span>() == <span class="string">&quot;7F0C0052&quot;</span>) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setText : &quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setText</span>(str);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h1 id="Frida-Hook-so"><a href="#Frida-Hook-so" class="headerlink" title="Frida Hook so"></a>Frida Hook so</h1><h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="Process-enumerateModules"><a href="#Process-enumerateModules" class="headerlink" title="Process.enumerateModules"></a>Process.enumerateModules</h3><p>用于查看目标 module 是否被正常加载, 使用 <code>Process.enumerateModules()</code> 将当前加载的所有 so 文件打印出来。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> modules = <span class="title class_">Process</span>.<span class="title function_">enumerateModules</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> <span class="variable language_">module</span> <span class="keyword">of</span> modules) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">name</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;libcalc.so&quot;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">          <span class="string">`module name: <span class="subst">$&#123;<span class="variable language_">module</span>.name&#125;</span> ; base: <span class="subst">$&#123;<span class="variable language_">module</span>.base&#125;</span> ; path:<span class="subst">$&#123;<span class="variable language_">module</span>.path&#125;</span>`</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Module-findBaseAddress"><a href="#Module-findBaseAddress" class="headerlink" title="Module.findBaseAddress"></a>Module.findBaseAddress</h3><p>获取指定 so 文件的基地址。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> baseAddr = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;libcalc.so&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;libcalc.so baseAddr: &quot;</span>, baseAddr);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Module-findExportByName"><a href="#Module-findExportByName" class="headerlink" title="Module.findExportByName"></a>Module.findExportByName</h3><p>通过导出函数名获取对应的地址。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> calc = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(</span><br><span class="line">      <span class="string">&quot;libcalc.so&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Java_com_example_seccon2015_rock_1paper_1scissors_MainActivity_calc&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;calc addr: &quot;</span>, calc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h1 id="Frida-代码片段"><a href="#Frida-代码片段" class="headerlink" title="Frida 代码片段"></a>Frida 代码片段</h1><p>Hook StringBuilder and print data only from a specific class</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sbActivate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">StringBuilder</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.StringBuilder&quot;</span>);</span><br><span class="line">  <span class="title class_">StringBuilder</span>.<span class="property">toString</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="variable language_">this</span>.<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">if</span> (sbActivate) &#123;</span><br><span class="line">      <span class="keyword">let</span> tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (res !== <span class="literal">null</span>) &#123;</span><br><span class="line">        tmp = res.<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="string">&quot;/n&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> someclass = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;&lt;the specific class you are interested in&gt;&quot;</span>);</span><br><span class="line">  someclass.<span class="property">someMethod</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    sbActivate = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="variable language_">this</span>.<span class="title function_">someMethod</span>();</span><br><span class="line">    sbActivate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>byte[]这种 hook 输出的时候该怎么写呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">ByteString</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.android.okhttp.okio.ByteString&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> j = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;c.business.comm.j&quot;</span>);</span><br><span class="line">j.<span class="property">x</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="variable language_">this</span>.<span class="title function_">x</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;j.x:&quot;</span>, <span class="title class_">ByteString</span>.<span class="title function_">of</span>(result).<span class="title function_">hex</span>());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">j.<span class="property">a</span>.<span class="title function_">overload</span>(<span class="string">&quot;[B&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">bArr</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">a</span>(bArr);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;j.a:&quot;</span>, <span class="title class_">ByteString</span>.<span class="title function_">of</span>(bArr).<span class="title function_">hex</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>hook Androd 7 以上的 dlopen 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> android_dlopen_ext = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="literal">null</span>, <span class="string">&quot;android_dlopen_ext&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(android_dlopen_ext);</span><br><span class="line"><span class="keyword">if</span> (android_dlopen_ext != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(android_dlopen_ext, &#123;</span><br><span class="line">    <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> soName = args[<span class="number">0</span>].<span class="title function_">readCString</span>();</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(soName);</span><br><span class="line">      <span class="keyword">if</span> (soName.<span class="title function_">indexOf</span>(<span class="string">&quot;**.so&quot;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;------load **----------&quot;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">hook</span> = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">hook</span>) &#123;</span><br><span class="line">        <span class="comment">//TODO hookso</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>frida 如何注入 dex？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">openClassFile</span>(dexPath).<span class="title function_">load</span>();</span><br></pre></td></tr></table></figure>

<p>在系统里装上这个这个 npm 包，可以在任意工程获得 frida 的代码提示、补全和 API 查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -g @types/frida-gum</span><br></pre></td></tr></table></figure>

<p>参考:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://kevinspider.github.io/fridahookjava/</span><br><span class="line">https://zyzling.gitee.io/2020/05/12/Frida%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>frida</category>
      </categories>
      <tags>
        <tag>frida</tag>
      </tags>
  </entry>
  <entry>
    <title>learn-html</title>
    <url>/2023/09/22/learn-html/</url>
    <content><![CDATA[<p>占坑： <a href="https://www.runoob.com/html/html-tutorial.html">https://www.runoob.com/html/html-tutorial.html</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>learn-javascript</title>
    <url>/2023/09/22/learn-javascript/</url>
    <content><![CDATA[<p>占坑 <a href="https://zh.javascript.info/first-steps">https://zh.javascript.info/first-steps</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>learn-rust</title>
    <url>/2023/09/22/learn-rust/</url>
    <content><![CDATA[<h1 id="Rust-环境搭建"><a href="#Rust-环境搭建" class="headerlink" title="Rust 环境搭建"></a>Rust 环境搭建</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Windows-平台"><a href="#Windows-平台" class="headerlink" title="Windows 平台"></a>Windows 平台</h3><ol>
<li>首先需要安装 <a href="https://visualstudio.microsoft.com/zh-hans/downloads/">Visual C++ 生成工具</a> 。</li>
<li>然后下载并运行 <a href="https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-msvc/rustup-init.exe">rustup‑init.exe</a> ，一路默认即可。</li>
</ol>
<p>所有工具都安装到 <code>%USERPROFILE%\.cargo\bin</code> 目录， 并且您能够在这里找到 Rust 工具链，包括 rustc、cargo 及 rustup。</p>
<p>安装完成后，运行 <code>rustc --version</code> 检查安装是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rustc --version</span><br><span class="line">rustc 1.59.0 (9d1b2106e 2022-02-23)</span><br></pre></td></tr></table></figure>

<h3 id="编译运行-Rust-程序"><a href="#编译运行-Rust-程序" class="headerlink" title="编译运行 Rust 程序"></a>编译运行 Rust 程序</h3><p>创建一个 hello_world 目录，并在其中创建 <code>main.rs</code> 文件，其中的内容如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">mian</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用 rustc 编译，并运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rustc main.rs</span><br><span class="line">$ ./main.exe</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<h2 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h2><p>Rust 开发工具可以使用 <a href="https://code.visualstudio.com/">VSCode</a> 以及下列插件。</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">rust-analyzer</a> : Rust language support for Visual Studio Code.</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml">Even Better</a> : TOML，支持 .toml 文件完整特性。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens">Error Lens</a> : 更好的获得错误展示。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=zhuangtongfa.Material-theme">One Dark Pro</a> : 非常好看的 VSCode 主题。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB</a> : Debugger 程序。</li>
</ul>
<h2 id="cargo"><a href="#cargo" class="headerlink" title="cargo"></a>cargo</h2><p>cargo 是 Rust 语言的包管理工具，提供了一系列的工具，从项目的建立、构建到测试、运行直至部署，为 Rust 项目的管理提供尽可能完整的手段。</p>
<h3 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h3><p>可以使用使用 <code>cargo new</code> 创建一个项目，默认参数 <code>--bin</code> 为应用程序类型的项目，也可以使用 <code>--lib</code> 创建一个依赖库项目。</p>
<p>创建一个应用程序项目。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo new hello          <span class="comment"># 创建一个应用程序项目。</span></span><br></pre></td></tr></table></figure>

<p>创建一个依赖库项目。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo new hellolib --lib    <span class="comment"># 创建一个依赖库项目。</span></span><br></pre></td></tr></table></figure>

<h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><ol>
<li>cargo run</li>
</ol>
<p>进入源码的根目录，直接运行 <code>cargo run</code> 即可自动编译运行。</p>
<ol start="2">
<li>手动编译运行</li>
</ol>
<p>进入源码的根目录，首先运行 <code>cargo build</code> 编译项目，然后运行编译好的应用。</p>
<p>以上默认编译为 debug 版，可以使用 <code>--release</code> 命令编译 release 版。</p>
<h3 id="cargo-check"><a href="#cargo-check" class="headerlink" title="cargo check"></a>cargo check</h3><p><code>cargo check</code> 是我们在代码开发过程中最常用的命令，它的作用很简单：快速的检查一下代码能否编译通过。因此该命令速度会非常快，能节省大量的编译时间。</p>
<h3 id="Cargo-toml-和-Cargo-lock"><a href="#Cargo-toml-和-Cargo-lock" class="headerlink" title="Cargo.toml 和 Cargo.lock"></a>Cargo.toml 和 Cargo.lock</h3><ul>
<li><p><code>Cargo.toml</code> 是 cargo 特有的项目数据描述文件。它存储了项目的所有元配置信息，如果 Rust 开发者希望 Rust 项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建 <code>Cargo.toml</code>。</p>
</li>
<li><p><code>Cargo.lock</code> 文件是 cargo 工具根据同一项目的 toml 文件生成的项目依赖详细清单，因此我们一般不用修改它，只需要对着 <code>Cargo.toml</code> 文件撸就行了。</p>
</li>
</ul>
<h4 id="Cargo-toml-文件"><a href="#Cargo-toml-文件" class="headerlink" title="Cargo.toml 文件"></a>Cargo.toml 文件</h4><ol>
<li>package 配置段落</li>
</ol>
<p>package 中记录了项目的描述信息，典型的如下：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br></pre></td></tr></table></figure>

<p>name 字段定义了项目名称，version 字段定义当前版本，新项目默认是 0.1.0，edition 字段定义了我们使用的 Rust 大版本。</p>
<ol start="2">
<li>dependencies 项目依赖</li>
</ol>
<p>使用 cargo 工具的最大优势就在于，能够对该项目的各种依赖项进行方便、统一和灵活的管理。</p>
<p>在 <code>Cargo.toml</code> 中，主要通过各种依赖段落来描述该项目的各种依赖项：</p>
<ul>
<li>基于 Rust 官方仓库 <code>crates.io</code>，通过版本说明来描述</li>
<li>基于项目源代码的 git 仓库地址，通过 URL 来描述</li>
<li>基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述</li>
</ul>
<p>这三种形式具体写法如下：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.3&quot;</span></span><br><span class="line"><span class="attr">hammer</span> = &#123; version = <span class="string">&quot;0.5.0&quot;</span>&#125;</span><br><span class="line"><span class="attr">color</span> = &#123; git = <span class="string">&quot;https://github.com/bjz/color-rs&quot;</span> &#125;</span><br><span class="line"><span class="attr">geometry</span> = &#123; path = <span class="string">&quot;crates/geometry&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="标准的-Package-目录结构"><a href="#标准的-Package-目录结构" class="headerlink" title="标准的 Package 目录结构"></a>标准的 Package 目录结构</h3><p>一个典型的 Package 目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src/</span><br><span class="line">│   ├── lib.rs</span><br><span class="line">│   ├── main.rs</span><br><span class="line">│   └── bin/</span><br><span class="line">│       ├── named-executable.rs</span><br><span class="line">│       ├── another-executable.rs</span><br><span class="line">│       └── multi-file-executable/</span><br><span class="line">│           ├── main.rs</span><br><span class="line">│           └── some_module.rs</span><br><span class="line">├── benches/</span><br><span class="line">│   ├── large-input.rs</span><br><span class="line">│   └── multi-file-bench/</span><br><span class="line">│       ├── main.rs</span><br><span class="line">│       └── bench_module.rs</span><br><span class="line">├── examples/</span><br><span class="line">│   ├── simple.rs</span><br><span class="line">│   └── multi-file-example/</span><br><span class="line">│       ├── main.rs</span><br><span class="line">│       └── ex_module.rs</span><br><span class="line">└── tests/</span><br><span class="line">    ├── some-integration-tests.rs</span><br><span class="line">    └── multi-file-test/</span><br><span class="line">        ├── main.rs</span><br><span class="line">        └── test_module.rs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这也是 Cargo 推荐的目录结构，解释如下：</p>
<ul>
<li><code>Cargo.toml</code> 和 <code>Cargo.lock</code> 保存在 package 根目录下</li>
<li>源代码放在 src 目录下</li>
<li>默认的 lib 包根是 <code>src/lib.rs</code></li>
<li>默认的二进制包根是 <code>src/main.rs</code></li>
<li>其它二进制包根放在 <code>src/bin/</code> 目录下</li>
<li>基准测试 benchmark 放在 benches 目录下</li>
<li>示例代码放在 examples 目录下</li>
<li>集成测试代码放在 tests 目录下</li>
</ul>
<h1 id="Rust-基础入门"><a href="#Rust-基础入门" class="headerlink" title="Rust 基础入门"></a>Rust 基础入门</h1><h2 id="变量绑定与解构"><a href="#变量绑定与解构" class="headerlink" title="变量绑定与解构"></a>变量绑定与解构</h2><h3 id="变量绑定"><a href="#变量绑定" class="headerlink" title="变量绑定"></a>变量绑定</h3><p>在 Rust 中，我们这样写： <code>let a = &quot;hello world&quot;</code> ，同时给这个过程起了另一个名字：变量绑定。</p>
<h3 id="变量可变性"><a href="#变量可变性" class="headerlink" title="变量可变性"></a>变量可变性</h3><p>Rust 的变量在默认情况下是不可变的。可以通过 mut 关键字让变量变为可变的。</p>
<h3 id="使用下划线开头忽略未使用的变量"><a href="#使用下划线开头忽略未使用的变量" class="headerlink" title="使用下划线开头忽略未使用的变量"></a>使用下划线开头忽略未使用的变量</h3><p>创建一个未使用的变量，Rust 通常会给你一个警告。如果希望 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头。</p>
<p>在函数头添加 <code>#[warn(unused_variables)]</code> 也可以忽略未使用的变量。</p>
<h3 id="变量解构"><a href="#变量解构" class="headerlink" title="变量解构"></a>变量解构</h3><p><code>let</code> 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (a, b) = (<span class="literal">true</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="解构式赋值"><a href="#解构式赋值" class="headerlink" title="解构式赋值"></a>解构式赋值</h3><p>在 Rust 1.59 版本后，我们可以在赋值语句的左式中使用元组、切片和结构体模式了。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解构式赋值</span></span><br><span class="line"><span class="keyword">let</span> (a, b, c, d, e);</span><br><span class="line"><span class="comment">// 对之前绑定的变量进行再赋值。</span></span><br><span class="line">(a, b) = (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">[c, .., d, _] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">Struct&#123;e, ..&#125; = Struct&#123;e:<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;, b = &#123;&#125;, c = &#123;&#125;, d = &#123;&#125;, e = &#123;&#125;.&quot;</span>, a, b, c, d, e);</span><br></pre></td></tr></table></figure>

<h3 id="变量和常量之间的差异"><a href="#变量和常量之间的差异" class="headerlink" title="变量和常量之间的差异"></a>变量和常量之间的差异</h3><ul>
<li>常量不允许使用 mut。常量不仅仅默认不可变，而且自始至终不可变，因为常量在编译完成后，已经确定它的值。</li>
<li>常量使用 const 关键字而不是 let 关键字来声明，并且值的类型必须标注。</li>
<li>在声明它的作用域之中，常量在整个程序生命周期中都有效。</li>
</ul>
<blockquote>
<p>Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词，另外对数字字面量可插入下划线以提高可读性。</p>
</blockquote>
<h3 id="变量遮蔽"><a href="#变量遮蔽" class="headerlink" title="变量遮蔽"></a>变量遮蔽</h3><p>Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的。</p>
<blockquote>
<p>常量是无法声明相同的名称。</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Struct</span> &#123;</span><br><span class="line">    e: <span class="type">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 通过 mut 关键字让变量变为可变的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;.&quot;</span>, x);</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;.&quot;</span>, x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用下划线作为变量名的开头告诉 Rust 不要警告未使用的变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">0</span>; <span class="comment">// #[allow(unused_variables)]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量解构</span></span><br><span class="line">    <span class="comment">// 解构元组</span></span><br><span class="line">    <span class="keyword">let</span> (a, b) = (<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;, b = &#123;:?&#125;&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解构式赋值</span></span><br><span class="line">    <span class="keyword">let</span> (a, b, c, d, e);</span><br><span class="line">    <span class="comment">// 对之前绑定的变量进行再赋值。</span></span><br><span class="line">    (a, b) = (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// .. 表示忽略 0 或多个，_ 表示忽略一个</span></span><br><span class="line">    [c, .., d, _] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    Struct&#123;e, ..&#125; = Struct&#123;e:<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;, b = &#123;&#125;, c = &#123;&#125;, d = &#123;&#125;, e = &#123;&#125;.&quot;</span>, a, b, c, d, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义常量，常量无法重复声明</span></span><br><span class="line">    <span class="keyword">const</span> ONE:<span class="type">u32</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of ONE is: &#123;&#125;&quot;</span>, ONE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量遮蔽</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spaces</span> = <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spaces</span> = spaces.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在内部作用域内，隐藏变量只在作用域内生效。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">spaces</span> = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;spaces = &#123;&#125;.&quot;</span>, spaces);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;spaces = &#123;&#125;.&quot;</span>, spaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>Rust 每个值都有其确切的数据类型，总的来说可以分为两类：基本类型和复合类型。</p>
<p>基本类型意味着它们往往是一个最小化原子类型，无法解构为其它类型，由以下组成：</p>
<ul>
<li>数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数</li>
<li>字符串：字符串字面量和字符串切片 <code>&amp;str</code></li>
<li>布尔类型： true 和 false</li>
<li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li>
<li>单元类型: 即 () ，其唯一的值也是 ()。</li>
</ul>
<h3 id="类型推导与标注"><a href="#类型推导与标注" class="headerlink" title="类型推导与标注"></a>类型推导与标注</h3><p>Rust 编译器可以根据变量的值和上下文中的使用方式来自动推导出变量的类型，但是在某些情况下，它无法推导出变量类型，需要手动去给予一个类型标注。</p>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>整数是没有小数部分的数字。下表显示了 Rust 中的内置的整数类型：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>有符号类型</th>
<th>无符号类型</th>
</tr>
</thead>
<tbody><tr>
<td>8 位</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16 位</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32 位</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>64 位</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>128-位</td>
<td>i128</td>
<td>u128</td>
</tr>
<tr>
<td>视架构而定</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody></table>
<p>整形字面量可以用下表的形式书写：</p>
<table>
<thead>
<tr>
<th>数字字面量</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>十进制</td>
<td>98_222</td>
</tr>
<tr>
<td>十六进制</td>
<td>0xff</td>
</tr>
<tr>
<td>八进制</td>
<td>0o77</td>
</tr>
<tr>
<td>二进制</td>
<td>0b1111_0000</td>
</tr>
<tr>
<td>字节 (仅限于 u8)</td>
<td>b’A’</td>
</tr>
</tbody></table>
<p>显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：</p>
<ul>
<li>使用 <code>wrapping_*</code> 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add</li>
<li>如果使用 <code>checked_*</code> 方法时发生溢出，则返回 None 值</li>
<li>使用 <code>overflowing_*</code> 方法返回该值和一个指示是否存在溢出的布尔值</li>
<li>使用 <code>saturating_*</code> 方法使值达到最小值或最大值</li>
</ul>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>浮点类型数字 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： f32 和 f64，分别为 32 位和 64 位大小。</p>
<p>使用浮点数需要遵守以下准则：</p>
<ul>
<li>避免在浮点数上测试相等性</li>
<li>当结果在数学上可能存在未定义时，需要格外的小心</li>
</ul>
<p>Rust 的浮点数类型使用 NaN (not a number)来处理数学上未定义的结果。</p>
<p>所有跟 NaN 交互的操作，都会返回一个 NaN，而且 NaN 不能用来比较。</p>
<h3 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h3><p>Rust 支持所有数字类型的基本数学运算：加法、减法、乘法、除法和取模运算。</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>Rust 的运算基本上和其他语言一样</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp; 位与</td>
<td>相同位置均为 1 时则为 1，否则为 0</td>
</tr>
<tr>
<td>| 位或</td>
<td>相同位置只要有 1 时则为 1，否则为 0</td>
</tr>
<tr>
<td>^ 异或</td>
<td>相同位置不相同则为 1，相同则为 0</td>
</tr>
<tr>
<td>! 位非</td>
<td>把位中的 0 和 1 相互取反，即 0 置为 1，1 置为 0</td>
</tr>
<tr>
<td>&lt;&lt; 左移</td>
<td>所有位向左移动指定位数，右位补零</td>
</tr>
<tr>
<td>&gt;&gt; 右移</td>
<td>所有位向右移动指定位数，左位补零</td>
</tr>
</tbody></table>
<h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p>Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 1..5，生成从 1 到 4 的连续数字，不包含 5 ；1..&#x3D;5，生成从 1 到 5 的连续数字，包含 5 。</p>
<p>序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。</p>
<h3 id="有理数和复数"><a href="#有理数和复数" class="headerlink" title="有理数和复数"></a>有理数和复数</h3><p>Rust 的标准库并未包含有理数和复数，需要引入第三方库 <a href="https://crates.io/crates/num">num</a>.</p>
<p>引入 num 库的方式：</p>
<ol>
<li>在 <code>Cargo.toml</code> 中的 <code>[dependencies]</code> 下添加一行 <code>num = &quot;0.4.0&quot;</code> 。</li>
<li>将 <code>src/main.rs</code> 文件中使用 <code>use num::complex::Complex;</code> 引入对应的库。</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 给 guess 变量一个显式的类型标注</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">guess</span>:<span class="type">i32</span> = <span class="string">&quot;42&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;not a number!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;guess = &#123;&#125;.&quot;</span>, guess);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">guess</span> = <span class="string">&quot;42&quot;</span>.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;not a number!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;guess = &#123;&#125;.&quot;</span>, guess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="所有权和借用"><a href="#所有权和借用" class="headerlink" title="所有权和借用"></a>所有权和借用</h2><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><h2 id="方法-Method"><a href="#方法-Method" class="headerlink" title="方法 Method"></a>方法 Method</h2><h2 id="泛型和特征"><a href="#泛型和特征" class="headerlink" title="泛型和特征"></a>泛型和特征</h2><h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h2 id="返回值和错误处理"><a href="#返回值和错误处理" class="headerlink" title="返回值和错误处理"></a>返回值和错误处理</h2><h2 id="包和模块"><a href="#包和模块" class="headerlink" title="包和模块"></a>包和模块</h2><ul>
<li>包（Packages）： Cargo 的一个功能，它允许你构建、测试和分享 crate。</li>
<li>Crates ：一个模块的树形结构，它形成了库或二进制项目。</li>
<li>模块（Modules）和 use： 允许你控制作用域和路径的私有性。</li>
<li>路径（path）：一个命名例如结构体、函数或模块等项的方式。</li>
</ul>
<p>crate 是一个二进制项或者库。包（package） 是提供一系列功能的一个或者多个 crate。一个包会包含有一个<code> Cargo.toml</code> 文件，阐述如何去构建这些 crate。</p>
<p>cargo new 命令创建包。</p>
<p><code>src/main.rs</code> 就是一个与包同名的二进制 crate 的 crate 根。如果包目录中包含 <code>src/lib.rs</code>，则包带有与其同名的库 crate，且 src&#x2F;lib.rs 是 crate 根。</p>
<p>模块 让我们可以将一个 crate 中的代码进行分组，以提高可读性与重用性。</p>
<p>cargo new –lib 创建模块。</p>
<p>路径有两种形式：</p>
<ul>
<li>绝对路径（absolute path）从 crate 根开始，以 crate 名或者字面值 crate 开头。</li>
<li>相对路径（relative path）从当前模块开始，以 self、super 或当前模块的标识符开头。</li>
</ul>
<h2 id="注释和文档"><a href="#注释和文档" class="headerlink" title="注释和文档"></a>注释和文档</h2><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><h1 id="Rust-高级进阶"><a href="#Rust-高级进阶" class="headerlink" title="Rust 高级进阶"></a>Rust 高级进阶</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h2 id="函数式编程：闭包、迭代器"><a href="#函数式编程：闭包、迭代器" class="headerlink" title="函数式编程：闭包、迭代器"></a>函数式编程：闭包、迭代器</h2><h2 id="深入类型"><a href="#深入类型" class="headerlink" title="深入类型"></a>深入类型</h2><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h2 id="循环引用与自引用"><a href="#循环引用与自引用" class="headerlink" title="循环引用与自引用"></a>循环引用与自引用</h2><h2 id="多线程并发编程"><a href="#多线程并发编程" class="headerlink" title="多线程并发编程"></a>多线程并发编程</h2><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h2 id="Unsafe-Rust"><a href="#Unsafe-Rust" class="headerlink" title="Unsafe Rust"></a>Unsafe Rust</h2><h2 id="Macro-宏编程"><a href="#Macro-宏编程" class="headerlink" title="Macro 宏编程"></a>Macro 宏编程</h2><h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><h2 id="async-x2F-wait-异步编程"><a href="#async-x2F-wait-异步编程" class="headerlink" title="async&#x2F;wait 异步编程"></a>async&#x2F;wait 异步编程</h2><h2 id="Tokio-使用指南"><a href="#Tokio-使用指南" class="headerlink" title="Tokio 使用指南"></a>Tokio 使用指南</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://course.rs/">Rust 语言圣经</a></p>
<p><a href="https://kaisery.github.io/">Rust 程序设计语言</a></p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>python使用记录</title>
    <url>/2019/12/11/learn-python/</url>
    <content><![CDATA[<p>本文章记录使用 python 过程中易忘的知识，方便自己查阅。</p>
<h2 id="设置-pypi-镜像"><a href="#设置-pypi-镜像" class="headerlink" title="设置 pypi 镜像"></a>设置 pypi 镜像</h2><h3 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</span><br></pre></td></tr></table></figure>

<p>注意，simple 不能少, 是 https 而不是 http</p>
<h3 id="设为默认"><a href="#设为默认" class="headerlink" title="设为默认"></a>设为默认</h3><p>升级 pip 到最新的版本 (&gt;&#x3D;10.0.0) 后进行配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pip -U</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清华源</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或：</span></span><br><span class="line"><span class="comment"># 阿里源</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"><span class="comment"># 腾讯源</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url http://mirrors.cloud.tencent.com/pypi/simple</span><br><span class="line"><span class="comment"># 豆瓣源</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>

<h2 id="conda-cheat-sheet"><a href="#conda-cheat-sheet" class="headerlink" title="conda cheat sheet"></a>conda cheat sheet</h2><h3 id="使用-TUNA-镜像源"><a href="#使用-TUNA-镜像源" class="headerlink" title="使用 TUNA 镜像源"></a>使用 TUNA 镜像源</h3><p>可以通过修改用户目录下的 <code>.condarc</code> 文件来使用 TUNA 镜像源。Windows 用户无法直接创建名为 <code>.condarc</code> 的文件，可先执行 <code>conda config --set show_channel_urls yes</code> 生成该文件之后再修改。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">defaults</span></span><br><span class="line"><span class="attr">show_channel_urls:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">default_channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span></span><br><span class="line"><span class="attr">custom_channels:</span></span><br><span class="line">  <span class="attr">conda-forge:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">msys2:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">bioconda:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">menpo:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">pytorch:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">pytorch-lts:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">simpleitk:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">deepmodeling:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/</span></span><br></pre></td></tr></table></figure>

<p>运行 <code>conda clean -i</code> 清除索引缓存，保证用的是镜像站提供的索引。</p>
<h3 id="管理-Conda"><a href="#管理-Conda" class="headerlink" title="管理 Conda"></a>管理 Conda</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda info                                        <span class="comment"># 验证 conda 是否已安装，检查版本</span></span><br><span class="line">conda update conda                                <span class="comment"># 更新 conda 包和环境管理器</span></span><br><span class="line">conda update --all                                <span class="comment"># 更新所有的包</span></span><br><span class="line">conda config --show channels                      <span class="comment"># 列出通道</span></span><br><span class="line">conda config --prepend channels conda-forge       <span class="comment"># 添加一个通道（最高优先级）</span></span><br><span class="line">conda config --append channels bioconda           <span class="comment"># 添加一个通道（最低优先级）</span></span><br><span class="line">conda config --get                                <span class="comment"># 从 .condarc 文件中获取所有键和值</span></span><br></pre></td></tr></table></figure>

<h3 id="管理环境"><a href="#管理环境" class="headerlink" title="管理环境"></a>管理环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda info --envs                                     <span class="comment"># 获取所有环境的列表</span></span><br><span class="line">conda info -e</span><br><span class="line">conda <span class="built_in">env</span> list</span><br><span class="line"></span><br><span class="line">conda create --name py35 python=3.5                   <span class="comment"># 创建一个名为 py35 的虚拟环境, 安装 python3.5</span></span><br><span class="line">conda create -n py35 python=3.5</span><br><span class="line">conda create --<span class="built_in">yes</span> -n py35 python=3.5</span><br><span class="line">conda create --<span class="built_in">clone</span> py35 --name py35-2               <span class="comment"># clone 一个已存在的环境</span></span><br><span class="line"></span><br><span class="line">conda list                                            <span class="comment"># 显示当前环境的所有包信息</span></span><br><span class="line">conda list ^z                                         <span class="comment"># 显示以 z 开始的包信息</span></span><br><span class="line">conda list --revisions                                <span class="comment"># 列出对当前环境的每个更改的历史</span></span><br><span class="line"></span><br><span class="line">conda install numpy pandas                            <span class="comment"># 使用conda install命令安装包，格式为conda install &#123;pkg1&#125; &#123;pkg2&#125;</span></span><br><span class="line">conda install --revision 2                            <span class="comment"># 将环境还原到先前的版本。</span></span><br><span class="line">conda uninstall pycaret                               <span class="comment"># 使用conda uninstall命令卸载包，格式为conda uninstall &#123;pkg&#125;</span></span><br><span class="line"></span><br><span class="line">conda list --explicit &gt; bio-env.txt                   <span class="comment"># 将环境保存到文本文件</span></span><br><span class="line">conda <span class="built_in">env</span> create --file bio-env.txt                   <span class="comment"># 从文本文件创建环境</span></span><br><span class="line">conda <span class="built_in">env</span> remove --name bio-env                       <span class="comment"># 删除一个环境以及其中的所有内容</span></span><br><span class="line">conda search PACKAGENAME                              <span class="comment"># 使用conda搜索包</span></span><br><span class="line"></span><br><span class="line">conda <span class="built_in">env</span> <span class="built_in">export</span> &gt; environment.yml                    <span class="comment"># 导出每个包及其依赖项（最大可再现性）。</span></span><br><span class="line">conda <span class="built_in">env</span> <span class="built_in">export</span> --from-history &gt; environment.yml     <span class="comment"># 只导出显式请求的包（增加可移植性）。</span></span><br><span class="line">conda <span class="built_in">env</span> create --name my_env2 --file environment.yml <span class="comment"># 从YAML文件导入环境。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h2><h3 id="pycharm-设置忽略大小写进行自动补齐"><a href="#pycharm-设置忽略大小写进行自动补齐" class="headerlink" title="pycharm 设置忽略大小写进行自动补齐"></a>pycharm 设置忽略大小写进行自动补齐</h3><p>进入下列设置</p>
<blockquote>
<p>settings -&gt; Editor -&gt; General -&gt; Code Completion</p>
</blockquote>
<p>将 <code>Match case</code> 不勾选就可以忽略大小写进行自动补齐了。</p>
<h3 id="pycharm-设置-python-代码模板"><a href="#pycharm-设置-python-代码模板" class="headerlink" title="pycharm 设置 python 代码模板"></a>pycharm 设置 python 代码模板</h3><p>设置 File &gt; Settings &gt; File and Code Template &gt; Python Script</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># File Name : $&#123;NAME&#125;</span></span><br><span class="line"><span class="comment"># Created by $&#123;USER&#125; on $DATE</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">&#x27;$&#123;USER&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>一些模板变量含义</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;PROJECT_NAME&#125;</span> - 当前Project名称;</span><br><span class="line"><span class="variable">$&#123;NAME&#125;</span> - 在创建文件的对话框中指定的文件名;</span><br><span class="line"><span class="variable">$&#123;USER&#125;</span> - 当前用户名;</span><br><span class="line"><span class="variable">$&#123;DATE&#125;</span> - 当前系统日期;</span><br><span class="line"><span class="variable">$&#123;TIME&#125;</span> - 当前系统时间;</span><br><span class="line"><span class="variable">$&#123;YEAR&#125;</span> - 年;</span><br><span class="line"><span class="variable">$&#123;MONTH&#125;</span> - 月;</span><br><span class="line"><span class="variable">$&#123;DAY&#125;</span> - 日;</span><br><span class="line"><span class="variable">$&#123;HOUR&#125;</span> - 小时;</span><br><span class="line"><span class="variable">$&#123;MINUTE&#125;</span> - 分钟；</span><br><span class="line"><span class="variable">$&#123;PRODUCT_NAME&#125;</span> - 创建文件的IDE名称;</span><br><span class="line"><span class="variable">$&#123;MONTH_NAME_SHORT&#125;</span> - 英文月份缩写, 如: Jan, Feb, etc;</span><br><span class="line"><span class="variable">$&#123;MONTH_NAME_FULL&#125;</span> - 英文月份全称, 如: January, February, etc；</span><br></pre></td></tr></table></figure>

<h2 id="python-cheat-sheet"><a href="#python-cheat-sheet" class="headerlink" title="python cheat sheet"></a>python cheat sheet</h2><h3 id="PYTHONPATH-作用"><a href="#PYTHONPATH-作用" class="headerlink" title="PYTHONPATH 作用"></a>PYTHONPATH 作用</h3><p><code>PYTHONPATH</code> 是 Python 搜索路径，默认我们 <code>import</code> 的模块都会从 <code>PYTHONPATH</code> 里面寻找。</p>
<p>默认情况下，<code>PYTHONPATH</code> 是个空值，可以通过命令设置临时环境变量 <code>PYTHONPATH</code> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># windows</span></span><br><span class="line"><span class="built_in">set</span> PYTHONPATH=path1;path2</span><br><span class="line"></span><br><span class="line"><span class="comment"># linux</span></span><br><span class="line"><span class="built_in">export</span>  PYTHONPATH=path1:path2</span><br></pre></td></tr></table></figure>

<p>pycharm 默认会设置 <code>PYTHONPATH</code> 为源码根目录，vscode 则不会设置。</p>
<p>python 中获取 <code>PYTHONPATH</code> 值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;PYTHONPATH&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>使用 <code>python -m</code> 执行 python 命令时， Python 将会在 <code>PYTHONPATH</code> 中添加当前目录。</p>
<h3 id="locals-和-globals-以及反射"><a href="#locals-和-globals-以及反射" class="headerlink" title="locals 和 globals 以及反射"></a>locals 和 globals 以及反射</h3><h2 id="python-第三方库"><a href="#python-第三方库" class="headerlink" title="python 第三方库"></a>python 第三方库</h2><h3 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h3><h4 id="Django-测试脚本"><a href="#Django-测试脚本" class="headerlink" title="Django 测试脚本"></a>Django 测试脚本</h4><p>当你只是想测试 django 中的某一个 py 文件内容 那么你可以不用书写前后端交互的形式，而是直接写一个测试脚本即可</p>
<p>测试环境的准备：</p>
<p>去 <code>manage.py</code> 中拷贝前四行代码 然后自己写两行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;day64.settings&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个代码块的下面就可以测试 django 里面的单个 py 文件了。</p>
<blockquote>
<p><a href="https://www.strongforu.top/archives/153">https://www.strongforu.top/archives/153</a></p>
</blockquote>
<h3 id="celery"><a href="#celery" class="headerlink" title="celery"></a>celery</h3><h3 id="mypy-cheat-sheet"><a href="#mypy-cheat-sheet" class="headerlink" title="mypy cheat sheet"></a>mypy cheat sheet</h3><p>禁用特定行或代码库中特定文件内的类型检查。为此，您可以使用 <code># type: ignore</code> 注释。</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于大多数类型，mypy通常可以从变量的值中推断出其类型</span></span><br><span class="line">x: <span class="built_in">int</span> = <span class="number">1</span></span><br><span class="line">x: <span class="built_in">float</span> = <span class="number">1.0</span></span><br><span class="line">x: <span class="built_in">bool</span> = <span class="literal">True</span></span><br><span class="line">x: <span class="built_in">str</span> = <span class="string">&quot;test&quot;</span></span><br><span class="line">x: <span class="built_in">bytes</span> = <span class="string">b&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For collections on Python 3.9+, the type of the collection item is in brackets</span></span><br><span class="line">x: <span class="built_in">list</span>[<span class="built_in">int</span>] = [<span class="number">1</span>]</span><br><span class="line">x: <span class="built_in">set</span>[<span class="built_in">int</span>] = &#123;<span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># For mappings, we need the types of both keys and values</span></span><br><span class="line">x: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">float</span>] = &#123;<span class="string">&quot;field&quot;</span>: <span class="number">2.0</span>&#125;  <span class="comment"># Python 3.9+</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For tuples of fixed size, we specify the types of all the elements</span></span><br><span class="line">x: <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">str</span>, <span class="built_in">float</span>] = (<span class="number">3</span>, <span class="string">&quot;yes&quot;</span>, <span class="number">7.5</span>)  <span class="comment"># Python 3.9+</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For tuples of variable size, we use one type and ellipsis</span></span><br><span class="line">x: <span class="built_in">tuple</span>[<span class="built_in">int</span>, ...] = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># Python 3.9+</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># On Python 3.8 and earlier, the name of the collection type is</span></span><br><span class="line"><span class="comment"># capitalized, and the type is imported from the &#x27;typing&#x27; module</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Set</span>, <span class="type">Dict</span>, <span class="type">Tuple</span></span><br><span class="line">x: <span class="type">List</span>[<span class="built_in">int</span>] = [<span class="number">1</span>]</span><br><span class="line">x: <span class="type">Set</span>[<span class="built_in">int</span>] = &#123;<span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">x: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">float</span>] = &#123;<span class="string">&quot;field&quot;</span>: <span class="number">2.0</span>&#125;</span><br><span class="line">x: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">str</span>, <span class="built_in">float</span>] = (<span class="number">3</span>, <span class="string">&quot;yes&quot;</span>, <span class="number">7.5</span>)</span><br><span class="line">x: <span class="type">Tuple</span>[<span class="built_in">int</span>, ...] = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># On Python 3.10+, use the | operator when something could be one of a few types</span></span><br><span class="line">x: <span class="built_in">list</span>[<span class="built_in">int</span> | <span class="built_in">str</span>] = [<span class="number">3</span>, <span class="number">5</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;fun&quot;</span>]  <span class="comment"># Python 3.10+</span></span><br><span class="line"><span class="comment"># On earlier versions, use Union</span></span><br><span class="line">x: <span class="built_in">list</span>[<span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>]] = [<span class="number">3</span>, <span class="number">5</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;fun&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use Optional[X] for a value that could be None</span></span><br><span class="line"><span class="comment"># Optional[X] is the same as X | None or Union[X, None]</span></span><br><span class="line">x: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="string">&quot;something&quot;</span> <span class="keyword">if</span> some_condition() <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># Mypy 可以理解 if 语句，x在这里不会是None。</span></span><br><span class="line">    <span class="built_in">print</span>(x.upper())</span><br><span class="line"><span class="comment"># 如果你知道一个值永远不会是None，但是 mypy 不理解的逻辑，可以使用assert。</span></span><br><span class="line"><span class="keyword">assert</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"><span class="built_in">print</span>(x.upper())</span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Callable</span>, Iterator, <span class="type">Union</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是如何对函数定义进行注释的</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stringify</span>(<span class="params">num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是如何指定多个参数的方式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plus</span>(<span class="params">num1: <span class="built_in">int</span>, num2: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果一个函数没有返回值，使用None作为返回类型。参数的默认值在类型注释之后。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">value: <span class="built_in">str</span>, excitement: <span class="built_in">int</span> = <span class="number">10</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(value + <span class="string">&quot;!&quot;</span> * excitement)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请注意，没有类型的参数是动态类型（被视为Any），没有任何注释的函数不会进行检查。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">untyped</span>(<span class="params">x</span>):</span><br><span class="line">    x.anything() + <span class="number">1</span> + <span class="string">&quot;string&quot;</span>  <span class="comment"># no errors</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是如何对可调用（函数）值进行注释的。</span></span><br><span class="line">x: <span class="type">Callable</span>[[<span class="built_in">int</span>, <span class="built_in">float</span>], <span class="built_in">float</span>] = f</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">callback: <span class="type">Callable</span>[[<span class="built_in">str</span>], <span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>: ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个产生整数的生成器函数实际上就是一个返回整数迭代器的函数，因此我们就是这样对其进行注释的。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; Iterator[<span class="built_in">int</span>]:</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，你可以将一个函数注释拆分成多行。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_email</span>(<span class="params">address: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">list</span>[<span class="built_in">str</span>]],</span></span><br><span class="line"><span class="params">               sender: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">               cc: <span class="type">Optional</span>[<span class="built_in">list</span>[<span class="built_in">str</span>]],</span></span><br><span class="line"><span class="params">               bcc: <span class="type">Optional</span>[<span class="built_in">list</span>[<span class="built_in">str</span>]],</span></span><br><span class="line"><span class="params">               subject: <span class="built_in">str</span> = <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="params">               body: <span class="type">Optional</span>[<span class="built_in">list</span>[<span class="built_in">str</span>]] = <span class="literal">None</span></span></span><br><span class="line"><span class="params">               </span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mypy理解位置参数和关键字参数。位置参数也可以通过使用以两个下划线开头的名称进行标记。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quux</span>(<span class="params">x: <span class="built_in">int</span>, /, *, y: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">quux(<span class="number">3</span>, y=<span class="number">5</span>)  <span class="comment"># Ok</span></span><br><span class="line">quux(<span class="number">3</span>, <span class="number">5</span>)  <span class="comment"># error: Too many positional arguments for &quot;quux&quot;</span></span><br><span class="line">quux(x=<span class="number">3</span>, y=<span class="number">5</span>)  <span class="comment"># error: Unexpected keyword argument &quot;x&quot; for &quot;quux&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这表示每个位置参数和每个关键字参数都是 &quot;str&quot; 类型。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, *args: <span class="built_in">str</span>, **kwargs: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    reveal_type(args)  <span class="comment"># Revealed type is &quot;tuple[str, ...]&quot;</span></span><br><span class="line">    reveal_type(kwargs)  <span class="comment"># Revealed type is &quot;dict[str, str]&quot;</span></span><br><span class="line">    request = make_request(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> self.do_api_query(request)</span><br></pre></td></tr></table></figure>

<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span>:</span><br><span class="line">    <span class="comment"># The &quot;__init__&quot; method doesn&#x27;t return anything, so it gets return</span></span><br><span class="line">    <span class="comment"># type &quot;None&quot; just like any other method that doesn&#x27;t return anything</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_name: <span class="built_in">str</span>, initial_balance: <span class="built_in">int</span> = <span class="number">0</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># mypy will infer the correct types for these instance variables</span></span><br><span class="line">        <span class="comment"># based on the types of the parameters.</span></span><br><span class="line">        self.account_name = account_name</span><br><span class="line">        self.balance = initial_balance</span><br><span class="line"></span><br><span class="line">    <span class="comment"># For instance methods, omit type for &quot;self&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.balance += amount</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.balance -= amount</span><br><span class="line"></span><br><span class="line"><span class="comment"># User-defined classes are valid as types in annotations</span></span><br><span class="line">account: BankAccount = BankAccount(<span class="string">&quot;Alice&quot;</span>, <span class="number">400</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transfer</span>(<span class="params">src: BankAccount, dst: BankAccount, amount: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    src.withdraw(amount)</span><br><span class="line">    dst.deposit(amount)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Functions that accept BankAccount also accept any subclass of BankAccount!</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AuditedBankAccount</span>(<span class="title class_ inherited__">BankAccount</span>):</span><br><span class="line">    <span class="comment"># You can optionally declare instance variables in the class body</span></span><br><span class="line">    audit_log: <span class="built_in">list</span>[<span class="built_in">str</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_name: <span class="built_in">str</span>, initial_balance: <span class="built_in">int</span> = <span class="number">0</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__(account_name, initial_balance)</span><br><span class="line">        self.audit_log: <span class="built_in">list</span>[<span class="built_in">str</span>] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.audit_log.append(<span class="string">f&quot;Deposited <span class="subst">&#123;amount&#125;</span>&quot;</span>)</span><br><span class="line">        self.balance += amount</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.audit_log.append(<span class="string">f&quot;Withdrew <span class="subst">&#123;amount&#125;</span>&quot;</span>)</span><br><span class="line">        self.balance -= amount</span><br><span class="line"></span><br><span class="line">audited = AuditedBankAccount(<span class="string">&quot;Bob&quot;</span>, <span class="number">300</span>)</span><br><span class="line">transfer(audited, account, <span class="number">100</span>)  <span class="comment"># type checks!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can use the ClassVar annotation to declare a class variable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    seats: ClassVar[<span class="built_in">int</span>] = <span class="number">4</span></span><br><span class="line">    passengers: ClassVar[<span class="built_in">list</span>[<span class="built_in">str</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># If you want dynamic attributes on your class, have it</span></span><br><span class="line"><span class="comment"># override &quot;__setattr__&quot; or &quot;__getattr__&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="comment"># This will allow assignment to any A.x, if x is the same type as &quot;value&quot;</span></span><br><span class="line">    <span class="comment"># (use &quot;value: Any&quot; to allow arbitrary types)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name: <span class="built_in">str</span>, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>: ...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This will allow access to any A.x, if x is compatible with the return type</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>: ...</span><br><span class="line"></span><br><span class="line">a.foo = <span class="number">42</span>  <span class="comment"># Works</span></span><br><span class="line">a.bar = <span class="string">&#x27;Ex-parrot&#x27;</span>  <span class="comment"># Fails type checking</span></span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/python/mypy">https://github.com/python/mypy</a></p>
<h4 id="json-类型定义"><a href="#json-类型定义" class="headerlink" title="json 类型定义"></a>json 类型定义</h4><p>当 json 结果固定时，使用 <a href="https://mypy.readthedocs.io/en/latest/more_types.html#typeddict">TypedDicts</a>，当结构不固定时，使用下面方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span>, <span class="type">List</span>, <span class="type">Union</span>, TypeAlias</span><br><span class="line"></span><br><span class="line">Json: TypeAlias = <span class="type">Union</span>[<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="string">&quot;Json&quot;</span>], <span class="type">List</span>[<span class="string">&quot;Json&quot;</span>], <span class="built_in">str</span>, <span class="built_in">int</span>, <span class="built_in">float</span>, <span class="built_in">bool</span>, <span class="literal">None</span>]</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a href="https://stackoverflow.com/questions/51291722/define-a-jsonable-type-using-mypy-pep-526">https://stackoverflow.com/questions/51291722/define-a-jsonable-type-using-mypy-pep-526</a></p>
<p><a href="https://github.com/python/typing/issues/182#issuecomment-1320974824">https://github.com/python/typing/issues/182#issuecomment-1320974824</a></p>
<h3 id="pydantic"><a href="#pydantic" class="headerlink" title="pydantic"></a>pydantic</h3><h3 id="poetry-cheatsheet"><a href="#poetry-cheatsheet" class="headerlink" title="poetry-cheatsheet"></a>poetry-cheatsheet</h3><p><a href="https://python-poetry.org/">https://python-poetry.org/</a></p>
<h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poetry new &lt;project-name&gt;  <span class="comment"># Create a new project</span></span><br><span class="line">poetry init                <span class="comment"># Create pyproject.toml</span></span><br></pre></td></tr></table></figure>

<h4 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poetry add &lt;package_name&gt;       <span class="comment"># Add a new lib</span></span><br><span class="line">poetry remove &lt;package_name&gt;    <span class="comment"># Remove a lib</span></span><br><span class="line">poetry update &lt;package_name&gt;    <span class="comment"># Update a lib</span></span><br><span class="line">poetry show &lt;package_name&gt;      <span class="comment"># show a lib</span></span><br><span class="line">poetry build                    <span class="comment"># Create a package</span></span><br><span class="line">poetry version prerelease       <span class="comment"># Update the alpha version of the next release number.</span></span><br><span class="line">poetry version patch            <span class="comment"># Update the patch version of the next release number.</span></span><br><span class="line">poetry install                  <span class="comment"># install dependencies</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poetry add Flask                   <span class="comment"># 添加 Flask 包</span></span><br><span class="line">poetry add <span class="string">&quot;Flask==1.1.2&quot;</span>          <span class="comment"># 添加 Flask 包，并指定版本为 1.1.2</span></span><br><span class="line">poetry add <span class="string">&quot;Flask==1.1.2&quot;</span> --dev    <span class="comment"># 添加包到开发依赖项中</span></span><br><span class="line">poetry add <span class="string">&quot;/path/to/locallib&quot;</span>     <span class="comment"># 通过指定库路径添加本地依赖</span></span><br><span class="line">poetry remove Flask                <span class="comment"># 移除 Flask 包</span></span><br><span class="line">poetry update                      <span class="comment"># 更新所有的依赖包</span></span><br><span class="line">poetry update Flask                <span class="comment"># 更新 Flask 包</span></span><br><span class="line">poetry show                        <span class="comment"># 显示所有已安装软件包的列表以及说明</span></span><br><span class="line">poetry show Flask                  <span class="comment"># 显示 Flask 包的信息</span></span><br><span class="line">poetry install --no-dev            <span class="comment"># 安装所有依赖项（开发依赖项除外)</span></span><br><span class="line">poetry install -n                  <span class="comment"># 禁用任何可能使安装暂停的交互式问题</span></span><br></pre></td></tr></table></figure>

<h4 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poetry <span class="built_in">env</span> use $(<span class="built_in">which</span> python3)            <span class="comment"># 在当前项目中创建一个新的虚拟环境</span></span><br><span class="line">poetry <span class="built_in">env</span> list                            <span class="comment"># 查找虚拟环境列表</span></span><br><span class="line">poetry <span class="built_in">env</span> list                            <span class="comment"># 查找虚拟环境列表，包括其完整路径</span></span><br><span class="line">poetry <span class="built_in">env</span> remove &lt;env_name&gt;               <span class="comment"># 通过指定虚拟环境的名称删除虚拟环境</span></span><br><span class="line">poetry run <span class="built_in">which</span> python                    <span class="comment"># 获取当前活动的 Python 解释器的路径</span></span><br><span class="line">poetry shell                               <span class="comment"># 激活Python虚拟环境</span></span><br><span class="line">poetry run python                          <span class="comment"># 在虚拟环境中执行python命令</span></span><br><span class="line">poetry run python -m unittest discover     <span class="comment"># Run tests</span></span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poetry config virtualenvs.create <span class="literal">false</span>    <span class="comment"># Disable virtual environment creation</span></span><br><span class="line">poetry config --list                      <span class="comment"># List configuratiom</span></span><br></pre></td></tr></table></figure>

<h1 id="python-打包工具"><a href="#python-打包工具" class="headerlink" title="python 打包工具"></a>python 打包工具</h1><p>⭐⭐⭐⭐⭐<a href="https://github.com/pyinstaller/pyinstaller">PyInstaller</a>: 支持 Windows、Mac 和 Linux 上的 Python 3.8-3.12，比较容易使用。</p>
<p>⭐⭐⭐<a href="https://github.com/marcelotduarte/cx_Freeze">cx_Freeze</a>: 支持 Windows、Mac 和 Linux 上的 Python 3.7-3.11，易用程度一般。</p>
<p>⭐⭐<a href="https://github.com/py2exe/py2exe">py2exe</a>: 仅支持 Windows 上的 Python 3.7 - 3.10。</p>
<p>⭐⭐<a href="https://github.com/ronaldoussoren/py2app">py2app</a>: 仅在 Mac 上支持 Python 3.6 - 3.10。</p>
<p>⭐<a href="https://github.com/kayhayen/Nuitka">Nuitka</a>: Nuitka 会逐字编译您的 Python 代码并生成一个应用来尝试加速您的代码。支持 Windows、Mac 和 Linux 上的 Python 2.6 - 2.7 和 Python 3.4 - 3.11。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python使用</tag>
      </tags>
  </entry>
  <entry>
    <title>learn-typescript</title>
    <url>/2023/09/22/learn-typescript/</url>
    <content><![CDATA[<p>占坑 <a href="http://www.patrickzhong.com/TypeScript/">http://www.patrickzhong.com/TypeScript/</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>xmake使用记录</title>
    <url>/2023/02/16/learn-xmake/</url>
    <content><![CDATA[<p>xmake 是一个基于 Lua 的轻量级跨平台构建工具，使用 xmake.lua 维护项目构建，相比 <code>makefile/CMakeLists.txt</code>，配置语法更加简洁直观，对新手非常友好，短时间内就能快速入门，能够让用户把更多的精力集中在实际的项目开发上。</p>
<p>其官网为：<a href="https://xmake.io/">https://xmake.io</a> 。</p>
<h1 id="xmake-基础"><a href="#xmake-基础" class="headerlink" title="xmake 基础"></a>xmake 基础</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p><code>xmake</code> 可以使用 <code>create</code> 选项创建一个 <code>xmake</code> 项目，例如创建一个名为 <code>helloxmake</code> 的项目。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> $ xmake create helloxmake</span><br><span class="line">create helloxmake ...</span><br><span class="line">  [+]: src\main.cpp</span><br><span class="line">  [+]: xmake.lua</span><br><span class="line">  [+]: .gitignore</span><br><span class="line">create ok!</span><br></pre></td></tr></table></figure>

<p>进入 <code>helloxmake</code> 项目根目录，执行 <code>xamke</code> 命令即可编译，执行 <code>xmake run</code> 即可运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> $ <span class="built_in">cd</span> helloxmake\</span><br><span class="line"> $ xmake</span><br><span class="line">checking <span class="keyword">for</span> platform ... windows</span><br><span class="line">checking <span class="keyword">for</span> architecture ... x64</span><br><span class="line">checking <span class="keyword">for</span> Microsoft Visual Studio (x64) version ... 2019</span><br><span class="line">[ 25%]: ccache compiling.release src\main.cpp</span><br><span class="line">[ 50%]: linking.release helloxmake.exe</span><br><span class="line">[100%]: build ok!</span><br><span class="line"> $ xmake run</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure>

<p>可以用 <code>xmake create -h</code> 命令查看 <code>create</code> 选项的更多用法。</p>
<h2 id="使用本地包"><a href="#使用本地包" class="headerlink" title="使用本地包"></a>使用本地包</h2><h3 id="创建本地包"><a href="#创建本地包" class="headerlink" title="创建本地包"></a>创建本地包</h3><p>首先创建一个库，添加 <code>hello.h</code> 和 <code>hello.cpp</code> 到 <code>src</code> 文件，其内容如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello.cpp</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 <code>xmake.lua</code> 文件内容如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;helloxmake&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;static&quot;</span>)</span><br><span class="line">    add_headerfiles(<span class="string">&quot;src/hello.h&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/hello.cpp&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行 <code>xmake</code> 命令即可编译出 <code>lib</code> 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> $ xmake</span><br><span class="line">checking <span class="keyword">for</span> Microsoft Visual Studio (x64) version ... 2019</span><br><span class="line">[ 25%]: ccache compiling.release src\hello.cpp</span><br><span class="line">[ 50%]: archiving.release helloxmake.lib</span><br><span class="line">[100%]: build ok!</span><br></pre></td></tr></table></figure>

<p>使用 <code>xmake package</code> 即可打包为本地包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> $ xmake package</span><br><span class="line">[ 25%]: ccache compiling.release src\hello.cpp</span><br><span class="line">[ 50%]: archiving.release helloxmake.lib</span><br><span class="line">[100%]: build ok!</span><br><span class="line">package(helloxmake): build\packages\h\helloxmake generated</span><br></pre></td></tr></table></figure>

<h3 id="add-requires-添加本地包"><a href="#add-requires-添加本地包" class="headerlink" title="add_requires 添加本地包"></a>add_requires 添加本地包</h3><p>前面编译的 <code>build\packages\h\helloxmake</code> 目录即为创建的本地包。</p>
<p>为了方便，将 <code>build</code> 目录复制到需要使用本地库的项目中，将 <code>xmake.lua</code> 内容修改如下即可使用本地库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line"></span><br><span class="line">add_repositories(<span class="string">&quot;local-repo build&quot;</span>)</span><br><span class="line">add_requires(<span class="string">&quot;helloxmake&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;usepackge&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/main.cpp&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;helloxmake&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>main.cpp</code> 内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hello.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>xmake</code> 命令即可编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> $ xmake</span><br><span class="line">[ 25%]: ccache compiling.release src\main.cpp</span><br><span class="line">[ 50%]: linking.release usepackge.exe</span><br><span class="line">[100%]: build ok!</span><br></pre></td></tr></table></figure>

<h3 id="add-links-添加本地包"><a href="#add-links-添加本地包" class="headerlink" title="add_links 添加本地包"></a>add_links 添加本地包</h3><p>修改 <code>xmake.lua</code> 内容如下，然后执行 <code>xmake</code> 命令即可编译。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;usepackge&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/*.cpp&quot;</span>)</span><br><span class="line">    <span class="comment">-- 添加 include 目录</span></span><br><span class="line">    add_includedirs(<span class="string">&quot;../helloxmake/src&quot;</span>)</span><br><span class="line">    <span class="comment">-- 添加 lib 目录</span></span><br><span class="line">    add_linkdirs(<span class="string">&quot;../helloxmake/build/windows/x64/release&quot;</span>)</span><br><span class="line">    <span class="comment">-- 添加 lib</span></span><br><span class="line">    add_links(<span class="string">&quot;helloxmake&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="使用远程包"><a href="#使用远程包" class="headerlink" title="使用远程包"></a>使用远程包</h2><p>这里我们使用 Apache 提供的跨平台运行库 <a href="https://github.com/apache/apr">apr</a> 作为示例 。</p>
<h3 id="使用官方提供的远程包"><a href="#使用官方提供的远程包" class="headerlink" title="使用官方提供的远程包"></a>使用官方提供的远程包</h3><p>首先创建一个项目，修改 <code>xmake.lua</code> 内容，使用 <code>add_requires(&quot;apr&quot;)</code> 添加官方提供的 <a href="https://xrepo.xmake.io/">xrepo</a> 远程包。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">add_rules(<span class="string">&quot;mode.debug&quot;</span>, <span class="string">&quot;mode.release&quot;</span>)</span><br><span class="line"></span><br><span class="line">add_requires(<span class="string">&quot;apr 1.7.0&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;testapr&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/main.cpp&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;apr&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>main.cpp</code> 内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;apr_general.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialization</span></span><br><span class="line">    <span class="built_in">apr_initialize</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">apr_terminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后运行 <code>xmake</code> 命令，将会自动下载对应的包，并编译。</p>
<h3 id="使用本地远程包"><a href="#使用本地远程包" class="headerlink" title="使用本地远程包"></a>使用本地远程包</h3><p>由于 apr 最新版本为 1.7.2，而 <a href="https://xrepo.xmake.io/">xrepo</a> 提供的最新版本为 1.7.0，我们可以参考 <a href="https://xrepo.xmake.io/">xrepo</a> 对应的 xmake.lua，使用本地远程包。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">package</span>(<span class="string">&quot;apr&quot;</span>)</span><br><span class="line">    set_homepage(<span class="string">&quot;https://github.com/apache/apr&quot;</span>)</span><br><span class="line">    set_description(<span class="string">&quot;Mirror of Apache Portable Runtime&quot;</span>)</span><br><span class="line">    set_license(<span class="string">&quot;Apache-2.0&quot;</span>)</span><br><span class="line"></span><br><span class="line">    add_urls(<span class="string">&quot;https://github.com/apache/apr/archive/refs/tags/$(version).tar.gz&quot;</span>,</span><br><span class="line">             <span class="string">&quot;https://github.com/apache/apr.git&quot;</span>)</span><br><span class="line">    add_versions(<span class="string">&quot;1.7.2&quot;</span>, <span class="string">&quot;8be046191792776815b5e123298a2c379a962abbdf124fddd2b487b5203d7da9&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;linux&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_deps(<span class="string">&quot;libtool&quot;</span>, <span class="string">&quot;python&quot;</span>)</span><br><span class="line">        add_patches(<span class="string">&quot;1.7.0&quot;</span>, <span class="built_in">path</span>.join(<span class="built_in">os</span>.scriptdir(), <span class="string">&quot;patches&quot;</span>, <span class="string">&quot;1.7.0&quot;</span>, <span class="string">&quot;common.patch&quot;</span>), <span class="string">&quot;bbfef69c914ca1ab98a9d94fc4794958334ce5f47d8c08c05e0965a48a44c50d&quot;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> is_plat(<span class="string">&quot;windows&quot;</span>) <span class="keyword">then</span></span><br><span class="line">        add_deps(<span class="string">&quot;cmake&quot;</span>)</span><br><span class="line">        add_syslinks(<span class="string">&quot;wsock32&quot;</span>, <span class="string">&quot;ws2_32&quot;</span>, <span class="string">&quot;advapi32&quot;</span>, <span class="string">&quot;shell32&quot;</span>, <span class="string">&quot;rpcrt4&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    on_install(<span class="string">&quot;linux&quot;</span>, <span class="string">&quot;macosx&quot;</span>, <span class="function"><span class="keyword">function</span> <span class="params">(package)</span></span></span><br><span class="line">        <span class="keyword">local</span> configs = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">package</span>:is_plat(<span class="string">&quot;linux&quot;</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">os</span>.vrunv(<span class="string">&quot;sh&quot;</span>, &#123;<span class="string">&quot;./buildconf&quot;</span>&#125;)</span><br><span class="line">            <span class="built_in">io</span>.replace(<span class="string">&quot;configure&quot;</span>, <span class="string">&quot;RM=&#x27;$RM&#x27;&quot;</span>, <span class="string">&quot;RM=&#x27;$RM -f&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">io</span>.replace(<span class="string">&quot;configure.in&quot;</span>, <span class="string">&quot;pid_t_fmt=&#x27;#error Can not determine the proper size for pid_t&#x27;&quot;</span>, <span class="string">&quot;pid_t_fmt=&#x27;#define APR_PID_T_FMT \&quot;d\&quot;&#x27;&quot;</span>)</span><br><span class="line">            <span class="built_in">os</span>.vrunv(<span class="string">&quot;sh&quot;</span>, &#123;<span class="string">&quot;./buildconf&quot;</span>&#125;)</span><br><span class="line">            <span class="built_in">table</span>.<span class="built_in">insert</span>(configs, <span class="string">&quot;CFLAGS=-DAPR_IOVEC_DEFINED&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        import(<span class="string">&quot;package.tools.autoconf&quot;</span>).install(<span class="built_in">package</span>, configs)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">package</span>:<span class="built_in">config</span>(<span class="string">&quot;shared&quot;</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">os</span>.rm(<span class="built_in">package</span>:installdir(<span class="string">&quot;lib/*.a&quot;</span>))</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">os</span>.tryrm(<span class="built_in">package</span>:installdir(<span class="string">&quot;lib/*.so*&quot;</span>))</span><br><span class="line">            <span class="built_in">os</span>.tryrm(<span class="built_in">package</span>:installdir(<span class="string">&quot;lib/*.dylib&quot;</span>))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">package</span>:add(<span class="string">&quot;links&quot;</span>, <span class="string">&quot;apr-1&quot;</span>)</span><br><span class="line">        <span class="built_in">package</span>:add(<span class="string">&quot;includedirs&quot;</span>, <span class="string">&quot;include/apr-1&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    on_install(<span class="string">&quot;windows&quot;</span>, <span class="function"><span class="keyword">function</span> <span class="params">(package)</span></span></span><br><span class="line">        <span class="keyword">local</span> configs = &#123;&#125;</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(configs, <span class="string">&quot;-DCMAKE_BUILD_TYPE=&quot;</span> .. (<span class="built_in">package</span>:<span class="built_in">debug</span>() <span class="keyword">and</span> <span class="string">&quot;Debug&quot;</span> <span class="keyword">or</span> <span class="string">&quot;Release&quot;</span>))</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(configs, <span class="string">&quot;-DAPR_BUILD_SHARED=&quot;</span> .. (<span class="built_in">package</span>:<span class="built_in">config</span>(<span class="string">&quot;shared&quot;</span>) <span class="keyword">and</span> <span class="string">&quot;ON&quot;</span> <span class="keyword">or</span> <span class="string">&quot;OFF&quot;</span>))</span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(configs, <span class="string">&quot;-DAPR_BUILD_STATIC=&quot;</span> .. (<span class="built_in">package</span>:<span class="built_in">config</span>(<span class="string">&quot;shared&quot;</span>) <span class="keyword">and</span> <span class="string">&quot;OFF&quot;</span> <span class="keyword">or</span> <span class="string">&quot;ON&quot;</span>))</span><br><span class="line">        import(<span class="string">&quot;package.tools.cmake&quot;</span>).install(<span class="built_in">package</span>, configs)</span><br><span class="line">        <span class="comment">-- libapr-1 is shared, apr-1 is static</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">package</span>:<span class="built_in">config</span>(<span class="string">&quot;shared&quot;</span>) <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">package</span>:add(<span class="string">&quot;defines&quot;</span>, <span class="string">&quot;APR_DECLARE_EXPORT&quot;</span>)</span><br><span class="line">            <span class="built_in">os</span>.rm(<span class="built_in">package</span>:installdir(<span class="string">&quot;lib/apr-1.lib&quot;</span>))</span><br><span class="line">            <span class="built_in">os</span>.rm(<span class="built_in">package</span>:installdir(<span class="string">&quot;lib/aprapp-1.lib&quot;</span>))</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">package</span>:add(<span class="string">&quot;defines&quot;</span>, <span class="string">&quot;APR_DECLARE_STATIC&quot;</span>)</span><br><span class="line">            <span class="built_in">os</span>.rm(<span class="built_in">package</span>:installdir(<span class="string">&quot;lib/lib*.lib&quot;</span>))</span><br><span class="line">            <span class="built_in">os</span>.rm(<span class="built_in">package</span>:installdir(<span class="string">&quot;bin/lib*.dll&quot;</span>))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">    on_test(<span class="function"><span class="keyword">function</span> <span class="params">(package)</span></span></span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">package</span>:has_cfuncs(<span class="string">&quot;apr_initialize&quot;</span>, &#123;includes = <span class="string">&quot;apr_general.h&quot;</span>&#125;))</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">package_end()</span><br><span class="line"></span><br><span class="line">add_requires(<span class="string">&quot;apr 1.7.2&quot;</span>)</span><br><span class="line"></span><br><span class="line">target(<span class="string">&quot;testapr&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/main.cpp&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;apr&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后运行 <code>xmake</code> 命令，将会自动下载对应源码进行编译打包，最终编译成可执行程序。</p>
<h1 id="常用的选项"><a href="#常用的选项" class="headerlink" title="常用的选项"></a>常用的选项</h1><h2 id="设置编译和链接选项"><a href="#设置编译和链接选项" class="headerlink" title="设置编译和链接选项"></a>设置编译和链接选项</h2><p>我们也可以根据实际情况通过额外配置一些编译和链接选项。</p>
<ul>
<li><code>--cflags/add_cflags</code>: 指定 <code>c</code> 编译参数。</li>
<li><code>--cxxflags/add_cxxflags</code>: 指定 <code>c++</code> 编译参数。</li>
<li><code>--cxflags/add_cxflags</code>: 指定 <code>c/c++</code> 编译参数。</li>
<li><code>--asflags/add_asflags</code>: 指定汇编器编译参数。</li>
<li><code>--ldflags/add_ldflags</code>: 指定可执行程序链接参数。</li>
<li><code>--shflags/add_shflags</code>: 指定动态库程序链接参数。</li>
<li><code>--arflags/add_arflags</code>: 指定静态库的生成参数。</li>
</ul>
<p>前者为 <code>xmake</code> 命令行参数，后者为函数。</p>
<h2 id="添加头文件目录"><a href="#添加头文件目录" class="headerlink" title="添加头文件目录"></a>添加头文件目录</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">add_includedirs(<span class="string">&quot;include&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="添加链接目录与链接库"><a href="#添加链接目录与链接库" class="headerlink" title="添加链接目录与链接库"></a>添加链接目录与链接库</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">add_linkdirs(<span class="string">&quot;ext/lib&quot;</span>)</span><br><span class="line">add_links(<span class="string">&quot;myext&quot;</span>)</span><br><span class="line">add_syslinks(<span class="string">&quot;pthread&quot;</span>, <span class="string">&quot;m&quot;</span>)</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/myuanz/getting-started-with-xmake-package">https://github.com/myuanz/getting-started-with-xmake-package</a></p>
<p><a href="https://xmake.io/#/zh-cn/guide/installation">https://xmake.io/#/zh-cn/guide/installation</a></p>
<p><a href="https://xrepo.xmake.io/#/zh-cn/getting_started">https://xrepo.xmake.io/#/zh-cn/getting_started</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/640701847">https://zhuanlan.zhihu.com/p/640701847</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>xmake</tag>
      </tags>
  </entry>
  <entry>
    <title>linux使用记录</title>
    <url>/2019/11/03/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="Android-studio-出现-grant-current-user-access-to-x2F-dev-x2F-kvm-以及-x2F-dev-x2F-kvm-devices-permission-denies"><a href="#Android-studio-出现-grant-current-user-access-to-x2F-dev-x2F-kvm-以及-x2F-dev-x2F-kvm-devices-permission-denies" class="headerlink" title="Android studio 出现 grant current user access to &#x2F;dev&#x2F;kvm 以及&#x2F;dev&#x2F;kvm devices: permission denies"></a>Android studio 出现 grant current user access to &#x2F;dev&#x2F;kvm 以及&#x2F;dev&#x2F;kvm devices: permission denies</h3><p>linux 中启动模拟器出现 <code>grant current user access to /dev/kvm</code> 错误</p>
<ol>
<li><p>临时解决方法：</p>
<p>打开 terminal 输入代码 <code>sudo chown username -R /dev/kvm</code> 注意 username 是你用的用户名， 重新启动模拟器就可以了。</p>
</li>
<li><p>永久解决办法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装qemu-kvm</span></span><br><span class="line">$ sudo apt install qemu-kvm</span><br><span class="line"><span class="comment"># 使用以下命令将您的用户添加到kvm组：</span></span><br><span class="line">$ sudo adduser <span class="variable">$USER</span> kvm</span><br><span class="line"><span class="comment"># 如果仍然显示拒绝权限：</span></span><br><span class="line">$ sudo <span class="built_in">chown</span> <span class="variable">$USER</span> /dev/kvm</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Android-studio-创建快捷方式"><a href="#Android-studio-创建快捷方式" class="headerlink" title="Android studio 创建快捷方式"></a>Android studio 创建快捷方式</h3><p>打开<code>/usr/share/applications</code>目录，使用<code>sudo vim AndroidStudio.desktop</code>创建 AndroidStudio 的快捷方式，加入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=Android Studio     <span class="comment">#名称</span></span><br><span class="line">Comment=Android Dev     <span class="comment">#注释</span></span><br><span class="line">StartupNotify=<span class="literal">true</span></span><br><span class="line">Terminal=<span class="literal">false</span></span><br><span class="line">Type=Application</span><br><span class="line">Icon=/home/ckcat/DevelopTools/android-studio/bin/studio.png     <span class="comment">#设置图标</span></span><br><span class="line">Exec=/home/ckcat/DevelopTools/android-studio/bin/studio.sh %F   <span class="comment">#设置启动方式</span></span><br></pre></td></tr></table></figure>

<p>保存退出后，其图标将会出现在 <code>Applications</code> 中，将其复制到桌面即可创建桌面快捷方式。</p>
<p>或者通过菜单 <code>Tool -&gt; Create Desktop Entry</code> 创建，其快捷方式位于 <code>~.local/share/applications</code> 目录中。</p>
<h3 id="Ubuntu-标题栏实时显示上下行网速、CPU-及内存使用率"><a href="#Ubuntu-标题栏实时显示上下行网速、CPU-及内存使用率" class="headerlink" title="Ubuntu 标题栏实时显示上下行网速、CPU 及内存使用率"></a>Ubuntu 标题栏实时显示上下行网速、CPU 及内存使用率</h3><p>安装 <code>indicator-sysmonitor</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install indicator-sysmonitor</span><br></pre></td></tr></table></figure>

<p>终端执行：<code>indicator-sysmonitor &amp;</code>， 为了方便还要为程序添加开机启动，鼠标右键点击标题栏上图标，弹出菜单，选择首选项，出现如下界面：</p>
<img src="/2019/11/03/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2019-11-03-14-57-30.png" class="">

<p>最后进行格式设定,设置界面如下：</p>
<img src="/2019/11/03/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2019-11-03-15-00-29.png" class="">

<p>设置好之后可以点击 Test 以下，最后别忘了保存,最终效果如下：</p>
<img src="/2019/11/03/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2019-11-03-15-02-39.png" class="">

<h3 id="设置深度截图快捷方式"><a href="#设置深度截图快捷方式" class="headerlink" title="设置深度截图快捷方式"></a>设置深度截图快捷方式</h3><p>通过应用商店安装<a href="(https://github.com/linuxdeepin/deepin-screenshot)"><code>deepin-screenshot</code></a>,在系统 <code>Keyboard</code> 中添加深度截图，设置快捷方式。</p>
<img src="/2019/11/03/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2019-11-03-15-48-05.png" class="">

<img src="/2019/11/03/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2019-11-03-15-49-11.png" class="">

<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><h4 id="路径写法"><a href="#路径写法" class="headerlink" title="路径写法"></a>路径写法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可执行文件(一般在文件夹bin内):</span></span><br><span class="line">$ <span class="built_in">export</span> PATH=/usr/local/cuda-8.0/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 库文件(一般在文件夹lib内 .so):</span></span><br><span class="line">$ <span class="built_in">export</span> LD_LIBRARY_PATH=/home/opencv2.4.9/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>

<h4 id="临时设置"><a href="#临时设置" class="headerlink" title="临时设置"></a>临时设置</h4><p>在终端中输入 <code>export</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=/usr/local/cuda-8.0/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<h4 id="当前用户的全局设置"><a href="#当前用户的全局设置" class="headerlink" title="当前用户的全局设置"></a>当前用户的全局设置</h4><p>打开 <code>~/.bashrc</code> ，在末尾添加环境变量，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/home/public/software_install/protobuf-3.1.0/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/home/public/software_install/protobuf-3.1.0/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>

<p>执行 <code>source ~/.bashrc</code> 命令使之生效。</p>
<h4 id="所有用户的全局设置"><a href="#所有用户的全局设置" class="headerlink" title="所有用户的全局设置"></a>所有用户的全局设置</h4><p>使用 <code>sudo vim /etc/profile</code> 打开系统配置文件，在末尾添加环境变量，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/home/public/software_install/protobuf-3.1.0/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/home/public/software_install/protobuf-3.1.0/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br></pre></td></tr></table></figure>

<p>执行 <code>source profile</code> 命令使之生效。</p>
<p>配置好后可以使用 <code>echo $PATH</code> 或 <code>env</code> 测试当前的环境变量。</p>
<h3 id="adb-devices-报错-no-permissions-user-in-plugdev-group-are-your-udev-rules-wrong"><a href="#adb-devices-报错-no-permissions-user-in-plugdev-group-are-your-udev-rules-wrong" class="headerlink" title="adb devices 报错 no permissions (user in plugdev group; are your udev rules wrong?)"></a>adb devices 报错 no permissions (user in plugdev group; are your udev rules wrong?)</h3><p>可以参考下面的仓库内容：</p>
<p><a href="https://github.com/snowdream/51-android">https://github.com/snowdream/51-android</a></p>
<p><strong><a href="https://github.com/M0Rf30/android-udev-rules">https://github.com/M0Rf30/android-udev-rules</a> （推荐）</strong></p>
<p>如果还是不行的话再参考下列方法。</p>
<h4 id="lsusb-找到你手机的-usb-地址"><a href="#lsusb-找到你手机的-usb-地址" class="headerlink" title="lsusb 找到你手机的 usb 地址"></a><code>lsusb</code> 找到你手机的 <code>usb</code> 地址</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lsusb</span><br><span class="line">Bus 002 Device 003: ID 18d1:4ee7 Google Inc.</span><br><span class="line">Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub</span><br><span class="line">Bus 001 Device 003: ID 04f2:b59e Chicony Electronics Co., Ltd</span><br><span class="line">Bus 001 Device 004: ID 8087:0aaa Intel Corp.</span><br><span class="line">Bus 001 Device 002: ID 0ea0:2213 Ours Technology, Inc.</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure>

<p>他会列出来所有的 usb 设备，如果找不到，那么拔掉手机 usb 连接，哪个没有了就是哪个。</p>
<h4 id="修改-etc-udev-rules-d-51-android-rules-文件"><a href="#修改-etc-udev-rules-d-51-android-rules-文件" class="headerlink" title="修改 /etc/udev/rules.d/51-android.rules 文件"></a>修改 <code>/etc/udev/rules.d/51-android.rules</code> 文件</h4><p>创建 <code>51-android.rules</code> 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo gedit /etc/udev/rules.d/51-android.rules</span><br><span class="line">[sudo] password <span class="keyword">for</span> ckcat:</span><br></pre></td></tr></table></figure>

<p>添加下列内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ATTR&#123;idProduct&#125;==<span class="string">&quot;4ee7&quot;</span>, SYMLINK+=<span class="string">&quot;android_adb&quot;</span>, MODE=<span class="string">&quot;0660&quot;</span>, GROUP=<span class="string">&quot;plugdev&quot;</span>, TAG+=<span class="string">&quot;uaccess&quot;</span>, SYMLINK+=<span class="string">&quot;android&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意：<code>ATTR&#123;idProduct&#125;</code> 的值是你查找手机设备的 usb 的地址。</p>
<h4 id="执行下列命令"><a href="#执行下列命令" class="headerlink" title="执行下列命令"></a>执行下列命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -a -G plugdev $(<span class="built_in">id</span> -u -n)</span><br><span class="line">$ sudo udevadm control --reload-rules</span><br><span class="line">$ sudo service udev restart</span><br><span class="line">$ sudo udevadm trigger</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行完上述命令后，重启 adb：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb kill-server</span><br><span class="line">$ adb devices</span><br><span class="line">* daemon not running; starting now at tcp:5037</span><br><span class="line">* daemon started successfully</span><br><span class="line">List of devices attached</span><br><span class="line">HT6770300079	unauthorized</span><br></pre></td></tr></table></figure>

<p>在手机上允许就可以了。</p>
<p>参考：<br><a href="https://www.cnblogs.com/caoxinyu/p/10568463.html">https://www.cnblogs.com/caoxinyu/p/10568463.html</a><br><a href="https://juejin.im/post/5bed2b45f265da61530457ee">https://juejin.im/post/5bed2b45f265da61530457ee</a></p>
<h3 id="VIM-普通用户保存文件时用-sudo-获取-root-权限"><a href="#VIM-普通用户保存文件时用-sudo-获取-root-权限" class="headerlink" title="VIM 普通用户保存文件时用 sudo 获取 root 权限"></a>VIM 普通用户保存文件时用 sudo 获取 root 权限</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:w !sudo <span class="built_in">tee</span> %</span><br></pre></td></tr></table></figure>

<p>百分号 (<code>%</code>) 代表当前文件名，这条命令的含义是把当前编辑的文件的内容当做标准输入输出到命令 <code>sudo tee</code> 文件名的文件里去，也就是 <code>sudo</code> 保存为当前文件名。</p>
<h3 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h3><ol>
<li><p>安装仓库中包含的最新版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install nodejs</span><br><span class="line">$ sudo apt install npm     <span class="comment"># 安装npm管理工具</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>升级 node 版本为长服务版（lts）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo npm install -g n</span><br><span class="line">$ sudo n lts</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo n            <span class="comment"># 将显示本机的可用版本列表，通过上下键来选择对应的版本</span></span><br><span class="line">$ sudo n 10.13.0    <span class="comment"># 如果对版本比较熟悉，可直接指定版本</span></span><br><span class="line">$ sudo n -v         <span class="comment"># 查看node版本</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>升级 npm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo npm i -g npm</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="解决-Ubuntu-下-KeePass2-中文显示为方块的问题"><a href="#解决-Ubuntu-下-KeePass2-中文显示为方块的问题" class="headerlink" title="解决 Ubuntu 下 KeePass2 中文显示为方块的问题"></a>解决 Ubuntu 下 KeePass2 中文显示为方块的问题</h3><p><strong>推荐安装 <a href="https://keepassxc.org/">keepassxc</a></strong></p>
<ol>
<li><p>安装 keepass2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install keepass2</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载 KeePass2 语言包</p>
<p><code>KeePass</code> 的<a href="http://keepass.info/translations.html">官网</a>提供了各种语言的语言包，下载中文 2.x 版本语言包后解压到 <code>/usr/lib/KeePass/Languages</code> 目录下，重启 <code>KeePass</code> 后设置 <code>View-&gt;Change Language</code>，选择 <code>Simplified Chinese</code> 即可。</p>
</li>
<li><p>修改启动脚本</p>
<p>修改 <code>/usr/bin/keepass2</code>，加入下列内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export LANG=zh_CN.utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改系统字体设置</p>
<p>参考 FAQ，修改 <code>/etc/fonts/conf.avail/65-nonlatin.conf</code>，添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;alias&gt;</span><br><span class="line">   &lt;family&gt;Ubuntu&lt;/family&gt;</span><br><span class="line">   &lt;prefer&gt;</span><br><span class="line">      &lt;family&gt;sans-serif&lt;/family&gt;</span><br><span class="line">   &lt;/prefer&gt;</span><br><span class="line">&lt;/alias&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在进行上述操作后，重启 KeePass2，应该就可以正常显示中文了。</p>
<h3 id="Ubuntu-安装-wireshark"><a href="#Ubuntu-安装-wireshark" class="headerlink" title="Ubuntu 安装 wireshark"></a>Ubuntu 安装 wireshark</h3><p>添加 PPA 存储库并安装 Wireshark：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:wireshark-dev/stable</span><br><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt -y install wireshark</span><br></pre></td></tr></table></figure>

<p>添加 wireshark 用户组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd wireshark</span><br></pre></td></tr></table></figure>

<p>将 dumpcap 更改为 wireshark 用户组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">chgrp</span> wireshark /usr/bin/dumpcap</span><br></pre></td></tr></table></figure>

<p>让 wireshark 用户组有 root 权限使用 dumpcap</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">chmod</span> 4755 /usr/bin/dumpcap</span><br></pre></td></tr></table></figure>

<p>将需要使用的普通用户名加入 wireshark 用户组，我的用户是 <code>ckcat</code> ，则需要使用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo gpasswd -a ckcat wireshark</span><br></pre></td></tr></table></figure>

<h3 id="安装-Albert"><a href="#安装-Albert" class="headerlink" title="安装 Albert"></a>安装 Albert</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:noobslab/macbuntu</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install albert</span><br></pre></td></tr></table></figure>

<p>设置自动启动，<a href="https://github.com/albertlauncher/albert/issues/11">参考</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ln</span> -s /usr/share/applications/albert.desktop ~/.config/autostart/</span><br></pre></td></tr></table></figure>

<img src="/2019/11/03/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2019-12-15-20-41-37.png" class="">

<h3 id="ubuntu-中添加和删除源"><a href="#ubuntu-中添加和删除源" class="headerlink" title="ubuntu 中添加和删除源"></a>ubuntu 中添加和删除源</h3><p>添加 <code>PPA</code> 源的命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:user/ppa-name</span><br></pre></td></tr></table></figure>

<p>添加好更新一下： <code>sudo apt-get update</code> 。</p>
<p>删除命令格式则为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository -r ppa:user/ppa-name</span><br><span class="line"></span><br><span class="line">$ sudo add-apt-repository -r ppa:eugenesan/java</span><br></pre></td></tr></table></figure>

<p>或者进入 <code>/etc/apt/sources.list.d</code> 目录，将相应 <code>ppa</code> 源的保存文件删除。</p>
<h3 id="vmware-装的-ubuntu-18-04-后安装-vm-tools-复制粘贴失效解决办法。"><a href="#vmware-装的-ubuntu-18-04-后安装-vm-tools-复制粘贴失效解决办法。" class="headerlink" title="vmware 装的 ubuntu 18.04,后安装 vm tools 复制粘贴失效解决办法。"></a>vmware 装的 ubuntu 18.04,后安装 vm tools 复制粘贴失效解决办法。</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt install -y open-vm-tools open-vm-tools-desktop</span><br><span class="line">$ reboot</span><br></pre></td></tr></table></figure>

<h3 id="试用-010Editor-、-Beyond-Compare-4-、Source-Insight4-0"><a href="#试用-010Editor-、-Beyond-Compare-4-、Source-Insight4-0" class="headerlink" title="试用 010Editor 、 Beyond Compare 4 、Source Insight4.0"></a>试用 010Editor 、 Beyond Compare 4 、Source Insight4.0</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> ~/.config/SweetScape/010\ Editor.ini</span><br><span class="line"><span class="built_in">rm</span> ~/.config/bcompare/registry.dat</span><br><span class="line"><span class="built_in">rm</span> ~/.wine/drive_c/ProgramData/Source\ Insight/4.0/si4.lic</span><br></pre></td></tr></table></figure>

<h3 id="安装-Gradle"><a href="#安装-Gradle" class="headerlink" title="安装 Gradle"></a>安装 Gradle</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://downloads.gradle-dn.com/distributions/gradle-7.0.1-bin.zip</span><br><span class="line">$ sudo <span class="built_in">mkdir</span> /opt/gradle</span><br><span class="line">$ sudo unzip -d /opt/gradle gradle-7.0.1-bin.zip</span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/opt/gradle/gradle-7.0.1/bin <span class="comment"># 添加到 .bashrc 中</span></span><br></pre></td></tr></table></figure>

<h3 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h3><p>首先卸载旧版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker \</span><br><span class="line">               docker-engine \</span><br><span class="line">               docker.io</span><br></pre></td></tr></table></figure>

<h4 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h4><p>可以通过 <code>--mirror</code> 选项使用国内源进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $ curl -fsSL test.docker.com -o get-docker.sh</span></span><br><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh --mirror Aliyun</span><br><span class="line"><span class="comment"># $ sudo sh get-docker.sh --mirror AzureChinaCloud</span></span><br></pre></td></tr></table></figure>

<p>启动 docker 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p>建立 docker 用户组，并将当前用户加入 docker 组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>

<p>测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> hello-world</span><br></pre></td></tr></table></figure>

<p>镜像加速</p>
<p>查看是否在 <code>docker.service</code> 文件中配置过镜像地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl <span class="built_in">cat</span> docker | grep <span class="string">&#x27;\-\-registry\-mirror&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果该命令有输出，那么请执行 <code>$ systemctl cat docker</code> 查看 <code>ExecStart=</code> 出现的位置，修改对应的文件内容去掉 <code>--registry-mirror</code> 参数及其值，并按接下来的步骤进行配置。</p>
<p>如果以上命令没有任何输出，那么就可以在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.baidubce.com&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>之后重新启动服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>参考： <a href="https://yeasy.gitbook.io/docker_practice/install/ubuntu">https://yeasy.gitbook.io/docker_practice/install/ubuntu</a></p>
<h4 id="使用-APT-安装"><a href="#使用-APT-安装" class="headerlink" title="使用 APT 安装"></a>使用 APT 安装</h4><p>首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加使用 HTTPS 传输的软件包以及 CA 证书。</span></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure>

<p>需要添加软件源的 GPG 密钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 鉴于国内网络问题，强烈建议使用国内源</span></span><br><span class="line">$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span></span><br></pre></td></tr></table></figure>

<p>向 <code>sources.list</code> 中添加 Docker 软件源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># $ echo \</span></span><br><span class="line"><span class="comment">#   &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="comment">#   $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test。</p>
</blockquote>
<p>更新 apt 软件包缓存，并安装 docker-ce 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<h3 id="neofetch"><a href="#neofetch" class="headerlink" title="neofetch"></a>neofetch</h3><p>Neofetch 是一个命令行系统信息工具。</p>
<p>安装和使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install neofetch</span><br><span class="line">$ neofetch</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="https://github.com/dylanaraps/neofetch">https://github.com/dylanaraps/neofetch</a></p>
</blockquote>
<h3 id="安装-Google-输入法"><a href="#安装-Google-输入法" class="headerlink" title="安装 Google 输入法"></a>安装 Google 输入法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install fcitx-googlepinyin</span><br><span class="line">$ im-config     <span class="comment"># 打开配置，选择 fcitx 输入法</span></span><br></pre></td></tr></table></figure>

<p>重启系统，然后打开输入法配置，添加 <code>Google Pinyin</code> 既可。</p>
<h3 id="安装-Fcitx5-中文输入法"><a href="#安装-Fcitx5-中文输入法" class="headerlink" title="安装 Fcitx5 中文输入法"></a>安装 Fcitx5 中文输入法</h3><p>然后最小安装 Fcitx 5 ，分别是主程序，中文输入法引擎，图形界面相关。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install fcitx5 \</span><br><span class="line">fcitx5-chinese-addons \</span><br><span class="line">fcitx5-frontend-gtk3 fcitx5-frontend-gtk2 \</span><br><span class="line">fcitx5-frontend-qt5 kde-config-fcitx5</span><br></pre></td></tr></table></figure>

<p>然后安装<a href="https://github.com/felixonmars/fcitx5-pinyin-zhwiki/releases">中文词库</a>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ wget https://github.com/felixonmars/fcitx5-pinyin-zhwiki/releases/download/0.2.4/zhwiki-20220416.dict</span><br><span class="line">$ <span class="built_in">mkdir</span> -p ~/.local/share/fcitx5/pinyin/dictionaries/</span><br><span class="line">$ <span class="built_in">mv</span> zhwiki-20220416.dict ~/.local/share/fcitx5/pinyin/dictionaries/</span><br></pre></td></tr></table></figure>

<p>其他词库：</p>
<p><a href="https://github.com/wuhgit/CustomPinyinDictionary">https://github.com/wuhgit/CustomPinyinDictionary</a></p>
<p>使用 <code>im-config</code> 配置 <code>fcitx5</code> 为首选输入法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ im-config</span><br></pre></td></tr></table></figure>

<p>设置环境变量，即将以下配置项写入用户或系统环境变量，这里我写入系统环境变量 <code>/etc/profile</code> 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> XMODIFIERS=@im=fcitx</span><br><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=fcitx</span><br></pre></td></tr></table></figure>

<p>使用 <code>Tweaks</code> 设置 <code>fcitx5</code> 为自动启动。如果没有安装 <code>Tweaks</code> 可以运行下列命令安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install gnome-tweaks</span><br></pre></td></tr></table></figure>

<p>使用命令行命令 <code>fcitx5-configtool</code> 打开 <code>Fcitx5</code> 配置图形界面，将 <code>pinyin</code> 加入默认分组中。</p>
<p>可以在 GitHub <a href="https://github.com/search?q=fcitx5+theme&type=Repositories">搜索主题</a>，然后在 <code>Fcitx5 configtool -&gt; Addons -&gt; Classic User Inteface</code> 中设置即可。</p>
<p>参考： <a href="https://zhuanlan.zhihu.com/p/508797663">https://zhuanlan.zhihu.com/p/508797663</a></p>
<h3 id="清理-VMwareWorkstation-linux-虚拟机的磁盘空间"><a href="#清理-VMwareWorkstation-linux-虚拟机的磁盘空间" class="headerlink" title="清理 VMwareWorkstation linux 虚拟机的磁盘空间"></a>清理 VMwareWorkstation linux 虚拟机的磁盘空间</h3><p>在 VMwareWorkstation 安装好 ubuntu 虚拟机使用了一段时间后，发现虚拟机的磁盘占用的空间远远大于 ubuntu 虚拟机使用的空间，导致物理机的磁盘空间不够用了，就想着如何进行清理，在网上找到了两种方法。</p>
<ol>
<li><p>使用 <code>vmware-vdiskmanager</code> 清理空间</p>
<p>进入 ubuntu 虚拟机，执行下列命令释放出磁盘空间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /dev/zero &gt; zero; <span class="built_in">sync</span>; <span class="built_in">sleep</span> 1; <span class="built_in">rm</span> -f zero</span><br><span class="line">$ <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=zero bs=1G count=10000     <span class="comment"># 或者使用 dd 命令</span></span><br></pre></td></tr></table></figure>

<p>当出现下列错误时，说明虚拟机上的剩余空间已经释放完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span>: write error: No space left on device</span><br></pre></td></tr></table></figure>

<p>然后关闭虚拟机，进入物理机 VMwareWorkstation 的安装目录，执行下列命令，进行碎片整理。只需要对没有编号 vmdk 文件调用命令就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vmware-vdiskmanager -d ubuntu18.vmwarevm/虚拟磁盘.vmdk</span><br><span class="line">  Defragment: 100% <span class="keyword">done</span>.</span><br><span class="line">Defragmentation completed successfully.</span><br></pre></td></tr></table></figure>

<p>接下来压缩空间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vmware-vdiskmanager -k ubuntu18.vmwarevm/虚拟磁盘.vmdk</span><br><span class="line">  Shrink: 100% <span class="keyword">done</span>.</span><br><span class="line">Shrink completed successfully.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>碎片整理和压缩空间也有图形化界面，就在 设置 -&gt; 磁盘 对应的选项。</p>
</blockquote>
</li>
<li><p>使用 VMware Tools 的相关命令</p>
<p>前提是你已经安装了 Vmware-Tools 增强工具，进入虚拟机后，可以直接使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vmware-toolbox-cmd disk list</span><br><span class="line">$ sudo vmware-toolbox-cmd disk shrink /</span><br><span class="line"></span><br><span class="line">Progress: 7 [=&gt;         ]</span><br></pre></td></tr></table></figure></li>
</ol>
<p>参考：</p>
<p><a href="https://zzqcn.github.io/misc/vmware/reduce-disk-size.html#vmware">https://zzqcn.github.io/misc/vmware/reduce-disk-size.html#vmware</a><br><a href="https://blog.csdn.net/Michael__One/article/details/103850274">https://blog.csdn.net/Michael__One/article/details/103850274</a></p>
<h3 id="共享文件夹不显示"><a href="#共享文件夹不显示" class="headerlink" title="共享文件夹不显示"></a>共享文件夹不显示</h3><p>内核版本大于 4.0 的虚拟机，使用下列命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vmhgfs-fuse .host:/ /mnt/hgfs -o subtype=vmhgfs-fuse,allow_other</span><br></pre></td></tr></table></figure>

<h3 id="ubuntu-重置网络配置"><a href="#ubuntu-重置网络配置" class="headerlink" title="ubuntu 重置网络配置"></a>ubuntu 重置网络配置</h3><p>ubuntu 虚拟机突然崩了，重新进入后无法连接网络，重置网络配置就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service network-manager stop</span><br><span class="line">$ sudo <span class="built_in">rm</span> /var/lib/NetworkManager/NetworkManager.state</span><br><span class="line">$ sudo service network-manager start</span><br></pre></td></tr></table></figure>

<h3 id="安装-IDA-pro"><a href="#安装-IDA-pro" class="headerlink" title="安装 IDA pro"></a>安装 IDA pro</h3><p>首先安装 <a href="https://wiki.winehq.org/Ubuntu">wine</a>,直接根据文档进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dpkg --add-architecture i386</span><br><span class="line">$ sudo <span class="built_in">mkdir</span> -pm755 /etc/apt/keyrings</span><br><span class="line">$ sudo wget -O /etc/apt/keyrings/winehq-archive.key https://dl.winehq.org/wine-builds/winehq.key</span><br><span class="line"><span class="comment"># 根据自己的系统版本进行选择</span></span><br><span class="line">$ sudo wget -NP /etc/apt/sources.list.d/ https://dl.winehq.org/wine-builds/ubuntu/dists/focal/winehq-focal.sources</span><br><span class="line"><span class="comment"># 安装稳定版</span></span><br><span class="line">$ sudo apt install --install-recommends winehq-stable</span><br><span class="line">$ wine --version</span><br><span class="line">wine-8.0.2</span><br></pre></td></tr></table></figure>

<p>整个安装过程没有出现问题，接下来安装 python，这里需要注意的是可能需要使用 python310 的版本，因为我使用 python39 安装后，启动 IDA 一直出现异常，使用 python310 就没有问题，具体原因未知。</p>
<p>使用 python 官方的安装包无法安装，这里使用的是 github 上的一个项目 <a href="https://github.com/adang1345/PythonWin7">PythonWin7</a>，直接下载 <code>python-3.10.9-amd64-full.exe</code> 进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wine python-3.10.9-amd64-full.exe</span><br></pre></td></tr></table></figure>

<p>运行上面的命令后，安装图形界面进行安装，这里需要勾选添加到环境变量中的选项，我这里的安装目录为 <code>C:\python310</code>，实际对应的目录为 <code>~/.wine/drive_c/Python310</code> 。</p>
<p>接下来运行 <code>idapyswitch.exe</code>，选择 python 环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wine tools/IDA7.7_Portable/idapyswitch.exe <span class="comment"># 根据自己的实际位置进行修改</span></span><br></pre></td></tr></table></figure>

<p>上面的命令实际上就是添加了注册表：<code>HKEY_CURRENT_USER\Software\Hex-Rays\IDA</code> 中的 <code>Python3TargetDLL</code> 的值，这里需要注意的是该值被修改为了 <code>C:\python310\python310.dll</code>，但是实际上却没有这个 dll 文件，需要手动修改为 <code>C:\python310\python3.dll</code>，否则启动 IDA pro 时会出现异常。到这里 IDApython 的环境就安装完成了。</p>
<p>接下来启动 IDA，完美的启动起来了，所有的 IDApython 插件也完美的加载了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wine tools/IDA7.7_Portable/ida.exe <span class="comment"># 根据自己的实际位置进行修改</span></span><br></pre></td></tr></table></figure>

<p>如果需要安装 python 库，也可以直接使用pip 进行安装，例如安装 <code>yara-python==4.2.0</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wine pip install yara-python==4.2.0</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.debugwar.com/article/activate-IDAPython-with-wine-IDA-under-linux">https://www.debugwar.com/article/activate-IDAPython-with-wine-IDA-under-linux</a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://voidchen.cn/1050TI%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9A%84Ubuntu18%E5%AE%89%E8%A3%85%E5%AE%9E%E8%AE%B0/">双显卡 1050TI 笔记本的 Ubuntu18 安装实记</a><br><a href="https://linuxconfig.org/how-to-install-the-nvidia-drivers-on-ubuntu-18-04-bionic-beaver-linux">How to install the NVIDIA drivers on Ubuntu 18.04 Bionic Beaver Linux </a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux 使用</tag>
      </tags>
  </entry>
  <entry>
    <title>r2Frida环境配置及使用</title>
    <url>/2019/12/21/r2Frida%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>本机环境：ubuntu 18.04</p>
</blockquote>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="安装-redare2"><a href="#安装-redare2" class="headerlink" title="安装 redare2"></a>安装 <a href="https://github.com/radareorg/radare2">redare2</a></h2><p>参考 github 使用下列命令安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/radare/radare2.git</span><br><span class="line">$ cd radare2</span><br><span class="line">$ ./sys/user.sh</span><br></pre></td></tr></table></figure>
<img src="/2019/12/21/r2Frida%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/2019-12-22-00-01-14.png" class="">

<p>安装完成之后，配置 <code>PATH</code> 变量，我这里将下列文本添加值 <code>.zshrc</code> 和 <code>.bashrc</code> 中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PATH=/home/ckcat/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>配置好之后，执行 <code>source .zshrc</code> 命令,然后执行 <code>r2</code> 命令，显示如下则表示安装成功。</p>
<img src="/2019/12/21/r2Frida%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/2019-12-22-00-06-27.png" class="">


<h2 id="安装-r2frida"><a href="#安装-r2frida" class="headerlink" title="安装 r2frida"></a>安装 <a href="https://github.com/nowsecure/r2frida">r2frida</a></h2><p>参考 github ，首先安装依赖，使用以下命令安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install -y make gcc libzip-dev nodejs npm curl pkg-config git</span><br></pre></td></tr></table></figure>
<p>使用 r2pn 安装 r2frida </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ r2pm -ci r2frida</span><br></pre></td></tr></table></figure>
<p>如果出现 <code>$R2PM_DBDIR: No such file or directory.</code> 错误，运行 <code>r2pm init</code> 初始化一下。</p>
<img src="/2019/12/21/r2Frida%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/2019-12-22-00-14-37.png" class="">

]]></content>
      <categories>
        <category>frida</category>
      </categories>
      <tags>
        <tag>radare2 frida</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh基本使用</title>
    <url>/2019/12/14/ssh%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>转载：<a href="https://abcdabcd987.com/ssh/">https://abcdabcd987.com/ssh/</a></p>
</blockquote>
<!-- TOC -->

<ul>
<li><a href="#%E7%BA%A6%E5%AE%9A">约定</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80">基础</a></li>
<li><a href="#%E5%AE%89%E8%A3%85-openssh-server">安装 OpenSSH Server</a></li>
<li><a href="#%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%85%A5">免密码登入</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E5%88%AB%E5%90%8D">配置别名</a></li>
<li><a href="#%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6">传输文件</a></li>
<li><a href="#%E4%BF%9D%E6%8C%81%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C">保持程序在后台运行</a></li>
<li><a href="#%E5%8F%8D%E5%90%91%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%BE%8B%E5%AD%901">反向端口转发：例子1</a></li>
<li><a href="#%E5%8F%8D%E5%90%91%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%BE%8B%E5%AD%902">反向端口转发：例子2</a></li>
<li><a href="#%E5%8F%8D%E5%90%91%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%BE%8B%E5%AD%903">反向端口转发：例子3</a></li>
<li><a href="#%E6%AD%A3%E5%90%91%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91">正向端口转发</a></li>
<li><a href="#%E7%94%A8%E4%BD%9C-socks5-%E4%BB%A3%E7%90%86">用作 SOCKS5 代理</a></li>
<li><a href="#%E4%BC%A0%E9%80%92%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2">传递图形界面</a></li>
</ul>
<!-- /TOC -->

<h1 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h1><p>本文不讲解 Linux 使用方法，只讲解机器之间的通信方法。<br>下文中行首的 local$ 以及 remote$ 等为命令行的提示符，不是输入的内容，用于区分当前是在哪台机子上。</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>在 Linux 系统上 SSH 是非常常用的工具，通过 SSH Client 我们可以连接到运行了 SSH Server 的远程机器上。SSH Client 的基本使用方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh user@remote -p port</span><br></pre></td></tr></table></figure>
<ul>
<li>user 是你在远程机器上的用户名，如果不指定的话默认为当前用户</li>
<li>remote 是远程机器的地址，可以是 IP，域名，或者是后面会提到的别名</li>
<li>port 是 SSH Server 监听的端口，如果不指定的话就为默认值 22</li>
</ul>
<p>实际上，知道了上面这三个参数，用任意的 SSH Client 都能连接上 SSH Server，例如在 Windows 上 PuTTY 就是很常用的 SSH Client。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh user@remote -p port</span><br><span class="line">user@remote&#x27;s password:</span><br></pre></td></tr></table></figure>
<p>在执行了 ssh 命令之后，远程机器会询问你的密码。在输入密码的时候，屏幕上不会显示明文密码，也不会显示 <code>******</code>，这样别人就不会看到你的密码长度了，按下回车即可登入。</p>
<p>登入之后，你就可以操作远程机器啦！</p>
<h1 id="安装-OpenSSH-Server"><a href="#安装-OpenSSH-Server" class="headerlink" title="安装 OpenSSH Server"></a>安装 OpenSSH Server</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh user@remote -p port </span><br><span class="line">ssh: connect to host remote port 22: Connection refused</span><br></pre></td></tr></table></figure>
<p>如果你遇到了上面的消息，说明在远程机器上没有安装 <code>SSH Server</code>，特别地，如果远程机器运行的是 <code>Ubuntu Desktop</code> 系统，那么默认是没有安装 <code>SSH Server</code> 的。这个时候，你可以联系管理员让他安装 <code>SSH Server</code>，或者如果你有 <code>sudo</code> 权限的话，可以执行下面命令安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<h1 id="免密码登入"><a href="#免密码登入" class="headerlink" title="免密码登入"></a>免密码登入</h1><p>每次 <code>ssh</code> 都要输入密码是不是很烦呢？与密码验证相对的，是公钥验证。也就是说，要实现免密码登入，首先要设置 <code>SSH</code> 钥匙。</p>
<p>执行 <code>ssh-keygen</code> 即可生成 <code>SSH</code> 钥匙，一路回车即可。<code>Windows</code> 用户可以使用 <code>PuTTY</code> 配套的 <code>PuTTYgen</code> 工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/user/.ssh/id_rsa):</span><br><span class="line">Created directory &#x27;/home/user/.ssh&#x27;.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /home/user/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/user/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:47VkvSjlFhKRgz/6RYdXM2EULtk9TQ65PDWJjYC5Jys user@local</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|       ...o...X+o|</span><br><span class="line">|      . o+   B=Oo|</span><br><span class="line">|       .....ooo*=|</span><br><span class="line">|        o+ooo.+ .|</span><br><span class="line">|       .SoXo.  . |</span><br><span class="line">|      .E X.+ .   |</span><br><span class="line">|       .+.= .    |</span><br><span class="line">|        .o       |</span><br><span class="line">|                 |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>
<p>这段话告诉了我们，生成的公钥放在了 <code>~/.ssh/id_rsa.pub</code>，私钥放在了 <code>~/.ssh/id_rsa</code>。接下来，我们要让远程机器记住我们的公钥。最简单的方法是 <code>ssh-copy-id user@remote -p port</code> .</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh-copy-id user@remote -p port</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/home/user/.ssh/id_rsa.pub&quot;</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">user@remote&#x27;s password:</span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh &#x27;user@remote&#x27; -p port&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure>
<p><code>ssh-copy-id</code> 在绝大多数发行版上都有预装，在 <code>Mac</code> 上也可以通过 <code>brew install ssh-copy-id</code> 一键安装。</p>
<p>在没有 <code>ssh-copy-id</code> 的情况下（比如在 <code>Windows</code> 上），也是可以轻松做到这件事的。用命令的话也是一句话搞定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh user@remote -p port &#x27;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#x27; &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>这句话的意思是，在远端执行新建 <code>.ssh</code> 文件夹，并把本地的 <code>~/.ssh/id_rsa.pub</code> （也就是公钥）追加到远端的 <code>.ssh/authorized_keys</code> 中。当然，不使用这条命令的话，你也可以手动操作这个过程，即先复制公钥，再登入远程机器，粘贴到 <code>.ssh/authorized_keys</code> 当中。</p>
<p>在完成这一步之后，ssh 进入远程机器时就不用输入密码了。Windows 用户在 PuTTY 上面设置登入用户名和 PuTTYgen 生成的私钥之后也可以免密码登入。</p>
<h1 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h1><p>每次都输入 <code>ssh user@remote -p port</code>，时间久了也会觉得很麻烦，特别是当 <code>user</code>, <code>remote</code> 和 <code>port</code> 都得输入，而且还不好记忆的时候。配置别名可以让我们进一步偷懒。</p>
<p>比如我想用 <code>ssh lab</code> 来替代上面这么一长串，那么在 <code>~/.ssh/config</code> 里面追加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host lab</span><br><span class="line">    HostName remote</span><br><span class="line">    User user</span><br><span class="line">    Port port</span><br></pre></td></tr></table></figure>
<p>保存之后，即可用 <code>ssh lab</code> 登入，如果还配置了公钥登入，那就连密码都不用输入了。</p>
<p><code>Windows</code> 用户使用 <code>PuTTY</code> 直接保存配置即可。</p>
<h1 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h1><p>在两台机之间传输文件可以用 <code>scp</code>，它的地址格式与 <code>ssh</code> 基本相同，都是可以省略用户名和端口，稍微的差别在与指定端口时用的是大写的 <code>-P</code> 而不是小写的。不过，如果你已经配置了别名，那么这都不重要，因为 <code>scp</code> 也支持直接用别名。<code>scp</code> 用起来很简单，看看下面的例子就明白了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 把本地的 /path/to/local/file 文件传输到远程的 /path/to/remote/file</span><br><span class="line">scp -P port /path/to/local/file user@remote:/path/to/remote/file</span><br><span class="line"></span><br><span class="line"># 也可以使用别名</span><br><span class="line">scp /path/to/local/file lab:/path/to/remote/file</span><br><span class="line"></span><br><span class="line"># 把远程的 /path/to/remote/file 下载到本地的 /path/to/local/file</span><br><span class="line">scp lab:/path/to/remote/file /path/to/local/file</span><br><span class="line"></span><br><span class="line"># 远程的默认路径是家目录</span><br><span class="line"># 下面命令把当前目录下的 file 传到远程的 ~/dir/file</span><br><span class="line">scp file lab:dir/file</span><br><span class="line"></span><br><span class="line"># 加上 -r 命令可以传送文件夹</span><br><span class="line"># 下面命令可以把当前目录下的 dir 文件夹传到远程的家目录下</span><br><span class="line">scp -r dir lab:</span><br><span class="line"></span><br><span class="line"># 别忘了 . 可以用来指代当前目录</span><br><span class="line"># 下面命令可以把远程的 ~/dir 目录下载到当前目录里面</span><br><span class="line">scp -r lab:dir/ .</span><br></pre></td></tr></table></figure>
<p><code>Windows</code> 用户可以使用 <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">PuTTY</a> 配套的 <code>PSCP</code>。</p>
<p>如果觉得使用命令行传输文件浑身不自在，你还可以使用 SFTP 协议。任何支持 SFTP 协议的客户端都能用你的 SSH 账号信息登入并管理文件，比如开源的有图形化界面的FTP客户端 <a href="https://filezilla-project.org/download.php?type=client">FileZilla</a>。别忘了，在这些客户端里面，你也可以指定你的私钥（<code>~/.ssh/id_rsa</code>），然后就能做到无密码登入了。</p>
<h1 id="保持程序在后台运行"><a href="#保持程序在后台运行" class="headerlink" title="保持程序在后台运行"></a>保持程序在后台运行</h1><p>有时候你想要在远程的机器上跑一个需要长时间运行的程序，比如一些计算，然后当你睡了一觉再登入远程的机子上却发现什么结果都没有。这是因为一旦 ssh 进程退出，所有它之前启动的程序都会被杀死。那么有什么办法可以保持程序在后台运行呢？</p>
<p>你需要在远程的机子上使用 <code>tmux</code>。<code>tmux</code> 是一个会话管理程序，他会保持程序一直运行着。在 Ubuntu 上你可以通过 <code>sudo apt-get install tmux</code> 来安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remote$ tmux</span><br></pre></td></tr></table></figure>
<p>这样你就进入到了 <code>tmux</code> 管理的会话中，之后你再运行任何东西都不会因为你退出 ssh 而被杀死。要暂时离开这个会话，可以先按下 <code>ctrl+b</code> 再按下 <code>d</code>。要恢复之前的会话，只需要执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remote$ tmux attach</span><br></pre></td></tr></table></figure>
<p><code>tmux</code> 还能管理多个窗口、水平竖直切分、复制粘贴等等，你可以看看<a href="http://blog.jobbole.com/87584/">这篇不错的文章</a>来入门。</p>
<p>如果你是Mac用户，那么十分幸运的是，你几乎不需要任何学习，只要把你的终端由系统自带的 <code>Terminal</code> 换成 <code>iTerm 2</code>。<code>iTerm 2</code> 自带超好的 <code>tmux</code> 支持，你可以像操作本机的标签页一样操作 <code>tmux</code> 会话。你只需要在新建会话的时候使用 <code>tmux -CC</code>，在恢复的时候使用 <code>tmux -CC attach</code> 即可。具体的可以参见 <a href="https://gitlab.com/gnachman/iterm2/wikis/TmuxIntegration">iTerm2 and tmux Integration</a>。</p>
<p>最后强调一遍，tmux 应该运行在远程的机子上，而不是本机上，否则程序在 ssh 退出时依然会被杀死。</p>
<h1 id="反向端口转发：例子1"><a href="#反向端口转发：例子1" class="headerlink" title="反向端口转发：例子1"></a>反向端口转发：例子1</h1><p>相信很多人都会有这样的需求：我实验室的机器和宿舍的机器都处在局域网中，但我需要在宿舍访问实验室的机器，或者反过来。这个时候，你需要一台处在公网的机器，如果没有的话，可以考虑腾讯云或者阿里云的学生优惠。</p>
<p>假设现在你有一台处在公网的机器 <code>jumpbox</code>，这台机器是在任何地方都能访问到的；你在实验室也有一台机子 <code>lab</code>，这台机子只能在实验室内部访问，但他可以访问公网，你希望能在任何地方都能访问这台机器。使用 <code>ssh -R</code> 可以轻松地做到这个事情。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lab$ ssh -R 10022:localhost:22 jumpbox</span><br><span class="line">jumpbox$ ssh user@localhost -p 10022</span><br><span class="line">lab$ </span><br></pre></td></tr></table></figure>
<p>如果上面这个过程成功了，就说明在你执行 <code>ssh -R 10022:localhost:22 jumpbox</code> 之后，你成功地将 <code>lab</code> 上的 22 端口反向转发到了 <code>jumpbox</code> 的 10022 端口。只要保持这个 <code>ssh</code> 不断，任何一台机器都可以首先连接到 <code>jumpbox</code>，然后通过 <code>ssh user@localhost -p 10022</code> 连回到 <code>lab</code>。可以看到，这里 <code>jumpbox</code> 起到了一个跳板的作用，所以我们把它称作跳板机。</p>
<p>不过上面这么做并不稳健，如果因为网络波动导致 <code>ssh -R</code> 那个连接断了，那么从 <code>jumpbox</code> 就完全失去了到 <code>lab</code> 的控制。万幸的是，有一个叫做 <code>autossh</code> 的软件，可以自动的检测断线，并在断线的时候重连。在 Ubuntu 上你可以使用 <code>sudo apt-get install autossh</code> 来安装，在 Mac 上则是 <code>brew install autossh</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lab$ autossh -NfR 10022:localhost:22 jumpbox</span><br></pre></td></tr></table></figure>
<p>上面这句话里面 <code>-N</code> 表示非不执行命令，只做端口转发；<code>-f</code> 表示在后台运行，也就是说，这句话执行之后 <code>autossh</code> 就在后台默默工作啦；<code>-R 10022:localhost:22</code> 就是把本地的22端口转发到远程的10022端口。</p>
<p>现在，任何一台电脑先连上跳板机，就可以连回内网的机子啦！</p>
<p>你甚至可以将这句话设置为开机时运行：在 <code>/etc/rc.local</code> 里面 <code>exit 0</code> 这句话之前加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su - user -c autossh -NfR 10022:localhost:22 jumpbox</span><br></pre></td></tr></table></figure>
<p>其中 <code>user</code> 是你的用户名。需要注意的是，如果你需要开机时运行 <code>autossh</code>，你需要配置公钥登入，因为开机运行的时候是没有交互界面让你来输入密码的。</p>
<p>这里顺带说一句，你可以绑定1024到65535之间的任意端口，只要这个端口之前没有程序在用就行。</p>
<h1 id="反向端口转发：例子2"><a href="#反向端口转发：例子2" class="headerlink" title="反向端口转发：例子2"></a>反向端口转发：例子2</h1><p>还是反向端口转发，再举一个很常见的例子：我在本地跑了一个网站，我想临时把我的网站发给朋友看看。你可以很容易的复现这个实验：在本地运行 <code>python -m SimpleHTTPServer</code> 即可在本地的8000端口启动一个网站，你可以在浏览器中通过 <code>http://localhost:8000/</code> 看到。下面我们想让远方的朋友看到这个网站。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh -NR 0.0.0.0:18000:localhost:8000 jumpbox</span><br></pre></td></tr></table></figure>
<p>远方的朋友即可通过 <code>http://jumpbox:18000/</code> 看到了。注意到这里和上面的命令有一个小小的不同，就是多了 <code>0.0.0.0</code>，这告诉 <code>ssh</code>，要把18000端口绑定在远端的所有IP上。如果像之前那样省略的话，缺省值是只绑定在 <code>localhost</code>，也就是只有在 <code>jumpbox</code> 本机才可以访问，而其他人都不能访问。</p>
<h1 id="反向端口转发：例子3"><a href="#反向端口转发：例子3" class="headerlink" title="反向端口转发：例子3"></a>反向端口转发：例子3</h1><p>比方说在本地的<code>127.0.0.1:1080</code>运行了HTTP代理服务，现在我想让另一台机子 <code>remote</code> 也能够使用这个HTTP代理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh -NR 11080:localhost:1080 remote</span><br><span class="line">local$ ssh remote</span><br><span class="line">remote$ export http_proxy=http://127.0.0.1:11080/</span><br><span class="line">remote$ export https_proxy=http://127.0.0.1:11080/</span><br><span class="line">remote$ curl http://ifconfig.co</span><br></pre></td></tr></table></figure>
<p>看看返回的IP，是不是 <code>remote</code> 也用上了代理？</p>
<h1 id="正向端口转发"><a href="#正向端口转发" class="headerlink" title="正向端口转发"></a>正向端口转发</h1><p>反向端口转发是把本机的端口转发到远程的机子上；与之对应，正向端口转发则是把远程的端口转发到本地。</p>
<p>比方说，之前我们把 <code>lab</code> 的22端口反向转发到了 <code>jumpbox</code> 的10022端口，现在我想把它转发到本机的20022端口，只需要执行 <code>ssh -L</code> 就行了，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh -NL 20022:localhost:10022 jumpbox</span><br><span class="line">local$ ssh localhost -p 20022</span><br><span class="line">lab$ </span><br></pre></td></tr></table></figure>
<h1 id="用作-SOCKS5-代理"><a href="#用作-SOCKS5-代理" class="headerlink" title="用作 SOCKS5 代理"></a>用作 SOCKS5 代理</h1><p>要是想要在家访问公司内网的一些网站，但是公司又没有提供进入内网的VPN，那怎么办呢？通过 <code>ssh -D</code> 可以在本地建立起一个 <code>SOCKS5</code> 代理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh -ND 1080 workplace</span><br></pre></td></tr></table></figure>
<p>如果 <code>workplace</code> 处在内网，不要忘记前面讲到可以用反向端口转发和跳板机来解决这个问题。现在，你可以在浏览器的设置里面，把代理服务器设成 <code>socks5://127.0.0.1:1080</code>，然后你就可以看到 <code>workplace</code> 能看到的所有网站啦。</p>
<h1 id="传递图形界面"><a href="#传递图形界面" class="headerlink" title="传递图形界面"></a>传递图形界面</h1><p>上面我们都是在运行命令行程序，那如果远程有一些程序是不得不用图形界面的话，是不是无解了呢？实际上，恰恰相反，X11的设计天生就支持这样的行为。</p>
<p>首先，我们需要在本机装上 X Server：Linux 桌面用户本身就已经有了 X Server，Windows 用户可以使用 <a href="http://www.straightrunning.com/XmingNotes/">Xming</a>，Mac 用户需要使用 <a href="https://www.xquartz.org/">XQuartz</a> 。</p>
<p>安装好了 X Server 之后，我们通过 <code>ssh -X</code> 进行连接，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh -X remote</span><br><span class="line">remote$ xeyes</span><br></pre></td></tr></table></figure>
<p>现在你应该会看到一对傻傻的眼睛，这就说明成功了，注意，这个眼睛是跑在远程的，而输入和输出都是在本地。这个方法几乎可以运行任何图形界面的程序，比如你可以试试看运行 <code>nautilus</code> 或者 <code>firefox</code>。</p>
<img src="/2019/12/14/ssh%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/2019-12-14-11-13-04.png" class="">]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>vim插件安装使用整理记录</title>
    <url>/2020/03/21/vim%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍:"></a>介绍:</h2><p>安装需要Git，触发git clone,默认将每一个指定特定格式插件的仓库复制到~&#x2F;.vim&#x2F;bundle&#x2F;. 搜索需要Curl支持。</p>
<p>Windows用户请直接访问Windows setup. 如果有任何问题, 请参考 FAQ. 查看 Tips 获取相关高级配置。</p>
<p>使用 non-POSIX shells, 比如比较流行对 Fish shell, 需要额外对步骤。 请查看 FAQ.</p>
<h2 id="初始安装-Vundle："><a href="#初始安装-Vundle：" class="headerlink" title="初始安装 Vundle："></a>初始安装 Vundle：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</span><br></pre></td></tr></table></figure>

<h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件 :"></a>配置插件 :</h2><p>请将以下加在 .vimrc 方可使用Vundle. 删掉你不需要的插件, 这些只是用做示例.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set nocompatible              &quot; 去除VI一致性,必须</span><br><span class="line">filetype off                  &quot; 必须</span><br><span class="line"></span><br><span class="line">&quot; 设置包括vundle和初始化相关的runtime path</span><br><span class="line">set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">&quot; 另一种选择, 指定一个vundle安装插件的路径</span><br><span class="line">&quot;call vundle#begin(&#x27;~/some/path/here&#x27;)</span><br><span class="line"></span><br><span class="line">&quot; 让vundle管理插件版本,必须</span><br><span class="line">Plugin &#x27;VundleVim/Vundle.vim&#x27;</span><br><span class="line"></span><br><span class="line">&quot; 以下范例用来支持不同格式的插件安装.</span><br><span class="line">&quot; 请将安装插件的命令放在vundle#begin和vundle#end之间.</span><br><span class="line">&quot; Github上的插件</span><br><span class="line">&quot; 格式为 Plugin &#x27;用户名/插件仓库名&#x27;</span><br><span class="line">Plugin &#x27;tpope/vim-fugitive&#x27;</span><br><span class="line">&quot; 来自 http://vim-scripts.org/vim/scripts.html 的插件</span><br><span class="line">&quot; Plugin &#x27;插件名称&#x27; 实际上是 Plugin &#x27;vim-scripts/插件仓库名&#x27; 只是此处的用户名可以省略</span><br><span class="line">Plugin &#x27;L9&#x27;</span><br><span class="line">&quot; 由Git支持但不再github上的插件仓库 Plugin &#x27;git clone 后面的地址&#x27;</span><br><span class="line">Plugin &#x27;git://git.wincent.com/command-t.git&#x27;</span><br><span class="line">&quot; 本地的Git仓库(例如自己的插件) Plugin &#x27;file:///+本地插件仓库绝对路径&#x27;</span><br><span class="line">Plugin &#x27;file:///home/gmarik/path/to/plugin&#x27;</span><br><span class="line">&quot; 插件在仓库的子目录中.</span><br><span class="line">&quot; 正确指定路径用以设置runtimepath. 以下范例插件在sparkup/vim目录下</span><br><span class="line">Plugin &#x27;rstacruz/sparkup&#x27;, &#123;&#x27;rtp&#x27;: &#x27;vim/&#x27;&#125;</span><br><span class="line">&quot; 安装L9，如果已经安装过这个插件，可利用以下格式避免命名冲突</span><br><span class="line">Plugin &#x27;ascenator/L9&#x27;, &#123;&#x27;name&#x27;: &#x27;newL9&#x27;&#125;</span><br><span class="line"></span><br><span class="line">&quot; 你的所有插件需要在下面这行之前</span><br><span class="line">call vundle#end()            &quot; 必须</span><br><span class="line">filetype plugin indent on    &quot; 必须 加载vim自带和插件相应的语法和文件类型相关脚本</span><br><span class="line">&quot; 忽视插件改变缩进,可以使用以下替代:</span><br><span class="line">&quot;filetype plugin on</span><br><span class="line">&quot;</span><br><span class="line">&quot; 简要帮助文档</span><br><span class="line">&quot; :PluginList       - 列出所有已配置的插件</span><br><span class="line">&quot; :PluginInstall    - 安装插件,追加 `!` 用以更新或使用 :PluginUpdate</span><br><span class="line">&quot; :PluginSearch foo - 搜索 foo ; 追加 `!` 清除本地缓存</span><br><span class="line">&quot; :PluginClean      - 清除未使用插件,需要确认; 追加 `!` 自动批准移除未使用插件</span><br><span class="line">&quot;</span><br><span class="line">&quot; 查阅 :h vundle 获取更多细节和wiki以及FAQ</span><br><span class="line">&quot; 将你自己对非插件片段放在这行之后</span><br></pre></td></tr></table></figure>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件:"></a>安装插件:</h2><p>运行 <code>vim</code> 再运行 <code>:PluginInstall</code></p>
<p>通过命令行直接安装 <code>vim +PluginInstall +qall</code></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:h vundle</span><br></pre></td></tr></table></figure>

<h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:PluginInstall</span><br><span class="line">:PluginUpdate</span><br><span class="line">:PluginSearch</span><br><span class="line">:PluginList</span><br><span class="line">:PluginClean</span><br></pre></td></tr></table></figure>

<h1 id="安装插件-1"><a href="#安装插件-1" class="headerlink" title="安装插件"></a>安装插件</h1><h2 id="安装-ctrlp-模糊搜索文件插件"><a href="#安装-ctrlp-模糊搜索文件插件" class="headerlink" title="安装 ctrlp 模糊搜索文件插件"></a>安装 ctrlp 模糊搜索文件插件</h2><p>打开 <code>.vimrc</code> 加入下面内容后，执行 <code>:PluginInstall</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Plugin &#x27;ctrlpvim/ctrlp.vim&#x27;</span><br></pre></td></tr></table></figure>
<p>ctrlp 插件使用</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ctrl + p</td>
<td>开启文件搜索</td>
</tr>
<tr>
<td>F5</td>
<td>刷新当前目录内容</td>
</tr>
<tr>
<td>ctrl + f&#x2F;b</td>
<td>切换显示模式</td>
</tr>
<tr>
<td>ctrl + d</td>
<td>只搜索文件名</td>
</tr>
<tr>
<td>ctrl + r</td>
<td>正则查找模式</td>
</tr>
<tr>
<td>ctrl + j&#x2F;k</td>
<td>搜索结果中移动光标</td>
</tr>
<tr>
<td>ctrl + t</td>
<td>新标签页打开</td>
</tr>
<tr>
<td>ctrl + v&#x2F;x</td>
<td>垂直分割打开 &#x2F; 水平分割打开</td>
</tr>
<tr>
<td>ctrl + n&#x2F;p</td>
<td>上下翻阅上次搜索历史</td>
</tr>
<tr>
<td>ctrl + y</td>
<td>在选中文件的父级目录创建新文件</td>
</tr>
<tr>
<td>ctrl + z</td>
<td>标记选择多个文件</td>
</tr>
<tr>
<td>ctrl + o</td>
<td>选择打开方式</td>
</tr>
</tbody></table>
<h2 id="安装-vim-autoformat-自动格式化插件"><a href="#安装-vim-autoformat-自动格式化插件" class="headerlink" title="安装 vim-autoformat 自动格式化插件"></a>安装 vim-autoformat 自动格式化插件</h2><p><code>.vimrc</code> 中增加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Plugin &#x27;Chiel92/vim-autoformat&#x27;</span><br></pre></td></tr></table></figure>
<p>增加快捷键配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">noremap &lt;F3&gt; :Autoformat&lt;CR&gt;</span><br></pre></td></tr></table></figure>
<p>增加对python代码的支持,安装autopep8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install --upgrade autopep8</span><br></pre></td></tr></table></figure>
<p>按F3开启自动格式化。</p>
<h1 id="使用-LSP-插件"><a href="#使用-LSP-插件" class="headerlink" title="使用 LSP 插件"></a>使用 LSP 插件</h1><h2 id="安装-vim-plug"><a href="#安装-vim-plug" class="headerlink" title="安装 vim-plug"></a>安装 vim-plug</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure>
<p>如果由于网络问题，无法访问 <a href="https://raw.githubusercontent.com/">https://raw.githubusercontent.com</a> ，可以手动安装。</p>
<ol>
<li>下载 <code>plug.vim</code> 。</li>
<li>将 <code>plug.vim</code> 移动到 <code>~/.vim/autoload/plug.vim</code> 。</li>
</ol>
<p>安装成功后修改 <code>~/.vimrc</code> 声明插件安装，然后进入 VIM 中运行 <code>:PlugInstall</code> 命令安装插件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; Plugins will be downloaded under the specified directory.</span></span><br><span class="line"><span class="string">call plug#begin(&#x27;~/.vim/plugged&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 声明需要安装的插件</span><br><span class="line">Plug <span class="string">&#x27;prabirshrestha/vim-lsp&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;mattn/vim-lsp-settings&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;prabirshrestha/asyncomplete.vim&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;prabirshrestha/asyncomplete-lsp.vim&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;piec/vim-lsp-clangd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; List ends here. Plugins become visible to Vim after this call.</span></span><br><span class="line"><span class="string">call plug#end()</span></span><br></pre></td></tr></table></figure>
<p>更多信息参考：<a href="https://github.com/junegunn/vim-plug">https://github.com/junegunn/vim-plug</a></p>
<h2 id="安装-vim-lsp"><a href="#安装-vim-lsp" class="headerlink" title="安装 vim-lsp"></a>安装 vim-lsp</h2><p>安装 vim-lsp 插件比较简单，上面安装 vim-plug 插件中已经安装好了。</p>
<p>这里主要讲一下注册服务。</p>
<p>例如：注册 python 服务。</p>
<p>首先安装 <code>python-language-server</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install python-language-server</span><br></pre></td></tr></table></figure>

<p>然后在 <code>~/.vimrc</code> 中，添加下列内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> executable(<span class="string">&#x27;pyls&#x27;</span>)</span><br><span class="line">    au User lsp_setup call lsp<span class="comment">#register_server(&#123;</span></span><br><span class="line">        \ <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;pyls&#x27;</span>,</span><br><span class="line">        \ <span class="string">&#x27;cmd&#x27;</span>: &#123;server_info-&gt;[<span class="string">&#x27;pyls&#x27;</span>]&#125;,</span><br><span class="line">        \ <span class="string">&#x27;whitelist&#x27;</span>: [<span class="string">&#x27;python&#x27;</span>],</span><br><span class="line">        \ &#125;)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>更详细的信息参考： <a href="https://github.com/prabirshrestha/vim-lsp/wiki/Servers-Python">https://github.com/prabirshrestha/vim-lsp/wiki/Servers-Python</a> 。</p>
<p>例如：安装 Clangd - C&#x2F;C++ 。</p>
<p>首先安装 llvm。</p>
<p>然后将下面内容添加到 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> executable(<span class="string">&#x27;clangd&#x27;</span>)</span><br><span class="line">    au User lsp_setup call lsp<span class="comment">#register_server(&#123;</span></span><br><span class="line">        \ <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;clangd&#x27;</span>,</span><br><span class="line">        \ <span class="string">&#x27;cmd&#x27;</span>: &#123;server_info-&gt;[<span class="string">&#x27;clangd&#x27;</span>, <span class="string">&#x27;-background-index&#x27;</span>]&#125;,</span><br><span class="line">        \ <span class="string">&#x27;whitelist&#x27;</span>: [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;cpp&#x27;</span>, <span class="string">&#x27;objc&#x27;</span>, <span class="string">&#x27;objcpp&#x27;</span>],</span><br><span class="line">        \ &#125;)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>最后安装 <code>piec/vim-lsp-clangd</code> 插件。</p>
<img src="/2020/03/21/vim%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/2021-11-23-20-09-17.png" class="" title="效果图">

<p>更多信息请参考：<a href="https://github.com/prabirshrestha/vim-lsp/wiki">https://github.com/prabirshrestha/vim-lsp/wiki</a> 。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>window下编译Frida</title>
    <url>/2021/08/17/window%E4%B8%8B%E7%BC%96%E8%AF%91Frida/</url>
    <content><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>安装 <code>VS2019</code> 选择 使用 <code>C++</code> 的桌面开发 ，并选择 对 <code>VS2017</code>（v141） 工具的 C++ Window XP 支持[已弃用] 组件，如下图所示。</p>
<img src="/2021/08/17/window%E4%B8%8B%E7%BC%96%E8%AF%91Frida/2021-08-17-22-08-29.png" class="">

<p>安装 <code>git</code> 和 <code>nodejs</code> , 并加入环境变量。</p>
<p>安装 <code>python3.8</code> ，安装目录为 <code>C:\Program Files (x86)\Python 3.8\</code> ，安装选项如下图所示。</p>
<img src="/2021/08/17/window%E4%B8%8B%E7%BC%96%E8%AF%91Frida/2021-08-17-22-12-47.png" class="">

<img src="/2021/08/17/window%E4%B8%8B%E7%BC%96%E8%AF%91Frida/2021-08-17-22-13-45.png" class="">

<p>这里需要注意， <code>python</code> 最好安装在系统盘，因为安装在其他盘在编译过程中可能会出现 <code>python</code> 执行子命令权限不足的情况。</p>
<p>安装好以上应用之后，在 <code>cmd</code> 中应该可以执行 <code>git</code> , <code>node</code> , <code>python</code>, <code>py</code> 这些命令。</p>
<h1 id="下载-Frida-源码并编译"><a href="#下载-Frida-源码并编译" class="headerlink" title="下载 Frida 源码并编译"></a>下载 Frida 源码并编译</h1><p>下载 Frida 源码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --recurse-submodules https://github.com/frida/frida</span><br></pre></td></tr></table></figure>
<p>等待源码下载完成，然后进入源码目录，执行下列命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ powershell</span><br><span class="line">PS&gt; Set-ExecutionPolicy -Scope Process -ExecutionPolicy Unrestricted</span><br><span class="line">PS&gt; .\releng\stage-python.ps1</span><br></pre></td></tr></table></figure>

<img src="/2021/08/17/window%E4%B8%8B%E7%BC%96%E8%AF%91Frida/2021-08-17-22-21-17.png" class="">

<p>等待命令运行完成，然后打开 <code>frida.sln</code> 文件直接 <code>F7</code> 编译源码。</p>
<p>在编译过程中，可能会出现下列错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">严重性	代码	说明	项目	文件	行	禁止显示状态</span><br><span class="line">错误	C2001	常量中有换行符	frida-core	e:\study\frida\build\tmp-windows\win32-debug\frida-core\src\fruity\keyed-archive.c	1050	</span><br><span class="line">严重性	代码	说明	项目	文件	行	禁止显示状态</span><br><span class="line">错误	C2146	语法错误: 缺少“)”(在标识符“_inner_error0_”的前面)	frida-core	e:\study\frida\build\tmp-windows\win32-debug\frida-core\src\fruity\keyed-archive.c	1051	</span><br></pre></td></tr></table></figure>
<p>这里需要将 <code>keyed-archive.c</code> 文件中的 <code>“%s”</code>换成 <code>&#39;%s&#39;</code> ，这是由于相应的 <code>c</code> 文件 <code>keyed-archive.c</code>  来源于 <code>vala</code> 文件 <code>keyed-archive.vala</code> ，所以需要将对应 <code>valva</code> 里的所有宽字符 <code>“”</code> 替换为 <code>&#39;&#39;</code> 。</p>
<img src="/2021/08/17/window%E4%B8%8B%E7%BC%96%E8%AF%91Frida/2021-08-17-22-31-57.png" class="">

<p>以上的所有错误修改完后，再编译即可成功.</p>
<h1 id="编译-frida-server"><a href="#编译-frida-server" class="headerlink" title="编译 frida-server"></a>编译 frida-server</h1><blockquote>
<p>环境：Ubuntu 18.04 </p>
</blockquote>
<p>根据官方文档，配置必要的环境，其中官方文档中提到的 <code>lib32stdc++-9-dev</code> 库安装不了，但是最后编译是没有问题的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential curl git libc6-dev-i386 nodejs npm python3-dev python3-pip</span><br></pre></td></tr></table></figure>

<p>配置 <code>ndk</code> 环境变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_NDK_ROOT=/home/ckcat/snap/sdk/ndk/22.1.7171670</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ANDROID_NDK_ROOT</span>:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>然后进入 <code>frida</code> 源码目录，执行下列命令进行编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make core-android-arm64    <span class="comment"># 编译 arm64 的 frida-server</span></span><br><span class="line">make core-android-arm        <span class="comment"># 编译 arm 的 frida-server</span></span><br></pre></td></tr></table></figure>
<p>执行以上命令，会自动下载对应的 <code>toolchain</code> 和 <code>sdk</code> ，编译好的</p>
<img src="/2021/08/17/window%E4%B8%8B%E7%BC%96%E8%AF%91Frida/2021-08-18-14-51-13.png" class="">


<p>如果因为网络原因无法自动下载，可以手动下载，官方 <code>toolchain</code> 和 <code>sdk</code> 下载地址如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://build.frida.re/deps/20210123/toolchain-linux-x86_64.tar.bz2</span><br><span class="line">https://build.frida.re/deps/20210123/sdk-linux-x86_64.tar.bz2</span><br><span class="line">https://build.frida.re/deps/20210123/sdk-android-arm.tar.bz2</span><br><span class="line">https://build.frida.re/deps/20210123/sdk-android-arm64.tar.bz2</span><br></pre></td></tr></table></figure>
<p>其中 <code>20210123</code> 是 <code>frida</code> 中 <code>releng/deps.mk</code> 中的 <code>frida_deps_version</code> 。</p>
<p>下载完之后，解压至 <code>frida/build</code> 目录，然后再执行上面的编译命令即可。（这个操作我没有试过，所以可能有坑，但是问题应该不大。）</p>
<blockquote>
<p>这里要说明一点，我使用的 <code>Ubuntu 18.04</code> 此前编译过 <code>Android</code> 系统，所以可能装的库比较齐全，如果安装上面的库以后还是编译不了，那么就根据报错信息安装对应的库就好了。</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://frida.re/docs/building/<span class="comment">#windows</span></span><br><span class="line">https://bbs.pediy.com/thread-267015.htm</span><br><span class="line">https://blog.seeflower.dev/archives/16/</span><br><span class="line">https://github.com/hluwa/strongR-frida-android/blob/main/.github/workflows/build.yml</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>frida</category>
      </categories>
      <tags>
        <tag>frida</tag>
      </tags>
  </entry>
  <entry>
    <title>编译x64dbg</title>
    <url>/2021/11/09/x64dbg%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>编译环境：VS2019 + QT5.15.2</p>
<p>参考： <a href="https://github.com/x64dbg/x64dbg/wiki/Compiling-the-whole-project">https://github.com/x64dbg/x64dbg/wiki/Compiling-the-whole-project</a></p>
<h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><ol>
<li><p>下载源码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recurse-submodules -b development https://github.com/x64dbg/x64dbg.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置好 VS2019 + QT5.15.2 的环境。</p>
</li>
</ol>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><ol>
<li><p>在 x64dbg 源码目录运行 <code>install.bat</code> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">λ install.bat</span><br><span class="line">Run this to install the auto-format hook.</span><br><span class="line">已复制         1 个文件。</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 <code>setupdeps.bat</code> 复制依赖库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">λ setupdeps.bat</span><br><span class="line">deps\x32\asmjit.dll</span><br><span class="line">deps\x32\dbghelp.dll</span><br><span class="line">deps\x32\DeviceNameResolver.dll</span><br><span class="line">deps\x32\jansson.dll</span><br><span class="line">deps\x32\ldconvert.dll</span><br><span class="line">deps\x32\libeay32.dll</span><br><span class="line">deps\x32\lz4.dll</span><br><span class="line">deps\x32\msdia140.dll</span><br><span class="line">deps\x32\msvcp120.dll</span><br><span class="line">deps\x32\msvcr120.dll</span><br><span class="line">deps\x32\Qt5Core.dll</span><br><span class="line">deps\x32\Qt5Gui.dll</span><br><span class="line">deps\x32\Qt5Network.dll</span><br><span class="line">deps\x32\Qt5Widgets.dll</span><br><span class="line">deps\x32\Qt5WinExtras.dll</span><br><span class="line">deps\x32\Scylla.dll</span><br><span class="line">deps\x32\ssleay32.dll</span><br><span class="line">deps\x32\symsrv.dll</span><br><span class="line">deps\x32\TitanEngine.dll</span><br><span class="line">deps\x32\x32_bridge.dll</span><br><span class="line">deps\x32\x32_dbg.dll</span><br><span class="line">deps\x32\XEDParse.dll</span><br><span class="line">deps\x32\yara.dll</span><br><span class="line">deps\x32\GleeBug\TitanEngine.dll</span><br><span class="line">deps\x32\platforms\qwindows.dll</span><br><span class="line">deps\x32\StaticEngine\TitanEngine.dll</span><br><span class="line">复制了 26 个文件</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 VS2019 打开 <code>x64dbg.sln</code> ，依次选择需要编译的 Project，进入 Project–&gt;Property 选项，将 Platform Toolset 设置为 Visual Studio 2019 (v142)，然后直接编译。</p>
</li>
<li><p>使用 qt creator 打开 <code>src/gui/x64dbg.pro</code>，配置好编译选项，直接编译。</p>
</li>
<li><p>编译完成后，运行 <code>windeployqt.exe --force x64gui.dll</code> 命令，获取相应的依赖库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">λ windeployqt.exe --force E:\Code\WinProjects\x64dbg\bin\x32d\x32gui.dll</span><br><span class="line">E:\Code\WinProjects\x64dbg\bin\x32d\x32gui.dll 32 bit, debug executable</span><br><span class="line">Adding Qt5Svg <span class="keyword">for</span> qsvgicond.dll</span><br><span class="line">Skipping plugin qtvirtualkeyboardplugind.dll due to disabled dependencies (Qt5Qml Qt5Quick).</span><br><span class="line">Skipping plugin qtvirtualkeyboard_hanguld.dll due to disabled dependencies (Qt5Qml Qt5Quick).</span><br><span class="line">Skipping plugin qtvirtualkeyboard_openwnnd.dll due to disabled dependencies (Qt5Qml Qt5Quick).</span><br><span class="line">Skipping plugin qtvirtualkeyboard_pinyind.dll due to disabled dependencies (Qt5Qml Qt5Quick).</span><br><span class="line">Skipping plugin qtvirtualkeyboard_tcimed.dll due to disabled dependencies (Qt5Qml Qt5Quick).</span><br><span class="line">Skipping plugin qtvirtualkeyboard_thaid.dll due to disabled dependencies (Qt5Qml Qt5Quick).</span><br><span class="line">Direct dependencies: Qt5Core Qt5Gui Qt5Network Qt5Widgets Qt5WinExtras</span><br><span class="line">All dependencies   : Qt5Core Qt5Gui Qt5Network Qt5Widgets Qt5WinExtras</span><br><span class="line">To be deployed     : Qt5Core Qt5Gui Qt5Network Qt5Svg Qt5Widgets Qt5WinExtras</span><br><span class="line">Warning: Cannot find Visual Studio installation directory, VCINSTALLDIR is not <span class="built_in">set</span>.</span><br><span class="line">Updating Qt5Cored.dll.</span><br><span class="line">Updating Qt5Guid.dll.</span><br><span class="line">Updating Qt5Networkd.dll.</span><br><span class="line">......</span><br><span class="line">Updating qwindowsvistastyled.dll.</span><br><span class="line">Creating qt_da.qm...</span><br><span class="line">Creating qt_de.qm...</span><br><span class="line">Creating qt_en.qm...</span><br><span class="line">Creating qt_es.qm...</span><br><span class="line">Creating qt_fi.qm...</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>这里需要注意的 windeployqt.exe 需要与编译选项对应，这里我选择的是<code>msvc2019/bin/windeployqt.exe</code>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>xposde源码分析</title>
    <url>/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#xposed%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E6%A6%82%E8%BF%B0">Xposed源码剖析——概述</a><ul>
<li><a href="#xposedinstaller%E7%9A%84%E6%9E%84%E6%88%90">XposedInstaller的构成</a></li>
<li><a href="#xposed%E5%8E%9F%E7%90%86">Xposed原理</a></li>
<li><a href="#xposed%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88">Xposed的实现方案</a></li>
</ul>
</li>
<li><a href="#xposed-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90--app_process-%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3">Xposed 源码剖析 —— app_process 作用详解</a><ul>
<li><a href="#app_maincpp-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%8E%E5%AF%B9%E6%AF%94">app_main.cpp 源码阅读与对比</a></li>
<li><a href="#xposedbridgejava">XposedBridge.java</a></li>
</ul>
</li>
<li><a href="#xposed%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90xposed%E5%88%9D%E5%A7%8B%E5%8C%96">Xposed源码剖析——Xposed初始化</a><ul>
<li><a href="#xposedinitialize%E5%88%9D%E5%A7%8B%E5%8C%96">xposed::initialize初始化</a></li>
<li><a href="#onvmcreated-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">onVmCreated 初始化后的准备工作</a></li>
<li><a href="#libxposed_dalvikcpp-hook-%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">libxposed_dalvik.cpp hook 环境初始化</a></li>
<li><a href="#jni%E6%96%B9%E6%B3%95%E6%B3%A8%E5%86%8C%E9%80%BB%E8%BE%91">JNI方法注册逻辑</a></li>
</ul>
</li>
<li><a href="#xposed-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-hook-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">Xposed 源码剖析—— hook 具体实现</a></li>
</ul>
<!-- /TOC -->

<h1 id="Xposed源码剖析——概述"><a href="#Xposed源码剖析——概述" class="headerlink" title="Xposed源码剖析——概述"></a>Xposed源码剖析——概述</h1><p>XPosed 是与 Cydia 其名的工具，它能够让 Android 设备在没有修改源码的情况下修改系统中的 API 运行结果。我们通常称之为：God Mode（上帝模式）。</p>
<p>之前享大家分享了 Xposed 的基础，Xposed 的作用和最简单的用法。那么，它的原理和它的内部构造是如何构成的？下面，我们从 Github 上看看，rovo89 大神是如何制作的。</p>
<p>rovo89的github地址：<a href="https://github.com/rovo89">https://github.com/rovo89</a></p>
<p>在主页上我们看到了，xposed 其实主要是由三个项目来组成的，如下图所示；</p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-17-48.png" class="">

<p>三个分别是：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Xposed</td>
<td>Xposed 框架的 native 部分（主要是改性 app_process 二进制文件）</td>
</tr>
<tr>
<td>XposedInstaller</td>
<td>Xposed 框架的 Android 端本地管理，环境架构搭建，以及第三方 module 资源下载的工具。</td>
</tr>
<tr>
<td>XposedBridge</td>
<td>Xposed 向开发者提供的 API 与相应的工具类库</td>
</tr>
</tbody></table>
<h2 id="XposedInstaller的构成"><a href="#XposedInstaller的构成" class="headerlink" title="XposedInstaller的构成"></a>XposedInstaller的构成</h2><p>Xposed 项目使我们最常用的项目，当然，他也是构造 Xposed 的核心部分。</p>
<p>如下图所示，是我们在 XPosedInstaller apk 中见到的，安装 xposed 框架的界面。</p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-19-33.png" class="">

<p>InstallerFragment 我们能够在其中找到 install 方法，其中主要就是针对使用不同方式的将自定义的 app_process 文件替换掉系统的 app_process 文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xposed install</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 安装成功返回true，否则false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取安装的方式，直接写入 or 使用 recovery进行安装</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">installMode</span> <span class="operator">=</span> getInstallMode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查获取Root权限</span></span><br><span class="line">    <span class="keyword">if</span> (!startShell())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; messages = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">showAlert</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        messages.add(getString(R.string.sdcard_location, XposedApp.getInstance().getExternalFilesDir(<span class="literal">null</span>)));</span><br><span class="line">        messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        messages.add(getString(R.string.file_copying, <span class="string">&quot;Xposed-Disabler-Recovery.zip&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把Xposed-Disabler-Recovery.zip文件 从asset copy到sdcard中</span></span><br><span class="line">        <span class="keyword">if</span> (AssetUtil.writeAssetToSdcardFile(<span class="string">&quot;Xposed-Disabler-Recovery.zip&quot;</span>, <span class="number">00644</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">            messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            messages.add(getString(R.string.file_extract_failed, <span class="string">&quot;Xposed-Disabler-Recovery.zip&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将编译后的app_process二进制文件，从asset文件夹中，copy到/data/data/de.robv.android.xposed.installer/bin/app_process下</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">appProcessFile</span> <span class="operator">=</span> AssetUtil.writeAssetToFile(APP_PROCESS_NAME, <span class="keyword">new</span> <span class="title class_">File</span>(XposedApp.BASE_DIR + <span class="string">&quot;bin/app_process&quot;</span>), <span class="number">00700</span>);</span><br><span class="line">        <span class="keyword">if</span> (appProcessFile == <span class="literal">null</span>) &#123;</span><br><span class="line">            showAlert(getString(R.string.file_extract_failed, <span class="string">&quot;app_process&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (installMode == INSTALL_MODE_NORMAL) &#123;</span><br><span class="line">            <span class="comment">// 普通安装模式</span></span><br><span class="line">            <span class="comment">// 重新挂载/system为rw模式</span></span><br><span class="line">            messages.add(getString(R.string.file_mounting_writable, <span class="string">&quot;/system&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">&quot;mount -o remount,rw /system&quot;</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(getString(R.string.file_mount_writable_failed, <span class="string">&quot;/system&quot;</span>));</span><br><span class="line">                messages.add(getString(R.string.file_trying_to_continue));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查看原有的app_process文件是否已经备份，如果没有备份，现将原有的app_process文件备份一下</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/system/bin/app_process.orig&quot;</span>).exists()) &#123;</span><br><span class="line">                messages.add(getString(R.string.file_backup_already_exists, <span class="string">&quot;/system/bin/app_process.orig&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">&quot;cp -a /system/bin/app_process /system/bin/app_process.orig&quot;</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                    messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    messages.add(getString(R.string.file_backup_failed, <span class="string">&quot;/system/bin/app_process&quot;</span>));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    messages.add(getString(R.string.file_backup_successful, <span class="string">&quot;/system/bin/app_process.orig&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mRootUtil.executeWithBusybox(<span class="string">&quot;sync&quot;</span>, messages);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将项目中的自定义app_process文件copy覆盖系统的app_process,修改权限</span></span><br><span class="line">            messages.add(getString(R.string.file_copying, <span class="string">&quot;app_process&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">&quot;cp -a &quot;</span> + appProcessFile.getAbsolutePath() + <span class="string">&quot; /system/bin/app_process&quot;</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                messages.add(getString(R.string.file_copy_failed, <span class="string">&quot;app_process&quot;</span>, <span class="string">&quot;/system/bin&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">&quot;chmod 755 /system/bin/app_process&quot;</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                messages.add(getString(R.string.file_set_perms_failed, <span class="string">&quot;/system/bin/app_process&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">&quot;chown root:shell /system/bin/app_process&quot;</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                messages.add(getString(R.string.file_set_owner_failed, <span class="string">&quot;/system/bin/app_process&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (installMode == INSTALL_MODE_RECOVERY_AUTO) &#123;</span><br><span class="line">            <span class="comment">// 自动进入Recovery</span></span><br><span class="line">            <span class="keyword">if</span> (!prepareAutoFlash(messages, <span class="string">&quot;Xposed-Installer-Recovery.zip&quot;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (installMode == INSTALL_MODE_RECOVERY_MANUAL) &#123;</span><br><span class="line">            <span class="comment">// 手动进入Recovery</span></span><br><span class="line">            <span class="keyword">if</span> (!prepareManualFlash(messages, <span class="string">&quot;Xposed-Installer-Recovery.zip&quot;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">blocker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(XposedApp.BASE_DIR + <span class="string">&quot;conf/disabled&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (blocker.exists()) &#123;</span><br><span class="line">            messages.add(getString(R.string.file_removing, blocker.getAbsolutePath()));</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">&quot;rm &quot;</span> + blocker.getAbsolutePath(), messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                messages.add(getString(R.string.file_remove_failed, blocker.getAbsolutePath()));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy XposedBridge.jar 到私有目录 XposedBridge.jar是Xposed提供的jar文件，负责在Native层与FrameWork层进行交互</span></span><br><span class="line">        messages.add(getString(R.string.file_copying, <span class="string">&quot;XposedBridge.jar&quot;</span>));</span><br><span class="line">        <span class="type">File</span> <span class="variable">jarFile</span> <span class="operator">=</span> AssetUtil.writeAssetToFile(<span class="string">&quot;XposedBridge.jar&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(JAR_PATH_NEWVERSION), <span class="number">00644</span>);</span><br><span class="line">        <span class="keyword">if</span> (jarFile == <span class="literal">null</span>) &#123;</span><br><span class="line">            messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            messages.add(getString(R.string.file_extract_failed, <span class="string">&quot;XposedBridge.jar&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mRootUtil.executeWithBusybox(<span class="string">&quot;sync&quot;</span>, messages);</span><br><span class="line"></span><br><span class="line">        showAlert = <span class="literal">false</span>;</span><br><span class="line">        messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (installMode == INSTALL_MODE_NORMAL) &#123;</span><br><span class="line">            offerReboot(messages);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            offerRebootToRecovery(messages, <span class="string">&quot;Xposed-Installer-Recovery.zip&quot;</span>, installMode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 删除busybox 工具库</span></span><br><span class="line">        AssetUtil.removeBusybox();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (showAlert)</span><br><span class="line">            showAlert(TextUtils.join(<span class="string">&quot;\n&quot;</span>, messages).trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看完了代码，发现所有的工作都是为了 app_process 文件的替换。那么，系统中这个 app_process 是做什么的？为什么我们需要替换？替换成什么样？替换后对于我们么来说有什么帮助呢？</p>
<h2 id="Xposed原理"><a href="#Xposed原理" class="headerlink" title="Xposed原理"></a>Xposed原理</h2><p>我们在 android 的源码中的 <code>init.rc</code> 文件可以看到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin –zygote –start-system-server</span><br><span class="line">socket zygote stream 666 </span><br><span class="line">onrestart write /sys/android_power/request_state wake</span><br><span class="line">onrestart write /sys/power/state on</span><br><span class="line">onrestart restart media</span><br><span class="line">onrestart restart netd</span><br></pre></td></tr></table></figure>
<p>app_process 是 andriod app 的启动程序（具体形式是 zygote <code>fork()</code> 调用一个  app_process 作为 Android app 的载体）。</p>
<h2 id="Xposed的实现方案"><a href="#Xposed的实现方案" class="headerlink" title="Xposed的实现方案"></a>Xposed的实现方案</h2><p>针对 Hook 的不同进程来说又可以分为全局 Hook 与单个应用程序进程 Hook ，我们知道在 Android 系统中，应用程序进程都是由 Zygote 进程孵化出来的，而 Zygote 进程是由 Init 进程启动的。</p>
<p>Zygote 进程在启动时会创建一个 Dalvik 虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个 Dalvik 虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的 Dalvik 虚拟机实例。所以如果选择对 Zygote 进程 Hook ，则能够达到针对系统上所有的应用程序进程 Hook ，即一个全局 Hook 。如下图所示：</p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2021-09-03-14-36-00.png" class="">


<h1 id="Xposed-源码剖析-——-app-process-作用详解"><a href="#Xposed-源码剖析-——-app-process-作用详解" class="headerlink" title="Xposed 源码剖析 —— app_process 作用详解"></a>Xposed 源码剖析 —— app_process 作用详解</h1><p>上面我们分析 Xposed 项目的源码，从 XposedInstaller 开始说明了 Xposed 安装的原理与过程。我们知道，XposedInstaller 主要的工作就是：</p>
<ul>
<li>替换系统的 app_process（当然，这个操作需要 Root 权限）</li>
<li>将 xposed 的 api 文件，<code>XposedBridge.jar</code> 文件放置到私有目录中</li>
</ul>
<p>至于为什么要替换 app_process 文件？</p>
<p>系统中的 app_process 文件有什么作用？</p>
<p>替换后的 app_process 为什么能够帮助我们hook？</p>
<p>下面我们就开始看看， rovo89 大神的 xposed 开源项目。从 GitHub 上面 clone 下来 xposed 项目，我们在目录中看到其目录结构，如下所示：</p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-22-42.png" class="">

<p>从目录中，我们能够清楚的了解到，其中 xposed 项目现在已经支持 Dalvik 虚拟机与 art 虚拟机的架构了。</p>
<h2 id="app-main-cpp-源码阅读与对比"><a href="#app-main-cpp-源码阅读与对比" class="headerlink" title="app_main.cpp 源码阅读与对比"></a><code>app_main.cpp</code> 源码阅读与对比</h2><p>我们先从 app_process 的源码开始阅读，打开 <code>app_main.cpp</code> 文件，估计大家和我一下，一时间也看不出来 xposed 针对源码修改了一些什么。</p>
<p>那么，我们就直接拿源码与 xposed 中的 <code>app_main.cpp</code> 进行对比。</p>
<p>源码地址：<code>/frameworks/base/cmds/app_process/app_main.cpp</code></p>
<p>发现了，rovo89 针对了一下几个地方进行了修改。</p>
<p><strong>atrace_set_tracing_enabled 进行了替换修改</strong></p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-23-35.png" class="">

<p><strong>onVmCreated 增加了 Xposed 的回调</strong></p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-24-05.png" class="">

<p><strong>main 函数中，增加了 xposed 的 options 操作</strong></p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-24-34.png" class="">

<p>我们在 <code>xposed.cpp</code> 中，能够看到其 handleOptions 的具体逻辑，其实就是处理一些 xposed 的特殊命令而已。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Handle special command line options. */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">handleOptions</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* <span class="type">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">parseXposedProp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--xposedversion&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Xposed version: %s\n&quot;</span>, xposedVersion);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--xposedtestsafemode&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Testing Xposed safemode trigger\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">detectSafemodeTrigger</span>(<span class="built_in">shouldSkipSafemodeDelay</span>())) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Safemode triggered\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Safemode not triggered\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// From Lollipop coding, used to override the process name</span></span><br><span class="line">    argBlockStart = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="type">uintptr_t</span> start = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">uintptr_t</span> end = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(argv[argc - <span class="number">1</span>]);</span><br><span class="line">    end += <span class="built_in">strlen</span>(argv[argc - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">    argBlockLength = end - start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main 函数中，启动的时候增加了启动一些逻辑.</p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-25-24.png" class="">

<p>具体的， 我们可以看到。<code>runtime.start</code> 那一段。做出了一个启动。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">isXposedLoaded = xposed::<span class="built_in">initialize</span>(zygote, startSystemServer, className, argc, argv);</span><br><span class="line"><span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">    <span class="comment">// 当xposed成功启动的时候，start XPOSED_CLASS_DOTS_ZYGOTE这个类</span></span><br><span class="line">    runtime.<span class="built_in">start</span>(isXposedLoaded ? XPOSED_CLASS_DOTS_ZYGOTE : <span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>,</span><br><span class="line">            startSystemServer ? <span class="string">&quot;start-system-server&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">    <span class="comment">// Remainder of args get passed to startup class main()</span></span><br><span class="line">    runtime.mClassName = className;</span><br><span class="line">    runtime.mArgC = argc - i;</span><br><span class="line">    runtime.mArgV = argv + i;</span><br><span class="line">    <span class="comment">// 当xposed成功启动的时候，start XPOSED_CLASS_DOTS_ZYGOTE这个类</span></span><br><span class="line">    runtime.<span class="built_in">start</span>(isXposedLoaded ? XPOSED_CLASS_DOTS_TOOLS : <span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>,</span><br><span class="line">            application ? <span class="string">&quot;application&quot;</span> : <span class="string">&quot;tool&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">app_usage</span>();</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的我们看到，在 main 函数中启动了逻辑，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runtime.start(isXposedLoaded ? XPOSED_CLASS_DOTS_ZYGOTE : &quot;com.android.internal.os.ZygoteInit&quot;,</span><br><span class="line">                startSystemServer ? &quot;start-system-server&quot; : &quot;&quot;);</span><br></pre></td></tr></table></figure>

<p>其中， XPOSED_CLASS_DOTS_ZYGOTE 变量在，<code>xposed.h</code> 头文件中有定义，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XPOSED_CLASS_DOTS_ZYGOTE <span class="string">&quot;de.robv.android.xposed.XposedBridge&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>其实这个类就是我们之前向私有目录防止的 XposedBridge 项目的包名。</p>
<p>而 <code>runtime.start</code> 这个包名有什么作用呢？我们在 AndroidRuntime 中找到 start 方法的具体逻辑。</p>
<p>在源代码中<code>/frameworks/base/core/jni/AndroidRuntime.cpp</code>中看到</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Start the Android runtime.  This involves starting the virtual machine</span></span><br><span class="line"><span class="comment"> * and calling the &quot;static void main(String[] args)&quot; method in the class</span></span><br><span class="line"><span class="comment"> * named by &quot;className&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Passes the main function two arguments, the class name and the specified</span></span><br><span class="line"><span class="comment"> * options string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* className, <span class="type">const</span> <span class="type">char</span>* options)</span></span></span><br></pre></td></tr></table></figure>

<p>系统源码对 start 方法的定义，就是启动对应类的 start void main 入口函数。这里，就将三个项目的逻辑连接起来了。</p>
<h2 id="XposedBridge-java"><a href="#XposedBridge-java" class="headerlink" title="XposedBridge.java"></a>XposedBridge.java</h2><p>我们在 <code>XposedBridge.java</code> 代码中，看到其 main 方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called when native methods and other things are initialized, but before preloading classes etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// Initialize the Xposed framework and modules</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SELinuxHelper.initOnce();</span><br><span class="line">        SELinuxHelper.initForProcess(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        runtime = getRuntime();</span><br><span class="line">        <span class="keyword">if</span> (initNative()) &#123;</span><br><span class="line">            XPOSED_BRIDGE_VERSION = getXposedVersion();</span><br><span class="line">            <span class="keyword">if</span> (isZygote) &#123;</span><br><span class="line">                startsSystemServer = startsSystemServer();</span><br><span class="line">                <span class="comment">// 为启动一个新的 zygote做好 hook准备</span></span><br><span class="line">                initForZygote();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 载入Xposed的一些modules</span></span><br><span class="line">            loadModules();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log(<span class="string">&quot;Errors during native Xposed initialization&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log(<span class="string">&quot;Errors during Xposed initialization&quot;</span>);</span><br><span class="line">        log(t);</span><br><span class="line">        disableHooks = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用系统原来的启动方法</span></span><br><span class="line">    <span class="keyword">if</span> (isZygote)</span><br><span class="line">        ZygoteInit.main(args);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        RuntimeInit.main(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，整个 app_process 的复制 hook 逻辑，到这里我们已经清楚了。逻辑如下图所示。</p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-27-01.png" class="">

<p>那么，xposed 具体怎么实现系统 api 逻辑的 replace 和 inject 我们下次在做分析。</p>
<h1 id="Xposed源码剖析——Xposed初始化"><a href="#Xposed源码剖析——Xposed初始化" class="headerlink" title="Xposed源码剖析——Xposed初始化"></a>Xposed源码剖析——Xposed初始化</h1><p>之前我们看过了 <code>app_main.cpp</code> 源码，知道了在其中，启动了 <code>XposedBridge.jar</code> 方法。那么，其中还做了些什么事情呢？</p>
<p>之前我们也看到了在 <code>app_main.cpp</code> 还有几处新增的逻辑。xposed::initialize和onVmCreated回调。下面我在仔细的阅读以下源码。</p>
<h2 id="xposed-initialize初始化"><a href="#xposed-initialize初始化" class="headerlink" title="xposed::initialize初始化"></a>xposed::initialize初始化</h2><img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-28-24.png" class="">

<p>对于 <code>xposed::initalize</code> 的初始化工作，我们能够在 <code>xposed.cpp</code> 中看到其具体的逻辑实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 初始化xposed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">initialize</span><span class="params">(<span class="type">bool</span> zygote, <span class="type">bool</span> startSystemServer, <span class="type">const</span> <span class="type">char</span>* className, <span class="type">int</span> argc, <span class="type">char</span>* <span class="type">const</span> argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(XPOSED_ENABLE_FOR_TOOLS)</span></span><br><span class="line">    <span class="keyword">if</span> (!zygote)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    xposed-&gt;zygote = zygote;</span><br><span class="line">    xposed-&gt;startSystemServer = startSystemServer;</span><br><span class="line">    xposed-&gt;startClassName = className;</span><br><span class="line">    xposed-&gt;xposedVersionInt = xposedVersionInt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> XPOSED_WITH_SELINUX</span></span><br><span class="line">    xposed-&gt;isSELinuxEnabled   = <span class="built_in">is_selinux_enabled</span>() == <span class="number">1</span>;</span><br><span class="line">    xposed-&gt;isSELinuxEnforcing = xposed-&gt;isSELinuxEnabled &amp;&amp; <span class="built_in">security_getenforce</span>() == <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    xposed-&gt;isSELinuxEnabled   = <span class="literal">false</span>;</span><br><span class="line">    xposed-&gt;isSELinuxEnforcing = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// XPOSED_WITH_SELINUX</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        xposed::logcat::<span class="built_in">start</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        <span class="comment">// TODO Find a better solution for this</span></span><br><span class="line">        <span class="comment">// Give the primary Zygote process a little time to start first.</span></span><br><span class="line">        <span class="comment">// This also makes the log easier to read, as logs for the two Zygotes are not mixed up.</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印rom信息</span></span><br><span class="line">    <span class="built_in">printRomInfo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!xposed::service::<span class="built_in">startAll</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> XPOSED_WITH_SELINUX</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xposed-&gt;isSELinuxEnabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!xposed::service::<span class="built_in">startMembased</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// XPOSED_WITH_SELINUX</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FIXME Zygote has no access to input devices, this would need to be check in system_server context</span></span><br><span class="line">    <span class="keyword">if</span> (zygote &amp;&amp; !<span class="built_in">isSafemodeDisabled</span>() &amp;&amp; <span class="built_in">detectSafemodeTrigger</span>(<span class="built_in">shouldSkipSafemodeDelay</span>()))</span><br><span class="line">        <span class="built_in">disableXposed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isDisabled</span>() || (!zygote &amp;&amp; <span class="built_in">shouldIgnoreCommand</span>(argc, argv)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将XposedBridge.jar的路径添加到环境变量classpath中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">addJarToClasspath</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="onVmCreated-初始化后的准备工作"><a href="#onVmCreated-初始化后的准备工作" class="headerlink" title="onVmCreated 初始化后的准备工作"></a>onVmCreated 初始化后的准备工作</h2><img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-29-28.png" class="">

<p>其具体的逻辑如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment">  * 向当前的runtime中载入libxposed_*.so </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onVmCreated</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Determine the currently active runtime</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* xposedLibPath = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">determineRuntime</span>(&amp;xposedLibPath)) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not determine runtime, not loading Xposed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the suitable libxposed_*.so for it</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *error;</span><br><span class="line">    <span class="type">void</span>* xposedLibHandle = <span class="built_in">dlopen</span>(xposedLibPath, RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (!xposedLibHandle) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not load libxposed: %s&quot;</span>, <span class="built_in">dlerror</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear previous errors</span></span><br><span class="line">    <span class="built_in">dlerror</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the library</span></span><br><span class="line">    <span class="built_in">bool</span> (*xposedInitLib)(XposedShared* shared) = <span class="literal">NULL</span>;</span><br><span class="line">    *(<span class="type">void</span> **) (&amp;xposedInitLib) = <span class="built_in">dlsym</span>(xposedLibHandle, <span class="string">&quot;xposedInitLib&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!xposedInitLib)  &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not find function xposedInitLib&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> XPOSED_WITH_SELINUX</span></span><br><span class="line">    xposed-&gt;zygoteservice_accessFile = &amp;service::membased::accessFile;</span><br><span class="line">    xposed-&gt;zygoteservice_statFile   = &amp;service::membased::statFile;</span><br><span class="line">    xposed-&gt;zygoteservice_readFile   = &amp;service::membased::readFile;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// XPOSED_WITH_SELINUX</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的xposed变量，其实是一个全局的XposedShare。</span></span><br><span class="line">    <span class="comment">// 调用XposedShare的onVmCreated则会根据不同的vm架构针对不同的实现。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xposedInitLib</span>(xposed)) &#123;</span><br><span class="line">        xposed-&gt;<span class="built_in">onVmCreated</span>(env);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="libxposed-dalvik-cpp-hook-环境初始化"><a href="#libxposed-dalvik-cpp-hook-环境初始化" class="headerlink" title="libxposed_dalvik.cpp hook 环境初始化"></a><code>libxposed_dalvik.cpp</code> hook 环境初始化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Called by Xposed&#x27;s app_process replacement. </span></span><br><span class="line"><span class="comment">  * 在被替换后的app_process中调用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xposedInitLib</span><span class="params">(xposed::XposedShared* shared)</span> </span>&#123;</span><br><span class="line">    xposed = shared;</span><br><span class="line">    <span class="comment">// 将自己的onVmCreated方法，指向onVmCreated方法</span></span><br><span class="line">    xposed-&gt;onVmCreated = &amp;onVmCreated;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Called very early during VM startup. </span></span><br><span class="line"><span class="comment">  * 在VM启动的时候调用，而且调用时机比较早</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onVmCreated</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">initMemberOffsets</span>(env))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到小米系统的MIUI_RESOURCE做特殊处理</span></span><br><span class="line">    jclass classMiuiResources = env-&gt;<span class="built_in">FindClass</span>(CLASS_MIUI_RESOURCES);</span><br><span class="line">    <span class="keyword">if</span> (classMiuiResources != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ClassObject* clazz = (ClassObject*)<span class="built_in">dvmDecodeIndirectRef</span>(<span class="built_in">dvmThreadSelf</span>(), classMiuiResources);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dvmIsFinalClass</span>(clazz)) &#123;</span><br><span class="line">            <span class="built_in">ALOGD</span>(<span class="string">&quot;Removing final flag for class &#x27;%s&#x27;&quot;</span>, CLASS_MIUI_RESOURCES);</span><br><span class="line">            clazz-&gt;accessFlags &amp;= ~ACC_FINAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;<span class="built_in">ExceptionClear</span>();</span><br><span class="line"></span><br><span class="line">    jclass classXTypedArray = env-&gt;<span class="built_in">FindClass</span>(CLASS_XTYPED_ARRAY);</span><br><span class="line">    <span class="keyword">if</span> (classXTypedArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Error while loading XTypedArray class &#x27;%s&#x27;:&quot;</span>, CLASS_XTYPED_ARRAY);</span><br><span class="line">        <span class="built_in">dvmLogExceptionStackTrace</span>();</span><br><span class="line">        env-&gt;<span class="built_in">ExceptionClear</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">prepareSubclassReplacement</span>(classXTypedArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到全局的XposedBridge</span></span><br><span class="line">    classXposedBridge = env-&gt;<span class="built_in">FindClass</span>(CLASS_XPOSED_BRIDGE);</span><br><span class="line">    classXposedBridge = <span class="built_in">reinterpret_cast</span>&lt;jclass&gt;(env-&gt;<span class="built_in">NewGlobalRef</span>(classXposedBridge));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (classXposedBridge == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Error while loading Xposed class &#x27;%s&#x27;:&quot;</span>, CLASS_XPOSED_BRIDGE);</span><br><span class="line">        <span class="built_in">dvmLogExceptionStackTrace</span>();</span><br><span class="line">        env-&gt;<span class="built_in">ExceptionClear</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一些 XposedBridge 的 native 方法</span></span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;Found Xposed class &#x27;%s&#x27;, now initializing&quot;</span>, CLASS_XPOSED_BRIDGE);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">register_natives_XposedBridge</span>(env, classXposedBridge) != JNI_OK) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not register natives for &#x27;%s&#x27;&quot;</span>, CLASS_XPOSED_BRIDGE);</span><br><span class="line">        <span class="built_in">dvmLogExceptionStackTrace</span>();</span><br><span class="line">        env-&gt;<span class="built_in">ExceptionClear</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xposedLoadedSuccessfully = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JNI方法注册逻辑"><a href="#JNI方法注册逻辑" class="headerlink" title="JNI方法注册逻辑"></a>JNI方法注册逻辑</h2><p>这里注册的几个方法都是，Xposed 核心的几个方法函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_natives_XposedBridge</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> JNINativeMethod methods[] = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, getStartClassName, <span class="string">&quot;()Ljava/lang/String;&quot;</span>),</span><br><span class="line">        <span class="comment">// 获得Runtime</span></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, getRuntime, <span class="string">&quot;()I&quot;</span>),</span><br><span class="line">        <span class="comment">// 启动SystemServer</span></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, startsSystemServer, <span class="string">&quot;()Z&quot;</span>),</span><br><span class="line">        <span class="comment">// 获取Xposed的版本信息</span></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, getXposedVersion, <span class="string">&quot;()I&quot;</span>),</span><br><span class="line">        <span class="comment">// 初始化navtive</span></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, initNative, <span class="string">&quot;()Z&quot;</span>),</span><br><span class="line">        <span class="comment">// hook一个方法的native实现</span></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, hookMethodNative, <span class="string">&quot;(Ljava/lang/reflect/Member;Ljava/lang/Class;ILjava/lang/Object;)V&quot;</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ART_TARGET</span></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, invokeOriginalMethodNative,</span><br><span class="line">            <span class="string">&quot;(Ljava/lang/reflect/Member;I[Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, setObjectClassNative, <span class="string">&quot;(Ljava/lang/Object;Ljava/lang/Class;)V&quot;</span>),</span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, dumpObjectNative, <span class="string">&quot;(Ljava/lang/Object;)V&quot;</span>),</span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, cloneToSubclassNative, <span class="string">&quot;(Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">RegisterNatives</span>(clazz, methods, <span class="built_in">NELEM</span>(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到 RegisterNatives 这个方法的时候不是很理解，这里做一个简介。</p>
<p>以前在 jni 中写本地方法时，都会写成 <code>Java_com_example_hellojni_HelloJni_stringFromJNI</code> 的形式，函数名很长，而且当类名变了的时候，函数名必须一个一个的改，麻烦。</p>
<p>现在好了有了 RegisterNatives ，可以简化我们的书写<br>和传统方法相比，使用 RegisterNative s的好处有三点：</p>
<ol>
<li>C＋＋中函数命名自由，不必像 javah 自动生成的函数声明那样，拘泥特定的命名方式；</li>
<li>效率高。传统方式下，Java 类 call 本地函数时，通常是依靠 VM 去动态寻找 <code>.so</code> 中的本地函数(因此它们才需要特定规则的命名格式)，而使用 RegisterNatives 将本地函数向 VM 进行登记，可以让其更有效率的找到函数；</li>
<li>运行时动态调整本地函数与 Java 函数值之间的映射关系，只需要多次 call  <code>RegisterNatives()</code> 方法，并传入不同的映射表参数即可。</li>
</ol>
<h1 id="Xposed-源码剖析——-hook-具体实现"><a href="#Xposed-源码剖析——-hook-具体实现" class="headerlink" title="Xposed 源码剖析—— hook 具体实现"></a>Xposed 源码剖析—— hook 具体实现</h1><p>之前我们看到了 xposed 各种初始化的工作，其实都是完成了针对系统中各种 method 的 hook 和替换工作。</p>
<p>那么具体如何替换，其实都是调用了其中的。 XposedBridge_hookMethodNative 函数。这里，我们详细的看看 XposedBridge_hookMethodNative 函数中，做了一些什么操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 将输入的Class中的Method方法的nativeFunc替换为xposedCallHandler </span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * @param env JniEnv</span></span><br><span class="line"><span class="comment">  * @param reflectedMethodIndirect 待反射的函数</span></span><br><span class="line"><span class="comment">  * @param declaredClassIndirect 定义的class</span></span><br><span class="line"><span class="comment">  * @param slot 函数偏移量</span></span><br><span class="line"><span class="comment">  * @param additionalInfoIndirect 添加的函数</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XposedBridge_hookMethodNative</span><span class="params">(JNIEnv* env, jclass clazz, jobject reflectedMethodIndirect,</span></span></span><br><span class="line"><span class="params"><span class="function">            jobject declaredClassIndirect, jint slot, jobject additionalInfoIndirect)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 容错</span></span><br><span class="line">    <span class="keyword">if</span> (declaredClassIndirect == <span class="literal">NULL</span> || reflectedMethodIndirect == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">dvmThrowIllegalArgumentException</span>(<span class="string">&quot;method and declaredClass must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据函数的偏移量，从classloader中找到准备替换的函数。</span></span><br><span class="line">    ClassObject* declaredClass = (ClassObject*) <span class="built_in">dvmDecodeIndirectRef</span>(<span class="built_in">dvmThreadSelf</span>(), declaredClassIndirect);</span><br><span class="line">    Method* method = <span class="built_in">dvmSlotToMethod</span>(declaredClass, slot);</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">dvmThrowNoSuchMethodError</span>(<span class="string">&quot;Could not get internal representation for method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isMethodHooked</span>(method)) &#123;</span><br><span class="line">        <span class="comment">// already hooked</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存替换前的数据信息</span></span><br><span class="line">    XposedHookInfo* hookInfo = (XposedHookInfo*) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(XposedHookInfo));</span><br><span class="line">    <span class="built_in">memcpy</span>(hookInfo, method, <span class="built_in">sizeof</span>(hookInfo-&gt;originalMethodStruct));</span><br><span class="line">    hookInfo-&gt;reflectedMethod = <span class="built_in">dvmDecodeIndirectRef</span>(<span class="built_in">dvmThreadSelf</span>(), env-&gt;<span class="built_in">NewGlobalRef</span>(reflectedMethodIndirect));</span><br><span class="line">    hookInfo-&gt;additionalInfo = <span class="built_in">dvmDecodeIndirectRef</span>(<span class="built_in">dvmThreadSelf</span>(), env-&gt;<span class="built_in">NewGlobalRef</span>(additionalInfoIndirect));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换函数方法 , 让nativeFunction指向本地的hookedMethodCallback</span></span><br><span class="line">    <span class="built_in">SET_METHOD_FLAG</span>(method, ACC_NATIVE);</span><br><span class="line">    method-&gt;nativeFunc = &amp;hookedMethodCallback;</span><br><span class="line">    method-&gt;insns = (<span class="type">const</span> u2*) hookInfo;</span><br><span class="line">    method-&gt;registersSize = method-&gt;insSize;</span><br><span class="line">    method-&gt;outsSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PTR_gDvmJit != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// reset JIT cache</span></span><br><span class="line">        <span class="type">char</span> currentValue = *((<span class="type">char</span>*)PTR_gDvmJit + <span class="built_in">MEMBER_OFFSET_VAR</span>(DvmJitGlobals,codeCacheFull));</span><br><span class="line">        <span class="keyword">if</span> (currentValue == <span class="number">0</span> || currentValue == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">MEMBER_VAL</span>(PTR_gDvmJit, DvmJitGlobals, codeCacheFull) = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Unexpected current value for codeCacheFull: %d&quot;</span>, currentValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 vm 不熟悉的，解释一下几个不怎么常用的函数。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>dvmDecodeIndirectRef</td>
<td>将间接引用 jobject 转换为对象引用 Object*</td>
</tr>
<tr>
<td>dvmSlotToMethod</td>
<td>根据偏移量，从 ClassLoader 中获取函数指针</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * hook方法调用时的回调</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hookedMethodCallback</span><span class="params">(<span class="type">const</span> u4* args, JValue* pResult, <span class="type">const</span> Method* method, ::Thread* self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isMethodHooked</span>(method)) &#123;</span><br><span class="line">        <span class="built_in">dvmThrowNoSuchMethodError</span>(<span class="string">&quot;Could not find Xposed original method - how did you even get here?&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    XposedHookInfo* hookInfo = (XposedHookInfo*) method-&gt;insns;</span><br><span class="line">    Method* original = (Method*) hookInfo;</span><br><span class="line">    Object* originalReflected = hookInfo-&gt;reflectedMethod;</span><br><span class="line">    Object* additionalInfo = hookInfo-&gt;additionalInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert/box arguments</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* desc = &amp;method-&gt;shorty[<span class="number">1</span>]; <span class="comment">// [0] is the return type.</span></span><br><span class="line">    Object* thisObject = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> srcIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> dstIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for non-static methods determine the &quot;this&quot; pointer</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dvmIsStaticMethod</span>(original)) &#123;</span><br><span class="line">        thisObject = (Object*) args[<span class="number">0</span>];</span><br><span class="line">        srcIndex++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayObject* argsArray = <span class="built_in">dvmAllocArrayByClass</span>(objectArrayClass, <span class="built_in">strlen</span>(method-&gt;shorty) - <span class="number">1</span>, ALLOC_DEFAULT);</span><br><span class="line">    <span class="keyword">if</span> (argsArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*desc != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="type">char</span> descChar = *(desc++);</span><br><span class="line">        JValue value;</span><br><span class="line">        Object* obj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (descChar) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">            value.i = args[srcIndex++];</span><br><span class="line">            obj = (Object*) <span class="built_in">dvmBoxPrimitive</span>(value, <span class="built_in">dvmFindPrimitiveClass</span>(descChar));</span><br><span class="line">            <span class="built_in">dvmReleaseTrackedAlloc</span>(obj, self);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:</span><br><span class="line">            value.j = <span class="built_in">dvmGetArgLong</span>(args, srcIndex);</span><br><span class="line">            srcIndex += <span class="number">2</span>;</span><br><span class="line">            obj = (Object*) <span class="built_in">dvmBoxPrimitive</span>(value, <span class="built_in">dvmFindPrimitiveClass</span>(descChar));</span><br><span class="line">            <span class="built_in">dvmReleaseTrackedAlloc</span>(obj, self);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            obj  = (Object*) args[srcIndex++];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Unknown method signature description character: %c&quot;</span>, descChar);</span><br><span class="line">            obj = <span class="literal">NULL</span>;</span><br><span class="line">            srcIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">setObjectArrayElement</span>(argsArray, dstIndex++, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Java中的对应方法，即之前我们用到，的handleHookedMethod</span></span><br><span class="line">    JValue result;</span><br><span class="line">    <span class="built_in">dvmCallMethod</span>(self, xposedHandleHookedMethod, <span class="literal">NULL</span>, &amp;result,</span><br><span class="line">        originalReflected, (<span class="type">int</span>) original, additionalInfo, thisObject, argsArray);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dvmReleaseTrackedAlloc</span>(argsArray, self);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exceptions are thrown to the caller</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dvmCheckException</span>(self)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return result with proper type</span></span><br><span class="line">    ClassObject* returnType = <span class="built_in">dvmGetBoxedReturnType</span>(method);</span><br><span class="line">    <span class="keyword">if</span> (returnType-&gt;primitiveType == PRIM_VOID) &#123;</span><br><span class="line">        <span class="comment">// ignored</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.l == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dvmIsPrimitiveClass</span>(returnType)) &#123;</span><br><span class="line">            <span class="built_in">dvmThrowNullPointerException</span>(<span class="string">&quot;null result when primitive expected&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pResult-&gt;l = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">dvmUnboxPrimitive</span>(result.l, returnType, pResult)) &#123;</span><br><span class="line">            <span class="built_in">dvmThrowClassCastException</span>(result.l-&gt;clazz, returnType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>转载：<a href="https://blog.csdn.net/yzzst/article/details/47659987">https://blog.csdn.net/yzzst/article/details/47659987</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title>一次ROM解包之旅</title>
    <url>/2023/12/22/%E4%B8%80%E6%AC%A1ROM%E8%A7%A3%E5%8C%85%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<p>最近遇到一个 ROM 包，需要获取其中的 APK，因此产生了解包的需求。</p>
<p>首先使用 <code>file</code> 命令查看文件格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file unkown.img</span><br><span class="line">unkown.img: data</span><br></pre></td></tr></table></figure>

<p>发现为 data 类型，即未知格式，接下来使用 <a href="http://www.010editor.com/">010Editor</a> 查看，发现文件头有 <code>IMAGEWTY</code> 标志：</p>
<img src="/2023/12/22/%E4%B8%80%E6%AC%A1ROM%E8%A7%A3%E5%8C%85%E4%B9%8B%E6%97%85/2023-12-22-15-53-46.png" class="">

<p>接着搜索 <code>imagewty file format</code> 关键字，找到这个项目：<a href="https://github.com/Ithamar/awutils">https://github.com/Ithamar/awutils</a> 。</p>
<img src="/2023/12/22/%E4%B8%80%E6%AC%A1ROM%E8%A7%A3%E5%8C%85%E4%B9%8B%E6%97%85/2023-12-22-15-55-19.png" class="">

<p>编译 <code>awimage</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/Ithamar/awutils</span><br><span class="line">Cloning into <span class="string">&#x27;awutils&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 181, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 181 (delta 0), reused 0 (delta 0), pack-reused 181</span><br><span class="line">Receiving objects: 100% (181/181), 64.50 KiB | 92.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (99/99), <span class="keyword">done</span>.</span><br><span class="line">$ <span class="built_in">cd</span> awutils</span><br><span class="line">$ make awimage</span><br><span class="line">cc  -Wall -o awimage awimage.c parsecfg.c twofish.c rc6.c</span><br><span class="line">awimage.c: In <span class="keyword">function</span> ‘decrypt_image’:</span><br><span class="line">awimage.c:371:43: warning: variable ‘firmware_id’ <span class="built_in">set</span> but not used [-Wunused-but-set-variable]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>执行 awimage 程序解包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./awimage unkown.img</span><br><span class="line">./awimage: unpacking unkown.img to unkown.img.dump</span><br><span class="line">Extracting: COMMON   SYS_CONFIG100000 (17060, 17072)</span><br><span class="line">Extracting: COMMON   BOARD_CONFIG_BIN (1024, 1024)</span><br><span class="line">Extracting: COMMON   SYS_CONFIG_BIN00 (27648, 27648)</span><br><span class="line">Extracting: COMMON   SPLIT_0000000000 (512, 512)</span><br><span class="line">Extracting: COMMON   SYS_CONFIG000000 (5789, 5792)</span><br><span class="line">Extracting: COMMON   DTB_CONFIG000000 (154112, 154112)</span><br><span class="line">Extracting: BOOT     BOOT0_0000000000 (73728, 73728)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这时会在当前目录下产生一个 <code>unkown.img.dump</code> 目录，其中为解包的内容，找到文件名包含 <code>SUPER</code> 的文件 <code>RFSFAT16_SUPER_FEX0000000</code>，再次使用 <code>file</code> 命令查看文件格式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file RFSFAT16_SUPER_FEX0000000</span><br><span class="line">RFSFAT16_SUPER_FEX0000000: Android sparse image, version: 1.0, Total of 917504 4096-byte output blocks <span class="keyword">in</span> 63 input chunks.</span><br></pre></td></tr></table></figure>

<p>这时可以看到文件格式为 <code>Android sparse image, version: 1.0</code>，搜索相关关键字，找到工具 <a href="https://github.com/anestisb/android-simg2img">android-simg2img</a>，接着编译获取工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/anestisb/android-simg2img.git</span><br><span class="line">Cloning into <span class="string">&#x27;android-simg2img&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 195, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (7/7), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (6/6), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 195 (delta 1), reused 7 (delta 1), pack-reused 188</span><br><span class="line">Receiving objects: 100% (195/195), 103.10 KiB | 99.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (100/100), <span class="keyword">done</span>.</span><br><span class="line">$ <span class="built_in">cd</span> android-simg2img</span><br><span class="line">$ make</span><br><span class="line">g++ -std=gnu++17 -O2 -W -Wall -Werror -Wextra -D__STDC_FORMAT_MACROS -D__STDC_CONSTANT_MACROS -Iinclude -Iandroid-base/include -c backed_block.cpp -o backed_block.o</span><br><span class="line">g++ -std=gnu++17 -O2 -W -Wall -Werror -Wextra -D__STDC_FORMAT_MACROS -D__STDC_CONSTANT_MACROS -Iinclude -Iandroid-base/include -c output_file.cpp -o output_file.o</span><br><span class="line">g++ -std=gnu++17 -O2 -W -Wall -Werror -Wextra -D__STDC_FORMAT_MACROS -D__STDC_CONSTANT_MACROS -Iinclude -Iandroid-base/include -c sparse.cpp -o sparse.o</span><br><span class="line">g++ -std=gnu++17 -O2 -W -Wall -Werror -Wextra -D__STDC_FORMAT_MACROS -D__STDC_CONSTANT_MACROS -Iinclude -Iandroid-base/include -c sparse_crc32.cpp -o sparse_crc32.o</span><br><span class="line">g++ -std=gnu++17 -O2 -W -Wall -Werror -Wextra -D__STDC_FORMAT_MACROS -D__STDC_CONSTANT_MACROS -Iinclude -Iandroid-base/include -c sparse_err.cpp -o sparse_err.o</span><br><span class="line">g++ -std=gnu++17 -O2 -W -Wall -Werror -Wextra -D__STDC_FORMAT_MACROS -D__STDC_CONSTANT_MACROS -Iinclude -Iandroid-base/include -c sparse_read.cpp -o sparse_read.o</span><br><span class="line">g++ -std=gnu++17 -O2 -W -Wall -Werror -Wextra -D__STDC_FORMAT_MACROS -D__STDC_CONSTANT_MACROS -Iinclude -Iandroid-base/include -c android-base/stringprintf.cpp -o</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>执行 <code>simg2img</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./simg2img RFSFAT16_SUPER_FEX0000000 super.img</span><br><span class="line">$ file super.img</span><br><span class="line">super.img: data</span><br></pre></td></tr></table></figure>

<p>可以发现 Android sparse image 并没有被转为 ext4 的 image，实际上直接使用 7z 可以解压这个文件，但是解压出来也无法识别文件格式。</p>
<p>这里使用关键字 <code>super img unpack</code> 搜索，找到了一个项目：<a href="https://github.com/munjeni/super_image_dumper">super_image_dumper</a>，然后编译使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/munjeni/super_image_dumper</span><br><span class="line">Cloning into <span class="string">&#x27;super_image_dumper&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 186, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 186 (delta 0), reused 0 (delta 0), pack-reused 186</span><br><span class="line">Receiving objects: 100% (186/186), 9.64 MiB | 243.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (107/107), <span class="keyword">done</span>.</span><br><span class="line">$ <span class="built_in">cd</span> super_image_dumper</span><br><span class="line">$ make</span><br><span class="line">gcc -Wall -g -O2 -Iinclude superunpack.c -o superunpack</span><br></pre></td></tr></table></figure>

<p>使用 <code>superunpack</code> 操作 <code>super.img</code> 可以解压出来一些文件，最后发现这个操作与使用 7z 解压的效果一样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./superunpack super.img</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">Super image unpacker v_15 by munjeni @ xda 2020)</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line">LpMetadataGeometry magic = 0x616c4467</span><br><span class="line">LpMetadataGeometry struct size = 0x34</span><br><span class="line">LpMetadataGeometry sha256 = 123456F0ABA7B506F25CB5DA5DCA09344234E8DF1D9C93AE82A499D98019467E</span><br><span class="line">LpMetadataGeometry metadata_max_size = 0x10000</span><br><span class="line">LpMetadataGeometry metadata_slot_count = 0x3</span><br><span class="line">LpMetadataGeometry logical_block_size = 0x1000</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中值得关注的是文件名包含 system 的文件 <code>system_dlkm_a.ext4</code> 和 <code>system_a.bin</code>，使用 <code>file</code> 命令查看文件格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file system_a.bin</span><br><span class="line">system_a.bin: data</span><br><span class="line">$ file system_dlkm_a.ext4</span><br><span class="line">system_dlkm_a.ext4: Linux rev 1.0 ext2 filesystem data, UUID=0887d040-56a8-4f76-b47d-4b2685db8d45, volume name <span class="string">&quot;system_dlkm&quot;</span> (extents) (large files) (huge files)</span><br></pre></td></tr></table></figure>

<p><code>system_a.bin</code> 为未知文件，<code>system_dlkm_a.ext4</code> 为 <code>Linux rev 1.0 ext2 filesystem data</code> 文件，然后挂载 <code>system_dlkm_a.ext4</code> 文件，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> system</span><br><span class="line">$ sudo mount -t ext4 -o loop system_dlkm_a.ext4 system</span><br><span class="line">[sudo] password <span class="keyword">for</span> ckcat:</span><br></pre></td></tr></table></figure>

<p>可以发现 <code>system_dlkm_a.ext4</code> 为下图中展示的内容：</p>
<img src="/2023/12/22/%E4%B8%80%E6%AC%A1ROM%E8%A7%A3%E5%8C%85%E4%B9%8B%E6%97%85/2023-12-22-16-42-42.png" class="">

<p>这时仍然没有实现我们最初的目标，尝试搜索了一下 <code>system_dlkm_a.ext4</code>，发现了这一段话：<code>system_dlkm</code> 分区的文件系统应该是 <code>EROFS</code> 而不是 <code>EXT4</code>。后续也搜了一下 <code>EROFS</code> 格式，但是没有深入。这时找到了一篇<a href="https://xdaforums.com/t/editing-system-img-inside-super-img-and-flashing-our-modifications.4196625/">文章</a>，在其中发现了 <a href="https://newandroidbook.com/tools/imjtool.html">imjtool</a> 工具。接下来试了一下这个工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./imjtool.ELF64 system_a.bin</span><br><span class="line">Huawei EROFS (not handled yet)</span><br></pre></td></tr></table></figure>

<p>虽然没有能够成功解包，但是至少知道了文件格式为 <code>Huawei EROFS</code>。搜索 <code>EROFS unpack</code> 找到了工具 <a href="https://github.com/sekaiacg/erofs-extract">erofs-extract</a>。接下来下载使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./extract.erofs -i system_a.bin -x</span><br><span class="line">Extract:        Starting...</span><br><span class="line">Extract:        [ 100.00% ]</span><br><span class="line">fs_config:      save...</span><br><span class="line">fs_config:      <span class="keyword">done</span>.</span><br><span class="line">files_context:  save...</span><br><span class="line">files_context:  <span class="keyword">done</span>.</span><br><span class="line">Extract:        The operation took: 4.758 second(s).</span><br></pre></td></tr></table></figure>

<p>该工具可以解包 <code>EROFS</code> 格式，达到了最初的目的，获取到了相应的 APK。</p>
<p>整个过程其实比较曲折，本文只是记录了一些比较重要的点，并将顺序进行了调整。</p>
<p>参考：</p>
<p><a href="https://wuxianlin.com/2019/03/22/android-reverse-engineering">https://wuxianlin.com/2019/03/22/android-reverse-engineering</a></p>
<p><a href="https://xdaforums.com/t/editing-system-img-inside-super-img-and-flashing-our-modifications.4196625/">https://xdaforums.com/t/editing-system-img-inside-super-img-and-flashing-our-modifications.4196625/</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>ROM 解包</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Android Studio调试Android源码</title>
    <url>/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E4%B8%80%E5%AF%BC%E5%85%A5%E6%BA%90%E7%A0%81%E5%88%B0-android-studio">一、导入源码到 Android Studio</a><ul>
<li><a href="#1-%E7%BC%96%E8%AF%91-idegen">1. 编译 idegen</a></li>
<li><a href="#2-%E5%AF%BC%E5%85%A5%E6%BA%90%E7%A0%81">2. 导入源码</a></li>
<li><a href="#3-%E5%BC%80%E5%A7%8B%E8%B0%83%E8%AF%95">3. 开始调试</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="一、导入源码到-Android-Studio"><a href="#一、导入源码到-Android-Studio" class="headerlink" title="一、导入源码到 Android Studio"></a>一、导入源码到 Android Studio</h1><p>导入源码到 Android Studio<br>要在 Android Studio 中调试源码，那第一步自然是导入系统源码到 Android Studio 中了。</p>
<h2 id="1-编译-idegen"><a href="#1-编译-idegen" class="headerlink" title="1. 编译 idegen"></a>1. 编译 idegen</h2><p>对于 Android 源码的导入， Google 官方给我们提供了一个很方便的工具idegen</p>
<p>它位于我们所下载的系统源码路径中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">developement/tools/idegen</span><br></pre></td></tr></table></figure>
<p>引用 README 的一句话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDEGen automatically generates Android IDE configurations for IntelliJ IDEA and Eclipse.</span><br></pre></td></tr></table></figure>
<p>idegen 工具会自动生成针对 Android 开发工具（Android Studio和Eclipse）的配置文件。 既然如此，那我们就来使用 idegen 工具生成导入源码所需的配置文件。</p>
<p>首先打开命令行工具，cd 进入到源码路径下，</p>
<p>执行如下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#初始化命令工具</span><br><span class="line">soruce build/envsetup.sh </span><br><span class="line"></span><br><span class="line">#编译 idegen 模块，生成idegen.jar</span><br><span class="line">mmm development/tools/idegen/</span><br><span class="line"></span><br><span class="line">#生成针对 Android 开发工具的配置文件 </span><br><span class="line">sudo ./development/tools/idegen/idegen.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-20-31-55.png" class="">

<p>在执行完上述指令后，会在源码路径下生成下面三个文件</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-20-20-30.png" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android.ipr：工程相关的设置，比如编译器配置、入口，相关的libraries等。</span><br><span class="line"></span><br><span class="line">android.iml：描述了modules，比如modules的路径,依赖关系等。</span><br><span class="line"></span><br><span class="line">android.iws：包含了一些个人工作区的设置。</span><br></pre></td></tr></table></figure>

<h2 id="2-导入源码"><a href="#2-导入源码" class="headerlink" title="2. 导入源码"></a>2. 导入源码</h2><p>接下来我们可以开始导入源码了.</p>
<p>由于Android太大了,所以我们需要给IDE更多的内存，在Help &gt; Edit Custom VM 中添加:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms1g</span><br><span class="line">-Xmx5g</span><br></pre></td></tr></table></figure>
<p>这两个参数的意思是初始堆内存为1G,最大堆内存为5G，其实不设置也没什么问题,但是经常会在看代码的时候,出现内存不够的错误信息,所以换个大内存还是很有必要的。</p>
<p>然后是AndroidStudio的类大小配置,在Help -&gt; Edit custom properties中添加:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea.max.intellisense.filesize=100000</span><br></pre></td></tr></table></figure>
<p>这个参数是定义AS默认的类大小的,默认值是2500,会导致太大的Java文件不能被识别,把这个数调大,<br>配置完成后重启IDE。</p>
<p>使用 <code>AndroidStudio</code> 打开 <code>android.ipr</code> ，之后AndroidStudio就开始打开项目了,这个过程会比较缓慢,有时,AS会出现如下信息:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Extnrnal file changes sync may be slow:The current inotify(7) watch limit is too low.</span><br></pre></td></tr></table></figure>
<p>大致的意思就是由于项目过于庞大,现在AS没有办法很好的监视整个项目的改变了,可以通过如下方式解决:</p>
<ol>
<li><p>在&#x2F;etc&#x2F;sysctl.conf 文件末尾中添加如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs.inotify.max_user_watches = 524288</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在终端执行以下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sysctl -p --system</span><br></pre></td></tr></table></figure></li>
</ol>
<p>最后重启AS，等待源码加载完成。</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-20-42-05.png" class="">

<p>由于 Android 的系统源码非常庞大，一次性导入 Android Studio 的话需要加载非常长的时间</p>
<p>因此，在正式开始导入前，我们可以打开 android.iml 文件根据自己需要调整要加载的源码。</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-21-23-53.png" class="">

<p>这里<code> &lt;excludeFolder&gt;</code> 表示不需要加载的目录，我们根据自己的需要使用 <code>&lt;excludeFolder&gt;</code> 标签添加对应的目录地址即可。</p>
<p>在加载完源码后，我们也可以在 Project Structure 中的 Module 选项中右键 exclude 来排除不需要加载的源码目录，如图：</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-20-57-37.png" class="">


<h2 id="3-开始调试"><a href="#3-开始调试" class="headerlink" title="3. 开始调试"></a>3. 开始调试</h2><p>调试前要设置 Project 的 SDK ，File -&gt; Project 下打开 Project Structure，选中 Project 设置对应版本的 SDK，于系统版本一致：</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-21-07-04.png" class="">

<p>此时点击 <code>Android Studio</code> 工具栏的 <code>run -&gt; attach debugger to Android process</code> 按钮，会打开 <code>Choose Process</code> 窗口，我们根据自己需要调试的代码选择对应的进程：</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-21-08-51.png" class="">

<p>这里假设我们要调试 <code>Android</code> 自带浏览器的源码，如图，我们在它的入口文件 <code>WebViewBrowserActivity</code> 中的 <code>loadUrlFromUrlBar</code> 方法中打上断点。</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-21-11-23.png" class="">

<p>然后我们在 <code>app</code> 的 <code>url</code> 输入栏输入 网址进行跳转,我们可以看到，代码成功进入了断点，然后我们就可以随心所欲地调试我们想要的调试的 Java 代码了。</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-21-13-00.png" class="">


<blockquote>
<p>参考：</p>
<p><a href="https://www.jianshu.com/p/4ab864caefb2">https://www.jianshu.com/p/4ab864caefb2</a></p>
<p><a href="http://gityuan.com/2016/08/13/android-os-env/">http://gityuan.com/2016/08/13/android-os-env/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android 源码调试</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Clion调试Android native源码</title>
    <url>/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E4%B8%80clion%E9%85%8D%E7%BD%AE">一、Clion配置</a><ul>
<li><a href="#1%E7%BC%96%E5%86%99cmakeliststxt">1.编写CMakelists.txt</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%AF%BC%E5%85%A5aosp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95">二、 导入Aosp项目，配置远程调试</a><ul>
<li><a href="#1-%E9%85%8D%E7%BD%AEgdb%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83">1. 配置gdb远程调试环境</a></li>
<li><a href="#2-%E7%BC%96%E5%86%99android_gdbserver%E8%84%9A%E6%9C%AC">2. 编写android_gdbserver脚本</a></li>
<li><a href="#3-%E8%B0%83%E8%AF%95">3. 调试</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%85%B6%E4%BB%96">三、其他</a><ul>
<li><a href="#1-%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95">1. 打开调试</a></li>
<li><a href="#2-%E9%85%8D%E7%BD%AEcmakelist%E5%B9%B6%E5%AF%BC%E5%85%A5%E6%BA%90%E7%A0%81">2. 配置CMakeList,并导入源码</a></li>
<li><a href="#3-%E5%AE%89%E8%A3%85androidnativedebug%E6%8F%92%E4%BB%B6%E5%B9%B6%E9%85%8D%E7%BD%AE">3. 安装AndroidNativeDebug插件，并配置</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="一、Clion配置"><a href="#一、Clion配置" class="headerlink" title="一、Clion配置"></a>一、Clion配置</h1><h2 id="1-编写CMakelists-txt"><a href="#1-编写CMakelists-txt" class="headerlink" title="1.编写CMakelists.txt"></a>1.编写<code>CMakelists.txt</code></h2><p>目前CLion只能识别CMake项目，所以为了使用CLion调试AOSP，需要编写CMakeList.txt。否则无法使用远程调试功能。<br>参考这篇博客<a href="https://blog.csdn.net/li864804994/article/details/79487834">Android Native C&#x2F;C++ 使用CLion阅读&#x2F;编译技巧</a></p>
<p>直接下载此地址的配置文件<a href="https://github.com/Ahren-Li/android-cmake-project">android-cmake-project</a>，并拷贝至Android源码根目录。</p>
<p>配置<code>env_android.cmake</code>文件，我的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">set(ANDROID_SDK_VERSION 27)</span><br><span class="line">set(ANDROID_LUNCH sailfish) # 编译目标</span><br><span class="line">set(ANDROID_TARGET_ARCH arm64)</span><br><span class="line">#set(ANDROID_ABI &quot;armeabi-v7a&quot;)</span><br><span class="line">#set(ANDROID_ABI &quot;armeabi-v7a with NEON&quot;)</span><br><span class="line">set(ANDROID_ABI &quot;arm64-v8a&quot;)</span><br><span class="line">set(ANDROID_TOOLCHAIN_NAME &quot;clang&quot;)</span><br><span class="line">set(ANDROID_STL c++_static)</span><br><span class="line">set(ANDROID_CLANG_VERSION &quot;clang-4053586&quot;)</span><br><span class="line">#set(ANDROID_PLATFORM android-25)</span><br><span class="line">#set(ANDROID_NATIVE_API_LEVEL 25)</span><br></pre></td></tr></table></figure>

<h1 id="二、-导入Aosp项目，配置远程调试"><a href="#二、-导入Aosp项目，配置远程调试" class="headerlink" title="二、 导入Aosp项目，配置远程调试"></a>二、 导入Aosp项目，配置远程调试</h1><p>导入aosp需要等待index完成。</p>
<h2 id="1-配置gdb远程调试环境"><a href="#1-配置gdb远程调试环境" class="headerlink" title="1. 配置gdb远程调试环境"></a>1. 配置gdb远程调试环境</h2><p>选择 <code>Edit Configurations</code> -&gt; <code>GDB Remote Debug</code> 按照下图进行配置：</p>
<img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-11-03.png" class="">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GDB: 这里我配置的为源码目录下的gdb</span><br><span class="line">‘target remote’ args: 这里填的端口号</span><br><span class="line">Sysroot: 这里填源码路径下的symbols</span><br><span class="line">Path mappings: 根据自己的源码填相应的path</span><br></pre></td></tr></table></figure>
<h2 id="2-编写android-gdbserver脚本"><a href="#2-编写android-gdbserver脚本" class="headerlink" title="2. 编写android_gdbserver脚本"></a>2. 编写android_gdbserver脚本</h2><p>这里我对<a href="https://blog.csdn.net/lylwo317/article/details/86545130">原博</a>中的脚本做了一点小修改，将 <code>gdbserver</code> 改为了 <code>gdbserver64</code> 。原因是后面调试时使用<code>gdb</code>连接不上远程的<code>gdbserver</code>，报错信息为<code>Reply contains invalid hex digit 59</code>，然后改为<code>gdbserver64</code>就可以了。猜测与<code>init</code>为64位程序有关。</p>
<p><code>-s ~/script/start_android_gdb_server.sh</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">gdbServerPid=`adb shell ps | grep gdbserver | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">if [[ &quot;&quot; != $&#123;gdbServerPid&#125; ]]; then</span><br><span class="line">    adb shell su -c &quot;kill $&#123;gdbServerPid&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">adb forward tcp:1234 tcp:1234</span><br><span class="line"></span><br><span class="line">if [[ `adb shell whoami` == &#x27;root&#x27;  ]]; then</span><br><span class="line">    is_root=true</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ -n $1 ]]; then</span><br><span class="line">	appPid=`adb shell ps | grep $&#123;1&#125; | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">	if [[ -n $&#123;appPid&#125; ]]; then</span><br><span class="line">        if [[ $is_root == true  ]]; then</span><br><span class="line">            adb shell gdbserver64 :1234 --attach $&#123;appPid&#125;</span><br><span class="line">        else</span><br><span class="line">            adb shell su -c &quot;gdbserver64 :1234 --attach $&#123;appPid&#125; &quot;</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line">    	echo &quot;$1 进程没有启动！&quot;</span><br><span class="line">	fi</span><br><span class="line">else</span><br><span class="line">	echo &quot;请设置要调试的进程名（app的进程名是包名）。例如 $0 &lt;process name&gt;&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>通过软连接连接到 ~&#x2F;bin目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s ~/script/start_android_gdb_server.sh ~/bin/android_gdb_server</span><br></pre></td></tr></table></figure>

<h2 id="3-调试"><a href="#3-调试" class="headerlink" title="3. 调试"></a>3. 调试</h2><p>这里通过调试zygote来演示如何使用CLion调试</p>
<ol>
<li><p>先停止zygote服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell stop zygote</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动gdbserver</p>
</li>
</ol>
<img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-28-38.png" class="">

<ol start="3">
<li>点击调试按钮（右边绿色按钮）</li>
</ol>
<img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-29-40.png" class="">

<p>如下图表示连接成功</p>
<img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-30-57.png" class="">
<img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-31-16.png" class="">

<ol start="4">
<li><p>设置断点位置如下<br><code>system/core/init/service.cpp</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool Service::Start() &#123;</span><br><span class="line">    // Starting a service removes it from the disabled or reset state and</span><br><span class="line">    // immediately takes it out of the restarting state if it was in there.</span><br><span class="line">    flags_ &amp;= (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START));</span><br><span class="line"></span><br><span class="line">    // Running processes require no additional work --- if they&#x27;re in the</span><br><span class="line">    // process of exiting, we&#x27;ve ensured that they will immediately restart</span><br><span class="line">    // on exit, unless they are ONESHOT.</span><br><span class="line">    if (flags_ &amp; SVC_RUNNING) &#123;//在这里断点</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动zygote服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell start zygote</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止在断点处</p>
</li>
</ol>
<img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-32-26.png" class="">

<blockquote>
<p>参考：<a href="https://blog.csdn.net/lylwo317/article/details/86545130">https://blog.csdn.net/lylwo317/article/details/86545130</a></p>
</blockquote>
<h1 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h1><p>使用<a href="https://www.lili.kim/2019/01/28/android/Debug%20Android%20Native%20with%20LLDB/">此链接</a>的方法进行调试，记录以下使用过程，虽然未成功。</p>
<h2 id="1-打开调试"><a href="#1-打开调试" class="headerlink" title="1. 打开调试"></a>1. 打开调试</h2><p>将下列内容添加至 <code>aosp/build/core/binary.mk</code> 中， 加了之后编译的系统暂时未感觉有什么不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"># No one should ever use this flag. On GCC it&#x27;s mere presence will disable all</span><br><span class="line"># warnings, even those that are specified after it (contrary to typical warning</span><br><span class="line"># flag behavior). This circumvents CFLAGS_NO_OVERRIDE from forcibly enabling the</span><br><span class="line"># warnings that are *always* bugs.</span><br><span class="line">my_illegal_flags := -w</span><br><span class="line">my_cflags := $(filter-out $(my_illegal_flags),$(my_cflags))</span><br><span class="line">my_cppflags := $(filter-out $(my_illegal_flags),$(my_cppflags))</span><br><span class="line">my_conlyflags := $(filter-out $(my_illegal_flags),$(my_conlyflags))</span><br><span class="line"></span><br><span class="line">#调试信息</span><br><span class="line">ifndef LOCAL_IS_HOST_MODULE</span><br><span class="line">    lili_test_so := libsurfaceflinger libcutils liblog libbinder libutils \</span><br><span class="line">                    libc++ libc libm libhardware libui libgui libpowermanager \</span><br><span class="line">                    libvulkan libbacktrace libsync libnativeloader libbase libz \</span><br><span class="line">                    gralloc.msm8974 libmemalloc hwcomposer.msm8974 liboverlay libhdmi \</span><br><span class="line">                    libhardware_legacy libmedia libskia libvirtual libstdc++</span><br><span class="line"></span><br><span class="line">    ifneq (,$(filter $(LOCAL_MODULE), $(lili_test_so)))</span><br><span class="line">            my_cflags_no_override += -O0 -g3 -Wno-error</span><br><span class="line">            ifeq ($(my_clang),true)</span><br><span class="line">                my_cflags_no_override += -fno-limit-debug-info -glldb</span><br><span class="line">            else</span><br><span class="line">                my_cflags_no_override += -ggdb3</span><br><span class="line">            endif</span><br><span class="line">    endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_YACCFLAGS := $(LOCAL_YACCFLAGS)</span><br></pre></td></tr></table></figure>

<h2 id="2-配置CMakeList-并导入源码"><a href="#2-配置CMakeList-并导入源码" class="headerlink" title="2. 配置CMakeList,并导入源码"></a>2. 配置CMakeList,并导入源码</h2><p>这个和之前的没有区别，略。</p>
<h2 id="3-安装AndroidNativeDebug插件，并配置"><a href="#3-安装AndroidNativeDebug插件，并配置" class="headerlink" title="3. 安装AndroidNativeDebug插件，并配置"></a>3. 安装<code>AndroidNativeDebug</code>插件，并配置</h2><img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-57-32.png" class="">

<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody><tr>
<td>SDK</td>
<td>Android SDK Path</td>
<td>none</td>
</tr>
<tr>
<td>NDK</td>
<td>Android NDK Path (Auto gen when ndk-bundle exist in SDK)</td>
<td>none</td>
</tr>
<tr>
<td>LLDB</td>
<td>LLDB Path (Auto gen when lldb exist in SDK)</td>
<td>none</td>
</tr>
<tr>
<td>Remote</td>
<td>LLDB Target Remote</td>
<td>unix-abstract-connect:&#x2F;&#x2F;&#x2F;sdcard&#x2F;debug.sock</td>
</tr>
<tr>
<td>Adb Root</td>
<td>The adb can root?</td>
<td>false</td>
</tr>
<tr>
<td>Process Name</td>
<td>The name of debug process</td>
<td>none</td>
</tr>
</tbody></table>
<img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-58-32.png" class="">

<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody><tr>
<td>Android Source</td>
<td>Android Source Tree Path</td>
<td>none</td>
</tr>
<tr>
<td>Lunch</td>
<td>Android target lunch</td>
<td>none</td>
</tr>
</tbody></table>
<p>后续直接进行调试就可以了。</p>
<p>我这里遇到的问题，可以启动调试，但是断点无法段下来，后续有时间再研究。</p>
<blockquote>
<p>参考：<a href="https://www.lili.kim/2019/01/28/android/Debug%20Android%20Native%20with%20LLDB/">https://www.lili.kim/2019/01/28/android/Debug%20Android%20Native%20with%20LLDB/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android 源码调试</tag>
      </tags>
  </entry>
  <entry>
    <title>从ActivityThread.main开始分析android应用的启动过程</title>
    <url>/2020/06/20/%E4%BB%8EActivityThread-main%E5%BC%80%E5%A7%8B%E5%88%86%E6%9E%90android%E5%BA%94%E7%94%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>最近准备学习一下 <a href="https://github.com/hanbinglengyue/FART">FART</a> 的源码及其相关文章的过程中发现绕不开 Android 应用的启动过程，所以准备阅读一下 android 的源码，了解一下相关知识。</p>
<p>本文研究的源码为 Android 9 。</p>
<!-- TOC -->

<ul>
<li><a href="#activitythreadmain">ActivityThread.main</a></li>
<li><a href="#activitythreadattach">ActivityThread.attach</a></li>
<li><a href="#activitymanagerserviceattachapplication">ActivityManagerService.attachApplication</a></li>
<li><a href="#activitymanagerserviceattachapplicationlocked">ActivityManagerService.attachApplicationLocked</a></li>
<li><a href="#activitythreadapplicationthreadbindapplication">ActivityThread.ApplicationThread.bindApplication</a></li>
<li><a href="#activitythreadhandlebindapplication">ActivityThread.handleBindApplication</a></li>
<li><a href="#activitymanagerserviceattachapplicationlocked-1">ActivityManagerService.attachApplicationLocked</a></li>
<li><a href="#activitystacksupervisorrealstartactivitylocked">ActivityStackSupervisor.realStartActivityLocked</a></li>
<li><a href="#transactionexecutorexecute">TransactionExecutor.execute</a></li>
<li><a href="#activitythreadhandlelaunchactivity">ActivityThread.handleLaunchActivity</a></li>
<li><a href="#instrumentationcallactivityoncreate">Instrumentation.callActivityOnCreate</a></li>
</ul>
<!-- /TOC -->

<h1 id="ActivityThread-main"><a href="#ActivityThread-main" class="headerlink" title="ActivityThread.main"></a>ActivityThread.main</h1><p>在 <code>ActivityThread.main</code> 方法中对 <code>ActivityThread</code> 进行了初始化，创建了主线程的 <code>Looper</code> 对象并调用 <code>Looper.loop()</code> 方法启动 Looper，把自定义 Handler 类 H 的对象作为主线程的 handler 。接下来跳转到 <code>ActivityThread.attach</code> 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // 创建 ActivityThread 实例</span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    // 完成一系列初始化工作，需要跟进分析</span><br><span class="line">    thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler == null) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (false) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(new</span><br><span class="line">                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // End of event ActivityThreadMain.</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    //// 主线程进入消息循环</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ActivityThread-attach"><a href="#ActivityThread-attach" class="headerlink" title="ActivityThread.attach"></a>ActivityThread.attach</h1><p>在 <code>ActivityThread.attach</code> 方法中，会通过 <code>ActivityManagerService</code> 为这个应用绑定一个 <code>Application</code> , 这里的关键方法为 <code>attachApplication</code> , 我们需要进一步跟进。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">private void attach(boolean system, long startSeq) &#123;</span><br><span class="line">    sCurrentActivityThread = this;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    if (!system) &#123;</span><br><span class="line">        ViewRootImpl.addFirstDrawHandler(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;,</span><br><span class="line">                                                UserHandle.myUserId());</span><br><span class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line"></span><br><span class="line">        // 获得AMS(ActivityManagerService)实例, AMS的log tag: &quot;ActivityManager&quot;</span><br><span class="line">        final IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 把 ApplicationThread 对象传给AMS</span><br><span class="line">            mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            throw ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ActivityManagerService-attachApplication"><a href="#ActivityManagerService-attachApplication" class="headerlink" title="ActivityManagerService.attachApplication"></a>ActivityManagerService.attachApplication</h1><p>这个方法没什么好看的，直接无脑跟进 <code>attachApplicationLocked</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line"></span><br><span class="line">public final void attachApplication(IApplicationThread thread, long startSeq) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        int callingPid = Binder.getCallingPid();</span><br><span class="line">        final int callingUid = Binder.getCallingUid();</span><br><span class="line">        final long origId = Binder.clearCallingIdentity();</span><br><span class="line">        //继续跟进</span><br><span class="line">        attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ActivityManagerService-attachApplicationLocked"><a href="#ActivityManagerService-attachApplicationLocked" class="headerlink" title="ActivityManagerService.attachApplicationLocked"></a>ActivityManagerService.attachApplicationLocked</h1><p>通过 binder , 跨进程调用 ApplicationThread 的 bindApplication() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line"></span><br><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">        int pid, int callingUid, long startSeq) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        else if (app.instr != null) &#123;</span><br><span class="line"></span><br><span class="line">            // 通过 binder , 跨进程调用 ApplicationThread 的 bindApplication() 方法, 下面代码逻辑重回 ActivityThread.java</span><br><span class="line">            thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                    app.instr.mClass,</span><br><span class="line">                    profilerInfo, app.instr.mArguments,</span><br><span class="line">                    app.instr.mWatcher,</span><br><span class="line">                    app.instr.mUiAutomationConnection, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                    new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                    getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, isAutofillCompatEnabled);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            thread.bindApplication(processName, appInfo, providers, null, profilerInfo,</span><br><span class="line">                    null, null, null, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                    new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                    getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, isAutofillCompatEnabled);</span><br><span class="line">        &#125;</span><br><span class="line">        if (profilerInfo != null) &#123;</span><br><span class="line">            profilerInfo.closeFd();</span><br><span class="line">            profilerInfo = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ActivityThread-ApplicationThread-bindApplication"><a href="#ActivityThread-ApplicationThread-bindApplication" class="headerlink" title="ActivityThread.ApplicationThread.bindApplication"></a>ActivityThread.ApplicationThread.bindApplication</h1><p><code>bindApplication</code> 最终通过发送消息 <code>BIND_APPLICATION</code> 给 <code>H</code> 处理，然后调用 <code>handleBindApplication</code> 处理该消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo,</span><br><span class="line">        List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">        ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">        IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">        IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">        boolean enableBinderTracking, boolean trackAllocation,</span><br><span class="line">        boolean isRestrictedBackupMode, boolean persistent, Configuration config,</span><br><span class="line">        CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span><br><span class="line">        String buildSerial, boolean autofillCompatibilityEnabled) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 发消息</span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">        TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)</span><br><span class="line">        + &quot;: &quot; + arg1 + &quot; / &quot; + obj);</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    if (async) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    //通过mH把BIND_APPLICATION消息发给H处理</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">        case BIND_APPLICATION:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);</span><br><span class="line">            AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">            // 调用ActivityThread的handleBindApplication()方法处理</span><br><span class="line">            handleBindApplication(data);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ActivityThread-handleBindApplication"><a href="#ActivityThread-handleBindApplication" class="headerlink" title="ActivityThread.handleBindApplication"></a>ActivityThread.handleBindApplication</h1><p><code>handleBindApplication</code> 开始创建 <code>Application</code> 类相关的的数据，并调用 <code>Application</code> 对象的 <code>attach</code> 和 <code>onCreate</code> 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line"></span><br><span class="line">    // 1: 创建LoadedApk对象</span><br><span class="line">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 2: 创建ContextImpl对象; 并对其进行初始化.</span><br><span class="line">    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);</span><br><span class="line">    updateLocaleListFromAppContext(appContext,</span><br><span class="line">            mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //  3: 创建 Instrumentation</span><br><span class="line">            final ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">            mInstrumentation = (Instrumentation)</span><br><span class="line">                cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate instrumentation &quot;</span><br><span class="line">                + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        //  4: 创建Application对象;在makeApplication函数中调用了newApplication，</span><br><span class="line">        //  在该函数中又调用了app.attach(context)，在attach函数中调用了Application.attachBaseContext函数</span><br><span class="line">        app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line"></span><br><span class="line">       ....</span><br><span class="line">        try &#123;</span><br><span class="line">            // 调Application的生命周期函数 onCreate()</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//frameworks/base/core/java/android/app/LoadedApk.java</span><br><span class="line"></span><br><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">        Instrumentation instrumentation) &#123;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        if (!mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                    &quot;initializeJavaContextClassLoader&quot;);</span><br><span class="line">            initializeJavaContextClassLoader();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">        // 调用 attch 函数</span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/Instrumentation.java</span><br><span class="line"></span><br><span class="line">public Application newApplication(ClassLoader cl, String className, Context context)</span><br><span class="line">        throws InstantiationException, IllegalAccessException, </span><br><span class="line">        ClassNotFoundException &#123;</span><br><span class="line">    Application app = getFactory(context.getPackageName())</span><br><span class="line">            .instantiateApplication(cl, className);</span><br><span class="line">    app.attach(context);</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/Instrumentation.java</span><br><span class="line"></span><br><span class="line">public void callApplicationOnCreate(Application app) &#123;</span><br><span class="line">    app.onCreate();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>至此整个 <code>Application</code> 类的流程就结束了，下面将继续跟进 Activity 的流程 。</p>
<h1 id="ActivityManagerService-attachApplicationLocked-1"><a href="#ActivityManagerService-attachApplicationLocked-1" class="headerlink" title="ActivityManagerService.attachApplicationLocked"></a>ActivityManagerService.attachApplicationLocked</h1><p>回到 <code>attachApplicationLocked</code> 方法，继续向下跟，可以发现一段注释 <code>See if the top visible activity is waiting to run in this process</code> , 这里就是调用 <code>Activity</code> 的关键, 跟进 <code>mStackSupervisor.attachApplicationLocked</code> 后，发现关键方法为 <code>realStartActivityLocked</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line"></span><br><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">        int pid, int callingUid, long startSeq) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // See if the top visible activity is waiting to run in this process...</span><br><span class="line">    if (normalMode) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 开始调用 activity 的 oncreate 方法</span><br><span class="line">            if (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                didSomething = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">            badApp = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</span><br><span class="line"></span><br><span class="line">boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (realStartActivityLocked(activity, app,</span><br><span class="line">            top == activity /* andResume */, true /* checkConfig */)) &#123;</span><br><span class="line">        didSomething = true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ActivityStackSupervisor-realStartActivityLocked"><a href="#ActivityStackSupervisor-realStartActivityLocked" class="headerlink" title="ActivityStackSupervisor.realStartActivityLocked"></a>ActivityStackSupervisor.realStartActivityLocked</h1><p>在 <code>realStartActivityLocked</code> 创建了一个 <code>activity launch transaction</code>, 然后再调用 <code>scheduleTransaction</code> 来实现将 <code>EXECUTE_TRANSACTION</code> 消息发送给 <code>ActivityThread.H</code> 进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</span><br><span class="line">final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">        boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // Create activity launch transaction.</span><br><span class="line">    final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class="line">            r.appToken);</span><br><span class="line">    clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),</span><br><span class="line">            System.identityHashCode(r), r.info,</span><br><span class="line">            // TODO: Have this take the merged configuration instead of separate global</span><br><span class="line">            // and override configs.</span><br><span class="line">            mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">            mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">            r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">            r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">            profilerInfo));</span><br><span class="line"></span><br><span class="line">    // Set desired final state.</span><br><span class="line">    final ActivityLifecycleItem lifecycleItem;</span><br><span class="line">    if (andResume) &#123;</span><br><span class="line">        lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">    &#125;</span><br><span class="line">    clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">    // Schedule transaction.</span><br><span class="line">    mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/services/core/java/com/android/server/am/ClientLifecycleManager.java</span><br><span class="line">void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;</span><br><span class="line">    final IApplicationThread client = transaction.getClient();</span><br><span class="line">    transaction.schedule();</span><br><span class="line">    if (!(client instanceof Binder)) &#123;</span><br><span class="line">        // If client is not an instance of Binder - it&#x27;s a remote call and at this point it is</span><br><span class="line">        // safe to recycle the object. All objects used for local calls will be recycled after</span><br><span class="line">        // the transaction is executed on client in ActivityThread.</span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/servertransaction/ClientTransaction.java</span><br><span class="line"></span><br><span class="line">public void schedule() throws RemoteException &#123;</span><br><span class="line">    mClient.scheduleTransaction(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">public void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;</span><br><span class="line">    ActivityThread.this.scheduleTransaction(transaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/ClientTransactionHandler.java</span><br><span class="line"></span><br><span class="line">void scheduleTransaction(ClientTransaction transaction) &#123;</span><br><span class="line">    transaction.preExecute(this);</span><br><span class="line">    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    case EXECUTE_TRANSACTION:</span><br><span class="line">        final ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">        mTransactionExecutor.execute(transaction);</span><br><span class="line">        if (isSystem()) &#123;</span><br><span class="line">            // Client transactions inside system process are recycled on the client side</span><br><span class="line">            // instead of ClientLifecycleManager to avoid being cleared before this</span><br><span class="line">            // message is handled.</span><br><span class="line">            transaction.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        // TODO(lifecycler): Recycle locally scheduled transactions.</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="TransactionExecutor-execute"><a href="#TransactionExecutor-execute" class="headerlink" title="TransactionExecutor.execute"></a>TransactionExecutor.execute</h1><p><code>execute</code> 经过一系列处理后最终调用了 <code>LaunchActivityItem.execute</code> 方法, 看到 <code>LaunchActivityItem</code> 这个类名就可以知道距离关键地方已经不远了, 继续跟进 <code>handleLaunchActivity</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java</span><br><span class="line"></span><br><span class="line">public void execute(ClientTransaction transaction) &#123;</span><br><span class="line">    final IBinder token = transaction.getActivityToken();</span><br><span class="line">    log(&quot;Start resolving transaction for client: &quot; + mTransactionHandler + &quot;, token: &quot; + token);</span><br><span class="line"></span><br><span class="line">    executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">    executeLifecycleState(transaction);</span><br><span class="line">    mPendingActions.clear();</span><br><span class="line">    log(&quot;End resolving transaction&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java</span><br><span class="line"></span><br><span class="line">private void executeLifecycleState(ClientTransaction transaction) &#123;</span><br><span class="line">    final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">    if (lifecycleItem == null) &#123;</span><br><span class="line">        // No lifecycle request, return early.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    log(&quot;Resolving lifecycle state: &quot; + lifecycleItem);</span><br><span class="line"></span><br><span class="line">    final IBinder token = transaction.getActivityToken();</span><br><span class="line">    final ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">    if (r == null) &#123;</span><br><span class="line">        // Ignore requests for non-existent client records for now.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Cycle to the state right before the final requested state.</span><br><span class="line">    cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */);</span><br><span class="line"></span><br><span class="line">    // Execute the final transition with proper parameters.</span><br><span class="line">    lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/servertransaction/LaunchActivityItem.java</span><br><span class="line"></span><br><span class="line">public void execute(ClientTransactionHandler client, IBinder token,</span><br><span class="line">        PendingTransactionActions pendingActions) &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">    ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">            mProfilerInfo, client);</span><br><span class="line">    client.handleLaunchActivity(r, pendingActions, null /* customIntent */);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="ActivityThread-handleLaunchActivity"><a href="#ActivityThread-handleLaunchActivity" class="headerlink" title="ActivityThread.handleLaunchActivity"></a>ActivityThread.handleLaunchActivity</h1><p>经过上面代码一步步的跳转，执行到 <code>ActivityThread.performLaunchActivity</code> 方法。在 <code>ActivityThread.performLaunchActivity</code> 方法中首先对 <code>Activity</code> 的 <code>ComponentName</code> 、 <code>ContextImpl</code> 、 <code>Activity</code> 以及 <code>Application</code> 对象进行了初始化并相互关联，然后设置 <code>Activity</code> 主题，最后调用 <code>Instrumentation.callActivityOnCreate</code> 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">public Activity handleLaunchActivity(ActivityClientRecord r,</span><br><span class="line">        PendingTransactionActions pendingActions, Intent customIntent) &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">    // 启动一个Activity，涉及到创建Activity对象，最终返回Activity对象</span><br><span class="line">    final Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    if (a != null) &#123;</span><br><span class="line">        r.createdConfig = new Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        if (!r.activity.mFinished &amp;&amp; pendingActions != null) &#123;</span><br><span class="line">            pendingActions.setOldState(r.state);</span><br><span class="line">            pendingActions.setRestoreInstanceState(true);</span><br><span class="line">            pendingActions.setCallOnPostCreate(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // If there was an error, for any reason, tell the activity manager to stop us.</span><br><span class="line">        try &#123;</span><br><span class="line">            //  activity启动失败，则通知AMS finish掉这个Activity</span><br><span class="line">            ActivityManager.getService()</span><br><span class="line">                    .finishActivity(r.token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            throw ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    Activity activity = null;</span><br><span class="line"></span><br><span class="line">    // 创建一个 activity</span><br><span class="line">    java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">    activity = mInstrumentation.newActivity(</span><br><span class="line">            cl, component.getClassName(), r.intent);</span><br><span class="line">    StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">    r.intent.setExtrasClassLoader(cl);</span><br><span class="line">    r.intent.prepareToEnterProcess();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    appContext.setOuterContext(activity);</span><br><span class="line">    // 调用 activity.attach</span><br><span class="line">    activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">            r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">            r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">            r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    int theme = r.activityInfo.getThemeResource();</span><br><span class="line">    if (theme != 0) &#123;</span><br><span class="line">        activity.setTheme(theme);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    activity.mCalled = false;</span><br><span class="line">    if (r.isPersistable()) &#123;</span><br><span class="line">        // 调用 activity 的 OnCreate</span><br><span class="line">        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Instrumentation-callActivityOnCreate"><a href="#Instrumentation-callActivityOnCreate" class="headerlink" title="Instrumentation.callActivityOnCreate"></a>Instrumentation.callActivityOnCreate</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/core/java/android/app/Instrumentation.java</span><br><span class="line"></span><br><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/Activity.java</span><br><span class="line"></span><br><span class="line">final void performCreate(Bundle icicle) &#123;</span><br><span class="line">    performCreate(icicle, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123;</span><br><span class="line">    mCanEnterPictureInPicture = true;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    if (persistentState != null) &#123;</span><br><span class="line">        onCreate(icicle, persistentState);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 调用 onCreate</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">    &#125;</span><br><span class="line">    writeEventLog(LOG_AM_ON_CREATE_CALLED, &quot;performCreate&quot;);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line"></span><br><span class="line">    mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(</span><br><span class="line">            com.android.internal.R.styleable.Window_windowNoDisplay, false);</span><br><span class="line">    mFragments.dispatchActivityCreated();</span><br><span class="line">    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就基本分析了Activity的启动流程。 这里只是简单的过了一遍，让自己对 Android 应用的启动过程中 frameworks 层做了那些工作，主要还是为了理解 FART 做的一些准备。</p>
<p>参考：</p>
<blockquote>
<p><a href="https://juejin.im/post/5dda8504e51d452306073434#heading-10">https://juejin.im/post/5dda8504e51d452306073434#heading-10</a></p>
<p><a href="https://www.jianshu.com/p/a1f40b39b3de">https://www.jianshu.com/p/a1f40b39b3de</a></p>
<p><a href="https://bbs.pediy.com/thread-252630.htm">https://bbs.pediy.com/thread-252630.htm</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Idea调试jebPro</title>
    <url>/2020/06/05/%E4%BD%BF%E7%94%A8Idea%E8%B0%83%E8%AF%95jebPro/</url>
    <content><![CDATA[<p>参考:</p>
<blockquote>
<p><a href="http://scz.617.cn:8/misc/202006051232.txt">http://scz.617.cn:8/misc/202006051232.txt</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.ms509.com/2020/03/19/Java-Debug/">https://www.ms509.com/2020/03/19/Java-Debug/</a></p>
</blockquote>
<!-- TOC -->

<ul>
<li><a href="#%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87">前期准备</a></li>
<li><a href="#%E5%BC%80%E5%A7%8B%E8%B0%83%E8%AF%95">开始调试</a></li>
</ul>
<!-- /TOC -->

<h1 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1. 前期准备"></a>1. 前期准备</h1><p>使用 Idea 新建一个空 java 工程。</p>
<img src="/2020/06/05/%E4%BD%BF%E7%94%A8Idea%E8%B0%83%E8%AF%95jebPro/2020-06-05-17-56-40.png" class="">

<p>把待调试的jar包加入到工程的依赖包中：右键点击工程名，选择 <code>Open Module Setteings</code> 。</p>
<img src="/2020/06/05/%E4%BD%BF%E7%94%A8Idea%E8%B0%83%E8%AF%95jebPro/2020-06-05-17-58-34.png" class="">

<p>然后在Libraries中加入待调试的jar文件。</p>
<img src="/2020/06/05/%E4%BD%BF%E7%94%A8Idea%E8%B0%83%E8%AF%95jebPro/2020-06-05-18-00-04.png" class="">

<p>然后就可以在工程中反编译jar包了，下好断点。</p>
<img src="/2020/06/05/%E4%BD%BF%E7%94%A8Idea%E8%B0%83%E8%AF%95jebPro/2020-06-05-18-04-33.png" class="">

<h1 id="2-开始调试"><a href="#2-开始调试" class="headerlink" title="2. 开始调试"></a>2. 开始调试</h1><p>以调试方式启动 jeb 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar -Xdebug -Xrunjdwp:transport=dt_socket,address=9000,server=y,suspend=n jebc.jar</span><br></pre></td></tr></table></figure>

<p>使用 Idea 附加 Jeb , <code>Run-&gt;Attach to Process</code> 选中 jeb。</p>
<img src="/2020/06/05/%E4%BD%BF%E7%94%A8Idea%E8%B0%83%E8%AF%95jebPro/2020-06-05-18-08-23.png" class="">

<p>在 jeb 中选则关于，可以看到直接断在断点处。</p>
<img src="/2020/06/05/%E4%BD%BF%E7%94%A8Idea%E8%B0%83%E8%AF%95jebPro/2020-06-05-18-10-17.png" class="">


<p>可以很清楚的看到和修改各变量的值，剩下的就自我发挥了。</p>
<h2 id="Jeb-配置"><a href="#Jeb-配置" class="headerlink" title="Jeb 配置"></a>Jeb 配置</h2><ol>
<li>禁止自动展开包结构</li>
</ol>
<ul>
<li>jeb 5.x</li>
</ul>
<p>进入下面设置面板 <code>Edit -&gt; Options -&gt; Back-end Properties... -&gt; parsers -&gt; dex</code> 滚动进度条至 <code>Well known library packages</code> GroupBox 控件，将该控件中编辑框内容修改为 <code>*</code> 。</p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>JEB</tag>
      </tags>
  </entry>
  <entry>
    <title>使用编译器查看类的内存布局</title>
    <url>/2023/08/03/%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n + p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">bar</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n + p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> cx, cy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n + a + p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    Point a_point;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sizeof</span>(Derived);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="msvc"><a href="#msvc" class="headerlink" title="msvc"></a>msvc</h1><p>命令格式：</p>
<ul>
<li>查看单个类的内存布局： <code>cl &lt;FileName&gt; /d1reportSingleClassLayout[ClassName]</code> 。</li>
<li>查看所有类的内存布局： <code>cl &lt;FileName&gt; /d1reportAllClassLayout</code> 。</li>
</ul>
<p>使用 cl 查看单个类的内存布局：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cl main.cpp /d1reportSingleClassLayoutDerived &gt; msvc.txt</span><br></pre></td></tr></table></figure>

<p>输出内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">main.cpp</span><br><span class="line"></span><br><span class="line">class Derived	size(40):</span><br><span class="line">	+---</span><br><span class="line"> 0	| +--- (base class Base)</span><br><span class="line"> 0	| | &#123;vfptr&#125;</span><br><span class="line"> 4	| | n</span><br><span class="line">	| +---</span><br><span class="line"> 8	| a</span><br><span class="line">12	| b</span><br><span class="line">16	| Point a_point</span><br><span class="line">32	| c</span><br><span class="line">  	| &lt;alignment member&gt; (size=7)</span><br><span class="line">	+---</span><br><span class="line"></span><br><span class="line">Derived::<span class="variable">$vftable</span>@:</span><br><span class="line">	| &amp;Derived_meta</span><br><span class="line">	|  0</span><br><span class="line"> 0	| &amp;Base::bar</span><br><span class="line">Microsoft (R) Incremental Linker Version 14.29.30151.0</span><br><span class="line">Copyright (C) Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line">/out:main.exe</span><br><span class="line">main.obj</span><br></pre></td></tr></table></figure>


<p>参考：<a href="https://www.gonwan.com/2010/09/20/c-class-layout-using-msvc/">https://www.gonwan.com/2010/09/20/c-class-layout-using-msvc/</a></p>
<h1 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h1><p>命令格式：</p>
<ul>
<li>gcc8 之前：<code>gcc -fdump-class-hierarchy &lt;FileName&gt;</code>。</li>
<li>gcc8 之后：<code>gcc -fdump-lang-class &lt;FileName&gt;</code>。</li>
</ul>
<p>使用例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fdump-lang-class main.cpp</span><br></pre></td></tr></table></figure>

<p>输出的内容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Vtable <span class="keyword">for</span> Base</span><br><span class="line">Base::_ZTV4Base: 3 entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">8     (int (*)(...))(&amp; _ZTI4Base)</span><br><span class="line">16    (int (*)(...))Base::bar</span><br><span class="line"></span><br><span class="line">Class Base</span><br><span class="line">   size=16 align=8</span><br><span class="line">   base size=12 base align=8</span><br><span class="line">Base (0x0x7fcb184c8420) 0</span><br><span class="line">    vptr=((&amp; Base::_ZTV4Base) + <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">Class Point</span><br><span class="line">   size=<span class="number">16</span> align=<span class="number">8</span></span><br><span class="line">   base size=<span class="number">16</span> base align=<span class="number">8</span></span><br><span class="line">Point (<span class="number">0</span>x0x7fcb184c8540) <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Vtable for Derived</span><br><span class="line">Derived::_ZTV7Derived: <span class="number">3</span> entries</span><br><span class="line"><span class="number">0</span>     (int (*)(...))0</span><br><span class="line">8     (int (*)(...))(&amp; _ZTI7Derived)</span><br><span class="line">16    (int (*)(...))Base::bar</span><br><span class="line"></span><br><span class="line">Class Derived</span><br><span class="line">   size=48 align=8</span><br><span class="line">   base size=41 base align=8</span><br><span class="line">Derived (0x0x7fcb18374208) 0</span><br><span class="line">    vptr=((&amp; Derived::_ZTV7Derived) + <span class="number">16</span>)</span><br><span class="line">  Base (<span class="number">0</span>x0x7fcb184c85a0) <span class="number">0</span></span><br><span class="line">      primary-for Derived (<span class="number">0</span>x0x7fcb18374208)</span><br></pre></td></tr></table></figure>



<p>参考：</p>
<p><a href="https://stackoverflow.com/questions/2979606/print-layout-of-c-object-with-g-compiler">https://stackoverflow.com/questions/2979606/print-layout-of-c-object-with-g-compiler</a></p>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Developer-Options.html">https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Developer-Options.html</a></p>
<h1 id="clang"><a href="#clang" class="headerlink" title="clang"></a>clang</h1><p>命令格式：<code>clang -cc1 -fdump-record-layouts &lt;FileName&gt;</code></p>
<p>使用例子:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -cc1 -fdump-record-layouts main.cpp &gt; clang.txt</span><br></pre></td></tr></table></figure>

<p>输出内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*** Dumping AST Record Layout</span><br><span class="line">         0 | class Base</span><br><span class="line">         0 |   (Base vtable pointer)</span><br><span class="line">         8 |   int n</span><br><span class="line">           | [sizeof=16, dsize=12, align=8,</span><br><span class="line">           |  nvsize=12, nvalign=8]</span><br><span class="line"></span><br><span class="line">*** Dumping AST Record Layout</span><br><span class="line">         0 | struct Point</span><br><span class="line">         0 |   double cx</span><br><span class="line">         8 |   double cy</span><br><span class="line">           | [sizeof=16, dsize=16, align=8,</span><br><span class="line">           |  nvsize=16, nvalign=8]</span><br><span class="line"></span><br><span class="line">*** Dumping AST Record Layout</span><br><span class="line">         0 | class Derived</span><br><span class="line">         0 |   class Base (primary base)</span><br><span class="line">         0 |     (Base vtable pointer)</span><br><span class="line">         8 |     int n</span><br><span class="line">        12 |   int a</span><br><span class="line">        16 |   int b</span><br><span class="line">        24 |   struct Point a_point</span><br><span class="line">        24 |     double cx</span><br><span class="line">        32 |     double cy</span><br><span class="line">        40 |   char c</span><br><span class="line">           | [sizeof=48, dsize=41, align=8,</span><br><span class="line">           |  nvsize=41, nvalign=8]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考：<br><a href="https://eli.thegreenplace.net/2012/12/17/dumping-a-c-objects-memory-layout-with-clang/">https://eli.thegreenplace.net/2012/12/17/dumping-a-c-objects-memory-layout-with-clang/</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>堆溢出利用</title>
    <url>/2022/05/10/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="堆的数据结构和管理策略"><a href="#堆的数据结构和管理策略" class="headerlink" title="堆的数据结构和管理策略"></a>堆的数据结构和管理策略</h1><h2 id="空表"><a href="#空表" class="headerlink" title="空表"></a>空表</h2><p>空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分为 128条。</p>
<h2 id="块表"><a href="#块表" class="headerlink" title="块表"></a>块表</h2>]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>0day安全：软件漏洞分析技术</tag>
      </tags>
  </entry>
  <entry>
    <title>史上最优雅的NDK加载pass方案</title>
    <url>/2020/03/07/%E5%8F%B2%E4%B8%8A%E6%9C%80%E4%BC%98%E9%9B%85%E7%9A%84NDK%E5%8A%A0%E8%BD%BDpass%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote>
<p>转载 : <a href="https://xz.aliyun.com/t/6643">https://xz.aliyun.com/t/6643</a></p>
</blockquote>
<p>关键词：</p>
<ul>
<li>不需要编译llvm</li>
<li>仅依赖NDK，不需要额外的其他环境</li>
<li>不会遇到配置引起的符号NotFound问题</li>
<li>不污染NDK<!-- TOC --></li>
</ul>
<ul>
<li><a href="#%E4%B8%80%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D">一、背景介绍</a></li>
<li><a href="#%E4%BA%8C%E4%BD%BF%E7%94%A8ndk%E7%9A%84%E7%8E%AF%E5%A2%83%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AApass">二、使用NDK的环境编译一个pass</a></li>
<li><a href="#%E4%B8%89%E4%BD%BF%E7%94%A8ndk%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AApass">三、使用NDK的环境加载一个pass</a></li>
<li><a href="#%E5%9B%9B%E5%BD%93%E6%88%91%E4%BB%AC%E6%9D%A5%E5%88%B0macos%E4%B8%8A">四、当我们来到macOS上</a></li>
<li><a href="#%E4%BA%94%E5%BD%93%E6%88%91%E4%BB%AC%E6%9D%A5%E5%88%B0windows">五、当我们来到Windows</a></li>
<li><a href="#%E5%85%AD%E5%85%B6%E4%BB%96">六、其他</a></li>
</ul>
<!-- /TOC -->


<h1 id="一、背景介绍"><a href="#一、背景介绍" class="headerlink" title="一、背景介绍"></a>一、背景介绍</h1><p>现在代码保护技术很多是在llvm上实现的，例如 ollvm 和 hikari，作者给出的实现是将源码混杂在llvm中，这样做非常不优雅。近来越来越多安全工作者都开始接触和研究基于llvm的代码保护，工欲善其事必先利其器，在编译、运行均是本机的环境下，不会出问题，因此本文介绍的是，如何优雅地在NDK中加载pass。</p>
<p>安卓开发者使用混淆技术来保护native代码时，一般有两种选择：</p>
<p>第一个选择是获得git上 ollvm 或 hikari 的代码，编译后，替换掉NDK中原先的toolchain。<br>这是最不优雅的方式，因为维护起来很麻烦，因为需要编译整个llvm工程，并且对NDK有侵入性，无法保证修改前和修改后NDK的功能不发生变化。</p>
<p>第二个选择是，编译llvm工程，替换掉NDK中原先的toolchain，并且在相同环境下，移植 ollvm 或hikari 为独立的plugin，（移植方案我的github里有写 <a href="https://github.com/LeadroyaL/llvm-pass-tutorial">https://github.com/LeadroyaL/llvm-pass-tutorial</a> ）用编译为插件的形式，动态加载插件。<br>相比第一个方案，极大降低维护的代价，只编译一个pass即可，但仍然对NDK有侵入性。</p>
<p>这两种方案的共同特点是：都需要编译整个llvm项目，初次部署时要消耗大量的时间和资源，另外在选择llvm版本时，也会纠结适配性的问题（虽然通常不会出现适配问题）</p>
<p>笔者曾经使用的是第二种方案，经过研究，本文提出第三种方案，使用NDK中的环境编译pass并加载pass，优雅程度上来看，有以下的特点：</p>
<ul>
<li>最最重要的，不需要编译llvm项目，节省巨大的时间和资源消耗；</li>
<li>其次，不修改原先的NDK运行环境，和原生的NDK是最像的，没有侵入性；</li>
<li>再次，上下文均和NDK完全一致，不需要担心符号问题，不需要额外安装软件和环境，有NDK的环境就足矣；</li>
</ul>
<p>本文演示的环境是：ubuntu18.04（任意linux均可）、ndk-r20（任意NDK版本均可）、cmake（选择较高版本）</p>
<h1 id="二、使用NDK的环境编译一个pass"><a href="#二、使用NDK的环境编译一个pass" class="headerlink" title="二、使用NDK的环境编译一个pass"></a>二、使用NDK的环境编译一个pass</h1><p>众所周知，编译Pass时需要使用llvm的环境，由于NDK中的llvm环境是破损的，所以开发者一般自己编译一份llvm环境出来，替换掉NDK中的llvm环境，包括我本人之前也是这样处理的，这样做的原因是NDK中的llvm是破损的，因为NDK来自AOSP编译好的toolchain，而AOSP在制作toolchain的过程中是移除了部分文件的。</p>
<p>上文提到，本文的方案是不需要亲自编译llvm的，因此就需要使用NDK中的破损的llvm环境来编译一个pass。</p>
<p>根据对 <a href="https://android.googlesource.com/toolchain/llvm_android/">https://android.googlesource.com/toolchain/llvm_android/</a> 的阅读和调试，NDK中的llvm缺失的是一部分binary文件、全部静态链接库文件、全部头文件，采用的是静态连接的方式，它的clang是较为独立的文件（它会依赖libc++，因此成为较为独立）。</p>
<p>平时编译Pass时，需要使用cmake并且导入各种cmake相关的环境，通常写如下的配置文件，<a href="https://github.com/abenkhadra/llvm-pass-tutorial/blob/master/CMakeLists.txt">https://github.com/abenkhadra/llvm-pass-tutorial/blob/master/CMakeLists.txt</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4)</span><br><span class="line"></span><br><span class="line"># we need LLVM_HOME in order not automatically set LLVM_DIR</span><br><span class="line">if(NOT DEFINED ENV&#123;LLVM_HOME&#125;)</span><br><span class="line">    message(FATAL_ERROR &quot;$LLVM_HOME is not defined&quot;)</span><br><span class="line">else ()</span><br><span class="line">    set(ENV&#123;LLVM_DIR&#125; $ENV&#123;LLVM_HOME&#125;/lib/cmake/llvm)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line">add_definitions($&#123;LLVM_DEFINITIONS&#125;)</span><br><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br><span class="line">link_directories($&#123;LLVM_LIBRARY_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">add_subdirectory(skeleton)  # Use your pass name here.</span><br></pre></td></tr></table></figure>
<p><strong>幸运的是</strong> ，NDK中的lib&#x2F;cmake&#x2F;llvm还在，里面的cmake文件都是原汁原味的的。</p>
<p><strong>不幸的是</strong> ，由于AOSP在编译toolchain时设置了 <code>defines[&#39;LLVM_LIBDIR_SUFFIX&#39;] = &#39;64&#39;</code> ，导致find_package的路径应该是 <code>lib64/cmake/llvm</code> ，需要稍加修改</p>
<p>之后进行 <code>mkdir b;cd b;cmake ..</code></p>
<p>会报如下的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  b git:(master) ✗ cmake ..</span><br><span class="line">CMake Error at /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/lib64/cmake/llvm/LLVMExports.cmake:806 (message):</span><br><span class="line">  The imported target &quot;LLVMDemangle&quot; references the file</span><br><span class="line"></span><br><span class="line">     &quot;/home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/lib64/libLLVMDemangle.a&quot;</span><br><span class="line">  but this file does not exist.  Possible reasons include:</span><br><span class="line">  * The file was deleted, renamed, or moved to another location.</span><br><span class="line">  * An install or uninstall procedure did not complete successfully.</span><br><span class="line">  * The installation package was faulty and contained</span><br><span class="line">     &quot;/home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/lib64/cmake/llvm/LLVMExports.cmake&quot;</span><br><span class="line"></span><br><span class="line">  but not all the files it references.</span><br><span class="line">Call Stack (most recent call first):</span><br><span class="line">  /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/lib64/cmake/llvm/LLVMConfig.cmake:173 (include)</span><br><span class="line">  CMakeLists.txt:8 (find_package)</span><br><span class="line"></span><br><span class="line">-- Configuring incomplete, errors occurred!</span><br><span class="line">See also &quot;/home/leadroyal/llvm-pass-tutorial/b/CMakeFiles/CMakeOutput.log&quot;.</span><br></pre></td></tr></table></figure>
<p>因为NDK不含有.a文件，而cmake会检查这些文件，用于静态连接，被认为初始化失败，出错。</p>
<p>看源码对应的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Loop over all imported files and verify that they actually exist</span><br><span class="line">foreach(target $&#123;_IMPORT_CHECK_TARGETS&#125; )</span><br><span class="line">  foreach(file $&#123;_IMPORT_CHECK_FILES_FOR_$&#123;target&#125;&#125; )</span><br><span class="line">    if(NOT EXISTS &quot;$&#123;file&#125;&quot; )</span><br><span class="line">      message(FATAL_ERROR &quot;The imported target \&quot;$&#123;target&#125;\&quot; references the file</span><br><span class="line">   \&quot;$&#123;file&#125;\&quot;</span><br><span class="line">but this file does not exist.  Possible reasons include:</span><br><span class="line">* The file was deleted, renamed, or moved to another location.</span><br><span class="line">* An install or uninstall procedure did not complete successfully.</span><br><span class="line">* The installation package was faulty and contained</span><br><span class="line">   \&quot;$&#123;CMAKE_CURRENT_LIST_FILE&#125;\&quot;</span><br><span class="line">but not all the files it references.</span><br><span class="line">&quot;)</span><br><span class="line">    endif()</span><br><span class="line">  endforeach()</span><br><span class="line">  unset(_IMPORT_CHECK_FILES_FOR_$&#123;target&#125;)</span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure>
<p>在文件不存在时，报 <code>message(FATAL_ERROR xxxxxx)</code>，从而中断编译，但我们本来就是编译动态链接库的，不需要.a文件，所以这里做一个patch，降低log_level，使用WARNING等级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- message(FATAL_ERROR &quot;The imported target \&quot;$&#123;target&#125;\&quot; references the file</span><br><span class="line">+ message(WARNING &quot;The imported target \&quot;$&#123;target&#125;\&quot; references the file</span><br></pre></td></tr></table></figure>
<p>接下来面对第二个问题，之前提到过，NDK中缺失我们需要的头文件，它们本该出现在 <code>include/llvm</code> 中，因此这句话失效了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br></pre></td></tr></table></figure>
<p>但我们又不能随便找一堆头文件过来，版本之间可能有变更，万一用到一些配置不一样的头文件，就会出现非预期（例如经常出错的LLVM_ENABLE_ABI_BREAKING_CHECKS配置）</p>
<p>此时的思路是，找到NDK中llvm生成时的那份commit，从中获取include文件，有两个方案</p>
<ul>
<li>第一个方案是找到源码并使用cmake帮我们提取一遍。</li>
<li>第二个方案是直接使用aosp提供的prebuilt文件，显然为了方便我们选择后者。<br>toolchain 在生成时会有一份描述版本信息的文件，在ndk生成时也被拷贝过来了<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  linux-x86_64 cat /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/AndroidVersion.txt </span><br><span class="line">8.0.7</span><br><span class="line">based on r346389c</span><br></pre></td></tr></table></figure>
<strong>【AOSP相关访问google的前提条件你懂的】</strong></li>
</ul>
<p><code>r346389c</code> 就是这份toolchain的唯一标识，它与出现在 <a href="https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/">https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/</a> 中的一系列clang-rxxxx是一回事，由于这个README.md经常被更新，我们需要checkout到对应的tag才可以找到它，<a href="https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+/refs/tags/ndk-r20%E3%80%82">https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+/refs/tags/ndk-r20。</a></p>
<p>于是在 <a href="https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+/refs/tags/ndk-r20/clang-r346389c/include/">https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+/refs/tags/ndk-r20/clang-r346389c/include/</a> 中我们非常轻易就获取到了那份编译时刻的 <code>include/llvm</code> 和 <code>include/llvm-c</code> 文件，使用点击右上角的 tgz ，有用的只有 <code>llvm</code> 和 <code>llvm-c</code> ，另外的 <code>clang</code> 、<code>clang-c</code> 、<code>lld</code> 我们用不到我就不下载了。</p>
<p><a href="https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/tags/ndk-r20/clang-r346389c/include/llvm.tar.gz">https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/tags/ndk-r20/clang-r346389c/include/llvm.tar.gz</a></p>
<p><a href="https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/tags/ndk-r20/clang-r346389c/include/llvm-c.tar.gz">https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/tags/ndk-r20/clang-r346389c/include/llvm-c.tar.gz</a></p>
<p>即可获得到这个目录的压缩包。</p>
<p>mac 对应的目录是<br><a href="https://android.googlesource.com/platform/prebuilts/clang/host/darwin-x86/+/refs/tags/ndk-r20/clang-r346389c/include/">https://android.googlesource.com/platform/prebuilts/clang/host/darwin-x86/+/refs/tags/ndk-r20/clang-r346389c/include/</a></p>
<p>如果可以接受NDK被污染（我使用的是这个方案），可以将它放到NDK的toolchain中，这样就可以继续使用 <code>$&#123;LLVM_INCLUDE_DIRS&#125; </code>这个变量；</p>
<p>如果不能接受NDK被污染，就随便放个目录，使用 <code>include_directories(/path/to/clang-r346389c/include)</code></p>
<p>比如放在NDK里的include里，是这个样子（c++目录本来就有）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  include lsa</span><br><span class="line">total 5.4M</span><br><span class="line">drwxr-xr-x  8 leadroyal leadroyal 4.0K Oct 21 02:13 .</span><br><span class="line">drwxr-xr-x 15 leadroyal leadroyal 4.0K Oct 20 23:16 ..</span><br><span class="line">drwxr-xr-x  4 leadroyal leadroyal 4.0K Oct 21 02:12 c++</span><br><span class="line">drwxr-xr-x 33 leadroyal leadroyal 4.0K Oct 21 02:12 llvm</span><br><span class="line">drwxr-xr-x  3 leadroyal leadroyal 4.0K Oct 21 02:12 llvm-c</span><br></pre></td></tr></table></figure>
<p>然后有几率遇到C++版本的问题，llvm10以上需要添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br></pre></td></tr></table></figure>
<p>在这在情况下使用的CMakeLists.txt最终是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4)</span><br><span class="line">if(NOT DEFINED ENV&#123;LLVM_HOME&#125;)</span><br><span class="line">    message(FATAL_ERROR &quot;$LLVM_HOME is not defined&quot;)</span><br><span class="line">endif()</span><br><span class="line">if(NOT DEFINED ENV&#123;LLVM_DIR&#125;)</span><br><span class="line">    set(ENV&#123;LLVM_DIR&#125; $ENV&#123;LLVM_HOME&#125;/lib64/cmake/llvm)</span><br><span class="line">endif()</span><br><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line">add_definitions($&#123;LLVM_DEFINITIONS&#125;)</span><br><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line">add_subdirectory(skeleton)  # Use your pass name here.</span><br></pre></td></tr></table></figure>
<p>修复完include问题后，就可以舒舒服服地使用cmake来生成demo了，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export LLVM_HOME=/home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64</span><br><span class="line">➜  b git:(master) ✗ cmake ..       </span><br><span class="line">-- The C compiler identification is GNU 7.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 7.4.0</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/leadroyal/llvm-pass-tutorial/b</span><br><span class="line">➜  b git:(master) ✗ cmake --build .                    </span><br><span class="line">Scanning dependencies of target SkeletonPass</span><br><span class="line">[ 50%] Building CXX object skeleton/CMakeFiles/SkeletonPass.dir/Skeleton.cpp.o</span><br><span class="line">[100%] Linking CXX shared module libSkeletonPass.so</span><br><span class="line">[100%] Built target SkeletonPass</span><br></pre></td></tr></table></figure>

<h1 id="三、使用NDK的环境加载一个pass"><a href="#三、使用NDK的环境加载一个pass" class="headerlink" title="三、使用NDK的环境加载一个pass"></a>三、使用NDK的环境加载一个pass</h1><p>编译部分完成了，接下来是加载部分，我们随便找一个android native项目，修改build.gradle中的flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">    cmake &#123;</span><br><span class="line">        cppFlags &quot;-Xclang -load -Xclang /home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>gradle build</code> 命令后，可能会如下报错（当编译pass时使用了GNU系列的c++时候会遇到，常见于ubuntu，因为NDK使用的是llvm系列的c++）<br>如果出现如下报错的话，解决方案如下，如果没有报错，请跳过这部分</p>
<p>通常被搜索的关键词是：<code>_ZNK4llvm12FunctionPass17createPrinterPassERNS_11raw_ostreamERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE</code></p>
<p><strong>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;GNU使用兼容libc++的方案（没遇到可以跳过） &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./gradlew build</span><br><span class="line">  error: unable to load plugin &#x27;/home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so&#x27;: &#x27;/home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so: undefined symbol: _ZNK4llvm12FunctionPass17createPrinterPassERNS_11raw_ostreamERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE&#x27;</span><br></pre></td></tr></table></figure>
<p>很奇怪，提醒这个符号找不到，但是我们编译时能找到、连接时找不到，就很奇怪。</p>
<p>demangle一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c++filt _ZNK4llvm12FunctionPass17createPrinterPassERNS_11raw_ostreamERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE</span><br><span class="line">llvm::FunctionPass::createPrinterPass(llvm::raw_ostream&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;) const</span><br></pre></td></tr></table></figure>
<p>去NDK的相关目录下grep，发现了该符号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  lib64 pwd</span><br><span class="line">/home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/lib64</span><br><span class="line">➜  lib64 strings * | grep _ZNK4llvm12FunctionPass17createPrinterPass</span><br><span class="line">strings: Warning: &#x27;clang&#x27; is a directory</span><br><span class="line">strings: Warning: &#x27;cmake&#x27; is a directory</span><br><span class="line">_ZNK4llvm12FunctionPass17createPrinterPassERNS_11raw_ostreamERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEE</span><br></pre></td></tr></table></figure>
<p>demangle一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c++filt _ZNK4llvm12FunctionPass17createPrinterPassERNS_11raw_ostreamERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEE</span><br><span class="line">llvm::FunctionPass::createPrinterPass(llvm::raw_ostream&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;) const</span><br></pre></td></tr></table></figure>
<p>对比一下二者，注意一个细节，参数命名空间不一致：<br>NDK里的叫 <code>std::__1::basic_string</code> ，我们编出来的叫 <code>std::__cxx11::basic_string</code></p>
<p>NDK里的叫 <code>std::__1::char_traits</code> ，我们编出来的叫 <code>std::char_traits</code></p>
<p>如果是老司机的话，一眼就知道它们使用了不同版本的c++，最初的源码是一致的，解决起来不难。</p>
<p>用 <code>__cxx11</code> 的叫 <code>libc++</code>，用 <code>__1</code> 叫 <code>libstdc++</code>。</p>
<p>解决方案是在连接时使用 <code>libc++</code> ，<code>set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -stdlib=libc++&quot;)</code> ，但由于ubuntu装的一般是gcc系列，而gcc系列是没有libc++的，编译会crash如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=/usr/bin/c++</span><br><span class="line">OFFLOAD_TARGET_NAMES=nvptx-none</span><br><span class="line">OFFLOAD_TARGET_DEFAULT=1</span><br><span class="line">c++: error: unrecognized command line option ‘-stdlib=libc++’</span><br></pre></td></tr></table></figure>
<p>gcc没有libc++，只有llvm系列拥有libc++，所以需要将编译器切换到clang。</p>
<p>重申我们之前的原则：不需要安装额外的软件，恰好NDK提供了一个clang给我们，为了方便我就用它提供的了（毕竟安装一个clang也挺麻烦的）</p>
<p>再使用libc++的头文件，也直接从对应的地方下载，但千万别和NDK的放在一起，因为 <code>libc++</code> 的 <code>c++/v11</code> 和NDK的 <code>c++/4.9.x</code>，放一起会冲突<br><a href="https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/tags/ndk-r20/clang-r346389c/include/c++.tar.gz">https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/tags/ndk-r20/clang-r346389c/include/c++.tar.gz</a></p>
<p>我把libc++的头文件放在 <code>/home/leadroyal/Android/Sdk/r346389c/include/</code> 下</p>
<p>放好后对它进行include，在这在情况下使用的CMakeLists.txt最终是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4)</span><br><span class="line">set(CMAKE_C_COMPILER /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/bin/clang)</span><br><span class="line">set(CMAKE_CXX_COMPILER /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++)</span><br><span class="line">if(NOT DEFINED ENV&#123;LLVM_HOME&#125;)</span><br><span class="line">    message(FATAL_ERROR &quot;$LLVM_HOME is not defined&quot;)</span><br><span class="line">endif()</span><br><span class="line">if(NOT DEFINED ENV&#123;LLVM_DIR&#125;)</span><br><span class="line">    set(ENV&#123;LLVM_DIR&#125; $ENV&#123;LLVM_HOME&#125;/lib64/cmake/llvm)</span><br><span class="line">endif()</span><br><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line">add_definitions($&#123;LLVM_DEFINITIONS&#125;)</span><br><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br><span class="line">include_directories(/home/leadroyal/Android/Sdk/r346389c/include/c++/v1)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -stdlib=libc++&quot;)</span><br><span class="line">add_subdirectory(skeleton)  # Use your pass name here.</span><br></pre></td></tr></table></figure>
<p>我们使用gcc和clang编译两份pass出来，对比一下前后的区别：</p>
<p>使用GCC编译出来的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  b git:(master) ✗ ldd skeleton/libSkeletonPass.so</span><br><span class="line">    linux-vdso.so.1 (0x00007ffc3c3d5000)</span><br><span class="line">    libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007ff114c76000)</span><br><span class="line">    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007ff114a5e000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff11466d000)</span><br><span class="line">    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007ff1142cf000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007ff115205000)</span><br></pre></td></tr></table></figure>
<p>使用clang编译出来的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  b git:(master) ✗ ldd skeleton/libSkeletonPass.so</span><br><span class="line">    linux-vdso.so.1 (0x00007ffc369e2000)</span><br><span class="line">    libc++.so.1 =&gt; not found</span><br><span class="line">    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f002042c000)</span><br><span class="line">    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f0020214000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f001fe23000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007f00209d3000)</span><br></pre></td></tr></table></figure>
<p>虽然后者提醒libc++.so.1找不到，感觉很诧异，于是去查ndk clang的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  bin ldd /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/bin/clang</span><br><span class="line">    linux-vdso.so.1 (0x00007ffc99bc7000)</span><br><span class="line">    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f3bb9d24000)</span><br><span class="line">    libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007f3bb9b07000)</span><br><span class="line">    librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f3bb98ff000)</span><br><span class="line">    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f3bb96fb000)</span><br><span class="line">    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f3bb935d000)</span><br><span class="line">    libc++.so.1 =&gt; /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/bin/../lib64/libc++.so.1 (0x00007f3bba07e000)</span><br><span class="line">    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f3bb9145000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3bb8d54000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007f3bb9f43000)</span><br></pre></td></tr></table></figure>
<p>发现在NDK里确实存在libc++.so.1环境，问题解决，我们回归主题，最后一步，使用NDK加载它！</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;GNU使用兼容libc++的方案 end &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>我们先用简单的c文件验证我们的pass，没有任何问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  /tmp cat test.c</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">printf(&quot;HelloWorld\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">➜  /tmp /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/bin/clang -Xclang -load -Xclang /home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so test.c </span><br><span class="line">I saw a function called main!</span><br><span class="line">➜  /tmp ./a.out </span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure>
<p>最后一步，见证奇迹的时刻！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  MyApplication ./gradlew clean build</span><br><span class="line">............</span><br><span class="line">&gt; Task :app:externalNativeBuildDebug</span><br><span class="line">Build native-lib_armeabi-v7a</span><br><span class="line">ninja: Entering directory `/home/leadroyal/AndroidStudioProjects/MyApplication/app/.cxx/cmake/debug/armeabi-v7a&#x27;</span><br><span class="line">[1/2] Building CXX object CMakeFiles/native-lib.dir/native-lib.cpp.o</span><br><span class="line">I saw a function called Java_com_example_myapplication_MainActivity_stringFromJNI!</span><br><span class="line">I saw a function called _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC2EPKc!</span><br><span class="line">I saw a function called _ZN7_JNIEnv12NewStringUTFEPKc!</span><br><span class="line">I saw a function called _ZNKSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE5c_strEv!</span><br><span class="line">I saw a function called _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev!</span><br></pre></td></tr></table></figure>
<p>泪流满面！我们终于成功编译并且加载了这个Pass!</p>
<h1 id="四、当我们来到macOS上"><a href="#四、当我们来到macOS上" class="headerlink" title="四、当我们来到macOS上"></a>四、当我们来到macOS上</h1><p>同Linux一样，先修复cmake文件，再下载include&#x2F;llvm和incude&#x2F;llvm-c，因为macOS默认就是clang了，所以不会存在libstdc++和libc++冲突的问题，编译过程全程没有任何障碍。</p>
<p>但是在加载时却遇到了如下的错误，也是在网上经常被贴出来问问题的报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  /tmp $ANDROID_NDK/20.0.5594570/toolchains/llvm/prebuilt/darwin-x86_64/bin/clang -Xclang -load -Xclang /home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so test.c</span><br><span class="line">error: unable to load plugin &#x27;/home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so&#x27;:</span><br><span class="line">      &#x27;dlopen(/home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so, 9): Symbol not found:</span><br><span class="line">      __ZN4llvm12FunctionPass17assignPassManagerERNS_7PMStackENS_15PassManagerTypeE</span><br><span class="line">  Referenced from: /home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so</span><br><span class="line">  Expected in: flat namespace</span><br><span class="line"> in /home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so&#x27;</span><br></pre></td></tr></table></figure>
<p>demangle一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c++filt __ZN4llvm12FunctionPass17assignPassManagerERNS_7PMStackENS_15PassManagerTypeE</span><br><span class="line">llvm::FunctionPass::assignPassManager(llvm::PMStack&amp;, llvm::PassManagerType)</span><br></pre></td></tr></table></figure>
<p>这个符号是llvm中导出的符号，供开发者调用，libSkeletonPass.so需要该符号，但是clang的进程空间里没有这个符号。</p>
<p>经过仔细对照，发现不仅仅缺失这一个符号，缺失的是一大堆相关的符号，而且都是较为基础的符号，只是最先被寻找的是这个就停下来了。<br>【先剧透一下，这个符号缺失是apple基础工具的bug，但是google没有发现这个bug，已报告<a href="https://issuetracker.google.com/issues/143160164%E3%80%91">https://issuetracker.google.com/issues/143160164】</a></p>
<p>这时有另一个线索：我们自己编译出来的pass是可以正常加载pass的，一定是AOSP动了手脚，这里省去大量的diff时间，直接说结果。</p>
<p>记作X：使用llvm默认配置（与Android无关）编译出来的clang，可以找到符号</p>
<p>记作Y：使用AOSP得到的stage2-install&#x2F;bin&#x2F;clang，可以找到符号</p>
<p>记作Z：使用AOSP得到的toolchain中的clang，无法找到符号</p>
<p>X&#x2F;Y 可以说明， <a href="https://android.googlesource.com/toolchain/llvm_android/">https://android.googlesource.com/toolchain/llvm_android/</a> 中对llvm的编译配置，是不影响符号的<br>Y&#x2F;Z 可以说明，strip前和strip后会导致符号缺失。在ubuntu上符号仍然被保留，在macOS上符号会消失。</p>
<p>代码如下 <a href="https://android.googlesource.com/toolchain/llvm_android/+/refs/heads/master/build.py">https://android.googlesource.com/toolchain/llvm_android/+/refs/heads/master/build.py</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for bin_filename in os.listdir(bin_dir):</span><br><span class="line">        binary = os.path.join(bin_dir, bin_filename)</span><br><span class="line">        if os.path.isfile(binary):</span><br><span class="line">            if bin_filename not in necessary_bin_files:</span><br><span class="line">                remove(binary)</span><br><span class="line">            elif strip and bin_filename not in script_bins:</span><br><span class="line">                check_call([&#x27;strip&#x27;, binary])</span><br></pre></td></tr></table></figure>
<p>之后我将X进行 <code>/usr/bin/strip</code> ，发现仍然可以加载pass，这时就开始犯晕，开始缺乏思路。</p>
<p>于是出现了另一个可能引发问题的原因：我编译X、strip-X都是在CommandLineTools 10.15上完成的，但编译Y、strip-Y是在CommandLineTools 10.13上完成的，二者的strip不完全一致！</p>
<p>经过最后一个实验，发现低版本的&#x2F;usr&#x2F;bin&#x2F;strip会错误地移除掉很多符号，导致加载失败，日志如下，我分别用10.13&#x2F;10.14&#x2F;10.15的strip去处理stage2-install&#x2F;bin&#x2F;clang文件，发现10.13&#x2F;14处理出来的文件是错误的。</p>
<img src="/2020/03/07/%E5%8F%B2%E4%B8%8A%E6%9C%80%E4%BC%98%E9%9B%85%E7%9A%84NDK%E5%8A%A0%E8%BD%BDpass%E6%96%B9%E6%A1%88/2020-03-07-00-33-38.png" class="">

<p>至此，真相大白，失败的原因是：AOSP在编译NDK时触发了macOS自带的strip的bug。</p>
<p>最后的挣扎：NDK中存在一个完备的、拥有符号的文件 LLVM.dylib 中的，如果我们让libSkeleton.so依赖它，从LLVM.dylib中获取符号会怎样？<br>最终结果是，关键变量PassManager在NDK-clang中是没有符号的，虽然在LLVM.dylib中可以找到，但二者已经完全不是同一个instance了。</p>
<p>因此，macOS宣告失败，等将来AOSP把这个bug修掉，就可以复用史上最优雅的方法了。</p>
<h1 id="五、当我们来到Windows"><a href="#五、当我们来到Windows" class="headerlink" title="五、当我们来到Windows"></a>五、当我们来到Windows</h1><p>对不起，能力有限告辞。。。</p>
<h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><p>不想看到的事情：</p>
<p>根据这次commit，开发者建议砍掉toolchain里的.cmake文件，因为作者已经砍掉.a文件了，防止.cmake加载失败引起的误会。我也是弄完这一系列才看到这条commit，于是想尽自己的绵薄之力回滚一下，希望能成功吧。</p>
<p><a href="https://android.googlesource.com/toolchain/llvm_android/+/5e612035111cb9f4abad43697350d4ea644fce33">https://android.googlesource.com/toolchain/llvm_android/+/5e612035111cb9f4abad43697350d4ea644fce33</a><br><a href="https://android-review.googlesource.com/c/toolchain/llvm_android/+/1139155">https://android-review.googlesource.com/c/toolchain/llvm_android/+/1139155</a><br>以及，开发者建议砍掉ndk里的.cmake文件，体现在这次commit里</p>
<p><a href="https://android-review.googlesource.com/c/platform/ndk/+/1137192">https://android-review.googlesource.com/c/platform/ndk/+/1137192</a><br>反正ndk-r21肯定是没有cmake了，到时候就从toolchain里下载回来吧。</p>
<p>本文介绍了一种非常优雅的NDK加载Pass方案，目前从未听说国内外有人使用该方案，感觉非常有意义，在此分享出来，希望更多人可以用到它、共同推动安全行业的发展，完结撒花~</p>
<p>参考链接：<a href="https://leadroyal.cn/">https://leadroyal.cn</a></p>
]]></content>
      <categories>
        <category>OLLVM</category>
      </categories>
      <tags>
        <tag>OLLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>学习资源</title>
    <url>/2020/12/29/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p><a href="https://github.com/bkerler/exploit_me">exploit_me</a> - Very vulnerable ARM&#x2F;AARCH64 application (CTF style exploitation tutorial with 14 vulnerability techniques).</p>
<p><a href="https://github.com/citra-emu/dynarmic-android">dynarmic-android</a> - A dynamic recompiler for ARM.</p>
<p><a href="https://github.com/0wlsec/Poc-Exp">Poc-Exp</a> - 记录在漏洞研究过程中编写的 PoC&#x2F;Exp.</p>
<p><a href="https://github.com/shining1984/PL-Compiler-Resource">PL-Compiler-Resource</a> - 程序语言与编译技术相关资料（持续更新中）.</p>
<p><a href="https://github.com/vulhub/vulhub">vulhub</a> - Pre-Built Vulnerable Environments Based on Docker-Compose.</p>
<p><a href="https://github.com/ashwio/arm64-hypervisor-tutorial">arm64-hypervisor-tutorial</a> - arm64-hypervisor-tutorial.</p>
<p><a href="https://github.com/ultraji/linux-0.12">linux-0.12</a> - 《Linux 内核完全剖析》linux0.12 源码及实验环境.</p>
<p><a href="https://firmianay.gitbook.io/ctf-all-in-one/">ctf-all-in-one</a> - ctf-all-in-one.</p>
<p><a href="https://github.com/Apress/modern-arm-assembly-language-programming">modern-arm-assembly-language-programming</a> -Source Code for ‘Modern Arm Assembly Language Programming’ by Daniel Kusswurm。</p>
<p><a href="https://github.com/mytechnotalent/Reverse-Engineering-Tutorial">Reverse-Engineering-Tutorial</a> - A comprehensive reverse engineering tutorial covering x86, x64, 32-bit ARM &amp; 64-bit ARM architectures.</p>
<p><a href="https://github.com/RangerNJU/Static-Program-Analysis-Book">Static-Program-Analysis-Book</a> - Getting started with static program analysis. 静态程序分析入门教程。</p>
<p><a href="https://github.com/hongriSec/Web-Security-Attack">Web-Security-Attack</a> - Web 安全相关内容.</p>
<p><a href="https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners">Ghidra-Software-Reverse-Engineering-for-Beginners</a> - Software Reverse Engineering with Ghidra, published by Packt.</p>
<p><a href="https://github.com/nas5w/100-days-of-code-frontend">100-days-of-code-frontend</a> - Curriculum for learning front-end development during #100DaysOfCode.</p>
<p><a href="https://github.com/iromise/fans">fans</a> - FANS: Fuzzing Android Native System Services.</p>
<p><a href="https://github.com/rabbitstack/fibratus">fibratus</a> - A modern tool for the Windows kernel exploration and tracing.</p>
<p><a href="https://github.com/ydf0509/python36patterns">python36patterns</a> - 最全 python36 种设计模式。</p>
<p><a href="https://github.com/alexMyG/AndroPyTool">AndroPyTool</a> - A framework for automated extraction of static and dynamic features from Android applications.</p>
<p><a href="https://github.com/den4uk/andriller">andriller forensic tools</a> - Andriller - is software utility with a collection of forensic tools for smartphones.</p>
<p><a href="https://github.com/topjohnwu/Magisk">Magisk</a> - The Magic Mask for Android.</p>
<p><a href="https://github.com/opengapps">The Open Google Apps Project</a> - The Open Google Apps Project.</p>
<p><a href="https://github.com/ElderDrivers">ElderDrivers</a> - An Android third-party xposed framework.</p>
<p><a href="https://github.com/applicazza/JNIDA">JNIDA</a> - Helps to rename JNI native methods and restore their C signatures.</p>
<p><a href="https://bbs.pediy.com/thread-260965.htm">关于抓包的碎碎念</a> - 关于抓包的碎碎念.</p>
<p><a href="https://bbs.pediy.com/thread-251370.htm">没有 WIFI 利用 USB 抓 https 包</a> - 没有 WIFI 利用 USB 抓 https 包.</p>
<p><a href="https://github.com/bkerler/android_universal">通用 android 引导到 root</a></p>
<p><a href="https://github.com/darvincisec/DetectFrida">DetectFrida</a> - Detect Frida for Android</p>
<p><a href="https://github.com/xrkk/awesome-ida">awesome-ida</a> - awesome-ida.</p>
<p><a href="https://github.com/alphaSeclab/awesome-reverse-engineering">awesome-reverse-engineering</a> - awesome-reverse-engineering.</p>
<p><a href="https://github.com/HongxuChen/awesome-llvm">awesome-llvm</a> - awesome-llvm.</p>
<p><a href="https://github.com/CrackerCat/javaweb-sec">javaweb-sec</a> - 攻击 Java Web 应用-[Java Web 安全].</p>
<p><a href="https://github.com/heibaiying/BigData-Notes">大数据入门指南</a> - 大数据入门指南.</p>
<p><a href="https://github.com/hadesangel/MITRE-ATT-CK-CN">MITRE-ATT-CK-CN</a> - MITRE-ATT-CK-CN.</p>
<p><a href="https://github.com/mitmproxy">mitmproxy</a> - mitmproxy.</p>
<p><a href="https://github.com/vaexio/vaex">Vaex</a> - Vaex is a python library for lazy Out-of-Core DataFrames.</p>
<p><a href="https://github.com/arieljt/VTCodeSimilarity-YaraGen">VTCodeSimilarity-YaraGen</a> - Yara rule generator using VirusTotal code similarity feature code-similar-to.</p>
<p><a href="https://github.com/Xu-Jian/Wifi-Crack">Wifi-Crack</a> - Wifi 破解实战详解.</p>
<p><a href="https://github.com/icedland/iced">iced</a> - High performance and correct x86&#x2F;x64 disassembler, assembler, decoder, encoder for .NET, Rust, Python, JavaScript.</p>
<p><a href="https://github.com/Fklearn">Fklearn</a> - 各种有用的项目。</p>
<p><a href="https://github.com/PaddlePaddle/PaddleOCR">PaddleOCR</a> - PaddleOCR 旨在打造一套丰富、领先、且实用的 OCR 工具库，助力使用者训练出更好的模型，并应用落地。</p>
<p><a href="https://github.com/deepfakes/faceswap">faceswap</a> - Deepfakes Software For All.</p>
<p><a href="https://github.com/JaidedAI/EasyOCR">EasyOCR</a>- Ready-to-use OCR with 80+ supported languages.</p>
<p><a href="https://github.com/hantmac/Mastering_Go_ZH_CN">Mastering_Go_ZH_CN</a> - 《Mastering GO》中文译本，《玩转 GO》。</p>
<p><a href="https://github.com/vxunderground/WinAPI-Tricks">WinAPI-Tricks</a> - Collection of various WINAPI tricks &#x2F; features used or abused by Malware.</p>
<p><a href="https://github.com/iggredible/Learn-Vim">Learn-Vim</a> - Learning Vim and Vimscript doesn’t have to be hard. This is the guide that you’re looking for.</p>
<p><a href="https://github.com/budtmo/docker-android">docker-android</a> - About Android in docker solution with noVNC supported and video recording.</p>
<p><a href="https://github.com/Martyx00/CollaRE">CollaRE</a> - CollareRE 是用于协作逆向工程的工具，其目的是允许需要在项目期间使用多个工具的团队进行协作，而无需在单独的位置共享文件。</p>
<p><a href="https://github.com/AlienwareHe/awesome-reverse">awesome-reverse</a> - awesome-逆向基础入门，包括 JS、安卓 APP&#x2F;Native .</p>
<p><a href="https://dmcxblue.gitbook.io/red-team-notes-2-0/">Red Team Notes 2.0</a> - Red Team Notes 2.0。</p>
<p><a href="https://rloura.wordpress.com/2020/12/04/reversing-flutter-for-android-wip/">Flutter Android 逆向分析</a> - Reverse engineering Flutter for Android.</p>
<p><a href="https://github.com/rscloura/Doldrums">Flutter Android 逆向 Doldrums</a> - Doldrums A Flutter&#x2F;Dart reverse engineering tool.</p>
<p><a href="https://github.com/hellodword/xflutter">Flutter Android 逆向 xflutter</a> - Flutter &amp; Android reverse engineering.</p>
<p><a href="https://github.com/deepmind/android_env">android_env</a> - 用于在 Android 设备上进行 RL 研究的库。</p>
<p><a href="https://github.com/Te-k/sdanalyzer">sdanalyzer</a> -<br>分析大量 APK 文件的工具。</p>
<p><a href="https://github.com/mildsunrise/darter">darter</a> - Dart &#x2F; Flutter VM 快照分析器.</p>
<p><a href="https://github.com/fuzhengwei/itstack-demo-bytecode">itstack-demo-bytecode</a> - 本专栏主要针对字节码编程系列知识栈进行编写文章学习。</p>
<p><a href="https://github.com/ptswarm/reFlutter">reFlutter</a> - Flutter Reverse Engineering Framework. 实现原理：<a href="https://tinyhack.com/2021/03/07/reversing-a-flutter-app-by-recompiling-flutter-engine/">reversing-a-flutter-app-by-recompiling-flutter-engine</a>.</p>
<p><a href="https://github.com/zhkl0228/unidbg">unidbg</a> - About<br>Allows you to emulate an Android ARM32 and&#x2F;or ARM64 native library, and an experimental iOS emulation.</p>
<p><a href="https://github.com/feiyangqingyun/QWidgetDemo">QWidgetDemo</a> - qt 的例子。</p>
<p><a href="https://github.com/artssec/burp-exporter">burp-exporter</a> - Exporter is a Burp Suite extension to copy a request to a file or the clipboard as multiple programming languages functions.</p>
<p><a href="https://github.com/Pithus/bazaar">bazaar</a> - Android security &amp; privacy analysis for the masses.</p>
<p><a href="https://github.com/OpenLoco/decompilation-tools">decompilation-tools</a> - 一些 IDC 脚本，暂时不太清楚有什么用。</p>
<p><a href="https://github.com/FeeiCN/ESD">ESD</a> - Enumeration sub domains(枚举子域名)。</p>
<p><a href="https://github.com/airbus-cert/Yagi">Yagi</a> - Yet Another Ghidra Integration for IDA.</p>
<p><a href="https://github.com/MitalAshok/ptracewrap">ptracewrap</a> - A C++ header-only wrapper around ptrace(2).</p>
<p><a href="https://github.com/g0dA/linuxStack">linuxStack</a> - Linux 技术栈.</p>
<p><a href="https://github.com/canliture/nju-software-analysis-homework">nju-software-analysis-homework</a> - 南京大学《软件分析》课程课后作业。</p>
<p><a href="https://github.com/the1812/Malware-Patch">Malware-Patch</a> - 阻止中国流氓软件的管理员授权。</p>
<p><a href="https://github.com/avast/apkverifier">apkverifier</a> - APK Signature verification in Go. Supports scheme v1, v2 and v3 and passes Google apksig’s testing suite.</p>
<p><a href="https://github.com/iluwatar/java-design-patterns">java-design-patterns</a> - Design patterns implemented in Java。</p>
<p><a href="https://github.com/Arinerron/heaptrace">heaptrace</a> - helps visualize heap operations for pwn and debugging.</p>
<p><a href="https://github.com/scutan90/DeepLearning-500-questions">DeepLearning-500-questions</a> - 深度学习 500 问，以问答形式对常用的概率知识、线性代数、机器学习、深度学习、计算机视觉等热点问题进行阐述，以帮助自己及有需要的读者。</p>
<p><a href="https://github.com/Lojii/Knot">Knot</a> - 一款 iOS 端基于 MITM(中间人攻击技术)实现的 HTTPS 抓包工具。</p>
<p><a href="https://github.com/AeonLucid/AndroidNativeEmu">AndroidNativeEmu</a> - Allows you to partly emulate an Android native library.</p>
<p><a href="https://github.com/yhnu/op7t">op7t</a> - oneplus 7t 自定义内核(for 安卓逆向&#x2F;android 逆向)。</p>
<p><a href="https://github.com/xbmc/libandroidjni">libandroidjni</a> - Android JNI bindings library.</p>
<p><a href="https://github.com/Ascotbe/Kernelhub">Kernelhub</a> - Windows 提权漏洞合集.</p>
<p><a href="https://github.com/kubo/plthook">plthook</a> - Hook function calls by replacing PLT(Procedure Linkage Table) entries.</p>
<p><a href="https://github.com/rcore-os">rcore-os</a> - THU Rust operating system workshop.</p>
<p><a href="https://github.com/fucking-translation">fucking-translation</a> - 翻译教程。</p>
<p><a href="https://github.com/datawhalechina/pumpkin-book">pumpkin-book</a> - 《机器学习》（西瓜书）公式推导解析.</p>
<p><a href="https://github.com/0xAX/linux-insides">linux-insides</a> - Linux 内核揭秘.</p>
<p><a href="https://github.com/fffaraz/awesome-cpp">awesome-cpp</a> - A curated list of awesome C++ (or C).</p>
<p><a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode">Android-ReadTheFuckingSourceCode</a> - Android-ReadTheFuckingSourceCode.</p>
<p><a href="https://github.com/taoxiongfeng/accumulation">accumulation</a> - 日常工作积累，用于平时工作参考资料。</p>
<p><a href="https://github.com/Launcher3-dev/Launcher3">Launcher3</a> - 基于谷歌 Android P 的 Launcher3 源码。</p>
<p><a href="https://github.com/chyyuu/os_course_info">os_course_info</a> - 清华大学操作系统课程.</p>
<p><a href="https://github.com/zhyingkun/LinuxUnix">LinuxUnix</a> - Linux 和 Unix 相关系统 C 编程的构建工程，包含众多书籍示例.</p>
<p><a href="https://github.com/downdemo/Cpp-Concurrency-in-Action-2ed">Cpp-Concurrency-in-Action-2ed</a> - C++ Concurrency in Action 2ed 笔记.</p>
<p><a href="https://github.com/KunMinX/Relearn-Android">Relearn-Android</a> - 重学安卓.</p>
<p><a href="https://github.com/FilledStacks/flutter-tutorials">flutter-tutorials</a> - The repo contains the source code for all the tutorials on the FilledStacks Youtube channel.</p>
<p><a href="https://github.com/ashishb/android-security-awesome">android-security-awesome</a> - A collection of android security related resources.</p>
<p><a href="https://github.com/opensource-101">opensource-101</a> -<br>开源 101 志愿者小分队.</p>
<p><a href="https://github.com/slidoooor/computer_book_list">computer_book_list</a> - 一个综合了豆瓣，goodreads 综合评分的计算机书籍书单.</p>
<p><a href="https://github.com/boy-hack/ksubdomain">ksubdomain</a> - Subdomain scanner.</p>
<p><a href="https://github.com/vblanco20-1/vulkan-guide">vulkan-guide</a> - Introductory guide to vulkan.</p>
<p><a href="https://github.com/lief-project/LIEF">LIEF</a> - LIEF - Library to Instrument Executable Formats.</p>
<p><a href="https://github.com/Dvd848/pytai">pytai</a> - Kaitai Struct: Visualizer and HEX Viewer GUI in Python.</p>
<p><a href="https://github.com/threat9/routersploit">routersploit</a> - Exploitation Framework for Embedded Devices.</p>
<p><a href="https://github.com/ErLinErYi/PlantsVsZombies">PlantsVsZombies</a> - PlantsVsZombies game made by cocos2dx 3.16 (c++).</p>
<p><a href="https://github.com/wuchangming/spy-debugger">spy-debugger</a> - 微信调试，各种 WebView 样式调试、手机浏览器的页面真机调试。</p>
<p><a href="https://github.com/moonAgirl/Exploit-Re">Exploit-Re</a> - exploit study.</p>
<p><a href="https://github.com/android-rooting-tools">android-rooting-tools</a> - android-rooting-tools.</p>
<p><a href="https://github.com/ziishaned/learn-regex">learn-regex</a> - Learn regex the easy way.</p>
<p><a href="https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System">How-to-Make-a-Computer-Operating-System</a> - How to Make a Computer Operating System in C++.</p>
<p><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts">GitHub-Chinese-Top-Charts</a> - 🇨🇳 GitHub 中文排行榜，帮助你发现高分优秀中文项目、更高效地吸收国人的优秀经验成果；榜单每周更新一次，敬请关注！</p>
<p><a href="https://github.com/M0cK1nG-b1Rd/CTF-Mind-maps">CTF-Mind-maps</a> - 整合入门到中高级题目的思路，for new CTFers !</p>
<p><a href="https://github.com/henrymorgen/android-knowledge-system">android-knowledge-system</a> - Android 应用开发最强原创知识体系.</p>
<p><a href="https://github.com/KB5201314/yark">yark</a> - Yet another Rootkit.</p>
<p><a href="https://github.com/zy445566/llvm-guide-zh">llvm-guide-zh</a> - LVM 系统的新用户指南,中文翻译版.</p>
<p><a href="https://github.com/Evian-Zhang/llvm-ir-tutorial">llvm-ir-tutorial</a> - LLVM IR 入门指南.</p>
<p><a href="https://github.com/xairy/linux-kernel-exploitation">linux-kernel-exploitation</a> - collection of links related to Linux kernel security and exploitation.</p>
<p><a href="https://github.com/woxihuannisja/Android-Reverse-Learn">Android-Reverse-Learn</a> - Android 逆向学习笔记.</p>
<p><a href="https://github.com/public-apis/public-apis">public-apis</a> - A collective list of free APIs.</p>
<p><a href="https://github.com/stong/how-to-exploit-a-double-free">how-to-exploit-a-double-free</a> - How to exploit a double free vulnerability in 2021. ‘Use-After-Free for Dummies’.</p>
<p><a href="https://github.com/AlexeySoshin/smali2java">smali2java</a> - Recreate Java code from Smali.</p>
<p><a href="https://github.com/pr0cf5/kernel-exploit-practice">kernel-exploit-practice</a> - repository for kernel exploit practice.</p>
<p><a href="https://github.com/qiang/Riru-ModuleFridaGadget">Riru-ModuleFridaGadget</a> - 一个 magisk 的模块，简化版，依赖 riru，能够简单的 hook，并且加载动态库，目前用来加载 frida 的 gadget 库，从而使 hook 脱离命令行和 server，并且能够在多进程中加载.</p>
<p><a href="https://github.com/freelancer-leon/notes">notes</a> - notes.</p>
<p><a href="https://github.com/arslanbilal/git-cheat-sheet">git-cheat-sheet</a> - git-cheat-sheet.</p>
<p><a href="https://github.com/EmYiQing/CodeInspector">CodeInspector</a> - 基于 Java ASM 技术和 GadgetInspector 的原理，尝试实现一个自动 Java 代码审计工具。</p>
<p><a href="https://github.com/japajoe/StackVMCPP">StackVMCPP</a> - A stack and register based virtual machine which can compile and run arbitrary code in runtime.</p>
<p><a href="https://github.com/riramar/Web-Attack-Cheat-Sheet">Web-Attack-Cheat-Sheet</a> - Web Attack Cheat Sheet.</p>
<p><a href="https://github.com/Zeyad-Azima/Offensive-Resources">Offensive-Resources</a> - A Huge Learning Resources with Labs For Offensive Security Players.</p>
<p><a href="https://github.com/bin2415/fuzzing_paper">fuzzing_paper</a> - fuzzing related paper.</p>
<p><a href="https://github.com/Enna1/LLVM-Clang-Study-Notes">LLVM-Clang-Study-Notes</a> - LLVM&#x2F;Clang 学习笔记.</p>
<p><a href="https://github.com/G4rb3n/IoT_Sec_Tutorial">IoT_Sec_Tutorial</a> - IoT 安全教程.</p>
<p><a href="https://github.com/metmit/easyFrida">easyFrida</a> - 快速上手开发使用 frida.</p>
<p><a href="https://github.com/Cyb3rWard0g/HELK">HELK</a> - Hunting ELK 或简称 HELK 是首批具有高级分析功能的开源狩猎平台之一.</p>
<p><a href="https://github.com/LyleMi/Learn-Web-Hacking">Learn-Web-Hacking</a> - Study Notes For Web Hacking &#x2F; Web 安全学习笔记.</p>
<p><a href="https://github.com/cfenollosa/os-tutorial">os-tutorial</a> - How to create an OS from scratch.</p>
<p><a href="https://github.com/helloobaby/Nt5Src-Lite">Nt5Src-Lite</a> - Leaked windows XP src.</p>
<p><a href="https://github.com/zjw-swun/JVMTI_Demo">JVMTI_Demo</a> - android p jvmti&#x2F;android studio apply change.</p>
<p><a href="https://github.com/zjw-swun/AppMethodOrder">AppMethodOrder</a> - 一个能让你了解所有函数调用顺序以及函数耗时的 Android 库.</p>
<p><a href="https://github.com/helloobaby/ida-plugin">ida-plugin</a> - ida plugin template.</p>
<p><a href="https://github.com/helloobaby/x32_x64dbgPluginTemplate">x32_x64dbgPluginTemplate</a> - x32_x64dbg Plugin Template.</p>
<p><a href="https://github.com/ChoiysApple/Swift-tutorial">Swift-tutorial</a> - Repository for swift online lecture.</p>
<p><a href="https://github.com/Ivan1ee/NET-Deserialize">NET-Deserialize</a> - 总结了十篇.Net 反序列化文章，持续更新.</p>
<p><a href="https://github.com/tide-emergency/yingji">yingji</a> - 应急相关内容积累.</p>
<p><a href="https://github.com/corkami/pocs">pocs</a> - Proof of Concepts (PE, PDF…).</p>
<p><a href="https://github.com/corkami/collisions">collisions</a> - Hash collisions and their exploitations.</p>
<p><a href="https://github.com/corkami/pics">pics</a> - 各种文件格式图片。</p>
<p><a href="https://github.com/javiersantos/PiracyChecker">PiracyChecker</a> - An Android library that prevents your app from being pirated &#x2F; cracked using Google Play Licensing (LVL), APK signature protection and more.</p>
<p><a href="https://github.com/RapidAI/RapidOCR">RapidOCR</a> - A cross platform OCR Library based on PaddleOCR &amp; OnnxRuntime.</p>
<p><a href="https://github.com/frankwxu/digital-forensics-lab">digital-forensics-lab</a> - Free hands-on digital forensics labs for students and faculty.</p>
<p><a href="https://github.com/hktalent/51pwn-framework">51pwn-framework</a> - 51pwn-framework.</p>
<p><a href="https://github.com/isrc-cas/flounder">flounder</a> - PLCT 实验室维护的 ollvm 分支。</p>
<p><a href="https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials">rust-raspberrypi-OS-tutorials</a> - Learn to write an embedded OS in Rust.</p>
<p><a href="https://github.com/Arinerron/heaptrace">heaptrace</a> - helps visualize heap operations for pwn and debugging.</p>
<p><a href="https://github.com/RJC497/IoT-Digital-Forensics-Course">IoT-Digital-Forensics-Course</a> - Free IoT Digital Forensics Course with hands-on labs.</p>
<p><a href="https://github.com/e-m-b-a/embark">embark</a> - EMBArk - The firmware security scanning environment.</p>
<p><a href="https://github.com/AvatarQing/Gradle-Plugin-User-Guide-Chinese-Verision">Gradle-Plugin-User-Guide-Chinese-Verision</a> - Gradle Plugin User Guide 中文翻译.</p>
<p><a href="https://github.com/DedSecInside/TorBot">TorBot</a> - Dark Web OSINT Tool.</p>
<p><a href="https://github.com/below/HelloSilicon">HelloSilicon</a> - An introduction to ARM64 assembly on Apple Silicon Macs.</p>
<p><a href="https://github.com/CodingDocs/awesome-idea-tutorial">awesome-idea-tutorial</a> - IntelliJ IDEA 使用指南 | 必备插件推荐 | 插件开发入门 | 重构小技巧 | 源码阅读技巧。</p>
<p><a href="https://github.com/TADSG/aosp-study">aosp-study</a> - The study note of AOSP.</p>
<p><a href="https://github.com/rigtorp/awesome-modern-cpp">awesome-modern-cpp</a> - A collection of resources on modern C++.</p>
<p><a href="https://github.com/nomi-sec/PoC-in-GitHub">PoC-in-GitHub</a> - 📡 PoC auto collect from GitHub. ⚠️ Be careful Malware.</p>
<p><a href="https://github.com/zhengjim/camille">camille</a> - 基于 Frida 的 Android App 隐私合规检测辅助工具.</p>
<p><a href="https://github.com/TonyChen56/WeChatRobot">WeChatRobot</a></p>
<p><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual">Effective-Java-3rd-edition-Chinese-English-bilingual</a> - Effective Java（第 3 版）各章节的中英文学习参考（已完成）.</p>
<p><a href="https://github.com/WallBreaker2/op">op</a> - Windows 消息模拟,gdi,dx,opengl 截图，找图,找字(OCR)等功能.</p>
<p><a href="https://github.com/Rvn0xsy/BadCode">BadCode</a> - 恶意代码逃逸源代码.</p>
<p><a href="https://github.com/kabeor/Unicorn-Engine-Documentation">Unicorn-Engine-Documentation</a> - Official Unicorn CPU emulator framework API documentation.</p>
<p><a href="https://github.com/BluePointLilac/ContextMenuManager">ContextMenuManager</a> - 纯粹的 Windows 右键菜单管理程序.</p>
<p><a href="https://github.com/BlueMatthew/WechatExporter">WechatExporter</a> - Wechat Chat History Exporter 微信聊天记录导出程序.</p>
<p><a href="https://github.com/NIKJOO/x86-Code-Virtualizer">x86-Code-Virtualizer</a> - x86 Binary Code Virtualization Tool.</p>
<p><a href="https://github.com/liancheng/llvm-tutorial-cn">llvm-tutorial-cn</a> - Simplified Chinese translation for the LLVM Tutorial.</p>
<p><a href="https://github.com/nothings/single_file_libs">single_file_libs</a> - List of single-file C&#x2F;C++ libraries.</p>
<p><a href="https://github.com/CrackerCat/LearnOpenGL">LearnOpenGL</a> - LearnOpenGL 代码，入门 OpenGL。</p>
<p><a href="https://github.com/su-vikas/Presentations">Presentations</a> - About Slides and other material from various conference presentations.</p>
<p><a href="https://github.com/Qazwar/limevisor">limevisor</a> - a simple, incomplete hypervisor.</p>
<p><a href="https://github.com/r0eXpeR/supplier">supplier</a> - 主流供应商的一些攻击性漏洞汇总.</p>
<p><a href="https://github.com/stealthcopter/AndroidNetworkTools">AndroidNetworkTools</a> - Set of useful android network tools.</p>
<p><a href="https://github.com/Wenzel/checksec.py">checksec</a> - Checksec tool in Python, Rich output. Based on LIEF.</p>
<p><a href="https://github.com/ChenJunsen/Hegui3.0">Hegui</a> - 工信部合规检测 Xposed 模块源码.</p>
<p><a href="https://github.com/fungos/cr">cr</a> - cr.h: A Simple C Hot Reload Header-only Library.</p>
<p><a href="https://github.com/epi052/fuzzing-101-solutions">fuzzing-101-solutions</a> - Companion repository to the Fuzzing101 with LibAFL series of blog posts.</p>
<p><a href="https://github.com/mav8557/Father">Father</a> - LD_PRELOAD rootkit.</p>
<p><a href="https://github.com/sharif-dev/AndroidKernelVulnerability">AndroidKernelVulnerability</a> - Triggering and Analyzing Android Kernel Vulnerability CVE-2019-2215.</p>
<p><a href="https://github.com/antonio-morales/Fuzzing101">Fuzzing101</a> - Fuzzing-101.</p>
<p><a href="https://github.com/MCMrARM/axml-parser">axml-parser</a> - A simple AXML parser written in C++.</p>
<p><a href="https://github.com/sunym1993/flash-linux0.11-talk">flash-linux0.11-talk</a> - 像小说一样品读 Linux 0.11 核心代码.</p>
<p><a href="https://github.com/threedr3am/learnjavabug">learnjavabug</a> - Java 安全相关的漏洞和技术 demo.</p>
<p><a href="https://github.com/lasarus/C-Compiler">C-Compiler</a> - Yet another C compiler.</p>
<p><a href="https://github.com/ComodoSecurity/openedr">openedr</a> - Open EDR public repository.</p>
<p><a href="https://github.com/makeloveandroid/apphook">apphook</a> - 一款基于 xposed 做的分析插件.</p>
<p><a href="https://github.com/spring2go/cs_study_plan">cs_study_plan</a> - 一份硬核计算机科学 CS 自学计划.</p>
<p><a href="https://github.com/CrackerCat/thc-tips-tricks-hacks-cheat-sheet">thc-tips-tricks-hacks-cheat-sheet</a> - Various tips &amp; tricks.</p>
<p><a href="https://github.com/S3cur3Th1sSh1t/Pentest-Tools">Pentest-Tools</a> - Pentest-Tools.</p>
<p><a href="https://github.com/rougier/CPP-Crash-Course">CPP-Crash-Course</a> - C++ Crash Course.</p>
<p><a href="https://github.com/ElivenLZY/AndroidSafeCheck">AndroidSafeCheck</a> - APP 过等保要用到的安全检测，支持调试检测&#x2F;签名校验&#x2F;Root 检测&#x2F;网络代理检测等，功能高度灵活可定制。</p>
<p><a href="https://github.com/hackerscrolls/SecurityTips">SecurityTips</a> - SecurityTips.</p>
<p><a href="https://github.com/grimm-co/NotQuite0DayFriday">NotQuite0DayFriday</a> - 这是一个 repo，它记录了真实软件中的真实错误，以说明趋势，了解如何预防或更快地找到它们。</p>
<p><a href="https://github.com/ixty/mandibule">mandibule</a> - linux elf injector for x86 x86_64 arm arm64.</p>
<p><a href="https://github.com/simple-android-framework/android_design_patterns_analysis">android_design_patterns_analysis</a> - Android 源码设计模式分析开源项目.</p>
<p><a href="https://github.com/pangudashu/php7-internal">php7-internal</a> - PHP7 内核剖析.</p>
<p><a href="https://github.com/havenow/AndroidGameModify">AndroidGameModify</a> - Android 逆向笔记。</p>
<p><a href="https://github.com/zsdlove/ApkVulCheck">ApkVulCheck</a> - 安卓漏洞扫描工具.</p>
<p><a href="https://github.com/StarCrossPortal/bug-hunting-101">bug-hunting-101</a> - bug-hunting-101</p>
<p><a href="https://github.com/StarCrossPortal">StarCrossPortal</a> - 星阑科技 PortalLab 实验室 .</p>
<p><a href="https://github.com/DavadDi/bpf_study">bpf_study</a> - bpf 学习仓库.</p>
<p><a href="https://github.com/tuoxie007/play_with_llvm">play_with_llvm</a> - A book about LLVM &amp; Clang（中文开源书：玩转 LLVM）</p>
<p><a href="https://github.com/gerhart01/Hyper-V-Internals">Hyper-V-Internals</a> - 有关 Hyper-V 的内部信息.</p>
<p><a href="https://github.com/debauchee/barrier">barrier</a> - Open-source KVM software.</p>
<p><a href="https://github.com/netdata/kernel-collector">kernel-collector</a> - Linux Kernel eBPF Collectors.</p>
<p><a href="https://github.com/TartanLlama/minidbg">minidbg</a> - A mini x86 linux debugger for teaching purposes.</p>
<p><a href="https://github.com/v8blink/v8-JavaScript-Documents">v8-JavaScript-Documents</a> - 《Chrome V8 原理讲解》系列技术文章.</p>
<p><a href="https://github.com/bisqwit/compiler_series">compiler_series</a> - 创建编译器视频课程系列的材料。</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C">Hands-On-Network-Programming-with-C</a> - 使用 C 进行网络编程实践.</p>
<p><a href="https://github.com/liwugang/pkcs7">pkcs7</a> - pkcs7- this is parse the CERT.RSA file.</p>
<p><a href="https://github.com/AlfredTheBest/Design-Pattern">Design-Pattern</a> - 设计模式。</p>
<p><a href="https://github.com/AlfredTheBest/git-handbook">git-handbook</a> - git 简易使用手册.</p>
<p><a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a> - 《TCP&#x2F;IP 网络编程》学习笔记.</p>
<p><a href="https://github.com/mkowsiak/jnicookbook">jnicookbook</a> - jnicookbook 在本书中，您可以找到我多年来使用 JNI 编写的 JNI 相关代码。</p>
<p><a href="https://github.com/dendibakh/perf-book">perf-book</a> - 《现代 CPU 的性能分析和调优》一书</p>
<p><a href="https://github.com/DhavalKapil/heap-exploitation">heap-exploitation</a> - This book on heap exploitation is a guide to understanding the internals of glibc’s heap and various attacks possible on the heap structure.</p>
<p><a href="https://github.com/dunwu/linux-tutorial">linux-tutorial</a> - linux-tutorial 是一个 Linux 教程。</p>
<p><a href="https://github.com/PKUFlyingPig/pku-cs-self-learning">pku-cs-self-learning</a> - 计算机自学指南.</p>
<p><a href="https://github.com/duguying/parsing-techniques">parsing-techniques</a> - parsing-techniques.</p>
<p><a href="https://github.com/Fare9/KUNAI-static-analyzer">KUNAI-static-analyzer</a> - 该工具旨在通过使用中间表示提供对不同文件格式的二进制分析。</p>
<p><a href="https://github.com/weiwosuoai/docker-tutorial">docker-tutorial</a> - Docker 学习教程.</p>
<p><a href="https://github.com/bit4woo/burp-api-drops">burp-api-drops</a> - burp 插件开发指南.</p>
<p><a href="https://breaking-bits.gitbook.io/breaking-bits/exploit-development/linux-kernel-exploit-development">linux-kernel-exploit-development</a> - Linux kernel exploit development</p>
<p><a href="https://www.ashw.io/blog">Ash Wilding’s Arm Architecture Blog</a> - Ash Wilding’s Arm Architecture Blog</p>
<p><a href="https://github.com/V33RU/IoTSecurity101">IoTSecurity101</a> - From IoT Pentesting to IoT Security.</p>
<p><a href="https://github.com/ashwio/arm64-hypervisor-tutorial">arm64-hypervisor-tutorial</a> - arm64-hypervisor-tutorial.</p>
<p><a href="https://daniel.haxx.se/docs/">docs</a> - Internet protocols and tools related documentation.</p>
<p><a href="https://github.com/0voice/linux_kernel_wiki">linux_kernel_wiki</a> - linux 内核学习资料：200+经典内核文章，100+内核论文，50+内核项目，500+内核面试题，80+内核视频.</p>
<p><a href="https://github.com/zu1k/LibAFL-Book-zh">LibAFL-Book-zh</a> - LibAFL 文档书 简体中文版。</p>
<p><a href="https://github.com/0voice/kernel_new_features">kernel_new_features</a> - 深挖 Linux 内核的新功能特性，以 io_uring, cgroup, ebpf, llvm 为代表，包含开源项目，代码案例，文章，视频，架构脑图等.</p>
<p><a href="https://github.com/dunwu/db-tutorial">db-tutorial</a> - db-tutorial 是一个数据库教程。</p>
<p><a href="https://github.com/Ciyfly/Source_code_learning">Source_code_learning</a> - 阅读各种源码写的笔记.</p>
<p><a href="https://github.com/tandasat/Hypervisor-101-in-Rust">Hypervisor-101-in-Rust</a> - The materials of “Hypervisor 101 in Rust”, a one-day long course, to quickly learn hardware-assisted virtualization technology and its application for high-performance fuzzing on Intel&#x2F;AMD processors.</p>
<p><a href="https://github.com/Hack-with-Github/Awesome-Hacking">Awesome-Hacking</a> - A collection of awesome lists for hackers, pentesters &amp; security researchers.</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>工具</title>
    <url>/2020/02/02/%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="Anroid-逆向工具"><a href="#Anroid-逆向工具" class="headerlink" title="Anroid 逆向工具"></a>Anroid 逆向工具</h1><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p><a href="https://www.pnfsoftware.com/">JEB</a> - The Interactive Android Decompiler.</p>
<p><a href="http://www.gda.wiki:9090/">GDA</a> - GGJoy Dex Analysizer(GDA)，国内第一款也是唯一一款全交互式反编译器，同时也是世界上最早实现的 dalvik 字节码反编译器。</p>
<p><a href="https://www.hex-rays.com/products/ida/">IDA</a> - The IDA Disassembler and Debugger is an interactive, programmable, extensible, multi-processor disassembler hosted on Windows, Linux, or Mac OS X. IDA has become the de-facto standard for the analysis of hostile code, vulnerability research and commercial-off-the-shelf validation.</p>
<p><a href="https://github.com/NationalSecurityAgency/ghidra">Ghidra</a> - Ghidra is a software reverse engineering (SRE) framework.</p>
<p><a href="https://github.com/skylot/jadx">jadx</a> - Dex to Java decompiler.</p>
<p><a href="https://github.com/java-decompiler/jd-gui">jd-gui</a> - A standalone Java Decompiler GUI.</p>
<p><a href="https://github.com/androguard/androguard">androguard</a> - Reverse engineering, Malware and goodware analysis of Android applications … and more (ninja !).</p>
<p><a href="https://code.google.com/p/android-apktool/">ApkTool</a> - A tool for reverse engineering Android Apk Files.</p>
<p><a href="https://github.com/Konloch/bytecode-viewer">Bytecode-Viewer</a> - A Java 8 Jar &amp; Android APK Reverse Engineering Suite (Decompiler, Editor, Debugger &amp; More)</p>
<p><a href="https://github.com/pxb1988/dex2jar">Dex2Jar</a> - Tools to work with android .dex and java .class files.</p>
<p><a href="https://github.com/Storyyeller/enjarify">Enjarify</a> - Enjarify is a tool for translating Dalvik bytecode to equivalent Java bytecode. This allows Java analysis tools to analyze Android applications.</p>
<p><a href="https://github.com/JesusFreke/smali">smali&#x2F;baksmali</a> - An assembler&#x2F;disassembler for Android’s dex format.</p>
<p><a href="https://github.com/deathmarine/Luyten">Luyten</a> - An Open Source Java Decompiler Gui for Procyon.</p>
<p><a href="https://www.52pojie.cn/thread-319641-1-1.html">AndroidKiller</a> - Android killer 是一款可视化的安卓应用逆向工具，集 Apk 反编译、Apk 打包、Apk 签名，编码互转，ADB 通信（应用安装-卸载-运行-设备文件管理）等特色功能于一身，支持 logcat 日志输出，语法高亮，基于关键字（支持单行代码或多行代码段）项目内搜索，可自定义外部工具；吸收融汇多种工具功能与特点，打造一站式逆向工具操作体验，大大简化了安卓应用&#x2F;游戏修改过程中各类繁琐工作。</p>
<p><a href="https://github.com/EiNSTeiN-/decompiler">decompiler</a> - A decompiler with multiple backend support, written in Python. Works with IDA and Capstone.</p>
<p><a href="https://github.com/zsdlove/ApkVulCheck">ApkVulCheck</a> - This is a tool to help androidcoder to check the flaws in their projects.</p>
<p><a href="https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security">RMS-Runtime-Mobile-Security</a> - Runtime Mobile Security (RMS) is a powerful web interface that helps you to manipulate Android Java Classes and Methods at Runtime.</p>
<p><a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF">Mobile-Security-Framework-MobSF</a> - Mobile Security Framework (MobSF) is an automated, all-in-one mobile application (Android&#x2F;iOS&#x2F;Windows) pen-testing, malware analysis and security assessment framework capable of performing static and dynamic analysis.</p>
<p><a href="https://github.com/radareorg/cutter">cutter</a> - Free and Open Source Reverse Engineering Platform powered by radare2.</p>
<p><a href="https://github.com/google/android-classyshark">android-classyshark</a> - Analyze any Android&#x2F;Java based app or game.</p>
<p><a href="https://bbs.pediy.com/thread-259688.htm">jda</a> - apk、dex、jar 反编译工具。</p>
<p><a href="https://github.com/Surendrajat/APKLab">APKLab</a> - Android Reverse Engineering WorkBench for VS Code.</p>
<p><a href="https://github.com/chason0528/profiler">profiler</a> - 这是一个主要用于逆向工程师用来跟踪 java 方法调用流程的工具。</p>
<p><a href="https://github.com/panhongwei/TraceReader">TraceReader</a> - About<br>android 小工具，通过读取 trace 文件，回溯整个整个程序执行调用树。</p>
<p>[reko]{<a href="https://github.com/uxmal/reko%7D">https://github.com/uxmal/reko}</a> - Reko is a binary decompiler.</p>
<p><a href="https://github.com/quark-engine/quark-engine">quark-engine</a> - Malware Scoring System.</p>
<p><a href="https://github.com/sonyxperiadev/ApkAnalyser">ApkAnalyser</a> - ApkAnalyser.</p>
<p><a href="https://github.com/LLVM-but-worse/java-disassembler">java-disassembler</a> - The Java Disassembler.</p>
<p><a href="https://github.com/pkilller/super-jadx">super-jadx</a> - Add new features for reverse engineering, such as: renaming of classes, fields, methods, variables, reference graphs and more.</p>
<p><a href="https://github.com/vaibhavpandeyvpz/apkstudio">apkstudio</a> - Open-source, cross platform Qt based IDE for reverse-engineering Android application packages.</p>
<p><a href="https://github.com/secure-software-engineering/FlowDroid">FlowDroid</a> - FlowDroid Static Data Flow Tracker.</p>
<p><a href="https://github.com/google/smali">smali</a> - smali&#x2F;baksmali is an assembler&#x2F;disassembler for the dex format used by dalvik, Android’s Java VM implementation.</p>
<p><a href="https://github.com/nbauma109/jd-gui-duo">jd-gui-duo</a> - A 2-in-1 JAVA decompiler based on JD-CORE v0 and v1 supporting 3rd party decompilers CFR, Procyon, Quiltflower &amp; Jadx.</p>
<h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p><a href="https://github.com/CalebFenton/simplify/sdbg">sdbg</a> - Sdbg is a Smali debugger powered by SmaliVM.</p>
<p><a href="https://github.com/frida/frida">frida</a> - Dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.</p>
<p><a href="https://github.com/alibaba/arthas">Arthas</a> - Alibaba Java Diagnostic Tool Arthas&#x2F;Alibaba Java 诊断利器 Arthas.</p>
<p><a href="https://github.com/MerryMage/dynarmic">dynarmic</a> - An ARM dynamic recompiler.</p>
<p><a href="https://github.com/FabricMC/Enigma">Enigma</a> - This is a fork of cuchaz’s engima, a deobfuscation&#x2F;remapping tool for Java software.</p>
<p><a href="https://github.com/jmpews/Dobby">Dobby</a> - a lightweight, multi-platform, multi-architecture hook framework.</p>
<p><a href="https://github.com/wfcpc/ARM64InlineHook">ARM64InlineHook</a> - ARM64InlineHook.</p>
<p><a href="https://github.com/sensepost/objection">objection</a> - objection - runtime mobile exploration.</p>
<p><a href="https://github.com/ele7enxxh/Android-Inline-Hook">Android-Inline-Hook</a> - thumb16 thumb32 arm32 inlineHook in Android.</p>
<p><a href="https://github.com/iqiyi/xHook">xHook</a> - A PLT hook library for Android native ELF.</p>
<p><a href="https://github.com/turing-technician/FastHook">FastHook</a> - 一种高效稳定、简洁易用的 Android Hook 框架，实际项目验证，拥有远超其他同类框架的优异稳定性。</p>
<p><a href="https://github.com/asLody/whale">whale</a> - Hook Framework for Android&#x2F;IOS&#x2F;Linux&#x2F;MacOS.</p>
<p><a href="https://github.com/PAGalaxyLab/YAHFA">YAHFA</a> - Yet Another Hook Framework for ART.</p>
<p><a href="https://github.com/ganyao114/SandHook">SandHook</a> - Android ART Hook&#x2F;Native Inline Hook&#x2F;Single Instruction Hook - support 4.4 - 11.0 32&#x2F;64 bit - Xposed API Compat.</p>
<p><a href="https://github.com/GToad/Android_Inline_Hook">Android_Inline_Hook</a> - Build an so file to automatically do the android_native_hook work. Supports thumb-2&#x2F;arm32 and ARM64 ! With this, tools like Xposed can do android native hook.</p>
<p><a href="https://github.com/GToad/Android_Inline_Hook_ARM64">Android_Inline_Hook_ARM64</a> - Build an .so file to automatically do the android_native_hook work. Supports ARM64 ! With this, tools like Xposed can do android native hook.</p>
<p><a href="https://github.com/mar-v-in/ArtHook">ArtHook</a> - Library for hooking on ART.</p>
<p><a href="https://github.com/tiann/epic">epic</a> - Dynamic java method AOP hook for Android(continution of Dexposed on ART), Supporting 5.0~11.</p>
<p><a href="https://github.com/zhuotong/Android_InlineHook">Android_InlineHook</a> - Android 内联 hook 框架.</p>
<p>[And64InlineHook]{<a href="https://github.com/Rprop/And64InlineHook%7D">https://github.com/Rprop/And64InlineHook}</a> - Lightweight ARMv8-A(ARM64, AArch64, Little-Endian) Inline Hook Library for Android C&#x2F;C++.</p>
<p><a href="https://github.com/woxihuannisja/StormHook">StormHook</a> - StormHook is a Android Hook Framework for Dalvik and Art.</p>
<p><a href="https://github.com/dodola/fbhookfork">fbhookfork</a> - 从 fb 的 profilo 项目里提取出来的 hook 库，自己用.</p>
<p><a href="https://github.com/canyie/pine">pine</a> - Dynamic java method hook framework on ART.</p>
<p><a href="https://github.com/ChickenHook/ChickenHook">ChickenHook</a> - A linux &#x2F; android &#x2F; MacOS hooking framework.</p>
<p><a href="https://github.com/BigFaceCat2017/frida-substrate">frida-substrate</a> - substrate framework for android based on frida.</p>
<p><a href="https://github.com/darvincisec/VirtualDynamicAnalysis">VirtualDynamicAnalysis</a> - A basic android pentest environment to instrument apps without root or repackaging an app.</p>
<p><a href="https://github.com/LSPosed/LSPosed">LSPosed</a> - LSPosed Xposed Framework.</p>
<p><a href="https://github.com/FrenchYeti/dexcalibur">dexcalibur</a> - About<br>[Official] Android reverse engineering tool focused on dynamic instrumentation automation.</p>
<p><a href="https://github.com/iGio90/Dwarf">Dwarf</a> - Full featured multi arch&#x2F;os debugger built on top of PyQt5 and frida.</p>
<p><a href="https://github.com/rohanrhu/gdb-frontend">gdb-frontend</a> - GDBFrontend is an easy, flexible and extensionable gui debugger.</p>
<p><a href="https://github.com/bytedance/bhook">bhook</a> - ByteHook(aka bhook) is a PLT hook framework for Android app.</p>
<p><a href="https://github.com/smx-smx/ezinject">ezinject</a> - Modular binary injection framework.</p>
<h2 id="脱壳工具"><a href="#脱壳工具" class="headerlink" title="脱壳工具"></a>脱壳工具</h2><p><a href="https://github.com/hanbinglengyue/FART">FART</a> - ART 环境下自动化脱壳方案。</p>
<p><a href="https://github.com/F8LEFT/FUPK3">FUPK3</a> - FUPK v3, 早期的一个 Android 半自动脱壳机。</p>
<p><a href="https://github.com/sepyeight/FartDexFix">FartDexFix</a> - hanbing 大佬 fart 工具脱壳后 dex 后修复.</p>
<p><a href="https://github.com/CodingGay/BlackDex">BlackDex</a> - BlackDex</p>
<p><a href="https://github.com/Youlor/unpacker">unpacker</a> - unpacker</p>
<p><a href="https://github.com/dqzg12300/MikRom">MikRom</a> - ROM 逆向工具</p>
<p><a href="https://github.com/ShivamKumarJha/android_tools">android_tools</a> - Bash scripts for ROM development stuff.</p>
<p><a href="https://github.com/iromise/fans">fans</a> - FANS: Fuzzing Android Native System Services.</p>
<p><a href="https://github.com/chason0528/profiler">profiler</a> - A tool to trace java method dynamically for android application.</p>
<p><a href="https://github.com/alitekin2fx/magiskboot">magiskboot</a> - ‘magiskboot’ command line application on linux.</p>
<p><a href="https://github.com/0x192/universal-android-debloater">universal-android-debloater</a> - Cross-platform GUI written in Rust using ADB to debloat non-rooted android devices. Improve your privacy, the security and battery life of your device.</p>
<p><a href="https://github.com/osm0sis/Android-Image-Kitchen">Android-Image-Kitchen</a> - Automated scripts to unpack&#x2F;repack Android kernel&#x2F;recovery images + ramdisks.</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://github.com/RealityNet/android_triage">android_triage</a> - Bash script to extract data from an Android device.</p>
<p><a href="https://github.com/droe/sslsplit">sslsplit</a> - 透明的 SSL&#x2F;TLS 拦截.</p>
<p><a href="https://github.com/anestisb/vdexExtractor">vdexExtractor</a> - Tool to decompile &amp; extract Android Dex bytecode from Vdex files.</p>
<p><a href="https://github.com/anestisb/android-simg2img">android-simg2img</a> - Tool to convert Android sparse images to raw images.</p>
<p><a href="https://github.com/anestisb/android-unpackbootimg">android-unpackbootimg</a> - Tools to work with Android boot images.</p>
<p><a href="https://github.com/rmnscnce/hsu">hsu</a> - Hide Magisk and root system-wide to prevent any kinds of detection.</p>
<p><a href="https://github.com/ysbing/yadb">yadb</a> - yadb 是一个根据原生 yadb 不支持的功能做的扩展。</p>
<p><a href="https://github.com/rev1si0n/bxxt">bxxt</a> - 解包，打包 boot.img 工具。</p>
<p><a href="https://github.com/Magisk-Modules-Repo/MagiskHidePropsConf">MagiskHidePropsConf</a> - MagiskHidePropsConf.</p>
<p><a href="https://github.com/vfsfitvnm/frida-il2cpp-bridge">frida-il2cpp-bridge</a> - A Frida module to dump, trace or hijack any Il2Cpp application at runtime, without needing the global-metadata.dat file.</p>
<p><a href="https://github.com/hamibot/hamibot">hamibot</a> - Android 平台 JavaScript 自动化工具，无需 root。</p>
<p><a href="https://github.com/TUSSON/android-event-recorder">android-event-recorder</a> - 一个记录&#x2F;重放 Android 平台输入事件的工具，自动化测试会更容易。</p>
<p><a href="https://github.com/svengong/xcubebase">xcubebase</a> - 基于 xposed 的 frida 持久化方案。</p>
<p><a href="https://github.com/svengong/xcubebase_riru">xcubebase_riru</a> - 基于 magisk 和 riru 的 frida 持久化方案。</p>
<p><a href="https://github.com/doridori/Android-Security-Reference">Android-Security-Reference</a> - A W.I.P Android Security Ref.</p>
<p><a href="https://github.com/AirtestProject/Airtest">Airtest</a> - 游戏和应用程序的 UI 自动化框架.</p>
<p><a href="https://github.com/leng-yue/py-scrcpy-client">py-scrcpy-client</a> - 一个简单易用的 python scrcpy 客户端。</p>
<p><a href="https://github.com/aktsk/apk-medit">apk-medit</a> - 无需 root 和 ndk 的可调试 apk 上的内存搜索和补丁工具。</p>
<p><a href="https://github.com/GJDuck/e9patch">e9patch</a> - 强大的静态二进制重写器.</p>
<p><a href="https://github.com/cfig/Android_boot_image_editor">Android_boot_image_editor</a> - Parsing and re-packing Android boot.img&#x2F;vbmeta.img, supporting Android 12.</p>
<p><a href="https://github.com/nightmare-space/adb_tool">adb_tool</a> - ADB TOOL，提供 adb 管理，android 端 adb 安装，开启远程调试。</p>
<p><a href="https://github.com/a13xp0p0v/kconfig-hardened-check">kconfig-hardened-check</a> - A tool for checking the security hardening options of the Linux kernel.</p>
<p><a href="https://github.com/shogo82148/androidbinary">androidbinary</a> - Android binary file parser written in golang.</p>
<p><a href="https://github.com/vm03/payload_dumper">payload_dumper</a> - Android OTA payload .</p>
<p><a href="https://github.com/Gyoonus/deoptfuscator">deoptfuscator</a> - Deobfuscator for Android Application.</p>
<p><a href="https://github.com/ashwio/arm64-pgtable-tool">arm64-pgtable-tool</a> - Tool for automatically generating MMU and translation table setup code, whether to drag and drop into your own bare metal arm64 projects or to assist you in your own learning.</p>
<p><a href="https://github.com/bmax121/APatch">APatch</a> - Patching, hooking, and rooting the Android using only a stripped kernel image.</p>
<h1 id="PC-逆向工具"><a href="#PC-逆向工具" class="headerlink" title="PC 逆向工具"></a>PC 逆向工具</h1><p><a href="https://github.com/x64dbg/x64dbg">x64dbg</a> - An open-source x64&#x2F;x32 debugger for windows.</p>
<p><a href="https://github.com/Air14/HyperHide">HyperHide</a> - Hypervisor based anti anti debug plugin for x64dbg.</p>
<p><a href="https://github.com/VenTaz/Themidie">Themidie</a> - x64dbg plugin to bypass Themida 3.x Anti-Debugger &#x2F; VM &#x2F; Monitoring programs checks (x64).</p>
<p><a href="https://github.com/ThunderCls/xAnalyzer">xAnalyzer</a> - xAnalyzer plugin for x64dbg.</p>
<p><a href="https://github.com/stevemk14ebr/RETools">RETools</a> - RETools.</p>
<p><a href="https://github.com/rizinorg/rizin">rizin</a> - UNIX-like reverse engineering framework and command-line toolset.</p>
<p><a href="https://github.com/nico/demumble">demumble</a> - A better c++filt and a better undname.exe, in one binary.</p>
<p><a href="https://github.com/airbus-cert/Winshark">Winshark</a> -</p>
<p><a href="https://github.com/udbg/udbg">udbg</a> - dynamic binary analysis tools.</p>
<p><a href="https://github.com/eteran/edb-debugger">edb-debugger</a> - edb is a cross-platform AArch32&#x2F;x86&#x2F;x86-64 debugger.</p>
<p><a href="https://github.com/lucasg/Dependencies">Dependencies</a> - depends.exe 的开源的现代版本。</p>
<p><a href="https://github.com/CERTCC/kaiju">kaiju</a> - CERT Kaiju is a binary analysis framework extension for the Ghidra software reverse engineering suite.</p>
<p><a href="https://github.com/4d61726b/VirtualKD-Redux">VirtualKD-Redux</a> - VirtualKD-Redux - A revival and modernization of VirtualKD.</p>
<p><a href="https://github.com/f0wl/MalwareLab_VM-Setup">MalwareLab_VM-Setup</a> - Setup scripts for my Malware Analysis VMs</p>
<p><a href="https://github.com/repnz/windbg-cheat-sheet">windbg-cheat-sheet</a> - My personal cheat sheet for using WinDbg for kernel debugging.</p>
<p><a href="https://github.com/0vercl0k/windbg-scripts">windbg-scripts</a> - A bunch of JavaScript extensions for WinDbg.</p>
<p><a href="https://github.com/cmu-sei/pharos">pharos</a> - 二进制程序的自动化静态分析工具。</p>
<p><a href="https://github.com/void-stack/VMUnprotect">VMUnprotect</a> - VMUnprotect 可以动态记录和操作来自虚拟化方法的调用。</p>
<p><a href="https://github.com/uxmal/reko">reko</a> - Reko is a binary decompiler.</p>
<p><a href="https://github.com/ClownQq/YDArk">YDArk</a> - X64 内核小工具.</p>
<p><a href="https://github.com/ph4ntonn/Impost3r">Impost3r</a> - Impost3r 是一个利用 C 语言编写,用来窃取 linux 下各类密码(ssh,su,sudo)的工具。</p>
<p><a href="https://github.com/HyperDbg/HyperDbg">HyperDbg</a> - HyperDbg Debugger is an open-source, community-driven, hypervisor-assisted, user-mode and kernel-mode Windows debugger with a focus on using modern hardware technologies.</p>
<p><a href="https://github.com/dnSpyEx/dnSpy">dnSpy</a> - Unofficial revival of the well known .NET debugger and assembly editor, dnSpy.</p>
<p><a href="https://github.com/jovibor/libpe">libpe</a> - Library for working with PE32&#x2F;PE32+ binaries’ inner information.</p>
<p><a href="https://github.com/SOUI2/soui">soui</a> - SOUI 是目前为数不多的轻量级可快速开发 window 桌面程序开源 DirectUI 库.其前身为 Duiengine,更早期则是源自于金山卫士开源版本 UI 库 Bkwin.经过多年持续更新方得此库.</p>
<p><a href="https://github.com/marakew/syser">syser</a> - syser debugger x32&#x2F;x64 ring3 with source level debugging&#x2F;watch view&#x2F;struct view.</p>
<p><a href="https://github.com/winsiderss/systeminformer">systeminformer</a> - A free, powerful, multi-purpose tool that helps you monitor system resources, debug software and detect malware.</p>
<p><a href="https://github.com/IcEy-999/Ntoskrnl_Viewer">Ntoskrnl_Viewer</a> - 可在非测试模式下符号化读取内核内存。</p>
<p><a href="https://github.com/BeneficialCode/Anti-Rootkit">Anti-Rootkit</a> - Windows Anti-Rootkit Tool.</p>
<p><a href="https://github.com/decalage2/oletools">oletools</a> - oletools - python tools to analyze MS OLE2 files.</p>
<p><a href="https://github.com/wallds/NoVmpy">NoVmpy</a> - This project is just a POC and only works with VMProtect 3.x .</p>
<p><a href="https://github.com/icsharpcode/AvaloniaILSpy">AvaloniaILSpy</a> - Avalonia-based .NET Decompiler (port of ILSpy).</p>
<h2 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h2><p><a href="https://github.com/woxihuannisja/vmp3-import-fix">vmp3-import-fix</a> - Fix VMProtect3 IAT</p>
<h1 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h1><p><a href="https://portswigger.net/burp">BurpSuite</a> - Burp Suite is a leading range of cybersecurity tools, brought to you by PortSwigger. We believe in giving our users a competitive advantage through superior research.</p>
<p><a href="https://github.com/TrojanAZhen/BurpSuitePro-2.1">BurpSuitePro-2.1</a> - 免费的 BurpSuitePro 版本。</p>
<p><a href="https://github.com/Mr-xn/BurpSuite-collections">BurpSuite-collections</a> - BurpSuite 的插件(非商店),文章以及使用技巧的收集.</p>
<p><a href="https://github.com/leolovenet/qqwry2mmdb">qqwry2mmdb</a> - 为 Wireshark 能使用纯真网络 IP 数据库(QQwry)而提供的格式转换工具.</p>
<p><a href="https://github.com/Hackl0us/GeoIP-CN">GeoIP-CN</a> - 🇨🇳 最小巧、最准确、最实用的 中国大陆 IP 段 + GeoIP2 数据库 🇨🇳.</p>
<p><a href="https://github.com/odedshimon/BruteShark">BruteShark</a> - Network Analysis Tool.</p>
<p><a href="https://github.com/brimsec/brim">brim</a> - Desktop application to efficiently search large packet captures and Zeek logs.</p>
<p><a href="https://github.com/mitmproxy/mitmproxy">mitmproxy</a> - An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers.</p>
<p><a href="https://github.com/tomer8007/chromium-ipc-sniffer">chromium-ipc-sniffer</a> - A tool to capture communication between Chromium processes on Windows.</p>
<p><a href="https://github.com/airbus-cert/Winshark">Winshark</a> - A wireshark plugin to instrument ETW.</p>
<p><a href="https://httptoolkit.tech/">httptoolkit</a> - Intercept &amp; view all your HTTP(S).</p>
<p><a href="https://github.com/BigFaceCat2017/frida_ssl_logger">frida_ssl_logger</a> - ssl_logger based on frida.</p>
<p><a href="https://github.com/r0ysue/r0capture">r0capture</a> - 安卓应用层抓包通杀脚本.</p>
<p><a href="https://github.com/lyxhh/lxhToolHTTPDecrypt">lxhToolHTTPDecrypt</a> - Simple Android&#x2F;iOS protocol analysis and utilization tool.</p>
<p><a href="https://github.com/emanuele-f/PCAPdroid">PCAPdroid</a> - No-root network monitor and traffic dump tool for Android devices.</p>
<p><a href="https://github.com/gojue/ecapture">ecapture</a> - capture SSL&#x2F;TLS text content without CA cert using eBPF. supports Linux&#x2F;Android x86_64&#x2F;Aarch64.</p>
<p><a href="https://github.com/fkie-cad/friTap">friTap</a> - The goal of this project is to help researchers to analyze traffic encapsulated in SSL or TLS.</p>
<h1 id="IDA-Pro-插件"><a href="#IDA-Pro-插件" class="headerlink" title="IDA Pro 插件"></a>IDA Pro 插件</h1><p><a href="https://github.com/airbus-cert/comida">comida</a> - An IDA Plugin that help analyzing module that use COM.</p>
<p><a href="https://github.com/cseagle/blc">blc</a> - Integrate Ghidra’s decompiler as an Ida plugin.</p>
<p><a href="https://github.com/danigargu/deREferencing">deREferencing</a> - IDA Pro plugin that implements more user-friendly register and stack views.</p>
<p><a href="https://github.com/push0ebp/ALLirt">ALLIRT</a> - Tool that converts All of libc to signatures for IDA Pro FLIRT Plugin. and utility make sig with FLAIR easily.</p>
<p><a href="https://github.com/a1ext/auto_re">auto_re</a> - IDA PRO auto-renaming plugin with tagging support.</p>
<p><a href="https://github.com/RevSpBird/HightLight">HightLight</a> - a plugin for ida of version 7.2 to help know F5 window codes better.</p>
<p><a href="https://github.com/RicBent/Classy">Classy</a> - IDA Pro plugin to manage classes.</p>
<p><a href="https://github.com/chrisps/Hexext">Hexext</a> - Hexext is a plugin to improve the output of the hexrays decompiler through microcode manipulation.</p>
<p><a href="https://github.com/polymorf/findcrypt-yara">findcrypt-yara</a> - IDA pro plugin to find crypto constants (and more).</p>
<p><a href="https://github.com/Cisco-Talos/GhIDA">GhIDA</a> - GhIDA is an IDA Pro plugin that integrates the Ghidra decompiler in IDA.</p>
<p><a href="https://github.com/tmr232/ida_ipython">ida_ipython</a> - An IDA Pro Plugin for embedding an IPython Kernel.</p>
<p><a href="https://github.com/patois/abyss">abyss</a> - abyss - IDAPython Plugin for Postprocessing of Hexrays Decompiler Output.</p>
<p><a href="https://github.com/patois/hexrays_scripts">hexrays_scripts</a> - Various scripts for the Hexrays decompiler.</p>
<p><a href="https://github.com/patois/dsync">dsync</a> - IDAPython plugin that synchronizes disassembler and decompiler views.</p>
<p><a href="https://github.com/patois/HRDevHelper">HRDevHelper</a> - HexRays decompiler plugin that visualizes the ctree of decompiled functions.</p>
<p><a href="https://github.com/patois/IDAPyHelper">IDAPyHelper</a> - IDAPyHelper is a script for the Interactive Disassembler that helps writing IDAPython scripts and plugins.</p>
<p><a href="https://github.com/patois/IDACyber">IDACyber</a> - Data Visualization Plugin for IDA Pro.</p>
<p><a href="https://github.com/ioncodes/idacode">IDACode</a> - An integration for IDA and VS Code which connects both to easily execute and debug IDAPython scripts.</p>
<p><a href="https://github.com/gaasedelen/lighthouse">lighthouse</a> - A Code Coverage Explorer for IDA Pro &amp; Binary Ninja.</p>
<p><a href="https://github.com/topics/ida-plugin">ida-plugin</a> - ida-plugin topics.</p>
<p><a href="https://github.com/onethawt/idaplugins-list">idaplugins-list</a> - A list of IDA Plugins.</p>
<p><a href="https://github.com/CheckPointSW/Karta">Karta</a> - Karta - source code assisted fast binary matching plugin for IDA.</p>
<p><a href="https://github.com/patois/HexraysToolbox">HexraysToolbox</a> - Hexrays Toolbox - IDAPython script for finding code patterns using Hexrays.</p>
<p><a href="https://github.com/REhints/HexRaysCodeXplorer">HexRaysCodeXplorer</a> - Hex-Rays Decompiler plugin for better code navigation.</p>
<p><a href="https://github.com/0xgalz/Virtuailor">Virtuailor</a> - IDAPython tool for creating automatic C++ virtual tables in IDA Pro.</p>
<p><a href="https://github.com/binarly-io/efiXplorer">efiXplorer</a> - IDA plugin for UEFI firmware analysis and reverse engineering automation.</p>
<p><a href="https://github.com/binaryai/sdk">binaryai</a> - BinaryAI Python SDK.</p>
<p><a href="https://github.com/Chordp/PatternGen">PatternGen</a> - ida sig pattern generate pulgin.</p>
<p><a href="https://github.com/oct0xor/highlight2">highlight2</a> - IDA Pro plugin that changes color of call instructions and works with all architectures.</p>
<p><a href="https://github.com/fireeye/flare-ida">flare-ida</a> - IDA Pro utilities from FLARE team.</p>
<p><a href="https://github.com/blackberry/pe_tree">pe_tree</a> - Python module for viewing Portable Executable (PE) files in a tree-view using pefile and PyQt5. Can also be used with IDA Pro to dump in-memory PE files and reconstruct imports.</p>
<p><a href="https://github.com/repnz/ida-plugins">ida-plugins</a> -A collection of my IDA plugins.</p>
<p><a href="https://github.com/LeadroyaL/IDA_ARM_Unwind">IDA_ARM_Unwind</a> - IDA plugin, unwind stack trace when debugging arm.</p>
<p><a href="https://github.com/synacktiv/bip">bip</a> - Bip is a project which aimed to simplify the usage of python for interacting with IDA.</p>
<p><a href="https://github.com/zyantific/IDASkins">IDASkins</a> - Advanced skinning plugin for IDA Pro .</p>
<p><a href="https://gitlab.com/bluedevil/ida-pro-solarized-theme">ida-pro-solarized-theme</a> - Solarized Theme for IDA Pro 7.3+.</p>
<p><a href="https://github.com/fireeye/FIDL">FIDL</a> - FLARE IDA Decompiler Library.</p>
<p><a href="https://github.com/tkmru/idapm">idapm</a> - idapm is IDA Plugin Manager via GitHub Repository.</p>
<p><a href="https://github.com/hasherezade/ida_ifl">ida_ifl</a> - IFL - Interactive Functions List (plugin for IDA Pro).</p>
<p><a href="https://github.com/ChiChou/IDA-ObjCExplorer">IDA-ObjCExplorer</a> - Objective C classdump for IDA Pro.</p>
<p><a href="https://github.com/lucasg/idamagnum">idamagnum</a> - idamagnum is a plugin for integrating MagnumDB requests within IDA.</p>
<p><a href="https://github.com/gaasedelen/lucid">lucid</a> - An Interactive Hex-Rays Microcode Explorer.</p>
<p><a href="https://github.com/fboldewin/COM-Code-Helper">COM-Code-Helper</a> - Two IDAPython Scripts help you to reconstruct Microsoft COM<br>(Component Object Model) Code.</p>
<p><a href="https://github.com/nccgroup/SusanRTTI">SusanRTTI</a> - Another RTTI Parsing IDA plugin.</p>
<p><a href="https://github.com/medigate-io/ida_medigate">ida_medigate</a> - Medigate plugin for c++ reverse engineering and other utils.</p>
<p><a href="https://github.com/0x1shyboy1/MiasmPlugin">MiasmPlugin</a> - This is a IDA plugin that integrates several modules of miasm.</p>
<p><a href="https://github.com/nologic/idaref">idaref</a> - IDA Pro Instruction Reference Plugin.</p>
<p><a href="https://github.com/hluwa/genmc-dom">genmc-dom</a> - Display Hex-Rays Microcode.</p>
<p><a href="https://github.com/jendabenda/fingermatch">fingermatch</a> - FingerMatch is IDA plugin for collecting functions, data, types and comments from analysed binaries and fuzzy matching them in another binaries.</p>
<p><a href="https://github.com/ajkhoury/SigMaker-x64">SigMaker-x64</a> - IDA Pro 7 compatible SigMaker plugin.</p>
<p><a href="https://github.com/L4ys/LazyIDA">LazyIDA</a> - Make your IDA Lazy!</p>
<p><a href="https://github.com/L4ys/IDASignsrch">IDASignsrch</a> - IDA_Signsrch in Python.</p>
<p><a href="https://github.com/patois/FuncScanner">FuncScanner</a> - Collects extended function properties from IDA Pro databases.</p>
<p><a href="https://github.com/lda-project">lda-project</a> - Topic modeling with latent Dirichlet allocation using Gibbs sampling.</p>
<p><a href="https://lumen.abda.nl/">Lumen</a> - Lumen compatible with IDA Pro’s Lumina.</p>
<p><a href="https://github.com/synacktiv/lumina_server">lumina_server</a> - Local server for IDA Lumina feature.</p>
<p><a href="https://github.com/repnz/ida-plugins">reg_xref</a> - Register Cross References.</p>
<p><a href="https://github.com/tacnetsol/ida">ida</a> - Collection of IDA Python plugins&#x2F;scripts&#x2F;modules.</p>
<p><a href="https://github.com/cellebrite-srl/PacXplorer">PacXplorer</a> - About<br>IDA plugin to find code cross references to virtual functions using PAC codes.</p>
<p><a href="https://github.com/fireeye/capa">capa</a> - FLARE 团队的开源工具可识别可执行文件中的功能。</p>
<p><a href="https://github.com/joxeankoret/idamagicstrings">idamagicstrings</a> - An IDA Python script to extract information from string constants.</p>
<p>[d810]{<a href="https://gitlab.com/eshard/d810%7D">https://gitlab.com/eshard/d810}</a> - D-810 is an IDA Pro plugin which can be used to deobfuscate code at decompilation time by modifying IDA Pro microcode.</p>
<p><a href="https://github.com/SentineLabs/Memloader">Memloader</a> - Memory loader is a DLL based on IDA SDK that allows you to load files into IDA and reverse them without writing the actual file to the disk.</p>
<p><a href="https://github.com/gaasedelen/tenet">tenet</a> - A Trace Explorer for Reverse Engineers.</p>
<p><a href="https://github.com/arizvisa/ida-minsc">ida-minsc</a> - IDA-minsc is a plugin for IDA Pro that assists a user with scripting the IDAPython plugin that is bundled with the disassembler.</p>
<p><a href="https://github.com/danielplohmann/idascope">idascope</a> - An IDA Pro extension for easier (malware) reverse engineering.</p>
<p><a href="https://github.com/TakahiroHaruyama/ida_haru">ida_haru</a> - scripts&#x2F;plugins for IDA Pro.</p>
<p><a href="https://github.com/ax330d/hrdev">hrdev</a> - Hex-Rays Decompiler Enhanced View.</p>
<p><a href="https://github.com/ax330d/functions-plus">functions-plus</a> - IDA Pro plugin to show functions in a tree view.</p>
<p><a href="https://github.com/giladreich/ida_migrator">ida_migrator</a> - IDA Migrator is an IDA Pro plugin which helps migrating current work from one idb instance to another. Giving the ability to conveniently migrate function names, structures and enums.</p>
<p><a href="https://github.com/Maximus-/cfold">cfold</a> - Slightly better IDA code folding.</p>
<p><a href="https://github.com/hugsy/ida-headless">ida-headless</a> - IDA (sort of) headless.</p>
<p><a href="https://github.com/airbus-cert/Yagi">Yagi</a> - Yet Another Ghidra Integration for IDA.</p>
<p><a href="https://github.com/aliyunav/Finger">Finger</a> - A tool for recognizing function symbol.</p>
<p><a href="https://github.com/Martyx00/CollaRE">CollaRE</a> - Multi-tool reverse engineering collaboration solution.</p>
<p><a href="https://github.com/P4nda0s/LazyIDA">LazyIDA</a> - Make your IDA Lazy!</p>
<p><a href="https://github.com/medigateio/ida_medigate">ida_medigate</a> - Medigate plugin for c++ reverse engineering and other utils.</p>
<p><a href="https://github.com/mandiant/flare-ida">flare-ida</a> - IDA Pro utilities from FLARE team.</p>
<p><a href="https://github.com/SentineLabs/AlphaGolang">AlphaGolang</a> - IDApython Scripts for Analyzing Golang Binaries.</p>
<p><a href="https://github.com/strazzere/golang_loader_assist">golang_loader_assist</a> - Making GO reversing easier in IDA Pro.</p>
<p><a href="https://github.com/0xjiayu/go_parser">go_parser</a> - Yet Another Golang binary parser for IDAPro.</p>
<p><a href="https://github.com/Jinmo/ifred">ifred</a> - IDA command palette &amp; more (Ctrl+Shift+P, Ctrl+P).</p>
<p><a href="https://github.com/lucasg/findrpc">findrpc</a> - Idapython script to carve binary for internal RPC structures.</p>
<p><a href="https://github.com/matteyeux/ida-iboot-loader">ida-iboot-loader</a> - IDA loader for Apple’s iBoot, SecureROM and AVPBooter.</p>
<p><a href="https://github.com/alexhude/FRIEND">FRIEND</a> - FRIEND 是一个 IDA 插件，旨在改进反汇编并将注册&#x2F;指令文档直接引入 IDA 视图。</p>
<p><a href="https://github.com/kweatherman/ida_missinglink">ida_missinglink</a> - IDA Plugin that fills in missing indirect CALL &amp; JMP target information.</p>
<h1 id="Ghidra-插件"><a href="#Ghidra-插件" class="headerlink" title="Ghidra 插件"></a>Ghidra 插件</h1><p><a href="https://github.com/0ffffffffh/dragondance">dragondance</a> - Binary code coverage visualizer plugin for Ghidra.</p>
<p><a href="https://github.com/RolfRolles/GhidraPAL">GhidraPAL</a> - Ghidra Program Analysis Library.</p>
<p><a href="https://github.com/RolfRolles/HexRaysDeob">HexRaysDeob</a> - Hex-Rays microcode API plugin for breaking an obfuscating compiler.</p>
<p><a href="https://github.com/ghidraninja/ghidra_scripts">ghidra_scripts</a> - Scripts for the Ghidra software reverse engineering suite.</p>
<p><a href="https://github.com/ghidraninja">ghidraninja</a> - Ghidra Ninja.</p>
<p><a href="https://github.com/andr3colonel/ghidra_wasm">ghidra_wasm</a> - Module to load WebAssembly files into ghidra.</p>
<p><a href="https://github.com/d3v1l401/FindCrypt-Ghidra">FindCrypt-Ghidra</a> - IDA Pro’s FindCrypt ported to Ghidra, with an updated and customizable signature database <a href="https://d3vsite.org/">https://d3vsite.org/</a>.</p>
<p><a href="https://github.com/enovella/ida2ghidra-kb">ida2ghidra-kb</a> - IDA Pro to Ghidra Key Bindings to feel like if you were in IDA Pro when navigating.</p>
<p><a href="https://github.com/Comsecuris/gdbghidra">gdbghidra</a> - gdbghidra - a visual bridge between a GDB session and GHIDRA.</p>
<p><a href="https://github.com/toor-de-force/Ghidra-to-LLVM">Ghidra-to-LLVM</a> - An binary-to-LLVM IR lifter that leverages Ghidra’s IR and analysis.</p>
<p><a href="https://github.com/astrelsky/Ghidra-Cpp-Class-Analyzer">Ghidra-Cpp-Class-Analyzer</a> - Ghidra C++ Class and Run Time Type Information Analyzer.</p>
<p><a href="https://github.com/AllsafeCyberSecurity/awesome-ghidra">awesome-ghidra</a> - A curated list of awesome Ghidra materials.</p>
<p><a href="https://github.com/0xb0bb/pwndra">pwndra</a> - A collection of pwn&#x2F;CTF related utilities for Ghidra.</p>
<p><a href="https://github.com/cetfor/GhidraSnippets">GhidraSnippets</a> - Python snippets for Ghidra’s Program and Decompiler APIs.</p>
<p><a href="https://github.com/fuzzywalls/ghidra_scripts">ghidra_scripts</a> - Port of devttyS0’s IDA plugins to the Ghidra plugin framework, new plugins as well.</p>
<p><a href="https://github.com/astrelsky/vscode-ghidra-skeleton">vscode-ghidra-skeleton</a> - VSCode Ghidra Plugin&#x2F;Script Skeletons.</p>
<p><a href="https://github.com/googleinterns/ghidra-nsis-extension">ghidra-nsis-extension</a> - ghidra-nsis-extension.</p>
<p><a href="https://github.com/reb311ion/emerald">emerald</a> - Import DynamoRIO drcov code coverage data into Ghidra.</p>
<p><a href="https://github.com/0x6d696368/ghidra-data">ghidra-data</a> - 支持 Ghidra 的数据档案 <a href="https://www.nsa.gov/ghidra">https://www.nsa.gov/ghidra</a>.</p>
<p><a href="https://github.com/felberj/gotools">gotools</a> - Plugin for Ghidra to assist reversing Golang binaries.</p>
<p><a href="https://github.com/meromwolff/Ghidra-EFI-Byte-Code-Processor">Ghidra-EFI-Byte-Code-Processor</a> - A Ghidra processor module for the EFI Byte Code (EBC).</p>
<p><a href="https://github.com/Dump-GUY/ghidra_scripts">ghidra_scripts</a> - Scripts for the Ghidra software reverse engineering suite.</p>
<p><a href="https://github.com/PAGalaxyLab/ghidra_scripts">ghidra_scripts</a> - Scripts for the Ghidra.</p>
<p><a href="https://github.com/0x36/ghidra_kernelcache">ghidra_kernelcache</a> - a Ghidra framework for iOS kernelcache reverse engineering.</p>
<p><a href="https://github.com/justfoxing/ghidra_bridge">ghidra_bridge</a> - Python 3 bridge to Ghidra’s Python scripting.</p>
<p><a href="https://github.com/Nalen98/AngryGhidra">AngryGhidra</a> - Angr plugin for Ghdira.</p>
<p><a href="https://github.com/daenerys-sre/source">Daenerys</a> - Daenerys: A framework for interoperability between IDA and Ghidra.</p>
<p><a href="https://github.com/0x6d696368/ghidra-data/tree/master/typeinfo">typeinfo</a> - Ghidra Data Type.</p>
<p><a href="https://github.com/Ayrx/JNIAnalyzer">JNIAnalyzer</a> - Analysis scripts for Ghidra to work with Android NDK libraries.</p>
<p><a href="https://github.com/revolver-ocelot-saa/GhidraX64Dbg">GhidraX64Dbg</a> - Extract annoations from Ghidra into an X32&#x2F;X64 dbg database.</p>
<p><a href="https://github.com/garyttierney/intellij-ghidra">intellij-ghidra</a> - An IntelliJ IDEA plugin for working on Ghidra Extensions.</p>
<p><a href="https://github.com/garyttierney/ghidra-batteries-included">ghidra-batteries-included</a> - Builds of Ghidra 9.2 with additional components included.</p>
<p><a href="https://github.com/schlafwandler/ghidra_SavePatch">ghidra_SavePatch</a> - A Ghidra script to save small patches back to the executable file.</p>
<p><a href="https://github.com/fmagin/ghidra_scripts">ghidra_scripts</a> - ghidra_scripts.</p>
<p><a href="https://github.com/Cuyler36/CodeWarriorDemangler">CodeWarriorDemangler</a> - Code Warrior Demangler Extension for Ghidra.</p>
<p><a href="https://github.com/0x6d696368/ghidra_scripts">ghidra_scripts</a> - Ghidra scripts such as a RC4 decrypter, Yara search, stack string decoder, etc.</p>
<p><a href="https://github.com/reb311ion/replica">replica</a> - Ghidra Analysis Enhancer.</p>
<p><a href="https://github.com/kohnakagawa/gdt_halper">gdt_halper</a> - Ghidra Data Type (GDT) Helper.</p>
<p><a href="https://github.com/HackOvert/GhidraSnippets">GhidraSnippets</a> - Ghidra 的程序和反编译器 API 的 Python 片段.</p>
<p><a href="https://github.com/cmu-sei/kaiju">kaiju</a> - CERT Kaiju 是 Ghidra 软件逆向工程套件的二进制分析框架扩展。</p>
<h1 id="Jeb-Pro-插件"><a href="#Jeb-Pro-插件" class="headerlink" title="Jeb Pro 插件"></a>Jeb Pro 插件</h1><p><a href="https://github.com/LeadroyaL/JebScript">JebScript</a> - Some usefull Jeb Script.</p>
<p><a href="https://github.com/S3cuRiTy-Er1C/JebScripts">JebScripts</a> - 通过 sourceInfo 恢复类名，兼容 jeb2 和 jeb3 的 API.</p>
<p><a href="https://github.com/acbocai/jeb_script">jeb_script</a> - 一些常用的基础的代码分析操作,可用于反混淆&#x2F;路径分析&#x2F;代码定位等.</p>
<p><a href="https://github.com/2Y2s1mple/JebScript">JebScript</a> - A bunch of JEB python scripts.</p>
<p><a href="https://github.com/yoavst/JebOps">JebOps</a> - Handy utils for reversing android apps in JEB.</p>
<h1 id="Frida-工具"><a href="#Frida-工具" class="headerlink" title="Frida 工具"></a>Frida 工具</h1><p><a href="https://github.com/tacesrever/frida-tsplugin">frida-tsplugin</a> - typescript autocomplete plugin for frida’s java warpper.</p>
<p><a href="https://github.com/FuzzySecurity/Fermion">Fermion</a> - Fermion, an electron wrapper for Frida &amp; Monaco.</p>
<p><a href="https://github.com/0x742/noia">noia</a> - Simple Android application sandbox file browser tool. Powered by <a href="https://www.frida.re/">frida.re</a>.</p>
<p><a href="https://github.com/chame1eon/jnitrace-engine">jnitrace-engine</a> - Engine used by jnitrace to intercept JNI API calls.</p>
<p><a href="https://github.com/chame1eon/jnitrace">jnitrace</a> - A Frida based tool that traces usage of the JNI API in Android apps.</p>
<p><a href="https://github.com/ChiChou/vscode-frida">vscode-frida</a> - Unofficial frida extension for VSCode.</p>
<p><a href="https://github.com/GoSecure/frida-xamarin-unpin">frida-xamarin-unpin</a> - A Frida script to bypass Xamarin certificate pinning implementations.</p>
<p><a href="https://github.com/Ch0pin/medusa">medusa</a> - Medusa is an extensible framework for Android applications which automates processes and techniques practised during the dynamic analysis of a malware investigation.</p>
<p><a href="https://github.com/iddoeldor/frida-snippets">frida-snippets</a> - Hand-crafted Frida examples.</p>
<h1 id="Java-逆向"><a href="#Java-逆向" class="headerlink" title="Java 逆向"></a>Java 逆向</h1><p><a href="https://github.com/Col-E/Recaf">Recaf</a> - The modern Java bytecode editor.</p>
<p><a href="https://github.com/GraxCode/JByteMod-Beta">JByteMod</a> - Java bytecode editor.</p>
<p><a href="https://github.com/Konloch/bytecode-viewer">bytecode-viewer</a> - A Java 8+ Jar &amp; Android APK Reverse Engineering Suite (Decompiler, Editor, Debugger &amp; More).</p>
<p><a href="https://github.com/skylot/jadx">jadx</a> - Dex to Java decompiler.</p>
<p><a href="https://github.com/java-decompiler/jd-gui">jd-gui</a> - A standalone Java Decompiler GUI.</p>
<p><a href="https://github.com/deathmarine/Luyten">Luyten</a> - An Open Source Java Decompiler Gui for Procyon.</p>
<p><a href="https://github.com/leibnitz27/cfr">CFR</a> - This is the public repository for the CFR Java decompiler.</p>
<p><a href="https://github.com/LLVM-but-worse/java-disassembler">java-disassembler</a> - The Java Disassembler.</p>
<p><a href="https://github.com/GraxCode/cafecompare">cafecompare</a> - Java code comparison tool (jar &#x2F; class).</p>
<p><a href="https://github.com/castor-software/decompilercmp">decompilercmp</a> - Dataset and tool to analyse and compare java bytecode decompilers.</p>
<p><a href="https://github.com/Col-E/Recaf">Recaf</a> - A modern Java bytecode editor.</p>
<p><a href="https://github.com/GraxCode/cafecompare">cafecompare</a> - Java code comparison tool (jar &#x2F; class)</p>
<p><a href="https://github.com/GraxCode/Cafebabe">Cafebabe</a> - Easy-to-use java bytecode editor - successor of JByteMod!</p>
<p><a href="https://github.com/sim0n/Caesium">Caesium</a> - A Java bytecode obfuscator.</p>
<p><a href="https://github.com/java-deobfuscator/deobfuscator-gui">deobfuscator-gui</a> - A GUI for a the popular java-deobfuscator.</p>
<h1 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h1><p><a href="https://github.com/WerWolv/ImHex">ImHex</a> - A Hex Editor for Reverse Engineers.</p>
<p><a href="https://github.com/williamboman/nvim-lsp-installer">nvim-lsp-installer</a> - Companion plugin for nvim-lspconfig that allows you to seamlessly install LSP servers locally with :LspInstall.</p>
<p><a href="https://github.com/VSCodium/vscodium">vscodium</a> -它就是 VS Code 的一个分支，但它删除 VS Code 原版收集用户数据的功能。如果你不信任微软，如果你是一个开源纯粹主义者，可以试试。</p>
<p><a href="https://github.com/Eloston/ungoogled-chromium">Ungoogled Chromium</a>- 它是 Chromium 的分支，但是把 Google Web 服务依赖全都移除了！</p>
<p><a href="https://github.com/nico/demumble">demumble</a> - A better c++filt and a better undname.exe, in one binary.</p>
<p><a href="https://github.com/TGSAN/CMWTAT_Digital_Edition">CMWTAT_Digital_Edition</a> - win10 激活工具，火绒不报错，开源工具，永久数字证书.</p>
<p><a href="https://github.com/barry-ran/QtScrcpy">QtScrcpy</a> - Android real-time display control software.</p>
<p><a href="https://github.com/CoatiSoftware/Sourcetrail">Sourcetrail</a> - Sourcetrail-免费和开源的交互式资源管理器.</p>
<p><a href="https://github.com/flameshot-org/flameshot">flameshot</a> - flameshot 是一个功能强大且易用的截图软件.</p>
<p><a href="https://github.com/easymodo/qimgv">qimgv</a> - Qt5 image viewer with optional video support.</p>
<p><a href="https://github.com/d2phap/ImageGlass">ImageGlass</a> - A lightweight, versatile image viewer.</p>
<p><a href="http://www.tenmax.com/Teleport_Pro_Installer.exe">Teleport Ultra Pro</a> - 整站下载工具。用户名：<code>zbezj</code> 激活码：<code>664504030</code> <a href="https://macyoyo.cn/html/732.html">来源</a>。</p>
<p><a href="https://github.com/Leon406/ToolsFx">ToolsFx</a> - 基于 kotlin+tornadoFx 开发的跨平台密码学工具箱.包含编解码,编码转换,加解密, 哈希,MAC,签名,二维码功能,ctf 等实用功能,支持插件。</p>
<p><a href="https://github.com/tldr-pages/tldr">tldr</a> - 控制台命令的协作备忘单.</p>
<p><a href="https://github.com/Awesome-Windows/Awesome">Awesome-Windows</a> - 适用于 Windows 的最佳应用程序和工具的精选列表。</p>
<p><a href="https://github.com/iCHAIT/awesome-macOS">awesome-macOS</a> - 适用于 macOS 的精选应用程序、软件、工具和闪亮事物的精选列表。</p>
<p><a href="https://github.com/ashishb/android-security-awesome">android-security-awesome</a> - A collection of android security related resources.</p>
<p><a href="https://github.com/luong-komorebi/Awesome-Linux-Software">Awesome-Linux-Softwar</a> - About<br>A list of awesome applications, software, tools and other materials for Linux distros.</p>
<p><a href="https://github.com/Hack-with-Github/Awesome-Hacking">Awesome-Hacking</a> - A collection of various awesome lists for hackers, pentesters and security researchers.</p>
<p><a href="https://github.com/Ciphey/Ciphey">Ciphey</a> - Automatically decrypt encryptions without knowing the key or cipher, decode encodings, and crack hashes.</p>
<p><a href="https://github.com/L-codes/pwcrack-framework">pwcrack-framework</a> - pwcrack-framework 是一个用 Ruby 编写的密码自动破解框架，目前提供了 25 个在线破解和 25 个离线破解接口，支持 48 种算法破解。</p>
<p><a href="https://github.com/YerongAI/Office-Tool">Office-Tool</a> - Office Tool Plus 本地化项目，用于 Office 部署的强大且有用的工具。</p>
<p><a href="https://github.com/VShawn/PRemoteM">PRemoteM</a> - PRemoteM 是一款现代的远程会话管理和启动器，它让你能够在任何时候快速开启一个远程会话。目前 PRemoteM 已支持 微软远程桌面(RDP)、VNC、SSH、Telnet、SFTP, FTP, RemoteApp 等协议。</p>
<p><a href="https://github.com/wmjordan/PDFPatcher">PDF 补丁丁</a> - PDF 补丁丁是一个用于修改 PDF 文件信息的工具。</p>
<p><a href="https://github.com/hiyohiyo/CrystalDiskInfo">CrystalDiskInfo</a> - CrystalDiskInfo is a disk information tool.</p>
<p><a href="https://github.com/joyqi/sfz">sfz</a> - 专门用于给图片加水印打码的工具</p>
<p><a href="https://github.com/kimci86/bkcrack">bkcrack</a> - 使用 Biham 和 Kocher 已知的明文攻击破解传统的 zip 加密。</p>
<p><a href="https://github.com/Klocman/Bulk-Crap-Uninstaller">Bulk-Crap-Uninstaller</a> - Remove large amounts of unwanted applications quickly.</p>
<p><a href="https://github.com/amezin/vscode-linux-kernel">vscode-linux-kernel</a> - Visual Studio Code project&#x2F;compile_commands.json generator for Linux kernel sources and out-of-tree modules.</p>
<p><a href="https://github.com/SimpleMobileTools">SimpleMobileTools</a> - A group of simple, open source Android apps without ads and unnecessary permissions, with customizable colors.</p>
<p><a href="https://github.com/andreas-mausch/whatsapp-viewer">whatsapp-viewer</a> - Small tool to display chats from the Android msgstore.db database (crypt12).</p>
<p><a href="https://github.com/tangshimin/MuJing">MuJing</a> - 幕境 - 沉浸式学英语,使用自己感兴趣的电影、美剧或文档，生成词库（单词本）。</p>
<p><a href="https://github.com/praetorian-inc/noseyparker">noseyparker</a> - Nosey Parker is a command-line program that finds secrets and sensitive information in textual data and Git history.</p>
<p><a href="https://github.com/iDvel/rime-ice">rime-ice</a> - Rime 配置：雾凇拼音 | 长期维护的简体词库。</p>
<p><a href="https://github.com/vmdiff/vmdiff-prototype">vmdiff-prototype</a> - Diff and display virtual machine snapshots.</p>
<p><a href="https://github.com/zealdocs/zeal">zeal</a></p>
<p>受 Dash 启发的面向软件开发人员的离线文档浏览器。</p>
<p><a href="https://www.voidtools.com/">Everything</a></p>
<p>“Everything” 是 Windows 上一款搜索引擎，它能够基于文件名快速定文件和文件夹位置。</p>
<p><a href="https://github.com/zhongyang219/TrafficMonitor">TrafficMonitor</a></p>
<p>这是一个用于显示当前网速、CPU 及内存利用率的桌面悬浮窗软件，并支持任务栏显示，支持更换皮肤。</p>
<p><a href="https://github.com/Klocman/Bulk-Crap-Uninstaller">Bulk Crap Uninstaller</a></p>
<p>Bulk Crap Uninstaller（或 BCUninstaller）是一个免费的程序卸载程序。</p>
<p><a href="https://github.com/Chuyu-Team/Dism-Multi-language/releases">Dism++</a></p>
<p>Dism++ 是一款 Windows 系统管理优化工具，它解决了我们安装、维护系统的一大痛点问题——自定义设置和优化。相当于一个“一站式”管理优化工具集。</p>
<p><a href="https://filezilla-project.org/">filezilla</a></p>
<p>FileZilla 是一个免费、开源、跨平台的 FTP 应用程序，由 FileZilla Client 和 FileZilla Server 组成。客户端可用于 Windows、Linux 和 macOS。服务器和客户端都支持 FTP 和 FTPS，而客户端还可以连接到 SFTP 服务器。</p>
<p><a href="https://winscp.net/">WinSCP</a><br>WinSCP 是一个开源免费的 SFTP 客户端、FTP 客户端、WebDAV 客户端、S3 客户端和 SCP 客户端以及 Windows 文件管理器。它的主要功能是在本地和远程计算机之间传输文件。除此之外，WinSCP 还提供脚本和基本文件管理器功能。</p>
<p><a href="https://github.com/agalwood/Motrix">Motrix</a></p>
<p>一款全能的下载工具，支持下载 HTTP、FTP、BT、磁力链接等资源。</p>
<p><a href="https://github.com/Kyome22/RunCat_for_windows">RunCat</a></p>
<p>在你的 windows 任务栏上有一个可爱的跑步猫动画。</p>
<p><a href="https://github.com/builtbybel/privatezilla">privatezilla</a><br>Privatezilla 是对您的 Windows 10 副本执行快速隐私和安全检查的最简单方法。</p>
<p><a href="https://github.com/builtbybel/ThisIsWin11">ThisIsWin11</a><br>ThisIsWin11 让你在一个地方定制 Windows 11。它作为 Windows 11 的实用全能工具正在慢慢扩展，取代了一些已停用的 PowerToys 组件并增加了额外的组件。</p>
<p><a href="https://github.com/Uahh/ToastFish">ToastFish</a><br>一个利用摸鱼时间背单词的软件。</p>
<p><a href="https://diskanalyzer.com/">WizTree</a><br>最快的磁盘空间分析器</p>
<p><a href="https://github.com/univrsal/input-overlay">input-overlay</a><br>在流中显示键盘、鼠标和游戏手柄输入。适用于 Windows 和 Linux（64 位）上的 OBS Studio。</p>
<p><a href="https://github.com/TGSAN/CMWTAT_Digital_Edition">CMWTAT_Digital_Edition</a><br>GitHub 上最棒的开源 Win10&#x2F;Win11 数字权利（数字许可证）激活工具！</p>
<p><a href="https://github.com/BluePointLilac/ContextMenuManager">ContextMenuManager</a><br>纯粹的 Windows 右键菜单管理程序</p>
<p><a href="https://github.com/stefankueng/grepWin">grepWin</a><br>一个使用正则表达式的强大而快速的搜索工具。</p>
<p><a href="https://www.sumatrapdfreader.org/">Sumatra PDF</a></p>
<p>PDF, eBook (epub, mobi), comic book (cbz&#x2F;cbr), DjVu, XPS, CHM, image viewer for Windows.</p>
<p><a href="https://github.com/troyeguo/koodo-reader">Koodo-Reader</a></p>
<p>一个跨平台的电子书阅读器，支持阅读格式：</p>
<ul>
<li>EPUB (.epub)</li>
<li>扫描文档 (.pdf, .djvu)</li>
<li>Kindle (.azw3, .mobi, .azw)</li>
<li>纯文本 (.txt)</li>
<li>漫画 (.cbr, .cbz, .cbt, .cb7)</li>
<li>富文本 (.md, .docx, .rtf)</li>
<li>FB2 (.fb2)</li>
<li>超文本 (.html, .xml, .xhtml, .mhtml, .htm, .htm)</li>
</ul>
<p><a href="https://github.com/d2phap/ImageGlass">ImageGlass</a></p>
<p>ImageGlass 是一个轻量级的软件，设计用于在一个简洁直观的界面中无缝查看图像。它支持 80 多种常见的图像格式，包括 WEBP、GIF、SVG、PNG、JXL、HEIC…。</p>
<p><a href="https://github.com/NickeManarin/ScreenToGif">ScreenToGif</a><br>ScreenToGif 允许你记录你的屏幕的选定区域，编辑并保存为 gif 或视频。</p>
<p><a href="https://github.com/obsproject/obs-studio">obs-studio</a><br>OBS Studio - 用于直播和屏幕录制的免费开源软件。</p>
<p><a href="https://github.com/microsoft/vscode">vscode</a></p>
<p>Visual Studio Code（简称 VS Code）是一款由微软开发且跨平台的免费集成开发环境。该软件支持语法高亮、代码自动补全、代码重构功能，并且内置了命令行工具和 Git 版本控制系统。用户可以更改主题和键盘快捷方式实现个性化设置，也可以通过内置的扩展程序商店安装扩展以拓展软件功能。</p>
<p><a href="https://github.com/SpriteOvO/VsCacheCleaner">VsCacheCleaner</a><br>清理 Visual Studio 解决方案缓存，拯救你的磁盘空间！</p>
<blockquote>
<p>以下工具来自 ：<a href="https://github.com/yifeitao/learn/wiki/tools">https://github.com/yifeitao/learn/wiki/tools</a><br>windows</p>
</blockquote>
<ul>
<li><p><a href="https://amazing-apps.gitbook.io/windows-apps-that-amaze-us/zh-cn">https://amazing-apps.gitbook.io/windows-apps-that-amaze-us/zh-cn</a></p>
</li>
<li><p><a href="http://www.wepe.com.cn/">http://www.wepe.com.cn/</a></p>
</li>
<li><p><a href="https://chocolatey.org/">https://chocolatey.org/</a></p>
</li>
<li><p><a href="http://msdn.itellyou.cn/">http://msdn.itellyou.cn/</a></p>
</li>
<li><p><a href="https://ninite.com/">https://ninite.com/</a></p>
</li>
<li><p><a href="https://www.nirsoft.net/">https://www.nirsoft.net/</a></p>
</li>
<li><p><a href="https://joplinapp.org/">https://joplinapp.org/</a> 笔记软件 印象笔记替代</p>
</li>
<li><p><a href="https://github.com/hackjutsu/Lepton">https://github.com/hackjutsu/Lepton</a> gist 管理软件</p>
</li>
<li><p><a href="https://www.basiccat.org/zh/">https://www.basiccat.org/zh/</a> 翻译辅助软件</p>
</li>
<li><p><a href="https://obsproject.com/">https://obsproject.com/</a> 屏幕录制</p>
</li>
<li><p>linux</p>
</li>
<li><p><a href="https://guacamole.apache.org/">https://guacamole.apache.org/</a></p>
</li>
<li><p>app</p>
</li>
<li><p><a href="https://tox.chat/">https://tox.chat/</a></p>
</li>
<li><p><a href="https://github.com/soimort/you-get">https://github.com/soimort/you-get</a><br>科学上网</p>
</li>
<li><p><a href="https://prism-break.org/zh-CN/">https://prism-break.org/zh-CN/</a></p>
</li>
<li><p><a href="https://www.v2ray.com/">https://www.v2ray.com/</a></p>
</li>
<li><p><a href="https://mysterium.network/">https://mysterium.network/</a></p>
</li>
<li><p><a href="https://github.com/ginuerzh/gost">https://github.com/ginuerzh/gost</a></p>
</li>
<li><p><a href="https://github.com/snooda/net-speeder">https://github.com/snooda/net-speeder</a></p>
</li>
<li><p><a href="https://github.com/trailofbits/algo">https://github.com/trailofbits/algo</a></p>
</li>
<li><p><a href="https://github.com/StreisandEffect/streisand">https://github.com/StreisandEffect/streisand</a></p>
</li>
<li><p><a href="https://github.com/haoel/haoel.github.io#33-%E7%94%A8-gost-%E8%AE%BE%E7%BD%AE-https-%E6%9C%8D%E5%8A%A1">https://github.com/haoel/haoel.github.io#33-%E7%94%A8-gost-%E8%AE%BE%E7%BD%AE-https-%E6%9C%8D%E5%8A%A1</a></p>
</li>
<li><p><a href="https://github.com/xuxiaodong/v2ray-for-ansible">https://github.com/xuxiaodong/v2ray-for-ansible</a></p>
</li>
<li><p><a href="https://github.com/ginuerzh/gost">https://github.com/ginuerzh/gost</a></p>
</li>
<li><p>安全</p>
</li>
<li><p><a href="https://flowerpassword.com/">https://flowerpassword.com/</a></p>
</li>
<li><p><a href="https://monitor.firefox.com/">https://monitor.firefox.com/</a></p>
</li>
<li><p><a href="https://www.pixelpin.io/">https://www.pixelpin.io/</a><br>文本编辑</p>
</li>
<li><p><a href="https://casual-effects.com/markdeep/">https://casual-effects.com/markdeep/</a></p>
</li>
<li><p><a href="https://github.com/zadam/trilium">https://github.com/zadam/trilium</a><br>流程图</p>
</li>
<li><p><a href="https://github.com/jgraph/drawio">https://github.com/jgraph/drawio</a><br>信息获取</p>
</li>
<li><p><a href="https://blogtrottr.com/">https://blogtrottr.com/</a></p>
</li>
<li><p><a href="https://fivefilters.org/">https://fivefilters.org/</a><br>文件中转</p>
</li>
<li><p><a href="http://tmp.link/">http://tmp.link/</a></p>
</li>
<li><p><a href="https://send-anywhere.com/">https://send-anywhere.com/</a></p>
</li>
<li><p><a href="https://www.multcloud.com/">https://www.multcloud.com/</a></p>
</li>
<li><p><a href="https://send.firefox.com/">https://send.firefox.com/</a><br>数据分析</p>
</li>
<li><p><a href="https://me.bdp.cn/home.html">https://me.bdp.cn/home.html</a><br>自动化脚本</p>
</li>
<li><p><a href="http://www.sikulix.com/">http://www.sikulix.com/</a><br>开发文档</p>
</li>
<li><p><a href="https://docusaurus.io/">https://docusaurus.io/</a><br>网站构建</p>
</li>
<li><p><a href="https://www.contentful.com/">https://www.contentful.com/</a><br>媒体创作</p>
</li>
<li><p><a href="https://obsproject.com/">https://obsproject.com/</a><br>其它</p>
</li>
<li><p><a href="https://uzer.me/">https://uzer.me/</a></p>
</li>
<li><p><a href="https://www.ipip.net/">https://www.ipip.net/</a></p>
</li>
<li><p><a href="https://www.wolframalpha.com/">https://www.wolframalpha.com/</a></p>
</li>
<li><p><a href="http://www.globalrichlist.com/">http://www.globalrichlist.com/</a><br>旅行</p>
</li>
<li><p><a href="https://traveladapter.xyz/">https://traveladapter.xyz/</a><br>数据</p>
</li>
<li><p><a href="https://github.com/ricklamers/gridstudio">https://github.com/ricklamers/gridstudio</a><br>图片合成</p>
</li>
<li><p><a href="https://imagemagick.org/">https://imagemagick.org/</a><br>视频处理</p>
</li>
<li><p><a href="https://ffmpeg.org/">https://ffmpeg.org/</a><br>代码运行</p>
</li>
<li><p><a href="https://code.labstack.com/">https://code.labstack.com/</a></p>
</li>
</ul>
<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><p>Visual Studio Product Keys</p>
<p><strong>Visual Studio 2022</strong></p>
<p>Enterprise: VHF9H-NXBBB-638P6-6JHCY-88JWH</p>
<p>Professional: TD244-P4NB7-YQ6XK-Y8MMM-YWV2J</p>
<p><strong>Visual Studio 2019</strong></p>
<p>Enterprise BF8Y8-GN2QH-T84XB-QVY3B-RC4DF | KBJFW-NXHK6-W4WJM-CRMQB-G3CD</p>
<p>Professional NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y | NJVYC-BMHX2-G77MM-4XJMR-6Q8QF</p>
<p><strong>Visual Studio 2017</strong></p>
<p>Enterprise: NJVYC-BMHX2-G77MM-4XJMR-6Q8QF | N2VYX-9VR2K-T733M-MWD9X-KQCDF</p>
<p>Professional: KBJFW-NXHK6-W4WJM-CRMQB-G3CDH | 4F3PR-NFKDB-8HFP7-9WXGY-K77T7</p>
<p><strong>Visual Studio 2013</strong></p>
<p>Visual Studio Ultimate 2013 ：BWG7X-J98B3-W34RT-33B3R-JVYW9</p>
<p>Visual Studio Premium 2013 ：FBJVC-3CMTX-D8DVP-RTQCT-92494</p>
<p>Visual Studio Professional 2013 ： XDM3T-W3T3V-MGJWK-8BFVD-GVPKY</p>
<p>Team Foundation Server 2013 ：MHG9J-HHHX9-WWPQP-D8T7H-7KCQG</p>
<p><strong>Visual Studio 2010 Express</strong></p>
<p>Visual Basic: 2KQT8-HV27P-GTTV9-2WBVV-M7X96</p>
<p>C#: PQT8W-68YB2-MPY6C-9JV9X-42WJV</p>
<p>C++: 6VPJ7-H3CXH-HBTPT-X4T74-3YVY7</p>
<p>Web Developer: CY8XP-83P66-WCF9D-G3P42-K2VG3</p>
<p><strong>Visual Studio 2008</strong></p>
<p>Visual Studio 2008 pro ：XMQ2Y-4T3V6-XJ48Y-D3K2V-6C4WT</p>
<h2 id="python-库"><a href="#python-库" class="headerlink" title="python 库"></a>python 库</h2><p><a href="https://github.com/Delgan/loguru">loguru</a> - Python logging made (stupidly) simple</p>
<p><a href="https://github.com/jmcnamara/XlsxWriter">XlsxWriter</a> - A Python module for creating Excel XLSX files.</p>
<p><a href="https://github.com/microsoft/playwright-python">playwright-python</a> - 微软开源的 Python 自动化神器 Playwright.</p>
<p><a href="https://github.com/pyppeteer/pyppeteer">pyppeteer</a> - Headless chrome&#x2F;chromium automation library (unofficial port of puppeteer).</p>
<p><a href="https://github.com/ssssssss-team/spider-flow">spider-flow</a> - 新一代爬虫平台，以图形化方式定义爬虫流程，不写代码即可完成爬虫。</p>
<h2 id="JS-库"><a href="#JS-库" class="headerlink" title="JS 库"></a>JS 库</h2><p><a href="https://github.com/lelinhtinh/de4js">de4js</a> - JavaScript Deobfuscator and Unpacker.</p>
<h2 id="C-库"><a href="#C-库" class="headerlink" title="C++ 库"></a>C++ 库</h2><p><a href="https://github.com/stbrumme/hash-library">hash-library</a> - Portable C++ hashing library.</p>
<p><a href="https://github.com/ZLMediaKit/ZLToolKit">ZLToolKit</a> - 一个基于 C++11 简单易用的轻量级网络编程框架.</p>
<p><a href="https://github.com/lewissbaker/cppcoro">cppcoro</a> - A library of C++ coroutine abstractions for the coroutines TS.</p>
<p><a href="https://github.com/d2school/da4qi4">da4qi4</a> - a cpp Web Server .</p>
<p><a href="https://github.com/zrax/pycdc">pycdc</a> - C++ python bytecode disassembler and decompiler.</p>
<p><a href="https://github.com/zrax/string_theory">string_theory</a> - 具有类型安全格式的灵活现代 C++ 字符串库.</p>
<p><a href="https://github.com/MiroKaku/ucxxrt">ucxxrt</a> - The Universal C++ RunTime library, supporting kernel-mode C++ exception-handler and STL.</p>
<p><a href="https://github.com/MiroKaku/libwsk">libwsk</a> - The Kernel-Mode Winsock library, supporting TCP, UDP and Unix sockets .</p>
<p><a href="https://github.com/LianjiaTech/kbms">kbms</a> - 一个轻量级 c++网络框架.</p>
<p><a href="https://github.com/protocolbuffers/protobuf">protobuf</a> - Protocol Buffers - Google 的数据交换格式.</p>
<p><a href="https://github.com/Raais/ImStudio">ImStudio</a> - Real-time GUI layout creator for Dear ImGui.</p>
<p><a href="https://github.com/troldal/OpenXLSX">OpenXLSX</a> - A C++ library for reading, writing, creating and modifying Microsoft Excel® (.xlsx) files.</p>
<p><a href="https://github.com/seladb/PcapPlusPlus">PcapPlusPlus</a> - PcapPlusPlus is a multiplatform C++ library for capturing, parsing and crafting of network packets.</p>
<p><a href="https://github.com/electronicarts/EAThread">EAThread</a> - EAThread implements a unified cross-platform interface for multithreaded programming.</p>
<p><a href="https://github.com/DaveGamble/cJSON">cJSON</a> - ANSI C 中的超轻量级 JSON 解析器.</p>
<p><a href="https://github.com/alexhude/MMUit">MMUit</a> - 用于探索和修改 ARM64 地址转换的轻量级工具包。</p>
<p><a href="https://github.com/greg7mdp/parallel-hashmap">parallel-hashmap</a> - 一系列仅标头、非常快速且内存友好的哈希图和 btree 容器。</p>
<p><a href="https://github.com/ArthurSonzogni/FTXUI">FTXUI</a> - 一个简单的 C++ 库，用于基于终端的用户界面。</p>
<p><a href="https://github.com/llxiaoyuan/oxorany">oxorany</a> - 带有混淆的编译时任意常量加密.</p>
<p><a href="https://github.com/ultimatepp/ultimatepp">ultimatepp</a> - U++是一个 C++跨平台快速应用开发框架，专注于程序员的生产力。它包括一组库（GUI、SQL、网络等）和集成开发环境（TheIDE）。</p>
<p><a href="https://github.com/kokke/tiny-regex-c">tiny-regex-c</a> - Small portable regex in C.</p>
<p><a href="https://github.com/lpcvoid/cpp-net-lib">cpp-net-lib</a> - Modern, header-only, compact and cross platform C++ network&#x2F;sockets library.</p>
<p><a href="https://github.com/sheredom/utf8.h">utf8.h</a> - single header utf8 string functions for C and C++.</p>
<p><a href="https://github.com/dougbinks/enkiTS">enkiTS</a> - A permissively licensed C and C++ Task Scheduler for creating parallel programs. Requires C++11 support.</p>
<p><a href="https://github.com/osen/stent">stent</a> - Completely avoid dangling pointers in C.</p>
<p><a href="https://github.com/jonathandata1/tyr">tyr</a> - Android Recon &amp; Research Tools.</p>
<p><a href="https://github.com/libcpr/cpr">cpr</a> - C++ Requests: Curl for People, a spiritual port of Python Requests.</p>
<p><a href="https://github.com/fnc12/sqlite_orm">sqlite_orm</a> - SQLite ORM light header only library for modern C++.</p>
<p><a href="https://github.com/skypjack/uvw">uvw</a> - Header-only, event based, tiny and easy to use libuv wrapper in modern C++ .</p>
<p><a href="https://github.com/HoShiMin/Sig">Sig</a> - The most powerful and customizable binary pattern scanner.</p>
<p><a href="https://github.com/fmtlib/fmt">fmt</a> - <code>&#123;fmt&#125;</code> is an open-source formatting library providing a fast and safe alternative to C stdio and C++ iostreams.</p>
<p><a href="https://github.com/abseil/abseil-cpp">abseil-cpp</a> - Abseil 是一个开源的 C++ 库代码集合，旨在增强 C++ 标准库。</p>
<p><a href="https://github.com/ryanhaining/cppitertools">cppitertools</a> - 受 Python 内置函数和 itertools 库启发的基于范围的 for 循环附加组件。与 itertools 和 Python3 内置函数一样，该库尽可能使用惰性求值。</p>
<p><a href="https://github.com/partouf/Crosscables">Crosscables</a> - 用于线程、文件系统、网络、MySQL 和其他事物的跨平台 C++98 库。</p>
<p><a href="https://github.com/niekbouman/ctbignum">ctbignum</a> - Constexpr C++20 Big-Integer &#x2F; Finite-Field library</p>
<p><a href="https://github.com/Neargye/magic_enum">magic_enum</a> - 为枚举提供静态反射，无需任何宏或样板代码即可处理任何枚举类型。</p>
<p><a href="https://github.com/CLIUtils/CLI11">CLI11</a> - CLI11 is a command line parser for C++11 and beyond that provides a rich feature set with a simple and intuitive interface.</p>
<p><a href="https://github.com/rbock/sqlpp11">sqlpp11</a> - A type safe SQL template library for C++.</p>
<p><a href="https://github.com/likle/cwalk">cwalk</a> - Path library for C&#x2F;C++. Cross-Platform for Windows, MacOS and Linux.</p>
<p><a href="https://github.com/Quintus/pathie-cpp">pathie-cpp</a> - Small C++ library for crossplatform Unicode path management</p>
<p><a href="https://github.com/iUIShop/LibUIDK">LibUIDK</a> - LibUIDK 原来是商业界面库，2019 年 9 月 8 号开源。是专业开发 Windows 平台下图形用户界面的开发包，也是国内第一款商业的高级界面开发工具。</p>
<p><a href="https://github.com/josuttis/belleviews">belleviews</a> - Belleviews are easier to use, more robust, and cause less unexpected compile-time and runtime errors than the views of the C++ standard library.</p>
<p><a href="https://github.com/google/benchmark">benchmark</a> - A library to benchmark code snippets, similar to unit tests.</p>
<p><a href="https://github.com/gabime/spdlog">spdlog</a> - Very fast, header-only&#x2F;compiled, C++ logging library. ci</p>
<p><a href="https://github.com/foonathan/type_safe">type_safe</a> - type_safe provides zero overhead abstractions that use the C++ type system to prevent bugs.</p>
<p><a href="https://github.com/marzer/tomlplusplus">tomlplusplus</a> - Header-only TOML config file parser and serializer for C++17.</p>
<p><a href="https://github.com/ToruNiina/toml11">toml11</a> - toml11 is a C++11 (or later) header-only toml parser&#x2F;encoder depending only on C++ standard library.</p>
<p><a href="https://github.com/TartanLlama/expected">expected</a> - Single header implementation of std::expected with functional-style extensions.</p>
<p><a href="https://github.com/oneapi-src/oneTBB">oneTBB</a> - oneTBB is a flexible C++ library that simplifies the work of adding parallelism to complex applications, even if you are not a threading expert.</p>
<p><a href="https://github.com/taocpp/json">taoJSON</a> - taoJSON is a C++ header-only JSON library that provides a generic Value Class, uses Type Traits to interoperate with C++ types, uses an Events Interface to convert from and to JSON, JAXN, CBOR, MsgPack and UBJSON, and much more…</p>
<p><a href="https://github.com/rollbear/strong_type">strong_type</a> - An additive strong typedef library for C++14&#x2F;17&#x2F;20 using the Boost Software License 1.0</p>
<p><a href="https://github.com/jfalcou/spy">spy</a> - Detection and versioning of operating systems, compilers, architecture and other element are traditionally done using preprocessor macros. Library like Boost.Predef provides a sanitized interface on top of those but still live in a world where the preprocessor is king.</p>
<p><a href="https://github.com/ThePhD/sol2">sol2</a> - sol2 is a C++ library binding to Lua. It currently supports all Lua versions 5.1+ (LuaJIT 2.0+ and MoonJIT included).</p>
<p><a href="https://github.com/ericniebler/range-v3">range-v3</a> - Range library for C++14&#x2F;17&#x2F;20, basis for C++20’s std::ranges .</p>
<p><a href="https://github.com/zeux/pugixml">pugixml</a> - Light-weight, simple and fast XML parser for C++ with XPath support.</p>
<p><a href="https://github.com/ned14/outcome">outcome</a> - Outcome is a C++14 library for reporting and handling function failures. It can be used as a substitute for, or a complement to, the exception handling mechanism.</p>
<p><a href="https://github.com/libuv/libuv">libuv</a> - libuv is a multi-platform support library with a focus on asynchronous I&#x2F;O. It was primarily developed for use by Node.js, but it’s also used by Luvit, Julia, uvloop, and others.</p>
<p><a href="https://www.lua.org/">lua</a> - Lua is a powerful, efficient, lightweight, embeddable scripting language. It supports procedural programming, object-oriented programming, functional programming, data-driven programming, and data description.</p>
<p><a href="https://github.com/p12tic/libsimdpp">libsimdpp</a> - libsimdpp is a portable header-only zero-overhead C++ low level SIMD library. The library presents a single interface over SIMD instruction sets present in x86, ARM, PowerPC and MIPS architectures.</p>
<p><a href="https://github.com/danielaparker/jsoncons">jsoncons</a> - A C++, header-only library for constructing JSON and JSON-like data formats, with JSON Pointer, JSON Patch, JSON Schema, JSONPath, JMESPath, CSV, MessagePack, CBOR, BSON, UBJSON .</p>
<p><a href="https://github.com/google/highway">highway</a> - Performance-portable, length-agnostic SIMD with runtime dispatch .</p>
<p><a href="https://github.com/nemequ/hedley">hedley</a> - Hedley is C&#x2F;C++ a header file designed to smooth over some platform-specific annoyances.</p>
<p><a href="https://github.com/beached/daw_json_link">daw_json_link</a> - Fast, convenient JSON serialization and parsing in C++ .</p>
<p><a href="https://github.com/Hosseinmoein/DataFrame">DataFrame</a> - This is a C++ analytical library designed for data analysis similar to libraries in Python and R. For example, you could compare this to Pandas or R data.frame.</p>
<p><a href="https://github.com/HowardHinnant/date">date</a> - A date and time library based on the C++11&#x2F;14&#x2F;17 <code>&lt;chrono&gt;</code> header.</p>
<p><a href="https://github.com/hanickadot/compile-time-regular-expressions">compile-time-regular-expressions</a> - Compile Time Regular Expression in C++ .</p>
<p><a href="https://github.com/hanickadot/cthash">cthash</a> - This library is constexpr implementation of SHA-2 and SHA-3 family of hashes.</p>
<p><a href="https://github.com/partouf/Crosscables">Crosscables</a> - A cross platform C++98 library for Threading, Filesystem, Network, MySQL and other things .</p>
<p><a href="https://github.com/soasis/text">ztd.text</a> - A spicy text library for C++ that has the explicit goal of enabling the entire ecosystem to share in proper forward progress towards a bright Unicode future.</p>
<p><a href="https://github.com/SRombauts/SQLiteCpp">SQLiteCpp</a> -</p>
<p><a href="https://github.com/p-ranav/indicators">indicators</a> - Thread-safe progress bars and spinners.</p>
<p><a href="https://github.com/simdutf/simdutf">simdutf</a> - Unicode routines (UTF8, UTF16, UTF32): billions of characters per second using SSE2, AVX2, NEON, AVX-512.</p>
<p><a href="https://github.com/codecrafters-io/build-your-own-x">build-your-own-x</a> - Master programming by recreating your favorite technologies from scratch.</p>
<p><a href="https://github.com/jarro2783/cxxopts">cxxopts</a> - Lightweight C++ command line option parser.</p>
<p><a href="https://github.com/GrammaTech/ddisasm">ddisasm</a> - A fast and accurate disassembler.</p>
<h2 id="Rust-库"><a href="#Rust-库" class="headerlink" title="Rust 库"></a>Rust 库</h2><h2 id="Java-库"><a href="#Java-库" class="headerlink" title="Java 库"></a>Java 库</h2><p><a href="https://github.com/dhatim/fastexcel">fastexcel</a> - Generate and read big Excel files quickly.</p>
<p><a href="https://github.com/hzw1199/xml2axml">xml2axml</a> - encode xml to axml AND decode axml to xml–Hack Android Manifest easily.</p>
<p><a href="https://github.com/fornwall/jelf">jelf</a> - ELF parsing library in java.</p>
<h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><p><a href="https://github.com/LostMyCode/javascript-deobfuscator">javascript-deobfuscator</a></p>
<h1 id="取证"><a href="#取证" class="headerlink" title="取证"></a>取证</h1><p><a href="https://github.com/cugu/awesome-forensics">awesome-forensics</a> - A curated list of awesome forensic analysis tools and resources.</p>
<p><a href="https://github.com/den4uk/andriller">andriller</a> - Andriller - is software utility with a collection of forensic tools for smartphones.</p>
<h1 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h1><p><a href="https://github.com/zgjx6/SocialEngineeringDictionaryGenerator">SocialEngineeringDictionaryGenerator</a> - 社会工程学密码生成器，是一个利用个人信息生成密码的工具.</p>
<p>下列提供的内容来自互联网，均未验证准确性，请自行抉择。</p>
<p>短信验证提供一次性号码的站点</p>
<p><a href="https://www.proovl.com/numbers">https://www.proovl.com/numbers</a><br><a href="http://7sim.net/">http://7sim.net</a><br><a href="https://receive-a-sms.com/">https://receive-a-sms.com</a><br><a href="https://www.receivesmsonline.net/">https://www.receivesmsonline.net</a><br><a href="https://1s2u.com/">https://1s2u.com</a><br><a href="http://smsget.net/">http://smsget.net</a><br><a href="https://sms-online.co/">https://sms-online.co</a><br><a href="http://receivesmsonline.eu/">http://receivesmsonline.eu</a><br><a href="https://www.groovl.com/">https://www.groovl.com</a><br><a href="http://getsms.org/">http://getsms.org</a><br><a href="http://sms.sellaite.com/">http://sms.sellaite.com</a><br><a href="https://virtty.com/">https://virtty.com</a><br><a href="http://receivefreesms.com/">http://receivefreesms.com</a><br><a href="https://anon-sms.com/">https://anon-sms.com</a><br><a href="http://receivesmsonline.me/">http://receivesmsonline.me</a><br><a href="http://www.virtualnumberbuy.com/">http://www.virtualnumberbuy.com</a><br><a href="https://smslisten.com/">https://smslisten.com</a><br><a href="https://www.smsver.com/">https://www.smsver.com</a><br><a href="https://www.temp-mails.com/">https://www.temp-mails.com</a><br><a href="https://freesmscode.com/">https://freesmscode.com</a><br><a href="https://www.pinger.com/">https://www.pinger.com</a><br><a href="https://freevirtualsmsnumber.com/">https://freevirtualsmsnumber.com</a><br><a href="http://hidemynumbers.com/">http://hidemynumbers.com</a><br><a href="https://sms.ndtan.net/">https://sms.ndtan.net</a><br><a href="https://receive-sms-online.com/">https://receive-sms-online.com</a><br><a href="http://hs3x.com/">http://hs3x.com</a><br><a href="https://receivesmsnumber.com/">https://receivesmsnumber.com</a><br><a href="http://www.sendsmsnow.com/">http://www.sendsmsnow.com</a><br><a href="http://receivefreesms.net/">http://receivefreesms.net</a><br><a href="https://5sim.net/">https://5sim.net</a><br><a href="http://receivesmsonline.in/">http://receivesmsonline.in</a><br><a href="https://smsreceiveonline.com/">https://smsreceiveonline.com</a><br><a href="https://smsreceivefree.com/">https://smsreceivefree.com</a><br><a href="http://freereceivesmsonline.com/">http://freereceivesmsonline.com</a><br><a href="https://smstibo.com/">https://smstibo.com</a><br><a href="https://www.freeonlinephone.org/">https://www.freeonlinephone.org</a><br><a href="https://catchsms.com/">https://catchsms.com</a><br><a href="https://es.mytrashmobile.com/numeros">https://es.mytrashmobile.com/numeros</a><br><a href="http://sms-receive.net/">http://sms-receive.net</a><br><a href="http://www.textanywhere.net/">http://www.textanywhere.net</a><br><a href="https://smsreceiving.com/">https://smsreceiving.com</a><br><a href="https://getfreesmsnumber.com/">https://getfreesmsnumber.com</a></p>
<p>为电子邮件验证提供一次性电子邮件的站点：</p>
<p><a href="https://maildrop.cc/">https://maildrop.cc</a><br><a href="https://tempmail.net/">https://tempmail.net</a><br><a href="https://tempr.email/en">https://tempr.email/en</a><br><a href="https://www.moakt.com/">https://www.moakt.com</a><br><a href="https://temp-mail.org/en">https://temp-mail.org/en</a><br><a href="https://www.emailondeck.com/">https://www.emailondeck.com</a><br><a href="https://www.guerrillamail.com/">https://www.guerrillamail.com</a></p>
<p>20MinuteMail 维持 20 分钟<br><a href="http://www.20minutemail.com/#top">http://www.20minutemail.com/#top</a><br>Snapmail 24 小时临时邮箱<br><a href="https://www.snapmail.cc/">https://www.snapmail.cc</a><br>10 Minutes Email - 10 分钟一次性电子邮件<br><a href="https://10minemail.com/zh/">https://10minemail.com/zh/</a><br>临时邮箱 - 十秒钟内收到邮件<br><a href="https://linshiyouxiang.net/">https://linshiyouxiang.net/</a><br>Temp Mail<br><a href="https://tempmail.altmails.com/">https://tempmail.altmails.com/</a><br>临时邮箱（10 分钟)<br><a href="http://24mail.chacuo.net/">http://24mail.chacuo.net/</a><br>Mailsac<br><a href="https://mailsac.com/">https://mailsac.com/</a><br>Mailinator<br><a href="https://www.mailinator.com/">https://www.mailinator.com/</a><br>DizyMail 保留 2 天<br><a href="https://dizymail.com/">https://dizymail.com/</a><br>maildrop<br><a href="https://maildrop.cc/">https://maildrop.cc</a><br>bccto 10 分钟邮箱<br><a href="http://bccto.me/">http://bccto.me</a><br>10minutemail 老牌网站 07 年稳定至今<br><a href="https://10minutemail.com/">https://10minutemail.com</a><br>10minutemail 10 分钟邮箱<br><a href="https://10minutemail.net/?lang=zh-cn">https://10minutemail.net/?lang=zh-cn</a><br>temp-mail 10 分钟临时邮箱<br><a href="https://temp-mail.org/zh/">https://temp-mail.org/zh/</a><br>guerrillamail 60 分钟临时邮箱<br><a href="https://www.guerrillamail.com/zh/">https://www.guerrillamail.com/zh/</a><br>moakt 一个 60 分钟临时邮箱<br><a href="https://www.moakt.com/zh/mail">https://www.moakt.com/zh/mail</a><br>incognitomail 60 分钟邮箱<br><a href="http://www.incognitomail.com/">http://www.incognitomail.com/</a><br>Nowmymail 60 分钟邮箱<br><a href="https://www.nowmymail.com/">https://www.nowmymail.com/</a><br>24mail 24 小时临时邮箱<br><a href="http://24mail.chacuo.net/enus">http://24mail.chacuo.net/enus</a><br>yopmail 5 天临时邮箱<br><a href="http://www.yopmail.com/zh/">http://www.yopmail.com/zh/</a><br>mfk.app<br><a href="https://www.8164.cc/">https://www.8164.cc/</a><br>Mailnesia - 便捷的匿名邮箱<br><a href="http://mailnesia.com/">http://mailnesia.com/</a><br>IHotmails Mail<br><a href="https://ihotmails.com/">https://ihotmails.com/</a><br>一次性临时电子邮件 - 📨 Temp Mail<br><a href="https://temp-mail.io/zh">https://temp-mail.io/zh</a><br>临时邮箱 - 一次性临时电子邮件服务<br><a href="https://mail.td/zh">https://mail.td/zh</a><br>临时邮箱- 马建军大学免费教育邮箱<br><a href="https://mail.mjj.edu.ge/">https://mail.mjj.edu.ge/</a><br>临时邮箱，10 分钟邮箱<br><a href="https://www.linshi-email.com/">https://www.linshi-email.com/</a></p>
<p>提供虚假身份的网站：</p>
<p><a href="https://fakena.me/">https://fakena.me</a><br><a href="https://fauxid.com/">https://fauxid.com</a><br><a href="https://uinames.com/">https://uinames.com</a><br><a href="https://www.fakenamegenerator.com/">https://www.fakenamegenerator.com</a><br><a href="https://www.fakepersongenerator.com/">https://www.fakepersongenerator.com</a></p>
<h1 id="威胁情报"><a href="#威胁情报" class="headerlink" title="威胁情报"></a>威胁情报</h1><p><a href="https://github.com/KasperskyLab/TinyCheck">TinyCheck</a> - TinyCheck allows you to easily capture network communications from a smartphone or any device which can be associated to a Wi-Fi access point in order to quickly analyze them.</p>
<p><a href="https://github.com/SpyGuard/SpyGuard">SpyGuard</a> - SpyGuard’s main objective is to detect signs of compromise by monitoring network flows transmitted by a device.</p>
<p><a href="https://github.com/stamparm/maltrail">maltrail</a> - Malicious traffic detection system.</p>
<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p><a href="https://github.com/LiLittleCat/awesome-free-chatgpt">awesome-free-chatgpt</a> - 免费的 ChatGPT 镜像网站列表，持续更新。</p>
<p><a href="https://github.com/xx025/carrot">carrot</a> - 这儿为你准备了众多免费好用的 ChatGPT 镜像站点，当前 100+站点.</p>
<p><a href="https://github.com/f/awesome-chatgpt-prompts">awesome-chatgpt-prompts</a> - This repo includes ChatGPT prompt curation to use ChatGPT better.</p>
<p><a href="https://github.com/PlexPt/awesome-chatgpt-prompts-zh">awesome-chatgpt-prompts-zh</a> - ChatGPT 中文调教指南。各种场景使用指南。学习怎么让它听你的话。</p>
<p><a href="https://github.com/Chanzhaoyu/chatgpt-web">chatgpt-web</a> - 用 Express 和 Vue3 搭建的 ChatGPT 演示网页</p>
<p><a href="https://github.com/acheong08/EdgeGPT">EdgeGPT</a> - Reverse engineered API of Microsoft’s Bing Chat AI.</p>
<h1 id="浏览器扩展"><a href="#浏览器扩展" class="headerlink" title="浏览器扩展"></a>浏览器扩展</h1><p><a href="https://github.com/immersive-translate/immersive-translate/">沉浸式双语网页翻译扩展</a></p>
<p>主要特性</p>
<ul>
<li>智能识别网页主内容区进行翻译，与同类插件翻译整个网页不同，降低对原网页的“侵入性”，提升阅读体验，因此得名“沉浸式翻译”。</li>
<li>双语显示，中英文对照。</li>
<li>针对常见主流网站进行定制优化，如 Twitter，Reddit，Discord, Gmail, Telegram, Youtube, Hacker News 等。</li>
<li>支持 10 余种常用翻译服务，包括 Deepl，OpenAI(ChatGPT 3.5)，谷歌，彩云小译，腾讯翻译君，百度翻译，火山翻译等。</li>
<li>支持 PDF 文件，EPUB 电子书双语翻译，制作与导出。</li>
<li>全平台浏览器支持，包括桌面端、移动端，iOS 端，Chrome、Edge、Firefox，Safari 等。</li>
<li>提供多种译文样式选择，如弱化、模糊、下划线、分隔线等样式，个性化定制翻译体验。</li>
</ul>
<p><a href="https://github.com/zimocode/smartup">smartup</a></p>
<p>一个更好的手势类扩展。功能包括：鼠标手势，简易拖曳，超级拖曳，摇杆手势和滚轮手势。</p>
<p><a href="https://github.com/iorate/ublacklist">ublacklist</a></p>
<p>此浏览器扩展可以帮你在谷歌搜索结果中屏蔽一些你不想看到的网站。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>移植FART到Adnroid 9.0</title>
    <url>/2020/07/17/%E7%A7%BB%E6%A4%8DFART%E5%88%B0Adnroid-9-0/</url>
    <content><![CDATA[<p>最近有点时间就尝试着移植 FART 到 Android 9.0 ，本文记录一下的整个过程。</p>
<h1 id="获取-cloassloader-执行主动调用"><a href="#获取-cloassloader-执行主动调用" class="headerlink" title="获取 cloassloader 执行主动调用"></a>获取 cloassloader 执行主动调用</h1><p>首先修改 <code>frameworks/base/core/java/android/app/ActivityThread.java</code> 文件，添加以下内容。其中主要思想就是获取 apk 的 classloader 然后通过反射获取 dumpMethodCode 方法，执行主动调用，下面添加 dumpMethodCode 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// add start</span><br><span class="line">import android.os.Build;</span><br><span class="line">import android.util.ArrayMap;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.lang.ref.WeakReference;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Modifier;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import dalvik.system.BaseDexClassLoader;</span><br><span class="line">import dalvik.system.DexClassLoader;</span><br><span class="line">// add end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// add start</span><br><span class="line">    public static String CKCatTAG = &quot;CKCatUnPack&quot;;</span><br><span class="line">    public static Field getClassField(ClassLoader classloader, String className,</span><br><span class="line">        String fieldName)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Class clazz = classloader.loadClass(className);</span><br><span class="line">            Field field = clazz.getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            return field;</span><br><span class="line"></span><br><span class="line">        &#125;catch(SecurityException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object getClassFieldObject(ClassLoader classloader, String className, </span><br><span class="line">        Object obj, String fieldName)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz = classloader.loadClass(className);</span><br><span class="line">            Field field = clazz.getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            Object result = null;</span><br><span class="line">            result = field.get(obj);</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object invokeStaticMethod(String className, String methodName,</span><br><span class="line">        Class[] pareType, Object[] pareValues)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz = Class.forName(className);</span><br><span class="line">            Method method = clazz.getMethod(methodName, pareType);</span><br><span class="line">            return method.invoke(null, pareValues);</span><br><span class="line">        &#125; catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object getFieldObject(String className, Object obj,</span><br><span class="line">        String fieldName)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz = Class.forName(className);</span><br><span class="line">            Field field = clazz.getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            return field.get(obj);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ClassLoader getClassLoader()&#123;</span><br><span class="line">        ClassLoader classloader = null;</span><br><span class="line">        Object currentActivityThread = invokeStaticMethod(&quot;android.app.ActivityThread&quot;,</span><br><span class="line">            &quot;currentActivityThread&quot;, new Class[]&#123;&#125;, new Object[]&#123;&#125;);</span><br><span class="line">        Object mBoundApplication = getFieldObject(&quot;android.app.ActivityThread&quot;, </span><br><span class="line">            currentActivityThread, &quot;mBoundApplication&quot;);</span><br><span class="line">        Object loadedApkInfo = getFieldObject(&quot;android.app.ActivityThread$AppBindData&quot;,</span><br><span class="line">            mBoundApplication, &quot;info&quot;);</span><br><span class="line">        Application mApplication = (Application)getFieldObject(&quot;android.app.loadedApk&quot;,</span><br><span class="line">            loadedApkInfo, &quot;mApplication&quot;);</span><br><span class="line">        classloader = mApplication.getClassLoader();</span><br><span class="line">        return classloader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void loadClassAndInvoke(ClassLoader appClassloader, String eachClassName, </span><br><span class="line">        Method dumpMethodCode_method)&#123;</span><br><span class="line">        Log.i(CKCatTAG, &quot;go into loadClassAndInvoke-&gt;&quot; + &quot;classname:&quot; + eachClassName);</span><br><span class="line"></span><br><span class="line">        Class retClass = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            retClass = appClassloader.loadClass(eachClassName);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (Error e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        if (retClass != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Constructor&lt;?&gt; cons[] = retClass.getDeclaredConstructors();</span><br><span class="line">                for (Constructor&lt;?&gt; constructor : cons)&#123;</span><br><span class="line">                    if (dumpMethodCode_method != null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            dumpMethodCode_method.invoke(null, constructor);</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125; catch (Error e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Log.e(CKCatTAG, &quot;dumpMethodCode_method is null &quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (Error e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Method[] methods = retClass.getDeclaredMethods();</span><br><span class="line">                if (methods != null) &#123;</span><br><span class="line">                    for (Method m : methods) &#123;</span><br><span class="line">                        if (dumpMethodCode_method != null) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                               dumpMethodCode_method.invoke(null, m);</span><br><span class="line">                             &#125; catch (Exception e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125; catch (Error e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125; </span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            Log.e(CKCatTAG, &quot;dumpMethodCode_method is null &quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (Error e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void fart()&#123;</span><br><span class="line">        //获取当前 classloader</span><br><span class="line">        ClassLoader appClassloader = getClassLoader();</span><br><span class="line">        List&lt;Object&gt; dexFieldsArray = new ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">        // 获取 pathList 字段</span><br><span class="line">        Field pathList_Field = (Field)getClassField(appClassloader, </span><br><span class="line">            &quot;dalvik.system.BaseDexClassLoader&quot;, &quot;pathList&quot;);</span><br><span class="line">        Object pathList_object = getFieldObject(&quot;dalvik.system.BaseDexClassLoader&quot;, </span><br><span class="line">            appClassloader, &quot;pathList&quot;);</span><br><span class="line"></span><br><span class="line">        // 获取 dexElements</span><br><span class="line">        Object[] dexElements = (Object[]) getFieldObject(&quot;dalvik.system.DexPathList&quot;, </span><br><span class="line">            pathList_object, &quot;dexElements&quot;);</span><br><span class="line"></span><br><span class="line">        Field dexFile_Field = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            dexFile_Field = (Field)getClassField(appClassloader, </span><br><span class="line">                &quot;dalvik.system.DexPathList$Element&quot;, &quot;dexFile&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class dexFileClazz = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            dexFileClazz = appClassloader.loadClass(&quot;dalvik.system.DexFile&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method getClassNameList_Method = null;</span><br><span class="line">        Method defineClass_Method = null;</span><br><span class="line">        Method dumpMethodCode_Method = null;</span><br><span class="line">        // 通过反射获取获取 dumpMethodCode </span><br><span class="line">        for (Method method : dexFileClazz.getDeclaredMethods())&#123;</span><br><span class="line">            if (method.getName().equals(&quot;getClassNameList&quot;)) &#123;</span><br><span class="line">                getClassNameList_Method = method;</span><br><span class="line">                getClassNameList_Method.setAccessible(true);</span><br><span class="line">            &#125;</span><br><span class="line">            if (method.getName().equals(&quot;defineClassNative&quot;)) &#123;</span><br><span class="line">                defineClass_Method = method;</span><br><span class="line">                defineClass_Method.setAccessible(true);</span><br><span class="line">            &#125;</span><br><span class="line">            if (method.getName().equals(&quot;dumpMethodCode&quot;)) &#123;</span><br><span class="line">                dumpMethodCode_Method = method;</span><br><span class="line">                dumpMethodCode_Method.setAccessible(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取 mCookie</span><br><span class="line">        Field mCookieField = getClassField(appClassloader, &quot;dalvik.system.DexFile&quot;, &quot;mCookie&quot;);</span><br><span class="line">        for (int i = 0; i &lt; dexElements.length; i++) &#123;</span><br><span class="line">            Object element = dexElements[i];</span><br><span class="line">            Object dexfile = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                dexfile = (Object)dexFile_Field.get(element);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (dexfile == null) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(dexfile != null)&#123;</span><br><span class="line">                dexFieldsArray.add(dexfile);</span><br><span class="line">                Object mCookie = getClassFieldObject(appClassloader, </span><br><span class="line">                    &quot;dalvik.system.DexFile&quot;, dexfile, &quot;mCookie&quot;);</span><br><span class="line">                if (mCookie == null) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String[] classNames = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    classNames = (String[])getClassNameList_Method.invoke(dexfile, mCookie);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; catch (Error e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (classNames != null) &#123;</span><br><span class="line">                    for(String eachClassName: classNames)&#123;</span><br><span class="line">                        // 执行主动调用</span><br><span class="line">                        loadClassAndInvoke(appClassloader, eachClassName, dumpMethodCode_Method);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void fartthread()&#123;</span><br><span class="line">        new Thread(new Runnable()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    Log.e(CKCatTAG, &quot;start sleep,wait for fartthread start......&quot;);</span><br><span class="line">                    Thread.sleep(1*60*1000);</span><br><span class="line">                &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                Log.e(CKCatTAG, &quot;sleep over and start fartthread&quot;);</span><br><span class="line">                fart();</span><br><span class="line">                Log.e(CKCatTAG, &quot;fart run over&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    // add end</span><br><span class="line"></span><br><span class="line">    /**  Core implementation of activity launch. */</span><br><span class="line">    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        // add start</span><br><span class="line">        fartthread();</span><br><span class="line">        // add end</span><br><span class="line">        return activity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="添加-dumpMethodCode-方法"><a href="#添加-dumpMethodCode-方法" class="headerlink" title="添加 dumpMethodCode 方法"></a>添加 dumpMethodCode 方法</h1><p>在 <code>libcore/dalvik/src/main/java/dalvik/system/DexFile.java</code> 中声明 dumpMethodCode 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//声明 dumpMethodCode 方法</span><br><span class="line">private static native void dumpMethodCode(Object m);</span><br></pre></td></tr></table></figure>

<p>在 <code>art/runtime/native/dalvik_system_DexFile.cc</code> 中实现 dumpMethodCode 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// add start</span><br><span class="line">#include &quot;art_method-inl.h&quot;</span><br><span class="line">#include &quot;class_linker.h&quot;</span><br><span class="line">#include &quot;jni_internal.h&quot;</span><br><span class="line">#include &quot;mirror/class-inl.h&quot;</span><br><span class="line">#include &quot;mirror/object-inl.h&quot;</span><br><span class="line">#include &quot;mirror/object_array-inl.h&quot;</span><br><span class="line">#include &quot;reflection.h&quot;</span><br><span class="line">#include &quot;scoped_fast_native_object_access-inl.h&quot;</span><br><span class="line">#include &quot;well_known_classes.h&quot;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; void myfartInvoke(ArtMethod* artmethod);</span><br><span class="line"></span><br><span class="line">static void DexFile_dumpMethodCode(JNIEnv* env, jclass, jobject method)&#123;</span><br><span class="line"></span><br><span class="line">  ScopedFastNativeObjectAccess soa(env);</span><br><span class="line">  if (method != nullptr)&#123;</span><br><span class="line">    ArtMethod* artmethod = ArtMethod::FromReflectedMethod(soa, method);</span><br><span class="line">    myfartInvoke(artmethod);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// add end</span><br></pre></td></tr></table></figure>

<p>动态注册 dumpMethodCode 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">  NATIVE_METHOD(DexFile, setTrusted, &quot;(Ljava/lang/Object;)V&quot;),</span><br><span class="line">  NATIVE_METHOD(DexFile, dumpMethodCode, &quot;(Ljava/lang/Object;)V&quot;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里移植的时候遇到了一个问题，即 ScopedFastNativeObjectAccess 类的头文件名称改变了，后续通过如下方法找到。</p>
<p>在 vscode 搜索类 ScopedFastNativeObjectAccess ，如下图：</p>
<img src="/2020/07/17/%E7%A7%BB%E6%A4%8DFART%E5%88%B0Adnroid-9-0/2020-07-17-09-42-21.png" class="">

<p>随便选择一个使用了该类的文件，查看头文件，最终发现 <code>native/scoped_fast_native_object_access-inl.h</code> 文件中定义了 ScopedFastNativeObjectAccess ，所以我们在自己的文件中添加该头文件即可。</p>
<h1 id="添加-myfartInvoke-方法"><a href="#添加-myfartInvoke-方法" class="headerlink" title="添加 myfartInvoke 方法"></a>添加 myfartInvoke 方法</h1><p>在 <code>art/runtime/art_method.cc</code> 文件中添加 myfartInvoke 相关代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// add start</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &quot;runtime.h&quot;</span><br><span class="line">#include &lt;android/log.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line">#include &lt;stddef.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/uio.h&gt;</span><br><span class="line">#include &lt;sys/un.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &quot;dex/code_item_accessors-inl.h&quot;</span><br><span class="line">#define gettidv1() syscall(__NR_gettid)</span><br><span class="line">#define LOG_TAG &quot;CKCatUnPack&quot;</span><br><span class="line">#define ALOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uint8_t* codeitem_end(const uint8_t** pData)&#123;</span><br><span class="line">  uint32_t num_of_list = DecodeUnsignedLeb128(pData);</span><br><span class="line"></span><br><span class="line">  for (; num_of_list &gt; 0; num_of_list--)&#123;</span><br><span class="line">    int32_t num_of_handlers = DecodeUnsignedLeb128(pData);</span><br><span class="line">    int num = num_of_handlers;</span><br><span class="line">    if (num_of_handlers &lt;= 0)&#123;</span><br><span class="line">      num = -num_of_handlers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (; num &gt; 0; num--)&#123;</span><br><span class="line">      DecodeUnsignedLeb128(pData);</span><br><span class="line">      DecodeUnsignedLeb128(pData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (num_of_handlers &lt;= 0)&#123;</span><br><span class="line">      DecodeUnsignedLeb128(pData);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return (uint8_t*)(*pData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; char* Base64EnCode(char* str, long strLen, long* outLen)&#123;</span><br><span class="line">  long len;</span><br><span class="line">  char* res;</span><br><span class="line">  int i, j;</span><br><span class="line">      const char *base64_table =</span><br><span class="line">        &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;</span><br><span class="line">    if (strLen % 3 == 0)</span><br><span class="line">      len = strLen / 3 * 4;</span><br><span class="line">    else</span><br><span class="line">      len = (strLen / 3 + 1) * 4;</span><br><span class="line"></span><br><span class="line">    res = (char *) malloc(sizeof(char) * (len + 1));</span><br><span class="line">    res[len] = &#x27;\0&#x27;;</span><br><span class="line">    *outLen = len;</span><br><span class="line">    for (i = 0, j = 0; i &lt; len - 2; j += 3, i += 4) &#123;</span><br><span class="line">      res[i] = base64_table[str[j] &gt;&gt; 2];</span><br><span class="line">      res[i + 1] =</span><br><span class="line">          base64_table[(str[j] &amp; 0x3) &lt;&lt; 4 |</span><br><span class="line">           (str[j + 1] &gt;&gt; 4)];</span><br><span class="line">      res[i + 2] =</span><br><span class="line">          base64_table[(str[j + 1] &amp; 0xf) &lt;&lt; 2 |</span><br><span class="line">           (str[j + 2] &gt;&gt; 6)];</span><br><span class="line">      res[i + 3] = base64_table[str[j + 2] &amp; 0x3f];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (strLen % 3) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">      res[i - 2] = &#x27;=&#x27;;</span><br><span class="line">      res[i - 1] = &#x27;=&#x27;;</span><br><span class="line">      break;</span><br><span class="line">    case 2:</span><br><span class="line">      res[i - 1] = &#x27;=&#x27;;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; void dumpDexFileByExecute(ArtMethod* artmethod)</span><br><span class="line">SHARED_LOCKS_REQUIRED(Locks::mutator_lock_)&#123;</span><br><span class="line">  char* dexfilepath = (char*)malloc(sizeof(char) * 2000);</span><br><span class="line">  if (dexfilepath == nullptr)&#123;</span><br><span class="line">      LOG(INFO) &lt;&lt; &quot;ArtMethod::dumpDexFileByExecute,methodname:&quot;</span><br><span class="line">        &lt;&lt; artmethod-&gt;PrettyMethod(false).c_str() &lt;&lt; &quot;malloc 2000 byte failed&quot;;</span><br><span class="line">        return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int fcmdline = -1;</span><br><span class="line">  char szCmdLine[64] = &#123; 0 &#125;;</span><br><span class="line">  char szProcName[256] = &#123; 0 &#125;;</span><br><span class="line">  int pid = getpid();</span><br><span class="line">  sprintf(szCmdLine, &quot;/proc/%d/cmdline&quot;, pid);</span><br><span class="line">  fcmdline = open(szCmdLine, O_RDONLY);</span><br><span class="line">  if(fcmdline &gt; 0)&#123;</span><br><span class="line">    int n = read(fcmdline, szProcName, 256);</span><br><span class="line">    if(n &gt; 0)</span><br><span class="line">      close(fcmdline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (szProcName[0])&#123;</span><br><span class="line">      const DexFile* dexfile = artmethod-&gt;GetDexFile();</span><br><span class="line">      const uint8_t* begin = dexfile-&gt;Begin();</span><br><span class="line">      size_t size = dexfile-&gt;Size();</span><br><span class="line"></span><br><span class="line">      memset(dexfilepath, 0, 2000);</span><br><span class="line">      sprintf(dexfilepath, &quot;%s&quot;, &quot;/sdcard/fart&quot;);</span><br><span class="line">      mkdir(dexfilepath, 0777);</span><br><span class="line"></span><br><span class="line">      memset(dexfilepath, 0, 2000);</span><br><span class="line">      sprintf(dexfilepath, &quot;/sdcard/fart/%s&quot;, szProcName);</span><br><span class="line">      mkdir(dexfilepath, 0777);</span><br><span class="line"></span><br><span class="line">      memset(dexfilepath, 0, 2000);</span><br><span class="line">      sprintf(dexfilepath, &quot;/sdcard/fart/%s/%zu_dexfile_execute.dex&quot;, szProcName, size);</span><br><span class="line">      </span><br><span class="line">      int dexfilefp = open(dexfilepath, O_RDONLY);</span><br><span class="line">      if (dexfilefp &gt; 0)&#123;</span><br><span class="line">        close(dexfilefp);</span><br><span class="line">        dexfilefp = 0;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        dexfilefp = open(dexfilepath, O_CREAT | O_RDWR, 0644);</span><br><span class="line">        if (dexfilefp &gt; 0)&#123;</span><br><span class="line">          int n = write(dexfilefp, (void*)begin, size);</span><br><span class="line">          if(n &gt; 0)</span><br><span class="line">            fsync(dexfilefp);</span><br><span class="line">          close(dexfilefp);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (dexfilepath != nullptr)</span><br><span class="line">  &#123;</span><br><span class="line">    free(dexfilepath);</span><br><span class="line">    dexfilepath = nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; void dumpArtMethod(ArtMethod* artmethod)</span><br><span class="line">SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) &#123;</span><br><span class="line"></span><br><span class="line">  char* dexfilepath = (char*)malloc(sizeof(char) * 2000);</span><br><span class="line">  if (dexfilepath == nullptr)&#123;</span><br><span class="line">    LOG(INFO) &lt;&lt;&quot;ArtMethod::dumpArtMethodinvoked,methodname:&quot;</span><br><span class="line">    &lt;&lt; artmethod-&gt;PrettyMethod(false).c_str() &lt;&lt; &quot;malloc 2000 byte failed&quot;;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int fcmdline = -1;</span><br><span class="line">  char szCmdline[64] = &#123; 0 &#125;;</span><br><span class="line">  char szProcName[256] = &#123; 0 &#125;;</span><br><span class="line">  int pid = getpid();</span><br><span class="line">  sprintf(szCmdline, &quot;/proc/%d/cmdline&quot;, pid);</span><br><span class="line">  fcmdline = open(szCmdline, O_RDONLY);</span><br><span class="line">  if (fcmdline &gt; 0)&#123;</span><br><span class="line">    int n = read(fcmdline, szProcName, 256);</span><br><span class="line">    if(n &gt; 0)</span><br><span class="line">    close(fcmdline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (szProcName[0])&#123;</span><br><span class="line">    const DexFile* dexfile = artmethod-&gt;GetDexFile();</span><br><span class="line">    const char* methodname = artmethod-&gt;PrettyMethod(false).c_str();</span><br><span class="line">    const uint8_t* begin = dexfile-&gt;Begin();</span><br><span class="line">    size_t size = dexfile-&gt;Size();</span><br><span class="line"></span><br><span class="line">    memset(dexfilepath, 0, 2000);</span><br><span class="line">    sprintf(dexfilepath, &quot;%s&quot;, &quot;/sdcard/fart&quot;);</span><br><span class="line">    mkdir(dexfilepath, 0777);</span><br><span class="line"></span><br><span class="line">    memset(dexfilepath, 0, 2000);</span><br><span class="line">    sprintf(dexfilepath, &quot;/sdcard/fart/%s&quot;, szProcName);</span><br><span class="line">    mkdir(dexfilepath, 0777);</span><br><span class="line"></span><br><span class="line">    memset(dexfilepath, 0, 2000);</span><br><span class="line">    sprintf(dexfilepath, &quot;/sdcard/fart/%s/%zu_dexfile_execute.dex&quot;, szProcName, size);</span><br><span class="line">    </span><br><span class="line">    int dexfilefp = open(dexfilepath, O_RDONLY);</span><br><span class="line">    if (dexfilefp &gt; 0) &#123;</span><br><span class="line">      close(dexfilefp);</span><br><span class="line">      dexfilefp = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      dexfilefp = open(dexfilepath, O_CREAT | O_RDWR, 0644);</span><br><span class="line">      if (dexfilefp &gt; 0) &#123;</span><br><span class="line">        int n = write(dexfilefp, (void*)begin, size);</span><br><span class="line">        if(n &gt; 0)</span><br><span class="line">          fsync(dexfilefp);</span><br><span class="line">        close(dexfilefp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const StandardDexFile::CodeItem* code_item = (StandardDexFile::CodeItem*)artmethod-&gt;GetCodeItem();</span><br><span class="line">    if (LIKELY(code_item != nullptr)) &#123;</span><br><span class="line">      int code_item_len = 0;</span><br><span class="line">      uint8_t* item = (uint8_t*)code_item;</span><br><span class="line">      if (code_item-&gt;tries_size_ &gt; 0)&#123;</span><br><span class="line">        CodeItemInstructionAccessor accessor(*dexfile, code_item);</span><br><span class="line">        const uint8_t* handler_data = (const uint8_t*)DexFile::GetTryItems(accessor.end(), code_item-&gt;tries_size_);</span><br><span class="line">        uint8_t *tail = codeitem_end(&amp;handler_data);</span><br><span class="line">        code_item_len = (int)(tail - item);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        code_item_len = 16 + code_item-&gt;insns_size_in_code_units_ * 2;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      memset(dexfilepath, 0, 2000);</span><br><span class="line">      // data 的长度</span><br><span class="line">      int size_int = (int)dexfile-&gt;Size();</span><br><span class="line">      uint32_t method_idx = artmethod-&gt;GetDexMethodIndexUnchecked();</span><br><span class="line">      sprintf(dexfilepath, &quot;/sdcard/fart/%s/%d_%ld.bin&quot;, szProcName, size_int, gettidv1());</span><br><span class="line"></span><br><span class="line">      int fp2 = open(dexfilepath, O_CREAT | O_APPEND | O_RDWR, 0644);</span><br><span class="line">      if (fp2 &gt; 0)&#123;</span><br><span class="line">        lseek(fp2, 0, SEEK_END);</span><br><span class="line">        memset(dexfilepath, 0, 2000);</span><br><span class="line">        int offset = (int)(item - begin);</span><br><span class="line">        sprintf(dexfilepath, &quot;&#123;name:%s,method_idx:%d,offset:%d,code_item_len:%d,ins:&quot;,</span><br><span class="line">          methodname, method_idx, offset, code_item_len);</span><br><span class="line"></span><br><span class="line">        int contentlength = 0;</span><br><span class="line">        while(dexfilepath[contentlength] != 0)</span><br><span class="line">          contentlength++;</span><br><span class="line"></span><br><span class="line">        int n = write(fp2, (void*)dexfilepath, contentlength);</span><br><span class="line">        if(n &gt; 0)</span><br><span class="line">          printf(&quot;&quot;);</span><br><span class="line">        long outlen = 0;</span><br><span class="line">        char* base64result = Base64EnCode((char*)item, (long)code_item_len, &amp;outlen);</span><br><span class="line">        n = write(fp2, base64result, outlen);</span><br><span class="line">        if(n &gt; 0)</span><br><span class="line">        n = write(fp2, &quot;&#125;;&quot;, 2);</span><br><span class="line">        if(n &gt; 0)</span><br><span class="line">        fsync(fp2);</span><br><span class="line">        close(fp2);</span><br><span class="line">        if (base64result != nullptr)&#123;</span><br><span class="line">          free(base64result);</span><br><span class="line">          base64result = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (dexfilepath != nullptr)&#123;</span><br><span class="line">    free(dexfilepath);</span><br><span class="line">    dexfilepath = nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; void myfartInvoke(ArtMethod* artmethod)</span><br><span class="line"> SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) &#123;</span><br><span class="line">  JValue* result = nullptr;</span><br><span class="line">  Thread* self = nullptr;</span><br><span class="line">  uint32_t tmp = 6;</span><br><span class="line">  uint32_t* args = &amp;tmp;</span><br><span class="line">  uint32_t args_size = 6;</span><br><span class="line">  artmethod-&gt;Invoke(self, args, args_size, result, &quot;Fart&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// add end</span><br><span class="line">void ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue* result,</span><br><span class="line">                       const char* shorty) &#123;</span><br><span class="line">  // add start</span><br><span class="line">  if (self == nullptr)&#123;</span><br><span class="line">    dumpArtMethod(this);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // add end</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里需要注意的是 PrettyMethod 方法和 GetTryItems 方法的参数有所改变，需要进行以下修改，可以参考上面关于 ScopedFastNativeObjectAccess 类查找头文件的方式进行修改，这里则关注那两个方法的使用和传参，然后再构造出相应的参数即可。由于这里主要关注的时移植，所以一些细节先这么处理了，后续可以在与阅读相关源码进行进一步处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const StandardDexFile::CodeItem* code_item = (StandardDexFile::CodeItem*)artmethod-&gt;GetCodeItem();</span><br><span class="line">   if (LIKELY(code_item != nullptr)) &#123;</span><br><span class="line">     int code_item_len = 0;</span><br><span class="line">     uint8_t* item = (uint8_t*)code_item;</span><br><span class="line">     if (code_item-&gt;tries_size_ &gt; 0)&#123;</span><br><span class="line">       CodeItemInstructionAccessor accessor(*dexfile, code_item);</span><br><span class="line">       const uint8_t* handler_data = (const uint8_t*)DexFile::GetTryItems(accessor.end(), code_item-&gt;tries_size_);</span><br><span class="line">       uint8_t *tail = codeitem_end(&amp;handler_data);</span><br><span class="line">       code_item_len = (int)(tail - item);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       code_item_len = 16 + code_item-&gt;insns_size_in_code_units_ * 2;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/07/17/%E7%A7%BB%E6%A4%8DFART%E5%88%B0Adnroid-9-0/2020-07-17-09-58-41.png" class="">

<img src="/2020/07/17/%E7%A7%BB%E6%A4%8DFART%E5%88%B0Adnroid-9-0/2020-07-17-09-59-56.png" class="">

<img src="/2020/07/17/%E7%A7%BB%E6%A4%8DFART%E5%88%B0Adnroid-9-0/2020-07-17-10-01-51.png" class="">

<h1 id="执行时-dumpDexFile"><a href="#执行时-dumpDexFile" class="headerlink" title="执行时 dumpDexFile"></a>执行时 dumpDexFile</h1><p>在 <code>/art/runtime/interpreter/interpreter.cc</code> 文件中的 Execute 方法中添加下列代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern &quot;C&quot; void dumpDexFileByExecute(ArtMethod* artmethod);</span><br><span class="line"></span><br><span class="line">static inline JValue Execute(</span><br><span class="line">    Thread* self,</span><br><span class="line">    const CodeItemDataAccessor&amp; accessor,</span><br><span class="line">    ShadowFrame&amp; shadow_frame,</span><br><span class="line">    JValue result_register,</span><br><span class="line">    bool stay_in_interpreter = false) REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line"></span><br><span class="line">  // add start</span><br><span class="line">  if (strstr(shadow_frame.GetMethod()-&gt;PrettyMethod(false).c_str(),&quot;&lt;clinit&gt;&quot;) != nullptr)</span><br><span class="line">  &#123;</span><br><span class="line">    dumpDexFileByExecute(shadow_frame.GetMethod());</span><br><span class="line">  &#125;</span><br><span class="line">  // add end</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，整个 FART 的代码移植完成了，后续有时间再研究一下 libdexfile 相关代码。</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android系统编译</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程师需要了解的网络知识-从铜线到HTTP</title>
    <url>/2023/04/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86-%E4%BB%8E%E9%93%9C%E7%BA%BF%E5%88%B0HTTP/</url>
    <content><![CDATA[<p>本文转自 <a href="https://lvwenhan.com/sort/tech-epic">https://lvwenhan.com/sort/tech-epic</a> 中“软件工程师需要了解的网络知识：从铜线到 HTTP”的一系列文章。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="写作目标"><a href="#写作目标" class="headerlink" title="写作目标"></a>写作目标</h2><p>本文面向中国互联网界众多的“应用软件工程师”，确切地说，面向 web 后端工程师（Java、PHP），web 前端工程师，移动开发工程师（iOS、Android）。本文将从铜线讲起，一路讲到 HTTP，为大家剖析出一个真实的“网络”。</p>
<h2 id="写作由来"><a href="#写作由来" class="headerlink" title="写作由来"></a>写作由来</h2><h3 id="内容来源"><a href="#内容来源" class="headerlink" title="内容来源"></a>内容来源</h3><p>前两天我给一个要跳槽的做 iOS 的哥们儿讲了几个小时的网络，给他的面试铺路，在讲之前，我就意识到了这次的内容如果能够整理一下将会是一套丰富的面向软件工程师的网络教程。</p>
<h3 id="为什么是我"><a href="#为什么是我" class="headerlink" title="为什么是我"></a>为什么是我</h3><p>我装系统起家，从自己搭建网站开始了解 PHP 技术，大学期间通过做外包成了一名 web 全栈，毕业后创业因为招不到满意的 iOS 于是自己动手写 Swift——当时 Swift 刚刚发布半年，基础库匮乏而且还有缺陷，于是我自己造了一堆轮子，其中就有网络库，于是我对 HTTP 有了深入的理解（实际上超级简单没啥好深入的），又搞了 HTTPS pinning，加上我自己做后端和运维，自己申请、购买、部署证书，对 HTTPS 有了一些了解；后来再次创业自己搭建办公室网络，对路由器、交换机、网关、DHCP、DNS 等的概念有了亲身体会，加上我偶尔也会从我买了不看的书堆中找出《图解 HTTP&#x2F;TCP,IP&#x2F;网络硬件》啥的看一看，加上这次讲解的机会，终于融会贯通了。</p>
<h3 id="说说融会贯通"><a href="#说说融会贯通" class="headerlink" title="说说融会贯通"></a>说说融会贯通</h3><p>大学时候我对计算机的理解融会贯通的点在“编译”，最近的融会贯通在于我看了神书《CS:APP》，对计算机系统又有了更深入的理解：硬件和操作系统是密切配合的；当前 x86_64 PC 的性能大部分来自于“缓存” + “乐观” 的概念。以后有机会的话我会写文章分享一下我的理解。</p>
<h2 id="本文约定"><a href="#本文约定" class="headerlink" title="本文约定"></a>本文约定</h2><p>本系列文章中，我们将进行如下几个重要约定：</p>
<p>本文目标是让软件工程师了解网络各层的本质，而不是事无巨细什么都讲<br>有些部分我将会用打比方的形式讲解，目的是让读者更容易理解，而不是每个细节都完全是真实情形<br>如果有我理解的不对的地方欢迎在评论里指出</p>
<h1 id="以太网与交换机"><a href="#以太网与交换机" class="headerlink" title="以太网与交换机"></a>以太网与交换机</h1><h2 id="网络七层、四层模型"><a href="#网络七层、四层模型" class="headerlink" title="网络七层、四层模型"></a>网络七层、四层模型</h2><img src="/2023/04/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86-%E4%BB%8E%E9%93%9C%E7%BA%BF%E5%88%B0HTTP/2023-04-13-17-45-57.png" class="">
<p>四层模型是 TCP&#x2F;IP 技术的实际模型，七层模型是标准化组织制订的理论规范，两者有如上图的对应关系。人们很少用到七层模型，一般常见的地方在负载均衡时：四层负载均衡和七层负载均衡，分别指的是在 TCP 和 HTTP 层面进行负载均衡。</p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><h3 id="历史沿革"><a href="#历史沿革" class="headerlink" title="历史沿革"></a>历史沿革</h3><p>Robert Metcalfe 在施乐帕洛阿尔托研究中心时发表了一篇名为《以太网：局域计算机网络的分布式包交换技术》的文章，随后获得了“具有冲突检测的多点数据通信系统”的专利，并于 1979 年创办了 3COM 公司，对，就是 H3C 的美国母亲。</p>
<h3 id="以太网是什么"><a href="#以太网是什么" class="headerlink" title="以太网是什么"></a>以太网是什么</h3><p>以太网是一系列标准，其显著特点是构造简单，可以多台计算机组成一个网络，虽然 IBM 的令牌环网理论上要比以太网优越，但是以太网胜在简单、便宜。实践证明，真正的计算机网络并不需要令牌环网的高吞吐量优势，而是更低价格更强扩展能力。以太网早期支持不同规格的同轴电缆和双绞线，最终双绞线技术胜出：可以实现更高速率。什么是同轴电缆呢？有线电视网络用的就是同轴电缆，起定义就是字面意思：两根线的轴是同一条线。</p>
<p>本文中我们只讨论最新的八芯双绞线实现的千兆网络，这也是当下最常见的局域网技术。</p>
<h3 id="双绞线是什么"><a href="#双绞线是什么" class="headerlink" title="双绞线是什么"></a>双绞线是什么</h3><p>双绞线也是字面意思：八根铜线两两绞在一起，目的是尽量减少电磁干扰：电磁干扰是阻碍双绞线获得 10G、40G、100G 等更高带宽最大的阻力，当下更高速度的网络一般用光纤技术来实现。</p>
<p>八芯双绞线就是八根铜线绞在一起，双绞线里的铜线和 USB 线里的铜线没有任何区别，都是铜线，只有电导率、粗细、电阻 等基础电气属性的不同。</p>
<h3 id="以太网传递的是什么"><a href="#以太网传递的是什么" class="headerlink" title="以太网传递的是什么"></a>以太网传递的是什么</h3><p>以太网传递的是电信号：一股又一股的电流而已。跟供电铜线不同的是，以太网协议确定了一系列的约定，让一股又一股的电流能够传递信息：0 或者 1。</p>
<h3 id="个简化模型"><a href="#个简化模型" class="headerlink" title="个简化模型"></a>个简化模型</h3><p>六类双绞线实现千兆以太网时的工作频率是 250MHz，即每根铜线中的电流一秒钟都会改变 250 000 000 次，每一次都会携带一个电压：我们假设为 -5V 和 0V，代表 0 和 1，那么只需要四根铜线就能够实现 1Gbps 的单向带宽，另外四根用于实现反向 1Gbps 的带宽。</p>
<p>超五类双绞线实现千兆以太网时只有 125MHz 的频率，它采用一个电压表示两个位的方法来实现千兆网络：即一个电压代表 00 或 01 或 10 或 11。我们假设这四个电压分别是： -5V -3.5V -2V 0V。这样每两根铜线合在一起恰好可以实现 250Mbps 的双向传输（还需要两端设备支持串扰消除技术），八根铜线恰好实现 1Gbps 双向带宽。</p>
<h3 id="一个关于计算机的常识"><a href="#一个关于计算机的常识" class="headerlink" title="一个关于计算机的常识"></a>一个关于计算机的常识</h3><p>计算机内部许多电路的电压都不是标准的，例如主板标准电压为 12V，一般情况下实际电压都会稍高于这个数字。所以才有了各种纠错方法来保证信息传递的正确。</p>
<h4 id="小结论"><a href="#小结论" class="headerlink" title="小结论"></a>小结论</h4><p>超五类双绞线和六类双绞线虽然都能实现千兆网络，但是我们可以看出两者是截然不同的两种技术：六类双绞线由于本身电气性能有很大优势，所以需要的设备更简单，抗干扰能力更强，而超五类可以说是“勉强”实现了千兆网络，抗干扰能力差；如果电压因为电路问题或者受到外部干扰而产生了一些变化，很可能导致数据传输错误导致校验失败而引发重新传输，结果就是实测带宽无法达到千兆。我就遇到过超五类双绞线因为线材受损导致网络连接速度在 1G 和 100M 之间跳跃，最终导致网卡自动关闭的事情。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>全双工千兆以太网，实现的是每秒钟在网线的两个方向分别传递 1G 个的 0 或 1。</p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>交换机是一种十分重要的设备，可以让多台计算机连入同一个局域网。以太网技术胜出的一大原因就是基于交换机技术可以实现低成本和高可靠性的网络扩展：对于早期计算机网络来说，没有什么比低成本地将新的计算机接入网络更激动人心的事情了。</p>
<p>以太网交换机典型的网络拓扑为树状：每一台交换机都可以下接 N 台计算机或交换机。</p>
<p>交换机工作在 OSI 模型的第二层（数据链路层），TCP&#x2F;IP 模型的第一层。</p>
<h3 id="局域网典型拓扑图"><a href="#局域网典型拓扑图" class="headerlink" title="局域网典型拓扑图"></a>局域网典型拓扑图</h3><img src="/2023/04/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86-%E4%BB%8E%E9%93%9C%E7%BA%BF%E5%88%B0HTTP/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B8%E5%9E%8B%E6%8B%93%E6%89%91%E5%9B%BE.png" class="">

<h3 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h3><img src="/2023/04/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86-%E4%BB%8E%E9%93%9C%E7%BA%BF%E5%88%B0HTTP/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7.png" class="">

<h3 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h3><p>物理层中的二进制数据会以上图中的格式进行组织，其基本单元被称为 MAC 帧。</p>
<p>每一台交换机的 MAC 帧 的长度都是一个固定的数值，多台交换机不一定一致<br>目的地址和源地址均为 MAC 地址，典型代表为 AA:BB:CC:DD:EE:FF，共有六段，每一段是一个两位的 16 进制数，十进制表示为 0-255，恰好可以用八位二进制数表示。所以 MAC 地址的长度为 8*6 &#x3D; 48 位。<br>类型字段采用 16 位二进制表示更上一层的网络层数据包的类型：IP、ARP、ICMP 等。<br>在理解网络的任何时候都要用位来表示数据，字节在这里毫无意义，只会干扰我们的大脑。</p>
<h2 id="交换机工作原理"><a href="#交换机工作原理" class="headerlink" title="交换机工作原理"></a>交换机工作原理</h2><p>MAC 帧 中没有 ip 的概念，只有 MAC 地址的概念。</p>
<p>假设局域网中一台 ip 为 192.168.1.2 的电脑（插在交换机接口 1 上）希望打开 192.168.1.3 这台服务器（插在交换机接口 2 上）上的网页，就会发生如下事情：</p>
<ol>
<li>192.168.1.2 向局域网发出一个 ARP 包，询问拥有 192.168.1.3 这个 ip 的计算机的 MAC 地址，假设为 AA:BB:CC:DD:EE:FF</li>
<li>将 TCP 数据包放在 IP 数据包的内部，再将 IP 数据包放在 MAC 帧 内部，通过 1 口将 MAC 帧 发给了交换机</li>
<li>交换机拿到数据后，并不知道 AA:BB:CC:DD:EE:FF 这个 MAC 地址的设备插在自己的哪一个网口上，于是将这个 MAC 帧 发送到所有口上，包括 1 口</li>
<li>2 口回应了，这时交换机就完成了第一次的自学习：AA:BB:CC:DD:EE:FF 这个 MAC 地址的设备插在自己的 2 口上，下次再转发就只发给 2 口就行了</li>
<li>交换机会自己维护一个 MAC 地址 - 物理接口 对应关系的缓存表，并在一定时间内刷新这张表，重新缓存</li>
</ol>
<h3 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h3><p>世界上每一块网卡都有一个全世界唯一的 MAC 地址，由厂商向 IEEE 购买，再预先烧录进芯片里：每个有线网卡、每台路由器、每个无线网卡甚至每个蓝牙芯片都有自己的唯一 MAC 地址。</p>
<h3 id="三层交换机"><a href="#三层交换机" class="headerlink" title="三层交换机"></a>三层交换机</h3><p>现在的网络组建特别是大型网络组建时，三层交换机会有很多应用，其本质是一种拥有部分路由器功能的高级交换机，感兴趣的同学可以自己了解。</p>
<h2 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h2><p>交换机第一次规范了双绞线中传递的 0、1 所代表的含义，这个就叫做“协议”。至此，交换机已经实现了局域网内数据的传递，可以由任意一台设备向任意一台设备传递二进制数据。</p>
<h1 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h1><h2 id="那些首部"><a href="#那些首部" class="headerlink" title="那些首部"></a>那些首部</h2><img src="/2023/04/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86-%E4%BB%8E%E9%93%9C%E7%BA%BF%E5%88%B0HTTP/%E9%82%A3%E4%BA%9B%E9%A6%96%E9%83%A8.png" class="">

<p>一个 HTTP 请求发送到服务器上，需要在头部按顺序加上 TCP 首部、IP 首部、以太网首部，这样才能保证这个 HTTP 请求的二进制数据能够在复杂的网络环境中得到可靠的传输：这三个首部在经过各种网络设备时会被大量修改以实现正确传输：以太网首部在经过交换机时并不会被修改，但是 IP 首部 和 TCP 首部 在经过路由器时会被修改。</p>
<h2 id="TCP-x2F-IP-概述"><a href="#TCP-x2F-IP-概述" class="headerlink" title="TCP&#x2F;IP 概述"></a>TCP&#x2F;IP 概述</h2><p>当我们通过书本、博文等了解 TCP&#x2F;IP 技术时，均将这两者作为两层来讲，似乎他们就是网络标准中的两个不同的虚拟化层级，但事实并没有这么简单。</p>
<h3 id="我的虚拟化观"><a href="#我的虚拟化观" class="headerlink" title="我的虚拟化观"></a>我的虚拟化观</h3><p>当初我学习《计算机组成原理》这本书的时候，我印象最深刻的就是里面对于计算机“虚拟化”的描述：只看计算机的硬件部分，其本质就是多层虚拟化：用逻辑电路、加法电路、积分电路、微分电路等模拟出算数逻辑单元、再和寄存器一起虚拟出运算器和控制器，配合由六个三极管组成一位的 SRAM 虚拟出的 L1、L2、L3 缓存，再配合由电容构成的 DRAM 虚拟出的“线性数组”内存，再由各种总线相互连接，实现了一个可以被操作系统软件控制的基础硬件平台。之后，这个基础硬件平台和操作系统一起虚拟出提供基本计算和逻辑判断服务的 CPU 以及可以被 C 指针读取的一个又一个内存存储单元。</p>
<p>计算机本身就是一层有一层虚拟化的产物，其复杂性远超我们日常生活中的复杂机械设备如汽车。计算机是一个纯粹的“人造”产物，是人类智能的集中体现。计算机从最底层的电路到最上层浏览器中显示出一个字，这背后正是虚拟化思想降低了复杂度，让人脑这个超低内存的计算机能够建造出如此纷繁复杂的计算机大厦。</p>
<h3 id="TCP-x2F-IP-的关系"><a href="#TCP-x2F-IP-的关系" class="headerlink" title="TCP&#x2F;IP 的关系"></a>TCP&#x2F;IP 的关系</h3><p>IP 技术是从 TCP 技术中拆分得来的，如此多层的虚拟化显然不是一开始就这么设计的，人脑是趋利避害的，不会随意提高复杂度。</p>
<p>TCP&#x2F;IP 技术源于美国军方自 1969 年起开始建设的控制点分散的网络系统 ARPAnet。1975 年，ARPAnet 的规模达到一百多台计算机，只靠传统的硬件协议（如以太网协议）已经很难再支撑更大规模的网络了，于是开始研发 TCP&#x2F;IP 技术，并在 1980-1983 年间完成了内部转换。1983 年，支持异构网络的完全架空的 TCP&#x2F;IP 协议正式发布。此处的异构网络指的是 ARPAnet、以太网、令牌环网、光纤网络（如 FDDI 和现在常说的 FTTH）、PPP 网络（如电话拨号 PPPoE）等 OSI 1-2 层的网络。</p>
<p>就在 1983 年，TCP&#x2F;IP 被 Unix 4.2 BSD 系统采用。随着 Unix 的成功，TCP&#x2F;IP 逐步成为 Internet 的标准网络协议，兼容多种物理实现。</p>
<h3 id="TCP-x2F-IP-和以太网"><a href="#TCP-x2F-IP-和以太网" class="headerlink" title="TCP&#x2F;IP 和以太网"></a>TCP&#x2F;IP 和以太网</h3><p>以太网诞生后，提供了一种简单的容易扩展的多台计算机相连接的电信号传输系统，能够一次性传输特定长度的 0、1 信息。以太网和 TCP&#x2F;IP 是独立发展的，以太网是当前最成功的局域网技术，TCP&#x2F;IP 则是整个 Internet 的标准协议：无论是局域网内常用的以太网，还是 FDDI 光纤网络，甚至是 LTE 4G 网络，都支持 TCP&#x2F;IP 协议在其之上运行。从这个角度来看，TCP&#x2F;IP 才是 Internet 的本体。</p>
<p>TCP&#x2F;IP 协议簇是先有实现后有协议的，是从一个已经商用的成熟的网络架构中拆分出来的。</p>
<h3 id="IP-首部"><a href="#IP-首部" class="headerlink" title="IP 首部"></a>IP 首部</h3><p>像以太网帧拥有首部一样，IP 报文也是用首部来描述属性信息的。</p>
<h3 id="详解图"><a href="#详解图" class="headerlink" title="详解图"></a>详解图</h3><p>以下为 ip 首部详解图（IPv4）：</p>
<img src="/2023/04/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86-%E4%BB%8E%E9%93%9C%E7%BA%BF%E5%88%B0HTTP/ip%E9%A6%96%E9%83%A8%E8%AF%A6%E8%A7%A3%E5%9B%BE.png" class="">

<h3 id="简单解释"><a href="#简单解释" class="headerlink" title="简单解释"></a>简单解释</h3><p>上图中每一行表示 32 位二进制数据。拥有 ip 首部特征的数据会被交换机、路由器、电脑网卡等以太网设备当做有效的 IP 报文（也称“IP 数据报”）。</p>
<h3 id="重要数据描述"><a href="#重要数据描述" class="headerlink" title="重要数据描述"></a>重要数据描述</h3><ol>
<li>总长度：界定了本次 ip 报文的长度，便于读取有效数据</li>
<li>源地址：本次 ip 报文是由那个 ip 地址发出的</li>
<li>目的地址：本次 ip 报文需要发给哪一台设备</li>
</ol>
<p>源地址和目的地址均为 32 位（4 个字节）。我们常见的一个 IPv4 地址为：192.168.1.1，IPv4 地址范围为 0.0.0.0 - 255.255.255.255，255 为 2 的 8 次方减一，也就是说用八位二进制可以表示 0-255，四个八位即为 32 位。</p>
<h4 id="小-tip"><a href="#小-tip" class="headerlink" title="小 tip"></a>小 tip</h4><p>1 字节等于八位，字节这个单位的出现是因为一个内存地址对应的数据长度为八位，是一个内存相关概念，在理解网络时我们最好抛弃这个概念，全部使用位。</p>
<h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>ip 层实际上就是规定了一个首部，里面最重要的数据是源 ip 地址和目的 ip 地址。</p>
<h2 id="TCP-首部"><a href="#TCP-首部" class="headerlink" title="TCP 首部"></a>TCP 首部</h2><img src="/2023/04/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86-%E4%BB%8E%E9%93%9C%E7%BA%BF%E5%88%B0HTTP/TCP%E9%A6%96%E9%83%A8.png" class="">

<h3 id="重要数据描述-1"><a href="#重要数据描述-1" class="headerlink" title="重要数据描述"></a>重要数据描述</h3><ol>
<li>TCP 首部中最重要的数据是源端口和目的端口</li>
<li>他们各由 16 位二进制数组成，2^16 &#x3D; 65536，即端口范围为 0-65535</li>
<li>我们可以需要注意到，目的端口号这个重要数据是放在 TCP 首部的，和 IP 首部、以太网帧首部毫无关系</li>
</ol>
<p>TCP 复杂的特性我们下一篇再解读。</p>
<h1 id="TCP-和路由器"><a href="#TCP-和路由器" class="headerlink" title="TCP 和路由器"></a>TCP 和路由器</h1><h2 id="基础梳理"><a href="#基础梳理" class="headerlink" title="基础梳理"></a>基础梳理</h2><ol>
<li>截至目前，我们已经得到了三个首部：以太网首部、IP 首部、TCP 首部。</li>
<li>这三者看起来类似，实际却完全不同：<br>a. 以太网首部是以太网技术提供的基础数据 package 功能：其数据包的长度是以太网独有的，和其他技术如光纤环网 FDDI 是完全不同的。实际上其他技术都不一定用的是 帧 这种基础逻辑单元，也不一定用的是这种简单的交换方式。<br>b. IP 是网络层协议，其存在的意义是规定一种跨物理实现的“虚拟网络”，让这个网络在上层看来是一致的。从这个意义上来讲，IP 层是 Internet 的本体。IP 网络是真正的全球统一的网络。每一台接入网络的计算机都有一个 ip 地址。<br>c. TCP 是传输层协议，其目的是在统一的 IP 层上实现“可靠”的信息传递。</li>
</ol>
<h2 id="可靠的-TCP"><a href="#可靠的-TCP" class="headerlink" title="可靠的 TCP"></a>可靠的 TCP</h2><p>以太网数据帧和 IP 数据包都只是简单地规定了头部应该如何携带信息，而以太网帧并不保证能够送达，也不能保证按照顺序送达，出现了可靠性问题。</p>
<h3 id="一个假设"><a href="#一个假设" class="headerlink" title="一个假设"></a>一个假设</h3><p>假设我们需要从 192.168.1.2 向 192.168.1.3 发送一首歌，这首歌是真正的二进制数据，全部采用 0、1 组成，这样会便于我们理解，因为人脑处理文本信息的时候总是有一种障碍。</p>
<p>在没有 TCP 协议的情况下，我们知道了本机以及目标计算机的 ip 地址，我们将歌曲的二进制信息按照 1500 字节（12000 位）一块，分别包裹上 IP 首部和以太网首部，通过网口将这段 0、1 发送了出去。假设一共 2000 个 以太网帧。接着就会出现下面几种情况：</p>
<ol>
<li>前 1000 个 以太网帧被交换机完美地转发过去了，但是后 1000 个因为交换机受到干扰而没有发到 192.168.1.3 那里，歌曲放到一半就放不出来了。</li>
<li>2000 个都发过去了，但是顺序错乱了：我们会得到一个放不出来的奇怪二进制文件。</li>
<li>2000 个都发过去了，但是部分数据遭到了破坏，0 变成了 1，结果歌曲放一半播放器崩溃了。<br>这时候我们就会发现只靠 IP 协议是无法满足所有通信要求的。</li>
</ol>
<h3 id="如何实现可靠传输？"><a href="#如何实现可靠传输？" class="headerlink" title="如何实现可靠传输？"></a>如何实现可靠传输？</h3><p>TCP 通过校验、序列号机制、确认应答机制、重发控制、连接管理等特性实现了可靠传输。具体的特性不再展开叙述，因为 TCP 实在是太复杂，展开讲还能再写五个本文这么长的系列文章。下面我重点介绍 TCP 实现可靠传输的几个重点功能：</p>
<ol>
<li>TCP 以 段 为基本单位发送数据，段的长度是在首次建立连接的时候双方约定好的。</li>
<li>序列号和确认应答机制：每个段的发送都会携带一个整数序列号：当前段第一位在完整数据中的字节顺序，每次接收到一个段，远程计算机都要回复一个带序列号的“确认收到”。</li>
<li>重发机制：首个段发送的时候使用一个比较大的 timeout 值，之后每次的 timeout 的值都是实时计算的，因为 TCP 希望在网络情况变化时也能够尽可能地提供高性能的传输。timeout 时间过了还没有收到携带本段序列号的“确认收到”，那就重发。<br>TCP 还有基于窗口的发送速度优化、流量控制、拥塞控制等内容不再赘述。</li>
</ol>
<h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><img src="/2023/04/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86-%E4%BB%8E%E9%93%9C%E7%BA%BF%E5%88%B0HTTP/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" class="">
<p>为了建立一个可靠的 TCP 连接，客户端和服务端之间需要进行三次数据发送：</p>
<ul>
<li>客户端：我要建立连接。</li>
<li>服务端：收到。我也要建立连接。</li>
<li>客户端：收到。<br>经历过这三个 IP 包的来往，这个可靠的 TCP 连接才算建立成功了。</li>
</ul>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><img src="/2023/04/13/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86-%E4%BB%8E%E9%93%9C%E7%BA%BF%E5%88%B0HTTP/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" class="">
<p>同上，经过这四次 IP 包的往来，双方都认为这个 TCP 连接已经断开了，相应的内存资源就可以释放了。</p>
<h4 id="为什么握手是三次而挥手是四次？"><a href="#为什么握手是三次而挥手是四次？" class="headerlink" title="为什么握手是三次而挥手是四次？"></a>为什么握手是三次而挥手是四次？</h4><p>原因很简单：TCP 是全双工协议，即可以同时发送和接收数据，两条通道是完全独立的。</p>
<ol>
<li>尝试建立连接时，两者之间什么关系都没有，而“收到。我也要建立连接。”这两个动作是有顺序的，直接用一个 IP 包发送就可以了，节省时间。</li>
<li>尝试断开连接时，“收到。我也要断开连接。”这两个动作之间还有其他事情要发生：客户端这边是不会再发送数据了，但是服务器发给客户端的 IP 包可能还在路上，所以两个方向的 TCP 流是并行的，要单独分别断开连接。</li>
</ol>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>严格意义的路由器是工作在网络层的设备，即 IP 层。但是现代以太网路由器都是 路由器、网关、NAT 服务器、DNS 服务器、DHCP 服务器 的结合体，不少路由器还有防火墙功能。下面我将分开解释这几种功能。</p>
<h3 id="路由器-1"><a href="#路由器-1" class="headerlink" title="路由器"></a>路由器</h3><p>Router 本质是一种“智能”设备，其会为经过它的每一个数据帧寻找一条最佳传输路径，以将该数据最有效地传送到目的站点。Internet 是网状的，而且是动态的，所以路由器是一种非常重要的设备，可以说是它保持了 Internet 的高性能。</p>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>Gateway 是用于两个不同类型的网络之间通信的设备，例如实现两个以太网的相互通信，实现家庭以太网中的所有设备和光纤背后的服务器的通信。在实际场景中，网关将实现一个重要功能：沟通局域网中的设备和公网设备，例如让 192.168.1.2 这台计算机能够从 baidu.com 的服务器下载网页显示到浏览器上。</p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>一台计算机所拥有的 ip 地址和子网掩码配合，让这台计算机认识到了自己的局域网的范围在哪儿。我们采用家用网络中最常见的 192.168.1.2&#x2F;255.255.255.0 的配合来解释它的作用：</p>
<ol>
<li><p>192.168.1.2 是本机的 ip，也是判定某个 ip 是不是局域网 ip 的基础</p>
</li>
<li><p>255.255.255.0 的意思是前三段保持一致，最后一段 0-255 都是局域网 ip</p>
</li>
<li><p>换句话说就是 192.168.1.0 - 192.168.1.255 都是和本机一个局域网的计算机<br>那判断目标 ip 是不是同一个局域网有什么用呢？</p>
</li>
<li><p>如果要连接的是局域网内的 192.168.1.3，那么连接方式将是：</p>
<ol>
<li>发送 ARP 请求得到该 ip 地址对应的 MAC 地址</li>
<li>将数据包上 TCP 首部、IP 首部（目标 ip 地址 192.168.1.3）、以太网首部（目标地址是 192.168.1.3 的 MAC 地址），发送给交换机</li>
<li>交换机会直接将这个包发到目标计算机所在的网口上</li>
</ol>
</li>
<li><p>如果要连接的是 114.114.114.114 这个 ip，那么本机就会将这个包发给网关 192.168.1.1 ：</p>
<ol>
<li>发送 ARP 请求得到网关的 MAC 地址</li>
<li>将数据包上 TCP 首部（目标端口 80，源端口 20000）、IP 首部（目标 ip 地址 114.114.114.114，源 ip 地址 192.168.1.2）、以太网首部（目标地址是 192.168.1.1 的 MAC 地址），发送给交换机</li>
<li>交换机会直接将这个包发到网关所在的网口上</li>
<li>网关收到了这个以太网帧，进行层层解包：<ol>
<li>目标 MAC 地址是自己，说明这个包是合法的</li>
<li>IP 首部中的目标 ip 地址不是自己，说明这是一个需要网关进行转发的数据包，接着进入转发流程：<ol>
<li>TCP 首部中，目标端口 80 不会变，但是源端口 20000 指的是 192.168.1.2 这台计算机的源端口，在网关 192.168.1.1 上这个端口已经被别的局域网机器用过了，该怎么办？修改端口</li>
<li>将 TCP 首部中的源端口改为 50000，将 IP 首部中的源 ip 地址改为本路由器的 WAN 口 ip，即公网 ip，发送出去。我们假设本路由器的公网 ip 为 106.0.0.1。</li>
<li>此时网关设备的内存里已经建立起了一个映射：50000 端口对应的是内网的 192.168.1.2 的 20000 端口，当来自 114.114.114.114 80 端口的 IP 包到达时，同样将目标 ip 地址从 106.0.0.1 改为 192.168.1.2，目标端口 从 50000 改为 20000，发送到局域网交换机上，再由交换机进行以太网帧转发。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="WAN-口、LAN-口"><a href="#WAN-口、LAN-口" class="headerlink" title="WAN 口、LAN 口"></a>WAN 口、LAN 口</h3><p>现代家用路由器一般有一个 WAN 口（广域网端口）和 4-8 个 LAN 口（局域网端口）。有多个 LAN 口本质上是集成了一个交换机。</p>
<h3 id="NAT-服务器"><a href="#NAT-服务器" class="headerlink" title="NAT 服务器"></a>NAT 服务器</h3><p>网络地址转换：将一个公网 ip 直接映射到一个内网 ip 上，当 IP 包经过路由器时，路由器会修改里面的 来源 IP 地址和目的 IP 地址，让双方都以为自己真的是和对方直接连接的。</p>
<h3 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h3><p>IP 网络中每一个网络终端都有一个 ip 地址，但是一串数字十分难记，于是域名便诞生了。路由器充当 DNS 服务器的目的是提升连接速度，节省局域网内设备的 DNS 查询时间。</p>
<h3 id="DHCP-服务器"><a href="#DHCP-服务器" class="headerlink" title="DHCP 服务器"></a>DHCP 服务器</h3><p>提供自动分配 IP 服务，免去手动设置 ip 地址、子网掩码、网关、DNS 服务器的烦恼，让网络实现真正的即开即用。</p>
<h1 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>在以前的文章中，我大力推荐过《图解 HTTP》这本书。这是一本好书，但是 HTTP 协议本身是一个静态协议：跟 HTML 一样是一堆标记的集合，十分简单。</p>
<p>我们首先明确一个简单的事实：TCP 首部后面的部分，依然是一堆二进制数据，但是此时，采用 HTTP 协议解析这堆数据之后，其内容终于可读了。</p>
<h3 id="HTTP-是什么"><a href="#HTTP-是什么" class="headerlink" title="HTTP 是什么"></a>HTTP 是什么</h3><p>HTTP 是 WWW（万维网）拥有的标准协议，用于在客户端和服务器之间传递信息：服务器给客户端传递网页，客户端给服务端传递需要的页面的 URL，上传文件等。</p>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>在讨论 HTTP 协议之前，我们必须首先认识到 HTTP 协议是站在巨人的肩膀上的：</p>
<ol>
<li>HTTP 往下看，是 TCP 协议保证了可靠传输，再往下是 IP 协议保证了 Internet 的大和谐，再往下是以太网协议在局域网内传递信息，再向底层追究，是双绞线中的电压变化将 0、1 一步步向下传递的。</li>
<li>HTTP 协议很简单，但却提供一个体验良好的应用标准，到今天依然生命力旺盛。为什么？因为 TCP&#x2F;IP 协议簇将复杂度消化了。</li>
</ol>
<h3 id="一个普通的-GET-例子"><a href="#一个普通的-GET-例子" class="headerlink" title="一个普通的 GET 例子"></a>一个普通的 GET 例子</h3><p>我们使用 Charles 反向代理软件可以轻易地得到 HTTP 协议的细节。下面我们展示一个普通的 GET 例子。使用浏览器访问 <a href="http://killtyz.com/">http://killtyz.com</a> （自己尝试的时候不要选择 HTTPS 网站）：</p>
<h4 id="请求内容"><a href="#请求内容" class="headerlink" title="请求内容"></a>请求内容</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: killtyz.com</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.119 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ol>
<li>第一行有三个元素：HTTP 方法、uri、HTTP 版本</li>
<li>之后的每一行均以 : 作为间隔符，左边是 key，右边是 value（当然都是在 trim 之后）</li>
<li>HTTP 协议中，换行采用的不是 Linux 系统采用的 \n，而是跟 Windows 一样的 \r\n。</li>
</ol>
<h4 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK Date: Thu, 25 Jan 2018 10:36:10 GMT Server: Apache</span><br><span class="line">Content-Length: 1321 Content-Type: text/html; charset=UTF-8 Proxy-Connection:</span><br><span class="line">Close</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>KillTYZ 干掉拖延症<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">      <span class="attr">href</span>=<span class="string">&quot;http://libs.baidu.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/css/main.css&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://libs.baidu.com/jquery/1.11.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://libs.baidu.com/bootstrap/3.2.0/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/js/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;head&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;logo&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/images/logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;logo&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>干掉拖延症<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">              <span class="attr">id</span>=<span class="string">&quot;add-input&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">placeholder</span>=<span class="string">&quot;添加任务&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">class</span>=<span class="string">&quot;list-group&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foot&quot;</span>&gt;</span></span><br><span class="line">        <span class="symbol">&amp;copy;</span>2018 <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://killtyz.com&quot;</span>&gt;</span>KillTYZ<span class="tag">&lt;/<span class="name">a</span>&gt;</span> |</span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com/johnlui/KillTYZ&quot;</span>&gt;</span>Github Repo<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span> /&gt;</span>Powered by <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://tinylara.com&quot;</span>&gt;</span>TinyLara<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>响应的基本套路和请求一样，第一行的三个元素分别是 协议版本、状态码、状态码的简短解释。需要注意的只有一点：</p>
<h4 id="HTTP-header-和-HTTP-body"><a href="#HTTP-header-和-HTTP-body" class="headerlink" title="HTTP header 和 HTTP body"></a>HTTP header 和 HTTP body</h4><ol>
<li>两个换行即 \r\n\r\n 之前的内容成为 HTTP header</li>
<li>两个换行之后的内容称为 HTTP body</li>
<li>HTTP body 就是你在浏览器查看源代码看到的内容</li>
</ol>
<h3 id="POST-例子"><a href="#POST-例子" class="headerlink" title="POST 例子"></a>POST 例子</h3><p>一下均为 Request 的 HTTP 内容。</p>
<p><code>Content-Type: application/x-www-form-urlencoded</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /api/app HTTP/1.1</span><br><span class="line">Host: killtyz.com</span><br><span class="line">Content-Length: 18</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.119 Safari/537.36</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line"></span><br><span class="line">post=man&amp;key=value</span><br></pre></td></tr></table></figure>

<p><code>Content-Type: multipart/form-data</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /api/app HTTP/1.1</span><br><span class="line">Host: killtyz.com</span><br><span class="line">Content-Length: 5195</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.119 Safari/537.36</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Origin: chrome-extension://fhbjgbiflinjbdggehcddcbncdddomop</span><br><span class="line">Postman-Token: 45479b21-15fa-9232-ab8b-52c7dde8523d</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary1s68Wb5ccTHj384y</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary1s68Wb5ccTHj384y</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;image&quot;</span>; filename=<span class="string">&quot;QQ20141011-2.jpg&quot;</span></span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">***二进制文件内容***</span><br><span class="line">------WebKitFormBoundary1s68Wb5ccTHj384y</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;post&quot;</span></span><br><span class="line"></span><br><span class="line">man</span><br><span class="line">------WebKitFormBoundary1s68Wb5ccTHj384y</span><br><span class="line">Content-Disposition: form-data; name=<span class="string">&quot;oo&quot;</span></span><br><span class="line"></span><br><span class="line">xx</span><br><span class="line">------WebKitFormBoundary1s68Wb5ccTHj384y--</span><br></pre></td></tr></table></figure>

<h4 id="Cookie-相关-Header"><a href="#Cookie-相关-Header" class="headerlink" title="Cookie 相关 Header"></a>Cookie 相关 Header</h4><ol>
<li>Set-Cookie：响应的 HTTP header 中如果有这个字段，那么浏览器会把这个字段的 value 设定到本地的 Cookie 里，配合服务端的 Session 可以实现登录状态临时记录的功能。</li>
<li>Cookie：会出现在请求的 HTTP header 中。Set-Cookie 设置的 Cookie 会有一个作用域名，一般为 <a href="http://www.baidu.com/">www.baidu.com</a> 或者 .baidu.com，在浏览器本地记录的众多 Cookie 中，只要有满足这个作用域名要求的，下一次 HTTP 请求发出的时候会把这些条 Cookie 全部带上。</li>
</ol>
<p>更多详细解释需要的时候可以自己查，都是明码实价，童叟无欺的。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS 这个名字取得不好，让很多人都误解了，以为他是和 HTTP 类似的协议，这是不对的。</p>
<p>HTTPS 全称为 HTTP Over TLS。（SSL&#x2F;TLS 是一系列承前启后的加密协议族，此处统称为 TLS。）</p>
<h3 id="什么是-TLS"><a href="#什么是-TLS" class="headerlink" title="什么是 TLS"></a>什么是 TLS</h3><p>TLS 中文名称为安全传输层协议，其目的是在客户端与服务端之间建立一个 防窃听、防篡改 的可信信息传递通道。</p>
<h3 id="技术细节不再阐述"><a href="#技术细节不再阐述" class="headerlink" title="技术细节不再阐述"></a>技术细节不再阐述</h3><p>TLS 真正的组成非常的复杂，本文不想讨论那些技术细节，更不想讨论客户联和服务端建立连接的繁琐方式，什么先非对称加密再对称加密，一概不讨论；本文只进行概述、阐述特点。</p>
<h4 id="技术特点"><a href="#技术特点" class="headerlink" title="技术特点"></a>技术特点</h4><p>TLS 采用非对称加密和对称加密结合的方式，在客户端和服务器之间建立起一个 防窃听、防篡改 的通信通道。TLS 具有以下特点：</p>
<ol>
<li>基于 TCP 协议，不需要再苦苦解决网络可靠性问题</li>
<li>采用服务端部署证书的形式提供对称加密基础</li>
<li>TLS 连接首次建立的过程十分消耗资源，不仅费 CPU 还非常耗时（和简单不可靠的 HTTP 比）</li>
<li>TLS 没有完美实现 防窃听、防篡改 功能：中间人攻击依然存在相当大的可能性</li>
</ol>
<h3 id="TLS-实现原理"><a href="#TLS-实现原理" class="headerlink" title="TLS 实现原理"></a>TLS 实现原理</h3><p>我从证书的两种签名方式来讲解 TLS 实现原理的简单描述，并分别阐述当前 HTTPS 证书的两大层面的功能。</p>
<h4 id="自签名-TLS-证书"><a href="#自签名-TLS-证书" class="headerlink" title="自签名 TLS 证书"></a>自签名 TLS 证书</h4><p>任何一台安装了 OpenSSL 开源软件的计算机均可以生成 TLS 证书并签名。制造自签名证书分为以下几步：</p>
<ol>
<li>使用 RSA 算法生成私钥。私钥为绝密，由于证书公开，所以拥有私钥的人将实质上拥有证书的所有权。</li>
<li>生成与私钥一对一的根证书，并填入 TLS 证书需要的必要信息（common name 等）。</li>
<li>采用严格配对的 私钥+证书 部署 Apache 或 Nginx。</li>
</ol>
<h4 id="第三方签名的-TLS-证书"><a href="#第三方签名的-TLS-证书" class="headerlink" title="第三方签名的 TLS 证书"></a>第三方签名的 TLS 证书</h4><p>分为以下几步：</p>
<ol>
<li>使用 RSA 算法生成私钥。私钥为绝密，由于证书公开，所以拥有私钥的人将实质上拥有证书的所有权。</li>
<li>生成与私钥一对一的 csr 文件。</li>
<li>将此文件上传到证书颁发商的网站，他们将用他们的 根证书 或者 从根证书派发出的二级证书 为我们的 csr 文件签名，得到 TLS 证书。期间会填入经过他们实际验证的必要信息，如 common name 和公司名称。</li>
<li>采用严格配对的 私钥+证书 部署 Apache 或 Nginx。</li>
</ol>
<h4 id="最重要的一点"><a href="#最重要的一点" class="headerlink" title="最重要的一点"></a>最重要的一点</h4><p>RSA 公钥加密算法从数学上决定了无法从公开的信息（证书）反推出私钥。所以说，只要私钥不泄露，哪怕有人自己写代码强制使用公开的 TLS 证书和他自己伪造的私钥也是不可能的：数学上无法成立，根本就没法和客户端正常交互建立 TLS 连接。</p>
<h4 id="防窃听、防篡改"><a href="#防窃听、防篡改" class="headerlink" title="防窃听、防篡改"></a>防窃听、防篡改</h4><ul>
<li>防窃听：TLS 内部携带的数据就是完整的 HTTP 协议，request 和 response 都会被加密，完全无法破解，除非 RSA 算法被破解。TLS 还会在表面上加上少许 HTTP header，只有极少数必要信息如域名等。所以，就算 Twitter 用了 HTTPS，功夫网还是能够侦测出你在访问 Twitter。</li>
<li>防篡改：TLS 会对每一次数据交互进行严格的校验。HTTP 时代大家饱受运营商劫持的困扰，本质就是对 HTTP 数据的篡改，明文的嘛，正常。TLS 层中的数据被修改一位，这个 TLS 连接就会崩塌，两边瞬间就都知道了。</li>
</ul>
<h4 id="当前-HTTPS-技术的两层功能"><a href="#当前-HTTPS-技术的两层功能" class="headerlink" title="当前 HTTPS 技术的两层功能"></a>当前 HTTPS 技术的两层功能</h4><ol>
<li>加密。无论证书是自签名还是服务商签名，只要证书没有过期，就可以实现加密，保证信息传递的防窃听、防篡改。</li>
<li>可信。全球数十家服务商的根证书是预置在操作系统内部的：iOS、macOS、Windows 都是这样。因为我们的计算机信任根证书，所以才信任由其派生出的二级及三级证书。可信虽然会在 Chrome 上被标红，但却可以“仍然继续”跳过；而证书过期则不行：TLS 连接都无法建立，Chrome 想继续都继续不了呀。</li>
</ol>
<h3 id="TLS-的局限"><a href="#TLS-的局限" class="headerlink" title="TLS 的局限"></a>TLS 的局限</h3><p>TLS 虽然很强大，还是有一些问题。我们先说小问题，再说大问题。</p>
<h4 id="安全要求不完善"><a href="#安全要求不完善" class="headerlink" title="安全要求不完善"></a>安全要求不完善</h4><p>TLS 证书是标准证书，和 HTTP 业务无关，这就导致我们必须采用现成的字段来保存这个证书可以用于那些域名：common name 字段。</p>
<p>我们知道，协议 + 域名 + 端口 组成了一个“域”，域是浏览器中的基本安全单位，用在很多地方。TLS 证书等于说放开了端口这个要求，这样一来一个证书就可以被部署到任意的 N 个端口上。</p>
<h4 id="中间人攻击风险依旧"><a href="#中间人攻击风险依旧" class="headerlink" title="中间人攻击风险依旧"></a>中间人攻击风险依旧</h4><p>中间人攻击指的是中间有一个人伪造是你想连接的那台服务器，窃取你的信息：在咖啡厅开一个假 wifi，就可以通过修改 DNS 的方式假装你的笔记本是百度的服务器，这样就可以获取想要的信息了。TLS 防止的是传输过程中的防窃听、防篡改，无法解决服务端伪造问题。</p>
<p>中间人攻击分为三个方式：</p>
<ol>
<li>HTTP 转 HTTPS。早期网银攻击经常采用这种方式：用户访问网银网站，浏览器默认发出的是 HTTP 请求，本来该网站会将用户跳转到 HTTPS，但是中间人从中作梗：跟客户交流时采用 HTTP，跟银行交流时采用 HTTPS，这样你的银行卡和密码就全暴露了。</li>
<li>合法证书方式。采用特殊手段签出一张合法的证书，正大光明地做中间人。</li>
<li>终端自残式。破坏自己的终端，强制让自己的操作系统信任一张全域名证书：这样任何网络请求都是明文了。所以 HTTPS 防不了 APP 破解者。<br>除非客户端和服务端预先进行信息约定，不然从理论上讲是不可能建立一个完全可信的加密数据通道的。</li>
</ol>
<h4 id="防止中间人攻击的方法"><a href="#防止中间人攻击的方法" class="headerlink" title="防止中间人攻击的方法"></a>防止中间人攻击的方法</h4><p>只有一个：在 APP 中内置证书，每次建立连接时都进行比对。感兴趣的可以到我的网站搜 SSL，我专门阐述了如何设置 SSL pinning（钢钉）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTTP 真的是一种十分简单的协议，HTTPS 只要了解了 TLS 的基本概念也不复杂，复杂度都在 TCP&#x2F;IP 那里被消化了。</p>
<p>可能还会有下一篇，讲讲我对一些关于网络的著名问题及争论的理解。大家有什么想了解的也欢迎留言。</p>
]]></content>
      <categories>
        <category>网络知识</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>天涯kkndme神贴聊房价</title>
    <url>/2020/04/21/%E5%A4%A9%E6%B6%AFkkndme%E7%A5%9E%E8%B4%B4%E8%81%8A%E6%88%BF%E4%BB%B7/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://github.com/shenzhengfang/kkndme_tianya/blob/master/README.md">https://github.com/shenzhengfang/kkndme_tianya/blob/master/README.md</a></p>
</blockquote>
<h1 id="kkndme-tianya（持续更新中…）"><a href="#kkndme-tianya（持续更新中…）" class="headerlink" title="kkndme_tianya（持续更新中…）"></a>kkndme_tianya（持续更新中…）</h1><blockquote>
<p>天涯神贴<a href="http://bbs.tianya.cn/post-house-252774-1.shtml">「2010年的房地产调控，我们收获了什么？写在房价暴涨前」</a>脱水版，内容时间顺序和原贴保持一致，原贴中的优质非楼主写的内容，添加了引用格式便于区分。</p>
<p>「2010年的房地产调控，我们收获了什么？写在房价暴涨前」里面写的内容，相信每一个站在 2019 年的我们看过后都会觉得怎么没有早点看到这个帖子。</p>
<p><strong>欢迎关注微信公众号：沈正方</strong>，我会在我的<strong>个人微信公众号「沈正方」</strong> 里写一些我对这篇帖子内容的思考，欢迎一起讨论。</p>
</blockquote>
<ul>
<li><a href="#%E6%88%BF%E5%9C%B0%E4%BA%A7%E8%B0%83%E6%8E%A7%E8%A1%A8%E9%9D%A2%E4%B8%8A%E7%9C%8B%E8%B5%B7%E6%9D%A5%E7%9A%84%E7%90%86%E7%94%B1%E6%9C%89%E4%B8%89%E6%9D%A1">房地产调控表面上看起来的理由有三条</a><ul>
<li><a href="#1%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%9C%89%E5%B1%85%E4%BD%8F%E6%9D%83">1、人人都有居住权</a></li>
<li><a href="#2%E6%88%BF%E5%AD%90%E6%98%AF%E7%94%A8%E6%9D%A5%E4%BD%8F%E7%9A%84%E4%B8%8D%E6%98%AF%E7%94%A8%E6%9D%A5%E7%82%92%E7%9A%84">2、房子是用来住的，不是用来炒的</a></li>
<li><a href="#3%E6%88%BF%E5%AD%90%E5%A4%AA%E8%B4%B5%E4%BA%86">3、房子太贵了</a><ul>
<li><a href="#%E6%9C%80%E8%A2%AB%E6%8F%90%E5%8F%8A%E4%B8%8E%E6%B3%A1%E6%B2%AB%E6%9C%89%E5%85%B3%E7%9A%84%E6%98%AF%E4%BB%A5%E4%B8%8B%E4%B8%A4%E7%82%B9">最被提及与泡沫有关的是以下两点：</a><ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%88%BF%E4%BB%B7%E7%94%9A%E8%87%B3%E9%AB%98%E4%BA%8E%E6%9F%90%E4%BA%9B%E5%8F%91%E8%BE%BE%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%88%BF%E4%BB%B7">第一：中国的房价甚至高于某些发达国家的房价。</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%A7%9F%E5%94%AE%E6%AF%94%E4%B8%A5%E9%87%8D%E4%B8%8D%E5%90%88%E7%90%86%E7%A9%BA%E7%BD%AE%E7%8E%87%E5%A4%AA%E9%AB%98%E4%BA%BA%E5%9D%87%E6%94%B6%E5%85%A5%E5%A4%AA%E4%BD%8E%E6%97%A9%E6%99%9A%E8%A6%81%E5%B4%A9%E7%9B%98">第二：租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4%E6%88%BF%E4%BB%B7%E4%B8%8A%E6%B6%A8%E9%80%A0%E6%88%90%E7%89%A9%E4%BB%B7%E4%B8%8A%E6%B6%A8%E4%BA%BA%E6%B0%91%E7%94%9F%E6%B4%BB%E5%8F%98%E5%BE%97%E5%9B%B0%E9%9A%BE">4、房价上涨造成物价上涨，人民生活变得困难</a></li>
</ul>
</li>
<li><a href="#%E6%88%BF%E5%9C%B0%E4%BA%A7%E8%B0%83%E6%8E%A7%E7%9A%84%E7%9C%9F%E6%AD%A3%E6%84%8F%E5%9B%BE%E9%80%9A%E8%BF%87%E5%9E%84%E6%96%AD%E8%8E%B7%E5%8F%96%E5%88%A9%E7%9B%8A%E6%9C%80%E5%A4%A7%E5%8C%96%E5%9B%BD%E5%AF%8C%E6%B0%91%E7%A9%B7">房地产调控的真正意图（通过垄断获取利益最大化：国富民穷）</a></li>
<li><a href="#%E8%AF%B4%E5%88%B0%E6%88%BF%E4%BA%A7%E6%B3%A1%E6%B2%AB%E7%9A%84%E9%97%AE%E9%A2%98">说到房产泡沫的问题</a><ul>
<li><a href="#1%E5%85%88%E8%AF%B4%E8%AF%B4%E5%AE%98%E6%96%B9%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%B1%E6%98%8E">1、先说说官方的统计数据。(选择性失明)</a></li>
</ul>
</li>
<li><a href="#%E6%88%BF%E5%9C%B0%E4%BA%A7%E8%B0%83%E6%8E%A7%E5%B7%A5%E5%85%B7%E6%88%BF%E4%BA%A7%E7%A8%8E">房地产调控工具：房产税？</a></li>
<li><a href="#%E5%9E%84%E6%96%AD%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E7%A4%BE%E4%BC%9A%E7%A8%B3%E5%AE%9A">垄断还可以解决一个问题：社会稳定。</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%9E%84%E6%96%AD%E6%88%BF%E5%B1%8B%E6%88%BF%E7%A7%9F">如何垄断房屋、房租？</a></li>
<li><a href="#%E5%9B%BD%E5%AE%B6%E5%9E%84%E6%96%AD%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D">国家垄断带来的影响</a></li>
<li><a href="#%E5%85%AC%E7%A7%9F%E6%88%BF%E9%97%AE%E9%A2%98">公租房问题</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BB%BA%E5%85%AC%E7%A7%9F%E6%88%BF%E7%9A%84%E9%92%B1%E4%BB%8E%E5%93%AA%E5%84%BF%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98">如何解决建公租房的钱从哪儿来的问题？</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E5%BE%81%E7%A8%8E%E8%B0%83%E8%8A%82%E8%B4%AB%E5%AF%8C%E5%B7%AE%E8%B7%9D%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%E5%9B%A0%E4%B8%BA%E5%AF%8C%E7%9A%84%E4%BA%BA%E8%B4%9F%E8%B4%A3%E5%88%B6%E5%AE%9A%E6%94%BF%E7%AD%96%E5%AF%8C%E7%9A%84%E4%BA%BA%E4%B8%8D%E4%BC%9A%E8%AE%A9%E6%94%BF%E7%AD%96%E9%92%88%E5%AF%B9%E8%87%AA%E5%B7%B1">通过征税调节贫富差距是耍流氓（因为富的人负责制定政策，富的人不会让政策针对自己）</a></li>
<li><a href="#%E6%88%BF%E4%BB%B7%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%B6%A8">房价什么时候会涨</a></li>
<li><a href="#%E4%B8%BA%E4%BA%BA%E6%B0%91%E6%9C%8D%E5%8A%A1%E5%B0%B1%E6%98%AF%E7%9E%8E%E6%8E%B0">为人民服务就是瞎掰</a></li>
<li><a href="#%E6%88%BF%E7%A7%9F%E9%97%AE%E9%A2%98">房租问题</a></li>
<li><a href="#%E7%B2%AE%E9%A3%9F%E9%97%AE%E9%A2%98">粮食问题</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%82%BB%E7%A9%BA">什么是傻空？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9C%9F%E4%B9%B0%E4%B8%8D%E8%B5%B7%E6%88%BF">什么是真买不起房？</a></li>
<li><a href="#%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98%E8%A6%81%E6%B7%B1%E5%85%A5">分析问题要深入</a></li>
<li><a href="#%E4%BB%8E%E8%B4%B5%E9%98%B3%E7%9A%84%E7%8E%B0%E7%8A%B6%E7%9C%8B%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%9C%AA%E6%9D%A5">从贵阳的现状看中国的未来</a></li>
<li><a href="#%E8%B4%A7%E5%B8%81%E8%B4%AC%E5%80%BC">货币贬值</a></li>
<li><a href="#%E6%88%BF%E4%BB%B7%E5%8F%AF%E8%83%BD%E7%9A%84%E4%B8%8B%E8%B7%8C%E6%96%B9%E5%BC%8F">房价可能的下跌方式</a></li>
<li><a href="#%E6%88%BF%E4%BA%A7%E6%8A%95%E8%B5%84%E7%9A%84%E9%97%AE%E9%A2%98">房产投资的问题</a></li>
<li><a href="#%E4%B9%B0%E6%88%BF%E6%97%B6%E6%9C%BA">买房时机</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E8%B0%83%E6%8E%A7">关于调控</a></li>
<li><a href="#%E6%99%AE%E9%80%9A%E4%BA%BA%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E">普通人该怎么办？</a></li>
<li><a href="#%E4%BD%93%E5%88%B6%E5%A4%96%E4%BA%BA%E5%91%98%E5%85%BB%E8%80%81%E7%A1%AE%E5%AE%9E%E6%98%AF%E4%B8%AA%E9%97%AE%E9%A2%98">体制外人员养老确实是个问题</a></li>
<li><a href="#%E6%87%82%E6%94%BF%E7%AD%96%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">懂政策的重要性</a></li>
<li><a href="#%E5%AD%98%E9%92%B1%E4%B8%8D%E5%A6%82%E5%AD%98%E6%88%BF%E5%AD%90%E5%AD%98%E6%9C%A8%E5%A4%B4%E5%AD%98%E6%A0%91">存钱不如存房子、存木头、存树</a></li>
<li><a href="#%E6%94%BF%E5%BA%9C%E4%B8%8D%E8%80%83%E8%99%91%E6%B0%91%E7%94%9F">政府不考虑民生</a></li>
<li><a href="#%E5%86%8D%E8%B0%88%E4%B9%B0%E6%88%BF%E6%97%B6%E6%9C%BA">再谈买房时机</a></li>
<li><a href="#%E5%88%A9%E7%9B%8A%E6%89%8D%E6%98%AFzf%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%8C%87%E6%8C%A5%E6%A3%92">利益才是zf行为的指挥棒</a></li>
<li><a href="#%E4%B9%B0%E6%88%BF%E5%BA%94%E8%AF%A5%E5%85%B3%E6%B3%A8%E4%BB%80%E4%B9%88">买房应该关注什么？</a></li>
<li><a href="#%E6%B5%81%E6%B0%93%E6%97%A0%E4%BA%A7%E8%80%85">流氓无产者</a></li>
<li><a href="#%E6%94%BF%E5%BA%9C%E8%B0%83%E6%8E%A7%E7%9A%84%E7%9B%AE%E7%9A%84%E4%B8%8E%E5%90%AF%E7%A4%BA">政府调控的目的与启示</a></li>
<li><a href="#%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%99%BA%E6%85%A7%E5%92%8C%E6%89%8D%E5%B9%B2%E5%86%B3%E5%AE%9A%E4%BA%86%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%91%BD%E8%BF%90">个人的智慧和才干决定了个人的命运</a></li>
<li><a href="#%E9%87%91%E9%92%B1%E8%87%B3%E4%B8%8A">金钱至上</a></li>
<li><a href="#%E4%BE%9B%E6%B1%82%E5%85%B3%E7%B3%BB">供求关系</a></li>
<li><a href="#%E6%8B%86%E8%BF%81%E8%A1%A5%E5%81%BF">拆迁补偿</a></li>
<li><a href="#%E6%89%A7%E6%94%BF%E8%80%85%E5%A6%82%E4%BD%95%E6%B2%BB%E5%9B%BD">执政者如何治国</a></li>
<li><a href="#10-%E5%B9%B4%E6%88%BF%E5%9C%B0%E4%BA%A7%E8%B0%83%E6%8E%A7">10 年房地产调控</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E6%88%BF%E8%B4%B7">关于房贷</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E5%95%86%E9%93%BA%E6%8A%95%E8%B5%84">关于商铺投资</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E6%88%BF%E4%BA%A7%E7%A8%8E">关于房产税</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E6%8B%86%E8%BF%81">关于拆迁</a></li>
<li><a href="#%E4%B9%B0%E6%88%BF%E5%92%8C%E4%B8%8D%E4%B9%B0%E6%88%BF%E7%9A%84%E5%B7%AE%E8%B7%9D">买房和不买房的差距</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%B0%E5%9C%A8%E7%A7%9F%E5%94%AE%E6%AF%94%E8%BF%99%E4%B9%88%E4%BD%8E">为什么现在租售比这么低？</a></li>
<li><a href="#%E6%88%BF%E4%BA%A7%E4%BA%A4%E6%98%93%E5%8E%86%E5%8F%B2">房产交易历史</a></li>
<li><a href="#%E5%A5%91%E7%A8%8E%E7%9A%84%E5%8E%86%E5%8F%B2">契税的历史</a></li>
<li><a href="#%E5%BB%89%E7%A7%9F%E6%88%BF%E7%9A%84%E5%8E%86%E5%8F%B2">廉租房的历史</a></li>
<li><a href="#%E5%8E%86%E5%8F%B2%E4%B8%8A%E4%B9%B0%E6%88%BF%E6%9C%80%E5%A5%BD%E7%9A%84%E6%9C%9D%E4%BB%A3">历史上买房最好的朝代</a></li>
<li><a href="#%E6%9C%AA%E6%9D%A5%E6%88%BF%E5%9C%B0%E4%BA%A7%E5%B8%82%E5%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95">未来房地产市场的发展</a></li>
<li><a href="#%E6%88%BF%E4%BA%A7%E5%88%B0%E6%9C%9F">房产到期</a></li>
<li><a href="#%E4%B9%B0%E5%AD%A6%E5%8C%BA%E6%88%BF%E9%97%AE%E9%A2%98">买学区房问题</a></li>
<li><a href="#%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5">人口普查</a></li>
<li><a href="#%E6%98%86%E5%B1%B1">昆山</a></li>
<li><a href="#%E4%B9%B0%E6%88%BF%E4%BA%89%E5%8F%96%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D">买房争取一步到位</a></li>
<li><a href="#%E6%94%B6%E5%85%A5%E7%A8%B3%E5%AE%9A%E7%9A%84%E5%AE%B6%E5%BA%AD%E5%A6%82%E4%BD%95%E4%B9%B0%E6%88%BF">收入稳定的家庭如何买房</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%BA%E5%8F%A3%E7%BA%A2%E5%88%A9%E6%B6%88%E5%A4%B1%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%88%BF%E5%AD%90%E8%BF%98%E7%9C%8B%E6%B6%A8">为什么人口红利消失，未来的房子还看涨</a></li>
<li><a href="#%E6%84%8F%E5%A4%A7%E5%88%A9%E7%9A%84%E4%BD%8F%E6%88%BF%E6%A8%A1%E5%BC%8F">意大利的住房模式</a></li>
<li><a href="#%E4%B8%AD%E5%9B%BD%E7%9A%84%E5%AD%A6%E6%9C%AF">中国的学术</a></li>
<li><a href="#%E7%B2%BE%E8%8B%B1%E7%9A%84%E8%B4%A2%E4%BA%A7">精英的财产</a></li>
<li><a href="#%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%96%B0%E9%97%BB%E4%B8%8D%E5%8F%AF%E4%BF%A1">中国的新闻不可信</a></li>
<li><a href="#%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80%E5%92%8C%E6%88%BF%E4%BB%B7%E7%9A%84%E5%85%B3%E7%B3%BB">通货膨胀和房价的关系</a></li>
<li><a href="#%E8%87%AA%E4%BD%8F%E4%B9%B0%E6%88%BF">自住买房</a></li>
<li><a href="#%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%9C%9D%E4%BB%A3%E6%9B%B4%E6%9B%BF">中国的朝代更替</a></li>
<li><a href="#%E8%81%8A%E8%81%8A%E4%BF%84%E7%BD%97%E6%96%AF">聊聊俄罗斯</a></li>
<li><a href="#%E6%AF%9B%E5%A4%AA%E9%98%B3%E7%9A%84%E5%BE%80%E4%BA%8B">毛太阳的往事</a></li>
<li><a href="#%E5%AF%8C%E4%BA%BA%E8%B6%8A%E5%AF%8C%E7%A9%B7%E4%BA%BA%E8%B6%8A%E7%A9%B7">富人越富、穷人越穷</a></li>
<li><a href="#%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80%E7%9A%84%E5%BD%A2%E6%88%90%E5%8E%9F%E5%9B%A0">通货膨胀的形成原因</a></li>
<li><a href="#%E6%9C%89%E5%A4%96%E6%9D%A5%E4%BA%BA%E5%8F%A3%E5%92%8C%E6%B2%A1%E6%9C%89%E5%A4%96%E6%9D%A5%E4%BA%BA%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB">有外来人口和没有外来人口的区别</a></li>
<li><a href="#%E9%A6%96%E4%BB%98%E6%8F%90%E9%AB%98%E7%9A%84%E9%80%BB%E8%BE%91">首付提高的逻辑</a></li>
<li><a href="#%E6%94%BF%E5%BA%9C%E6%90%AC%E8%BF%81">政府搬迁</a></li>
<li><a href="#kkndme%E8%81%8A%E5%8C%97%E5%AE%8B%E5%94%90%E6%9C%9D">kkndme聊北宋、唐朝</a></li>
<li><a href="#%E7%8E%8B%E5%AE%89%E7%9F%B3%E7%9A%84%E9%9D%92%E8%8B%97%E6%B3%95%E4%B9%8B%E5%9B%BD%E5%AE%B6%E5%87%BA%E6%94%BF%E7%AD%96%E7%9A%84%E5%8A%A8%E6%9C%BA">王安石的青苗法之国家出政策的动机</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A4%BE%E4%BC%9A%E5%85%AC%E5%B9%B3">什么是社会公平</a></li>
<li><a href="#%E8%BF%98%E6%98%AF%E6%9C%89%E5%BE%88%E5%A4%9A%E6%9C%89%E9%92%B1%E4%BA%BA">还是有很多有钱人</a></li>
<li><a href="#%E5%8F%8C%E8%BD%A8%E5%88%B6%E4%B9%8B%E4%BD%93%E5%88%B6%E5%86%85%E7%9A%84%E7%A6%8F%E5%88%A9">双轨制之体制内的福利</a></li>
<li><a href="#%E5%BC%80%E5%8F%91%E5%95%86%E6%80%9D%E7%BB%B4">开发商思维</a></li>
<li><a href="#%E5%86%9C%E6%B0%91%E6%94%BF%E6%9D%83%E7%9A%84%E7%BC%BA%E7%82%B9">农民政权的缺点</a></li>
<li><a href="#%E9%83%91%E5%B7%9E%E6%9C%89%E5%89%8D%E6%99%AF">郑州有前景</a></li>
<li><a href="#%E5%85%AC%E5%9B%AD%E5%9C%B0%E4%BA%A7%E6%98%AF%E7%A8%80%E7%BC%BA%E8%B5%84%E6%BA%90">公园地产是稀缺资源</a></li>
<li><a href="#%E5%BC%A0%E7%8C%AE%E5%BF%A0%E5%B1%A0%E5%B7%9D">张献忠屠川</a></li>
<li><a href="#%E6%B4%AA%E7%A7%80%E5%85%A8%E9%BB%84%E5%B7%A2%E6%9D%8E%E8%87%AA%E6%88%90">洪秀全、黄巢、李自成</a></li>
<li><a href="#%E6%9C%B1%E5%85%83%E7%92%8B">朱元璋</a></li>
<li><a href="#%E6%9B%B9%E5%8F%82%E6%B2%BB%E5%9B%BD">曹参治国</a></li>
<li><a href="#%E6%99%81%E9%94%99">晁错</a></li>
<li><a href="#%E6%B0%91%E8%90%A5%E5%B0%8F%E4%BC%81%E4%B8%9A%E7%9A%84%E8%80%81%E6%9D%BF%E5%92%8C%E6%89%93%E5%B7%A5%E8%80%85">民营小企业的老板和打工者</a></li>
<li><a href="#%E9%83%AD%E8%A7%A3">郭解</a></li>
<li><a href="#2010%E5%B9%B4%E7%9A%84%E4%B8%AD%E5%9B%BD%E6%88%BF%E5%9C%B0%E4%BA%A7">2010年的中国房地产</a></li>
<li><a href="#%E7%B2%BE%E8%8B%B1%E4%BA%BA%E7%BE%A4%E7%9A%84%E5%B9%B3%E5%9D%87%E6%94%B6%E5%85%A5%E5%86%B3%E5%AE%9A%E6%88%BF%E4%BB%B7">精英人群的平均收入决定房价</a></li>
<li><a href="#%E5%86%85%E5%9C%B0%E4%B8%8D%E6%98%AF%E9%A6%99%E6%B8%AF%E6%B5%B7%E5%8D%97">内地不是香港、海南</a></li>
<li><a href="#%E5%8E%86%E5%8F%B2%E6%98%AF%E4%B8%80%E9%9D%A2%E9%95%9C%E5%AD%90">历史是一面镜子</a></li>
<li><a href="#%E4%B9%B0%E6%88%BF%E4%B8%80%E6%AC%A1%E6%80%A7%E5%88%B0%E4%BD%8D%E6%AF%94%E8%BE%83%E5%A5%BD">买房一次性到位比较好</a></li>
<li><a href="#%E5%A4%96%E6%B1%87%E7%AE%A1%E5%88%B6">外汇管制</a></li>
<li><a href="#%E4%B8%80%E7%BA%BF%E5%92%8C%E4%BA%8C%E7%BA%BF">一线和二线</a></li>
<li><a href="#%E5%90%95%E5%90%8E%E7%AF%A1%E6%9D%83">吕后篡权</a></li>
<li><a href="#%E5%B0%8F%E4%BA%A7%E6%9D%83%E6%88%BF">小产权房</a></li>
<li><a href="#%E5%95%86%E9%93%BA%E5%92%8C%E4%BD%8F%E5%AE%85">商铺和住宅</a></li>
<li><a href="#%E4%BD%93%E5%88%B6%E5%86%85%E5%A4%96">体制内外</a></li>
<li><a href="#2010%E5%B9%B4%E7%9A%84%E4%B8%8A%E6%B5%B7">2010年的上海</a></li>
<li><a href="#%E4%B9%B0%E6%88%BF%E7%89%A9%E4%B8%9A%E4%B8%8E%E6%88%BF%E8%B4%B7">买房：物业与房贷</a></li>
<li><a href="#%E6%94%B6%E7%B4%A7%E4%BD%8F%E6%88%BF%E8%B4%B7%E6%AC%BE">收紧住房贷款</a></li>
<li><a href="#%E5%A5%B8%E8%87%A3%E8%94%A1%E4%BA%AC">奸臣蔡京</a></li>
<li><a href="#%E4%BD%93%E5%88%B6%E5%86%85%E7%9A%8428%E5%8E%9F%E5%88%99">体制内的28原则</a></li>
<li><a href="#%E8%B4%BE%E8%B0%8A">贾谊</a></li>
<li><a href="#kkndme-%E6%8E%A8%E8%8D%90%E7%9A%84%E5%8E%86%E5%8F%B2%E4%B9%A6">kkndme 推荐的历史书</a></li>
<li><a href="#%E5%B9%B4%E8%BD%BB%E4%BA%BA%E8%A6%81%E6%97%A9%E4%B9%B0%E6%88%BF">年轻人要早买房</a></li>
<li><a href="#%E4%B8%8D%E8%A6%81%E4%BD%8E%E4%BC%B0%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80">不要低估通货膨胀</a></li>
<li><a href="#%E4%BA%8C%E4%B8%89%E7%BA%BF%E5%9F%8E%E5%B8%82%E4%B8%8E%E9%87%8D%E5%BA%86">二三线城市与重庆</a></li>
<li><a href="#%E5%9F%8E%E5%8C%BA%E5%92%8C%E9%83%8A%E5%8C%BA">城区和郊区</a></li>
<li><a href="#%E5%AE%88%E7%9D%80%E9%87%91%E7%A2%97%E8%A6%81%E9%A5%AD%E5%90%83">守着金碗要饭吃</a></li>
<li><a href="#%E4%BA%BA%E5%88%B6%E7%9A%84%E7%A4%BE%E4%BC%9A%E4%BA%BA%E5%B0%B1%E6%98%AF%E5%88%B6%E5%BA%A6">人制的社会，人就是制度</a></li>
<li><a href="#%E5%87%86%E5%85%AC%E5%8A%A1%E5%91%98%E7%9A%84%E5%A5%BD%E5%A4%84">准公务员的好处</a></li>
<li><a href="#%E4%BA%8C%E4%B8%89%E7%BA%BF%E5%9F%8E%E5%B8%82%E7%9A%84%E5%8F%91%E5%B1%95%E9%9D%A0%E6%8B%86%E8%BF%81">二三线城市的发展靠拆迁</a></li>
<li><a href="#%E4%B8%80%E4%B8%AA%E5%BF%BD%E6%82%A0%E4%BA%86%E5%87%A0%E4%BA%BF%E4%B8%AD%E5%9B%BD%E4%BA%BA%E7%9A%84%E4%BC%AA%E6%A6%82%E5%BF%B5%E6%89%80%E8%B0%93%E4%B8%AD%E5%9B%BD%E6%88%BF%E5%9C%B0%E4%BA%A7%E6%B3%A1%E6%B2%AB">一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”</a></li>
<li><a href="#%E6%8B%86%E8%BF%81%E8%A1%A5%E5%81%BF">拆迁补偿</a></li>
<li><a href="#%E5%9F%8E%E5%B8%82%E5%BA%95%E5%B1%82">城市底层</a></li>
<li><a href="#%E5%9E%84%E6%96%AD%E4%BC%81%E4%B8%9A">垄断企业</a></li>
<li><a href="#%E5%86%9C%E6%9D%91%E8%87%AA%E6%9D%A5%E6%B0%B4">农村自来水</a></li>
<li><a href="#%E8%A2%81%E7%9B%8E">袁盎</a></li>
<li><a href="#%E4%BA%8C%E4%B8%89%E7%BA%BF%E5%9F%8E%E5%B8%82%E9%80%89%E6%96%B0%E5%9F%8E%E8%BF%98%E6%98%AF%E8%80%81%E5%9F%8E">二三线城市，选新城还是老城</a></li>
<li><a href="#%E5%9C%A8%E4%B8%AD%E5%9B%BD%E6%99%AE%E9%80%9A%E4%BA%BA%E6%89%8B%E4%B8%8A%E9%97%B2%E9%92%B1%E4%B8%8D%E5%A4%9A%E7%9A%84%E4%BA%BA%E8%A2%AB%E5%89%A5%E5%89%8A">在中国，普通人手上闲钱不多的人被剥削</a></li>
<li><a href="#%E4%B8%89%E5%88%86%E5%A4%A9%E6%B3%A8%E5%AE%9A%E4%B8%83%E5%88%86%E9%9D%A0%E6%89%93%E6%8B%BC">三分天注定七分靠打拼</a></li>
<li><a href="#%E4%BA%BA%E7%9A%84%E5%89%8D%E7%A8%8B%E6%9C%89%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8D%E6%8E%8C%E6%8F%A1%E5%9C%A8%E8%87%AA%E5%B7%B1%E6%89%8B%E9%87%8C">人的前程有的时候不掌握在自己手里</a></li>
<li><a href="#%E6%B2%B3%E5%8D%97%E9%83%91%E5%B7%9E-%E4%B8%8E-%E6%B4%9B%E9%98%B3">河南郑州 与 洛阳</a></li>
<li><a href="#%E6%9D%AD%E5%B7%9E">杭州</a></li>
<li><a href="#%E8%A5%BF%E5%AE%89-%E4%B8%8E-%E9%87%8D%E5%BA%86">西安 与 重庆</a></li>
<li><a href="#%E8%B0%A2%E5%9B%BD%E4%B8%AD%E7%A9%BA%E7%BD%AE%E7%8E%87">谢国中「空置率」</a></li>
<li><a href="#%E6%89%93%E5%B7%A5%E4%B8%8D%E5%A6%82%E6%9C%89%E4%B8%80%E6%8A%80%E4%B9%8B%E9%95%BF%E7%9A%84%E5%B0%8F%E8%80%81%E6%9D%BF">打工不如有一技之长的小老板</a></li>
<li><a href="#%E4%B8%80%E7%BA%BF%E3%80%81%E4%BA%8C%E7%BA%BF%E7%9A%84%E7%94%9F%E6%B4%BB">一线、二线的生活</a></li>
<li><a href="#%E6%88%BF%E5%AD%90%E4%B8%8D%E5%B1%9E%E4%BA%8E%E5%B8%82%E5%9C%BA%E7%BB%8F%E6%B5%8E%EF%BC%88%E9%98%B4%E8%B0%8B%E8%AE%BA%E7%9A%84%E8%A7%92%E5%BA%A6%EF%BC%89">房子不属于市场经济（阴谋论的角度）</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%BD%E7%9A%84%E6%94%BF%E7%AD%96">什么是好的政策</a></li>
</ul>
<h2 id="房地产调控表面上看起来的理由有三条："><a href="#房地产调控表面上看起来的理由有三条：" class="headerlink" title="房地产调控表面上看起来的理由有三条："></a>房地产调控表面上看起来的理由有三条：</h2><ul>
<li>1）人人都有居住权。</li>
<li>2）房子是用来住的，不是用来炒的。</li>
<li>3）房子太贵了<ul>
<li>1）租售比严重不合理</li>
<li>2）空置率太高</li>
<li>3）人均收入太低，早晚要崩盘。</li>
<li>4）房价上涨造成物价上涨，人民生活变得困难。</li>
</ul>
</li>
</ul>
<h3 id="1、人人都有居住权"><a href="#1、人人都有居住权" class="headerlink" title="1、人人都有居住权"></a>1、人人都有居住权</h3><p>任志强说的并没有错，居者有其屋并不等于人人享有商品房的产权。居住的房屋也不等于商品房。</p>
<blockquote>
<p>liougehooa</p>
<p>任志强这句话绝对没说炒房价，房子在他眼里还是住的。<br>难道你用byt是你老er比较稀缺才买？那也没看见byt暴涨到5W一个。<br>”而土地所具备稀缺性？“任志强也说了，拿出全国耕地的1%也够老百姓住了！现在是啥科技了，舍掉1%耕地对农作物有什么影响？</p>
<p>kkndme:</p>
<p>华北平原从河北到山东有大片的盐碱地，你都可以用于盖房，而且会非常便宜，也没有人跟你竞价。但是你在那里盖了房子并不能保证你天天按时在北京城区上班。</p>
</blockquote>
<blockquote>
<p><strong>bryanshen:</strong></p>
<p>人人都有居住权不等于人人都拥有一套商品房，人人都有居住权等于人人都可以有房子住，这个房子可以是买商品房，也可以租政府建的公租房、廉租房。</p>
</blockquote>
<h3 id="2、房子是用来住的，不是用来炒的"><a href="#2、房子是用来住的，不是用来炒的" class="headerlink" title="2、房子是用来住的，不是用来炒的"></a>2、房子是用来住的，不是用来炒的</h3><p>房子包括房屋及房屋所属的土地两个部分。</p>
<p>房屋本身只有居住价值；而土地所具备稀缺性，决定了土地的投资价值。</p>
<p>房地产贵的不是房屋，而是房屋下面那块地皮。所以商品房具备了投资与自住双重属性。</p>
<blockquote>
<p><strong>bryanshen:</strong></p>
<p>房子是用来住的，不是用来炒的？</p>
<p>虽然这么说可能政治不正确，但这句话很有问题。</p>
<p>我们口中的房子由房屋和房屋下的土地共同组成的。 </p>
<p>房屋本身作为商品是可以像汽车一样流水线化生产的，只有居住价值。 </p>
<p>但是房屋下的土地是政府招拍挂供给的，政府通过控制土地供给，让土地具备了稀缺性，土地因为稀缺性决定了土地有投资价值。 </p>
<p>房子贵的不是房屋，而是房屋下面的那块土地，因为土地有投资属性，决定了房子一定会被炒。 </p>
</blockquote>
<h3 id="3、房子太贵了"><a href="#3、房子太贵了" class="headerlink" title="3、房子太贵了"></a>3、房子太贵了</h3><p>这个问题比较大。<br>房价是不是太贵了？有没有泡沫？</p>
<p>我们首先从国民的收入结构来分析</p>
<p>一个遵从“丛林法则”的精英社会决定了国民收入的金字塔结构。</p>
<p>既然是金字塔，底端的中低收入者占据了金子塔的最大比例，但是大家要知道金字塔的顶端既使只有10%人口，那也将是一个1亿多的绝对庞大的数字，远远超过了绝大多数西方国家的人口总和。</p>
<p>而北上广深以及三十多个省会，这些个靠掠夺全国或者一省资源，以牺牲大多数人口的利益为代价发展壮大起来的超大型及大型城市，需要容纳全国1亿多的精英人群，是否能得出房地产严重泡沫，空置率过高的结论？</p>
<p>当低收入者们努力挥洒汗水期望着自己年薪能够超过5万，8万，10万。。。的时候，他们可能做梦也想不出精英阶层手中究竟拥有多少财富。</p>
<p>精英们会象流氓无产者们一厢情愿认为的那样：因为一个区区房产税而恐慌性抛弃手中的大量房产吗？</p>
<blockquote>
<p><strong>liougehooa:</strong></p>
<p>现在不说哪个富豪不是靠偷税漏税爆发的，我就举个例子，一套房不收税，二套房也不收税，三套房收300%税，你龟儿子还敢买三套房？</p>
<p><strong>kkndme:</strong></p>
<p>你说的事情在历史上已有发生，大明律明令禁止超标准建房，如果违禁，不仅仅是收税的问题，而是打板子下大狱，没收充公的，比房产税可要狠多了。但是终究没能执行下去，原因在于官员太腐败，不符合官员地主阶层的利益，最后名存实亡了。光是梗着脖子叫唤是没有用的，利益驱动着社会的发展，违背统治阶层利益的事情即使出台也难以执行，最后的下场都是不了了之。</p>
</blockquote>
<p>答案显然是否定的。</p>
<p>可以确认的是，<strong>房价不是由统计局的平均收入决定的。而是精英的平均收入决定的。</strong></p>
<p>为了便于分析，我们剥离掉商品房（注意：只是商品房，而不是房屋）的社会属性，先把它看做商品。是商品就有他的内在规律。</p>
<p>什么决定商品的价格，价值？对不起，我只能说你上学上傻了。</p>
<p>是供求关系，只有供求关系。</p>
<p>我们判断一个核心城市市区内的商品房是具备足够稀缺性的。</p>
<p>如果你在北京海淀区上班，即使你在山海关拥有1000平方米的住宅也不能替代你住在北京市近郊区以内的愿望。</p>
<p>而无论你是租房，分房还是买房，只要你还在海淀区上班，你就必须住在北京市近郊区以内。</p>
<p>假设你挣得钱不足够多，你需要租一套房子解决你的上班问题，上班距离的远近及居住的质量，取决于你愿意支付的租金。</p>
<p>假设你的钱够买房子，我相信你更愿意买房，因为你可以拥有房屋的产权和房产增值的收益。而买房子的大小，品质，离你上班的远近，取决于你手中的资金和你对未来收入的预期。</p>
<p>买房问题很象是中国的上学问题，而且简直是异曲同工。</p>
<p>假设你家附近有个重点中学，教学质量很好，考大学几率很高，而其他的学校你觉得不理想，你肯定希望无论如何自家小孩也要上这个重点中学。</p>
<p>上重点中学凭什么？我们简单的剥离掉其他社会因素的影响，可以认为想上重点中学就要凭好成绩，小孩努力考到前多少名，就可以上重点中学。这与努力赚钱买房是一个道理，有钱的出高价就能买到好位置好环境的房子。</p>
<p>我们再加入社会因素的影响，比如某大人物看到这个中学很抢手，很可以赚一笔，于是就设计了加分项，谁给自己送的钱多，就给谁加分，于是小孩要上重点中学不但要考高分，还要送钱加分。</p>
<p>同理，当好位置的商品房成为稀缺资源，各类炒房客的出现是必然的。</p>
<p>如果说炒房客加高价给最终住户的行为会产生泡沫，那么重点小学和公立幼儿园高昂的择校费应不应该也叫做泡沫？</p>
<blockquote>
<p><strong>liougehooa:</strong></p>
<p>你拿一个错误的现象，说这个现象是正确的来证明你错误的房价观念是正确的，可笑！</p>
<p><strong>kkndme:</strong></p>
<p>事情不能简单用正确还是错误来评价，一件事物发生一定有发生的原因。你说皇帝统治老百姓，想杀谁杀谁是正确还是错误？如果是错的，但是却在中国延续了几千年。</p>
</blockquote>
<p>尽管炒房和公立幼儿园加价成为普遍的社会现象是令人痛心的，但它们不以刚需人群的意志为转移的存在着，且与泡沫无关。</p>
<h4 id="最被提及与泡沫有关的是以下两点："><a href="#最被提及与泡沫有关的是以下两点：" class="headerlink" title="最被提及与泡沫有关的是以下两点："></a>最被提及与泡沫有关的是以下两点：</h4><h5 id="第一：中国的房价甚至高于某些发达国家的房价。"><a href="#第一：中国的房价甚至高于某些发达国家的房价。" class="headerlink" title="第一：中国的房价甚至高于某些发达国家的房价。"></a>第一：中国的房价甚至高于某些发达国家的房价。</h5><p>其实，众所周知的是：不光房价高于某些发达国家，石油，高速，教育，医疗，税收等费用都远远高于某些发达国家。</p>
<p>而且中国的精英人群尽管所占比例不大，但是绝对数量足够大，而且精英平均收入甚至远远高于某些发达国家的收入水平。</p>
<h5 id="第二：租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。"><a href="#第二：租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。" class="headerlink" title="第二：租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。"></a>第二：租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。</h5><p>这个问题不用过多解释，使租售比更合理的方法不是只有降低房价一种，还有一种更靠谱的：房租大幅度上涨。而且已经在行动中。房租长期保持低价就像1990年以前的和田玉长期保持低价一样不可能。</p>
<h3 id="4、房价上涨造成物价上涨，人民生活变得困难"><a href="#4、房价上涨造成物价上涨，人民生活变得困难" class="headerlink" title="4、房价上涨造成物价上涨，人民生活变得困难"></a>4、房价上涨造成物价上涨，人民生活变得困难</h3><p>这个问题其实也不用多解释，懂经济学的该明白自然会明白，不会轻易被忽悠，不懂的解释半天也不会明白。</p>
<p>简单的可以这样说，物价上涨是经济过热，钞票印多了的后果。而房地产因为稀缺性和易保存比较吸金，所以吸收了大量的钞票，以至于大家光看到了房地产的飞涨。</p>
<blockquote>
<p><strong>liougehooa:</strong></p>
<p>房价高涨，你要发的钞票必须要多，不然怎么去买房子？你发的钞票越多，钞票不是你发下来去买房子就死掉了不流通了，它只要流到人的口袋或者银行的口袋，这钱立马回出现流动，能不造成通货膨胀吗？除非这笔钱收到后限制房东使用。<br>为了支持高房价，国家必须发大量货币，这也是去年房价高涨的原因。</p>
<p><strong>kkndme:</strong></p>
<p>请先了解一下中国的货币发行制度，人可以无知，但不可以乱说。让人笑话。</p>
</blockquote>
<blockquote>
<p><strong>tianxiaobing11:</strong></p>
<p>中国可以无限印钞票吗？有没有个限度呢？我是请教楼主，肉食者会怎么思考呢？他们的幕僚能从历史中找到答案吗？楼主的历史资料库中有这方面的吗？</p>
<p><strong>kkndme:</strong></p>
<p>如果你收集过铜钱，你会发现有一种大钱叫一当十五。这就是中国古代的铸钱方式。当铜不够了，zf用铸造2枚铜钱的铜铸造一枚大钱当作十五个大钱用。那时还没有纸币，所以采取了这种方法。<br>到了解放战争时期，物品紧缺，国军大量印制金圆券，今天用一捆钱没一斤米，明天用同样一捆钱却只能买一两米。当然这种金圆券无限制满天飞也和我军大量投放伪币有关。<br>当物质紧缺时，必然会通过发行纸币来缓和矛盾。小时候我常去买2毛钱的肉馅包一顿饺子，现在2毛钱仍在大街上也没人捡。肉馅从2毛钱涨到4块钱，货币贬值了20倍。为什么我们认可肉馅从2毛钱涨到4块钱的既定事实，但是却不能想象现在的物价会在未来的10年再涨20倍呢。<br>如果你收集过邮票，会发现50年代的老有票的票面价格都是500元一张，1000元一张，我们建国后的货币也并不是一开始就是圆角分的。50年代圆是最基本的货币单位，随便买个最小的东西，都是1000元起步的，很象现在的越南盾。<br>我们国家的印钞制度，主要跟外汇挂钩，在帖子里已经做过了描述，你可以在帖子里找一找。正是由于国内商品的内需不足，完全依靠低附加值商品出口创汇，才造成了人民币的外升内贬。</p>
</blockquote>
<p>其实如果房地产交易量下降，不再具有吸金功能，那么农产品等生活必须品以及房屋租金等等就会大幅上涨。这是因为多出来的大量钞票总要有个流向，如果不被房地产吸收，就会被大蒜，绿豆，姜，及全部生活必须品的上涨来吸收</p>
<p>事实也证明确实如此。2010年房产调控后，物价上涨的势头非常迅猛。</p>
<h2 id="房地产调控的真正意图（通过垄断获取利益最大化：国富民穷）"><a href="#房地产调控的真正意图（通过垄断获取利益最大化：国富民穷）" class="headerlink" title="房地产调控的真正意图（通过垄断获取利益最大化：国富民穷）"></a>房地产调控的真正意图（通过垄断获取利益最大化：国富民穷）</h2><p>防范金融风险？不错，你说的很对，但是没这么简单。</p>
<p>辨别利益是看透一切事物真相的武器。</p>
<p>高房价谁是受益者？</p>
<blockquote>
<p>房地产游戏的模式三个环节：dfzf卖地、银行贷款、开发商在二级市场销售</p>
<p>dfzf卖地之后，剩余的风险和收益都归银行和开发商</p>
<p>dfzf卖地的款则用于地方广场，地铁，公路之类的建设和权贵的挥霍。</p>
<p>dfzf只负责卖地，是无风险的买卖。</p>
<p>只要房价不断上涨，加杠杆的炒房客就会赚到盆满钵满</p>
</blockquote>
<p>这么分析下来，最受益的是地方政府、开发商、炒房客。</p>
<p>独独缺了zy。</p>
<p>这时你是否猜到zy为什么要调控？如果还猜不到没关系，听我道来。</p>
<p>纵观古今在位者最不能容忍的是别人受益，自己被黑锅。</p>
<p>大kfs，小kfs，大炒房客，小炒房客，dfzf都是收益者，但是风险却由zy来抗。这是一笔很不划算的买卖。</p>
<p>而房地产混战的局面，造成了国家队央企成员只有凭财大气粗高价拿地的份，钱花的最多，风险却抗的最大。</p>
<p>zy深深的感觉到要想国家队受益，要想控制风险只有做到两个字：垄断。</p>
<p>提高资金门槛，让小kfs，小炒房客，有点钱的小老百姓推出这个游戏。房地产很好玩，但不是小人物应该玩的。</p>
<p>先让市场冷静，彻底整顿，踢出那些个跳梁小丑，然后国家队出马，绝对垄断的市场，才能够统一定价，才能够控制风险，才能够利润最大化。</p>
<p>既然油价高于美国是合理的，那麽房价高于美国一定也是合理的，关键在于垄断。</p>
<p>不仅仅是房价的垄断，因为过高的垄断定价将会使交易量下降，国家队也需要资金周转。</p>
<p>真正厉害的，还是房租的垄断。公租房的推出是房租垄断进程的里程碑。</p>
<p>至于苦等廉租房的同志，不要抱太大的希望。城市要建设，地铁，广场，政府大楼都要上马，钱从哪里来？不会无缘无故凭空出来。</p>
<p>想想小学就近上学，但是重点小学真的就近就能上吗？小学名额可以寻租，经适房，廉租房也是一个道理。</p>
<blockquote>
<p><strong>tjOOSAN:</strong></p>
<p>真扯啊~~~ 油价跟房价去比？？</p>
<p>这位kkndme ，你就别忽悠了！~~ </p>
<p>汽车对于百姓而言，可有可无，油价涨到是美国的一百倍，中国百姓才高兴了。</p>
<p><strong>kkndme:</strong></p>
<p>这位兄弟，您比那些希望钱钱去炒大米的还不靠谱。</p>
<p>石油影响的不仅仅是开车的人花费多了。疯狂上涨的运输成本会导致民不聊生的。</p>
<p>假设一斤蔬菜从广西的农民地里收购是0.5元一斤，但是由于油价的像你说的上百倍的涨，运到北京，这斤蔬菜要卖300块一斤。</p>
<p>社会就瘫痪了</p>
<p>我们为确实买不起房的低收入群体，只能感到无奈</p>
<p>但有些本来能买房却嫌这嫌那而不买房的傻空同志，我们只能说你买不起房，完全是自己的原因，连油价上涨意味着什么都搞不懂，贫穷真的不能怨别人。</p>
</blockquote>
<blockquote>
<p><strong>tjOOSAN:</strong></p>
<p>大哥！房子是必须品。ok？那么既然你也认为政府的钱大多从地产来。</p>
<p>那么这种发展正常嘛？会持续吗？？没有实体经济，能行吗？</p>
<p>招你的法子说，炒楼才是中国的前途？</p>
<p><strong>kkndme:</strong></p>
<p>实体经济的发展不是简单的钱不去投资房产，就会去投资实体经济，实体经济就发展起来了。估计媒体洗脑洗的比较厉害，你中毒了。</p>
<p>资本是趋利的。无论是哪个国家，哪个社会，只要存在市场经济，这个道理就一定不会错。</p>
<p>为什么资金进入房地产及其他资本市场而逃离实体经济？是因为实体经济环境不好，不赚钱。</p>
<p>一是税赋太高;<br>二是各种需要打点孝敬的部门、管理人员、工作人员太多，比税赋还高，不能承受之重;<br>三是国家队在各个重要领域的垄断，使国企变成了变相税务局的职能，垄断企业的暴利定价，又是压在本应该蓬勃发展的实体经济上的又一座大山。</p>
<p>现在央企基本是不垄断的行业不做，把产能过剩，充分竞争的产业交给民间资本，并且还要给这些资本压上高昂的负担.</p>
<p>有可能垄断的行业包括房地产都会收到国家队手里，以后更是将发展成为一个高度垄断的社会。</p>
<p>资本不是傻子，一定会趋利，所以资本放弃了操心受累不挣钱的实体经济，转而投向房地产。房地产的调控，让资本又进入了黄金、农产品领域参与爆炒，反正就是不进实体经济。因为国家不给实体经济的环境做任何的改善。</p>
<p>如果实体经济有一个好的环境，有一个好的获利空间，大量的资金就不会撤出实体经济，没有资金潮涌般的投入房地产市场，中国的房地产将会是一个平稳的上涨趋势。</p>
<p>但是体制决定了资金的去向，不以人的意志为转移。</p>
<p>高税赋、暗箱成本及垄断不但造成巨大的贫富差距，而且将会导致生活成本的大幅提高，生活负担日益沉重。</p>
<p>一方面百姓生活负担的加重，导致一些非生活必须品严重产能过剩，将会出现大量亏损倒闭的内需企业。</p>
<p>另一方面精英阶层快速聚集大量财富，使奢侈品供不应求。古董，字画，玉器，豪车，顶级服装的消费比重也将越来越大。</p>
<p>但是能够容纳大量资金的只有两个领域：农产品领域（满足老百姓的肚子）和商品房领域（居住权要满足老百姓的需求，产权要满足精英阶层的需求）。</p>
<p>资金的流向只能疏导不能强堵，zf很明白这个道理。两者危害取其轻，你认为zf会选择哪个领域？</p>
</blockquote>
<p>总结一下：</p>
<ul>
<li><p>调控的根本原因是zy在房地产的游戏中没有得到好处。调控是为了让zy的国家队参与进来，成为主体。</p>
</li>
<li><p>垄断的目的还在于能够控制价格，为了维稳，zy是不希望暴涨的，但也不希望不涨。</p>
</li>
</ul>
<h2 id="说到房产泡沫的问题"><a href="#说到房产泡沫的问题" class="headerlink" title="说到房产泡沫的问题"></a>说到房产泡沫的问题</h2><h3 id="1、先说说官方的统计数据。-选择性失明"><a href="#1、先说说官方的统计数据。-选择性失明" class="headerlink" title="1、先说说官方的统计数据。(选择性失明)"></a>1、先说说官方的统计数据。(选择性失明)</h3><p>官方的统计数据从来是可以很雷，但不可以很真。</p>
<p>我们的统计原则基本就是：村骗乡，乡骗县，一骗骗到国务院。</p>
<p>不知道有人去市、县、乡、村进行过社会调查没有？</p>
<p>社会调查是怎么一回事？</p>
<p>我来告诉你，所有的关于人口、收入、田地、贫困户的数据都是官方统一编写，统一口径，如果胆敢有哪个小民对调查人员乱说，那是吃不了兜着走的。</p>
<p>你问了数据编来编去的意义在哪里呢？</p>
<p>意义很大，起码跟向上申请拨款是关系非常密切的。数据不假，钱从哪来？</p>
<p>统计数据无所谓是否真实并不重要，重要的是它是或缺利益的重要手段。</p>
<p>假设官方想证明房地产不存在泡沫，那么一定拿的出不存在泡沫的统计数据作证。</p>
<p>反之，也一样。</p>
<p>好比,CCAV为了证明高空置率的结论，派出记者专门找偏远且刚刚完工的楼盘，进行了一次纯粹为了证明内部已事先得出结论的毫无科学依据的调研。</p>
<p>而dfzf，为了证明刚需多么强劲，也立刻拿出了选择性失明的统计数据来进行回击。</p>
<p>无论是左还是右，同样都是不科学，都是现有结论，再有证据。</p>
<p>我们到底应该信谁</p>
<blockquote>
<p><strong>cdwl:</strong></p>
<p>商品房本来名字中就有商品二字不准投资岂不是笑话？<br>真正不准投资的那叫公房，这才是保证老百姓有房住的关键，商品房诞生的时候就很明确是改善居民居住条件的，现在政府怪商品房价格过高造成老百姓没房住本来就是颠倒黑白.<br>政府不造保障老百姓居住的公房，而让老百姓去购买改善居住条件的商品房来解决本该政府解决的居住问题，政府不作为才是造成老百姓出现居住问题的罪魁祸首。<br>我不期望人人有房，我只希望每一个在城市里找到工作的人通过努力工作勤俭持家能在生活城市里有希望拥有一套安稳的房子来容身，不管这房子的性质是商品房、经适房、廉租房或者其他什么房子。</p>
<p><strong>kkndme:</strong></p>
<p>你说的正是根源所在啊<br>zf的职责应该向无房者提供的保障房，建成经适房、两限房，被权贵占有牟利，<br>而非要把商品房赋予稳定社会的职能。<br>zf不是不知道问题的根源，而是不愿意放弃巨大的利益</p>
</blockquote>
<h2 id="房地产调控工具：房产税？"><a href="#房地产调控工具：房产税？" class="headerlink" title="房地产调控工具：房产税？"></a>房地产调控工具：房产税？</h2><p>当然还有人企图利用流氓无产者和无知群众的群情激奋来进一步收取房产税来提高dfzf收入。</p>
<p>税收从来都是向下游转嫁的，zf多收出来的钱一定是通过最下游的房租来体现。</p>
<p>当然，也有很多明白人士大声疾呼反对房产税。</p>
<p>自古而今，即使最辉煌的朝代，最被广大群众津津乐道的太平盛世，普通群众也仅仅只是解决了温饱而已，包括贞观、文景、康乾。</p>
<p>国家的富庶都是以老百姓勒紧裤腰带为代价的。</p>
<p>所以，zf是不会理会部分明白人反对房产税的呼声的。</p>
<p>真正对房产税的顾及来自于dfzf对土地出卖前途的担忧，真是鱼与熊掌不可兼得。</p>
<p>尽管流氓无产者和无知群众的呼声很高，然而房产税征收一旦实际操作起来，就会变的不得人心，征收难度非常之大，实际效果难以预知。</p>
<p>也就是说zf没有底。而如果房产税征收效果不佳，dfzf卖地收入再受到巨大影响，那就真正是得不偿失了。</p>
<p>就会变成赔了夫人又折兵。</p>
<p>这样的买卖，zf是不会轻易做的</p>
<p>房地产的现状是，商品房二级市场是由各种类型的开发商自由竞争的，一手房开发商之间的竞争，二手房投资客之间的的竞争。</p>
<p>房价为什麽在一个自由竞争的市场上能够持续上涨？因为稀缺性。不是房屋的稀缺性，而是房屋所必须占用的土地的稀缺性。</p>
<p>有些群情激奋的群众立刻以6500万套房子空置的事情提出质疑，还有ccav的报道，那是要多煽情又多煽情。</p>
<p>我们无需说6500万套的真实性（明白人都知道非常离谱）和空置率的科学性。</p>
<p>为什么不说，因为这种稀缺性跟空置率就完全没有关系。商品房的稀缺性是相对人民币而言的。人民币印多了，资金没地方去，商品房就涨价了。</p>
<p>垄断的市场是没有风险的，土地是完全垄断的，所以dfzf完全没有风险。</p>
<p>而商品房是自由竞争的市场，是具备风险属性的，尽管由于大量印钞造成了商品房的飞涨，但随着房价的高涨，风险也在积聚。</p>
<p>dfzf土地垄断没有风险，完全可以置身事外。</p>
<p>可是银行呢？属于国家的银行。</p>
<p>银行正在承担自由竞争市场房价高涨积聚的风险。</p>
<p>这是zy不允许看到的，dfzf受益，而风险全部甩给zy。</p>
<p>既然垄断的市场是没有风险的，那还是让房屋和土地一起垄断好了。</p>
<h2 id="垄断还可以解决一个问题：社会稳定。"><a href="#垄断还可以解决一个问题：社会稳定。" class="headerlink" title="垄断还可以解决一个问题：社会稳定。"></a>垄断还可以解决一个问题：社会稳定。</h2><p>常被媒体和群情激奋群众所提及的一个重要问题就是:房价收入比。</p>
<p>大量印刷的人民促成了房价高企（因为商品房实在是具备了大资金需要的所有投资品属性），可是那些个巨额的资金普通老百姓并没有见到。</p>
<p>路人甲：我们一个月就挣2000多块钱，干一辈子买不起房啊。</p>
<p>路人乙：我一个月上万都买不起房。</p>
<p>媒体：一个家庭不吃不喝22年买一套房</p>
<p>大量的疯狂印刷的人民币在哪里呢？</p>
<p>在精英手里。</p>
<p>我们在回顾一下开篇，我们奉行的是精英社会，丛林法则，金字塔式收入结构。</p>
<p>人民币再多，也不可能流到金字塔的底端。</p>
<p>dfzf垄断卖地也就让百姓们发发牢骚。</p>
<p>而炒房客，kfs赚的盆满钵满就让生活在中下层的老百姓眼红和不能容忍。</p>
<p>不患寡而患不均啊。</p>
<p>垄断，国家队的垄断，可以解决眼红问题，也就是社会稳定问题。</p>
<p>还有一个最重要的问题：银行和民营开发商之间，是官与民之间的问题。</p>
<p>而银行和国家队央企，是左兜和右兜的问题。</p>
<h2 id="如何垄断房屋、房租？"><a href="#如何垄断房屋、房租？" class="headerlink" title="如何垄断房屋、房租？"></a>如何垄断房屋、房租？</h2><p>土地是垄断的</p>
<p>然而房屋垄断并不是一件容易的事情。</p>
<p>因为民间百姓手里是存在大量二手房的.当然这也是为什么调控的板子只打在二套房、投资客、炒房客身上的原因。</p>
<p>同样，房租的垄断也并不是一件容易的事情，因为民间百姓手中的大量二手房都具备出租的特性。</p>
<p>俗话说，问渠哪得清如许，唯有源头活水来。</p>
<p>要垄断，必须抓住源头。</p>
<p>源头在哪里？</p>
<p>在一级市场，而不是二级市场。</p>
<p>房地产的垄断就是要国家队从一级市场做起，从一级市场开发着手完成对商品房开发的垄断。</p>
<p>一级市场，那是一个高高的门槛，民间资金，就让他该干嘛干嘛吧，房地产不是你玩的。</p>
<p>一级市场包括的内容是一般开发商无法参与的：</p>
<p>城市规划，城中村改造，旧房拆迁，城市综合体开发。</p>
<p>可以说从规划、改造拆迁、开发、到二级市场销售，一条龙服务。</p>
<p>一级市场开发的最大特点就是可以创造需求：你不是有房子吗？我拆掉你的房子，看你有没有刚需。</p>
<p>国家垄断控制风险的意义还在于：需求可以拆出来。</p>
<h2 id="国家垄断带来的影响"><a href="#国家垄断带来的影响" class="headerlink" title="国家垄断带来的影响"></a>国家垄断带来的影响</h2><p>以后的路，民营开发商的日子将变得越发艰难。</p>
<p>土地是dfzf的，商品房开发是央企和国企的。</p>
<p>处于金字塔下层的40%家庭，如果还没有一套自己的房子，那么买一套自己的房子就越发的变得不可能。</p>
<p>商品房将逐渐往金字塔的上层积聚。</p>
<p>处于金字塔下层40%的无房家庭将只能以租房来解决居住问题。</p>
<p>租金的快速上涨期即将到来，zf已经盯上了房租这块巨大的蛋糕。因为房租的收益比房产税更靠谱，更具有操作性。</p>
<p>公租房，呼之欲出</p>
<blockquote>
<h4 id="政府是否会考虑民生问题："><a href="#政府是否会考虑民生问题：" class="headerlink" title="政府是否会考虑民生问题："></a>政府是否会考虑民生问题：</h4><p><strong>sunxinmfc:</strong></p>
<p>政府无需考虑民生问题么，本次号称史上最严厉的打压政策再起不到一点效果，ZF威信力将进一步下降，需要仔细考量</p>
<p><strong>kkndme:</strong></p>
<p>自古以来，民生问题的底线就是不要出现陈胜吴广的极端情况。所以zf更在意的是农民问题。</p>
<p>因为历史的改朝换代都是大饥荒引起的，无论是汉末、唐末、隋末、还是明末。农产品价格上涨的对zf的震动要远远大于房价的上涨。</p>
<p>农民具备最原始的力量，而他们关心的并不是三线以上城市的房价，而是能否填饱肚子。</p>
<p>而关心自己能否拥有一套产权房的都市白领，除了呻吟一下意外，几乎是没有什么有效反抗的可能的。</p>
<blockquote>
<p><strong>sunxinmfc:</strong></p>
<p>秀才造反，三年不成，自古已然。</p>
<p>但我们还没有谈到所谓“造反”的地步，只是说房价如你所述，暴涨，中国的中产和以上人士将进一步携款合法外流（在房价暴涨的09年，中国外流人口达到历史峰值）。</p>
<p>这一部分人利益如何保证？您觉得zf不需要考虑对么？</p>
<p><strong>kkndme:</strong></p>
<p>现在社会跟几百年前最大的不同是，世界是开放的，这得益于地理大发现和世界经济一体化，即使缅甸朝鲜这样封闭的国家也免不了受到来自世界范围的影响。大一统的集权社会融入了西方民主的思想，同时互联网的出现也让人们对过去的思维进行了再思考。</p>
<p>尽管底层百姓出国还是一个梦想，但对于精英人群，基本上是在世界范围自由流动的。</p>
<p>中国自古以来，商人都是没有地位的，商人的财产可以随时被官员没收，自古如此，至今如此，即使是今天也并没有出现私人财产神圣不可侵犯的宣言。即使出现了，也没有任何可以操作的可能。</p>
<p>明朝以后大量的商人移居海外成了华侨，现今的商人为了安全移居海外也不是什么新鲜事，不过是步明朝华侨的后尘罢了，zf会真的放在心上吗？朱元璋没有放在心上，朱棣没有放在心上，现在同样也不会放在心上。</p>
<p>真正可怕的是官员一方面谋取私利一方面把亲属和存款送到国外，这其实是一种国家背叛。在国内榨干老百姓的血汗，得到的金钱却在国外挥霍。什么叫卖国，不过如此。</p>
<p><strong>connstr：</strong></p>
<p>假如商人可以移居海外，官员自然也可以。官商能分家吗？</p>
<p><strong>kkndme：</strong></p>
<p>商人还是要分的吧：红顶商人就是官商，统治阶级，那是上位者。普通商人，比如开个袜子厂赚个辛苦钱，最后袜子厂不挣钱了，官员还天天找他，让他孝敬，他就只好移民了。普通商人在中国也是海量的，有点钱，但是没一点地位。</p>
</blockquote>
<p>中国自古以来都不是人人都能有属于自己的房子，大量的丫鬟、仆妇、管家、小厮寄养在权贵人家，身体都是不自由的，何谈拥有自己的房子。</p>
<p>自古以来，最多的就是失去土地的农民，住在地主家做长工，又何谈属于自己的房子。</p>
<p>只要是有贫富差距的社会，只要存在阶级，只要存在统治和被统治，这个社会就会不以人的意志为转移的出现大量的底层居民，没有这些底层居民。权贵就不能很好的生活。</p>
<p>为了权贵生活的更好，就要维持大量的底层群众。</p>
<p>权贵必须保证大量底层群众的基本生活，才能够让自己过得更舒服，仅此而已。这就是民生</p>
<p><strong>sunxinmfc:</strong></p>
<p>不得不说，你说的很对。</p>
<p>君不见，天涯上多少盼着被美军解放的铁杆准汉奸，政府楼被炸七成网民不是替死者默哀，而是一片欢呼。为什么会有这样的民意，参考前苏联，ZF确实应三思</p>
<p><strong>kkndme:</strong></p>
<p>爱国是与中华的历史分不开的，自秦统一以来，中国由封建时代转变为帝国时代，只有在项羽焚烧咸阳后，对诸侯进行了一次分封，但时间非常短暂，刘邦重新统一了天下，帝国时代经历了漫长的汉、唐、宋、元、明、清。天下一统的爱国情结是根深蒂固的。</p>
<p>而在秦以前，与中世纪的欧洲是极为相似的，齐国人可以到秦国做宰相，赵国人可以到燕国做将军。中世纪法国的诺曼底公爵可以到英格兰继承王位，瑞典的贵族可以到基普做大公，封建时代的国家概念并不是明显。欧洲经历了漫长的封建时代，国家观念很淡薄，能够抛弃国家货币成立欧盟就是明证。这对于漫长帝国时代，天下一统的国家是很难想象的。</p>
<p>爱国只跟历史文化传统有关。</p>
<p>1978年越南入侵红色高棉，当时的红色高棉对内实行红色恐怖，以gongchanzhuyi的名义对全国700万人口进行奴役和屠杀，总共屠杀了100万人。当越南军入侵时，受到了广大柬埔寨群众的热烈欢迎，称越南军解放柬埔寨是解放人类的战争。</p>
<p>红色高棉失去了民心，必然败亡。</p>
<p>那时，为了支援红色高棉，中越战争打响。有我国的强力支持，红色高棉仍然走向败亡。</p>
</blockquote>
<blockquote>
<h4 id="政府分租房市场蛋糕："><a href="#政府分租房市场蛋糕：" class="headerlink" title="政府分租房市场蛋糕："></a>政府分租房市场蛋糕：</h4><p><strong>中年不惑吗:</strong></p>
<p>不过从政府要分租房市场的蛋糕而言，我有不同的看法</p>
<p>政府的公租房要想租出好价格，有两种方式</p>
<p>1）减少市场可出租房源（北京就这样干了，拆迁廉价城中村）<br>2）提高竞争房源的成本。（所以我认为推出房产税是大概率的事情，<br>因为政府的公租房是不需要交房产税的）</p>
<p>于是竞争房源的房租暴涨，政府的公租房也就可以羞羞答答的打个9折来<br>安抚一些底层了，反正所有的黑锅都有竞争房源的房东背了</p>
<p><strong>kkndme：</strong></p>
<p>房产税的问题我觉得zf还是慎重的</p>
<p>1、如果采用不公平法则：</p>
<p>公务员，垄断企业，事业单位的福利房不上税，权贵与利益集团购买囤积的大量商品房不上税，只有普通百姓上税，会加剧社会矛盾。</p>
<p>而房产税会大幅提升租金，在公租房没有大量建起来之前，对稳定不利，维稳才是第一要务。</p>
<p>2、如果实行公平法则</p>
<p>小产权房，福利房，权贵囤积房都要上税，执行难度太大，可操作性不强，阻力几乎难以逾越。</p>
<p>如果真的收房产税，采用不公平法则的可能性最大，普通的无房百姓生活将变得非常艰难。</p>
<p>3、维稳问题其实最终还是吃饭问题。</p>
<p>房价上涨可以不买，如果房租价格不能控制，农产品价格不能控制，一旦大批群众吃饭出现了问题，维稳就无从谈起了。这个底线，还是要严守的。</p>
<p><strong>中年不惑吗:</strong></p>
<p>对公租房的问题受教了</p>
<p>不过当前从来不存在什么公平正义</p>
<p>税收向来是穷人多交，富人不交或少交</p>
<p>不过我很感兴趣的是假如推出了房产税</p>
<p>政府采取何种方式收</p>
<p>难道是如同鬼子进村了，挨家挨户的收？</p>
<p>但鬼子本身就是房产税的征收对象（不然也当不了鬼子）</p>
<p>他们自己都抵制，难道还指望他们向屁民收</p>
<p>遇到那种要钱没有，要命有一条的主</p>
<p>难道政府还开拖拉机来收？</p>
<p>5年前就叫嚣对房租收个人所得税</p>
<p>到现在也没有个影了</p>
<p>操作性实在太差</p>
<h4 id="房产税征收的影响，以及为什么要征税？"><a href="#房产税征收的影响，以及为什么要征税？" class="headerlink" title="房产税征收的影响，以及为什么要征税？"></a>房产税征收的影响，以及为什么要征税？</h4><p><strong>kkndme：</strong></p>
<p>房产税无论是持有环节征收，还是交易环节征收都是要向最终租房人转嫁的。</p>
<p>好比鸡饲料上涨没有可能鸡肉不涨价，但是养鸡的并没有赚更多钱。</p>
<p>降低百姓租房困难的唯一国际通行办法就是减税。</p>
<p>但是减税，在我国是很难行的通的。</p>
<p>一个高增长高通胀的国家，高昂的腐败成本和巨大的浪费将导致国家必须维持高税收才能维持运转，gdp保8实际上是必须的也是迫不得已的。</p>
<p>维持正常的运转，维持庞大的消耗税收而不是创造税收的公务员队伍，没有gdp快速的增长怎么可能呢。</p>
</blockquote>
<h2 id="公租房问题"><a href="#公租房问题" class="headerlink" title="公租房问题"></a>公租房问题</h2><p>说到公租房问题</p>
<p>首先还是要提到我们实行的双轨制</p>
<p>从某一方面可以简单的理解为统治阶级内和统治阶级外。</p>
<p>也就是我们常说的体制内，体制外。</p>
<p>体制内：公务员、垄断企业及医院高校科研院所等事业单位。</p>
<p>体制外：外资、私企打工者，个体工商户，农民，这里面也应当包括高层的老板和最底层的长期无业人员。</p>
<p>我们感受最深的就是涨工资的问题，一旦政府涨工资，那就一定是体制内涨工资，跟体制外完全没有关系。</p>
<p>在金融危机的08年，大批企业关门，减薪，裁员，美国欧洲因为钱紧不得不降低公务员薪水。而这时，我们神奇的国家在干一件事：公务员普遍加薪，是为了全国百姓着想—刺激消费。</p>
<p>还有保障房问题，这个也是我们感受最深的：保障房&#x3D;公务员及垄断企业住房；解决住房问题变成了如何让领导干部住更多更大的房子，如何让体制内员工拥有足够舒适住房的问题。</p>
<p>体制外的群众，那是别想得到一点好处的。谁让你是被统治阶级呢。</p>
<p>公租房的推出，也要解决两个问题：<br>1、体制内的最下层（最下层也是统治阶级，也就是是古代官吏中的吏）员工的基本住房问题。<br>2、向体制外被统治的小民稳定收钱的问题。</p>
<p>在私企打过工的都知道，毫无归属感可言，老板脑袋一发热，随时让员工卷铺盖卷走人。</p>
<p>那是要多没保障有多没保障。原因是社会关系，关键客户，都掌握在老板一个人手里，员工就是打个下手，一不爽了，就换人呗。</p>
<p>统治者可知道不能这么用人的。一个庞大的国家机器要想正常运转，必须得让手下的和自己的利益一致。如果自己吃肉，手下的连汤都没得喝，这个机器就转不动了。</p>
<p>因此，在房价高涨的时代，保障房才成为zy默认的公务员房、垄断企业房。</p>
<p>公租房首要解决的就是手下里面最底层人士的住房问题。</p>
<p>我认为针对于体制内来说，无论是公务员，事业单位，还是国有企业的初级员工，都可以通过所在单位申请公租房，公租房的租金会略低于市场，主要是单位一定会提供补贴。</p>
<p>体制外对公租房的申请就没有那么幸运了。</p>
<h2 id="如何解决建公租房的钱从哪儿来的问题？"><a href="#如何解决建公租房的钱从哪儿来的问题？" class="headerlink" title="如何解决建公租房的钱从哪儿来的问题？"></a>如何解决建公租房的钱从哪儿来的问题？</h2><p>钱的问题，dfzf也想到了解决的办法。</p>
<p>在卖地时就要求开发商配套建设一定比例的经适房、廉租房或公租房。</p>
<p>然而，羊毛出在羊身上，开发商不可能做赔本的买卖。</p>
<p>经适房好说，反正是卖个住户，大不了利润很低，顶多挣得少点。</p>
<p>而廉租房和公租房就纯粹是只见投入不见产出的（开发商可没资金没耐心收租子）。</p>
<p>廉租房和公租房的建设成本必须加到所建的商品房身上，这肯定会抬高房价。</p>
<p>关键是拿地成本逐年上涨，孝敬的资金也在逐年上涨，在加上多出来的廉租房和公租房建设成本，房价不可能无限抬高的。开发商也需要资金回笼周转。</p>
<p>房价越高风险越大只是无论zf，开发商，炒房客和买房群众都有的共识。</p>
<p>只是房价多高才是高，不同的人理解是不同的。</p>
<p>显然，把大量廉租房和公租房的建设寄托在开发商配套身上是完全行不通的，不仅不能解决住房问题，还让本来就高企的房价更加雪上加霜。</p>
<p>体制内公务员、垄断企业和事业单位的员工住房问题是不难解决的，因为有zf行为的强制意志在里面。</p>
<p>1、df划拨土地，征集开发商建经适房、公租房</p>
<p>2、dfzf强制要求开发商建配套经适房、公租房，建设成本就转嫁给购买商品房的冤大头吧。</p>
<p>3、体制内单位自有土地，集资建房。</p>
<p>多管齐下，体制内人员的住房不难解决，甚至体制内人员每人住好房子大房子多套房子的问题都不难解决。处于金字塔的中上层，他们俯瞰着芸芸众生。</p>
<p>处于金字塔下层的体制外的广大群众怎么办？</p>
<p>体制内员工的住房舒适性和投资获利是首要保证的，不然光让干活不给好处，怎么能让手下听话呢？</p>
<p>体制外广大群众的住房问题也要解决，这关系到社会稳定。</p>
<p>能不能拿出一个办法，即解决了群众住房问题，又可以从群众手里长期获取收益？</p>
<p>细水长流收租子的事情开发商做不了，但zf可以做。</p>
<p>公租房，如果解决了钱的问题，面向广大群众的公租房的推出，将会取得双赢的局面。</p>
<p>既然房地产开发最肥的肉留给了国家队，国家队也应该投身到公租房的建设中来。</p>
<p>国家队全面进场之前，大鱼小鱼虾米泥鳅，皆可得利。</p>
<p>不把小鱼虾米泥鳅赶出池塘，市场无法控制，风险无法控制，公租房建设也无从谈起。</p>
<p>二套房首付提高到50%，第三套房停止贷款，小开发商的清理整顿，民营企业在招拍挂中无论价高价低都无法取得土地，等等一系列重拳直击小鱼虾米。</p>
<p>土地将回到国家队手中，这个世界将变得清爽。</p>
<p>让时光倒流到80、90年代，我们的dfzf守着蕴藏着巨大财富的金矿、锡矿、铜矿却过着贫穷的日子。</p>
<p>没有资金，矿山是没有办法变成财富的。</p>
<p>于是招商引资，为了gdp、为了解决就业问题，出台了各种优惠政策，于是外商堂而皇之的走进来了。成为了这些矿山的主人。</p>
<p>5年，7年或者10年，外商享受的免税期满的时候，外商卷着巨额财富走了，留下了一个个废弃的充满危险的大坑。这是血琳琳的教训，zf没有理由不吸取。</p>
<p>外资、私企、小业主总有一天会让他们清场，尽管这一天晚来了十几年。</p>
<p>在土地日益稀缺的今天，房租难道不是可持续产出的金矿？让炒房客、投资客、民企开发商见鬼去吧。</p>
<blockquote>
<h4 id="商品房和公租房的不同："><a href="#商品房和公租房的不同：" class="headerlink" title="商品房和公租房的不同："></a>商品房和公租房的不同：</h4><p><strong>中年不惑吗:</strong></p>
<p>有个疑问</p>
<p>商品房和公租房相比，优势在什么地方？</p>
<p>那些楼裂裂的商品房估计质量还不如公租房吧</p>
<p>楼主应该加一句，买质量好的商品房</p>
<p><strong>kkndme：</strong></p>
<p>商品房和公租房的区别实际就是土地性质的不同，一个是出让，一个是划拨。</p>
<p>出让那必须是招拍挂，那必须是天价。</p>
<p>划拨就基本算是白给，收钱就是象征性的意思意思。</p>
<p>是商品房还是公租房，土地的性质说了算，dfzf说了算。跟房屋质量没有关系。</p>
<p>一套房子假设20000一平，房子的价值也就占30%，剩余的都是土地的价值</p>
</blockquote>
<blockquote>
<p><strong>yjfsam：</strong></p>
<p>看新闻说,在经济适用房里提供一定数量的廉租房,而不是大量廉租房,经济适用房是可以购买的,而且是建在市中心附近。</p>
<p>如果是我,我当然是想买经济适用房,而廉租房又不多,这会不会跟楼主的意思有点不一样?</p>
<p>另外经济适用房在高价房附近推出,可以打压附近房价?</p>
<p><strong>kkndme:</strong></p>
<p>你认为建在市中心附近的经济适用房是给普通老百姓建的吗？是低收入群众有资格购买的吗？</p>
<p>经济适用房都是内部分配的，但一旦走进市场就可以牟取暴利了。</p>
<blockquote>
<p><strong>tjOOSAN：</strong></p>
<p>市中心的经适，就是叫做定向分配。就是 在这附近拆迁的人，住的！！</p>
<p>你非要说，有人谋私，我也不反对！但绝对不会多。</p>
<p><strong>kkndme:</strong></p>
<p>我估计是你理解错了，谋私和牟取暴利是两回事。<br>假设你是某市科级公务员，分到两套房子，以保障房的价格购买，但是却可以按照市场价格出售，只要一转手就可以进账几十万甚至上百万。<br>这就是分房双轨制给体制内有级别的员工带来的暴力机会。这跟谋私没有关系</p>
<p><strong>tjOOSAN：</strong></p>
<p>你。。我不知道你说这个是什么意思？</p>
<p>贪污腐败是少数。这是肯定存在的现象。但我现在讨论的是大众现象！</p>
<p>而且内部分房的们都要够一定级别！就算他们一人分三套，那根本对楼市没有影响的</p>
<p><strong>kkndme:</strong></p>
<p>我说的是房产双轨制，是一种制度，不是说个人的以权谋私。</p>
<p>房屋问题实际上是土地问题，当一少部分人群能够以很低的代价占有更多的土地，市场上的土地就会变得稀缺，价格就会上升。</p>
<p><strong>tjOOSAN：</strong></p>
<p>唉！~~ 那才能占多少土地啊~~ 。。一栋高层就能住300户 。那才多大点儿地儿啊</p>
<p>房价上升，是因为国企和制造业资金输入。加上适龄人口增加。<br>最最主要的是 大资本的进入~~ 那点内部分房。。。。唉。。</p>
</blockquote>
<p><strong>tjOOSAN：</strong></p>
<p>大哥！！我真服你了。。。。。。 </p>
<p>你知道 定向分配吗？？？就是只有拆迁户才有资格买的房子。不存在收入的问题！！</p>
<p>你纯粹是胡诌啊！我发现</p>
<p><strong>kkndme：</strong></p>
<p>兄弟，你一直比较鸡栋，呵呵</p>
<p>拆迁户的定向房属于另外的问题，作为有产阶级的拆迁户来说，部分是城市扩大化的受益者，而部分又是受害者，不能一概而论。时机不同，城市不同，境遇也不同。</p>
<p>但是有一点可以肯定，拆迁的目的，不是为了拆迁户过得更好更舒服。开发商愿意支付高额的拆迁费（只限于超大型文明的城市，许多城市拆迁户的补偿是很可怜的）而是有更大的利润可图。</p>
<p>zf为主导建设的市中心经济适用房也不仅仅为了拆迁户回迁，拆迁户回迁比例最多占小区总放量的30%，而其余的基本上是权贵房</p>
<p><strong>tjOOSAN：</strong></p>
<p>我可不激动！就是闲的没事，来找事吧！还算是正事！</p>
<p>你说的什么给权贵房，固然存在。但是比例太太少了！！你说的话，根本没有依据！<br>现在买限价房的和经济适用房的人，都要在报纸上公布姓名和住址。</p>
<p>而且只要不是太穷的，基本都希望拆迁！因为第一，给的钱多。 第二 可以有定向分配。而且还是好地段的房子！！</p>
<p><strong>kkndme:</strong></p>
<p>兄弟你还是去了解一下体制内分福利房的真相吧。</p>
<p>福利房占用的都是经济适用房的指标啊</p>
<p>真正向社会公示的保障房才有多少呢？相对于数量庞大的福利房，可以说凤毛麟角。</p>
<p>不了解真相就没有发言权啊</p>
<p>特别是在二三线城市，房源比一线相对略为宽松，一个有点级别的公务员，通常都是分两三套房，这些房子占用的都是保障房的指标，都是要统计入保障房数据的。</p>
<p>不信你可以问问身边的公务员、银行员工、垄断企业员工</p>
<p><strong>tjOOSAN：</strong></p>
<p>奥！你说的是，传说中的 国企员工啊！！<br>可你一开始却说得是 经济适用房！是你搞错了把？<br>国企员工分配房子的，也要够一定工龄！一定级别！不是谁都有的。好伐？<br>而且 现在中国地产，很大一部分就是国企投资的。</p>
<p>所以叫内部分配么！！国企分房，在中国的体制内是正常的！</p>
<p><strong>kkndme:</strong></p>
<p>传说中的上海人？</p>
<p>我没有搞错，体制内员工分配的福利房就是经济适用房。</p>
<p>我举个例子，昆明武警干部的福利房叫恒安新邻居，它的官方名称叫什么？</p>
<p>我告诉你，叫做“武警经济适用房小区”</p>
<p>你看到的内部分房，占用的都是经济适用房的指标，也就是占用的是：我们所说的为了解决民生问题的保障房的指标。</p>
<p><strong>tjOOSAN：</strong></p>
<p>那就是个别了！！而且注意看“干部”两个字。就是到一定级别的分房!这打几十年前就有了！ 错就错在他不该占用经济适用！！ </p>
<p>说到底，不就是武警省钱么</p>
<p>现在买经济适用的人，都会上报纸！</p>
</blockquote>
<h2 id="通过征税调节贫富差距是耍流氓（因为富的人负责制定政策，富的人不会让政策针对自己）"><a href="#通过征税调节贫富差距是耍流氓（因为富的人负责制定政策，富的人不会让政策针对自己）" class="headerlink" title="通过征税调节贫富差距是耍流氓（因为富的人负责制定政策，富的人不会让政策针对自己）"></a>通过征税调节贫富差距是耍流氓（因为富的人负责制定政策，富的人不会让政策针对自己）</h2><p>今天看到搜狐上一篇文章说道要通过征税来调节贫富差距，提出这个方案的人不知是无知还是故意，如果zf听了这种无耻参谋的建议，不知道多少老百姓会活的更惨。</p>
<p>假设出台又一个新税种，无乱它叫什么，我们暂定为财产税。既然有了新税种，就要定任务，那好了为了这个税种制定了年上缴多少多少的任务。</p>
<p>实操的时候，执行的工作人员发现一旦轮到权贵脑袋上的事就没办法执行，你执行，他先让你下课。</p>
<p>但是任务必须完成，那还是从普通老百姓身上打主意吧。于是政策就完全走样了，非但起不了劫富济贫的目的，反而加重了穷人的负担。</p>
<p>往近里说，个人所得税，挣的是谁的税？权贵没看见交，月薪3000块的工薪层可一个都跑不了。</p>
<p>3000块月薪上缴的个人所得税你看着不多，可对于养孩子糊口的老百姓来说，哪怕10块钱都是重要的。他们可没有资本象月薪上万的小资一样动不动花500块钱泡个吧。</p>
<p>个人所得税是有任务的，工作人员必须完成任务，税别管是局级干部交的，还是连孩子幼儿园都上不起的穷光蛋交的，总之完成任务就是好样的。既然局长的税收不上来，就要从穷光蛋身上加倍收上来。</p>
<p>往远里说，王安石变法是怎么失败的，以史为鉴可以知得失。</p>
<p>王安石的初衷难道不是好的吗，可结果怎么样呢？只有一个——民不聊生。</p>
<p>书生误国啊。</p>
<h2 id="房价什么时候会涨"><a href="#房价什么时候会涨" class="headerlink" title="房价什么时候会涨"></a>房价什么时候会涨</h2><p>许多兄弟关心房价什么时候会涨？</p>
<p>那么先看看这次调控后都出现了什么样的现象。</p>
<p>1、全国房产成交量大幅下降<br>2、一线城市房价略有下跌，但并不持续，到现在基本跌不动了<br>3、多数二三线城市房价不跌反涨，成交量逐渐回升<br>4、大多数二线以上城市租金持续上涨<br>5、农产品价格有上涨迹象，大蒜、姜等小品种农产品遭遇爆炒。<br>6、变化莫测的政策导致精英阶层出现移民潮</p>
<p>农产品价格的上涨是很值得警惕的。想买房子但嫌房子贵的都市白领对农产品的价格很不敏感，但是金字塔最底层的最大多数群众是很敏感的。</p>
<p>领导们也很敏感。这牵扯到相当大比例人口的吃饭问题，稳定压倒一切。</p>
<p>农产品价格的抬头将会导致物价全面上涨，在不引起质变的前提下，房价作为商品也不例外。</p>
<p>这个引起质变的前提是出现饥荒的极端情况，这样的几率在现在社会很少。尽管干旱和洪涝使农产品大幅度减产，但是农产品还可以进口，国家还有粮食储备，保证全国人民填饱肚子还是不存在问题的。</p>
<p>一线城市仍然沉默，国家队在积极运动。二三线城市的房价上涨的成交量的回升却给了市场一个明确的信号。</p>
<p>这是资金运动的规律。国家队对一线城市的布局，迫使资金流向二三线城市。二三线城市相对（与一线城市相比）不高的价位给出了较大上升空间的预期。</p>
<p>全国富人买北京上海，全省富人买省会，房价的合理性已经不能用简单的本地平均收入来衡量。精英阶层的购买力才是关键。</p>
<p>明年物价进入持续上涨期是一个不容回避的问题。</p>
<p>在资金总量不变的前提下，巨量资金推动农产品价格上涨或者推动房价上涨是一个必须的选择。</p>
<p>今年zf用行政手段严厉打击蒜和绿豆价格的暴炒，基本上没有起到作用，资金有自己的运作规律，光靠拿张悟本出气也不能解决问题。</p>
<p>二三线城市的房价的上涨使与一线城市的差价缩小，为一线城市的发力提供了动能。</p>
<p>无论你喜欢还是不喜欢，都不是以人的意志为转移的</p>
<p>许多人心怀房价肯定会跌回2004年的美好愿望，刻舟求剑似的思维错过了一次次购房的机会。在患得患失中，在牛刀的号角声中，在任志强的大炮声中，迷失了自我。</p>
<p>任何事物都是有其规律性的。关键是否有一双慧眼能够穿透重重的迷雾。</p>
<p>假设你是个投资客，你非要去石家庄和长沙买房子，结果发现不怎么升值，怨天怨地：</p>
<p>石家庄作为一个二线省会怎么会不涨？</p>
<p>长沙的房价怎么那么低？</p>
<p>我们知道，北京的房子是全国有钱人买的，省会的房子是全省的有钱人买的。</p>
<p>但是当省会城市距离一线大城市在6个小时高速以内，省里的有钱人的资金就会流向一线大城市，而不是省会。</p>
<p>河北的富人一定会选择在北京投资房产，湖南的富人一定会选择广州深圳投资房产。</p>
<p>假设你是一个投资客，你去昆明旅行，发现昆明的房价甚至高过重庆，很不理解。你很疑惑昆明这么小的西部边陲城市投资价值在哪里？</p>
<p>昆明是云南省内唯一的大城市，且相邻的二线以上城市离云南省都比较远。云南地州资源丰富，虽然穷人占的比例大，富人的数量却也不少。昆明南有滇池，北有长虫山，作为一个700万人口的城市，土地资源非常稀缺。所以贵，一定有贵的原因。便宜一定有便宜的道理。</p>
<blockquote>
<h4 id="房价会不会涨要看地方政府的规划："><a href="#房价会不会涨要看地方政府的规划：" class="headerlink" title="房价会不会涨要看地方政府的规划："></a>房价会不会涨要看地方政府的规划：</h4><p><strong>zzz4697:</strong></p>
<p>楼主针对南昌的房价做个分析吗？从刚公布的100个城市房子均价看，南昌5k每平左右，是高了还是低了？</p>
<p><strong>kkndme:</strong></p>
<p>对于不了解的城市不敢妄下断言。没到现场调查就没有发言权啊。</p>
<p>房价会不会涨还要看dfzf的规划。</p>
<p>比如广州拥有大量的城中村，其周边有较多的大城市，广州的房价就比北京和上海低。如果广州的城中村一旦大规模拆迁，房价将会大幅上涨。</p>
<p>比如南宁东盟贸易自由港的概念使南宁的房价涨幅惊人。</p>
<p>南昌的地理位置，zf规划，发展前景，江西富裕人口的多少，都是决定房价的因素</p>
</blockquote>
<blockquote>
<h4 id="房价暴涨的底层逻辑："><a href="#房价暴涨的底层逻辑：" class="headerlink" title="房价暴涨的底层逻辑："></a>房价暴涨的底层逻辑：</h4><p><strong>tjOOSAN:</strong></p>
<p>。。。。。。暴涨之后。。。。。。<br>我们不就是第二个日本吗？</p>
<p>供求关系？供求关系，现在是谁在决定？国家！</p>
<p>国家的经济结构决定的。制造业的资金都进入房地产了。能不涨吗？普通人有几个可以够炒房资格的？</p>
<p>日本 当初也是供求关系！~~ 供求关系的根本也不应脱离，国家的经济实力！！</p>
<p>还暴涨？怎么涨？再涨都够去美国买房了！！ 你这不扯淡么</p>
<p><strong>Kkndme:</strong></p>
<p>中国和日本最大的不同在于日本的货币是开放的，中国的不是，是不能自由兑换的。</p>
<p>暴涨是相对于钱而言的，不是相对于实际购买力而言的。</p>
<p>80年代工资200多块钱一个月的时候，是不能想象90年代末北京城区5000每平米的房价的。那时候万元户已经是富人的代表了。</p>
<p>90年代末工资1000块钱的时候是不能想象现在30000一平米的房价的。90年代的100万绝对是富裕群体。可现在连个中产都算不上。</p>
<p>货币的持续贬值你没有考虑</p>
</blockquote>
<blockquote>
<h4 id="中国的土地稀缺吗？"><a href="#中国的土地稀缺吗？" class="headerlink" title="中国的土地稀缺吗？"></a>中国的土地稀缺吗？</h4><p><strong>tjOOSAN:</strong></p>
<p>在反驳楼主一句！！</p>
<p>在中国的土地，可不稀缺！~~ 只是没开发罢了！！</p>
<p>中国与世界不同！ok？13亿人！！用十三亿的居住权作为市场竞争的资本。</p>
<p>那太可怕了！真的！！！如果可能，中国绝对可以产出世界第一贵的地价！</p>
<p>为什么？这么多人需要房子。能不涨吗？</p>
<p>呵呵！多少有点扯淡！！别再提供求关系了！~~ 供求根本是平衡的！！</p>
<p><strong>kkndme:</strong></p>
<p>中国有13亿人口，960万平方公里土地，土地一点不稀缺。</p>
<p>但假设你在北京西城上班，让你去塔特拉马干买房子，你愿意去吗？</p>
<p>全国有点钱的都要在一线城市和省会城市买房子，所以才会稀缺。</p>
<p>大兴安岭有大量的土地，哪个有钱愿意跑去置业呢？</p>
<p>中国经济发展不平衡，牺牲全国大多数城市和乡村，来保证北上广深及大部分省会城市的繁荣才是造成土地稀缺的原因。</p>
<p>土地有的是，房子有的是，但好位置的土地和房子并不多。</p>
<p>一方面大量的小县城和乡镇、村庄人口锐减，因为缺乏谋生手段不得不背景离乡外出打工，另一方面超大型城市越来越拥挤，土地资源越来越稀缺。</p>
<p>这就是中国集中发展极少数标杆城市所造成的呀，也是因为如此，才造成了中国金子塔式的收入结构，贫富差距越来越悬殊。</p>
</blockquote>
<h2 id="为人民服务就是瞎掰"><a href="#为人民服务就是瞎掰" class="headerlink" title="为人民服务就是瞎掰"></a>为人民服务就是瞎掰</h2><p>很多人很疑惑，贪官越来越多，根本不把老百姓的利益放在心里，这些贪官即使被曝光了，还能继续当官。这是为什么呢？</p>
<p>首先理解一下老百姓，也就是民到底是什么？</p>
<p>民就是牛养，古代的时候，官员管理百姓叫做牧。官员管理百姓就是替君主放牧，只要保证牛羊不逃跑，不骚乱，那么就是合格的官员。</p>
<p>秦始皇暴政，百姓揭竿而起，可是陈胜起事后基本视民众如草芥，项羽屠杀平民比始皇更残暴。</p>
<p>萧何是一个很贤德的人，对百姓很好，赢得了很高的名声。刘邦在广武山和项羽对峙，得知了萧何在关中深受百姓爱戴，就疑心萧何要造反。一个君主爱民如子是为了百姓的支持，江山永固，一个臣子对老百姓好是不是要造反呢？于是派人去调查萧何。</p>
<p>萧何是个聪明人，感觉到刘邦已经不信任他了。于是赶紧改变工作作风，开始霸占百姓的田产，上大街欺负漂亮的妇女同志，并且派自己的子女上前线给刘邦做人质。</p>
<p>刘邦看到了萧何的行为非常高兴，知道萧何不会造反就放心了。</p>
<p>百姓不是牛羊是什么？</p>
<p>在红色高棉统治下的柬埔寨人，民连牛羊都不如呀。</p>
<p>波尔布特同志坚持gongchanzhuyi的按需分配，取消了货币。于是市场经济完全没有了。群众完全变成了按阶级分配了。</p>
<p>阶级只分为两种，波尔布特老板及其打手是绝对的统治阶级，其他人为被统治阶级，也可以称为奴隶阶级。</p>
<p>统治阶级对奴隶阶级不爽可以直接拿ak47突突。柬全国700万人口被波老板突突死了100万，当然不光是突突，还有活埋。</p>
<p>以至于越南派了10万军队侵略柬埔寨，受到了柬埔寨人民的夹道欢迎，称为解放人类的战争。</p>
<p>公道自在人心</p>
<p>博古才能通今，不了解历史无法治理国家，不了解历史也无法对事务有一个清楚的认识。</p>
<p>我们的今天本来就是历史的延续，前人经验和智慧的总结，不是一句话就可以抹杀的。</p>
<p>因为秦以后漫长帝国时代的大一统，才会把中央集权延续到现在。</p>
<p>而西方封建时代延续到地理大发现，诸侯割据王国、公国、侯国林立为现代的西方提供了民主制度的可能。</p>
<p>在制度上完全的不可比性，使向国际接轨成为了笑话。</p>
<p>我们看到的结果就是，物价上涨与西方接轨，甚至堂而皇之的超过西方，体制外的工资则与非洲结果，也算是国际化了。</p>
<blockquote>
<h4 id="政府安排的政策房的猫腻："><a href="#政府安排的政策房的猫腻：" class="headerlink" title="政府安排的政策房的猫腻："></a>政府安排的政策房的猫腻：</h4><p><strong>mellyzhang：</strong></p>
<p>大家听过那个西三旗的有名的限价房——旗胜家园吧<del>！外表看起来那么光鲜，地段也不是特别偏，紧邻城铁，当然是被人疯抢都抢不到的两限房呀</del>！还不是质量问题一大堆。</p>
<p>ZF安排的政策房也是要KFS建的，哪个KFS没肉吃还能保证把房子盖好？？！！所谓检测都TMD是虚的~。</p>
<p><strong>kkndme：</strong></p>
<p>这是肯定的，开发商都追求利润最大化。</p>
<p>zf建设两限房限制开发商利润，开发商必然偷工减料，zf都知道怎么回事，必须争一只眼闭一只眼，否则这个政策就执行不下去了</p>
</blockquote>
<p>对于渴望拥有一套产权住房的都市小白领对希望房价狂降已经到了歇斯底里的程度，他们赞成农产品价格放开，让资金炒作农产品，而离开房地产市场。</p>
<p>理由很简单，一套房子一涨就是几十万甚至上百万，而大米小麦，一斤就算涨到10块，也根本不能影响到自己的生活质量。</p>
<p>如果我国农产品价格是开放的，资金流向大米、小麦、猪肉，并且允许囤积，房地产一定会下跌的，这是毫无疑问的。</p>
<p>但是，我们看到的绝不是10块钱一斤的大米、小麦，而是500块钱、1000块钱一斤的大米、小麦。</p>
<p>我国将会出现大面积的饥荒，几千万甚至上亿的底层人士饿死街头，社会将出现大的动荡。</p>
<p>而产权房屋价格的上涨牺牲的主体只是体制外部分都市白领的利益，换来的不过是网络上没完没了的牢骚和咒骂。</p>
<p>巨量资金必须有地方去，如今面临的房地产和农产品之间的选择，你认为zf会怎么做？</p>
<p>体制内中层、高层可以分到多套福利房，低层至少能够分到一套保障房，即使最不重要部门的底层员工，搞到由单位补贴的公租房是没有问题的。</p>
<p>体制外的高层、中层，以他们的资金实力买多套房子都是不成问题的。</p>
<p>农民，分配有宅基地。国家要稳定，首先就是要农民稳定，因此我国只有农民能够分到土地自己盖房子。</p>
<p>军人，会享受到比公务员更好的福利，让军人享受更高标准的福利待遇，国家有深刻的认识。</p>
<p>那么只有体制外的都市中下层群众才是高房价的受害者，可是这个群体的地位真的很微不足道。</p>
<p>这些既无稳定工作（低层都市白领失业的概率还是蛮大的）又无自己的房产的都市小白领是金子塔底层被压榨的对象，甚至远远不如交通便利地区的农民。</p>
<p>没有这个群体的存在，金字塔上层的权贵是无法享受舒适的生活的。</p>
<p>社会需要底层群体用巨大的付出和极少的收获为金字塔上层群体服务。</p>
<p>当然，在巨大的付出后，有少数人会从低层脱颖而出，爬到金子塔的中层、甚至上层。</p>
<p>这些少数人带给了底层群体奋斗的希望。</p>
<p>拥有一套属于自己产权的房子，就只有一套路：从金字塔的底层往上爬。这条路很艰辛，并且会越来越艰辛，但总有希望。</p>
<blockquote>
<p><strong>天地间间：</strong></p>
<p>楼主有一点没说透彻，那就是白领的工资普遍较高，他们有能力买房子，但是受到几千年以来的小农经济思想的约束，他们普遍认为买房子不划算，占便宜心里普遍严重，别看他们外表光鲜，其实还都是一帮农民。</p>
<p><strong>kkndme：</strong></p>
<p>我说的是买不起房的低收入小白领</p>
<p>高薪白领不买房的不多吧，都是网上吹的吧。</p>
<p>高薪白领一般还是有自住房的，只是有人不愿意投资房产。每个人想法不同而已。</p>
<p><strong>天地间间：</strong></p>
<p>请问楼主所说的低薪白领一个月赚多少钱算底薪？</p>
<p>就拿我说吧，我06年买的房子，当时月薪3000元，这在当时算不算低薪？</p>
<p>但是我买房了，还是一个人买的，当然老爸赞助了点。每个月还完月供兜里就剩几十元，硬扛下来了。</p>
<p>目前年薪12万，我老婆年薪6万？这算不算高新？</p>
<p>如果我当时没买房子，以我们2个人的收入当下也买的起，只不过生活负担重一些。</p>
<p>所以请楼主明示，什么是低薪？</p>
<p><strong>kkndme:</strong></p>
<p>兄弟，你所描述的是另外一个问题。先说说你所说的这个问题，再谈谈什么叫低薪</p>
<p>先说06年你月薪3000买房子的问题。</p>
<p>我们打一个比方：</p>
<p>假设80年代，咱们两个月薪都是100块。你喜欢清朝的瓷盘子，咬咬牙，一年用好不容易攒下的100块钱买了清朝瓷盘子。我喜欢缝纫机，用一年好不容易攒的钱买了一个缝纫机。</p>
<p>市场有价值发现功能。显然，80年代清代瓷盘子的价值没有得到发现。</p>
<p>进入90年代，随着社会的发展，社会财富的增加，钞票也大幅度增加。清代瓷盘子的市场价值发现出来了，瓷盘子价格开始大幅上涨，你的瓷盘子由100块涨到1000块。而我买的缝纫机已经淘汰了</p>
<p>瓷盘子具备投资品的一切属性，能够吸收社会的富裕资金，而缝纫机没有这个功能。</p>
<p>我很眼红，我虽然买的起这个瓷盘子（因为90年代我的工资由100涨到了800），但是我觉得价格太高了，没有买。而你的瓷盘子在90年代为你挣了900元钱。</p>
<p>时光又到21世纪，社会资金越来越多，钞票越印越多，可瓷盘子在市场上越来越少（都被收藏了），于是瓷盘子涨到了1千万一个，我即使想买瓷盘子再也买不起了，而不是嫌价格高的问题。</p>
<p>而你已经成为了千万富翁。那个瓷盘子也并没有因为1千万的价格实在太高而暴跌，相反价格仍以每年20%的速度增长。</p>
<p>06年你在房价价值发现的初期买了房子，就像90年代你用1000块买清代瓷盘子。</p>
<p>如果你的工资不变，或者变化不足够大，现在你将没不起房子，就像你在21世纪不可能买的起瓷盘子。</p>
<blockquote>
<p><strong>天地间间：</strong></p>
<p>楼主啊，你有一个概念错误：清代的瓷盘子是收藏品是古董，其价值是由拥有瓷盘子的收藏家决定的，而房子是商品（我指的是商品房，不是公租房之类的保障房），其价值远没有古董增值速度快，所以说收藏品和商品是有区别的。</p>
<blockquote>
<p><strong>kkndme:</strong><br>呵呵，商品房当然和清代磁盘是不同的，升值空间不同，投资对象也不同，但价值发现的道理是一样的。投资品的基本属性：稀缺性是共有的，当然稀缺的程度不同。</p>
<p>我所讲的是投资品的价值发现，而不是商品房&#x3D;清代瓷盘</p>
</blockquote>
<p>此外，您还没有正面回答我什么是低薪，我今年30多岁，如果我刚毕业肯定是拿底薪的，往最坏了想，我毕业几年到今年混的不好，今年只赚3000元一个月，我就买不起房么？</p>
<p>如果你觉得是，那么你错了，我仍然可以买的起，我会到比较偏远的地段去买房子，比如密云，延庆等买套小户型二手房，那里的房价我仍然可以支付月供，当然我还是要像老爸要点钱付首付的。</p>
<p>可是如果我不这么想，觉得去哪里不划算，在四环里买房子多好啊！那么我可能就买不起了，因为在四环里买房已经超出了我的能力，那么请问我买不起四环里的房子是房价的问题呢还是我的问题呢？是不是说我买不起四环里的房子就是我买不起房？<br>综上所述，每个人都有自己的能力极限，不同能力的人去不同的地段买房子，一味的强求自己做能力不及的事情，反而还怨天尤人的，这就是小农意识。</p>
<p>如有不详，愿同楼主共同切磋</p>
<blockquote>
<p><strong>kkndme:</strong></p>
<p>如果我们买首套房，不是为了投资。我们买房总有个基本的要求：</p>
<p>有一个自己的家，并且上班相对方便。如果你在长城饭店上班，你跑去密云买个房子。首先你上班就成问题。</p>
<p>如果我月薪3000块，我甚至不能在密云买房子（因为也上万了），但我可以在山西的某个县城买套房子。问题是我买这套房子干什么？</p>
</blockquote>
</blockquote>
<p><strong>再说说收入高低</strong>，不同城市，不同消费水平，对收入高低有着不同的理解。</p>
<p>我们举北京为例。</p>
<p>反映真实居住成本的是房屋租金，而不是房价。</p>
<p>在北京生活，一家三口的通常情况</p>
<p>一个位置能够满足上班条件的两居室租金大约3000元，小孩花费没有3000块是下不来的，再加上夫妻俩2000元的基本生活花费，也就是说8000月收入的家庭，刚好能达到收支平衡。</p>
<p>如果是体制外的都市白领，这个收入是很可怜的，因为还要考虑到失业问题，并且应付万一发生的意外支出。所以每月能有2000元的结余是必须的，那么10000元是在北京生活的基本水平。</p>
<p>而购买商品房所支付的金钱是要远高于租金成本的，因为你买的不是房屋居住权，而是房屋的产权，一定会出现溢价。</p>
<p>如果你现在的家庭收入能够再买得起一套房子，那么你的收入水平应该至少是小康，甚至达到中产</p>
<p><strong>天地间间：</strong></p>
<p>楼主，一对有工作经验的年轻的北京白领夫妻月收入只有8000元？</p>
<p>这是怎么统计的？您的统计结果不准啊</p>
<p>我的结论是10000-12000元&#x2F;月是北京标准的白领夫妻的月收入，那么这笔钱能不能买房子？能，能不能付首付？可能不能，首付款怎么来的？一部分是父母赞助的。作为父母就要把自己的孩子扶上马，再送一程，这和啃老没关系</p>
<blockquote>
<p><strong>kkndme:</strong></p>
<p>呵呵，这个也不好这么说，不同行业间的薪水差距实在太大了。</p>
<p>比如一个有6、7年职业学校的教师或者一个有5，6年电脑分销经验的产品经理（都是大学毕业），他们辛辛苦苦干一年多点的也就7、8万块。他们都不晓得招商银行随便一个客户经理轻轻松松年薪几十万。</p>
<p>同是大学毕业，同是5、6年工作经验，北京几十万年薪收入的人不少，但一个月只挣3、4000块的数量更庞大。</p>
</blockquote>
<p>我的中心思想是：</p>
<p>北京的白领普遍买的起房子，但是有一部分不买，其原因是想花最少的钱去获得最好的地段，最好的楼层，最好的朝向的房子，这是划算不划算的问题，不是买得起买不起的问题.</p>
<p>当然有的人会说：买房了，得病了怎么办？失业了怎么办？一大堆怎么办！那么请问：既然你知道早晚要见马克思，为什么现在还活着啊？一刀了断了算了，呵呵</p>
<p><strong>kkndme:</strong></p>
<p>你说的这类人其实是因为贪婪和恐惧，幸运不会垂青即贪婪又恐惧的人。用天涯的语言来说：就是传说中的傻空</p>
</blockquote>
<blockquote>
<h4 id="股市分析"><a href="#股市分析" class="headerlink" title="股市分析"></a>股市分析</h4><p><strong>新智战者:</strong></p>
<p>楼主对楼市的分析让人佩服！</p>
<p>能否谈谈股市？现在的股市不管涨跌，我只是看到ZF在疯狂的发行新股大盘股，压大盘是肯定的了，看样子又是下一盘很大的棋！</p>
<p><strong>kkndme:</strong></p>
<p>你要注意2010年的股市与以往是不同的。因为股指期货的出现。<br>要时刻关注股指期货投入的资金量。</p>
<p>当股指期货资金量足够大的时候（什么叫足够大就要看个人的判断了），期指将指导沪深300指数。大盘会跟着固执期货走</p>
</blockquote>
<blockquote>
<h4 id="报复性上涨："><a href="#报复性上涨：" class="headerlink" title="报复性上涨："></a>报复性上涨：</h4><p><strong>lfastro:</strong></p>
<p>“上帝欲使其灭亡，必先使其疯狂！”</p>
<p>很想看看“报复性上涨”是个什么样子。</p>
<p><strong>kkndme:</strong></p>
<p>你可以这样理解（只是为了理解方便做个示意）：<br>假设房价从2004年的4000一平，涨到2010年的20000一平<br>猪肉从2004年的6块一斤，涨到2010年的10块一斤。</p>
<p>但是如果房价2004年4000一平，到了2010年还是4000一平<br>那么，猪肉从2004年的6块一斤，将在2010年涨到30块一斤，不仅猪肉，还有大米，小麦，大蒜、葱、姜、房租都会翻几倍的价格。</p>
</blockquote>
<blockquote>
<h4 id="政府如何利用公租房垄断市场"><a href="#政府如何利用公租房垄断市场" class="headerlink" title="政府如何利用公租房垄断市场"></a>政府如何利用公租房垄断市场</h4><p><strong>中年不惑吗:</strong></p>
<p>政府要垄断房租市场？</p>
<p>市场上已有的和不断要产生的出租房源政府怎么让它们消失呢？</p>
<p>还是说政府要造足够多的公租房来占据市场主体，那就更难了，要花多少钱呀，公租房的地段好不了的</p>
<p><strong>kkndme:</strong></p>
<p>公租房将为房租市场树立一个标杆。有了这个标杆，私人出租房将会对比公租房做一个参照。</p>
<p>公租房是有限的，是需要申请的，而私人出租房会在相同位置将自己的房租定价高于公租房。</p>
<p>这样就保证了公租房的价格低于市场。</p>
<p>公租房不是廉租房，zf要持续赚钱，他的定价不会低，私人房就会定得更高，这将导致市场上的房租整体上涨。</p>
<p>公租房的吸引力在哪里？</p>
<p>1、对体制内会有单位补贴<br>2、对体制外人员可以提供一个较长的稳定租期。<br>3、zf定价的标杆作用，无论怎么定价，公租房都会低于周边市场价格.</p>
</blockquote>
<blockquote>
<h4 id="城中村注定要拆除消失"><a href="#城中村注定要拆除消失" class="headerlink" title="城中村注定要拆除消失"></a>城中村注定要拆除消失</h4><p><strong>中年不惑吗:</strong></p>
<p>城中村可是提供廉价房源的地方，这个公租房的竞争对手肯定要被政府干掉，所以城中村的拆迁改造那是一定的</p>
<p><strong>kkndme:</strong></p>
<p>城中村一定会消失的，不消灭城中村，哪来的GDP</p>
</blockquote>
<blockquote>
<h4 id="三四线城市和海南的发展"><a href="#三四线城市和海南的发展" class="headerlink" title="三四线城市和海南的发展"></a>三四线城市和海南的发展</h4><p><strong>alice_xg：</strong></p>
<p>楼主能否分析下未来三四线小城市的发展，是否会空心化</p>
<p>另外，请分析下海南的城市有没有投资价值</p>
<p><strong>kkndme：</strong></p>
<p>四线城市房价也会缓步上涨，但比较慢，主要还是因人工成本，原材料价格上涨造成的建筑成本上涨。</p>
<p>城市的空心化可能性不大，人口仍然会缓慢增长。但偏远乡镇却存在空心化的可能。</p>
<p>海南具备得天独厚的海岸线资源，这是全国任何一个其他海滨城市无法比拟的（其他的海滨确实比较差，毫无美感）。但关键还是zf如何开发，急功近利的开发，和毫无节制的圈海岸线可能会大幅降价海南的旅游与投资价值。</p>
<p>取决于政策，有较高风险</p>
</blockquote>
<h2 id="房租问题"><a href="#房租问题" class="headerlink" title="房租问题"></a>房租问题</h2><p>一是再说说房租问题，房租的发展趋势：</p>
<p>现在房租低的一个重要原因是因为，大多数都市小白领还希望能够买一套属于自己的产权房，至少他们觉得即使现在钱钱不够，但是努力一把，跳个脚还能够得着。</p>
<p>所以他们省吃俭用拼命的存钱。一个月薪10000块的小白领租一套月租金3000元的还算舒适的两居室是没有问题的，但是他为了攒钱买房宁可几个人合租一室，仅仅愿意在居住上花费少得可怜的500元钱。</p>
<p>随着国家队的进入，民营资本的退出，房地产开发和房地产投资的门槛都会大幅度提高，投资房产以后就成为富人的专属。</p>
<p>小白领的生活将变得“轻松”，因为除非能够上位，否则一般人跳脚是够不到属于自己的那套房子的。对于拥有房产失去希望，将使他不得不搬出合租房而转而租住一套还算舒适的两居室。</p>
<p>高昂的商品房价把大量的小白领从合租房中解放出来，转而去租住两居室或者三居室。</p>
<p>房租的价格一定会通过市场发现功能，找到他的位置。</p>
<blockquote>
<p><strong>想住清合吗:</strong></p>
<p>看了那么久，突然间觉得，楼主会不会过于武断了？</p>
<p>尽管我也看好房价和房租都上涨，但是，买房应该不会只是富人的专属。例如在日本，有许多的普通白领买的起房，难道在中国，白领就买不起吗？</p>
<p><strong>kkndme:</strong></p>
<p>白领是分层次的，有技术，有能力，有背景，肯吃苦的白领将通过努力获得更多的收入，获取更高的职位，走进金字塔的中层，买房子肯定没有问题。但进入金字塔中层的绝不会占大多数比例。</p>
<p>低级白领，公司办公室普通职员，一无技术，二无资 没有特殊的技能或本领，又没有什么关系和背景，对机会的把握能力也不是很强，如果家里也不富裕，这样的同志今后买房子就比较困难了。金字塔的底层人数比例是最大的。</p>
<p>日本的国情确实跟中国有很大不同，另外日本东京的房子也不是普通白领买的起的。我认识个NEC的部长（相当于中国企业的总监），也算大企业的中层干部，他也在东京买不起房子，家在离东京很远的郊区。</p>
<p><strong>中年不惑吗:</strong><br>日本的城市化已完成，不过东京市中心的房子小白领是买不起的，他们买的是东京卫星小城市的房子。</p>
<p>如同你在上海工作，去扬州买房子还是能承受的，人家的地铁一个小时能跑200公里，你说生活半径能扩大多少呢 再说日本是有选票的。</p>
<p><strong>kkndme：</strong></p>
<p>没错，就是这个道理。天涯里有些人说年薪30万买不起房，年薪70万买不起房。原因还是期望太高了，以为自己年薪70万了，就是人上人了，就必须住市中心的大房子。</p>
<p>但事实上市中心的大房子是绝对稀缺的，人上有人，天外有天。</p>
<p>买房子还是量力而行。有1000万资产的人是买不起价值2000万的翡翠的。有1个亿资产的人也不能买下故宫的居住权。</p>
</blockquote>
<blockquote>
<p><strong>vavan2010：</strong></p>
<p>楼主说得好，根据你所描述的，关于房租的这一块，我看到的前景是，由于国家队的加入和垄断，以后开发商只有可能是财雄势大集团的地产商和国家队这两种了。</p>
<p>而大量的建筑公屋，也是要分租赁市场的一杯之羹，又有公租房又有廉租房，再加上物业税的出台，这样愿意持有普通住宅多套的收租客会不会减少？</p>
<p>因为没钱买的会去租公租或廉租，有钱租的也去租高端好房，就象香港一样，有钱的买商品房，一般的买普通限价房，经济实用房，没钱的住公屋或廉租。反而持有普通住宅多套的会不会逐渐减？</p>
<p><strong>kkndme：</strong></p>
<p>公租房只能是有一定量，不会是大量，首先解决的也是体制内的住房问题。持有多套住宅的有自己的市场空间。</p>
<p><strong>醉生梦思1：</strong></p>
<p>这个问题很好解答，香港公租房占5成比例，私人租房市场委缩了吗？没有，这是市场上不同档次的产品，对应不同的需求。</p>
<p>就像有人看盘，绿化不好，没有游泳池的房子坚决不要是一样的道理。</p>
</blockquote>
<h2 id="粮食问题"><a href="#粮食问题" class="headerlink" title="粮食问题"></a>粮食问题</h2><p>中国的粮食实行储备制度，国家每年从农民手里收购一定数量粮食以及进口一定数量的粮食用于储备。</p>
<p>中国的稻米主要出自东北和广西，东北米好吃但产量小价格高，广西米难吃但产量达价格低，都市人都愿意花高点的价格购买东北米。</p>
<p>各地储粮通行的做法是以储粮为名收购的东北米加价在市场上出售牟取利润，再低价收购难吃的广西米用于粮食储备。</p>
<p>米在市场上的价格差别还是很大的，好的东北米可以卖到5块钱一市斤，一般的东北米卖到3块钱左右一斤，差点的东北米卖到2块钱一斤。而广西米基本在2块钱以下，而且除非比较穷的，一般人都不愿意吃。</p>
<p>大家可以看到在市场上交易的大米跟其他商品并没有什么不同，好的稀缺的就贵，差的产量大的就便宜。</p>
<p>但是米和房子不同，一方面米是当年的好吃，放到第二年陈了就不值钱了，第二年土地上新的稻子又长出来，会有新的米下市。</p>
<p>但是房子不会，一栋楼今年卖掉了，明年这块已经卖掉了的土地并不能长出另外一栋楼。另一方面，中国实行的储备粮制度将会在粮食减产的时候平易粮食价格的上涨（尽管储粮和市场上销售的粮食完全不是一个品质），而且国家对口粮的问题会高度重视。</p>
<p>粮食作为商品本身是与土地剥离的，而房屋作为商品却无法从土地剥离出来。这是粮食与房子的根本不同。</p>
<p>商人在粮食稀缺时期进行囤积会枪毙，在粮食丰收时期囤积粮食只能亏损（第二年的米就没人吃了。）</p>
<p>商品房作为商品在市场上交易，而保障房是为了保障低收入群体的最基本居住，这与粮食分为储备粮和商品粮又多少有些相似。</p>
<p>但是商品房土地和房屋无法剥离，产权和居住权却是剥离的，这就使既保障人民的基本居住权，又通过产权的升值牟取巨大的利益成为可能。zf实在是再明白不过了。</p>
<blockquote>
<p><strong>Razerwu：</strong></p>
<p>我也年纪小，07年才毕业，学经济的，人文历史基础有一点，关注房价有两年了。看了楼主帖子，更是开朗了。</p>
<p>升斗小民一定要跟形式跑，千万别一厢情愿，也别被媒体的话语误导了。</p>
<p>以后，征服会逐渐保证居者有其屋，但是不是每个家庭住的房子有自己产权。中国社会阶层分化很严重。主要分体制内和体制外两个群体。体制内的即使明摆着的收入一般，但是福利好。体制外的，有高薪的，但是低收入的更多。我们公司一般在年收入到手5-6W左右。这个应该是这个城市的平均水平了。我相信50%的人都在这个数。这个收入租个房子，除去其他生活开支，一年还能余个1,2W，如果是两个人一起生活，也能养小孩的，只是，你永远买不起自己的房子。</p>
<p>但是我也知道，更多的小白领，在空调房里工作，一个月就领1000来块的薪水，而那里房价也不低，8000-10000了。你还是买不起。</p>
<p>所以，未来你可以选择在房价高的地方生活，然后租房。你也可以选择回到三四线城市。但是很可能，到时候那里的房子价格也不低，如果你能力够，还是有希望买到商品房。</p>
<p>非常有钱的人很多，我不知道他们会怎样投资。</p>
<p>我想给一些跟我一样收入层次的人一些建议。</p>
<p>物价必涨，这是趋势，如今农村的农民都不怎么种地了，征服在搞平整，以后都会自动流转，每个村的徒弟承包给一个人，别的农民给他打工。有资金的农村出来的，可以考虑往农业方向发展。</p>
<p>我薪水收入一般，但是有外快，跟女友一块存钱，年收入超过20W，</p>
<p>楼主在帖子里提到长沙和石家庄的例子，我认为，二三线城市也要具体分析，像我老家长沙，房产升值空间还是有的，只要每年涨20%，我就满足了。</p>
<p>一线城市的房子更稀缺，但是，城市化的进程，不可能继续像上一个10年那样，大家都往一线城市跑了。所以，房地产暴涨的时代我不相信还有。我还相信二线城市和一线的房价差距会慢慢拉近。</p>
<p>所以，我用09年的结余，在今年上半年长沙贷款买了一套，我准备下半年再买一套。我不是炒房，我是略有结余的工薪阶层，我选择保值，总比放在银行要好。事实证明我是对的上半年买的现在已经涨了10%了。</p>
<p>一线和省会城市的商品房，未来一定会成为更加稀缺的资源。</p>
<p><strong>kkndme：</strong></p>
<p>长沙的房子一定会涨，只不过涨得会比其他城市慢。</p>
<p>低价买涨幅滞后的房子有一个好处，一旦长沙放出“大量拆迁”等利好因素，你就赚大了。购买房价基数低的省会城市，怎么都不会亏的</p>
</blockquote>
<p>还有一个关于实体经济的问题，房地产是资本市场还是实体经济？</p>
<p>我们回顾一下，房地产的居住属性和产权属性是剥离的。</p>
<p>依照房地产的居住属性，房地产绝对属于实体经济。</p>
<p>从下游来说，不搬新家重新购买一套家具、一套家电、做一次大的装修的可能性都不大。在没有改善住房的前提下，去换家具家电，搞装修的应该是一个很小的比例。</p>
<p>从上游来说，钢铁、水泥、机械等行业无一不受到到房地产的影响。</p>
<p>房地产影响到钢铁、水泥、机械、家电、家具、建筑建材等多种领域，影响真的不小。</p>
<p>依照房地产的产权属性，房地产又是资本市场。</p>
<p>资金推动了商品房价格的快速上涨。</p>
<p>房地产为政府积聚了大量的财富（卖地），这些财富用来建造地铁、公园、广场、办公大楼、公款招待、潇洒挥霍，又推动了实体经济的增长。</p>
<blockquote>
<h4 id="房价不可能跌的三个原因"><a href="#房价不可能跌的三个原因" class="headerlink" title="房价不可能跌的三个原因"></a>房价不可能跌的三个原因</h4><p><strong>sunxishila:</strong></p>
<p>我认为房价不可能跌的（至少5年内） ，尤其北上广，因为</p>
<p>1，地球资源就那么点，美国人不可能允许所有的人都过上他们那样的高消耗生活，所以美国人就尽可能地创造无产阶级国家来为其当奴隶进行打工。</p>
<p>中国的现状也一样，利益集团以及国家政府为了其利益以及维稳庞大的执政集团必须要通过工具将更多的人丧失生产资料以便当其奴隶。试想如果人人都有房住，人人都有闲钱可以自由的选择生活方式，我们以出口为主的血汗工厂还能招得到工人吗？北上广还能存在这么多外资企业吗？外资企业没的话，没这么多就业机会，所有的外地人回家了，上海的办公楼，出租房不全完蛋了，那么势必减少了各种税收，那么北上广正常的维持城市运行的资金必将断裂…怎么可能呢。</p>
<p>2，适度宽松的货币政策（也就是过量发行的货币）必将导致通货膨胀，在中国货币多了必将走进房地产，因为在中国基本没有别的更靠谱的投资渠道。长期看来，货币一直是贬值的 ，世界上几乎所有的国家货币一直都在贬值，这是货币的固有属性，就是剥削。除非取消货币，可能吗？</p>
<p>3，房价下跌或者价格合理当然是有可能的，可是这取决于政治，除非取消一党执政，除非土地似有话，原因相信大家都清楚，你们认为近期可能吗？</p>
</blockquote>
<h2 id="什么是傻空？"><a href="#什么是傻空？" class="headerlink" title="什么是傻空？"></a>什么是傻空？</h2><p>关于买房量力而行的事，还是有必要再说得清楚些的。</p>
<p>还是打个比方</p>
<p>假设某人家庭月收入15000块（都市小白领的通常收入），工作6年，手里有50万存款，我可以在北京北五环外（比如西三旗或者回龙观）买一套价值150万的房子（2万每平米，70几平米）。首付50万，贷款100万，月供7000多，是完全买的起的，而且因为轻轨的开通，即使在市中心工作，上班时间肯定可以在2个小时之内（作为北京这个城市来说是可以接受的）。</p>
<p>但是这个人心比较高，非要在北四环内，买一套100平的住宅，二手房3万一平米，100平米就是300万。首付按30%算，也就是90万，还要贷210万，已经完全超过了他的收入水平及收入预期。于是这个人成天怨天尤人，成天喊自己买不起房，抱怨zf，憎恨炒房客和开发商。天天叫唤社会不公平。</p>
<p>过了1年，国家队布局完毕，西三旗、回龙观房价涨到30000一平米了，买个70平的还要210万。首付30%，要60多万，贷款150万，月供12000左右。这时，他买西三旗70多平米的房子已经很费劲了。</p>
<p>这种行为叫什么？这就叫傻空。</p>
<h2 id="什么是真买不起房？"><a href="#什么是真买不起房？" class="headerlink" title="什么是真买不起房？"></a>什么是真买不起房？</h2><p>再比如说</p>
<p>某人家庭月收入比较低，8000块，在北京上班，西三旗和回龙观的房也要150万的总价，是买不起的。他的收入水平只能在密云或者河北买房子，但是即使在密云或者河北买了房也没办法上班。这个人就叫做真的买不起房。</p>
<p>如果他对未来的收入预期也不是很高的话，房价未来的上涨将使他进一步对买方绝望，他将彻底放弃攒钱买房，带着老婆孩子搬出跟人合租的城中村，每月花费2500块钱在回龙观租一间两室一厅的住宅。</p>
<p>日子就这么过下去了。</p>
<p>量变将引起质变，8000块钱的家庭月收入，是真买不起房的家庭，而15000月收入的家庭买不起房就叫傻空。</p>
<h2 id="分析问题要深入"><a href="#分析问题要深入" class="headerlink" title="分析问题要深入"></a>分析问题要深入</h2><p>小时候看春秋战国之类的书籍，总弄不明白一个问题：</p>
<p>a国家跟c国家打，他的邻国b就会很害怕，害怕a国家灭了c国家实力更强大，对自己不利。</p>
<p>e国家跟g国家打，他的邻国f就会很高兴，高兴e国家与g国家两败俱伤，自己可以获取利益。</p>
<p>后来我终于弄懂了。</p>
<p>当a国家跟c国家打仗时，如果a的国力明显强过c,他的邻国b就会很害怕，因为a国家很轻易就会灭掉c国家变得更强大。</p>
<p>当a国家跟c国家打仗时，如果a的国力跟c差不多,他的邻国b就会很高兴，因为a国家跟c国家会拼得两败俱伤。</p>
<p>分析问题，一定要深入的研究啊</p>
<h2 id="从贵阳的现状看中国的未来"><a href="#从贵阳的现状看中国的未来" class="headerlink" title="从贵阳的现状看中国的未来"></a>从贵阳的现状看中国的未来</h2><p>旅行的第一站，是贵阳。</p>
<p>一座低收入高消费的西部边远城市。</p>
<p>当地人说贵阳的消费太黑人，太畸形了。大多数当地人的收入相当于中部城市的县城水平，生活必需品的消费却超过了北京。</p>
<p>越偏远的地方越黑暗，越偏远的地方越不存在公平，越偏远的地方贫穷群众的比例越大，越偏远的地方权贵生活的越腐败、越奢华。</p>
<p>越是资源匮乏的地区，权贵阶层越富裕，这是以绝大多数人的贫穷为代价的。</p>
<p>资源的稀缺，导致权贵易于对资源形成垄断，通过以低收入高物价的方式，对底层群体进行赤裸裸的掠夺。</p>
<p>于是权贵们鲜衣怒马，下层群众褴褛衣衫。</p>
<p>贵州难道不是中国的缩影吗？</p>
<p>在欧洲的商业区，我国权贵们一掷万金，引来欧洲群众围观，瞠目结舌。以至于全世界都没法相信我国不是超级发达国家。</p>
<p>贵阳的近郊房价已经9000一平米，远郊的金阳房价已经接近了6000一平。</p>
<p>但是我们能就此判断贵阳的房价存在巨大泡沫吗？</p>
<p>贵阳到处是山，地少人多，物产极不丰富。</p>
<p>因此，贵阳的商品房就像贵阳的餐厅一样，和普通群众是完全没有关系的。而对于权贵与精英来说，即使再翻几倍的价格也一样买得起。（腐败啊）</p>
<p>看看贵阳，想想中国。</p>
<p>资源的匮乏将形成高度的垄断，导致贫富分化进一步加剧，生活成本大幅度提高，中国正走向低收入高消费的畸形社会结构，群众生活越艰难，权贵的生活就会越富足。</p>
<p>生活必需品和房价都会变得比西方国家更贵。</p>
<h2 id="货币贬值"><a href="#货币贬值" class="headerlink" title="货币贬值"></a>货币贬值</h2><p>货币贬值，来自于大量的印钞</p>
<p>可不可以少发点钞票。</p>
<p>对不起，不行。</p>
<p>这是我国的官有经济体制决定的。</p>
<p>凡是去过美国的朋友，会惊奇一个现象</p>
<p>除了人工服务行业，几乎大多数产品的绝对价格都低于国内。</p>
<p>从数码产品，到奢饰品，从矿泉水，鸡蛋到汽车，统统比国内的绝对价格（把美金换成人民币，再拿人民币进行比较）便宜。（美国的餐馆比较贵是因为包含了人工服务成本）</p>
<p>不仅仅是美国货比在中国卖的便宜，几乎所有 made in china 的商品在美国卖的绝对价格都低于国内售价（一件国内生产出口的服装在美国售价150人民币左右，但在国内售价竟然达到800-1000人民币）</p>
<p>贫穷的发展中国家——我们的物价却远远高于美国，这是什么样的原因呢？</p>
<p>我想主要还是我们的体制决定的：</p>
<p>1、高昂的行政成本</p>
<p>中国庞大的公务员队伍对货币的消耗达到惊人的程度。任何一种商品的销售都要分摊政府高昂的行政开支。不大量印钞票是无法维持正常运转的</p>
<p>2、过渡依靠政府投资。</p>
<p>大家都知道，中国的经济发展，是依靠政府投资为主导的，全世界都知道，政府投资的效率是最底下的，1个亿的投资往好了说只能产生3000万的效益，剩余7000万损耗掉了。因此政府不得不持续增加货币发行量</p>
<p>3、惊人的fb成本</p>
<p>一集中箱货物运到美国的成本甚至低于从北京运到深圳的国内运费。这是令人惊讶的事情，又是确凿的事实。中国高昂的高速费用使物流贵得吓人，从农民手中2分钱收购的蔬菜，运到了目的地，成本就变成了1元钱。</p>
<p>这中间不仅仅是高速费，当公路及铁路运输变得紧张的时候，你不得不花费比高速费更贵的支出用于打点关系。</p>
<p>关系的成本已经远远贵过商品本身。惊人的fb成本是物价上涨的重要原因，因为权贵贪心也是逐年增加的，fb成本越来越高。fb成本的每年高速增长，迫使印钞需求高速增长。</p>
<p>4、低附加值产品出口创汇</p>
<p>低附加值产品出口创汇是我国经济发展的主要支柱。</p>
<p>可以这样理解，我们的商品卖到了国外，换回的是外汇。国内的商品少了，就变贵了。</p>
<p>换回的外汇，国家就会按照外汇的总金额依据汇率全都印成人民币，投放到社会。社会上不但商品变少了，每年还会多印出一大堆钞票，这就是通货膨胀。货币的购买力在持续贬值，国家通过货币持续贬值来收割普通劳动者的羊毛。</p>
<p>所以说我国高通胀，货币持续贬值，是官有经济体制所决定的。</p>
<p>是不可能改变的。</p>
<p>持有闲置现金的风险，比持有任何一种可保存的商品的风险都大。</p>
<p>奉劝那些盼着zf政策出打击房产直到崩盘，以此得到高潮的同志们，真的不要等了，除非出现明末的极端事件，否则一辈子等不到高潮。</p>
<p>也奉劝希望房价能降个30%-50%好买套自己的房子的善良百姓，还是看有什么机会多挣点钱吧，等房价大降真的不现实。</p>
<p>百姓们希望领导们能给自己做个主，可是几千年以来，中国的上位者们从来都只考虑一个问题：“卧榻之上，岂容他人安睡。”真的没有时间管你们的那些小事儿。</p>
<blockquote>
<h4 id="关于康乾盛世的讨论"><a href="#关于康乾盛世的讨论" class="headerlink" title="关于康乾盛世的讨论"></a>关于康乾盛世的讨论</h4><p><strong>中年不惑吗:</strong></p>
<p>大家应该知道所谓的康乾盛世，开元盛世都是什么样子了</p>
<p>上层阶级的盛世而已</p>
<p>底层老百姓在史书上连“某人甲，某人乙”都留不下</p>
<p><strong>dantez13:</strong></p>
<p>康乾确实是虚假的所谓“盛世”开元还是不错的 </p>
<p>看历史不光纵向看 也要横向看</p>
<p><strong>kkndme:</strong></p>
<p>开元盛世留下巨大的隐患才导致玄宗悲惨的人生，不应简单的认为是杨玉环和安史之乱的原因。</p>
<p>首先是大量的土地兼并，大量的农民同志逃跑，社会的不安定为安史之乱埋下了隐患。还有就是节度使的权力太大，以全国之力供养节度使的军备，而内地养了一群废兵。</p>
<p>相当于老大把精兵干将派去边远山区收保护费，结果自己身边连个像样的保镖都没有。有个收保护费的领班突然不爽，自己想当老大，带着打手跑回去揍老大，准备上位。这时老大就光杆司令一个，看着自己的手下叛变之能干瞪眼</p>
<p><strong>dantez13:</strong></p>
<p>我说的看历史纵向横向的意思是指</p>
<p>康乾时期 纵向来看 还算是个稳定时期 但是17 18世纪 欧洲正轰轰烈烈的搞工业革命 </p>
<p>乾隆却几下江南 还搞什么骑射乃满洲之本</p>
<p>而开元时期 ，虽然的确有很多隐患 但是大唐还是当之无愧的世界老大 </p>
<p>唐朝也是那个时候达到的巅峰</p>
<p><strong>kkndme:</strong></p>
<p>呵呵，大唐当世界老大也不知道是好事还是坏事。</p>
<p>欧洲经历了漫长的中世纪黑暗时代，结果由诸侯割据的封建社会直接进入了资本主义社会，并向国家社会主义过渡。</p>
<p>中国早在秦就结束了诸侯国林立的封建时代，进入了大一统高度集权的帝国时代，到现在也没完全结束。</p>
</blockquote>
<h2 id="房价可能的下跌方式"><a href="#房价可能的下跌方式" class="headerlink" title="房价可能的下跌方式"></a>房价可能的下跌方式</h2><p>几天没有上来，发现来了很多比较鸡冻的同志。心情可予以理解。</p>
<p>但是鸡冻并不能让日子过的更好。</p>
<p>油价大涨小跌，我们鸡冻了，但是事实并没有改变。</p>
<p>高速费早就收回成本，可是依然雷打不动的收着，我们鸡冻了，可是事实也没有任何改变。</p>
<p>房价就能真如很多人所愿，使劲跌到人人买的起吗？今后的现实将告诉我们答案。</p>
<p>房价会不会跌？</p>
<p>我说在较远的将来一定会跌，但下跌的方式是完全不同的。不可能象大家所期望的由2010年的30000一平跌到2004年的6000一平。</p>
<p>下跌一定是另一种方式：当农产品价格以几年翻10倍甚至几十倍的速度上涨的时候，房产却相对滞涨。这是最有可能的下跌方式。</p>
<p>最善良的意愿并不能阻止事务向邪恶的方向发展。</p>
<p>我们大家都很清楚却都没关注的一个常识，当我们满怀热情无偿献血的时候，有哪个贫穷的患者在需要输血时，能够因为广大群众的无偿献血而得到医院的优惠吗？</p>
<p>不能，无论你是穷是富，只要你是平头百姓，你都不得不因为需要输血而支付昂贵的医药费。</p>
<p>同样，zf并不会因为拆迁给你补偿的太低，而强迫开发商降低房价卖给群众。压低建设成本，抬高售价，中间的利润由商人和权贵进行分配，这是官商结合的通行做法。自古以来，能够赚大钱的都是红顶商人，而不是普通个体户。</p>
<p>对于很多鸡冻的群众，指着鼻子问我：国家会不管吗？疯狂难道不是导致灭亡吗？</p>
<p>我告诉你，通货膨胀就是减缓灭亡时间的最好良药</p>
<blockquote>
<p><strong>被忽悠的群众:</strong></p>
<p>通货膨胀是zf偷偷掠夺人民财富的手段，极少数人暴利，怎是良药？？？</p>
<p><strong>kkndme:</strong></p>
<p>通货膨胀是zf偷偷掠夺人民财富的手段，极少数人暴利————没错，通货膨胀就是剪老百姓的羊毛，让权贵的财富更集中，中下层群众更贫穷。</p>
<p>但是，从国家的统治与巩固来讲，的确是良药啊（当然有一定限度）。</p>
<p>当大多数资源掌握在少数人手中的时候，占有绝大多数的金字塔下层的群众能够分配到的资源就越少，资源的价格就会越高，少数的金字塔中上层的既得利益者就会越富有。</p>
<p>大家知道，有些资源会变成富人间的游戏（比如现在的古董，字画），完全失去群众基础；而如果与生活密切相关的资源过度集中，一定会爆发极端冲突事件，造成社会动荡。</p>
<p>zf通过不断稀释货币的实际购买能力，并且对粮食等生活必需品实行平准制度，一方面保证了绝大多数人民的基本吃饭问题，另一方面让中下层群众手中的余钱基本消耗在特定的商品上，以至于不得不马不停蹄的劳作，这才能保证社会的稳定和向前发展。而上层精英就可以坐享其成。</p>
<p>让我们回顾一下过去</p>
<p>80年代，那时的人们靠省吃俭用积攒出节余，被消耗在自行车、手表、缝纫机上。通过不断的劳动，才能吃饱饭，才能攒点钱买三大件取媳妇。</p>
<p>80年代末，90年代初，人们的工资提高了，手里的结余增加了，彩电、冰箱的大规模普及又消灭了老百姓手中的流动性。</p>
<p>紧接着电话、空调又接过了彩电、冰箱的大旗。那时安装个电话可要5000大元啊。</p>
<p>随着工业化水平大幅度提高，经济高速增长，货币发行量也迅速增加，彩电、冰箱等工业化大规模产品已经不具备稀缺资源的特性，也无法吸收百姓手中庞大的结余资金。</p>
<p>汽车和商品房的发展成为消灭老百姓手中的流动性的最好工具。</p>
<p>在经济发展的大潮中，一旦对资源的支配权可以换取利益，贫富两极分化是发展的必然。随着贫富分化开始加剧，财富集中在少部分人手中，集中了大量财富的少部分人已经不满足于购买普通的消费品（汽车是工业化的产物，不具备稀缺性），对投资品的追捧造就了2005年房地产的崛起。</p>
<p>房地产具备了投资品和生活必须品的双重属性，即可以让金字塔中上层的精英群体依靠房地产保值增值，又可吸收掉中下层群众的未来若干年的结余资金。</p>
<p>大量印刷的货币还是有一定数量留到勤劳肯干的白领手中的，而这些货币又因为通货膨胀因素消耗在不断上涨的生活必需品上，必需品中商品房占了大头。</p>
<p>于是拥有大量房产的金字塔中上层精英可以坐享其成，享受房产升值带来的收益，而中下层群众不得不为房子打工。</p>
<p>发行大量货币满足经济发展的需要，同时通过通货膨胀来消灭广大群众手中的流动性，是zf稳定社会，发展经济的法宝，适度的通货膨胀当然是缓解社会矛盾的良药</p>
<p><strong>tjOOSAN:</strong></p>
<p>楼主！这段话，我不是很明白。</p>
<p>好像世界上，每个国家都是如此把？谁会不买东西？谁会不买生活必须品？</p>
<p>别忘了，中国发展到现在，百姓也没有能力购买一切生活必须品！当然，随着社会的发展，人民在一点一点的去完善基本生活。</p>
<p>这你却说成。。。精英和国家的阴谋。。。我。。。很难理解。</p>
<blockquote>
<p><strong>kkndme:</strong></p>
<p>不是阴谋，我没提过一句阴谋，是国策</p>
<p>好比美国，以中产阶级利益为代表的美国，一个币值相对稳定的国家，主导借钱消费，这就是国策。</p>
<p>当08年的金融危机，多数中产却尝到了惨痛的教训。而在美国的华人，因为热爱储蓄的原因（这跟美国币值相对稳定、华人储蓄习惯都有关系），生活并没有受到太大影响。</p>
</blockquote>
<p>稳定粮食价格，这对每个国家而言，都是必须的啊！？？这最最基本了吧？</p>
<p>房子为什么涨价？？？国家决策！懂吗？间接取消了经济适用房政策。市场上百分之九十都是商品房！！你告诉我，房价能不涨吗？</p>
<p>房价涨了，受益人是谁？？？是政府！！不是你嘴里所谓的精英，他们只是傀儡罢了！</p>
</blockquote>
<p>明朝末年，可怜的崇祯皇帝面临的最可怕的问题貌似两个:一是努尔哈赤的入侵；一是大饥荒下，到处闹蚁贼。</p>
<p>光是努尔哈赤的入侵，明末的关宁铁骑完全可以将满人挡在山海关外；光是蚁贼肆虐，凭洪承畴、孙传庭等名将镇压一群乌合之众还是易如反掌的；内忧外患才导致了明朝的灭亡。这是通行的说法。</p>
<p>明朝灭亡的真正原因，是经济原因。</p>
<p>当然，这也是句废话，无论是社会的稳定，还是国家的动乱，或者邻国间的战争，都是经济原因导致的。</p>
<p>明朝真正灭亡的原因是：货币供给不足。</p>
<p>不要说百姓的经济行为受到很大制约，即使是军队也发不出饷银。以至于除了关宁铁骑以外，明朝就找不出一支有战斗力的军队，甚至洪承畴、孙传庭打高迎祥、李自成、张献忠，居然靠农民军的馈赠过日子。</p>
<p>货币供给不足，明朝的经济崩溃了。</p>
<p>再谈谈鸦片战争和那个满脑子浆糊的林则徐。</p>
<p>鸦片战争的原因，在于大清国与欧洲诸国之间存在的巨大贸易顺差。</p>
<p>大清虽然闭关锁国，丝绸、茶叶、瓷器通过民间和官员私下大量出口欧洲换取白银，却没有任何的进口需求。以至于英、法国家不得不世界范围开采银矿，但依然不能满足采购中国商品的需求。</p>
<p>英法诸国必须要与中国通商贸易，才能解决贸易顺差这个根本的问题。英国人实在不知道拿什么商品来进行贸易(貌似中国什么都不需要），于是不法商人想出了鸦片撬开中英贸易缺口的馊主意——这并没有得到英国官方的支持。</p>
<p>但是林则徐同志既不懂得经济，又不懂得外交，对欧洲人的认识也就停留在：我不给你茶叶，你的腿都站不直。</p>
<p>不管洋人打算干什么，总之洋人就是邪恶的，就该抓起来打板子。于是，自然而然的一顿开打，结果可想而知。</p>
<p>于是清朝官员施展出了村骗乡，乡骗县，一骗骗到guowuyuan，的传统技能，咸丰同志在故宫几乎自始至终听到的都是捷报频传。</p>
<p>清末，一会儿闹拳匪，一会儿闹白莲教，一会儿闹太平天国。然而，靠鸡冻的群众杀几个洋毛子并不能使中国变得强大。林则徐如果能够有点知识，不妄自尊大，能够说动咸丰开放正常通商贸易、拒绝鸦片，联军入侵圆明园的事大致可以避免。</p>
<p>经济问题才是导致社会动荡，战争爆发的根源。</p>
<h2 id="房产投资的问题"><a href="#房产投资的问题" class="headerlink" title="房产投资的问题"></a>房产投资的问题</h2><p>感谢大家的支持，不少朋友还提了一些关于房产投资的问题。</p>
<p>我觉得无论做什么样的投资，自己一定要做足功课。就房产来说，对于区域经济发展，要有深刻的理解，否则就不要轻易出手。</p>
<p>关于房产，我只是从大方向上说了一下自己的判断，并没有对区域的房产升值做过研究，所以没法给大家提供建议，请大家谅解。</p>
<p>不过，关于房产投资的方向，也有几点心得：供大家参考：</p>
<p>一、坚决不能投资自己不熟悉的城市</p>
<p>二、坚决不投资中小城市，一般省会及计划单列以上城市问题都不大，但中小城市即使房价上涨也存在变现困难问题。</p>
<p>三、坚决不投资距离大城市较偏远的旅游城市，比如山东乳山之类的，几乎无法变现。</p>
<p>四、慎重投资大城市的郊区，除非价格绝对低。如果外来人口比较多，zf又有发展规划，且价格与城区相比有较大的价差，才可以考虑</p>
<h2 id="买房时机"><a href="#买房时机" class="headerlink" title="买房时机"></a>买房时机</h2><p>很多朋友都关心买房时机问题</p>
<p>对于自住需求者和投资需求者是要区别对待的</p>
<p>对于一线城市与二三线城市也是要区别对待的</p>
<p>对于自住需求者（仅指普通群众）来说，只要你还有钱能够买的起房，那你就买吧。不要赌博和赌气，因为真的赌不起。人人都可以买得起商品房，只是一个美丽的童话。当然如果你赶上了国家调控的好时机，那你就要认真选房，做足功课，迅速出手。因为买到一套户型、位置、楼层都让你满意的房子，在商品房热销期，是很难的事情，根本没有给你挑选的机会，而在调控期，或许房价没怎么下降，但绝对给了你挑选的余地。</p>
<p>对于投资来说，问题就比较复杂，要考虑的问题就会更多，不同条件的人就有不同的需求。</p>
<p>总的来说在严厉调控期，需要关注以下几点：</p>
<p>一、当新盘的价格低于周边二手房的价格。<br>二、当看房的人不断增加<br>三、当kas拿地热情大减，以至于多处土地流拍</p>
<p>以上三点是提示你准备出手的信号。</p>
<p>对于一线城市，一定会有一段时期小幅下跌，及跌后滞涨。</p>
<p>对于二三线城市，多数城市会缓步持续上涨。但遇到大规模拆迁的城市，那房价就会忽视调控，选择快速上涨。近期，在二三线城市，无论自住还是投资，都是早买好于晚买。</p>
<h2 id="关于调控"><a href="#关于调控" class="headerlink" title="关于调控"></a>关于调控</h2><p>短期的调控并不能改变长期上涨的趋势，</p>
<p>当资金的运作规律收到外力的压制，短暂低头的房价就会迎来暴涨。这是规律。</p>
<h2 id="普通人该怎么办？"><a href="#普通人该怎么办？" class="headerlink" title="普通人该怎么办？"></a>普通人该怎么办？</h2><blockquote>
<p><strong>被忽悠的群众：</strong></p>
<p>我们P民怎么办呢？只有买房保住自己的社会地位！？</p>
<p><strong>kkndme：</strong></p>
<p>问题是房子将会是普通人越来越难以参与的游戏，门槛越来越高。</p>
<p>只有努力工作赚钱才是唯一能抵抗通胀的办法，这也是zf最希望看到的。</p>
<p>当然体制内员工，工资制度本身就可以抵御通胀。这些多发出来的钱是需要体制外广大群众创造出来的，他们本身并不创造价值。</p>
<p>而体制外的广大群众要想抵御通胀，就必须努力工作，创造更大的价值来提高收入水平。</p>
<p>这也就是国家能够维持运转的根源所在啊</p>
</blockquote>
<blockquote>
<p><strong>feifeilongdi:</strong></p>
<p>请问楼主国家的收入分配改革调整的是哪一部分人的收入？</p>
<p>我们底层p民如果真的连公租房都只能勉强供得起，那以后子女的抚养费用，夫妻以后的养老资金如何解决</p>
<p><strong>kkndme：</strong></p>
<p>工资收入分配改革应该只是个说法，对公有制经济是很有实惠的。但非公有制员工的工资是阳光雨露都撒不到的。</p>
<p>以前说涨工资基本都是公务员，收入分配改革后可能对事业单位及国企工资收入有明显改善。</p>
<p>至于体制外，无论打工仔和个体户都是自生自灭的</p>
</blockquote>
<h2 id="体制外人员养老确实是个问题"><a href="#体制外人员养老确实是个问题" class="headerlink" title="体制外人员养老确实是个问题"></a>体制外人员养老确实是个问题</h2><p>做生意的赚钱养老<br>聪明的下手早的以房养老<br>最惨的是没有混上去，且又没有特殊技能的私企打工仔。养老实在是个大问题。<br>所以东部地区才有宁挣老板1000元，不赚打工5000块的说法。<br>双轨制下，低层群众想翻身确实比较难。</p>
<h2 id="懂政策的重要性"><a href="#懂政策的重要性" class="headerlink" title="懂政策的重要性"></a>懂政策的重要性</h2><p>刚从深山老林钻出来，终于找到地方洗澡了，我激动啊。</p>
<p>洗完澡轻松，讲一个刚从支书那里听来的故事。</p>
<p>大家普遍感觉很穷的贵州省榕江县栽麻乡宰荡村，在解放前却是有名的富裕村，他们靠勤劳开垦荒地，良田多到种不过来，直到土改后，zf将宰荡的良田分给了加所、林所等周围几个土地较少的村子的村民（这些村子土地少的原因主要还是周围几个村子的村民比较懒惰，宁肯受穷也不愿意开垦荒地），宰荡才穷下来。</p>
<p>因为宰荡村过去比较富裕，拨给的富农指标就比较多。有一户人家很富裕，按理应该划为富农，但这户人家很了解政策，知道评上富农就会挨整，于是走关系，成分改成了中农。</p>
<p>而其他大多数依靠勤劳致富的人家非常老实，也不懂评为富农有什么不好，认为什么成分都无所谓，还不是老老实实干活。结果可想而知。当上了富农接下来就是没完没了的批斗。</p>
<p>这个故事告诉我们，哪怕当个农民也必须了解zf的意图。</p>
<h2 id="存钱不如存房子、存木头、存树"><a href="#存钱不如存房子、存木头、存树" class="headerlink" title="存钱不如存房子、存木头、存树"></a>存钱不如存房子、存木头、存树</h2><p>去年在宰荡做了一段时间的田野调查，今年这次来算是回访。时过一年，发现去年村子附近的大多数农田，今年都变成了房子。</p>
<p>现在农民政策还是可以的，即使贫困如贵州山区，农民除了能够完全自给自足外，多余的粮食蔬菜也能换来一定的经济收入，随着家境变好了，对更大的房子的需求也就产生了，农民愿意把闲钱都用来盖成更大的房子，宁肯牺牲掉自有耕地。这其实是一件可怕的事情。</p>
<p>这次同样对村民做了入户调查，发现了一件有意思的事情。</p>
<p>村民最感到遗憾的事情就是早在2000年初，那时村里还没有电，村民为了想让全村通电，卖掉了所有山上的古树。电通了，当时的村民很高兴，而且认为古树卖了一个高价格（当时总共卖了6万块钱），换来了全村的生活方便。</p>
<p>大约在三年后，其他村寨，zf都给免费通了电。如果那些古树不卖掉，现在随便一颗的价格都超过了6万。现在那些古树至少值几百万。</p>
<p>村民们用最朴实无华的思想总结了一个道理：存钱不如存房子、存木头、存树</p>
<h2 id="政府不考虑民生"><a href="#政府不考虑民生" class="headerlink" title="政府不考虑民生"></a>政府不考虑民生</h2><p>全国人民都知道有个以雷厉风行著称的球书记</p>
<p>球书记曾说过一段著名的话，大意是：昆明的开发商拿地价格很低，卖的价格却很高，腐败才是高房价根源。</p>
<p>当时昆明的很多无房户都很鸡冻，以为这下可好了，找到问题根源了，昆明房价要降了。</p>
<p>可是我听到的意思却是：zf卖地卖得太低了，应该大幅提高土地价格。</p>
<p>果然不久就出台了54321政策，以前拿地没走招拍挂程序的，一律按照54321补交土地款，否则开发商不发放任何证件，以至于升级到已买了房的业主也拿不到房产证。</p>
<p>于是昆明的新盘由于手续问题都无法开盘，已经卖掉很久的老盘，开发商还要求业主补交房款，否则退房。</p>
<p>结果可想而知，昆明的房价以一环与二环之间为例，由去年下半年的6000多涨到现在的均价过万。</p>
<p>如果从民生着想，会做出这样荒唐的事来吗。</p>
<h2 id="再谈买房时机"><a href="#再谈买房时机" class="headerlink" title="再谈买房时机"></a>再谈买房时机</h2><p>帖子里有朋友问昆明的买房时机，我只能说越早买越好，因为dfzf想钱已经想疯了</p>
<h2 id="利益才是zf行为的指挥棒"><a href="#利益才是zf行为的指挥棒" class="headerlink" title="利益才是zf行为的指挥棒"></a>利益才是zf行为的指挥棒</h2><p>北大朱晓阳用了十多年时间跟踪昆明城中村，对刚刚建好5年的宏仁村就要因为商业利益而拆迁已经出离了愤怒，结果这事捅到CCAV曝光了，拆迁的事只好暂停。</p>
<p>利益才是zf行为的指挥棒</p>
<h2 id="买房应该关注什么？"><a href="#买房应该关注什么？" class="headerlink" title="买房应该关注什么？"></a>买房应该关注什么？</h2><p>说到买房子，无论投资还是自住，最重要的还是稀缺性，首选还是学区房。</p>
<p>自住最好买政府公务员小区，无论是商业配套，教育配套以及休闲娱乐配套都是商品房所无法比拟的。特别是商品房经过十几二十年，房子旧了，电梯很容易出故障，如果物业有问题或者小区里有人不交物业费，那么这个小区就很难住了。</p>
<p>公务员小区则完全不用考虑房子老旧的问题，那都是zf包干到底的。</p>
<blockquote>
<p><strong>usstcai：</strong></p>
<p>怎么找这种房源呢？</p>
<p><strong>kkndme:</strong></p>
<p>每个城市的情况不一样，北京基本上是单位的老公房，老计委的房，中石化的房都有上市交易的，但新房很难找。</p>
<p>至于二三线城市，现在还存在大量的公务员、垄断企业的新小区，并且很多房源都在市场上交易。比如昆明，存在大量的权贵小区，比如金江小区是省政府公务员小区，月牙塘小区是市政府公务员小区。</p>
</blockquote>
<h2 id="流氓无产者"><a href="#流氓无产者" class="headerlink" title="流氓无产者"></a>流氓无产者</h2><p>关于流氓无产者，在宰荡村子里还听了个故事</p>
<p>说很久以前的事情。</p>
<p>宰荡村民都很勤劳很淳朴。但是意外的出了一个叫罗老黑的人。</p>
<p>这个人好吃懒做无所事事，看见人家地里庄稼蔬菜长的好就跑去抢，为此挨过几次打。有一天罗老黑路上遇到个大兵，骗了大兵的枪，于是开始在村子里耀武扬威，不但抢人家辛辛苦苦种的菜，遇到单身的姑娘还动手动脚。</p>
<p>罗老黑在村里到处宣传他的逻辑：村里的庄稼、蔬菜、猪牛应该见者有份。</p>
<p>村里一些年轻人受了罗老黑的感染，开始变得好吃懒做，谁家种的东西都跑去拿。于是，村里人都不愿意劳动了，宰荡村开始变穷。</p>
<p>村里有个人很憎恨罗老黑的行为，但不敢明着跟王老黑作对，就在晚上在王老黑家放了一把火。侗族人住的房子都是杉木的，一旦一家着火，很可能全村遭殃，那把火烧了整个宰荡寨子，连青石板都烧裂了。</p>
<p>罗老黑，这个典型的流氓无产者，他的光荣事迹被当作反面教材激励着世世代代的宰荡村民。</p>
<blockquote>
<p><strong>zhuce010022:</strong></p>
<p>不合理的制度不会永远的存在下去的。。。正如国父当年说的一句“天下大势浩浩荡荡，顺之者昌，逆之者亡”。。。现在的高房价是目前中国的政治、经济结构失序造成的。楼主上面分析了那么多，确实是，在目前这种局面下可能一直冲到崩是唯一的选择，但是，你怎么知道这种失序的大局面会一直持续下去呢？</p>
<p><strong>kkndme:</strong></p>
<p>一个朝代从鼎盛到衰亡至少维持个一两百年。所谓天下大势分久必合，合久必分，由合到分，总还是有个时间跨度的。<br>侥幸能在有生之年平平安安就是最大的福气，身死之后，哪管洪水滔天</p>
</blockquote>
<blockquote>
<p><strong>错误角色:</strong></p>
<p>其实个人觉得普通炒房者不一定就能获多少利</p>
<p>比如他买一套新房是三千每平，等新房价到六千时出手，他能卖到五千每平。</p>
<p>看上去他每平赚了二千…但是，他要继续炒的话，就要再加每平一千的本金进去买新房…看上去他们是资产翻翻了，但是他们的二次投资也是翻翻的…也就是说他以前三十万买了一百平，现在卖出去是五十万，看上去赚了二十万，但是，他想再买个一百平的却需要六十万…</p>
<p>他还得从老本掏十万买同样大小的房子…这样算我也不知道对不对…要是对的话，就说明炒房的人不是抬高房价的最根本原因和最关键因素</p>
<p><strong>kkndme：</strong></p>
<p>你没考虑金融杠杆的作用</p>
<p>真正的投机炒房是贷款炒房，而投资客更愿意一次性付清。</p>
<p>一个炒房客用20万可以买100万的房子，等到200万卖掉，投入20多万，赚了170多万。</p>
<p>然后用变现的钱又可以贷款买多套，这就是投机炒房比股市更吸引人的地方，但是一旦资金链断掉就会比较惨。</p>
<p>这种赌徒心态的投机炒客还是比较遭人恨的，这次调控提高首付比例，对这类投机炒家打击不小。小资金的纯粹投机客数量控制在一个比较小的范围内，房产市场才会健康发展，这个国家是有共识的。所以二套房首付比例提高后，有可能变成常态</p>
</blockquote>
<h2 id="政府调控的目的与启示"><a href="#政府调控的目的与启示" class="headerlink" title="政府调控的目的与启示"></a>政府调控的目的与启示</h2><p>目前传言与辟谣越来越频繁，如何透过重重的迷雾看到事情背后的真相。</p>
<p>这次调控zy盯的主要还是一线城市，从提高首付比例，直到监管预售款的准备推出，都是为了提高房地产进入门槛，踢出大量小资金投资客，让小开发商民营开发商知难而退，为国家队入场铺路</p>
<p>zy需要稳定一线城市房价，使2012年能够顺利换届，为换届后的上涨留足空间。</p>
<p>有了国家队的后盾，zy无需因为调控导致部分小开发商资金链断掉而担心，相反这是zy希望看到的。</p>
<p>当然在政策和市场的博弈中，是否能够达到zy的预期，zy的心理也不一定完全有底，因为资金有他自己内在的规律。在打压房地产的同时，会带来农产品等生活必须品的价格全面上涨，这就需要xy做出一个权衡。因为填饱肚子的问题比房价的问题更重要。</p>
<p>多数二三线城市会在一线城市滞涨期间进行补涨，补足09年行情中远低于一线城市的涨幅。</p>
<p>作为二三线城市的刚需买房者，多数城市的情况都是早买胜于晚买</p>
<h2 id="个人的智慧和才干决定了个人的命运"><a href="#个人的智慧和才干决定了个人的命运" class="headerlink" title="个人的智慧和才干决定了个人的命运"></a>个人的智慧和才干决定了个人的命运</h2><p>领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运。</p>
<p>精英社会相对于法制社会存在更多的不稳定性，更崇尚个人能力、才干与职业精神，如果刘备只懂得眼泪是不可能得到三分天下的。</p>
<p>精英社会的根本就是以人治国，就是要承认人与人之间的差别。</p>
<p>百年战争，法国拥有全世界最强大的重骑士军团，可是由于统帅的无能，被英国长弓兵打得落花流水。</p>
<p>而耶路撒冷王国的鲍德温四世，一个年轻的麻风病人，率领几百个骑士打得萨拉丁三万马木流克骑兵溃不成军，几乎全军覆没。</p>
<p>一个人很可能决定一个国家的命运。</p>
<p>聪明智慧决定了人的眼界，有远见的人一定会未雨绸缪。</p>
<p>刘邦身为区区亭长可以得天下，朱元璋一个穷和尚驱除鞑虏重建朝廷，一个司机未尝不能当富商，一个小姐也可能当局长</p>
<h2 id="金钱至上"><a href="#金钱至上" class="headerlink" title="金钱至上"></a>金钱至上</h2><p>也许任何一个国家，甚至中国历史上任何一个朝代都没有象现在那样金权至上。</p>
<p>无论中国的儒家思想还是西方的骑士精神，都告诉人们，人总是要有所追求的，不能仅仅盯着钱。</p>
<p>秦时，有个老头叫郦食其，70多岁了还跑到刘邦大营参与革命，当然最后下场比较凄惨，被齐王煮了。郦老头本事很大，只身到齐国说服齐王归降了汉王刘邦。</p>
<p>韩信害怕郦老头功劳太高，超过自己，于是很不仗义，在郦老头人还在齐国的时候，带兵攻打了齐国。齐王很愤怒，后果很严重，把郦老头放在锅里煮了。郦老头的才能出众，本想做一番事业，可惜没有算到人类本性丑恶的一面。</p>
<p>当然韩信也没有好下场，这个军事上的天才，政治上的白痴，本来做了齐王，汉、楚、齐三足鼎立，结果向刘邦缴了枪，直接兔死狗烹了。</p>
<p>另一个喜欢没事找事的老头叫姚广孝，是个和尚，法号道衍。</p>
<p>虽是和尚，但既无和尚的慈悲心肠，又无和尚的遁世清修，这个老头专门搞权谋，不玩阳谋专玩阴谋，背靠朱棣这颗大树，不图名不图利，专搞武装夺取政权。</p>
<p>姚老头的头脑比郦老头高得多，不但是牛叉的阴谋家，也是牛叉的政治家，此人协助朱棣夺权后，深味帝王权术的精髓。</p>
<p>不立家室，不营产业，把一脑袋阴谋全都转向文化事业，跟大才子解缙纂修《永乐大典》，是为数不多投身权谋得了好死的大师级人物</p>
<h2 id="供求关系"><a href="#供求关系" class="headerlink" title="供求关系"></a>供求关系</h2><p>关于供求关系还是有必要解释一下的</p>
<p>一提起供求关系，马上口水就来了，什么空置率啦，闲置率啦，空置我心啦，电表显示6000万套房没人住啦。</p>
<p>实际上供求关系跟空置率和闲置率完全没有关系。</p>
<p>对于具备投资属性的商品，供求关系是指货币与商品之间的关系。当货币量大于商品供应量时，商品价格就会上涨，即使人为打压也是短期行为，这是铁律。</p>
<blockquote>
<p><strong>fantabulouski:</strong></p>
<p>楼主给点意见吧，想在上海市内环内买套二手房，现在出手合适嘛？等等的话可能跌点么？有没有什么风险吗？多谢！ 因为首套房可以贷款七成，多谢！！</p>
<p><strong>kkndme:</strong></p>
<p>如果手头有钱，又是自住，到不一定非要考虑抄在最底部。</p>
<p>因为钱要贬值是毋庸置疑的，房价在一段较长时期上涨的趋势也是毋庸置疑的。</p>
<p>但短期，波段性的抄底和逃顶是很难把握的，尤其是自住，考虑太多实在没有意义。</p>
<p>持币要冒房价持续上涨的风险，买房可能会面临短暂小幅下跌，哪个风险更大，需要自己认真考虑。</p>
<p>一线城市如上海一定会有短期的滞涨甚至小幅的下跌，当新房的价格低于周边二手房价，并且成交量开始逐渐攀升就是买房的时机。</p>
<p>我反复强调，这次调控期却是二三线城市的补涨期，对于一线城市正好可以仔细的挑选好房，这种机会在房价上升期是难以遇到的。</p>
<p><strong>fantabulouski:</strong></p>
<p>楼主再问一个问题，看看这一两天调控的信息满天飞，上海房产税的消息也到处都是，银行在不断的紧缩，感觉这次调控可是不同以往，是外松内紧啊，至少到年底前看不到放松的迹象，还什么情况下才可能会放松呢？难道要等到KQ 接班不成？</p>
<p><strong>kkndme:</strong></p>
<p>可以肯定的是首付款的比例是不会轻易放松的。房产税的推出就没那么容易了。</p>
<p>上海和北京城区的二手房价有点幅度的下跌几乎不可能，很长一段时间都会滞涨或者维持小幅度的上涨。手里资金多的人全款买房的比例大幅提高，精英阶层的购买力基本能够维持一线城市的正常的成交量（09年下半年的高成交量zy认为是反常的，已经影响了金融秩序，是zy不愿意看到的。）</p>
<p>现在的状况是，zy对调控后一线城市的房价增幅及成交量基本是满意的。</p>
</blockquote>
<blockquote>
<p><strong>黛眉轻：</strong></p>
<p>LZ厉害，分析得很透彻。</p>
<p>请教LZ，对于目前的合肥房价怎么看呢？</p>
<p>做为皖江城市带的中心城市，合肥的房价目前中心城区已经到了7000，也有了超过万元的所谓豪宅。和武汉长沙比起来，经济上感觉合肥还是差的，可是房价却已经不差了。</p>
<p><strong>kkndme：</strong></p>
<p>凡是大兴土木积极拆迁的城市，房价都低不了，城市发展规划的资金都要得益于dfzf卖地。</p>
<p>这是zf主导投资经济模式的必然结果。这也是二三线城市在这次调控中补涨的根本原因</p>
</blockquote>
<h2 id="拆迁补偿"><a href="#拆迁补偿" class="headerlink" title="拆迁补偿"></a>拆迁补偿</h2><blockquote>
<p><strong>welldayzwb：</strong></p>
<p>楼主我想请教一下：就是北京二三环甚至四环有不计其数的老式砖混板楼，年代分布从六七十年代到八十年代初的都有，这些房子都是北京城市发展的产物，也是北京留给土著们的天然福利。</p>
<p>但是现在有个问题是它们的房龄已经超过30年奔着40,50去了，这些房子的命运如何呢？拆迁吗？在原址上盖回迁房或者重新规划把里面的居民赶到周围郊区？</p>
<p>因为随着政策的收紧，这类房子越来越不容易流通了，银行不给贷款，升值空间也逐渐放缓，但是地段都非常好。是不是随着房龄的增加，这类房子只剩下保值功能而最终无法流通了呢？</p>
<p>这批房子最终会大规模寿终正寝，不知道dfzf会怎么处置？很想听听你的看法。</p>
<p><strong>kkndme：</strong></p>
<p>这个情况比较复杂，因为大多数老房子是各大部委的单位房。原则还是谁的孩子谁包干，谁的孩子谁认领。所以说买房子买到公务员小区最保险，即使房子旧了也不会没人管，也不会存在物业跑路、小区沦为贫民窟的问题，即使老房子拆了单位盖了高楼，保证会在原址上还你一套。</p>
<p>至于说单位不行了或者单位不存在了的老公房也是有的，早晚会走拆迁的路子，那就没有原址回迁那么幸运了，肯定是搬到远郊区县，但补偿条件肯定不差，离开城中心到郊区就成了富翁。</p>
<p>位置决定了价值。北京郊区农民房拆迁补偿两万一平就算高的，但是城中心房屋拆迁，补偿款那都是10万一平起步的。愿意一掷千金全款买城中心老房子的人只会多不会少，说白了就是：哥买的不是房子，是位置。</p>
</blockquote>
<blockquote>
<p><strong>汝爱之罪：</strong></p>
<p>北京七八十年代的砖混老房有体制内的，也有体制外的。现在公房上市流通，好多央产房也易主了，也许过个十年二十年的这批房子的产权证上早已换了一波又一波人。除非像楼主所说的昆明那种大型的省市公务员小区，房子新，户型好，环境和地理位置都不错，一般公务员没个20年轻易不会卖。</p>
<p>北京的这些老楼，不管谁是房主，肯定值钱，房子不值钱，位置还值钱呢。</p>
<p>至于这些房子使用寿命到了以后怎么处置，谁也说不清，能不能回迁，要看dfzf和规划局的利益。比如眼下金融街西侧月坛的老房子就要被集体拆除，连中学都要搬迁，这些西城人很有可能被撵到昌平回龙观西去，那边已经在建大批安置房了。</p>
<p>所以说，这些老房子不管是体制内的还是体制外的，命运如何不在自己手里。即使体制内的比较不错的老小区（比如三里河的建设部小区），如果牵涉到地方的利益，肯定也是毫不犹豫全部拆除，除非那里面住着实权人物当官的不让拆。这个时候就要看这些被拆迁户的谈判能力了，谈判能力强的，当个钉子户，当然是要得越多越好。</p>
<p>我以前买房的时候，也想了这些，不过最后还是买了新楼。现在因为地皮的价值，北京新老楼的房价差距不大，这个在别的城市是不可思议的。</p>
<p>很感谢楼主发这么一个帖子，版主还给了个绿脸，要不然可能就错过拜读的机会了</p>
<p>其实有些问题平时自己也在思考，比如GDP为什么保八，房价和滥发纸币等等，但是关于炒房和房租这一块，思考的并不多，而楼主的帖子比较有条理和逻辑的分析了这些方面，真的是很感谢，我甚至不用自己写分析，只要把楼主的帖子稍微整理，就是一篇很不错的分析资料了。</p>
<p>关于zf收紧口子，抬高小老百姓炒房门槛这一块，天涯房观有几个高人和楼主的看法一致。我细细想了一下，这个提高首付到50%的政策，确实会成为长期政策保持下去，而其实即使没有这个政策，稳健型的小老百姓也会掂量自己的钱袋买房。没有谁想断供，因为刚需需要房子。</p>
<p>至于以后十年甚至更长时间，房价仍然会涨。因为城市的发展离不开勤劳的人民，zf在不断的修建地铁画大饼，就是为了土地能卖个好价钱，只有不断的卖地搞铁公鸡，才会有gdp，才会有政绩。统治阶级带着他的各种利益集团一起玩，而老百姓以后可玩之物会越来越少，只能老老实实的干活挣钱。</p>
<p>由于家人的优柔寡断和缺乏对北京房地产现实的认识，我直到今年初才在四环买了第一套房，3w多的均价，让家里背负了100多w的债务。我错过了07年1w的机会，和09年1w+的机会。世上没有后悔药，历史也不会重演，那些07年买房和09年买房的人是幸运的。我现在努力攒钱挣钱的同时，最希望看到的事情居然是房价尽快远离我的成本区，我知道没有买房的同学一定会抨击我这种想法，但是现实就是这样可笑，一方面希望房价能降，这样可以把老人接到身边，另一方面又希望房价涨，这样自己在还贷的时候心里稍微能好受点。呵呵，不知道自己这样是不是活得太累。</p>
<p>不管怎么说，希望大家都能住上自己称心如意的房子，这几年来，zf真把我们这些人折腾的够呛。我和家人都是传说中的体制内，体制内确实有福利，可惜要想自己的财富不缩水，还得靠自己。</p>
</blockquote>
<p>关于拆迁补偿的事，巨大的利益驱使，那真是鲜血淋淋的。所以二手老房买在哪里很重要。银行的房、zf的房、各大部位的房，有上市交易的，买下来肯定不会吃亏。</p>
<p>存在风险的就是弱势群体聚居区。但是北京，毕竟天子脚下，不能搞得太僵，最终该补的还是会补到位，至于外省就很不好说了</p>
<h2 id="执政者如何治国"><a href="#执政者如何治国" class="headerlink" title="执政者如何治国"></a>执政者如何治国</h2><blockquote>
<p><strong>傻子也疯狂:</strong></p>
<p>今天看到新闻<br>什么房产市场回暖啊<br>温州炒房团又出江湖了<br>成交均价上涨啊</p>
<p>请问这个是真的吗，房价会在短时间涨上去吗<br>如果是真的，那中央调控有什么用，在没有下降的基础上再涨10%<br>不是自己打自己嘴巴吗</p>
<p>很想听听楼主怎么看待这个事情。</p>
<p><strong>kkndme:</strong></p>
<p>维持在正常成交量，保持一个缓步上涨的趋势，是zy最愿意看到的。因为zy很清楚，除非体制上有大动作，否则让房价下跌只是唱给人听的口号。体制是不能动摇的根本，是国家稳定的基础，高房价是体制造成的必然结果。zy很清楚，最好的方式就是以一个平缓的速度增长。但是决策者是不是有此能力控制房价缓慢上涨，这是值得仔细研究的。</p>
<p>任何一个朝代，即使是我们在电影里常看到的奸佞当权，往往政策的初衷都是好的，但是执行效果却常常适得其反，领袖的智慧与执政能力对国家的命运起着至关重要的作用。</p>
<p>明朝朱厚照时期有个太监刘瑾，权势一手遮天，是个典型的奸佞。但他其实是很想做点事情的。</p>
<p>明朝开国时，朱元璋搞了个戍边屯田，相当于现在的军垦，因为军队自给自足，给国家省了大笔的银子。但是到了后来，军官们都变成了大地主，霸占了士兵的土地，把士兵当作佃农，依靠盘剥士兵来实现让一部分人先富起来的号召。这是与杀良冒功、贪吃空饷并列齐名的第三大快速发家致富手段。</p>
<p>我们说了刘瑾是个有雄心壮志，很想做点事业的高责任心人士。对于军官霸占士兵田产导致士气低下这件事很看不惯，很不满意。决定坚决打击这种行为。于是下令地方zf</p>
<p>清理军官霸占田产的问题。</p>
<p>军官霸占的田产不仅仅是士兵的，更多的是当地老百姓的。</p>
<p>按理说，这应该是个老百姓叫好的政策，而事实上这是老百姓头上的噩梦。</p>
<p>执行人是谁？地方官。</p>
<p>地方官执行的时候就实在为难了，军官老爷手里都是握着重兵的，你上门还没开口，兵大爷的刀已经架在脖子上了。</p>
<p>可是刘瑾刘老板下达命令的同时，还是要下达任务指标的，没收的田产有任务指标，以前军官老爷占有的田都不交税，既然清理田产就要交税，交税也有任务指标。</p>
<p>有些地方官比较聪明，不敢找军官大爷收，就摊派给了老百姓，结果老百姓又交田又交税，自然是连活路都没了。</p>
<p>有些地方官脑子不清醒，真的跑去找军官老爷要田要税，结果造成军官勾结宁王造了反，最后刘瑾自己的脑袋也保不住了。</p>
<p>历朝历代，统治者代表的都是地主阶级的利益。历朝历代的改革都只是为了缓和底层群众与地主阶级的矛盾，防止因为过激发生极端群体性事件。</p>
<p>调控也是为了缓和矛盾，要温水煮青蛙，而不要一把火把青蛙烧死。</p>
<p>关于自己打自己嘴巴的事，那是太多了，自古以来，统治者也从来不怕自己打自己嘴巴。古人就总结过，只准州官放火，不准百姓点灯。</p>
<p>以前的科举制度与现在的公务员考试制度基本目的都是相同的，让全天下的优秀的和不优秀但有出身的知识分子依附于官，这样就有了绝对的话语权。</p>
<p>无法进入体制内的知识分子，有商业头脑和技术专长的人员，就相当于过去的商人、小作坊主，尽管也许还算富裕，但是没有任何地位，任人支配。</p>
<p>要是没有一技之长，又不能经商，就基本上在社会的最底层很难翻身，相当于过去城市里的贩夫走卒，甚至无片瓦立锥，糊口都是困难，地位和稳定性反而远远不如自给自足，拥有宅基地的农民。</p>
<p><strong>中年不惑吗：</strong></p>
<p>说到底空空太幼稚了，当年拖拉机之夜太学生怎么也想不到机关枪和拖拉机真的会招呼到自己身上，这和他们从小接受到的教育不一样呀。</p>
<p>主流宣传中party妈妈都是慈祥的温柔的全心全意为p民服务的</p>
<blockquote>
<p><strong>kkndme:</strong></p>
<p>这就是中西方的不同，西方的拖拉机是对外的，中国的拖拉机从来对的都是p民，对外基本比较忪。</p>
<p>所以才有元和清，明明是外族入侵灭了国，还要把蒙古人和女真人一起拉进来统一叫中华民族，居然认为中华民族很强大，元朝时一直打到亚得里亚海。也不管蒙古人跟中华的两河文明有关系没有。</p>
</blockquote>
<p>有皇帝大力支持的王安石变法到了地方法令也大变味，如今虎温的威权要远远小于当年的宋神宗和王安石，而且统治阶层从上到下的改革从来是为了巩固统治地位，至于p民收益那从来都是附属作用。</p>
</blockquote>
<blockquote>
<p><strong>汝爱之罪：</strong></p>
<p>其实，几千年来，唱的都是同样的戏，只不过台上的演员变换而已。</p>
<p><strong>kkndme：</strong></p>
<p>赞赏这一句，呵呵，历史规律是不变的，变化的只是时间、地点、人物、事件。</p>
<p>城头变换大王旗。</p>
<p><strong>tjOOSAN：</strong></p>
<p>历史规律是不变！但他妈世界变了！~~ 中国采用资本主义制度了</p>
<p>还只参考中国历史？</p>
<p><strong>kkndme：</strong></p>
<p>你知道什么叫资本主义制度吗？</p>
<p>首先基础是三权分立。</p>
<p>早在1748年，孟德斯鸠男爵发表了伟大的划时代的巨著“论法的精神”明确提出了三权分立。奠定了资本主义制度的基础。</p>
<p>三权分立制度就是国家的立法、行政、司法三权分别由三个机关独立行使，并相互制衡的制度。讲的是法律精神，讲得是私人财产神圣不可侵犯。</p>
<p>而作为一个人治而非法制国家，怎么能说是资本主义呢？</p>
<p>建议个别不读书，不研究，不了解中西方历史，不懂经济，对社会制度基本的理解基本是个白痴的同志，就不要乱发表议论了，惹人笑话。</p>
</blockquote>
<p>无论是中国还是西方历史对现在都是很有借鉴意义的。这就使毛说过的“古为今用，洋为中用”，毛建的武装斗争及建国思想其实很大程度来自于朱元璋。</p>
<p>古代君主统治国家征服世界靠战争武器，现在则靠金融武器。</p>
<p>西方，我们所熟悉的具备最纯正贵族血统的哈布斯堡家族，曾经的德意志王国和神圣罗马帝国的统治者，家族成员曾经统治过欧洲诸国：包括波希米亚王国 、匈牙利王国 、克罗地亚及斯洛文尼亚王国、伦巴第及威尼斯王国 、奥地利皇室领地 、萨尔茨堡公国 、塞尔维亚及塔米斯-巴纳特公国等等无数欧洲国家。</p>
<p>而现在，哈布斯堡家族控制着华尔街，继而通过华尔街控制着全球的经济。</p>
<p>历史是在继承的前提下发展的，特别是在西方，现在几乎每一个显赫的家族都能追根溯源。因为尽管西方也发生大革命，但是象文革一样彻底否定历史是完全不可思议的。</p>
<p>我们有点英雄情结的人听到最多的西方中世纪十字军三大骑士团：圣殿骑士团、条顿骑士图案、医院骑士团；直到现在仍有两大骑士团存在。</p>
<p>条顿骑士团总部现在还在德国，专门从事慈善事业。医院骑士团后来改名为马耳他骑士团，也就是现在的马耳他，世博会还来上海参展。只有圣殿骑士团灰飞烟灭，但现在仍有大量的修士组织自称为圣殿骑士团的继承人。</p>
<p>完全不懂历史，就等于完全不懂得社会。</p>
<blockquote>
<p><strong>肖肖19850706:</strong></p>
<p>楼主虽然有很多观点写的很有道理，但是对于历史这块，并不太正确</p>
<p>引用一段楼主的话：</p>
<blockquote>
<p><strong>kkndme:</strong></p>
<p>自古以来，民生问题的底线就是不要出现陈胜吴广的极端情况。所以zf更在意的是农民问题。<br>因为历史的改朝换代都是大饥荒引起的，无论是汉末、唐末、隋末、还是明末。农产品价格上涨的对zf的震动要远远大于房价的上涨。<br>农民具备最原始的力量，而他们关心的并不是三线以上城市的房价，而是能否填饱肚子。<br>而关心自己能否拥有一套产权房的都市白领，除了呻吟一下意外，几乎是没有什么有效反抗的可能的。</p>
</blockquote>
<p>其实在当今政权建立之前，还有一个政权，叫做中华民国<br>这个政权是由民主革命带来的<br>他们所举的旗帜是资产阶级革命，所建立的政权是资本主义社会<br>为什么会失败？<br>这是一个值得思考的问题<br>让一个经历了5000年封建社会的国家经过一次革命就达到资本主义社会的境界<br>没有工业革命的基础<br>没有原始的积累<br>有的只是借鉴西方<br>想先变制度再进行调整，结果固然是失败<br>于是“农民起义”卷土重来，我想大家肯定明白“农民”所指的是什么<br>于是又了现在的这个政权<br>由工人阶级和资产阶级去推翻帝制<br>再由农民阶级把土地抢回来，最终回到封建政权来压迫资产阶级<br>他们最怕的还是农民么？<br>显然不再是了<br>他们最怕的正是资产阶级<br>其次就是你说的那些<br>“关心自己能否拥有一套产权房，除了呻吟一下意外，几乎是没有什么有效反抗的可能的都市白领”<br>攻占巴士底狱的不是农民<br>正是这些“几乎没有什么有效反抗可能的都市白领”<br>是工人阶级结束了地球上长达上千年的封建统治<br>而改革开放，市场经济的发展，给了这一切充足的物质基础<br>社会的转化过程有两种<br>一种是和平演变<br>一种就是革命</p>
<p>现在所存在的问题，不是他们更怕谁<br>而是他们选择面对哪种演变方式</p>
<p><strong>kkndme:</strong></p>
<p>最可怕的不是农民而是失去土地的农民。</p>
<p>为什么说新民主主义革命是工人阶级领导的？</p>
<p>那时的工人阶级是什么？就是失去土地的农民和破产的手工业者，除了体力一无所有，所以他们才具备脑袋掖在裤腰带上，为了抢土地而玩命的动力。解放战争时期，我军的宣传就是：“同志们，国民党要把分给你们的土地抢走，你们说怎么办？”于是广大失去土地的农民兄弟不干了，玩命了。</p>
<p>工农红军一四方面军胜利会师，在选择南下和北上发生了分歧，真的为了北上抗日吗？1935年抗日战争还没有打响，日本人在东北而不是西北。北上抗日的说法实在有些牵强。</p>
<p>我想真正的原因还是群众基础。</p>
<p>近几年多次在西南地区的乡村进行田野调查，发现一个问题：解放前，即使如贵州山区的偏僻乡村，农民自给自足吃饱肚子是完全没有问题的，更别说富庶的四川平原。</p>
<p>那时参加红军要有不要脑袋的玩命精神，对于多数能够填饱肚子的农民来说，主动参加革命显然是不现实的。红军在西南地区完全没有群众基础，战斗中的减员得不到有效的补充，所以人才会越打越少。</p>
<p>而西北地区完全不同，自然条件恶劣，农村耕地很少，存在大量食不果腹，无地可种的农民。李自成起义也是从陕西发起的，可以说具备了随时发动武装暴动的群众基础。所以毛选择了北上的正确路线。而张同志南下凄惨的下场印证了毛的正确判断。</p>
<p>北上延安的另一个重要原因是获得苏联的支持，没有强大的后援是无法取得决定性胜利的。</p>
<p>一旦农民失去了土地，而又没有去处，那是相当可怕的，所以农民工就业问题是zy最为关注的。甚至提出如何让农民工在城镇买房子置业，处理好农民问题，是社会稳定的重中之重。</p>
<p>将来，有地可耕的农民将会成为都市中的底层群众羡慕的对象，农民有地有住宅有粮食。进可以在城市打工，有聪明的甚至通过经商迈进富人阶层，退可以回乡种田，虽然现钱不多，但是吃穿住行都是没有问题的。</p>
<p>而真正一无所有的将是大量在都市中沦为贫困的人群。在打拼挣扎的打工仔，如果没有能力购置房产，也没有得到向上爬的机会，在都市立足将变得困难，而又毫无退路。</p>
<blockquote>
<p><strong>我是天天念经:</strong></p>
<p>收入分配改革方案下月定稿 二次分配成重点。党中央终于回到正确的道路上来，以贪官污吏和强势群体为主要来源的二会代表妄图把房价问题炒成最热，来掩盖收入不公的根本，终于没有得逞。</p>
<p>对楼主的佩服之情，尤如滔滔江水，连绵不绝，又如黄河绝堤，一发而不可收。<br>强烈建议楼主改个容易记住的名字，便于查阅。</p>
</blockquote>
</blockquote>
<p>讲个故事，可能这个故事很多人都看过，并且曾经多次被转帖：</p>
<p>宇文泰是北周开国的奠基者。当他模仿曹操，作北魏的丞相而“挟天子令诸侯”之时，遇到了可与诸葛亮和王猛齐名的苏绰。宇文泰向苏绰讨教治国之道，二人密谈 三日三夜。</p>
<p>宇文泰问：“国何以立？”</p>
<p>苏绰答：“具官。”</p>
<p>宇文泰问：“如何具官？”</p>
<p>苏绰答：“用贪官，反贪官。 ”</p>
<p>宇文泰不解的问：“为什么要用贪官？”</p>
<p>苏绰答：“你要想叫别人为你卖命，就必须给人家好处。而你又没有那么多钱给他们，那就给他权，叫他用手中的权去搜刮民脂民膏，他不就得到好处了吗？”</p>
<p>宇文泰问：“贪官用我给的权得到了好处，又会给我带来什么好处？”</p>
<p>苏绰答：“因为他能得到好处是因为你给的权，所以，他为了保住自己的好处就必须维护你的权。那么，你的统治不就牢固了吗。你要知道皇帝人人想坐，如果没有贪官维护你的政权，那么你还怎么巩固统治？”</p>
<p>宇文泰恍然大悟，接着不解的问道：“既然用了贪官，为什么还要反呢？”</p>
<p>苏绰答：“这就是权术的精髓所在。要用贪官，就必须反贪官。只有这样才能欺骗民众，才能巩固政权。”宇文泰闻听此语大惑，兴奋不已的说：“爱卿快说说其中的奥秘。”</p>
<p>苏绰答：“这有两个好处：其一、天下哪有不贪的官？官不怕贪，怕的是不听你的话。以反贪官为名，消除不听你话的贪官，保留听你话的贪官。这样既可以消除异己，巩固你的权力，又可以得到人民对你的拥戴。其二、官吏只要贪墨，他的把柄就在你的手中。他敢背叛你，你就以贪墨为借口灭了他。贪官怕你灭了他，就只有乖乖听你的话。所以，‘反贪官 ’是你用来驾御贪官的法宝。如果你不用贪官，你就失去了‘反贪官’这个法宝，那么你还怎么驾御官吏？如果人人皆是清官，深得人民拥戴，他不听话，你没有借口除掉他；即使硬去除掉，也会引来民情骚动。所以必须用贪官，你才可以清理官僚队伍，使其成为清一色的拥护你的人。”</p>
<p>他又对宇文泰说：“还有呢？”</p>
<p>宇文泰瞪圆了眼问： “还有什么？”</p>
<p>苏绰答：“如果你用贪官而招惹民怨怎么办？”宇文泰一惊，这却没有想到，便问：“ 有何妙计可除此患？”</p>
<p>苏绰答：“祭起反贪大旗，加大宣传力度，证明你心系黎民。让民众误认为你是好的，而不好的是那些官吏，把责任都推到这些他们的身上，千万不要让民众认为你是任用贪官的元凶。你必须叫民众认为，你是好的。社会出现这么多问题，不是你不想搞好，而是下面的官吏不好好执行</p>
<h2 id="10-年房地产调控"><a href="#10-年房地产调控" class="headerlink" title="10 年房地产调控"></a>10 年房地产调控</h2><p>这次调控与08年调控后的结果是有所区别的。08年调控的结果是一线城市的暴涨；而2010年调控的结果是房价以二三线城市为主的全面上涨。不但是二三线城市，高房价甚至已经传到至四线及以下城市。</p>
<p>在二三线以下城市，无房户的需求其实并不大，真正的刚需来自改善性住房。</p>
<p>城市升级使人们开始不满足过去老旧式住房的居住环境，开始追求大盘大开放商的品质住宅。房价也由此迎来全面上涨。这种全面上涨，不能理解为全面泡沫，而是有基础存在的。不能理解为全国炒房。</p>
<p>特别是四线及以下城市尽管新盘价格高涨，老旧住宅却乏人问津，县级市二手房变现也比较困难。</p>
<p>在2010年的调控的大背景下，却神奇的出现了二三线以下城市的刚需大量释放现象，不得不令人叹为观止。这神秘的幕后推手其实就是资金的规律。</p>
<p>对于在2010年初布局二三线城市的房开商和有远见的投资者，在这次调控中，无疑是受益者。</p>
<p>一线城市，这次调控给刚需买房者一个最好的入市良机，但是能够抓得住的只是少数。</p>
<blockquote>
<p><strong>tianxiaobing11：</strong></p>
<p>请问楼主，房价会在年底重新确立上涨趋势吗？</p>
<p>如果再不涨，政府的地卖不上好价钱，地方财政就回吃紧，地方政府还会像去年那样出各种政策救市吗</p>
<blockquote>
<p><strong>九五二七八：</strong></p>
<p>全国各地 一线二线三线 情况都有不同<br>楼主预测时点 怕不好预测啊</p>
<p><strong>kkndme:</strong></p>
<p>不但是不同城市情况有区别，同一城市的不同区位情况也有区别。就拿北京来说，过渡爆炒的通州房山等远郊区县，房价一定会有所回调，但是城市中心，特别是学区房是没有下降可能的。</p>
<p>而对于多数二三线城市，均价下降的原因主要还是远郊区的房源投放量增加，城区内的房子不但不降，而且涨得还很厉害。</p>
<p>房产投资最重要的还是位置，当远郊区县的房价远低于城中心的时候，一定会有补涨的要求，但当远郊区县的房价向城中心接近的时候，一定会出现城中心的补涨，当然在调控期也会体现为远郊区县房价的回调。</p>
</blockquote>
<p><strong>kkndme：</strong></p>
<p>仔细看一下各地的房价，不要被公布的所谓均价迷惑，只有少部分城市价格下降或者持平，多数城市都在上涨，只不过幅度不大而已。</p>
<p>现在成交量属于正常水平，不存在dfzf吃紧的问题，当然不可能象09年那样的疯狂，09年底甚至银行出现无款可贷，太高的成交量会被zy视为危险的信号，是达到危害金融安全的高度的。</p>
</blockquote>
<h2 id="关于房贷"><a href="#关于房贷" class="headerlink" title="关于房贷"></a>关于房贷</h2><blockquote>
<p><strong>四环四环:</strong></p>
<p>眼下商业贷款贷款46万。<br>分20年还，月供3066<br>分30年还，月供2562</p>
<p>朋友劝我贷款时间越长月供越少越好。<br>直觉判断我觉得也是这样。<br>有科学依据么？</p>
<p><strong>kkndme:</strong></p>
<p>你的朋友考虑是有道理的。</p>
<p>如果不考虑通货膨胀，当然是利息越少越好，20年还的利息要少于30年还的利息。</p>
<p>但是因为通货膨胀的因素，我国是高增长高通胀的国家，每年的通胀率远远大于实际公布的数字，更远远高于贷款利息，所以贷款时间越长越好。</p>
<p>至于月供是否越少越好，完全取决于个人的承受能力，有条件当然买大房子，宁肯月供多一点。但是条件不够就买小的，量力而行。</p>
<p><strong>四环四环:</strong></p>
<p>谢谢楼主指点。</p>
<p>假设通胀率有一个固定值（当然实际这是没有的，它也是个取决于经济规律和国家意志的不确定因素）、贷款利息有一个值。<br>完后不同的贷款年限。<br>就能估算出两个值此消彼长。</p>
<p>需要选择判断的是，通胀率这个值的数字。<br>但通过对国际意志不确定因素极端情况的估算，预计这个值。</p>
<p>完后把这变成一个数学题。</p>
<p>是这意思么？</p>
<p>那不用算了，按常识，知道该怎么选了。</p>
<p><strong>kkndme:</strong></p>
<p>银行贷款的年限越高，利息支出越高，但不会高过通胀。你能贷30年就贷30年，这是你年轻的优势。年纪大点的就只能贷25年，甚至20年了。</p>
<p>所以说40岁买房的人很不靠谱，首先40岁的人不一定有钱，反而错过了最敢买房的黄金年龄。其次是40岁贷款年限就短了好多，相当于月供压力更大了。</p>
</blockquote>
<p>以后，商品房本来就变成了富人间的游戏，普通人将不能卖进参与的门槛。</p>
<p>到多数人真的买不起房时也就安心了，也不用关心房价的涨跌了。</p>
<p>但是现在，房价还没有到那个高度，很多人还觉得有希望，所以对房价的涨跌才会特别关注。这个时期应该就是普通人最后买房的机会。错过了，将不会再有。</p>
<h2 id="关于商铺投资"><a href="#关于商铺投资" class="headerlink" title="关于商铺投资"></a>关于商铺投资</h2><blockquote>
<p><strong>马甲马甲_马马甲：</strong></p>
<p>请教楼主：</p>
<p>因为种种原因， 错过了很多买房的好时期，现在租房住，（ 享受到了朋友提供的体制内的好处， 远低于市场价格租了一套房子）。</p>
<p>手上200万左右的现金， 在上海，想买房子保值增值，</p>
<p>1，有套著名大学附近的二手房子，57平米， 130万左右，估计租金大约是2.5万-3万 之间，<br>2，在市中心成熟的商业区有个店铺， 124万， 年租金现在是6.4万一年。</p>
<p>2个选择， 个人倾向于投资店铺， 因为在上海店铺的涨价远远低于住宅的涨幅，况且店铺的资金回报率也达到了 5% ，不知道楼主是否有更好的建议？</p>
<p><strong>kkndme：</strong></p>
<p>很多人不愿意投资商铺还是在于风险大，好位置熟铺是很少有人愿意拿出来卖的，谁愿意放弃生蛋的母鸡呢？</p>
<p>而新开发的商铺要不然位置比较偏，不知道能不能做的起来，要不然就溢价太高，超出了大多数人的承受。好的商铺是市面上很难买到的。</p>
<p>如果经过考察确认商铺没有问题，还是首选商铺，但是一定要经过认真的考察。</p>
<p>而住宅的风险就相对小多了，而且投资不需要很多的经验，更适合一般投资者。</p>
</blockquote>
<h2 id="关于房产税"><a href="#关于房产税" class="headerlink" title="关于房产税"></a>关于房产税</h2><blockquote>
<p><strong>tianxiaobing11:</strong></p>
<p>还有一问题请教楼主，目前我一共有三套房，一套自己住，一套父母住，一套是投资房，在大连最繁华的地方，租金回报是百分之六点五。</p>
<p>请问房产税会很快推出吗？我的那套投资房是卖掉还是持有呢？卖的话能赚白分之五十</p>
<p><strong>kkndme：</strong></p>
<p>在卖掉之前，你要先问问自己，拿这笔钱打算干什么？如果没的可做，干等着贬值，那你为什么要卖呢？</p>
<p>如果你有更好的投资或者创业渠道，那当然立刻卖掉，不用犹豫。</p>
<p>至于房产税，第一：近两年一定不会征收，因为条件还不成熟。第二：房产税只是一项苛捐杂税，目的是补充财政收入，并没有降低房价和租金的功能，并且只能导致租金的上涨。怕房产税的应该是租客，而不是房东。</p>
</blockquote>
<p>任何税种最终都要转嫁到社会最底层群众身上。丛林法则实际就是大鱼吃小鱼，小鱼吃虾米。</p>
<p>上层人士的享受是靠底层群众勒紧裤腰带过日子换来的。</p>
<h2 id="关于拆迁"><a href="#关于拆迁" class="headerlink" title="关于拆迁"></a>关于拆迁</h2><blockquote>
<p><strong>wofuleyumin1：</strong></p>
<p>从头至尾，一口气看完了。。赞同之极。。。</p>
<p>也向楼主问些问题。。。</p>
<p>是否老公房都会拆迁？<br>在成都，一环，二环内还有非常多的老公房，总量比商品房还多，这么多的房子都会拆迁吗？<br>我在想是否先买套老公房。。因为价格也便宜。新的商品房一般八九千。。老公房才5千多。买了后灯拆迁。</p>
<p>但这么多老公房都会拆迁吗？我觉得可能很多房子是不会拆迁的吧？否则只要现在买这些房子，以后都发财了。</p>
<p>是否拆迁的只是很少部分？</p>
<p><strong>kkndme：</strong></p>
<p>将来多数房都会拆迁，这是中国体制和经济发展模式决定的。在城市拆迁改造升级过程中，大量的老房拆毁，大量的新房拔地而起。而随着拆迁改造的成本的上升，房子也越来越贵。</p>
<p>现在拆迁改造集中建设70-90的小户型，将来会沦为新的城中村，通过二手置换，这类房子会变成新的贫民窟，而将来的拆迁改造建设的一定是追求环境品质的大户型。</p>
<p>因为zf官员任期的限制，决定了官员的短视，决定了城市规划的短视。</p>
<p>但是市中心的房子，即使在将来人口下降的过程中，仍然是稀缺的，房价高不可攀的。如果手有余钱首选的是市中心的大户型。</p>
<p>关于市中心老旧二手房的购买，还是有一定学问的，一定要选择位置好，低密度的矮层住宅楼，因为密度低，便于拆迁。而密度高的塔楼拆迁非常困难，拆迁成本太高，开发商很难有利可图。现在住在市中心高层旧式塔楼的富裕人口，将来一定会二次置业，这些旧式塔楼逐渐会沦为新一代年轻中产阶层的过渡性住房。</p>
<p><strong>wofuleyumin1：</strong></p>
<p>楼主。。谢谢你的答复</p>
<p>我接着问</p>
<p>你说现在投资是投资一套新房好，，还是找个老公房投资？</p>
<p>新房，，一切都好，但价格贵。。</p>
<p>老公房，一切都不好，但价格便宜。。主要是等拆迁。。但可能要等七八年。。（从我近2年的观察，一般都要这么久。。除非有内部消息）</p>
<p><strong>kkndme:</strong></p>
<p>有钱当然是新房舒服。</p>
<p>老公房如果是学区房，随着住着不舒服但是不影响小孩上学。至于啥时拆迁那真是有年头等了。运气好，三年五年，运气不好十年八年。</p>
<p>关键是拆迁后，原地回迁是很难的，拆迁后安置一般都到远郊区县。如果碰上个铁腕书记，拆迁还真不见的能得什么便宜。条件还没谈好，推土机就开来了。</p>
<p><strong>wofuleyumin1：</strong></p>
<p>有钱当然是新房舒服。<br>老公房如果是学区房，随着住着不舒服但是不影响小孩上学。至于啥时拆迁那真是有年头等了。运气好，三年五年，运气不好十年八年。关键是拆迁后，原地回迁是很难的，拆迁后安置一般都到远郊区县。如果碰上个铁腕书记，拆迁还真不见的能得什么便宜。条件还没谈好，推土机就开来了。<br>。。。。。。。。。。。。。。。。。。。</p>
<p>楼主的意思是。。还是投资新房比较好？</p>
<p><strong>kkndme：</strong></p>
<p>还是量力而行，买老公房也比不买强，有条件当然买新房。</p>
</blockquote>
<blockquote>
<p><strong>wofuleyumin1：</strong></p>
<p>楼主。。。又有一个问题</p>
<p>我附近的普通房子大概9000 旁边有个02年的别墅现在13000 现在又有一个新的楼盘开盘了。。是电梯 容积3 十多层的 是中海的高端项目，装修过的 居然卖将近2万。。。离谱吗？旁边容积0.8的老别墅才13000啊 </p>
<p>请问中海这个项目是否价格过高？ 另外，这个项目对我这附近的房价能拉动多少？</p>
<p><strong>kkndme:</strong></p>
<p>高端房产，开发商都是不急着卖的，而且也从来不乏有钱人慷慨解囊。你说的情况跟昆明的空间俊园完全相同。在市中心徘徊在万元关口的时候，空间俊园直接开出了19000的均价，之后市中心的二手房紧随攀升到15000.而一环二环间的房价在万元关口徘徊。</p>
<p>大盘高端盘对房价的带动作用是显而易见的。</p>
<p>自调控刚刚推出的时候，与一个朋友闲聊，说起调控将是二三线城市大涨的机会，还聊了聊昆明的发展，结果那个朋友头顶调控的大棒，去昆明投了n套房产，当时价格7000多点，时过几个月，现在看房价已经涨到9000.而且他买的位置周边先后有高端大盘推出，预计开盘价格在12000-15000，一旦高端大盘开盘将让他买的房子直接迈上万元的台阶。</p>
</blockquote>
<h2 id="买房和不买房的差距"><a href="#买房和不买房的差距" class="headerlink" title="买房和不买房的差距"></a>买房和不买房的差距</h2><blockquote>
<p><strong>汝爱之罪：</strong></p>
<p>新穷三代。。。ORZ<br>我可不想做穷一代。。。。</p>
<p>房子真的让人抓狂，当跟你同样起点的人早你三年买房的时候，这种感觉尤为明显。</p>
<p>我老公是77年的，他一个女同学2007年底在清河新城买了一套房，一百多平100多万吧，找家里东拼西凑的全款。其实当时我老公也能拿出100w不用借钱的，可是他偏不听我的话，认为清河在五环外，那种地方还要100多万不可思议。结果北京经历了09年的疯狂以后他同学那套房子已经翻倍，借的钱也已经还清。</p>
<p>而我们呢，在犹豫和老公的优柔寡断中错过了时机，终于在2010年3月最疯狂的时候入手了，这时候即使首付160多万，还要背负100多万的贷款，生活质量比他的女同学差的不是一点半点。</p>
<p>这是真实发生的事情，犹豫和无知真的能让人付出很大的代价。</p>
<p><strong>kkndme：</strong></p>
<p>清河新城好像是50年产权吧。反正我对50年产权的都不感冒。</p>
<p>我一朋友06年买的水木天成，买时5000多，现在25000，调控都不带降价的。</p>
</blockquote>
<p>说到租房举个活生生的例子。</p>
<p>我有朋友是个房产的死空头，一直租住着北京一套两居室的老公房，租金不高1000多点，所以没什么负担，对买方族恨不能理解。结果今年他租住的那片老公房要拆迁，限期20天内搬家走人，结果终于理解了找房子的辛苦，而且随便租一套两居室也找不到2500以下的了。</p>
<p>真是心态决定命运。</p>
<h2 id="为什么现在租售比这么低？"><a href="#为什么现在租售比这么低？" class="headerlink" title="为什么现在租售比这么低？"></a>为什么现在租售比这么低？</h2><blockquote>
<p><strong>我爱的飞飞：</strong></p>
<p>对待房子，我的看法是这样的，50-60年代的人，兄弟姐妹至少5-10个，2004-2020年之间正50、60、70、80、90年代共存的时代，人口达到了爆发阶段，现在好多小年轻70、80代人因为买不起房结不起婚，甚至晚婚索性不育，等50.60后在未来20-30年离世之后，将会有大量的房子空出来。而80后的子女2000后，人口根本不足以养活上一辈。</p>
<p>我在成都，我的父母是体制内的，我是体制外的80后，刚结婚，老公是体制内的。原家里有一套单位的集资建房，只有小产权，在二线城市的一环内，98年的房子，因为担心迟早有一天拆迁以后没有房子住，小产权也不会赔多好的地段或者得到较好的补偿，再加上以房养房的心理作祟，以及我参加工作以后想从家里独立出来，于是父母在08年底四川地震以后全国大降价赶上好时光在三环外买了一套140的房子，那会儿才买成2900，今年交房以后装修到一半，就有人以双倍价格想买入，父母不卖，留着养老。一年不到翻了一番起来，我结婚以后，也和老公一起在一环附近购入一套小户，8千多。老公家在外省某市有2套，这样算下来，我门要是生一个孩子，以后这孩子手里就有我父母在成都的2套加上老家的1套，我和我老公的1套，孩子爷爷奶奶的2套，一共6套，您说等我父母和老公父母都去世以后，房子嗖的一下就空出来了不少。所以我觉得80后到了四十岁左右肯定都能住上房子，那个时候房子也不再值钱，不过话又说回来，其实我的父母也是年轻的时候住在单位的公房，三十五近四十岁才有了第一套集资建房，而他们的第二套和第三套相对比较快了。所以我现在觉得年轻人还是应该多奋斗吧。但是我真的不清楚，到了房子不缺的时候，那个时候又会炒什么。</p>
<p>虽然我是土著，也不缺房子，但是压力也不小，特别是还贷，连车也没敢买。有时候我跟LG也想，为啥我们买的房子首付了二十几万，装修十万，我们每个月还还着2500的按揭款，租房客2000就租走了，那不是我们垫着钱给别人提供福利么？向楼主求解。</p>
<p><strong>welldayzwb：</strong></p>
<p>同困惑，只能等租金明显上涨了，否则就是活雷锋了，呵呵</p>
<p><strong>wofuleyumin1：</strong></p>
<p>我来回答吧。。。租金的涨幅。。。你看看10年前的租金。。。也可以看看20年前的租金。。。</p>
<p>10年后你的月供还是2500 但租金可能是5000了。甚至10000</p>
<blockquote>
<p><strong>我爱的飞飞：</strong></p>
<p>但是选择等额本息的人，意味着以后如果贷款利率往上浮动，很可能在还贷多年以后月供超过2500。。。这个还真的不好说。个人愚见，再过15-20年其实房子是过剩的，我打算在此期间卖出自己部分房产。</p>
<p><strong>kkndme：</strong></p>
<p>如果你拥有市区10年以上房龄的房子，等不到15年，你的房子一定会遭遇拆迁。</p>
</blockquote>
<p><strong>kkndme:</strong></p>
<p>打个比方，假设你打算在某地开个游乐园，竞拍一块地，经过计算当时的门票定价10元一张，根据人流测算，你认为出500万投标这块地，5年可以回本，于是你出了500万，但是别人出到了1000万，你认为1000万要10年回本，风险太大了，于是你放弃了。你冷笑着认为那个傻子一定会赔钱。</p>
<p>结果过了2年，票价涨到100元一张了，人流量一点也没减小。人家5年就回本了，以后赚的盆满钵满。可是这个生意你却因为太能算计没有做成。</p>
<p>为什么房价租售比低？</p>
<p>其中原因之一是现在的房价预期了以后的租金。</p>
<p>另一个也是最重要的原因就是：现在的房价不够高，说明了很大一部分普通家庭都有希望买得起房，所以宁肯省吃俭用住合租房，为了攒首付。但当房价高到普通家庭不敢问津的时候，这部分中等收入的合租家庭就会放弃买房转而追求租住有一定舒适度的房屋，房屋租金就会上涨到合理的程度。</p>
<p><strong>welldayzwb:</strong></p>
<p>楼主在线啊，真好，这个道理大概也明白，不过现在出于”活雷锋”阶段，心里还是很不舒服<br>去年底在北五环投资的一套大一居，首付加税款超过60％，贷了30年的公积金，现在房租还是不顶月供，而且空租期很长<br>很怀疑自己的投资决策，好象不是一个很明智的选择，纠结中</p>
<p><strong>kkndme:</strong></p>
<p>当房价快速脱离你的成本区，你的心理就好受了。</p>
<p><strong>welldayzwb:</strong></p>
<p>再多问一句，有机会一步到位买个满意的大房好(也是老房，得房率高，三居)，还是买两套小房，一套凑合着住，一套放租好？</p>
<p>当然两套小房的总额比一套还是要多不少，帮忙分析一下，短期和长期来看的情况？谢谢！</p>
<p><strong>kkndme：</strong></p>
<p>其实买两套同一小区的房子是最好的，投资自住兼顾，可进可退。如果家里有老人，和老人分别居住，又在同一小区，照顾起来很方便。</p>
</blockquote>
<h2 id="房产交易历史"><a href="#房产交易历史" class="headerlink" title="房产交易历史"></a>房产交易历史</h2><p>最早的房产交易，出现在一个名字叫“盉”的西周青铜器上。在公元前919年农历三月份，一个叫矩伯的人分两次把一千三百亩土地抵押给一个叫裘卫的人，换来了价值一百串贝壳的几件奢侈品，包括两块玉，一件鹿皮披肩，一条带花的围裙。</p>
<p>周厉王三十二年又发生了一宗土地买卖。这宗土地买卖的交易过程也被刻在青铜器上。 </p>
<p>这次记录的是周厉王买地的事，周厉王为扩建王宫，买下一个叫鬲从的人的地，没有立即给钱。鬲从担心周厉王赖账，周厉王派人对鬲从说：“你别怕，我一定会照价付款的，如果我赖账，就让上天罚我被流放好了。”这是个很毒的誓。</p>
<p>周厉王买地花了多少钱，铭文上没写。不过李开周说，有人买地，有人卖地，说明当时除了有土地抵押，还存在土地买卖，房地产市场已经有了雏形。</p>
<p>隋唐时，有个叫窦乂的人，他生在陕西，很小的时候就死了爹娘，无依无靠，跟着舅舅一块儿生活。</p>
<p>他舅舅是个公务员，住在长安城。窦乂先通过卖鞋、卖树等生意赚了一些钱，后来有了80万钱的身家，于是开始向房地产行业进军。</p>
<p>当时长安西市有一个废弃的化粪池，面积不小，有十几亩，闲置七八年了，一直没人买。窦乂把它买了下来，雇人填平，在上面盖了20间店铺，租给波斯胡人做生意，平均每天都收上来几千钱的房租。</p>
<p>再后来，窦乂听说当朝太尉李晟喜欢打马球，于是斥资70万钱买下一块地，又花30万钱把这块地建成一片马球场，送给了李晟。</p>
<p>李晟很高兴，从此跟窦乂结成死党，有求必应。有这种靠山保驾护航，窦乂发得更快了，不到40岁就成了长安首富，人称“窦半城”。</p>
<p>除了像窦乂这样的开发商，古代的业余开发商还有一些是公务员、退休干部等，甚至官府自己就是开发商。 </p>
<p>比如在北宋，中央政府下面就有个专门搞开发的机构，叫做“修完京城所”。这个机构本来只能是修筑城墙和宫殿，后来城墙修得差不多了，宫殿也盖得够豪华了，这个机构就开始转型，开始给中央财政搞创收。</p>
<p>怎么搞创收呢？修完京城所向朝廷请示，划拨给他们大片地皮，他们在上面盖住宅盖店铺，盖好了，有的卖给老百姓，有的赁给老百姓，给国库做了很大贡献。</p>
<p>古代是没有专业的开发商的。做开发商最需要的是钱。买地、买建材、雇人、摆平关系，哪个环节都得花钱。尤其买地，流动资金不能少，钱不够，就得找同行拆借，或者找银行贷款。</p>
<p>古代没有银行，但有钱庄，可是钱庄规模一般很小，即使有一些大型的全国连锁的钱庄，他们也不做开发商的生意，都把钱借给别的老板了。</p>
<p>史料上有这样两个办理房地产抵押贷款的例子，一个是南北朝时候的梁朝郡王萧宏，让人家拿着房契去贷款，一张房契最多只贷给几千钱；还有一个是明朝嘉庆年间山阴县的一个富户，名叫求仲，最多的一次才贷给15000文。这点儿钱别说搞开发，吃一顿大餐都不够。<br>直到民国时期，外国银行纷纷到中国开展业务，开发商们才能贷到大笔的贷款。所以中国的职业开发商直到民国才出现。 </p>
<p>古代开发商如果大量囤地得挨板子</p>
<p>以唐朝为例。唐玄宗在位时，土地政策里有这么一条：“应给园宅地者，良口三口以下给一亩，每三口加一亩，贱口五口给一亩，每五口加一亩，……诸买地者不得过本制。”意思就是说，政府给老百姓划拨宅基地，划拨的宅基地大小取决于家庭等级和家庭人口，如果是平民家庭，每三口人给一亩宅基；如果是贱民家庭，每五口人给一亩宅基。另外老百姓也可以购买宅基，但是购买的面积有限，不能超过政府规定的指标。</p>
<p>政府规定的指标是多少呢？平民家庭买地，每三口人，最多只能买一亩宅基；如果是贱民家庭买地，每五口人，才能买一亩宅基。</p>
<p>在唐朝，商人也属于贱民，再有钱的商人也是贱民，贱民老板去买地，即使是上百口人的大家庭，最多也只能购买20亩地，用这20亩地搞开发，一两年就倒腾光了。而如果超标大量买地会怎么样呢？</p>
<p>唐朝法律规定：“诸占田过限者，一亩笞十。”意思是买地超过指标的，得挨板子，每超出一亩指标，挨10大板。</p>
<p>虽然古代开发商没有现如今的开发商这么“牛”，环境和政策对他们都不太有利，但是在拆迁问题上，始终还是开发商们占优势。就比如窦乂，他就知道要搞房地产，首先得朝上有人，于是傍上了当朝太尉。</p>
<p>古代拆迁过程更为暴力，因为普天之下，莫非王土，国家要用哪里就用哪里。</p>
<p>当然，在古代，也不乏一些民主的君主。例如北宋元丰六年(1083年)，开封外城向外拓展，规划中的新修城墙要占用120户居民的住宅，宋神宗让开封府制定拆迁补偿计划，开封府写报告说，总共需要补偿款两万零六百贯，平均每户至少能拿到补偿款171贯。</p>
<blockquote>
<p><strong>Peter_Takeshi：</strong></p>
<p>LZ写的不错，有些意见不敢苟同。<br>LZ既然熟读历史，又在安抚众人去接受被统治的命运，那能否告知最后的结局呢？<br>是否跟前几十个朝代一样？呵呵~<br>人性几千年从未根本改变，所以即使过程不同，结局仍旧是一样。<br>谁上台都改变不了这一切。</p>
<p><strong>kkndme：</strong></p>
<p>历史上的结局三条路：<br>和平演变——在中国好像没发生过，今后也不可能，没有土壤<br>大革命——哪次也少不了<br>外来入侵——这个也比较靠谱</p>
</blockquote>
<h2 id="契税的历史"><a href="#契税的历史" class="headerlink" title="契税的历史"></a>契税的历史</h2><p>关于契税、物业税或者房产税，其实也不是现在的创造或者纯粹的拿来主义。</p>
<p>早在东晋时期，就开始收契税，当时叫“散估”，这也是中国第一个有据可查的契税。其后，几乎所有朝代都有契税。</p>
<p>唐初魏征等人写出了房产税的实质：“其实利在剥削也”——当时“剥削”没有现今这么贬义，与“增加财政收入”是一个意思。</p>
<p>从税率上看，东晋税率为4%，隋唐税率是5%，宋代4%，元明清三朝基本是3%。我们现在的契税大户型也是3%。</p>
<p>万历三十三年，利玛窦在北京宣武门附近买了处房子，他在意大利、葡萄牙、印度都呆过，那些地方并没有“契税”这一说，所以他也没有去有关部门办理手续。</p>
<p>《大明律》规定：“凡典买田宅不税契者，笞五十，仍追田宅一半价钱入官。”好在利玛窦同志上面有人，托了户部官吏，最后交了一笔可观的滞纳金了事。 </p>
<p>相比之下，“物业税”这税种兴起较晚，而且断断续续。公元783年，唐德宗向长安城内拥有房产的市民开征物业税，叫作“间架税”，乃是按照房屋的等级和间架计税，上等房屋每年每间缴纳两千文，中等房屋一千，下等房屋五百。</p>
<p>结果民怨载道，当年深秋五万军兵哗变，口号就是“不税汝间架”。迫于压力，784年唐德宗废止了这个税种，也就是说，中国第一个正规的物业税仅仅活跃了半年就夭折了。</p>
<p>到了五代十国，梁唐晋汉周的每一代帝王都曾征收物业税，不过鉴于“间架税”惹过乱子，改叫“屋税”。</p>
<p>北宋物业税不是常设税种。南宋由于军费困难，每年两次向城乡居民征收屋税。元代，不叫间架税或屋税了，改叫“产钱”，按地基面积征稻米若干或折成钱若干。明朝，物业税不常设，江浙地区小范围征收过一段，叫“房廊钱”。清代，物业税也不常设，往往临时征收，比如1676年由于对吴三桂用兵，朝廷财政紧张，康熙下诏“税天下市房”，规定“不论内房多寡，惟计门面间架，每间税银二钱，一年即止。”算下来，是只对门面房征税，二钱税额相当于两斗大米或七斤白糖的价钱，不多。</p>
<p>总而言之，无论是间架税、屋税、地基钱、产钱、房捐，都是不折不扣的物业税。只不过，它们与国际上通行的物业税是不同的——不是为了调节需求，而是单纯地敛财。 </p>
<p>然而物业税在中国并不能成为常设税种，因为这个税是纯粹的苛捐杂税，税又比较重，很容易激化矛盾，直接结果是百姓吃不起饭，太容易导致大规模的农民运动，所以很难持续征收。</p>
<h2 id="廉租房的历史"><a href="#廉租房的历史" class="headerlink" title="廉租房的历史"></a>廉租房的历史</h2><p>言及公房和廉租房系统，最是宋朝搞得好。</p>
<p>宋朝原则上不分房，京官无论大小，一律租房居住，宰相那样的高干都是如此。偶尔有“赐第”，只照顾部级领导和有军功的将军。算起来大家的住房自有率不高。</p>
<p>南宋初年，大量流亡人口涌进杭州，三十平方公里的杭州城一度住了一百万人口，人口密度接近上海浦西。</p>
<p>因人多地少房价高，居民普遍租住公房。除了大规模公房出租，宋朝还有住房救济体制，一是灾年对租住公房的市民减免房租；二是政府建房（福田院、居养院）免费安置流民和赤贫民众；三是修建比公房条件要差的简易房，但是租金更低，堪称“廉租房”。此外，宋朝还有安济坊——慈善医疗，还有漏泽园——安葬无人认领的尸身，比较有人性。 </p>
<p>如果是公务员的话，生在元代也还不错。建国开始，就给半数京官和所有地方官分了房，叫“系官房舍”。一般分不到的市民以自主建房为主导，但是盖房不用买地，政府批给一块官地，然后每月交一次租金，时称“地基钱。” </p>
<p>满人刚进北京那会儿，也给领导们分房子。一品官二十间，二品官十五间，三品官十二间，四品官十间，五品官七间，六、七品官四间，八品官三间，不入流小军官每人两间。按照每间十五平方米估算，从一品官的三百平方米、到小军官的三十平方米不等。 </p>
<p>廉租房主要由寺观经营。土地由政府划拨，建房资金由民众捐献，房产维护可以从香火钱里冲销，僧尼道士理论上讲不以盈利为目的，再加上信仰需要，正适合执掌这项半慈善业务。大都市的庙宇常有上千间客房，供应试的学生、出门的商旅和遭了天灾的百姓临时居住。</p>
<p>《西厢记》里张生和崔莺莺在山西停留一整月，在那永济县普救寺里，莺莺住西厢，张生住东厢，该故事充分说明：在廉租房里也可能发生爱情。</p>
<p>到了明清两代，又多出个廉租房的来源，便是会馆。在这异乡人建立的聚会场所里，客房租金相当便宜。顺治十八年建于北京的漳州会馆，福建人来租住，只象征性地收取租金：每月三文钱！ </p>
<h2 id="历史上买房最好的朝代"><a href="#历史上买房最好的朝代" class="headerlink" title="历史上买房最好的朝代"></a>历史上买房最好的朝代</h2><p>历朝历代，哪朝买房最容易呢？</p>
<p>南北朝最不靠谱，贫富相差极为悬殊，普通居民收入只有几千，房价则是几百万。谢灵运那样的大财阀“左江右湖，南北二山”，房价都被他们给炒上去了。 </p>
<p>唐朝不用说啊，我们都知道“居长安，大不易”，而且士大夫时兴攀比，为了写诗题名好看，非得有个别墅不行。比如王维有辋川别业，岑参有南溪别业，杜牧有樊川别业，就是白居易本人，后来也在洛阳买了十七亩地，修了个“履道园”。</p>
<p>宋朝文人叶梦得说：“人未有无产而致富者也。有好便田产，可买则买之……勿计厚值。”这话一再被地主老财们重复。有点闲钱，买房子置地，不惜一切代价。</p>
<p>明代买房也不是件容易事。《金瓶梅》第五十六回，西门庆的结义兄弟要买房，朋友帮他算了算帐，“一间门面，一间客座，一间床房，一间厨灶——四间房子是少不得的。论着价银，也得三四千多银子”。小户型房子，要三四千两银子。而清河县县令，从七品国家公务员，每年薪水不过三百五十两。就是说，就算县长去买房，如果不贪污的话，需要十年不吃不喝才能攒够房钱。明代楼市虚火上延，与攀比之风分不开。尽管明太祖规定，任何人不得超越等级建房，例如居民门窗不得使用朱红油漆；庶民住房不得超过三间；功臣宅邸两边可以保留五丈空地；军民房屋不许建成五间或九间；寺观庵院不得使用斗拱。但如小说里所说，庶民西门庆“现住着门面五间到底七进的房子”，超标超大发了。</p>
<p>嘉靖年间，大家纷纷打肿脸充胖子，浙江人的房子必须带客厅了，江西人的房子必须带兽头了，江苏人的房子里必须摆上时尚家具和精美古玩了。明朝中叶，北京的地皮已经涨到每亩纹银两千两，就是折成人民币也有好几十万。 　　　 </p>
<h2 id="未来房地产市场的发展"><a href="#未来房地产市场的发展" class="headerlink" title="未来房地产市场的发展"></a>未来房地产市场的发展</h2><blockquote>
<p><strong>中年不惑吗：</strong></p>
<p>楼主旅行结束呢？</p>
<p>将来房租市场会如何演化？</p>
<p>房租涨的太多，如果大多数租客的收入承担不起该如何？</p>
<p>例如租客的平均工资4000元&#x2F;月，你让他和别人合租一个小两室要6000元<br>他们承担不起恐怕就只能离开这个城市了</p>
<p><strong>kkndme:</strong></p>
<p>公租房具有平准作用，zf要敛财，不能定价太低，但也不会高的离谱。有了这个参照物，个人普通房出租应该保持在比公租房稍高水平，当然位置好的高端房精装房也可能租出天价。</p>
<p>中国的房价在未来将成为多数群众遥不可及的梦想，也可以说大多数人都不再关心商品房的房价涨跌。</p>
<p>未来，租房将成为常态，所以房子的位置环境装修的档次不同，房租的差距将会非常明显。但好房子一定只有中等收入以上家庭才租得起。</p>
<p>而买房子是富人阶层的事，中等收入家庭想都不敢想。</p>
</blockquote>
<blockquote>
<p><strong>中年不惑吗：</strong></p>
<p>呵呵，将来，只要中等收入的家庭2个月的收入能买1平米，他们也会买房子的</p>
<p>难道将来的房价要涨到中等收入家庭半年甚至更长的时间才能买1平米？</p>
<p><strong>kkndme:</strong></p>
<p>除了房价高，贷款也没那么容易。而且除了房子，各方面的花销都会涨得离谱，这是太平盛世后期的普遍规律。</p>
<p>关键还在于体制外的中产，都是逆水行舟，一旦不能前进，就可能沦为赤贫。</p>
</blockquote>
<blockquote>
<p><strong>九五二七八:</strong></p>
<p>楼主说的以后大部分人买不了房的论题<br>中美在这个方面的差距 怎么这么大呢<br>现在产业转移 一部分人就业就有回乡的趋势<br>今后再有一波转移 会不会再离故乡近一些<br>这样 分散置业 购买难度会不会下降</p>
<p><strong>kkndme:</strong></p>
<p>中美体制不同、文化不同、人口不同。一辆在美国2万美金的汽车，国内要卖几十万人民币。一件made in china的服装美国卖20美金，国内卖900人民币。</p>
<p>不管一线城市、三三线城市都是人满为患的，从一线城市逃离的也会驻扎在二三线城市，绝没有可能大中型城市向小城市回流。</p>
<p>返乡潮指的是家有自留地的农民工，如果工资待遇差不多，与其到沿海地区漂泊不如回乡打工或者种地。比如贵州镇远的油漆工一天工资是150，而在珠三角打工一天工资还不到150，这也是大量农民工返乡的原因。</p>
<p><strong>九五二七八:</strong></p>
<p>最难的怕是现在三四流的大学生和跟着打工父母生活在城里的二代<br>失去了农村生活本领<br>在城里也无法立足<br>楼主<br>难道拉美化真的不远了</p>
<p><strong>kkndme:</strong></p>
<p>很多人都丑化拉美，但是拉美的生活水平要高过我国。不说远超中国的巴西，即使是法属及荷属圭亚那(苏里南）这样的小国，人民的生活也很富足。</p>
<p>前几年有个援助项目去苏里南等拉美国家，去之前所有的人给我灌输的都是拉美国家如何贫困。但事实上，这些国家与中国完全不同，国穷民富，藏富于民，与中国正好是相反的，只要勤快点的家庭都还比较富裕。当然不排除也有很多穷人（美国也有很多穷人），穷人一般以当地的黑人为主，好吃懒做，整日无所事事。</p>
<p>这些国家的人民不如中国人勤奋，从不攒钱，只图眼前享受，我想主要原因还是由于币值不稳定，通货膨胀比较严重，所以没有人愿意攒钱。在拉美国家是无法炒房地产的，比如苏里南平均25平方公里有一口人，真的是地广人稀。所以才保留了世界上最高的森林覆盖率。</p>
<p>拉美人的懒惰会让中国人瞠目结舌，当地的蔬菜价格昂贵，尽管有大片肥沃的土地，当地却没有人愿意耕种，很多去苏里南种植蔬菜的中国人为此发了大财。</p>
<p>而相反中国人可以说是全世界最勤劳的民族，但是大量勤劳的中国人却过着低水准的生活。这与中国的国富民穷，藏富于国，与民争利的政策是分不开的。</p>
<p>拉美国家尽管有这样那样的问题，但是确实是法制国家与民主国家，私人财产神圣不可侵犯，这是与中国完全没有可比性的。</p>
</blockquote>
<blockquote>
<p><strong>九五二七八:</strong></p>
<p>一般对“拉美化”的定义是这个吧：贫富悬殊扩大、腐败严重、国有企业效率低下、社会治安恶化、城市人口过多、地下经济泛滥、对外资依赖性强、金融危机频繁和政局不稳定，等等</p>
<p>没去过拉美 不知道真实的拉美</p>
<p><strong>kkndme:</strong></p>
<p>看来拉美妖魔化后，深入人心了。好比在越南旅游，越南人自己说越南官僚太腐败，我笑了，能有中国腐败？</p>
<p>拉美的官僚机构，国企、医院、警察我都见识过。</p>
<p>说到官员的官僚，相比中国我真的觉得那里的官员很亲切。我曾经以一个游客的身份和苏里南的司法部长一起在街边小店喝咖啡。以一个陌生的外国游客身份在财政部长家里做客，逗他家的几个黑小孩玩。</p>
<p>说到治安，我在街边咖啡店坐了一下午，每二十分钟一辆巡逻车从我身边经过。里约热内卢的治安绝对不会差过广州。</p>
<p>国有企业效率低下恐怕是全世界的通病，况且拉美根本没有可能赚钱的行业全部由国企垄断。</p>
<p>政局不稳要看怎么理解，拉美国家是相对民主的国家，国家元首倒是常常因为民众的不满而换届（排除少数经常政变的军政国家）。但人民并没有感觉到不幸福。</p>
<p>拉美国家的经济基本被美国所控制，所以才会对外资依赖严重和金融危机频繁。作为一个主权国家我们看到的是国家财政贫困，但是作为拉美地区的中下层人民群众，生活水平和幸福感是要高于国内的中下层群众的。</p>
</blockquote>
<h2 id="房产到期"><a href="#房产到期" class="headerlink" title="房产到期"></a>房产到期</h2><blockquote>
<p><strong>不明真相的草民：</strong></p>
<p>向LZ请教</p>
<p>商品房的土地证年限有多重要？</p>
<p>现在一个二线城市的开发区，中心地段很多小区房子倒是新盖的，但地是90年代初拿的，有40年、50年的，还有30年20年的，大部分房子的土地证从现在算起只有10几年20几年，有的房子土地证已经到期了，但由于位置较好所以房价一点不便宜。按KFS的说法，土地证到期将来再续就是了，没有大的影响。</p>
<p>LZ给分析一下，这样房子将来的风险在哪？如果买来自住又如何？</p>
<p>谢谢！</p>
<p><strong>kkndme：</strong></p>
<p>其实有无土地证都无所谓，无论有没有土地证，最大的风险都在dfzf，人治社会法律文件其实就是一张纸，关键还是zf做得不要太过份。</p>
<p>即使你证件齐全zf想拆一定会拆，即使没有土地证拆的时候也会同样补偿。</p>
<p>这个东西实在没多大意义。</p>
<p><strong>不明真相的草民：</strong></p>
<p>感谢LZ答复。都是新建的高层，应该不会轻易拆迁，这么说自住还好。但如果将来要出手是否就存在困难？？</p>
<p>期望LZ继续指明。</p>
<p>Lz似乎没有看到这个问题，再次感谢Lz，望答复。</p>
<p><strong>kkndme：</strong></p>
<p>出手不存在困难。二手房交易国家不会对土地证进行严格限制，关键还是房产证。</p>
</blockquote>
<h2 id="买学区房问题"><a href="#买学区房问题" class="headerlink" title="买学区房问题"></a>买学区房问题</h2><blockquote>
<p><strong>开洋木瓜：</strong></p>
<p>楼主，有个问题想咨询一下。</p>
<p>家在南京，郊区有一套自住房，130平，市值大概150万左右。市中心有一套小公房，居住权，目前空置（刚分到的，还没有装修，而且单位也禁止对外出租）。现在宝宝一岁，想给宝宝买个学区房，很多名校都要求提前三年落户，所以必须要在2年内买房。一线的学区房单价在2万2-2万6之间。一线小学的分校学区房在1万5-2万之间。我想买的是一个名小的分校，近几年的小升初成绩都非常不错，可以进入南京前三名。</p>
<p>我想买的一个房子位于这个小学的学区，是拆迁安置房，97年的房子，小区环境比较杂乱，没有物管，停车也不方便。但是周围配套都非常齐全，菜场超市医院都很近，上学也不用过马路。今年年初，2月份的时候我本来在这个小区买了一套，但因为房价上涨房主违约。当时买的房价是12500，现在看中一套，房主要17000，挂了很久没卖掉，我出15000，可能有机会成交。</p>
<p>这个隔壁有个新小区，物管环境都很好，但价格也上到2万一平了，如果要在这个新小区买房，我们家里的钱就不够了，如果要卖掉现有的房子去买，老公也不愿意。</p>
<p>还有个问题是，房主要求净得价，12月的时候满五年，就不用付营业税。如果现在交易过户也可以，但要多付几万块。如果算上这几万的税，房价就差不多一万七一平了，我也不愿意现在过户多付这个钱。如果现在签约等12月再交易过户会不会有风险？另外现在是否是出手时机？请楼主赐教。</p>
<p><strong>kkndme：</strong></p>
<p>学区房即使在调控最严厉的时期也几乎不可能下跌。但是在上涨期就很难买到，因为房东会跳价。</p>
<p>12月过户有一定风险，如果到12月时，房价上涨比较厉害，房东有可能违约。</p>
<p>制约房东违约的方法就是签较高的违约金。</p>
</blockquote>
<h2 id="人口普查"><a href="#人口普查" class="headerlink" title="人口普查"></a>人口普查</h2><blockquote>
<p><strong>平静的房奴：</strong></p>
<p>看来楼主今天比较空闲，一口气发了这么多帖子。</p>
<p>有个问题想青椒哈楼主，我在武汉，最近武汉在全免清理个人和家庭住房信息，晚上调查人员还上门登记、记录，请问这是何意？是否在为出台房产税做准备。</p>
<p><strong>kkndme:</strong></p>
<p>人口普查。不但武汉，连穷山沟里也在忙这个，穷乡僻壤的支书天天忙得不亦乐乎。这是第六次人口普查，前面查过五次了</p>
</blockquote>
<h2 id="昆山"><a href="#昆山" class="headerlink" title="昆山"></a>昆山</h2><blockquote>
<p><strong>買房難：</strong></p>
<p>樓主﹐麻煩你分析一下昆山的房價吧﹐先謝謝﹗﹗</p>
<p>昆山是一個縣級市﹐原先是屬于蘇州的﹐離上海很近﹐動車只要20分鐘﹐現在高鐵也開通了﹐原先房價還算便宜的﹐現在連鎮上也貴到五千多六千了﹐市中心最便宜的也要七千多八千﹐09年10月的時候一下子漲了很多﹐原先我看好的一套二手房32萬﹐現在要50多萬﹐太奇怪了</p>
<p><strong>kkndme：</strong></p>
<p>昆山不能理解为县级市，要理解为上海的卫星城。相当于北京的燕郊。所以房子八千多一点也不奇怪。</p>
<p><strong>買房難：</strong></p>
<p>謝謝樓主回復﹗昆山市中心的房子大一點的開發商開發的如世茂在一萬左右一平﹐這個價位算不算高啊﹖</p>
<p>買房子要在市中心好點呢﹐還是城東靠近上海方向好些﹖</p>
<p>昆山很小的﹐就那么几個鎮﹐現在火車站﹐汽車站﹐高鐵﹐人才市場都在城南﹐另外除市中心的玉山鎮外﹐其它的都是工廠很多﹐污染還是多。</p>
<p><strong>kkndme：</strong></p>
<p>买在哪里合适，你要看zf规划，跟着zf规划走。比如房山，zf打造的是长阳而不是老的镇中心，所以买房就应当买在长阳。道理是一样的。</p>
</blockquote>
<h2 id="买房争取一步到位"><a href="#买房争取一步到位" class="headerlink" title="买房争取一步到位"></a>买房争取一步到位</h2><p><strong>hohowell:</strong></p>
<p>楼主，诚心请教下，从开贴开始就一直在潜水关注，终于坚定了买房的决心</p>
<p>现在在犹豫，一是买个80平米的小户型，开发商一般，房型尚可，这样贷款比较少，基本不影响供车，旅游和以后小孩的开销，不过考虑5到8年左右，这个房子就不能满足居住要求了，回头换，又是一大笔钱，而且城区内的好小区也会越来越小，另外一个就是保利的大户型，开发商物业都靠得住，基本上短期可以不用换，不过贷款至少贷100多万，短期内还会要小孩，压力会比较大，基本手里每个月都没有闲钱了，很容易回到赤贫线，一直犹豫不决，诚心请教楼主解惑，我在南京，一个一线以下二线以上的鬼地方，两处房子都靠地铁，周边商业中心配套齐全，谢谢！</p>
<p><strong>kkndme：</strong></p>
<p>买房子如果有能力还是要争取一步到位。将来改善，除非个人有较大的发展，否则将很难很难。而且买楼首选好位置，大开发商，大盘，升值空间才大。</p>
<blockquote>
<p><strong>welldayzwb：</strong></p>
<p>看来楼主分析说购房应该一步到位，我就犯了一个错误，用投资的眼光来选择自住房，后来买的两居室比同小区的三居室性价比高很多，但是居住环境不好，临一条小街，所以现在住起来不是很爽，现在调控着价格先不说了，光是现在限制换房的一些条条框框感觉再置换就很麻烦<br>另外一套买的外面一点，小区环境非常棒，不过当时是被环境给迷惑了，放租的房子管那么多环境做什么，感觉两套房子操作反了<br>纠结中啊纠结中，现在唯一能安慰自己的就是，买上房子总比没买强，如果去年年底再犹豫一下或是赌气的话，那就真是悲剧了，一个好三居得活活等成质量差些的两居了</p>
</blockquote>
<h2 id="收入稳定的家庭如何买房"><a href="#收入稳定的家庭如何买房" class="headerlink" title="收入稳定的家庭如何买房"></a>收入稳定的家庭如何买房</h2><p><strong>黑眼圈钱：</strong></p>
<p>请教楼主，买房子的事情，比较纠结。</p>
<p>1）夫妻两人均在西部某高校任职，一个教师，一个行政人员，年龄都不小了，37和35，两人每月总收入在8000-10000，1年算10万收入，应该会多一点。</p>
<ol start="2">
<li>一个女儿，才两个多月。</li>
<li>3）每年给双方父母1万，双方父母均已60出头，一方父母城里的有退休金及医保。另一方父母农村的，得为他们准备点钱。</li>
</ol>
<p>4）目前租住单位两室一厅房，就在学校住宅小区内，除了小点，别的都好，房租100。</p>
<p>5）公积金两人很少，约1000元每月，未来1-2年内会有购福利房机会，估计90多平方的旧三室一厅（约需 10万元），可能有120平米的房子，但需要排队看单位建房情况（2000每平米）。</p>
<p>6）两人都有单位医疗保险。</p>
<p>7）孩子可以上学校的幼儿园和小学、初中，就在150米范围内。</p>
<p>8）对于车没有什么想法，每天步行上班用不到车代步。不过会买辆10万左右的。</p>
<p>9）现在没有任何投资和理财。银行存款1-2年期定期存款50万，这个傻了，已经存2年了，平时光顾着干活。</p>
<p>有没有必要买个商品房呢，周围的房价从08年的4500涨到现在8500，容积率还非常高，并且楼间距等等不理想，那种房子我不想住的。</p>
<p>其实在附近买套120平米的房子，首付后也供得起，买房子放那等涨价或者出租？ 不想放弃单位的房子，每天睡到自然醒再去上班还是挺惬意的，送孩子上幼儿园上学也方便。</p>
<p>买了房子后经济会紧张些，不像现在自由。财务自由也算一种幸福吧，我太太对于房子没什么要求，所以也不给我什么压力。</p>
<p><strong>kkndme：</strong></p>
<p>对于工作稳定，收入不错的体制内家庭，基本上的情况就是有闲钱就买房。主要还是由于收入稳定不用担心失业，钱放着只有贬值，不如置业。投资型住房与自住型住房在选择方向上有很大不同。</p>
<p>举个例子，昆明打造了个螺丝湾，几乎半个昆明做生意的人都聚集在哪里。如果自住没有人愿意选择在那里买房，实在是不好住。但是投资确是最好的选择，因为可以获取较高的租金的收益，将来升值空间也不会小。</p>
<p>假如在昆明一环附近买一套两居室，月租金一般在1500-1800，而房价在万元左右。而在螺蛳湾附近买一套两居室，月租金都在2000多，而房价在7000多。</p>
<h2 id="为什么人口红利消失，未来的房子还看涨"><a href="#为什么人口红利消失，未来的房子还看涨" class="headerlink" title="为什么人口红利消失，未来的房子还看涨"></a>为什么人口红利消失，未来的房子还看涨</h2><blockquote>
<p><strong>和风中的树叶:</strong></p>
<p>看了那么多 有点意思<br>不过在下有一事想不明白：<br>因中国的计划生育政策 往近了说 人口红利会在这几年消失 往远了说 80后基本都是独生子女 父辈在城市里都是有房子的 这些房子作为遗产 按理说 在未来应该使00后没有买房的需求。<br>LZ如何解释在这种情况下在未来房子仍然看涨？</p>
<p><strong>kkndme:</strong></p>
<p>回去找了一下，居然被删了。<br>大意基本是讲中国经济未来的发展模式，城市升级与拆迁改造的关系，没想到这样也不允许说。实在懒得再长篇大论说一遍。<br>关键的意思就是一方面是富裕阶层对更高端产品，更大面积的追求，一方面是城市升级带来的大规模拆迁改造。下层群众将被挤出城市核心区。许多住房都会被拆迁置换。</p>
</blockquote>
<h2 id="意大利的住房模式"><a href="#意大利的住房模式" class="headerlink" title="意大利的住房模式"></a>意大利的住房模式</h2><p>我本人对意大利的住房模式还是比较赞同的。<br>有去过米兰的朋友可能很清楚，米兰城区的房屋居住的大多数是富豪显贵，一旦出了城区，则是大片大片鳞次栉比的公租房供普通工薪族居住。<br>以后的中国有可能学习这个模式，原市中心的居民被拆迁安置到郊区，城区居住的都是达官贵人。郊区将形成拆迁安置房、中产阶级商品房、公租房、廉租房混居的模式。</p>
<h2 id="中国的学术"><a href="#中国的学术" class="headerlink" title="中国的学术"></a>中国的学术</h2><p>97年我大学毕业的第一任老板就是在龙乡小区买的房，我还到他家送礼。那时从城里骑车到西三旗，花了我将近两个小时。一晃就十几年过去了，真是有很多感慨。</p>
<blockquote>
<p><strong>汝爱之罪：</strong></p>
<p>感觉您是学者型的啊，看您去做田野调查什么的。大学毕业送礼给老板。。。。</p>
<p>看您点评回龙观的那一段，估计很多人要捶胸顿足的后悔了。回龙观真是个奇迹，从2600涨到15000，让所有人大跌眼镜。</p>
<p><strong>kkndme：</strong></p>
<p>送礼也算学者型？晕</p>
<p><strong>九五二七八：</strong></p>
<p>他是说本以为你是学者型的 不需要送礼<br>现在看到你说送礼 觉得自己判断失误了 呵呵<br>现在这个时代 学者也需要送礼啊</p>
<p><strong>汝爱之罪：</strong></p>
<p>差不多这个意思，呵呵。我一直以为楼主是搞学术的。</p>
<p>其实吧，虽然大多数学者砖家都成了贬义词，但我觉得在北京这个大环境里，还是有土壤培养一些目光敏锐犀利的人，BBS的P民也需要这样有前瞻性的引导者，因为毕竟不是每个人都强大到能把这些东西娓娓道来，没有积淀，根本悟不出。</p>
<p><strong>kkndme:</strong></p>
<p>中国的学者是很难拿出点时间好好搞搞学问的，功利性太强。</p>
<p>以前跟一伙民族学者到元阳考察，这帮人没呆满两个星期就跑回去了，说是又要评职称了，人不能不在单位。而日本学者已经在元阳与当地人同吃同住了3年，还没有一次回日本。真不知道这帮民族学者研究了两个星期的东西能发表什么样的惊世论文出来。</p>
</blockquote>
<h2 id="精英的财产"><a href="#精英的财产" class="headerlink" title="精英的财产"></a>精英的财产</h2><p>5万一平的房子对于中国的精英阶层真算不上什么。500、600万一套的房子一次性付清的人群在北京大把的存在着。这是很多工薪阶层一辈子都觉得不可能挣到的财富，但对于另外一些人却可以轻而易举的拿出来。平均工资的概念在中国是完全没有用处的。</p>
<blockquote>
<p><strong>baiyang11112010：</strong></p>
<p>直白说，我刚毕业一年，完全靠着父母资助，要完全靠自己根本买不起房，我一些同学在北京两人的话年薪也就15万左右吧，现在好歹还能惦念着买房，要是像您所说，“北四环西四环东四环达到5万，北五环西五环外到达3万应该不是什么难事”，那他们根本就没有盼头了，这是很可怕的事啊</p>
<p><strong>kkndme：</strong></p>
<p>将来年薪20万的中产阶层一定连北京6环内的房子都买不起。这一天，不会很远。</p>
</blockquote>
<blockquote>
<p><strong>tianxiaobing11：</strong></p>
<p>楼主，我也是不明白，现在成交量确实上来了，按说现在贷款控制的这么严，第三套房都贷不到款，是谁在买房，难道都是第一套房的刚需吗</p>
<blockquote>
<p><strong>bluesyang2010：</strong></p>
<p>我认为,这个跟kfs和政府之间的博弈有很大关系,投资人前段时间一直在观望或者投入到农产品等领域,我不记得是7月还是8月,突然听到热钱大量涌入国内房地产市场的传闻,之后成交量就上来了,这些信息之间有很大的关系,但我捋不清.<br>请楼主评评</p>
<p><strong>kkndme:</strong></p>
<p>你说的很有道理，当资金泛滥无处可去，一定会找到一个出口。资金如洪水在于疏而不在于堵，资金一旦冲破调控所筑的堤坝，将一发不可收拾。所以屡次调控屡次暴涨。如果不能有效开渠，将注定调控政策的失败。</p>
</blockquote>
<p><strong>kkndme：</strong></p>
<p>民币发行泛滥，有钱人绝对数量庞大。在北京上海等城市，手中拥有千万现金的人不在少数，都是全国的精英阶层啊。精英阶层的财富积累已经逐步完成，提高首付，严控贷款只能抑制小白领保值的需求，但对于精英阶层是没有任何作用的。</p>
<p>如果将来推出房产税就更好笑了。精英阶层谈笑风声，小白领神情紧张，最终结果是全部转嫁租房客。</p>
</blockquote>
<blockquote>
<p><strong>tianxiaobing11：</strong></p>
<p>还有一个问题始终不明白，请教楼主，现在五六百万的房子都有人全款买，这些人为什么不买国外的别墅呢？难道就因为中国的房子升值快吗？要我有那么多钱早移民了</p>
<p><strong>kkndme：</strong></p>
<p>我国实行的是外汇管制，人民币不能自由兑换，不可能大批人口通过地下钱庄转移资产。只有官员和少部分有背景的高端人士才能做到人民币资产顺利兑换转移。</p>
<p>一旦发现较多资金量的人民币兑换美元出境，国家将采取强制管制措施。</p>
<p>现在国家对外汇外流已经非常重视，携带价值50美元以上的商品入境都要交税，实际上国家给出了一个不希望人民币兑换成外币外流的一个强烈信号。</p>
<p><strong>理财的猫咪：</strong></p>
<p>我有段动过移民的念头，但现在基本放弃了。不知自己的选择正确与否，想听听楼主高见。</p>
<p><strong>kkndme：</strong></p>
<p>移民不见得能够适应，毕竟文化差异太大，但是如果拥有一个外国国籍，在中国生活，是一个比较好的选择，至少，你的财产是受到保护的。</p>
</blockquote>
<blockquote>
<p><strong>showcar:</strong></p>
<p>楼主说的正确啊，除非世界经济再次崩溃或者朝内变天，否则的房价要跌，太难！</p>
<p>到处听说是纸币不受截至的发行，有点现金留在手上都发抖啊，是因为“贬值”发抖！</p>
<p>所以，出手了，淘一套保值去吧！！总价150万左右。</p>
<p>楼主请教付款方式：<br>1：分期付款，30%首付，6个月内付30%， 12个月内付30%，10%交房前付清（约24个月）；<br>2：商业银行贷款，需要50%首付，50%余款贷款，首付3个月后按揭，110%的贷款利息。<br>商业贷款的话，计划交房后就付清。</p>
<p>不知道哪个更合算？期待楼主解惑。。。。</p>
<p><strong>kkndme:</strong></p>
<p>分期付款是你和房东的约定？这个比较不靠谱，如果是付清后过户，一旦房价上涨，很可能出现毁约。</p>
</blockquote>
<blockquote>
<p><strong>tianxiaobing11:</strong></p>
<p>我现在就被抑制住了，现在是认房不认贷，我也不能贷款了，可现在动不动就得百万以上才能买房，真是力不从心啊，房贷新政看来是堵塞了中低收入的房产投资渠道了，对精英阶层反而是利好，这调控就搞笑了</p>
<p><strong>bluesyang2010:</strong></p>
<p>zf倒是想调控精英层呢,但zf本身就是精英的组成部分,所以zf只能借砍掉投机者之名,开拓自身,抢占市场,特别是楼主说的租赁这个大市场,所以特别佩服楼主之前说的:zf找到了吃租赁这块蛋糕的最好时机,明着是抑制房价,其果却是让很大部分老百姓租着zf的房,zf的钱就更多了,到时候想拆哪儿拆哪儿,精英更精英,百姓更百姓….可悲呀</p>
<p><strong>kkndme:</strong></p>
<p>估计给政府出这主意的幕僚熟读过宋史，宋代官府就是靠出租房给群众敛财的。</p>
</blockquote>
<h2 id="中国的新闻不可信"><a href="#中国的新闻不可信" class="headerlink" title="中国的新闻不可信"></a>中国的新闻不可信</h2><blockquote>
<p><strong>bluesyang2010：</strong></p>
<p>搂主分析一下,现在的新闻都说房屋成交量的上升是因为kfs打折才上升的,但这个很不成立,为什么新闻这么懵老百姓.是不是政策上还有可能收得更紧?</p>
<p><strong>kkndme：</strong></p>
<p>中国的新闻最不可信，为了抓眼球不惜胡编乱造，不惜前后自相矛盾。我倒觉得这个成交量放大的背后的意义更值得深入研究。</p>
<p>在二套房首付50%，三套房首付更是严格控制的前提下，成交量大幅提升，中国的货币到底泛滥到何种程度，中国的精英阶层的绝对数量多么庞大，手里多么有钱。中国的贫富差距很可能已经达到了一般人不敢想象的程度。</p>
<p>这是一个坏的预兆。</p>
</blockquote>
<h2 id="通货膨胀和房价的关系"><a href="#通货膨胀和房价的关系" class="headerlink" title="通货膨胀和房价的关系"></a>通货膨胀和房价的关系</h2><p>要解释通膨和房价的关系，我来建个简单的模型，跟大家说说</p>
<p>假设5年前，某个国家一共有10个一篮子生活必须品（包括吃，穿，住，行的所有的必需品），这个国家发行了100万货币，一共有10个人。那么这个国家的毎个篮子生活必须品价值10万。</p>
<p>假设这10个人每人得到了10万元收入，则每个人刚好分配了一个篮子。</p>
<p>实际情况是，这10个人中，有人得到了10万元，有人得到了8万元，有人得到12万元。那么这10个篮子通过在品质上的差别有所区分，卖给这10个人，刚好1人1份，只不过有的品质略好些，有的品质略差些。<br>时间过了5年，这个国家增加到20个一篮子生活必须品，人口还是10个人，但是发行了1000万的货币，那么这个国家的毎个篮子生活必须品价值50万。价格翻了5倍。如果每个人平均是100万，则每个人可以得到2篮子生活必需品，生活提高了。但实际上是，这10个人中，4个穷人每人还是10万，3个普通人每人是20万，剩下3个富人每人300万。</p>
<p>这3个富人共900万可以买掉18个一篮子生活必需品。剩下7个人只能分配到2个一篮子生活必需品。这样势必有人会饿死。而且无论是穷人还是普通人都买不起任何一个一篮子生活必需品。社会不可能只有富人才配生存，没有穷人，富人就不会存在。</p>
<p>因此必须有一项物品能够从一篮子生活必须品中剥离出来，吸收掉富人庞大的资金，同时也要让穷人和普通人能够买的起一篮子生活必需品中能够维持生命的最基本的生活品。</p>
<p>于是就要把一篮子生活必须品进行拆分。找到一项物品，不拥有不会饿死，但拥有能够让人过的舒服，具备高的使用价值，能够保存，具备稀缺性。</p>
<p>这个东西就是具备产权房屋（注意不是使用权），而一篮子生活必须品中其他的东西都不具备这个条件。<br>吃的不能保存，</p>
<p>衣服不具备稀缺性，</p>
<p>土地和房屋，是生产，居住，商业贸易的必需品，可以保存，具备稀缺性，富人拥有房屋土地的所有权可以租给普通人和穷人进行生产和居住。土地和房屋超过租金部分的溢价就变成了富人中吸收资金，炫耀财富的特殊品。</p>
<p>所以请注意，真正吸收大量发行的被富人拥有的货币的，是土地和房屋超过租金部分的溢价，所以房屋的租售比很低是货币大量发行造成的。房屋土地租金成为了新的一篮子货币中的必需品，而房屋土地所有权被剥离出来变成了富人之间货币再分配的游戏。<br>这样一篮子生活必须品进行了重新定义，本来包括的房屋，变成了房屋租金，而房屋所有权被从一篮子生活必须品中剥离出来，变成了吸收富人多出来的货币的奢嗜品。而一篮子生活品分成两大类，即最基本的和品质高的。</p>
<p>最基本的又变成了10万一个，保证这个国家的4个穷人可以每人得到一份。</p>
<p>品质高的，20万一个,3个普通人和3个富人每人得到一份就可以得到较好品质的生活。</p>
<p>多出来的840万，就是房屋的所有权，供3个富人拥有。房屋所有权的价格远高于租金，这是因为房屋所有权已经变成了富人炫耀的资本，身份的象征。<br>因此说，高房价的根本原因是由于货币发行泛滥和收入分配不公。这个根本问题不解决房价不可能下降。</p>
<p>而且单纯的依靠行政手段让房价下跌不但不能抑制通货膨胀，多出来的流动泛滥的货币得不到有效吸收，会推动生活必需品上涨，使穷人的生活更加艰难。<br>当然，有人的说，这多出来的840万为什么不投入到创新领域带动需求，增加一篮子生活必须品的品质。</p>
<p>这显然是不现实的，900万的财富集中在3个人手里，剩余7个人总共只分到100万，而平均一篮子生活必需品的价格是50万，7个人应该有350才能满足生活需要。购买力的不足一定会使远离生活必须品的任何东西都没有市场。</p>
<p>高房价，低租金是货币泛滥发行和分配不公的必然结果，而不是推动通货膨胀的，阻碍实体经济发展的原因。</p>
<p>货币泛滥和分配不公才是实体经济发展困难，房价高企的根本原因</p>
<blockquote>
<p>fataltomato</p>
<p>有钱人的投资渠道一般都不是房子</p>
<p>房子最多是资产配置中的一项</p>
<p>开始投房收租，说明财富控制能力的下滑，往往意味着人生下坡路的开始</p>
<p>所以诸君，还是努力赚钱改变人生为第一要务</p>
<p>评来论去，于事无补</p>
<p>别人说到了，你不一定明白，你明白了，不一定有体会</p>
<p>你有体会，不一定能做到，你做到了，不一定能做好</p>
<p>你做好了，还不一定有机会呢，呵呵</p>
<p>welldayzwb：</p>
<p>对于不善理财的人来说，买房收租未尝不是一个选择，到没必要上纲上线，当然为了收租而买房，目前看起来不是很理想的一个选择</p>
</blockquote>
<blockquote>
<p>baiyang11112010</p>
<p>我觉得LZ你的分析思路不错，但是这种涨幅应该不会再有了吧？虽然我今年4月投资了一套，但是，我能回本就行，没敢过分估计，你这样有煽动别人之心啊</p>
<p>kkndme：</p>
<p>首先投资房产不是炒股，不能有炒股的心态。目前说起投资房产是最安全的品种，指的是长线投资，而不是短线投机炒房。短线投机炒房还是因政策的不稳定有较高风险的，一旦资金链断掉，将万劫不复。</p>
<p>对于4月份，在山雨欲来风满楼的特殊时期，投资一线城市郊区房地产肯定是欠考虑的。</p>
<p><strong>对于房地产调控，主要针对一线城市，且一线城市在09年行情涨幅过大，郊区楼盘一定会受到调控影响，而资金的运作规律告诉我们，调控抑制住了一线城市的投资资金，一定有相当部分转向二三线房价相对不高的城市，大开发商对二三线城市的入住，将加速城市升级。所以调控征兆的开始，正是布局二三线城市的时机，而不是一线城市。</strong></p>
<p>值得安慰的是，回龙观地区并没有遭遇疯狂炒作，表现比较抗跌，即使被套损失也不会大。从未来两三年看，回龙观的区位一定会有50%左右的涨幅，这是不用担心的。</p>
</blockquote>
<h2 id="自住买房"><a href="#自住买房" class="headerlink" title="自住买房"></a>自住买房</h2><p>我还是觉得投资自住都要选择大开发商、大体量楼盘，不仅配套好，升值空间也大，这样的楼盘几乎没有风险。</p>
<h2 id="中国的朝代更替"><a href="#中国的朝代更替" class="headerlink" title="中国的朝代更替"></a>中国的朝代更替</h2><p>中国与西方最大的不同，是历次革命都要推倒重来，革命总是伴随着血琳琳的屠杀和破坏，无论是财富还是文化。每次建朝人民都要从一穷二白做起，所以才说中国人民苦难深重，几千年的历史，居然没有什么积累，有的只是统治者根深蒂固的帝王思想世代传承。<br>从项羽焚烧阿房宫到近代的破四旧，革命的都非常彻底，人民洗脑也非常彻底。所以帝国时代才能够一直延续。西方人贪婪对财富是占有和继承，东方人重义轻利所以破坏焚烧和屠杀。</p>
<p>西方的大革命产生了资产阶级新贵阶层，然而当时却不为普通群众接受，尽管他们有钱有势，但是却得不到群众的尊敬，直到资产阶级新贵们捐钱捐物，为群众做了大量的善事之后，才得到人民的认可。<br>而我们这个时代产生的新贵却太多的为富不仁。</p>
<p>而中国古代的乡村，通常族长就是村子里的大地主，族长是非常重视名胜的，一个族长必须有足够的威望，象修桥补路，借无米下锅的族人粮食，都是族长份内的事。去徽州旅游的人都知道，道路、桥梁等公益设施无不是富商修建。古人不但讲个人声望，还讲积阴功。假设你去贵州的深山中旅游，发现山径上常常有个亭子，不但有坐的地方，还有水井或者用水管从山上引来的泉水供路人休息。这都是周围的村里人为积阴功修建的，绝非政府投资。<br>时值社会主义的今天，反而一切行善积德的事都不讲了，全民金钱至上。没有文化建设的民族是悲哀的。</p>
<blockquote>
<p><strong>feiying：</strong></p>
<blockquote>
<p><strong>kkndme：</strong></p>
<p>一个高增长高通胀的国家，高昂的腐败成本和巨大的浪费将导致国家必须维持高税收才能维持运转，gdp保8实际上是必须的也是迫不得已的。维持正常的运转，维持庞大的消耗税收而不是创造税收的公务员队伍，没有gdp快速的增长怎么可能呢。</p>
</blockquote>
<p>这种看法很有道理，但保8毕竟会有个尽头，一旦走到头了那怎么去做呢</p>
<p><strong>kkndme：</strong></p>
<p>对于小富即安的我等小老百姓来说，希望此生不要见到这一天的到来。</p>
<p>对于流氓无产者来说，盼望着这一天的到来。届时新的英雄将从流氓无产者中产生。如同威武的 同志。</p>
</blockquote>
<blockquote>
<p><strong>facetowall：</strong></p>
<p>对lz的深厚的历史功底十分佩服。lz说改朝换代的方式有三种：1.和平演变；2.农民qiyi；3.外族入侵。我觉得前苏联的解体看似像是和平演变吧，第2、3条好像不符合。lz说zhongguo无和平演变的土壤，但是前苏联好像也没有啊。这该如何解释呢？</p>
<p><strong>kkndme：</strong></p>
<p>苏联的文化背景与中国完全不同。我国是自秦以来进入帝国时代，是一个上千年大一统的国家。<br>而苏联是在近代革命后才出现的。俄罗斯的主要人种是斯拉夫人，在日耳曼民族眼中是奴隶的意思，人种低劣。中世纪叫做罗斯地区，由基辅公国、莫斯科公国、立陶宛公国等多个公国割据，在元代一直附属于拔都建立的金帐汗国。罗斯诸国在西方中世纪非常弱小，直到波兰立陶宛联军大破德意志的条顿骑士团后，才逐渐强大。俄罗斯于1721年彼得大帝时期才开始崛起，19世纪末才成为帝国主义国家，根本就没有大一统的土壤存在，这也就是苏联能够和平演变，而中国不行的原因。</p>
</blockquote>
<h2 id="聊聊俄罗斯"><a href="#聊聊俄罗斯" class="headerlink" title="聊聊俄罗斯"></a>聊聊俄罗斯</h2><blockquote>
<p>有同志提起俄罗斯很可以再说一说的。<br>俄罗斯的前身叫罗斯公国。首都不在莫斯科，而在基辅。<br>建立罗斯公国的，是东斯拉夫人，日耳曼人眼中的劣等民族。有人说过，俄罗斯和西方国家的差别，并不仅仅是经济上的差别，而是民族和文化的差别。这种说法还是很有道理的。用我们现在的话来说，斯拉夫的人种有问题。善于侵略，欺软怕硬，野蛮无礼。这是斯拉夫人的特点。所以在罗斯的土壤，永远出不了骑士精神。<br>罗斯人信奉基督教，源于弗拉基米尔一世娶了东罗马帝国安娜公主为妻。所以我们看到的俄罗斯教堂全部是拜占庭式的。拜占庭帝国灭亡后，东正教的中心就搬到俄罗斯。<br>罗斯国并不是统一的帝国，而是象我们的西周，搞的是封建分封制（我国在秦以后就不是封建社会了，因为取消了封建分封制，丞相都是打工仔，这一点是与我们的课本不同的），到了十二世纪，礼崩乐坏，罗斯国分裂了，罗斯的周天子弗拉基米尔二世·莫诺马赫的统一大业未能完成，故罗斯的土地上居然出现了十八个公国，很有点象我们的十八路诸侯。<br>十三世纪，成吉思汗的孙子，术赤的儿子，英勇的拔都同志西征，一个强大的统一的蒙古帝国攻击分裂的罗斯诸公国，很有点欺负人的味道。于是强大野蛮的东斯拉夫人在金帐汗国的铁蹄下，当了孙子。<br>莫斯科公国的伊凡一世·达尼洛维奇以贿赂的方式从金帐汗那里获取了弗拉基米尔大公的封号，并把东正教罗斯教区总主教驻地从弗拉基米尔迁到莫斯科。<br>莫斯科大公是很有一手的，一面拍金帐汗的马屁，一面组织军队，终于利用金帐汗国的内部分裂，一举击败了马迈汗率领的大帐汗国军队，并且兼并了科斯特罗马公国、加里奇公国、白湖公国、乌格里奇公国、下诺夫哥罗德公国、木罗姆公国和苏霍纳河流域北部等广大东北罗斯地区。<br>14世纪，莫斯科大公依凡三世在乌格拉河战役中，迫使阿合马特汗撤退，终于结束了金帐汗国长达两个多世纪的统治。<br>直到1713年，莫斯科公国干掉了罗斯地区的绝大多数王公，才形成了统一的集权国家，正式命名为俄罗斯帝国。</p>
</blockquote>
<p>罗斯公国打得最精彩的战役就是楚德湖战役。<br>对手是称霸普鲁士的赫赫有名的三大骑士团之一，条顿骑士团，欧洲强大到令人恐怖的军事组织。<br>罗斯的最高指挥官是亚历山大诺夫格罗德公爵。<br>俄罗斯联军一方有1.5万到1.7万，主要是步兵。而条顿骑士团的大约有1万人，以重骑兵为主，其中大骑士应该不下千人，这是一支让整个欧洲都发抖的军队。<br>罗斯联军的步兵排成密集队形，据守冰湖东岸。骑士团的重骑兵以楔形阵发起冲锋。按常理看这是一场毫无悬念的战斗，罗斯步兵在强大的世界第一军事组织面前应该不堪一击。<br>但是亚历山大诺夫格罗德公爵是军事天才，军事才能相当于中国的乐毅。这位乐毅公爵仔细研究了重骑兵的楔形阵，认为弱点在于两翼的防御力量有限，如果重骑不能迅速撕开步兵防线，重骑的两翼会慢慢被侵蚀。<br>亚历山大同志于是把联军中主要的轻步兵安排在中间，列成加厚的方阵，消磨条顿重骑的突击能力，然后把他自己的诺夫格罗德精锐步兵放在两翼。<br>条顿骑士团的攻击开始还是成功的，但无法撕开罗斯步兵的军阵。最惨的还是条顿骑士狂妄自大，非要在楚德湖的冰面上发起冲锋（冬天结了冰），可想而知重骑兵跑到冰面上冲锋是什么样的效果，战争逐渐陷入僵持。<br>亚历山大的精锐步兵攻击骑士团的两翼，骑士团被包围了。亚历山大同志果断的派出最精锐的骑士亲兵卫队，从右翼后方包抄攻击骑士团。<br>可怜的条顿骑士，拥有世界上最强悍的战力，但在湖面上根本发挥不出来，大量的重装甲骑士掉进冰窟窿里，条顿骑士大团长也被俘虏了。<br>每次看这段历史，都为条顿骑士团唏嘘不已。</p>
<p>条顿骑士团败的最惨的是另一场战役，塔能堡。是中世纪欧洲最大规模的战争。<br>对手是波兰、立陶宛联军。<br>著名的波兰小说“十字军骑士”就是讲的这段历史。<br>骑士团的大团长是荣金根，大概有投入1万多名士兵。<br>波兰、立陶宛联军大约有3万名士兵。<br>联军方面指挥官是波兰国王Jagiello和立陶宛大侯爵Witold。<br>条顿骑士大团长荣金根是一个位标准的日耳曼大骑士，开战前，骑居然给波兰国王Jagiello送去两把剑，表示要进行一场骑士之间的较量。斯拉夫人是不敢这么玩命的，立刻拒绝了日耳曼骑士的要求。<br>条顿骑士团的骑士拥有强大的武力，真不是盖的，荣团长挥动旗枪组织冲锋，立陶宛军立刻溃败，波兰的翼骑兵也根本无法抵挡日耳曼骑士强大的冲击力，准备开始溃逃。这时一个意外发生了，大团长兼倒霉蛋荣金根同志在奋勇冲锋时突然遭了冷箭挂掉了，骑士团缺了指挥官陷入混乱，无法阻止有效的进攻，波兰立陶宛联军乘机组织起冲锋，条顿骑士团莫名其妙的大败。<br>真是谋事在人，成事在天。强大的条顿骑士的惨遭溃败居然因为一个意外。</p>
<h2 id="毛太阳的往事"><a href="#毛太阳的往事" class="headerlink" title="毛太阳的往事"></a>毛太阳的往事</h2><p>当年毛太阳发动文ge的原因是因为政府被刘奇和邓平的政经系所把持</p>
<p>当年要是老毛召开人大来决定谁去谁留，老毛肯定被PK掉</p>
<p>如此不发动底层，通过正常的程序夺不回权利</p>
<p>什么防止腐败，打到走资派都是借口</p>
<p>毛太阳比任何人都要腐败</p>
<p>死的时候存款有1亿多（不是工资积攒的，都是稿费，垄断市场的稿费）</p>
<p>70几年的时候，1亿多，确实恐怖</p>
<p>但是后来被邓平给没收了，讽刺呀，以这是全党的财富为由</p>
<h2 id="富人越富、穷人越穷"><a href="#富人越富、穷人越穷" class="headerlink" title="富人越富、穷人越穷"></a>富人越富、穷人越穷</h2><blockquote>
<p><strong>我爱的飞飞：</strong></p>
<p>其实很多空军比较SB，天天叫着加息，说是提高收入就可以买得起房子，试问穷人手里10万，富人有100万，按照现在的利息，穷人每年整存整取10万不开税收是2250元，而富人得到的是22500，加息以后假设穷人每年收入是4000，富人是40000万，成千上万的富人每年多出40000，而生产资料和资源是有限的，当每个富人的4万流入市场，试问是不是又要通膨呢？所以加息是最愚蠢的均贫富方法。行之有效的办法其实是重新发行货币。但是除了改朝换代几乎不可能。<br>其实穷人一穷就注定穷下去，除了少数几个可以翻身，原因很简单，因为生产资料掌握在富人手中，富人为什么有生产资料的支配和拥有权，答案很简单，只有革ming。<br>由此则可以明白为什么房子可以按照富人的想法定价，就因为土地，建材等生产资料掌握在富人手中。<br>妄想房子降价其实是更愚蠢的想法，为什么？GCD拼命给公务员和arm加薪，这些钱用印刷机印出来发到公务员手里最终却让老百姓埋单？统治阶层当然首先第一位维护和最大化自己的利益，任何朝代都是如此，只有当民心涣散的时候才出台一些政策缓和民心。现在看CCAV，对社会主义这充满美好想象的词的强调都逐渐弱化了，你不得不承认，在GCD的领导下大家都有肉吃了，国家安定，在这里嚷嚷的，不过是对贫富不均不满而已。</p>
<p><strong>kkndme：</strong></p>
<p>今年朝鲜搞货币改革，重新发行货币，结果导致不可控的通货膨胀，财政部长给枪毙了。</p>
<p><strong>我爱的飞飞：</strong></p>
<p>所以民众还是愚蠢的，只看到了15元最后换成1元的落差和失落，没有看到除去附加值的生产资料的价值。货币改革是富人最不愿意看到的，跟加息是一个道理，因为改革让货币的附加值骤然缩水，富人的货币不再比穷人有更多的附加值，而统治阶级恰恰是富人，没人愿意搬石头砸自己的脚。所以为什么我说不可能。</p>
</blockquote>
<h2 id="通货膨胀的形成原因"><a href="#通货膨胀的形成原因" class="headerlink" title="通货膨胀的形成原因"></a>通货膨胀的形成原因</h2><blockquote>
<p><strong>我爱的飞飞：</strong></p>
<p>在谈谈通膨是怎么形成的。生产资料是有限的，生产资料其实一直都没有变，而货币只是一种虚拟附加值而已。像楼主所言，一个国家，有人手里有8元（假设他是建材行业的），有人有12元（假设是石油行业的），但是人心不足蛇吞象，建材行业的员工觉得不够用了，8元的想变成13元，石油行业的12元想变成20元。因此，建材行业把原来卖8元的水龙头提价成13元，对于石油行业的人，装修的时候拿着12元发现自己买不了13元的龙头了，于是琢磨着把石油卖到20元，由此各行业依次提价，物价越来越高，实际上水龙头还是水龙头，一桶石油还是一桶石油，生产资料始终没有变，稀少，远远不够人均分配，但是生产资料的价值变了，提高了。拿成都的房价为例，02年的时候成都人均收入800-1200，房价2000-4000，约为房价的3倍，现在成都人均收入2500-3000，成都房价7500左右，仍然为3倍比例，看似7500比2000翻了多翻，实际上房子作为所谓的生产资料，始终是稀缺的，在02年的时候，拿着当时的工资买4000的房子仍然不容易。任何时候，其实都是一种相对平衡的比例，而空军喜欢拿现在的工资跟过去的房价相比，但是那种状态太过理想，想明白的，就会觉得房子不贵。</p>
<p>什么时候房价会下降，一句话供求关系，人口减少是房价下降的唯一出路。即便是出台房产税，很有可能富人顶着房产税不卖，变相加租抵消房产税，特别当今租房市场存在中介的操纵，很多房子都是通过中介渠道才租出，垄断的中介忽悠房东集体涨价，房产税很容易就转嫁给租房者。ZF也不是完全不作为，当你开着车逛着公园坐着快铁地铁的时候，就应该加速印刷的钞票有一部分投入了基础设施建设，如果不通过税收和出让土地收入来建设，我们很可能还走在乡间小路上。</p>
<p>虽然瓷器国是中yang高度集权的国家，但是任何朝代都是诸侯之间相互制约，上面出台个政策，各个诸侯执行与否或者执行是否到位都可以影响房价甚至很大影响，且不谈上面是不是真的想降房价，即便是动真格，下面的诸侯听不听招呼是另外一回事。有心无力的事情不是不可能发生。共同富裕其实是一种美好愿望，因为人与人的竞争天性，不可能人人平等，只要有人还想凌驾于其他人之上，就永远不可能GC主义。</p>
<p>为什么重庆可以建公租房，可以扫黄打非，为什么成都没有公租房没有扫黑扫黄？很简单个道理，皇帝可以管太子，但是不见得能够管得到大臣的贝勒爷。这样就可以理解有心无力这四个字了</p>
</blockquote>
<p>任何社会都是这样的形态，</p>
<p>忍无可忍-geming-平稳-不满足-垄断与剥削-改革-改革失败-再次忍无可忍。为何历史反反复复如此？就是因为人的劣根性，因为人性的贪婪。所以周而复始而已。</p>
<p>人性的贪婪决定了社会进程，刚开始穷人只想平均，从富人手中夺取生产资料，当GEming之后，穷人开始不满足于仅仅是平均，穷人想要凌驾于其他人之上，想变成富人，于是利用geming占有的各种手段获取利益，最终变成了富人，被凌驾的穷人再次想通过变革改变自己的地位。。。。如此循环。。</p>
<blockquote>
<p>跳坑的青蛙：</p>
<p>楼主关于精简膨胀的见解很精辟~<br>很多事情看起来、听起来很美，也仅仅是看起来、听起来而已，<br>有丰富生活经验的人仔细思考一下、观察一下就不是那么回事了~</p>
<p><strong>kkndme：</strong></p>
<p>是啊，很多空空们扯着脖子呼喊这个政策那个政策，殊不知执行下来，最倒霉的还是自己。管老爷利用空空们鸡冻的心情趁机敛财，赚个盆满钵满。等空空们明白过来，也没办法了。<br>好比许多人最欢迎的费改税，结果税增加了，费却一点没见少。</p>
<p>关于通货膨胀问题，体制内的职工工资一定会与时俱进的。体制外人员的薪水不取决于通货膨胀，而是取决于行业的利润率，企业的利润和个人的能力运气。对于多数竞争激烈，产能过剩行业内的民营企业一般员工，工资增长是很难抵御通胀的，而且由于通胀导致生产成本的价格上涨，减薪甚至裁员的可能反而更大。</p>
</blockquote>
<blockquote>
<p><strong>facetowall：</strong></p>
<p>另一个问题啊，我准备用住房公积金购买首套房，在其它的一些帖子上看到政府将在某个时间点上加息，那么对住房公积金的贷款利息（3.87%）会不会同样上调呢？上调幅度会是多少？对这个比较关心，麻烦楼主给解答一下吧。谢谢了！</p>
<p><strong>kkndme：</strong></p>
<p>如果当年加息，再次年的元旦后贷款利率也会相应增加，但公积金贷款利率增加的幅度很小，不用担心。加息说明通货膨胀严重，如果不是连续过度加息，对房价没有影响。从长期看更是不可能影响房价上涨趋势，除非经济崩溃。如果经济崩溃，持有纸币也没有意义，等同于废纸。<br>90年代我国高度通货膨胀，银行存款年利率曾达到百分之十几，但并没有影响房价的上涨趋势。</p>
</blockquote>
<h2 id="有外来人口和没有外来人口的区别"><a href="#有外来人口和没有外来人口的区别" class="headerlink" title="有外来人口和没有外来人口的区别"></a>有外来人口和没有外来人口的区别</h2><p>贵阳与成都、昆明这些西部城市略有区别，昆明、成都有大量的外地人口，这些外地人口构成了买房刚需，因此市区位置的稀缺性就显得尤为重要。<br>但是贵阳的外地人口相较昆明、成都要少，以本地改善型需求为主，所以城区楼盘的档次尤为重要。<br>作为相邻的省会城市，重庆的吸引力要大于贵阳，贵州许多地州的资金可能会被重庆分流。</p>
<h2 id="首付提高的逻辑"><a href="#首付提高的逻辑" class="headerlink" title="首付提高的逻辑"></a>首付提高的逻辑</h2><blockquote>
<p><strong>tianxiaobing11：</strong></p>
<p>请教楼主，最近有银行提高了首付，这是为什么？政府真要让中低层租房子吗？政府吃租赁的大蛋糕吗？</p>
<p><strong>kkndme：</strong></p>
<p>主要还是防范金融风险，政府调控的目的从来也不可能是解决穷人的买房问题。恰恰相反，金融风险来自于让穷人买房，所以提高首套房首付比例，杜绝穷人买房，才是防范金融风险的有效手段。同时可以推升租金上涨，政府推出的公租房才有市场，有钱可赚。</p>
</blockquote>
<h2 id="政府搬迁"><a href="#政府搬迁" class="headerlink" title="政府搬迁"></a>政府搬迁</h2><blockquote>
<p><strong>xhyyhzy：</strong></p>
<p>楼主您好，从您的帖中收获很多。觉得以前真的被洗脑洗的很厉害，从天涯学到很多。非常感谢您，又让我明白了很多事情。</p>
<p>请教您，市政府从原来的市中心，搬迁到另外一个地方，相对较远，因为城市不大。好的医院，学校，各种好的资源都在市中心。现在搬到一个特别偏远，荒凉的地方，重新开始建设，政府这么做是什么意思阿？以后这些医院，学校也会搬吗？多浪费阿。另，您怎么看该城市未来房价的变化。（注，离上海很近的3线城市）</p>
<p>期待您的分析。</p>
<p><strong>kkndme：</strong></p>
<p>政府搬迁到郊区不仅仅是个别城市问题，而是大多数二三线城市面临的问题。政府的用意在于扩大城市规模，扩充人口，追求gDP的高速增长，但对于新开发出一块荒郊野地，没有政府的带头搬迁，是很难炒作起来的。政府的迁入是一个信号，告诉老百姓，政府都搬过去了，以后配套肯定不会有问题。于是概念将透支未来，房地产价格就会飙涨。但是未来建成后政府是否真的搬迁就不一定了。<br>医院和学校全部搬迁会加深社会矛盾，所以通常是在新规划的区域建分校。如果自住还是主城，如果投资投机，可以考虑新城。</p>
</blockquote>
<h2 id="kkndme聊北宋、唐朝"><a href="#kkndme聊北宋、唐朝" class="headerlink" title="kkndme聊北宋、唐朝"></a>kkndme聊北宋、唐朝</h2><p>北宋时期，有个文豪及公务员叫苏东坡，一辈子也没能在首都开封买上房子，不得已，在外省小县城投资了几套房地产。苏文豪公务员的儿子在首都结婚的时候，居然都没搞到一套新房，苏公务员急眼了，最后想办法跟朋友借了一套房子，总算把喜事办了。北宋跟我们的现实还是有区别的，象苏文豪公务员这样的中层国家干部，在京城大都是有几套房子的。可见北宋时期公务员待遇还不如现在。</p>
<p>苏文豪公务员的弟弟苏辙就比较幸运了。该同志也是公务员国家干部，工作上兢兢业业，勤勤恳恳，熬了几十年工龄，在七十岁的时候终于买到了房子，但是买的位置还算不上首都开封，而是在开封南边的许昌买的，相当于首都的卫星城。就好比在北京买不起房的同志，跑到天津去搞了一套。<br>苏辙公务员同志专门为买房的事写了诗，“我生发半白，四海无尺椽”，我老未有宅，诸子以为言”诗的意思反正是比较愤青，很想现在的傻空</p>
<p>唐朝还有个白居易同志，也是个公务员，级别相当于正处级，工作是在中央办公厅负责校对红头文件。白公务员职务一般，但工资可不低，每月一万六千钱。但是白公务员却买不起房，在长安东郊常乐里租了四间茅屋，因为房租比较高，城区的租不起，所以上班比较远，很潇洒的买了一匹马，相当于我们买车。白公务员还是很懂享受生活的，雇了两个保姆，每月的总支出大约是七千五百钱。白公务员很象蜗居里的海萍，不肯高价租城里的好房子，而是把剩下八千五百钱存起来，一心要买套房。但是存了十年，他也没能买的起长安的房子，白公务员兼诗人的文学功底很高，但是不懂经济，不了解通货膨胀。</p>
<p>最后白公务员急了，很愤青的说：“你们局级干部在长安炒房子，我处级干部就去周边炒房子。”于是白公务员跑到长安城的卫星城——陕西渭南县，买了套房子，平时在单位蹭房子住，逢假期和周末回渭南的家里跟老婆叉叉呕呕。可见唐朝时处级及以下公务员待遇也就跟我们的都市普通小白领差不多。</p>
<h2 id="王安石的青苗法之国家出政策的动机"><a href="#王安石的青苗法之国家出政策的动机" class="headerlink" title="王安石的青苗法之国家出政策的动机"></a>王安石的青苗法之国家出政策的动机</h2><p>关于呼唤国家出政策已达成自己买车买房心愿的空空们，有必要听听王安石变法的故事。</p>
<p>我国的官僚有几千的当官经验，最不怕的就是新政策，只要是新政策，无论目的是为了民生还是敛财，反正就找到了由头，就有办法敛财，有空子可钻。</p>
<p>王安石变法的初衷是好的，但是不了解中国的官僚体制，变法让老百姓吃饭都成为了困难，加速了北宋的灭亡。所以盼着出房产税的空空要认真的用脑子想问题，梗着脖子泄愤是没有用处的。</p>
<p>说说王安石同志的青苗法。</p>
<blockquote>
<p><strong>tjOOSAN:</strong></p>
<p>我想 这个 “房产税”出不出。不是什么决策问题吧？</p>
<p>是我们产权的解释问题！我们产权只有70年，换句话说就是租七十年，地和房子本身还是国家的！那么国家的房产再收税，是不是有点法理不通呢？ 这是 郎咸平说的</p>
<p>楼主！这个。你让我再次质疑你了</p>
<p>我其实 很想看进去你的文章！可惜。。。。唉 这成了您的历史秀了~~ 海</p>
<p><strong>kkndme:</strong></p>
<p>连法制国家都不是还提什么法理。</p>
<p>拆迁条例是违背宪法的，后来又违背了物权法，但是管用的既不是宪法也不是物权法，而是拆迁条例。一群人说要修改条例，牵扯到利益就没了下文。</p>
<p>有时间你不妨研究一下，看看我们的政策有多少是违反宪法的。<br>在中国拿法理说事就比较搞笑了</p>
</blockquote>
<p>青苗法，按理说是一项最为民生考虑的政策。</p>
<p>在百姓青黄不接，缺少粮、钱的时候，让老百姓自己估计当年谷、麦产量，先向官府借钱，谷熟后还给官府，称“青苗钱”。</p>
<p>青苗法规定把以往为备荒而设的常平仓、广惠仓的钱谷作为本钱。每年分两期，即在需要播种和夏秋未熟的正月和五月，按自愿原则，由农民向政府借贷钱物，收成后加息，随夏秋两税纳官。</p>
<p>实行青苗法的目的肯定是好的，可以让农民在青黄不接时免受高利贷盘剥、并且让农民不至于在没粮的时候土地被大地主所兼并。同时,让政府获得一大笔“青苗息钱”的收入————单纯为了民生，政府收不到钱的事情王安石同志也不同意。 </p>
<p>按理说，出了这个政策，农民该欢呼了，zf出面了，农民们不用受地主老财剥削了，很多傻空老农民鸡冻的喊：“还是王领导的政策好啊。”</p>
<p>地方官员也鸡冻了：“太牛了，发财的机会来了，王领导这人人品虽然不怎么样，但是很给我们挣钱的机会啊。”</p>
<p>于是，王领导的青苗法一推行下去，完全走样了。</p>
<p>首先青苗息钱从王领导定的年息二分，本来就挺高的贷款20%利率，比我们房贷可高多了。但是就这个年息二分，在地方一下子变成了半年息二分，年利率高达40%：因为是春季发一次贷款，秋季发一次贷款，所以地方官每半年收回本利，还是按二分收，所以变成了半年息二分，年息四分。到了后来地方官想怎么收怎么收，甚至年息高达百分之几百。</p>
<p>傻空农民立刻傻眼，说反正自愿的，我不贷还不行吗？接着管地主老财借不行吗？</p>
<p>zf说了：不行。你贷也得贷，不贷也得贷，于是变成了强制高利贷。</p>
<p>王领导在推行青苗法的时候，还下了定额，贷款多少那是有任务的。任何朝代推行某个政策，只要涉及到收钱，都是有任务的。</p>
<p>王领导下达了任务，地方官必须完成，不然要罢官丢脑袋，扣个阻碍变法的帽子可不得了，同时本着无利不早起的伟大思想，不但要完成任务还要层层加码。</p>
<p>这下，傻空老农民彻底傻了，饭都吃不上了。</p>
<p>结果是王领导给zf增加了税收，官员闷声大发财，老百姓彻底崩溃。</p>
<p>所以请呼唤房产税的朋友，好好读一下王安石变法</p>
<p>读懂历史</p>
<p>对自己真没坏处。</p>
<p>王安石不但动员zf放高利贷。</p>
<p>还是我国搞中央政采、垄断企业和官倒的先驱。这就是王领导推行的均输法。</p>
<p>宋初以来，为了供应京城皇室、百官、军队的消费，在东南六路设置发运使，负责督运各地“上供”物质。 　　</p>
<p>发运司只照章办事，各路丰年物多价贱时不敢多办，歉年物少价贵时却又必须办足。物货运到京城后往往因不合需要而削价抛售，朝廷所需却又要另去搜括。这些做法给富商大贾操纵物价，控制市场，囤积居奇提供了方便。</p>
<p>王领导希望能够节省劳务费，减少政府的财政支出和减轻人民的负担，就想出了均输法，相当于中央政府采购。 </p>
<p>于是官府直接做生意，行政机构变成了大型国有垄断企业。</p>
<p>中石化、中石油、中国移动、电力等大企业的苦大家都吃过。</p>
<p>垄断企业的低效率，fb，强迫定价，强制消费，这些古今中外都是一样。</p>
<p>而且老百姓跟官府做生意，必须得上供。zf采购那是要多黑有多黑。<br>紧俏商品，官倒搞双轨制，体制内搞配额，体制外高价卖指标。<br>结果是zf闷声大发财，老百姓直接崩溃。</p>
<p>王领导的独断专行，刚愎自用还是很为大家所称道的，呵呵</p>
<p>张居正的一条鞭法从地主阶级的利益出发，反而成功了。</p>
<p>而王领导从民生的利益出发，搞改革，失败的很惨。</p>
<p>不能不说，历史是很搞笑的</p>
<blockquote>
<p><strong>中年不惑吗</strong></p>
<p>符合地主阶级利益的张居正变法？？</p>
<p>怎么后来张被清算呢？</p>
<p>封建社会官僚本来就是地主阶级的代言人</p>
<p><strong>kkndme:</strong></p>
<p>张同志的清算不是因为变法，而是把万历同志架空了，比皇帝还牛的首辅能活到寿终正寝已经算是奇迹了，跟他的变法无关。</p>
<p>这位徐阶先生的得意门生，政治上是青出于蓝的，无懈可击，贪污受贿大概也师承徐阶吧，呵呵</p>
<p>很多人只对张居正同志是否和太后有一腿感兴趣，呵呵</p>
<p>张居正通常是以正面形象出现，但是在贪污受贿方面是很有一手的。另一个贪污受贿的正面人物是戚继光。</p>
<p>我国历朝历代的体制，不搞点潜规则什么事都干不成。</p>
<p>比如一事无成的海瑞，光赢得了个好名，其实毫无建树。</p>
<p>关于写青词的严嵩搞掉了正值的夏言，忍耐力超强的徐阶搞掉了老奸巨猾的严嵩，心狠手辣的高拱搞掉了徐阶，而张居正又搞掉了高拱。</p>
<p>这是各机关、企业学习政治斗争的最好案例啊。</p>
</blockquote>
<h2 id="什么是社会公平"><a href="#什么是社会公平" class="headerlink" title="什么是社会公平"></a>什么是社会公平</h2><p>古今中外，任何一次武装革命，无论最终成功还是失败，上位者因为野心的极度膨胀，都变得更加专制。陈胜、李自成、朱元璋、罗伯斯皮尔、斯大林、 ，都是一个个鲜活的例子。<br>真正公平的社会并不是均贫富、等贵贱的乌托邦，也不是贵族享有领地少女初夜权的强权社会，而是法制社会，大家在一个完善的法律制度下，享有人身和财产自由，知道什么该做什么不该做，法典之下对于任何人都是平等的，无论是平民还是权贵。<br>作为爱好和平，小富即安的我等小民，最愿意看到的是社会的稳定而不是动乱。</p>
<h2 id="还是有很多有钱人"><a href="#还是有很多有钱人" class="headerlink" title="还是有很多有钱人"></a>还是有很多有钱人</h2><p>说起空空们们不买房是因为没钱，我还真不相信。<br>在某二线城市，调控重拳刚出的时候，我赶紧去买房，碰见一个大姐。<br>那个大姐很有意思，说从08年底看房，一直觉得房价高，所以坚决不买，结果等到了2010年，一直盼着降，但是调控政策刚一出就心慌了，害怕后面是大暴涨，赶紧把房买了，这位大姐买房是一次性付款。到现在房价涨了30%。</p>
<h2 id="双轨制之体制内的福利"><a href="#双轨制之体制内的福利" class="headerlink" title="双轨制之体制内的福利"></a>双轨制之体制内的福利</h2><blockquote>
<p><strong>汝爱之罪</strong></p>
<p>水木社区上有很多愤青打电话给北京建委，举报领秀慧谷捂盘内购的事，我跟了个贴子说不要太幼稚，结果被骂的很惨。今天他们接到建委电话了，说是没有违规。我在想：有这些不明真相的群众存在，房价怎么会跌呢？通胀怎么会停呢？股市IPO怎么会停呢？底层不被收割就奇怪了</p>
<p><strong>kkndme：</strong></p>
<p>让北京建委去查国资委就比较搞笑。北京的房优先安置各大部委，剩余很少的部分才用于商品房开发，所以才说北京四环房价5万一平都不算贵。</p>
</blockquote>
<h2 id="开发商思维"><a href="#开发商思维" class="headerlink" title="开发商思维"></a>开发商思维</h2><p><strong>鼻使豆豆：</strong></p>
<p>高房价不可怕，可怕的是没有辩别是非的能力，明明是老百姓，却有开发商的意识，可悲</p>
<p><strong>kkndme：</strong></p>
<p>其实这个道理是很浅显的，你不买房并不能代表房价不涨，而你买了房不但可以住的舒适，还可以获利。反而是有开发商的思维才能有好日子过。</p>
<p>这个道理跟炒股票是相同的。大家知道，股票与房地产不同，并不能创造财富，只是财富再分配的工具，但是财富再分配，是庄家分配散户的钱，而不是散户分配庄家的钱。所以炒股要有庄家的思维才能挣钱。</p>
<p>道理都是一样的。</p>
<h2 id="农民政权的缺点"><a href="#农民政权的缺点" class="headerlink" title="农民政权的缺点"></a>农民政权的缺点</h2><p><strong>tianxiaobing11：</strong></p>
<p>请问楼主，为什么历史上的农民起义军领袖，一旦得势后比原来的统治阶级还残暴呢？像黄巢，张献忠等等</p>
<p><strong>kkndme：</strong></p>
<p>是因为缺乏一个纲领。</p>
<p>农民伯伯因为没饭吃拿起武器造反了，造反之后怎么办？——对不起，从来没想过。国家治理到底是怎么回事？——对不起，一概不懂。</p>
<p>比如陈胜，刚占了一块地盘就不知道姓什么了，老子天下第一，农民暴富后，就想拼命享受，自己的属下和革命战友在自己眼中就是一坨屎，就更别说老百姓了。武装还没胜利呢，就生怕别人夺权，大搞内部政治斗争。吴广挂掉最高兴的就是陈胜。太平天国表现的更是淋漓尽致。</p>
<p>朱元璋就不同，是个军事天才和政治天才，懂得治国之道，有做皇帝的野心，也懂得当皇帝需要的知识，朱清楚的知道靠均贫富等贵贱是不能坐天下的。</p>
<p>古代能够夺取天下的，基本都是贵族阶层，有野心有理想有知识。最典型的就是李世民。汉高祖刘邦同样不是单纯的流氓无产者，他幸运的娶了吕雉，一跃成为地主家族的一员。</p>
<p>历史上只有朱元璋是个异数。这也是毛为什么要推崇朱的原因。</p>
<h2 id="郑州有前景"><a href="#郑州有前景" class="headerlink" title="郑州有前景"></a>郑州有前景</h2><blockquote>
<p><strong>larryzs：</strong></p>
<p>最喜欢看楼主评说历史了</p>
<p>呵呵，看来历史要重新好好读一下了</p>
<p>不知道楼主对河南郑州的房价了解吗？</p>
<p>希望楼主对郑州将来的发展分析一下。</p>
<p>现在郑州的房价均价也差不多快到6000了，郑东新区的一万以上。</p>
<p>市政府也在大力修建地铁，个人认为还是有发展前景的。</p>
<p><strong>kkndme：</strong></p>
<p>郑州的交通区位决定了经济发展的空间，同意你的说法，很有前景</p>
</blockquote>
<h2 id="公园地产是稀缺资源"><a href="#公园地产是稀缺资源" class="headerlink" title="公园地产是稀缺资源"></a>公园地产是稀缺资源</h2><blockquote>
<p><strong>klid：</strong></p>
<p>LZ，省会城市二环边公园边房产和市中心无天然气房产，选择哪个比较好？</p>
<p><strong>kkndme：</strong></p>
<p>公园地产未来是稀缺资源，市中心虽好，但是没有天然气毕竟不方便。两者相较还是公园边合适。</p>
</blockquote>
<h2 id="张献忠屠川"><a href="#张献忠屠川" class="headerlink" title="张献忠屠川"></a>张献忠屠川</h2><p>关于张献忠屠四川，尽管学术上存在争议，但大致是不差的，虽不见于正史，但《蜀碧》及《求幸福斋随笔》都有记录。很多学者也做了大量的考证。</p>
<p>张献忠此人曾经读过书，做过zf最基层公务员——捕快，但是被开除了。人格比较扭曲，不但好色，且好杀成性，是典型的流氓无产者。大明的苦难子民指望这样的有严重心理疾病的杀人狂拯救，那是毫无指望的。</p>
<p>张献忠每攻城略地特别喜欢把当地的妇女同志送进军营当营妓，并且乐此不疲，军队没粮了，就把美丽的少女切成块做成腊肉。把儿童成群的围起来用火烧，谁往外跑就用刀刺，也是张大义军领袖最喜欢的游戏。</p>
<p>对于张的行为，我们只能用有严重的心理疾病来解释。</p>
<p>一个仇视社会的愤青，掌握了军队，破坏力是相当可怕的，是人民的灾难。</p>
<p>张攻陷四川建立大西国政权，与柬埔寨的红色高棉政权简直是异曲同工。以至于清军进入四川受到了百姓的欢迎而不是抵抗。这跟越南入侵柬埔寨，越南军受到了柬埔寨人民的欢迎是多么相似啊。</p>
<p>人民的眼睛是雪亮的，违反人性的，即使打着爱国的旗号，也终将被人民抛弃。</p>
<h2 id="洪秀全、黄巢、李自成"><a href="#洪秀全、黄巢、李自成" class="headerlink" title="洪秀全、黄巢、李自成"></a>洪秀全、黄巢、李自成</h2><p>洪秀全同志，人生比较悲剧，人家好歹是个落地秀才。洪教主考了20多年，连个秀才都没考上，相当于小学都没毕业。</p>
<p>洪教主考试不行，搞邪教确是个高手，夜里做梦居然梦见上帝（形象大概是个白胡子老道）说洪教主是他的二儿子。这个梦确实不太靠谱。很可能是洪教主有意编的。</p>
<p>洪教主的拜上帝教应该算是白莲教的一支或者说是余孽。</p>
<p>洪教主搞革命，对解放劳苦大众却一点不感冒，最感兴趣的是一夫多妻制，娶了88个后妃。好像历史上的农民军领袖对妇女同志都有出奇好感，大概是小时候性压抑的结果。</p>
<p>太平天国攻下南京得了半壁江山，洪教主从41岁开始，直到11年后自杀，竟然没出南京城一步。大概是收罗的漂亮的妇女同志太多了，实在没有时间干别的。</p>
<p>比起张大义军领袖的变态，洪教主还是比较有人性。好色，人之天性。</p>
<p>不过洪教主进南京，并没有因为女性的爱情滋润，而让他变得温柔。虽然没有张大领袖变态，实行的也是三光政策：杀光、烧光、抢光。</p>
<p>“凡掳之人，每视其人之手，如掌心红润，十指无重茧者，恒指为妖，或一见即杀，或问答后杀，或不胜刑掠自承为妖杀，或竞捶楚以死。”大意是手上没长茧子的就是妖人，就要统统杀掉。</p>
<p>农民起义带来的不是均田地等贵贱的乌托邦，而是血腥恐怖</p>
<p>说起洪教主玩弄的美女确实让人流口水，除了88个妃子外，女官侍婢不计其数，算下来用了11年时间玩了2300名妇女。</p>
<p>有一本《江南春梦笔记》：王后娘娘下辖爱娘、嬉娘、妙女、姣女等16个名位共208人；24个王妃名下辖姹女、元女等七个名位共960人，两者共计1169人。以上都属嫔妃，都是要和洪秀全同床共枕的。天王府不设太监，所以另外还有许多服役的“女官”。以二品掌率60人各辖女司20人计算，合计为1200人。各项人数加起来，总计有2300多名妇女在天王府陪侍洪秀全一个人。</p>
<p>一个农民当了教主，就有这样的眼福。换做了傻空当教主，会怎么做？</p>
<p>黄巢比洪教主学问要高一些，但是屡试不第，当了私盐贩子。</p>
<p>从起义的第一天开始，黄巢的脑子里也从来没有过百姓该如何如何的。</p>
<p>他是一个彻头彻尾的投机分子，说是义军，不如说是强盗。</p>
<p>新唐书中说，贼军所过州县，老百姓皆烧杀殆尽。黄巢的兵可并不懂三大纪律八项注意，那是能抢救抢，抢不了就烧就杀。</p>
<p>无论是旧唐书、新唐书、还是资治通鉴，从头到尾，就没有出现过黄巢的一句好话。</p>
<p>黄巢攻陷广州，至少屠杀了十二万人，把皇帝气晕了。</p>
<p>皇帝还知道体恤子民呢，而黄巢就是彻头彻尾的强盗外加杀人犯。</p>
<p>黄巢攻进长安当了天子，充分显现了流氓无产者的本质，穷奢极欲，挥霍无度，治理国家的事彷佛就跟他没有一点关系。不搞建设就只能做吃山空，结果长安的粮食都被糟蹋完了。</p>
<p>长安没有余粮，黄巢就把长安老百姓抓来，煮着吃，十万大军靠吃老百姓过日子。</p>
<p>幸好老天开眼，官军打进了长安，结果是老百姓对官军夹道欢迎。<br>农民军真是义军吗？</p>
<p>不但中国的农民军领袖都是杀人魔鬼的化身，就是法国资产阶级大革命领袖罗伯斯皮尔，同样也是法西斯暴政的先驱者。最后被人民送上了断头台。</p>
<p>只有一个真正的法制化国家，人民在法律的制约下，享有人身与财产自由，才能够安居乐业。</p>
<p>李自成在军队纪律上，是要比张献忠高明一点的，所以李自成打进了北京。李自成到北京后，拷贝了黄巢进长安的淫乐经验，对美女极尽淫乱之能事，对百姓烧杀抢劫做的也很出色。</p>
<p>历代农民军对妇女的态度与《水浒传》中梁山好汉完全相反。</p>
<p>施耐庵笔下的梁山好汉们似乎对妇女有天生的仇视，动不动就把女同志劈死，李逵甚至终生不尽女色，就凭这一点，我们只能说梁山好汉是农民军中的异类。</p>
<p>但是梁山好汉不是为了起义，而是为了招安。一群由小公务员和渔民组成的社会最底层群众梦想通过拉山头再跳槽的方式走进金字塔的中层，但是这个梦想破灭了。</p>
<p>古代历史上，能够治理天下的穷苦人，只有一个：朱元璋。</p>
<h2 id="朱元璋"><a href="#朱元璋" class="headerlink" title="朱元璋"></a>朱元璋</h2><p>为什么朱元璋可以，而别人不可以。</p>
<p>经过仔细研究发现，朱元璋的人生际遇不像黄巢、张献忠和李自成，他有点像刘邦，但又有很大区别。</p>
<p>朱元璋是一个到处要饭吃的和尚，但是喜欢思考，见世面，交朋友，并且找到了自己的宗教信仰——明教（也叫摩尼教、白莲教）。</p>
<p>朱元璋走投无路投奔起义军的时候，娶了起义军濠州大帅郭子兴的义女当老婆，就是那个著名的马皇后。郭子兴并不是一个农民，而是一个大地主，所以朱元璋加入的这个新家族，思想完全不同一个扛着扁担造反的农民。</p>
<p>郭子兴作为农民军的统帅，却在逛街的路上，被其他的农民军兄弟（真正的农民）绑了票，大概是因为农民对地主阶级比较仇恨。最后被朱元璋救了出来。</p>
<p>郭子兴看见朱元璋比自己强，反而起了憎恨之心，一心想把朱元璋弄死。</p>
<p>朱元璋在丰富的人生经历中看到了农民起义军领袖们的鼠目寸光，要想成大事，必须有远大的理想和抱负，而这些是黄巢、张献忠、李自成、洪秀全都没有的。</p>
<p>朱元璋与那些个农民军领袖最大的不同在于，他熟读历史，因此他把汉高祖刘邦作为榜样。目标是建立一个基业长青的强大统一的国家。</p>
<p>朱元璋就懂得无论是得到天下，还是治理天下，就必须有能力的人来辅佐。嫉贤妒能的人只能被历史的车轮碾碎。</p>
<h2 id="曹参治国"><a href="#曹参治国" class="headerlink" title="曹参治国"></a>曹参治国</h2><p>人们最希望的，就是在一个良好的社会环境下，安居乐业，自食其力。zf的职责就是健全法制，维护一个良好的环境，剩下的事，交给民间去做。三天两头出政策，过度插手百姓如何过日子，甚至朝令夕改，就会让百姓的正常生产生活无所适从。<br>早在汉朝初期，曹参已经参悟了这个道理。<br>曹参是刘邦当亭长时的领导，也是刘邦最亲密的战友。萧何是文官，曹参则是武将，曾经在韩信麾下效力，除了披坚执锐外，最重要的工作就是监视韩信，防止韩大军事家谋反。<br>这样一个万夫难敌的勇将，却在革命胜利后被分配给齐王刘肥（刘邦的私生子）当相国，主抓齐国的政务。</p>
<p>曹参是一介武夫，只懂得军事，并不懂治理地方，就用厚礼聘请了精通黄老之术的盖公。盖公认为：治理国家很简单，只要按照律法办事，给老百姓提供一个安全的稳定的环境，其他的都不用管，官府千万不要好大喜功，追求政绩，过多插手百姓的事物，顺其自然就好了。<br>曹参很赏识盖公，并且按照盖公的话去做，九年的时间，齐国变得非常繁荣。<br>这时候，传来噩耗，萧何挂了，皇帝刘盈聘请曹参出任相国。曹参上任以后，几乎罢免了所有办事效率高、口才好，有追求有抱负的能吏，提拔了一群只知道按部就班，照章办事的老实巴交的官员，然后就彻底大松心，成天喝酒吃肉听小曲。</p>
<p>很多人对曹参不满就给皇帝刘盈打小报告，刘盈的表现是很愤怒。<br>曹参就问刘盈：是陛下你牛呢，还是先皇刘邦牛呢？<br>刘盈：当然是先皇牛<br>曹参又问：那我跟萧何比，谁牛呢？<br>刘盈愤怒的说：你比萧何差远了。<br>曹参做了个总结：您讲的太对了，先皇和萧相国拟定的法令已经非常清楚了，只要贯彻执行下去就好，我只要按照他们的法令办，不就行了吗？<br>刘盈虽然不事朝政，但应该算是比较聪明的君主，一听就懂：对于已经定下的治国方针大略，只要执行下去，一定会使人民休养生息，国家富足。如果大搞政绩工程，对于先皇刚死，吕后掌权时期风雨飘摇的大汉来说，将是灾难性的。<br>民间把成天喝酒吃肉听小曲的曹参称为贤相。司马迁在史记中也给了曹参极高的评价。</p>
<p>假设一个工程队要盖楼房，起初设计人员设计了20层，刚盖了两层，队长换人了，非要盖成30层，工人于是绞尽脑汁费劲办法改造。等盖到25层的时候，又换队长了，新队长说还是改成两层的别墅吧。刚把楼房都拆掉，别墅建了一半，又来了一个队长，说要建成比迪拜塔还高的大塔楼。这个楼建了n年也没建起来。<br>建房子跟治国的道理是一样的，我国汉代的相国曹参就已经明白了这个道理。</p>
<h2 id="晁错"><a href="#晁错" class="headerlink" title="晁错"></a>晁错</h2><p>刚才有人提到吴楚七国之乱，讲得是晁错。晁错其人是很值得讲讲的，一个有才能的人在错误的时间做了一个理论上正确的事，却导致吴楚七国之乱，汉景帝差点完蛋。结果是景帝砍了晁错的脑袋。</p>
<p>这个故事，几乎家喻户晓，蕴藏的道理却很深，大家如果懒得看史料，有兴趣可以参看易中天“帝国的惆怅”，还是很值得一看的</p>
<h2 id="民营小企业的老板和打工者"><a href="#民营小企业的老板和打工者" class="headerlink" title="民营小企业的老板和打工者"></a>民营小企业的老板和打工者</h2><p>糊涂人即使把道理说的再浅显，他也听不明白，呵呵。<br>现在我国已经进入高通胀期，但是地方巨额债务与人民币的升值又封杀了加息的空间，经济形式有可能恶化，民营小企业的老板和打工者只能自求多福了。</p>
<blockquote>
<p><strong>汝爱之罪：</strong></p>
<p>刚查了一下央行的数据，8月份的M2是68.75万亿，我没记错的话，7月份的M2控制的很好，基本没怎么涨，但是到了8月份，没想到有那么猛的涨幅，看来不到12月，我国的M2就要到70万亿了。2007年1月份，我国的货币供应量是35万亿。</p>
<p>今早去小摊买早点，原来一块五的加鸡蛋灌饼现在卖两块。如果涨工资，只会把通胀越推越高，如果不涨工资，P民就要忍受通胀的剥削。真是无语了</p>
</blockquote>
<h2 id="郭解"><a href="#郭解" class="headerlink" title="郭解"></a>郭解</h2><p>从古到今，小老百姓遇到不公，受了委屈，幻想最多的就是跳出一个大侠，劫富济贫，为自己伸张正义。所以金庸的小说广为流传，被称为成年人的童话。<br>我国古代，真有大侠，不过古代的大侠并不是会降龙十八掌的郭靖，也不是小李飞刀，而是黑帮的老大，相当于西方的教父。<br>最有名的大侠叫郭解，汉朝时有极高的威望，不然也不会写进史记。<br>郭解的爸爸是个职业杀手，非常有名，用古龙的话说，最厉害的杀手是没有名字的，郭解的老爸名声太大，注定活不长。有个米商请郭解的老爸到监狱里救出犯了法的儿子，郭老爸看在钱的份上去了，就再也没能回来。</p>
<p>郭解跟他老爸学过功夫，很有两下子，于是干起了抢劫和盗墓的这份很有前途的职业。因为功夫高，谁只要说句话让他不爱听，必然遭遇一顿暴打。本着流氓会武术谁也挡不住的精神，到了三十岁，郭解已经钱多的数不过来了。男怕入错行，女怕嫁错郎，看来抢劫和盗墓的职业选择对了。<br>30岁以后，郭解为了从强盗升级为教父，开始积累自己的名声，并且学习战国四公子，开始蓄养门客，但凡是哪个人有难，有求必应。俨然形成了一个严密的黑社会组织。在民间的声望，甚至超过了皇帝。<br>皇帝的权威是不容冒犯的，一个地方黑社会头子怎么能够这么嚣张呢？就把郭解抓了起来，虽然有大量的证据证明郭解作奸犯科草菅人命，但都是汉武帝大赦前的事情，没有办法定罪。汉武帝一筹莫展，人抓了不能定罪，又不能放掉，该怎么办呢？<br>这时，正好有个书生，骂郭解不遵纪守法。正巧被郭解的门客听到了，就把那个书生给杀了。<br>汉武帝听了哈哈大笑，正巧找这个理由把郭解灭族。<br>侠客的黄金时代，从此结束</p>
<p>剑侠情侣，快意江湖，听着是一个充满了浪漫的世界，而事实是完全不可取，一个没有法制的社会，奉行者赤裸裸的丛林法则，什么是对？什么又是错？理由就永远站在强者一边，强者可以随自己的意愿决定弱者的生死。<br>这个社会是可怕的。<br>郭解，就让他永远埋葬吧</p>
<h2 id="2010年的中国房地产"><a href="#2010年的中国房地产" class="headerlink" title="2010年的中国房地产"></a>2010年的中国房地产</h2><blockquote>
<p><strong>汝爱之罪：</strong></p>
<p>今天跟家里人打电话，姨妈说了下近一年来老家云南东北方向一个地级市曲靖的变化。</p>
<p>主要就是：好些有资金的外地大佬大手笔拿地，开发酒店和商品房。都是市区的黄金地段。</p>
<p>其实房地产开发在中国的任何一个城市每天都在发生，不过令人感慨的是这样的“四线”城市也如此火爆，购买力之强令人感慨，她说最近几天曲靖正在举行房交会，人头攒动。<br>现在老百姓有钱都向往好的房子和户型了，已经不满足90年代的老旧房子了，而且通货膨胀也逼得大家不得不置业保值。</p>
<p>再回头看看北京，简直找不到跌的理由。那么多地铁要修，那么多优质生源每年涌向北京高校，那么多人口，每天要造就那么多富人。。。。</p>
<p><strong>kkndme：</strong></p>
<p>钱太多了，流动性泛滥，老百姓恐慌了。这次调控暂时抑制了一线城市房价的上涨势头，但是却直接导致了全国性房价的上涨，不光二三线城市，连四级以下城市都是如此。这就是领导水平。</p>
</blockquote>
<h2 id="精英人群的平均收入决定房价"><a href="#精英人群的平均收入决定房价" class="headerlink" title="精英人群的平均收入决定房价"></a>精英人群的平均收入决定房价</h2><blockquote>
<p><strong>skysurfer2208：</strong></p>
<p>想请教一下楼主，对于很多的二线城市，比如武汉，市区房子的均价一万左右了，但当地的平均收入一般也就3000左右吧，难倒你不认为现在的房价里面有泡沫吗？特别是现在正处在调控期，对于我们这些近年打算买房的来说，是在等等看呢还是在在这个时期出手？多谢楼主</p>
<p><strong>kkndme：</strong></p>
<p>你所说的平均收入是什么概念？是人人都挣3000块，还是有人挣2000块，有人挣1万块。武汉的房价，要看湖北省包括各地市的人口，家庭收入上万的人有多少，如果你认为很少，几乎没有，那房价肯定存在泡沫。如果湖北省有20%的人口家庭月收入超过万元，那么武汉市区的房价就没有泡沫。</p>
</blockquote>
<h2 id="内地不是香港、海南"><a href="#内地不是香港、海南" class="headerlink" title="内地不是香港、海南"></a>内地不是香港、海南</h2><p><strong>johny__：</strong></p>
<p>那香港97年的时候还不是一样跌了一大截，按LZ的说法，1）土地资源很稀缺；2）作为消费群体的白领收入也能买房；3）作为世界城市，更是汇聚了世界级精英的购买力，仿佛现在上海。最后，不是一样大跌？？中产都成了负资产了。就连林百欣的儿子林建岳97年以69亿港元高价购入中环富丽华，还不是赔得一塌糊涂。</p>
<p>楼价涨高了就要跌，哪都不例外，这个才是规律。什么通涨，精英购买力决定房价，都是涨了之后在找理由。</p>
<p><strong>kkndme：</strong></p>
<p>这就是体制上的不同啊，所以我们无法重复香港和日本。97年的金融风暴，还是中国以国家之力对抗索罗斯的量子基金，保住了香港，这种行为在西方国家是难以想象的。一个国家动用全国人民的外汇储备与美国的民间资本打一场战争，这是令全世界震惊的。索罗斯因为不了解中国的体制，悻悻而归。</p>
<p>人民币不能在世界流通，依照我国实行的货币制度，货币只不过是一种符号。如果有一天我们的人民币能够自由兑换，香港发生的事也一定会发生在我们身上，但你认为我们的人民币能够自由兑换吗？</p>
<p><strong>johny__：</strong></p>
<p>那92年的海南崩盘有从何说起？从7000多掉到了几百元，这难道是海南体制？发币行是海南银行？同样是国内，同样的外汇管理制度，不是日本也不是香港，是中国海南。</p>
<p>–据《中国房地产市场年鉴（1996）》统计，1988年，海南商品房平均价格为1350元&#x2F;平方米，1991年为1400元&#x2F;平方米，1992年猛涨至5000元&#x2F;平方米，1993年达到7500元&#x2F;平方米的顶峰。短短三年，增长超过4倍。</p>
<p>–海峡对岸的北海，沉淀资金甚至高达200亿元，烂尾楼面积超过了三亚，被称为中国的“泡沫经济博物馆”。</p>
<p>[经验交流]92年海南房地产泡沫始自于“击鼓传花”(转载)<br><a href="http://www.tianya.cn/publicforum/content/house/1/163988.shtml">http://www.tianya.cn/publicforum/content/house/1/163988.shtml</a></p>
<p><strong>kkndme：</strong></p>
<p>全国的资金去炒海南、北海，炒的纯粹是概念，没有实体的支撑，就是一种博傻游戏。今年年初海南房地产的爆炒，同样积聚了巨大的风险。买房并不是全无风险，好比通州、燕郊，经历疯狂的炒作一定会理性的回归。但是如果指望北京四环内房价下跌，也只是痴心妄想。</p>
<p>房产投资也不是随便买套房就只涨不跌，比如说山东乳山的房子，开发商疯狂炒作旅游地产概念，但如果真的想投资升值，那就成了天大的笑话，因为根本无法变现。</p>
<p>什么样的房产适合投资，投资者不是傻子，都会有理性的判断。</p>
<p>90年代初的强硬调控让海南和北海的经济崩盘，对全国来说不可怕，毕竟只是一隅之地，但是如果用粗暴手段搞崩了全国，zf一定会好好掂量的。</p>
<h2 id="历史是一面镜子"><a href="#历史是一面镜子" class="headerlink" title="历史是一面镜子"></a>历史是一面镜子</h2><p>如果以为本帖讲的历史故事，那就完全理解错了。<br>本帖讲得不是历史，而是总结前人的经验，讲得是故事背后的道理。<br>如果毛不是熟读历史，也不可能取得胜利。毛在进京的时候，说过一句话：我们不学李自成。<br>只有认真总结过李自成失败的教训，才能够做出正确的选择。</p>
<h2 id="买房一次性到位比较好"><a href="#买房一次性到位比较好" class="headerlink" title="买房一次性到位比较好"></a>买房一次性到位比较好</h2><blockquote>
<p><strong>包容会通：</strong></p>
<p>我老婆是长春人,岳父母退休,都有退休金.我和我老婆现在都在国外,准备3年以后回长春工作,我们现在有40万的现金,放在银行也没什么用,也担心3年以后,长春的房价还要涨.</p>
<p>因此,现在准备用其中的20万作首付买套70平的小户型的,让岳父母住(岳父母有住房,但很快就要拆迁了).等3年以后回长春,把这套小的卖了换成大的.不知这样的计划是否可行?贷款如何弄?<br>　　　　　　　　<br>谢谢兄弟.</p>
<p><strong>kkndme：</strong></p>
<p>既然是自住型需求，何不买套大点的，70平（建筑面积）的房子无论是自住、父母住还是合住，都比较拥挤。既然有40万的闲钱，还是一次到位比较好，3年后长春的房价一定要比现在高的多。</p>
<p>只是贷款比较麻烦，你的父母是无法贷款的，除非你们夫妻能够回国，这种事用别人的名字办肯定是不行的，房价上涨后就有可能会陷入扯皮甚至打官司的境地。</p>
</blockquote>
<h2 id="外汇管制"><a href="#外汇管制" class="headerlink" title="外汇管制"></a>外汇管制</h2><blockquote>
<p><strong>tianxiaobing11：</strong></p>
<p>楼主，这个tj连人民币不能自由兑换都不知道，可见他的水平也太差了，就不用和他计较了，从上个月开始人民币换美圆好象收紧了，是怕民众把人民币换美圆出逃吗？</p>
<p><strong>kkndme：</strong></p>
<p>外汇外流趋势比较严重，zf开始严管，包括携带50美元以上商品入境必须征税等措施，都是限制外汇外流。富人从穷人身上赚了钱，换成美元在国外消费，这是zf不愿意看到的，zf不在意富人搜刮穷人，但肉一定要烂在锅里</p>
</blockquote>
<h2 id="一线和二线"><a href="#一线和二线" class="headerlink" title="一线和二线"></a>一线和二线</h2><blockquote>
<p><strong>yamazaki28：</strong></p>
<p>楼主好，小弟有问题请教，本人所在二线省会城市，存款40w,近来看中本市CBD区域高端住住宅一套，各方面条件十分优越，面积100左右，均价18000。但通过观察，又看中觉得北京五环附近的待建地铁房，均价16000，想贷款弄小户型60左右，不知哪个升值潜力大，本人已有房一套。谢楼主指点。</p>
<p><strong>kkndme：</strong></p>
<p>短期来看，二三线城市的房产升值速度要高于北京，这是这次调控造成的结果，从长期来看，北京房产的升值速度要高于二三线城市。五环附近地铁房，还是很有优势的。</p>
</blockquote>
<h2 id="吕后篡权"><a href="#吕后篡权" class="headerlink" title="吕后篡权"></a>吕后篡权</h2><p>大凡是60年代末，70年代初生人，小时候肯定看过一本小人书：吕后篡权。<br>在那个时代推出这本书，很有寓意，起到了很好的宣传效果。<br>吕后真的是十恶不赦的妖妇吗？让我们还原历史的真相。<br>我们读到的吕雉，通常的形象是蛇蝎心肠的女强人。<br>大家感兴趣的，首先是关于吕雉在项羽大营和审食其是否有一腿。<br>然后看到的是吕雉协助刘邦诛杀异性王、与倾国倾城的戚夫人争宠、帮助儿子刘盈与戚夫人的儿子刘如意争夺太子、杀害戚夫人和刘如意、提拔吕氏家族成员。<br>但是因为宣传的需要，几乎所有人都忽略了吕雉的另一面</p>
<p>刘邦见上帝以后，吕雉掌权期间，对待老百姓还是很够意思的。<br>俗话说嫁出的女就是泼出去的水。吕雉可不同，吕雉非常照顾自己的娘家人，想把自己的娘家人都提拔起来。<br>秦始皇把分封制改成郡县制，搞天下大一统，意识比较超前，结果政权不稳定，秦朝很短时间就完蛋了。高祖刘邦吸取了这个教训，仍然搞分封制，不过分封制做了重大的改革:首先是分封的诸侯王必须是皇族，也就是说必须姓刘。其次是从中央派丞相给诸侯王，丞相掌握诸侯国的军政大权，防止生变。<br>吕雉提拔娘家干部最大的障碍就是：高祖说过，诸侯王只能姓刘。</p>
<p>吕雉是一个极其精明的女人，她追尊自己的老爹吕公为宣王，吕公是刘邦的老岳父，追尊皇帝的老岳父，旁人自不能有异议。既然有了先例，剩下的事就好办了，吕雉趁机把自己吕姓家族的成员封为吕王。<br>吕王吕嘉这个人很嚣张，仗着外戚的身份，飞扬跋扈，不尊法纪。<br>吕雉是一个出色的国家领导人，不是黄巢李自成之类的强盗流民，是很关心民生的，所以很生气，把吕嘉给废了，让吕嘉的叔叔吕产当吕王。<br>吕雉掌权后，做了很多亲民的好事，减免老百姓的税赋，加强建设健康的人民文化娱乐，最受百姓欢迎的是废除了“三族罪”和“妖言令”。<br>三族罪的意思很直白，就是一人犯罪株连三族。<br>妖言令有点象后来的文字狱，哪里出现统治者认为的妖言，就把那个地方的所有百姓全部处死。这是一个伟大的历史进步。<br>吕雉还是女权运动的先驱者，在吕雉时代，女子也可以封官封侯，可以随意离婚再嫁。那个时代是中国古代史上，女人最幸福的时代之一。<br>吕雉，一个柔弱的女子，在残酷的宫廷政治斗争中表现的异常凶狠，然而权力的斗争本身就是你死我活，在治国方面，吕雉却无愧于一个贤明的统治者，可谓巾帼不让须眉。吕雉与后来的老佛爷完全就不是一个等级，毫无可比性。<br>吕雉执掌朝政十五年，直到病死后，吕氏家族才土崩瓦解。<br>还原真实的历史，我们不应该对这位叱诧风云的女政治家，致以深深的敬意吗？</p>
<h2 id="小产权房"><a href="#小产权房" class="headerlink" title="小产权房"></a>小产权房</h2><blockquote>
<p><strong>大水牛跟水牛仔：</strong></p>
<p>楼主,可以谈谈小产权房的看法吗?父母是珠海的原居民且拥有两套小产权房,无房产证只有村里所发的使用证,是村委会卖给原居民的,离市中心约半小时车程,近河边,而一路之隔的位置己建有大型高尚住宅小区,在售价一万二以上,请问这些小产权房可靠吗?听说往后政府对这些小产权房采取放宽政策,只需补一点钱就可改成商品房,你觉得有可能吗?</p>
<p><strong>kkndme：</strong></p>
<p>这个补点钱就改商品房的可能性不大，如果是大片的小产权房，拆的可能性也不大。这个问题很让zf头痛，城乡双轨制的结果，所以zf能拖就拖。</p>
<p>但是对于片区不大的小产权房，风险就很大</p>
<p><strong>大水牛跟水牛仔：</strong></p>
<p>谢谢楼主回复,父母手上的两套小产权房在同一小区,小区比较大,这类小区有好几个,由于村内将进行旧村改造,规划成高级住宅片区,那此类小产权房如遭迁拆的话会得到赔偿吗?</p>
<p><strong>kkndme：</strong></p>
<p>这个会比较扯皮，最坏的情况是按照原价退赔，最好的情况是回迁安置。如果原价退赔损失就很大。</p>
</blockquote>
<h2 id="商铺和住宅"><a href="#商铺和住宅" class="headerlink" title="商铺和住宅"></a>商铺和住宅</h2><blockquote>
<p><strong>deeplp：</strong></p>
<p>kkndme 兄，你好。</p>
<p>从这个帖子一开始就一只跟着，每天必看。受益良多。</p>
<p>你对广州感觉如何？请教一个问题，不知你对商铺是否有研究？你觉得眼下投资商铺好呢，还是继续投资房产。<br>本人已有2套房产，都在广州市区且近地铁但不带很好学位。现有如下两个想法，</p>
<ol>
<li>分散投资，投资一个商铺，目前看中一个广州北京路拐弯处二楼商铺一个，靠近地铁。</li>
<li>继续房产，买一个130以上大户型且带学位房，方便以后小孩读书。（计划明年要小孩，现在就做打算是怕以后买不起阿。）<br>麻烦兄台给些意见。十分感谢。</li>
</ol>
<p><strong>kkndme：</strong></p>
<p>找到合适的商铺是很难的，因为商铺投资风险大，所以非常考验个人的眼光，属于高风险高回报，找对了，将财源滚滚，找错了很可能血本无归。<br>如果你有眼光，首选商铺。如果不具备这方面的能力投资住宅比较保险。</p>
</blockquote>
<h2 id="体制内外"><a href="#体制内外" class="headerlink" title="体制内外"></a>体制内外</h2><p><strong>tuzi1976：</strong></p>
<p>kkndme兄，你好。上周提了几个问题，可能你没看到，再请教一次，请抽空指点一二。<br>看到楼主说过“人民币对外是升值，对内贬值”，我认识到“人民币对外是升值，对内贬值”这一点也有一年多了吧，主要是从生活经历、经济新闻中得到的结论（本人学工科、不懂经济）。虽然看到了表面现象，但对其发生的根本原因、对群众生活的深刻影响、“中产阶级（勉强算是有这么个阶级）”的应对之策等等尚没有深刻的认识。楼主看到我提的这些问题恐怕也觉得范围太大、难以回答？难道体制外的“中产阶级”只有任人宰割、移民海外、钻营往上爬这几个选择？诚心求教，风险自担（呵呵，楼主也不是神仙）</p>
<p><strong>kkndme：</strong></p>
<p>普天之下莫非王土，决定了今天的土地国有<br>万般皆下品，也决定了以后知识分子的前途必须进入体制内。<br>不能考中进士的明清两代知识分子，即使经商发了大财，也一样让人看不起，不能光宗耀祖。今天的知识分子将面临同样的命运。<br>体制外，凭个人的本事和运气，自生自灭。</p>
<h2 id="2010年的上海"><a href="#2010年的上海" class="headerlink" title="2010年的上海"></a>2010年的上海</h2><blockquote>
<p><strong>youme5845：</strong></p>
<p>看到LZ的帖子真是太及时了！因为要解决小孩子上学，我最近开始密集型的看房子.</p>
<p>感慨房价高的同时后悔没有早点考虑买房。头痛啊！！！</p>
<p>说说我们的情况：目前现金40W,家庭收入1W5,住上海，目前看的房子为周边世纪公园地铁10分钟老公房(新房很少)，81P 190W,地段很好，但房子都是95年左右的了。算下来除了首付家里帮助外每个月供5K还30年(扣除公积金还款),我们现在可以出手么？还是等十一新政策出来后买？</p>
<p>还是在交通稍微不便的地方买低价的房子？</p>
<p>请LZ给个意见~ 在线等~<br>多谢！！！！</p>
<p><strong>kkndme：</strong></p>
<p>月供5k,收入1万5，说明的你的压力不大，完全可以承受。如果地段好，可以不考虑房子的新旧。一线城市的买房时机最不好拿捏，因为一线城市是调控的目标，你要仔细观察，如果发现中介的铺面里看房客越来越多，建议赶紧下手。</p>
<p><strong>youme5845：</strong></p>
<p>多谢！！！ 那我最近关注多一些！<br>还有这块小区同时是学区房，是否可以买个100W出头的出租，然后自己租房住(我们长期租住房租很便宜 1700两室户)，这样即使以后出现金融危机等情况也不会担太大风险，是这样么？</p>
<p><strong>kkndme：</strong></p>
<p>对自己好一点的就会自己住，对钱看的比较重，可以买房出租，自己租便宜的。因人的性格而已。<br>不过人生苦短，在短短的有生之年，还是要对自己好一点。自己买的房子住起来跟租房子的感觉是完全不同的。</p>
</blockquote>
<h2 id="买房：物业与房贷"><a href="#买房：物业与房贷" class="headerlink" title="买房：物业与房贷"></a>买房：物业与房贷</h2><blockquote>
<p><strong>fallenleafe：</strong></p>
<p>关注本贴多日，非常欣赏楼主的睿智和理性。<br>小女子也是上海众多买房人之一，目前所谓单身剩女，得家人支持有一百五十万的首付金。基本确定买在内环交通方便的次新房（老公房停车太成问题）。<br>对上海浦西内环内的诸多区位和楼盘做过研究，发现离地铁近的同时能有苏州河景观的房源最具性价比，满足交通性和景观稀缺性的双重优势（上海内环内几乎没什么安静同时又具有自然资源的地方）。<br>现在基本确定了两个小区，比较纠结的问题有两个。<br>第一个问题，一个是小区管理和区位优势明显单价在3万3左右，另一个区位和管理比较差，名声不好，但是面苏州河的独一无二景观，单价在3万左右。从小区管理的角度，我也认可楼主的看法，管理好的小区升值空间大，管理差的小区由于群租问题严重，目前价格偏低，但是这个软件问题在日后随着自住率的提高貌似也能解决。究竟我该选一个景观资源非常稀缺的管理和配套相对较差的小区，还是一个相对成熟价格稍高同时综合配套比较好的小区？那个小区比较有保值和投资优势？<br>第二个问题，目前的月收入税后刚过万元，如果拿150万的首付买一房大概80平左右，是比较轻松的，月供不成问题（目前租的一室一厅租金3500，已经可以做为还贷资金了）。但是考虑长远问题和一些小户型的局限性，非常想投资一套能长久居住的两房甚至三房（众所周知，一个小区里好的位置总是留给最大的户型）。这样的话，大概一套就要在320万甚至350万，我需要每月还贷1万2左右，基本和我的月工资持平。从个人观点来看，我比较想冒这个风险，比较合适的做法是首付降低到3成左右，留出三十万左右的还贷资金用以应付前面两至三年的还贷。由于目前单身，两至三年后也许家庭收入就可以完全承受这个月供。即使还是单身，目前事业发展良好，对2年后的收入在2万以上很有信心，因此还是认为可以目前阶段多点勇气，目光长远，以保证日后生活安康。<br>不知道楼主怎么看这个问题？如果是房价持续上涨的情况，也许更该相信我的工资也会持续上涨，是否我看问题太乐观？贷款200万的风险是不是会太大？</p>
<p><strong>kkndme：</strong></p>
<p>第一个问题：物业管理对于小区的价值起着至关重要的作用，好的物业管理才能让人居住舒适，这一点是非常重要的。软件的提升往往比硬件的提升难度更大。物业很差的景观楼盘，可以比喻为鲜花丛中的一坨屎，周边环境再好，它也是一坨屎。一坨屎能否脱胎换骨变成黄金，存在着较大的不确定性。<br>第二个问题：是否承受较高月供，取决于你对未来的预期，所以你要仔细分析你的行业前途，如果你所处的行业告诉成长，或者你的能力职位将得到进一步提升，你可以承受较高的月供。<br>一般来说月供不要超过全部收入的70%，如果超过这个边际，就会有较大风险。</p>
</blockquote>
<h2 id="收紧住房贷款"><a href="#收紧住房贷款" class="headerlink" title="收紧住房贷款"></a>收紧住房贷款</h2><blockquote>
<p><strong>welldayzwb：</strong></p>
<p>顶楼主，越读越觉得受益良多<br>楼主分析一下，最近几年一线城市是否会一直收紧贷款，想改善住房是否也得必须全款了？一想起这个就很郁闷，去年机会没利用好，后面不仅仅是经济成本的问题了，又面临和无房空空类似的问题，攒钱永远赶不上房价了。。。</p>
<p><strong>kkndme：</strong></p>
<p>收紧住房贷款起码在未来的一段时间会成为常态。由于货币泛滥，一次性付款的人群数量庞大，收紧贷款虽然不能降低房价，但可以抑制房价上涨的速度，防止商品房卖给穷人，以规避金融风险，对社会稳定和经济平稳增长都是有利的。</p>
</blockquote>
<h2 id="奸臣蔡京"><a href="#奸臣蔡京" class="headerlink" title="奸臣蔡京"></a>奸臣蔡京</h2><p>现代的纸币发行成本很低，拿着印钞机印就是了。古代就没那么好办，金银的开采量是有限的，别说金银，就是铸铜钱用的铜，也不是想要多少就有多少。</p>
<p>古代要想制造通货膨胀，最绝的办法就是拿一个铜钱当十个铜钱花，叫做当十大钱。搞当十大钱，扰乱货币秩序的领导，最有名的就是蔡京。</p>
<p>蔡京这个名字并不陌生，不爱读历史的人也一定看过水浒传。就是这个领导，被宋史称为六贼之首。大家一提起他，就自然把他跟奸臣划了等号，恨不得在他脸上踹几脚。</p>
<p>蔡京的确是个奸臣，但很多人可能不知道的是：蔡京是王安石的最得力干将，他的很多祸国殃民的政策，竟然是源于恢复王安石的变法。</p>
<p>王安石可以说是一个品德高尚的人，但是变法的流毒，竟直接导致了北宋的灭亡。王安石是一个在历史上有争议的任务，但是他的得力骨干蔡京同志，却是不折不扣的奸臣。</p>
<p>蔡京领导的罪恶，大家一致公认的就是那么几条<br>第一、花石纲，水浒传有精彩的描述，这个纯属于皇帝的个人爱好，似乎都推到蔡领导身上比较冤枉。<br>第二、大兴土木，大搞基础设施建设拉动内需，顺便搜刮点民财，以至于百姓怨愤<br>第三、恢复王安石时期的方田法，并且更改盐法茶法，国库和官员一起大肆搜刮民财，与民争利，结果租税混乱，富人把负担全部转嫁给穷人，穷苦百姓的负担更加沉重。<br>第四、就是当十大钱，制造通货膨胀，严重扰乱金融秩序和金融安全，北宋的经济崩溃了<br>蔡京，一个王安石变法的坚定执行者，最后成为祸国殃民的奸贼。</p>
<p>关于蔡京的奸臣形象，到了现在，有人企图为他翻案。但终究声音比较弱小。<br>因为在中国的古代，肆意敛财、大兴土木、搞官商垄断，与民争利，以至于人民不堪重负的领导，都被称为奸臣。对于减轻人民赋税，不胡乱插手民间生产和贸易，让人民修养生息的，被称为贤臣。<br>中国的古代，奸臣远远多于贤臣。</p>
<h2 id="体制内的28原则"><a href="#体制内的28原则" class="headerlink" title="体制内的28原则"></a>体制内的28原则</h2><blockquote>
<p><strong>facetowall：</strong></p>
<p>有人说，高校里20%的人掌握着80%的资源和财源，本人深有同感。所以经常想怎样才能成为20%里面的人。每天也很努力工作着，科研教学也可以，但是总看不到希望。</p>
<p><strong>kkndme：</strong></p>
<p>从一个小吏变成中高级干部，是需要深入研究中国古代政治斗争史的。否则就变成了宋江，企图另立山头通过跳槽达到目的，最终的结果只能是失败。宋江是一个政治上的白痴。<br>还有一个白痴叫贾谊，我们所熟知的“过秦论”的作者，才高八斗，政治却很白痴。被文帝做了棋子。如果贾谊同志知道晁错的下场，是无论如何不会仗着有才胡说八道，口无遮拦的</p>
</blockquote>
<h2 id="贾谊"><a href="#贾谊" class="headerlink" title="贾谊"></a>贾谊</h2><p>贾谊的粉墨登场，是有很深的政治大背景的。<br>首先要从吕雉死翘翘，以陈平、周勃为首的功臣集团铲出了吕氏一党说起。<br>吕氏一党灰飞烟灭，小皇帝是个吕雉制造出来的傀儡，甚至跟高祖刘邦都没有任何血缘关系。<br>难题是让谁当皇帝呢？<br>于是中国历史上最为搞笑的一幕发生了，在高祖刘邦的子孙中要搞最弱外戚选举。</p>
<p>大概是被吕雉专权搞怕了，大家推举皇帝，专门看哪个皇子的外戚弱。于是众人的目光投向了刘邦的第四个儿子，代王刘恒。原因是刘恒的母亲薄氏出身低微，为人又很低调，堪当最弱外戚之名望。<br>提起薄氏，野史里记载的很香艳，很可以拍三级片</p>
<p>野史里说，楚汉争霸时期，高祖刘邦大败。<br>薄氏还是个姑娘的时候叫薄姬，逃难的时候占领了一个无人居住的民宅。忽然有一天看见一个浑身是血，穿着盔甲拿着兵器的男人闯进了自己的屋子，这个人就是刘邦。<br>薄姬听到后面有追兵，就把刘邦的盔甲和兵器藏了起来。然后放了一大桶洗澡水，把自己和刘邦脱光光，洗起了鸳鸯浴。追兵闯了进来，惊奇的看了一通三级片，然后走人。<br>这个只是野史，可信度不高，但是说明了薄氏的低微出身。</p>
<p>不管怎麽说，有着最弱外戚称号，并且做事很低调的刘恒当了皇帝。但是对于刘恒来说，陈平、周勃等功臣集团有着很高的声望，齐王刘襄是高祖长孙并且在铲除吕党是很有功劳，声望也很高，受到了很多人的支持，而刘恒却毫无功劳，因为功臣集团平衡关系，天上掉下了皇帝的帽子，砸在自己脑袋上。<br>所以刘恒必须提拔自己人，这个人不能有很高的功劳，也不能有结党的嫌疑，最好比较有本事能治理国家，于是大才子贾谊粉墨登场了</p>
<p>贾谊同志很有口才，一腔热血，要到现在来说最适合搞传销或者卖保险。<br>贾谊同志激愤起来甚至说：自己完全可以带兵打仗，灭了匈奴，把匈奴王象狗一样牵回来。”刘恒很贤德，但也很老谋深算，当然认为贾谊同志满嘴喷粪，所以一笑置之。<br>贾谊同志的胆子不是一般的大，向皇帝刘恒提供了一个深的帝心的建议：让所有的诸侯王滚回自己的封地。<br>为什么说这是深得帝心的建议？因为朝里功劳大的人太多，居功自傲，而自己却没有什么威望和功绩，如果功臣集团和齐王、淮南王联合起来造反怎么办？<br>所以，最好的办法就是让诸侯王滚回封地。汉代的诸侯王可跟周朝不同，周朝的诸侯王是有实权的，有自己的军队。而汉代的诸侯王只能收收领地的税，军政事务全说了不算。<br>这个事，从贾谊嘴里说出来最好不过。</p>
<p>汉代的京城是最繁华的，有全国最好的教育、医疗、商业，有钱人的天堂，大臣们都可以花天酒地。让诸侯王回到封地，大家都不干了，回封地有什么好？房价又低，又没什么娱乐，漂亮姑娘也不好找，偏远的地方气候还不好，梅雨一来全身都要发霉。<br>首先带头反对的是功臣集团的领袖周勃（陈平已经死翘翘了）。在历朝历代，多数皇帝并不是想干什么就干什么的。既然所有大臣都反对，那就先暂且作罢。<br>但是贾谊，已经为刘恒种下了希望的种子，给自己埋下了祸根。<br>贾谊注定了只能是一颗棋子。</p>
<p>贾谊的建议没有被采纳，估计很郁闷，成天滔滔不绝的演讲，甚至建议刘恒削藩，要是贾谊知道晁错的下场，一定不敢这么建议。<br>这时候，贾谊已经得罪光了朝中几乎所有的大臣。于是大家的不满全部转移到贾谊的身上。<br>刘恒要的就是这个效果。</p>
<p>随着政权的逐渐稳固，刘恒把矛头指向了周勃。给予周勃最高的赏赐，却经常在治理国家方面，询问一些周勃不可能知道的问题。让周勃很尴尬。<br>周勃有个门客，就对周勃说：“皇帝经常给你很多赏赐，您就安心的接受，这很危险。皇帝给你的赏赐越多，说明皇帝对您越不放心啊。”<br>功高震主，弄不好会有杀身之祸，周勃不是傻子，立刻明白了这个道理。所以周勃才能称的上除曹参外，最有政治头脑的武将，最后得了善终。<br>于是周勃就上表辞职，表示年老体病干不动了。周勃还期望皇帝能挽留一下，但皇帝一点挽留的意思都没有，立刻同意了。<br>刘恒让周勃起个带头作用，回到自己的封地去吧。并且赐予了大把的金银。其他诸侯王看周勃都走了，也扛不住了，只好都回到了封地，这叫射人先射马，擒贼先擒王。<br>刘恒为了安抚大家，把遭人恨的贾谊明升暗降，贬到了长沙，从此离开了政治中心。<br>后来有一天，刘恒想起了贾谊，找他来中央谈话。贾谊一见皇帝立刻滔滔不绝，把皇帝立马侃晕了。<br>刘恒想：我靠，这厮死不悔改，留着没用，有多远滚多远吧。<br>再次把贾谊贬到了梁国。<br>贾谊不多久就死了。</p>
<p>关于魏豹和薄姬是否有一腿，也不好就肯定，也是个悬疑。因为记载薄姬的版本太多，我国古代人也比较八卦，呵呵。</p>
<h2 id="kkndme-推荐的历史书"><a href="#kkndme-推荐的历史书" class="headerlink" title="kkndme 推荐的历史书"></a>kkndme 推荐的历史书</h2><blockquote>
<p><strong>welldayzwb：</strong></p>
<p>这个帖子最大的感受就是应该认真读一下历史了，麻烦楼主给列个入门级的书单，鉴于我的历史水平只有演艺级的，书单请尽量入门级，当然演绎过的就免了，别读历史还别人顺带洗脑，比较郁闷了</p>
<p>先再次表示感谢！</p>
<p><strong>kkndme：</strong></p>
<p>比较浅显的是“史记”，入门级基本都读的懂。如果开始觉得部头太大，觉得累，刚开始可以从“古文观止”入门。逐渐增加难度。<br>入门以后，很多古文就好读了。<br>现代翻译的一般都加工的比较多，同一部历史可能有无数个解释。象易中天和当年明月，都是写的不错的。</p>
<p>关于古文观止，很多文章都曾被节选进中小学课本，篇篇堪称经典，其中就包括贾谊的“过秦论”。不看过秦论真的不知道贾谊的才华呀。所以想读读历史的童鞋，不妨回过头再温习温习古文观止，边品茶边看，真是一种享受。</p>
</blockquote>
<p><strong>EchoMa9999：</strong></p>
<p>楼主晚上好！<br>我看之前有跟贴的朋友提过，请楼主列个史书入门级的书单，我不求列了很多书的书单，只请楼主推荐三本，佛渡有缘人，楼主，望不吝赐书名，先谢了！</p>
<p><strong>kkndme：</strong></p>
<p>我觉得读史最基本的就是古文观止，读了古文观止，有了功底，再读其他的就好读了。<br>开始读的时候，通史类是很难看得进去的，象“资治通鉴类”的也不好读，因为“资治通鉴”应当算评史算不上史书。<br>入门开读的话还是选择文学性强的比较好读，故事性趣味性都高，比如“史记”“三国志”“汉书”。<br>有了兴趣再读大部头的“宋史”“明史”<br>现代编写的中国史纲之类的就不要读了，纯粹洗脑，很多加工过的历史类读物就是瞎扯。</p>
<p>特别是： 千万不要读“中国通史”那样的垃圾!!!!!!!!</p>
<p>一定要读懂原文，跟中国通史讲得完全不是一回事。读不懂原文宁可不读，也不要让中国通史洗脑。</p>
<h2 id="年轻人要早买房"><a href="#年轻人要早买房" class="headerlink" title="年轻人要早买房"></a>年轻人要早买房</h2><blockquote>
<p><strong>GGKMM：</strong></p>
<p>看了三天，终于看完了。。有些是一眼带过的，有些是比较认真的看下来的；</p>
<p>感觉回帖的筒子大多数都挺有钱的啊，至少相对我来说。因为都在计划一二百万的房子了。</p>
<p>本人在福州，目前月薪只有4K，但是福州市区的房产均价已经越过一万了，市中心的更是到了1.5万这样高不可及的地步。我就那楼主口中那种民企私企的体制外的P民了，属于自生自灭型的。但也还是得活下去啊，今年也二十五了，过两年也要结婚了。房子成为不可避免的头等大事；</p>
<p>不知道楼主对福州这样一个三线或者四线城市的房产怎么看待？平均工资水平约2000，有钱人据自己观察应该不少，至少超过20%的福州人口（有关这个，从大街上越来越多的好车做判断的，或许数字不准，但有钱人不少是肯定的）。如果在郊区能找到六千左右的小户型（65平左右），首付（还得存两年或者去借钱）自己掏，剩下的做货款，因为家里实在是没办法再支援了。这样的话应该还可承受，前提是付房贷的这二十年或者十五年里不失业。。</p>
<p>希望楼主给分析分析，写得有点乱。。。</p>
<p><strong>kkndme：</strong></p>
<p>25岁不是考虑失业的年龄，35岁体制外没有混出来的群众才应该考虑失业问题。<br>所以房子一定要趁年轻买，刚开始钱不够，就不要计较太多，先买个小的，以后有能力再换，如果没混出来，以后起码有个自己的窝住。不至于租房子被人赶出来。</p>
<p>福州是有点尴尬，明明是省会，又比不过厦门，不过市区1万左右的房价，在省会城市里真的谈不上高。你是自住，你又不打算去厦门生活，所以你该买还是得买。福州的房价也许涨得没那么块，但是也不可能跌。</p>
</blockquote>
<h2 id="不要低估通货膨胀"><a href="#不要低估通货膨胀" class="headerlink" title="不要低估通货膨胀"></a>不要低估通货膨胀</h2><p><strong>someway2010：</strong></p>
<p>跟楼主请教一下：<br>楼主怎么看知春里小区的房子？那边连着双榆树小区，有大片的老房子，都是6层的板楼，都是上世纪8、90年代建的。环境看起来有点乱，以前的老公房，原单位早就没了，物业基本等于没有。将来拆迁的可能性有多大？值得买不？</p>
<p><strong>kkndme:</strong></p>
<p>只要是4环内保值升值不会有问题，那个位置还是可以。关键是看投资还是自住，如果是自住，我就觉得那边有点乱糟糟的，不舒服。挨着中关村其实住着都不舒服，但不耽误升值。</p>
<p><strong>someway2010：</strong></p>
<p>多谢楼主，是自住<del>因为老公在中关村上班，想离公司近些，所以就挑了那里</del>是挺乱的，唉~<br>希望以后等我们有钱了能换个别的地方的大房子，不过按照楼主的分析这个是极有可能实现不了了。。。5555~~~~~~<br>再问一个，现在市场上卖200w的房子，十年后大概会涨到多少钱？麻烦楼主</p>
<p><strong>kkndme:</strong></p>
<p>80年代你想象不出以后一瓶茅台会卖1000块<br>现在你同样想象不出十年后你的房子能卖多少钱。<br>那时也许人民币都是1000块一张的</p>
<h2 id="二三线城市与重庆"><a href="#二三线城市与重庆" class="headerlink" title="二三线城市与重庆"></a>二三线城市与重庆</h2><p><strong>dali_05：</strong></p>
<p>浏览了楼主观点，和我之前的货币推动楼市的看法完全一致<br>但由于无法像楼主那样掌握一些基础数据，对一些楼市的演变细节还有几个疑问</p>
<p>，还请lz指点<br>（1）二三线城市在这轮调控中的增长不出意料，但是二三线城市的房价增长，我</p>
<p>始终认为存在一个最终谁接盘的问题。我是重庆人，以重庆为例，这个城市代表</p>
<p>了典型的二三线城市。外来人口少，特别是外来的普通白领阶层。据我了解的数</p>
<p>据，2008年之前，重庆的具备房子购买力的人群任然是净流出。到08年后才得以</p>
<p>改观。但是流入任然缓慢，这也就是意味着重庆的楼市将没有长期稳定的接盘群</p>
<p>体。而本地人，没有房子的是非常少的。在没有外来人群接盘的情况下，本地人</p>
<p>在有房的情况下，任然投资囤积房产，最终，这些房产将如何变现。<br>一句话，房价要持续的上涨，还得有没房者接盘，而且这些人还得要有购买</p>
<p>力。多次购房者无法稳定的解决这个问题。那么我就有理由对这样的二三线城市</p>
<p>的房产前景表示担忧。</p>
<blockquote>
<p><strong>kkndme:</strong></p>
<p>重庆房价的上涨得益于zy的战略规划，打造中国的大后方，把重庆的经济发展提升到了政治的高度。因为如果发生战争，重庆将变成第二首都，是中国最安全的大后方，蒋同志就很有眼光的选择过重庆。<br>重庆并不是以城中心为核心向外辐射的城市，繁华区域相对比较分散，所以房价很难快速上涨。这也就是过去重庆长期滞涨的原因。<br>重庆房价的崛起可以说完全是中央规划概念推动的，至于日后是否会吸引大量的精英和富人来重庆发展，我想一定可以。作为上升到国家政治高度的发展计划，就算是代价再大，也一定会搞得起来。<br>二三线城市房价的支撑，要因城市而异的，大体上二三线城市的核心区域与高端住宅区都不会有问题。毕竟一线城市的体量，不可能满足全国中产以上群体定居，而且一线城市随着竞争的日益激烈，钱也不是那么好赚的。有很大比例的富裕人群仍会选择二三线城市生活。<br>中国的二三线城市的富裕人口，要比大家想象的多的多，特别是二三线城市，有相当比例的人口都有较高的隐性收入，权力寻租现象更为严重。<br>关于中国的房产能够持有多少年的问题，这要持续观察zf的动向。对于现在的80后来说，如果在有生之年能够平安度过，不经历大的动乱，已经是很值得庆幸了。<br>如果有动乱发生，即使你没有买房，你手中的现金也将变成废纸。</p>
</blockquote>
<p>（2）高端房产还是普通住宅？<br>看了lz的观点，认为高端房产，由于其稀缺性，更具价值。<br>但我认为，房产和古玩还是存在差别的。古玩最大的价值在于收藏把玩，只要</p>
<p>有钱，买再多古玩来玩都无所谓。但是房产不一样，房产的价值除了和古玩一样</p>
<p>的投资外，真正的功能在于居住。但是目前的二三线城市，精英阶层的数量是非</p>
<p>常有限的，他们谁没个3，5套别墅，在没有外来精英加入购买的前提下，这些高</p>
<p>端的房产也就是在精英圈子中流转，这样封闭的流转，如何实现价值的增长呢？<br>要知道，在2，3线城市，普通白领阶层能跳出自己的阶层而具备购买高端房产</p>
<p>能力的概率是非常小的，不具有代表性。那这些每个富人，有权人都有很多的高</p>
<p>端房产有什么价值可言？<br>而普通住宅由于有普通白领的接盘，是否投资价值更大？</p>
<p>（3）长期持有房产的变数<br>中国房产只有70年，甚至50年的使用权，如果长期持有，随着时间推移，房产</p>
<p>价值是否会受到影响。因为我在重庆，这个问题尤其严重，重庆只有50年。<br>如果我只是持有，出租。那我的租金将是较低的（相对房价而言），因为zf不</p>
<p>会允许房租像房价那样疯涨，原因和粮食问题一样，基本需求嘛。那有可能50年</p>
<p>到了，我的房租收益实际上还抵不上房款的综合支出。而那时房子早就是危房了</p>
<p>，强拆将是完全可能的情况。那做为普通人，怎么可能和zf在赔偿上博弈。这个</p>
<p>风险lz是怎么理解的？？<br>我的理解是，房子不能长期持有，必须在5年左右变现，否则将存在贬值和变现</p>
<p>难度加大的风险，请lz指点</p>
<p>（4）天津现象（或者即将出现的重庆现象）<br>天津房价在二线城市中增长是惊人的，但收入水平并没有达到那样的高度。这</p>
<p>种依靠所谓开发区吸引资金推动房价的模式，是否具备可持续性？？<br>我认为真正的天津常住精英阶层的资金实力是无法支撑这样的价格的，只能理</p>
<p>解是外来游资的介入，推高了价格。<br>我想问的是，这些游资有可能退去吗，一旦退去，面临的风险是否很大。<br>据我的理解，中国真正成功的开发区，都是由于本身的条件好，而非开发区本</p>
<p>身的作用。<br>比如深圳，享受的是经济转型的首发政策优势。上海浦东是由于本身就实力雄</p>
<p>厚。而所谓的滨海新区，重庆两江新区，本身实力就不过如此，即使要真正实力</p>
<p>上来，那也将是非常漫长的过程。那这些进入房地产的游资，将在概念炒作一遍</p>
<p>之后，获得一定收益后撤出，一旦撤出，这些地区的房价将会是怎样的趋势？<br>放眼中国，房价高的地方无不是富人集中，或周边富人多的区域。天津重庆这</p>
<p>样的地方，一旦外地资金撤出，将何去何从？</p>
<p>（5）新兴城区和老核心城区<br>新兴城区环境好，轨道交通也使得原本偏远的新兴城区变得方便起来。那老核</p>
<p>心城区的房产是否不如这样的新兴城区有价值。这个问题一直很困惑。因为我是</p>
<p>重庆人，这个问题尤其明显。现在重庆房价最高的是以前的郊区，江北，渝北。</p>
<p>而传统的渝中，房价反而排着中等水平。这和北京的一二环贵，上海的黄埔徐汇</p>
<p>贵完全不同。这样的状况具备可持续性吗，还是仅仅是阶段性的。但是感觉现在</p>
<p>zf的规划更倾向于向外发展，避免主城区拆迁的高成本，这会否导致传统主城区</p>
<p>的边缘化</p>
<p>先问这几个问题，困惑很久了，期待lz的高论</p>
<h2 id="城区和郊区"><a href="#城区和郊区" class="headerlink" title="城区和郊区"></a>城区和郊区</h2><p><strong>hey-hey：</strong></p>
<p>楼主 我在上海， 小白领一枚。最近想买房。稍微好点的区均价已经至少2万5+了， 现在考虑在其他价格洼地的区买套新房，看中了均价1万7左右，买90送30，到手面积120左右。此楼盘开发建造定位2万&#x2F;米以上，因政策调控，故现1万7。好处是小区规划不错，属大型国企房产公司，2012年交房。附近有超大型公园，地铁明年开通（升值利好），附近有医院，学校，路上看到的在建建筑较多（百废待兴）。不好处是离上班开车要1个小时，属工业区（在另外一个方向），路上集卡较多，有传空气质量不好。 </p>
<p>另外一个选择是在市中心或其他比较好的区买个小房子，大概5、60平方米左右，预算也是180万左右。 好处是地段好，租金回报可能较高。如果自住相对比较方便。</p>
<p>单身，买房投资愿望大于自住愿望。 请楼主给分析分析。谢谢</p>
<p><strong>kkndme：</strong></p>
<p>多数人买房子都是郊区买个大的，后来上班实在不方便，再想办法城里买套小的。住郊区牺牲时间，住城里牺牲面积。总得来说，还是住城里更方便些。<br>关于房价升值，一定是郊区和城区版块轮动的。当郊区房价较低时，资金就会关注价值洼地，当郊区房价炒起来以后，城区的房价跟着上涨，但总的来说，城区的房价涨幅一定高于郊区，且比郊区更抗跌。</p>
<p><strong>hey-hey：</strong></p>
<p>谢谢楼主。真是纠结阿。一样的钱想买个新点的。而且周边的觉着还有这样那样的优势，比如公园，比如现在的性价比。比如大了一倍。比如该区未来发展空间和前途。如路建好了地铁修好了，城市辐射发展的面扩展了。<br>市区现在虽然完善，但未来没什么发展空间，该发展的都饱和了该配套的都配好了。升值的空间是否相对就小了。 </p>
<p>还请楼主再给说说。</p>
<p><strong>kkndme：</strong></p>
<p>你说的其实还是性价比的问题，比如郊区（前提是配套能发展的起来）1万7，城区2万5，那肯定是选择城区，毕竟相差不大。如果郊区1万7，城区3万以上，那肯定选择郊区。<br>好比北京的通州，城区2万的时候，通州8000，肯定选择通州，升值会快。但城区3万，通州2万5的时候，肯定会选城区。</p>
<h2 id="守着金碗要饭吃"><a href="#守着金碗要饭吃" class="headerlink" title="守着金碗要饭吃"></a>守着金碗要饭吃</h2><p>守着金碗要饭吃，最典型的就是老一辈玩田黄寿山石的，收藏了一屋子石头，穷了大半辈子，第一次参加石头交易会，居然发现自己随便拿块石头出来能卖上千万。</p>
<h2 id="人制的社会，人就是制度"><a href="#人制的社会，人就是制度" class="headerlink" title="人制的社会，人就是制度"></a>人制的社会，人就是制度</h2><p>让李荣融来讲垄断巨头的功劳，这个事很有意思。</p>
<p>西汉时期，功臣集团和他们的后人势力比较大，大街上瞎晃的黑社会头子比较多，皇帝提倡以法治国，靠法律来制约功臣集团，先是重用了皇宫守大门出身的张释之大法官。<br>张法官完全按法律办事，该杀头的绝不会流放，但是该流放的也绝不会杀头。张大法官实现了我国历代百姓追求的天下无冤民的梦想。<br>史书上记录：汉文帝车驾过中渭桥，一个人从桥底下突然钻出来把皇帝的御马惊了，刘恒很生气，让张法官治他的罪。张法官审讯后发现是个意外，属于民事事件，打算罚点钱放掉。刘恒不干了，那可是惊了圣驾呀。罪该杀头。张法官却认为：律条上没有说因意外惊了圣驾就必须杀头，按律条就应该罚钱放人。要不然陛下你就不要把这个人交给我审，直接杀掉算了。既然陛下让我审，就必须按法律办事。刘恒只好按照张法官的审判结果，放掉了那个人。<br>其实，遵守法律，按照法律办事的不仅仅是张法官，而是刘恒自己。刘恒为了保证社会安定、基业长青，就必须限制特权阶层，限制特权阶层就必须依法治国。<br>但是文景之后，武帝就不满足于完全依法办事的张释之法官这样的人了，而是开始重用酷吏，张汤、义纵、宁成这些新一代法官登上了历史舞台。法律是什么？法律就是张汤，张汤就是法律，犯了法的要往死理打，没犯法的也要往死里打。<br>唐朝武则天时期，出现了一个史无前例的酷吏：来俊臣。<br>来俊臣法官不管法律专搞冤狱，专门养了一大群打手无赖，凡是武则天不喜欢的人，还有他自己不喜欢的人，一律刑讯逼供，屈打成招。发明的酷刑比张汤有过之而无不及。<br>古代，法律是什么？是皇帝？是张释之？是张汤? 是来俊臣？其实，法律什么都不是。</p>
<h2 id="准公务员的好处"><a href="#准公务员的好处" class="headerlink" title="准公务员的好处"></a>准公务员的好处</h2><p>最著名的皇宫传达室看门老大爷叫冯唐，头发都白了还在未央宫值班呢。皇帝刘恒没事瞎溜达，看见老大爷一脑袋白头发，就叫过来神侃。不侃则已，一侃才知道冯大爷的爷爷是赵国的官帅将，跟大名鼎鼎的名将李牧是哥们。而且冯大爷不愧是名将之后，太懂带兵打仗的道道了。<br>刘恒说：我要是能有李牧这样的大将，还怕什么匈奴啊。<br>冯唐很牛叉的说：就是有李牧这样的大将，也得不到重用。<br>冯大爷直接把皇帝气晕，皇帝转身就走了。<br>后来刘恒气消了，又找冯大爷问话。<br>冯大爷就说了一番大道理：<br>对待将士，要以激励为主，才能得到将士拼死效力的心。重惩罚，轻奖励，光拿大棒不掏胡萝卜，将士怎么肯用命呢？（皇帝是信奉法家的，法家的精神领袖商鞅同志认为管理手下最高境界就是基本不怎么用胡萝卜，直接用大棒的最牛——罚九赏一。）<br>云中太守魏尚是个名将，让匈奴文风丧胆。魏尚的手下都是农民子弟，魏尚对待士兵很好，很舍得犒劳，也和舍得给钱，所以大家都很拼命。但是陛下您经常因为军兵的一点小错误，就扣掉军兵的赏赐，因为魏尚虚报了几个斩获的首级数量，就把魏尚抓起来关监狱，奖励太轻，而惩罚太重了。所以说陛下有李牧这样的良将也不能重用。<br>刘恒大悟，拜冯大爷为车骑都尉。<br>唐代的王勃，很不得志，于是写了《秋日登洪府滕王阁饯别序》:“嗟乎!时运不齐，命途多舛;冯唐易老,李广难封。” 冯大爷一下子因为王勃的文学作品，家喻户晓了。</p>
<h2 id="二三线城市的发展靠拆迁"><a href="#二三线城市的发展靠拆迁" class="headerlink" title="二三线城市的发展靠拆迁"></a>二三线城市的发展靠拆迁</h2><p><strong>dali_05：</strong></p>
<p>支持楼主房价大涨房租必涨的观点</p>
<p>但是这仅限于外来人口众多的一线城市<br>二三线城市本地人几乎没有没房的，如果算上父母的，将来普遍一个家庭拥有两套以上的房子<br>房租也就失去了大涨的基础<br>唯一可导致房租上涨的就是拆迁，一旦便宜的旧房子少了，房租肯定是要上调的<br>但那也是有限的<br>总之，外来人口极其可支配收入是房租的决定性因素</p>
<p><strong>kkndme：</strong></p>
<p>二三线城市的敛财和追求政绩方式，全靠大规模拆迁，城市搞升级改造，这个拆迁规模是一线城市市民难以想象的。有的城市已经搞得如火如荼了，有的城市还没开始，但都会走这一步。</p>
<h2 id="一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”"><a href="#一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”" class="headerlink" title="一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”"></a>一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”</h2><p>中国大陆大家目前最为关心，讨论最为热烈的一个问题就是中国的房地产泡沫问题。从政府到民间，从经济专家到普通百姓，大家都在关注这个问题。以前，我也觉得中国存在一个叫“中国房地产泡沫”的所谓概念，但今天我忽然感悟，原来多少年来包括我在内的几亿中国人都被蒙骗了，中国根本就不存在所谓“房地产泡沫”的问题，“房地产泡沫”这个概念本身就是一个伪概念。</p>
<p>如同市场经济一样，房地产泡沫也是一个外来事物，它是市场经济的产物。但问题是，中国是市场经济吗？显然不是，否则为什么大多数西方国家都不承认中国是一个市场经济国家。尤其是中国大陆的房地产市场，更不是市场经济，而是计划经济与市场经济相结合的一个怪物，政府操纵着房地产行业，政府对房地产有着绝对的掌控能力。</p>
<p>房地产泡沫是市场经济的产物，既然是泡沫，那么这个泡沫也会遵循市场经济的规律，即当泡沫足够大的时候，会破裂。因为日本与美国的经济是市场经济，所以当日本与美国的房地产产生泡沫的时候，就会破裂。</p>
<p>目前包括中国在内的几乎所有世界经济学家都以为，当年日本与美国的房地产泡沫破裂了，中国的房地产泡沫比日美大几倍，当然也会破裂。事实却是，中国的房地产泡沫在几年年前的膨胀程度就超过了当年日本与美国的房地产泡沫，中国的泡沫几年来虽然翻倍，但却没有破裂，这是何故？显然，经济学家们犯了一个错误，那就是把中国的房地产乃至中国经济当成了市场经济来看待，而事实是中国的房地产市场根本不是市场经济。所以，西方市场经济国家所有的房地产泡沫，在中国也根本不存在，所谓的“中国房地产泡沫”根本就是一个伪概念。</p>
<p>当然，我说到这里时，肯定有很多人不服气，中国的房地产明明几年之内翻了很多倍，远远超过了普通人的收入水平，这不是泡沫这是什么？我的回答是，中国的房地产价格确实虚高，远远超过普通人的收入水平，这是事实，但这不是“房地产泡沫”，因为泡沫会破，而中国的这个被大家称为“泡沫”的东西却不会破，因为它的真实名字其实不叫泡沫，应该叫“变相的税收”或者“房地产垄断价格”。</p>
<p>中国的房地产业本质上已经不是一种行业，像中国大陆的税收与垄断行业的垄断价格一样，成了少数人剥夺多数人财富的一种工具。在这个工具上，寄生着很多食利者。这个食物链的最上层为地方政府，地方政府通过卖地与房地产税收，养着一大批高薪的公务员及满足他们的奢侈需求。食物链的第二层为与官员勾结的房地产商以及受贿吃回扣的官员，第三层是炒房者，炒房者相当部分为拥有大量现金的官员及家属。</p>
<p>市场经济的泡沫会破裂的，但中国的房地产不是市场经济，房地产价格也不是“泡沫”，所以它也不会破裂。中国的房地产价格被政府严格操控着，不说是操控自如，也是有绝对的控制力。因为政府掌控着土地银行汇率等房地产的关键要素。中国的高税收是泡沫吗？中国的垄断行业的高垄断价格如水价电价油价是泡沫吗？当然不是，他们是转移财富的手段。中国的房地产价格也是一种变相的“税收与垄断价格”，其“税率”与“垄断价格”是政府控制的。这也解释了为何中国几年来房价如此之高，却不下跌，所谓“泡沫”却不破裂的原因。</p>
<p>中国房地产的所谓“泡沫”会“破裂”吗？会，只要政府愿意。中国的房地产的“泡沫”会不破裂吗？会，只要政府愿意。</p>
<p>其实，中国所有的问题都是政治问题，而不是经济问题，离开政治谈经济，永远找不到问题的答案。</p>
<h2 id="拆迁补偿-1"><a href="#拆迁补偿-1" class="headerlink" title="拆迁补偿"></a>拆迁补偿</h2><p>拆迁补偿的两种方式：1、现金补偿；2、回迁安置。<br>在二三线及以下城市，通常采用第二种，因为多数开发商没有钱现金补偿，房地产开发基本上是靠zf关系，空手套白狼，就是有钱也不愿意拿出来。<br>对于拆迁户来说，现金补偿也不划算，因为补偿的现金在与原地同级别的位置肯定是买不了相同面积的住房的，所以多数拆迁户选择回迁安置。<br>但是越小的城市开发新盘的速度越慢，往往回迁房盖个三五年也不见得盖得起来。在这期间，开发商会按月补偿拆迁户一定的租金，用于过渡。<br>手里现金多的拆迁户会先买房住，慢慢等拆迁，但是现金不多的拆迁户，就不得不拿着开发商的过渡款租房住。通常这笔过渡款都要高于相同位置的租金，所以拆迁户就把房租炒起来了。</p>
<p>北京已经没有原地回迁的说法了，一线城市，还有部分较发达的二线城市都不搞原地回迁了，土著一旦拆迁了就赶到郊区。反而是二、三线城市，特别是三线以下城市多数还在搞原地回迁。主要原因是城市小，住户多多少少都有些背景，特别是单位的老公房，开发商不让原地回迁，根本就拆不动，阻力太大。</p>
<p>房子从拆到迁是有时间的，快的情况是1年多，但很多情况都是拆迁安置房3,4年盖不起来。比如昆明的莲花池片区，大概是06年左右拆迁的，但拆迁安置房现在才开始动工，2012年才盖的起来。这种事情并不是个案。<br>贵州更离谱，房子04年拆了就再也没有音讯，开发商一直盖不起来，到现在都6年了。原来的拆迁户，现在还在租房住。</p>
<h2 id="城市底层"><a href="#城市底层" class="headerlink" title="城市底层"></a>城市底层</h2><p><strong>游泳横渡马六甲：</strong></p>
<p>经常有人说收入是决定因素，其实人均收入没有意义。北京姑娘去外企做前台一个月2000，和公司外地姑娘拿这么多，和做公务员的外地姑娘拿这些，生活成本天差地远。不是说有10万个月入2000的外来人口，四环内就有一万处他们能承受的住房。而个体的外来人口的支出，会随着生活成本调整。开始很难理解月入两三千的白领在北京市如何生活，毕竟他们不可能像楼下卖蔬菜水果的大叔那样，炖点猪肉粉条就算开荤，穿特价五块的汗衫就算工作服。一样的月入，白领的幸福起点高得多。后来知道他们原先偶尔用兰蔻改成一直用大宝，早餐不再喝豆浆，住单位附近的搬到五环外，有人在燕郊买了房……突然想起小时候学新概念英语，说起蓝领工资比白领高，但还有人为了能西装革履宁可减薪做白领。</p>
<p>对80后而言，最恐怖的绝不是房价，而是养老。这也不是计生的问题，一个社会的生活资源是有限的，老龄化早晚会到来，为了改变老龄化呼吁多生育，那是饮鸩止渴。等多生出来这部分老了，再这么循环？而福利社会如英国是50多岁的人最幸福，有稳定养老金，二三十岁最痛苦，看不到未来依靠。家底不厚的像希腊，透支做社会福利，后果还不如不做。中国则是取不足以奉有余，竭全民之力供特权阶层挥霍，没有哪个年龄段享受过全民福利，还得共同面对养老难题。房子，真不算此生最纠结的事</p>
<p><strong>kkndme：</strong></p>
<p>正是如此，以后城市的底层吃饭都是问题，zf最喜欢拿房子说事转移矛盾</p>
<h2 id="垄断企业"><a href="#垄断企业" class="headerlink" title="垄断企业"></a>垄断企业</h2><p>我们的垄断企业其实都是第二税务局的角色，比如石油、移动、电力、水务、地产、银行等等。zf一定要掏空百姓的钱包，所以说什么泡沫不泡沫，就是个笑话</p>
<h2 id="农村自来水"><a href="#农村自来水" class="headerlink" title="农村自来水"></a>农村自来水</h2><p>说起农村建自来水更搞笑，亲眼目睹要不然真不敢相信。<br>贵州有个村子，以前，自来水是村子集体出钱买的管子，然后全村出劳力从山上接下来（用的山泉水），要是水管坏了，大家再摊钱摊劳动力修。<br>结果zf不愿意了，说他们修的不规范，zf给重新修，还是从山泉引水下来，zf包给工程队换了一下管子，然后每户给按了水表，安好了以后，要按照2块钱一吨收费，全村都炸了窝了，集体抗议，现在还没有结果。</p>
<h2 id="袁盎"><a href="#袁盎" class="headerlink" title="袁盎"></a>袁盎</h2><p>丛林社会就是要承认人与人之间的差别，性格决定命运。<br>我要讲一个奇人，这个人叫袁盎。故事的出处是《史记·袁盎晁错列传》，如果鸡冻同志认为我瞎编，可以自己去看原文。</p>
<p>袁盎同志的神奇是一般人都无法想象的，这个奇人在吴国当相国的时候，他手下的一个小公务员跟老袁同志的爱妾乱搞，经常背着老袁嘿咻嘿咻。老袁知道了这个事就装聋作哑。<br>有人跟那个小公务员说:坏了，你跟袁领导的二奶私通的事让袁领导知道了，你死定了。<br>小公务员一听吓坏了，骑了马就跑，公务员这份全世界最令人羡慕的工作也不要了。<br>小公务员一跑，袁领导就使劲追，小公务员就更拼命跑，袁领导就更拼命追。袁领导的马要好一点，跑的快，终于把小公务员追上了。小公务员只好下马等死。<br>袁领导急了，对小公务员说：你跑什么呀？我正打算把我的二奶送给你。兄弟如手足，妻子如衣服。大概就是这个意思。<br>小公务员感激涕零，抱着袁领导的二奶继续嘿咻。<br>所以说老袁这人最仗义，人缘最好。上下都买他的帐。</p>
<p>老袁也有个把敌人。老袁在皇宫里当小跟班的时候，得罪了汉文帝宠爱的一个太监叫赵谈的，所以特别害怕，怕赵太监哪天找茬把自己给黑了。<br>老袁征求了侄子的意见，认为自己应该先下手为强，应该当众侮辱一下赵太监，这样如果赵太监再黑自己，就没人信了，别人都以为是公报私仇。老袁的政治手腕还是相当高的。<br>一天，文帝刘恒跟找太监坐在一辆车子里外出，老袁上前拦住车子，大义凛然的说：能够跟天子共乘一车的，都是天下豪杰，天子怎么能跟一个没小鸡鸡的人坐一辆车呢？<br>赵太监当场就气哭了，还不能说什么。以后赵太监要黑老袁，也没那么容易了，因为大家都知道老袁义正言辞，充满正义的得罪了赵太监，如果赵太监再说老袁坏话，就是公报私仇。</p>
<p>老袁的人缘是公认的好，但是在朝里有一个最大的敌人，就是大名鼎鼎的晁错。<br>晁错这个人学的是商鞅之术，法家的代表人物。为人冷酷，不讲人情，人缘特别差。老袁和晁错关系不好，可能跟两个人的性格很有关系。<br>晁错跟贾谊很有一拼，特别喜欢喷，口才也特别好，跟贾谊同志喷的内容也差不多，一会儿说打匈奴其实很简单啦，一会儿说必须削藩啦。刘恒听晁错喷的很有水平，很欣赏，但是刘恒不是傻子。<br>打匈奴？那得是国力强大以后的事，现在必须让老百姓修养生息。<br>削藩？我也想削藩，但是总得有合适时机才行啊，现在削藩不是逼人造反吗？<br>刘恒对晁错这种人的态度就是，你建议你的，我听听就可以了，不能当真。</p>
<p>晁错同志懂得要想发达，必须选择一个有前途的职业，所以凭着他气死保险推销员的口才，当上太子的老师。这个太子就是汉景帝刘启。<br>晁错的时代终于来了，原因是刘恒挂掉了。<br>刘启生下来就是锦衣玉食，可没他老子那两下子，也不怎么懂帝王之术，晁错说什么就是什么。<br>晁错于是抖起来了，不知姓什么了，仗着是皇帝的老师，飞扬跋扈，人缘极差。晁老师最爱追求政绩，立刻提出削藩。<br>削藩的结果就是吴楚七国反了。<br>这个故事跟明代朱允文同志的削藩如出一辙。明朝朱允文同志削藩的结果就是朱棣反了，当了皇帝。朱允文被迫流浪，泡吉普赛美眉去了。<br>吴王不是朱棣，性格有点象袁绍，生性多疑，手下有人才不会用，所以没能成大事，被周亚夫跟干掉了。如果吴王能有朱棣的本事，汉朝的历史就会改写。</p>
<p>吴王一反，老袁就着急了。老袁给吴国当过相国，吴王造了反，晁错必然要借机宰了老袁，老袁觉得自己冤枉啊，吴王造反不是你晁错逼的吗？<br>晁错果然趁机对老袁打击报复，安排了两个手下去弹劾老袁。但是晁错的人缘实在太差了，老袁的人缘实在太好了，那两个手下竟然不同意弹劾老袁。而且还劝晁错,大意是：现在七国兵马造反了，形式很危急，我们还搞内斗就不好了。老袁这个人是不可能参与谋反的。<br>晁错也着急叛乱的事，就把老袁放一边了。政治斗争，不是你死就是我活。<br>晁错错了，赔进了自己的老命。<br>窦婴同学也曾经在吴国当过相国，立刻跟老袁站在了一条战线上，准备给晁错来个致命一击。<br>晁错这个人的死，完全是他自己性格造成的，对人苛刻，政治上又是白痴。吴楚七国打着“诛晁错，清君侧”的名义造反，皇帝问晁错应该怎么办?<br>晁错的白痴精神充分发挥了出来，“陛下您御驾亲征，臣留守长安，做好看家的工作。”<br>皇帝估计当时心里要多愤怒有多愤怒。你自己惹的祸，你一个当臣子的在家躲起来，让我当天子的上去当炮灰，你是何居心? 不过刘启涵养好，没说出来。<br>这时候老袁跑了进来，说有平乱之计，要单独跟皇帝说。刘启很不客气的就把晁老师请了出去。<br>老袁立刻献计，既然反叛打着清君侧的名义，就先把晁老师宰了，叛军就出师无名了，就得不到老百姓的响应，事情就好办了。<br>刘启一听挺高兴，正恨晁老师让自己当炮灰的事呢，立刻同意，腰斩晁错。<br>晁错的下场要比贾谊惨多了。</p>
<p>不过老袁的下场也并不好。皇帝的老妈想让皇帝的弟弟梁王在刘启驾崩后继承皇帝这份工作，但是老袁不同意，坚决表示反对，得罪了梁王。<br>梁王不是一般的高级公务员，最喜欢搞黑社会，找了杀手把老袁干掉了。<br>这个故事又告诉我们，即使人缘再好，在政治斗争中活下来也是不容易的。</p>
<p>我说的不是袁盎也不是晁错，说的是削藩，皇帝削藩怎么样？看看朱允文的下场，晁错几乎独揽了大权，削藩的下场是什么？腰斩。清查空置率，zf不参与一级开发，不是扯淡吗？</p>
<h2 id="二三线城市，选新城还是老城"><a href="#二三线城市，选新城还是老城" class="headerlink" title="二三线城市，选新城还是老城"></a>二三线城市，选新城还是老城</h2><p><strong>wofuleyumin1：</strong></p>
<p>楼主 我又有问题了。。。。请务必回答 谢谢</p>
<p>1。目前很多城市开发新城 我们主要谈二三线城市吧。。。这些地方的新城会超越老城吗？ 我们投资该投新城还是老城？</p>
<p>比如成都 南边的天府新城，口号国际城南。。</p>
<p>2。投资一定投越靠市中心越好吗？ 比如成都，西三环是比东二环还好。。但未来2环是否最终比3环好？</p>
<p><strong>kkndme：</strong></p>
<p>拆迁是块硬骨头，不够铁腕的领导会避开破旧但繁华的老城区的问题，转而开发新城，所以往往形成倒挂，即新城一下子变成了新贵聚居区，新城的房价甚至高过老城区。 但这是一种倒挂，老城升级改造是必然的一步棋，只是时间的早晚。未来老城区的升级改造，老城区的价值就会凸显，价格要远远高于新城。</p>
<p>但是老城区的多数老房子都可能面临拆迁，投资老城区的老房子不见得划算，特别是二三线城市的拆迁，离皇帝越远的城市，争取合理补偿越困难。</p>
<h2 id="在中国，普通人手上闲钱不多的人被剥削"><a href="#在中国，普通人手上闲钱不多的人被剥削" class="headerlink" title="在中国，普通人手上闲钱不多的人被剥削"></a>在中国，普通人手上闲钱不多的人被剥削</h2><p><strong>抽着雪茄喝着绿茶：</strong></p>
<p>兰州，我近来盛干人民币的贬值力度之强烈<br>现在手上还有十万的盈余<br>做什么好呢<br>咬紧牙关供一套房？买黄金？还是买车呢？<br>总之不能空放着，<br>这样通货膨胀下去，汽车的价格也会涨吗？</p>
<p><strong>kkndme：</strong></p>
<p>买车是消费，不是投资，如果追求享受，可以买车，但不能保值增值。汽车属于工业品，通过扩大生产规模可以使边际成本下降，所以汽车会因为档次的不同有涨有跌。<br>黄金可以适当配置，但由于黄金的定价权不在国内，所以买黄金有一定的风险。<br>十几万买房子估计不够首付，除非特别小的城市。但小城市的房产变现起来比较麻烦。<br>至于古玩字画茅台酒之类的，真假难辨，不是专家很难参与投资，且一般人变现还是很困难的。<br>所以资金越小，资金实现保值增值越困难。我国实行的高通胀低利率政策，是对手中闲钱不多的普通群众赤裸裸的剥削。而手中闲钱较多的中产阶层，相对好一点，可以投资住宅商铺进行保值增值。</p>
<h2 id="三分天注定，七分靠打拼"><a href="#三分天注定，七分靠打拼" class="headerlink" title="三分天注定，七分靠打拼"></a>三分天注定，七分靠打拼</h2><p><strong>汝爱之罪：</strong></p>
<p>从晁错的上位过程可以看出，口才很重要</p>
<p><strong>kkndme：</strong></p>
<p>呵呵，这个也不一定，一个是看老板的风格，一个是看自身的运气。<br>说汉文帝刘恒去参观皇家动物园（上林苑）就问动物园园长：“咱们动物园有多少动物啊，都有什么品种啊？”一下子把园长问晕了，吭吭叽叽答不上来。<br>这时有个负责老虎的工作人员跑了出来，作了一通汇报，如数家珍，回答的头头是道。刘恒特别高兴，觉得这个管理老虎的工作人员口才特别好，想提拔他当动物园园长。<br>这时候张释之蹦了出来，对皇帝说：秦朝的时候，赵高口才就特别好，特别巧言善辩，结果忠厚的大臣都被迫害了，天下大乱，秦朝完蛋了。陛下要是提拔这个管理大老虎的人，恐怕所有的大臣都会效仿他，专门学习卡耐基演讲，并且天天琢磨吹牛拍马，就没人真正为皇帝干活了。<br>结果是可怜的管理老虎的工作人员白高兴了一场，不但没得到奖赏，还得罪了动物园园长。</p>
<h2 id="人的前程有的时候不掌握在自己手里"><a href="#人的前程有的时候不掌握在自己手里" class="headerlink" title="人的前程有的时候不掌握在自己手里"></a>人的前程有的时候不掌握在自己手里</h2><p>某城市从外省调来个姓q的一把手。该一把手一上任就把该市原来的骨干公务员全部晾到一边，一概不用，名义上对外宣称的是：领导干部年轻化。提拔了一批没有工作经验刚毕业的博士生当处级干部，大多数30岁还不到。这些人一点工作经验没有，以至于外界都很惊讶，甚至惊动了日本友人。<br>该一把手正是要用这些毫无工作经验的白纸，第一：人是自己一手提拔的，他能不感激涕零吗？第二：这些人啥也不懂，自己想怎么干就怎么干，这些人听话就行。不这样做，怎么能一手遮天呢？<br>一批期望往上爬的老公务员就这样牺牲掉了，而一批新丁就此崛起。人生的前程往往不掌握在自己手里。</p>
<h2 id="河南郑州-与-洛阳"><a href="#河南郑州-与-洛阳" class="headerlink" title="河南郑州 与 洛阳"></a>河南郑州 与 洛阳</h2><p><strong>scdf1234：</strong></p>
<p>楼主，我想咨询一下，像洛阳这样的城市，它的经济在河南是第二位，但又离省会郑州很近，洛阳的房价现在大概是四千多，您认为洛阳的房价上涨的空间大吗？<br>谢谢！！！！！！！！！！！！</p>
<p><strong>kkndme：</strong></p>
<p>洛阳只能成为郑州的影子，如果自住，趁早在洛阳买房，以后一定会涨，如果投资，还是在郑州买，郑州的上涨空间，肯定大于洛阳。<br>不过95年以后，我就再也没去过洛阳，所以洛阳买哪个楼盘升值快，你得自己仔细研究。</p>
<h2 id="杭州"><a href="#杭州" class="headerlink" title="杭州"></a>杭州</h2><p><strong>灵魂被枪决：</strong></p>
<p>不知道楼主还在不在，因为只看完前面几页。</p>
<p>我前两天刚定了一套二手房，昨天打了首付款，下星期应该就要办银行按揭手续了。</p>
<p>我一直很想买房，但我LG一直不愿意买房，就在定下这套房子之前他还是很不乐意，但</p>
<p>因为我的坚持，我们终于买了房子了。房子定下后一个石头落地了，但另一个石头有悬</p>
<p>地半空了，因为我们是做个体户生意的，就怕生意有变故贷款接不上（我是个悲观主义</p>
<p>者，总先把最坏情况打算在前）。我们是在杭州，虽然不是市中心，但也算是市区了，</p>
<p>请问楼主能分析一下杭州楼市情况吗？？</p>
<p>先谢过了，楼主的文章对我启发真的很大</p>
<p><strong>kkndme：</strong></p>
<p>前面说过了，杭州我是当一线城市看的。杭州这个城市，本来就是富人的天堂，房价涨到多高都不奇怪，而且极好变现。所以你根本无须担忧资金问题。</p>
<h2 id="西安-与-重庆"><a href="#西安-与-重庆" class="headerlink" title="西安 与 重庆"></a>西安 与 重庆</h2><p><strong>ttan12345：</strong></p>
<p>用了一整天的时间拜读了楼主的精彩文章，很是佩服！</p>
<p>印象最深刻的就是北周宇文式和苏的关于贪官的对答，古人真有高人啊！</p>
<p>感觉楼主知识面相当的宽广，尤其对世界历史比较精通，许多观点非常符合世界发展的规律</p>
<p>关于房产的问题，我也一直认为，最终不是我们小老百姓可以玩的东子，所以能买就</p>
<p>尽早买。看了楼主不止一次给大家推荐去投资西安和重庆的地产，楼主问什么看好西安</p>
<p>和重庆这两个地方，现在各个省会城市哪个不是大兴土木呢？为何西安和重庆会进入你</p>
<p>的法眼？</p>
<p><strong>kkndme：</strong></p>
<p>重庆我就不多说，论述的比较多了，发展重庆是国家战略性的，这是政治任务。<br>西安是西北地区唯一的大城市（乌市比较特殊，不讨论乌市），教育资源丰富，且房价基数较低，所以说后续发展潜力很大，未来该城市的发展一定会纳入zy的视野</p>
<h2 id="谢国中「空置率」"><a href="#谢国中「空置率」" class="headerlink" title="谢国中「空置率」"></a>谢国中「空置率」</h2><p><strong>林语边的鸽子：</strong></p>
<p>谢国中:”一是加息预期；二是政府对房地产的政策调控力度不改；三是市场对人民币升值的预期减弱；四是参考了实际的供应量，“到2012年，房地产的空置率会非常高，全中国13亿老百姓要有的房子都有了。”<br>谢国忠预测，“接下来可能会看到交易量一直在增长，而房价却不死不活地拖几年，房地产没有第二场戏了</p>
<p>请问楼主对谢国中的说法怎么看?<br>谢谢</p>
<p><strong>kkndme：</strong></p>
<p>谢是油价和中国房地产的长期唱空者，从04年开始唱空中国房产。谢的有些话还是很有道理的，但有些预测就另有目的了，毕竟屁股决定脑袋。<br>今年谢一直呼吁的是加息，兼带唱空房地产，唱空房地产的主要依据是空置率。<br>谢自己也说中国的房地产最大受益的是zf，但却用空置率给出了一个下跌的结论。<br>人民币升值，呼吁加息，唱空房地产，摩根史丹利的喉舌作用显而易见的</p>
<h2 id="打工不如有一技之长的小老板"><a href="#打工不如有一技之长的小老板" class="headerlink" title="打工不如有一技之长的小老板"></a>打工不如有一技之长的小老板</h2><p>进不了体制内的，无论是不是大学毕业，凡是有头脑的、懂做生意的，会一技之长的，只要不懒，活的肯定比无特长一般在公司打工的小白领强。<br>古代也是这样的，街面上卖爆肚的肯定比大户人家厨房里负责切葱的日子过的稳当。卖爆肚的小本生意很累很辛苦，但是有个手艺就不会饿肚子。大户人家切葱的上班期间日子过的比较轻松，甚至收入比卖爆肚的还强点，在大户人家也体面些。但一旦大户人家不要切葱的了，裁员了，这个切葱的出来还真没办法养活自己。<br>大学文凭顶多算个秀才资格，有这个资格才有机会举士，但是举不了士的，就必须学点技术，否则收入远远赶不上瓦工、电工。<br>过去的穷秀才，饭都吃不饱，但是社会地位却不差，一旦中了恩科，就是宰相根苗。现在有点不同，进不了体制内，又没点技术，那肯定沦为社会的最底层，不要说买房子了，能不能解决吃饭问题都不一定。</p>
<h2 id="一线、二线的生活"><a href="#一线、二线的生活" class="headerlink" title="一线、二线的生活"></a>一线、二线的生活</h2><p>一线和二线选择哪个城市生活，其实就是围城。<br>在一线打拼，有技术有背景或者机会好的，进了金字塔的中层。对于没背景的，运气差点的，看着没什么希望就离开了，到二线发展，起码二线生活成本还低点。混不下去的离开了，又有大量的打算拼一把的冲进来。<br>很多人宁可在大城市当底层，也不愿意回小城市。这还是个观念问题。小城市从城东走到城西也就二十分钟，觉得过得太枯草。大城市灯红酒绿的，虽然跟自己其实没多大关系，但是看着就是舒服。</p>
<h2 id="房子不属于市场经济（阴谋论的角度）"><a href="#房子不属于市场经济（阴谋论的角度）" class="headerlink" title="房子不属于市场经济（阴谋论的角度）"></a>房子不属于市场经济（阴谋论的角度）</h2><p>不说历史了，讲个故事吧。这个故事纯属虚构，如有雷同，纯属巧合。讲故事麽，就不要和谐了。<br>传说王安石变法失败，后人小王跑到了海外，发现了大西洲。大西洲正处于混乱阶段，军阀割据，外族入侵。小王是个政治军事天才，煽动农民起义，统一了大西洲政权，建立了大西国。<br>小王继承了王安石变法的理想，建立了一个中央高度集权，百姓与百姓之间完全消灭差别的理想国家。农场、工厂、商场全部由国家统一经营，老百姓只需要在国家的农场、工厂、商场里快乐打工就行了。老百姓穿一样的，吃一样的，连结婚都是国家给安排。<br>大西国里有的知识分子认为这样治理国家太机器化了，有违人性。小王同志对这些知识分子很生气。<br>遥远的东方，有一个白鹿洞书院，书院的院长是个伟大的导师，这个人叫朱熹，此人提出了存天理、灭人欲的理论，给了小王同志治理国家理论上的支持。<br>于是小王同志大搞禁欲主义，凡是学习过陆九渊、王阳明心学理论的都抓起来改造。</p>
<p>不久，大西国经营的农场、工厂、商场就出了问题。效率特别低，老百姓出工不出力，胡干蛮干的比比皆是，后来出现了大饥荒，饿死了不少人。小王同志干不下去，被人赶走了。<br>新领导上台后，先把农场划分给农民，提高农民的积极性，先解决粮食问题。但是工厂、商场就比较不好办。<br>新领导认为，工厂、商场效益低，赔钱是因为负担太重了，城市里的老百姓生老病死都是由国家的工厂、商场负责，国家哪里管的起呢？<br>于是新领导就提出给国家的企业减负，给点优惠政策，拿出胡萝卜，让胆子大愿意自己单干的同志们主动离开国家企业。对于很多死活不肯走的同志，新领导强令这些人卷铺盖，国家不再负担这些人的生老病死了。大家自己解决吧，国家不管了。<br>新领导把还留在国家企业的自己人，定义为内部人员。离开国家企业的，就是外人，定义为社会闲杂人等。<br>社会闲杂人等，有人欢喜有人忧。有人利用内部人员的关系，大把赚钱，有人跑去给外国人当洋买办赚的也不少，还有的知识分子凭着有点文化，给人打工生活的也不错，反正这些人都挺高兴，比在内部受穷强。当然也有没本事的，就比较惨，生活的比较困难。</p>
<p>新领导看见内部都是自己人了，闲杂人等都清理掉了，于是着手内部改革，凡是稀缺的，与老百姓生产生活密切相关的行业，都由内部来经营，不需要动脑子搞创新，只要定个价，老百姓就必须得接受。<br>而需要创新动脑子的产业，不具备稀缺性必须充分竞争的产业，不是跟老百姓生产生活密切相关的产业都交给社会闲杂人等去自由竞争。<br>相当于把肉都留给了内部自己，把骨头扔给了外部闲杂人员。<br>这样做还有个好处：新领导喜欢内部自己人直接跟外国人做生意，但是只要跟外国人做生意就赔钱，赔的还不是一点半点。赔的钱从哪里补呢？<br>只要通过内部自己人经营的企业，抬高定价，将赔掉的钱转嫁给社会闲杂人等就可以了。<br>于是，当初离开内部的社会闲杂人等发现，钱也难赚了，生活成本也越来越高了，日子过得变得越来越艰难了。<br>这时有个傻空跳出来说：我就不信了，市场经济没有只涨不跌的商品。房价肯定会跌。<br>有个明白人告诉他：市场经济是分品种的。外部社会闲杂人等经营的电脑、电视是市场经济。但是内部人经营的石油、房地产不是市场经济。不能拿市场经济来解释。<br>这个傻空不信，本来在大西国能买房的，结果一直没买，后来买不起了，只好一直租房住。但是房租老涨价，吃饭越来越困难，一年难得吃两回肉。</p>
<h2 id="什么是好的政策"><a href="#什么是好的政策" class="headerlink" title="什么是好的政策"></a>什么是好的政策</h2><p>好的政策就象挂在驴子鼻子上的胡萝卜，让人永远有希望，但是拼命追也吃不到。这就是中国政治家的最高智慧。</p>
<p>洋人进北京，老佛爷把义和团推出来，结果拳匪搞的鸡飞狗跳，没法收场。<br>保钓也打算发动群众，靠爱国激情转嫁矛盾。不过好像这招不灵了。老板怎么对待员工，员工就会怎么回报老板。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>非技术转贴</tag>
      </tags>
  </entry>
</search>
