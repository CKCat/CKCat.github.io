<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ckcat.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="线程概念每个线程都包含有表示执行环境所必需的信息，其中包括进程中标识线程的线程 ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno 变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。 线程标识就像每个进程有一个进程 ID 一样，每个线程也有一个线程 ID。线程 ID 是用 pthread_t 数据类型">
<meta property="og:type" content="article">
<meta property="og:title" content="unix环境高级编程11-线程">
<meta property="og:url" content="https://ckcat.github.io/2023/04/10/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B11-%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="CKCat的博客">
<meta property="og:description" content="线程概念每个线程都包含有表示执行环境所必需的信息，其中包括进程中标识线程的线程 ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno 变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。 线程标识就像每个进程有一个进程 ID 一样，每个线程也有一个线程 ID。线程 ID 是用 pthread_t 数据类型">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-04-10T17:22:18.000Z">
<meta property="article:modified_time" content="2023-09-19T14:03:10.485Z">
<meta property="article:author" content="CKCat">
<meta property="article:tag" content="linux 编程">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ckcat.github.io/2023/04/10/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B11-%E7%BA%BF%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ckcat.github.io/2023/04/10/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B11-%E7%BA%BF%E7%A8%8B/","path":"2023/04/10/unix环境高级编程11-线程/","title":"unix环境高级编程11-线程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>unix环境高级编程11-线程 | CKCat的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">CKCat的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">线程概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AF%86"><span class="nav-number">2.</span> <span class="nav-text">线程标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">3.</span> <span class="nav-text">线程创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-number">4.</span> <span class="nav-text">线程终止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">5.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">5.1.</span> <span class="nav-text">互斥量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">5.2.</span> <span class="nav-text">避免死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0-pthread-mutex-timedlock"><span class="nav-number">5.3.</span> <span class="nav-text">函数 pthread_mutex_timedlock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">5.4.</span> <span class="nav-text">读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89%E8%B6%85%E6%97%B6%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">5.5.</span> <span class="nav-text">带有超时的读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">5.6.</span> <span class="nav-text">条件变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">5.7.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%8F%E9%9A%9C"><span class="nav-number">5.8.</span> <span class="nav-text">屏障</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CKCat</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">113</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/CKCat" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;CKCat" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ckcatck@qq.com" title="E-Mail → mailto:ckcatck@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ckcat.github.io/2023/04/10/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B11-%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CKCat">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CKCat的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="unix环境高级编程11-线程 | CKCat的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          unix环境高级编程11-线程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-04-10 17:22:18" itemprop="dateCreated datePublished" datetime="2023-04-10T17:22:18+00:00">2023-04-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-19 14:03:10" itemprop="dateModified" datetime="2023-09-19T14:03:10+00:00">2023-09-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">unix环境高级编程</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>每个线程都包含有表示执行环境所必需的信息，其中包括进程中标识线程的线程 ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、<code>errno</code> 变量以及线程私有数据。<strong>一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。</strong></p>
<h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>就像每个进程有一个进程 ID 一样，每个线程也有一个线程 ID。线程 ID 是用 <code>pthread_t</code> 数据类型来表示的，实现的时候可以用一个结构来代表 <code>pthread_t</code> 数据类型，所以可移植的操作系统实现不能把它作为整数处理。因此必须使用一个函数 <code>pthread_equal</code> 来对两个线程 ID 进行比较。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> tid1, <span class="type">pthread_t</span> tid2)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<ul>
<li>若相等，返回非 0 数值；</li>
<li>否则，返回 0。</li>
</ul>
<p>Linux 3.2.0 使用无符号长整型表示 <code>pthread_t</code> 数据类型。</p>
<p>线程可以通过调用 <code>pthread_self</code> 函数获得自身的线程 ID。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<ul>
<li>调用线程的线程 ID。</li>
</ul>
<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>在传统 UNIX 进程模型中，每个进程只有一个控制线程。从概念上讲，这与基于线程的模型中每个进程只包含一个线程是相同的。在 <code>POSIX</code> 线程（<code>pthread</code>）的情况下，程序开始运行时，它也是以单进程中的单个控制线程启动的。在创建多个控制线程以前，程序的行为与传统的进程并没有什么区别。新增的线程可以通过调用 <code>pthread_create</code> 函数创建。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *<span class="keyword">restrict</span> tidp, <span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,</span></span><br><span class="line"><span class="params">                    <span class="type">void</span> *(*start_rtn)(<span class="type">void</span> *), <span class="type">void</span> *<span class="keyword">restrict</span> arg)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号。</li>
</ul>
<p>参数：</p>
<ul>
<li><code>tidp</code>：指向 <code>pthread_t</code> 类型的指针，用于存储新线程的标识符。</li>
<li><code>attr</code>：指向 <code>pthread_attr_t</code> 类型的指针，用于指定新线程的属性，通常可以设置为 <code>NULL</code> 以使用默认属性。</li>
<li><code>start_rtn</code>：是一个指向线程主函数的指针，该函数在新线程中运行。它接受一个 <code>void*</code> 类型的参数，并返回一个 <code>void*</code> 类型的值。</li>
<li><code>arg</code>：是传递给 <code>start_rtn</code> 函数的参数。</li>
</ul>
<p>当 <code>pthread_create</code> 成功返回时，新创建线程的线程 <code>ID</code> 会被设置成 <code>tidp</code> 指向的内存单元。<code>attr</code> 参数用于定制各种不同的线程属性，置为 <code>NULL</code>，创建一个具有默认属性的线程。新创建的线程从 <code>start_rtn</code> 函数的地址开始运行，该函数只有一个无类型指针参数 <code>arg</code>。</p>
<p>新创建的线程可以访问进程的地址空间，并且继承调用线程的浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除。</p>
<p>例子，打印线程 ID。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> ntid;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printids</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>&#123;</span><br><span class="line">	<span class="type">pid_t</span> pid;</span><br><span class="line">	<span class="type">pthread_t</span> tid;</span><br><span class="line">	pid = getpid();</span><br><span class="line">	tid = pthread_self();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s pid %lu tid %lu (0x%lx)\n&quot;</span>, s, (<span class="type">unsigned</span> <span class="type">long</span>)pid,</span><br><span class="line">			(<span class="type">unsigned</span> <span class="type">long</span>)tid, (<span class="type">unsigned</span> <span class="type">long</span>)tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thr_fn</span><span class="params">(<span class="type">void</span>* arg)</span>&#123;</span><br><span class="line">	printids(<span class="string">&quot;new thread: &quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	err = pthread_create(&amp;ntid, <span class="literal">NULL</span>, thr_fn, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	printids(<span class="string">&quot;main thread: &quot;</span>);</span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc 01pthread_create.c -lpthread</span><br><span class="line">$ ./a.out</span><br><span class="line">main thread:  pid 6391 tid 140047663408960 (0x7f5f633aa740)</span><br><span class="line">new thread:  pid 6391 tid 140047663404800 (0x7f5f633a9700)</span><br></pre></td></tr></table></figure>

<h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>如果进程中的任意线程调用了 <code>exit</code>、<code>_Exit</code> 或者 <code>_exit</code>，那么整个进程就会终止。与此相类似，如果默认的动作是终止进程，那么，发送到线程的信号就会终止整个进程</p>
<p>单个线程可以通过 3 种方式退出，因此可以在不终止整个进程的情况下，停止它的控制流。</p>
<ol>
<li>线程可以简单地从启动例程中返回，返回值是线程的退出码。</li>
<li>线程可以被同一进程中的其他线程取消。</li>
<li>线程调用 <code>pthread_exit</code>。</li>
</ol>
<p><code>pthread_exit</code> 是 <code>POSIX</code> 线程库中的一个函数，它用于终止当前线程的执行，并可以传递一个退出状态给等待它的其他线程或进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *rval_ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>参数：<br><code>rval_ptr</code> 参数是一个无类型指针，与传给启动例程的单个参数类似。进程中的其他线程也可以通过调用 <code>pthread_join</code> 函数访问到这个指针。</p>
<p><code>pthread_join</code> 是 <code>POSIX</code> 线程库中的一个函数，它用于等待指定线程的终止，并且可以获取该线程的返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **rval_ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号</li>
</ul>
<p>参数：</p>
<ul>
<li><code>thread</code>：要等待的线程的标识符，通常由 <code>pthread_create</code> 返回。</li>
<li><code>rval_ptr</code>：一个指向指针的指针，用于存储目标线程的返回值。</li>
</ul>
<p>调用线程在调用 <code>pthread_join</code> 函数后将一直阻塞，直到指定的线程调用 <code>pthread_exit</code>、从启动例程中返回或者被取消。如果线程简单地从它的启动例程返回，<code>rval_ptr</code> 就包含返回码。如果线程被取消，由 <code>rval_ptr</code> 指定的内存单元就设置为 <code>PTHREAD_CANCELED</code>。</p>
<p>默认情况下，通过 <code>pthread_create</code> 创建的线程是非分离状态的。这意味着在线程终止后，它的资源（如线程描述符和内存）不会被自动释放，直到另一个线程通过调用 <code>pthread_join</code> 来等待并获取该线程的终止状态和返回值。这种情况下，线程的资源会一直被保留，直到其他线程明确地要求回收它们。</p>
<p>通过调用 <code>pthread_join</code> 并将 <code>rval_ptr</code> 参数设置为 <code>NULL</code>，或者使用 <code>pthread_detach</code> 函数，可以将线程置于分离状态。在分离状态下，线程的资源会在它终止时自动释放，而无需其他线程显式等待和获取线程的状态和返回值。如果对线程的返回值并不感兴趣，那么可以把 <code>rval_ptr</code> 设置为 <code>NULL</code>。</p>
<p>例子，获得线程退出状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thr_fn1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread 1 returning.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thr_fn2</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread 2 returning.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">	<span class="type">void</span> *tret;</span><br><span class="line"></span><br><span class="line">	err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;can&#x27;t create thread 1&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	err = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thr_fn2, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;can&#x27;t create thread 2&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里将阻塞，等待线程退出</span></span><br><span class="line">	err = pthread_join(tid1, &amp;tret);</span><br><span class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;can&#x27;t join thread 1&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread 1 exit code %ld\n&quot;</span>, (<span class="type">long</span>)tret);</span><br><span class="line"></span><br><span class="line">	err = pthread_join(tid2, &amp;tret);</span><br><span class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;can&#x27;t join thread 2&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread 2 exit code %ld\n&quot;</span>, (<span class="type">long</span>)tret);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc 02pthread_join.c -lpthread</span><br><span class="line">$ ./a.out</span><br><span class="line">thread 1 returning.</span><br><span class="line">thread 1 <span class="built_in">exit</span> code 1</span><br><span class="line">thread 2 returning.</span><br><span class="line">thread 2 <span class="built_in">exit</span> code 2</span><br></pre></td></tr></table></figure>

<p>当一个线程通过调用 <code>pthread_exit</code> 退出或者简单地从启动例程中返回时，进程中的其他线程可以通过调用 <code>pthread_join</code> 函数获得该线程的退出状态。</p>
<p><code>pthread_create</code> 和 <code>pthread_exit</code> 函数的无类型指针参数可以传递的值不止一个，这个指针可以传递包含复杂信息的结构的地址，但是注意，这个结构所使用的内存在调用者完成调用以后必须仍然是有效的。</p>
<p>例子，<code>pthread_exit</code> 参数的不正确使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> a, b, c, d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printfoo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="keyword">struct</span> foo *fp)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  structure at 0x%lx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  foo.a = %d\n&quot;</span>, fp-&gt;a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  foo.b = %d\n&quot;</span>, fp-&gt;b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  foo.c = %d\n&quot;</span>, fp-&gt;c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;  foo.d = %d\n&quot;</span>, fp-&gt;d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thr_fn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">fo</span> =</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">	printfoo(<span class="string">&quot;in thread 1:\n&quot;</span>, &amp;fo);</span><br><span class="line">	pthread_exit((<span class="type">void</span>*)&amp;fo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">pthread_t</span> tid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">fp</span>;</span></span><br><span class="line">	err = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_fn, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;can&#x27;t create thread&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	err = pthread_join(tid, (<span class="type">void</span> *)&amp;fp);</span><br><span class="line">	<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot; can&#x27;t join thread&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	printfoo(<span class="string">&quot;in parent:\n&quot;</span>, fp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ gcc 03pthread_exit.c -lpthread</span><br><span class="line">$ ./a.out</span><br><span class="line"><span class="keyword">in</span> thread 1:</span><br><span class="line">  structure at 0x7f18f8c79ed0</span><br><span class="line">  foo.a = 1</span><br><span class="line">  foo.b = 2</span><br><span class="line">  foo.c = 3</span><br><span class="line">  foo.d = 4</span><br><span class="line"><span class="keyword">in</span> parent:</span><br><span class="line">  structure at 0x7f18f8c79ed0</span><br><span class="line">  foo.a = 0</span><br><span class="line">  foo.b = 0</span><br><span class="line">  foo.c = -1743576962</span><br><span class="line">  foo.d = 32767</span><br></pre></td></tr></table></figure>

<p>运行结果根据内存体系结构、编译器以及线程库的实现会有所不同。可以看到，当主线程访问这个结构时，结构的内容已经改变了。</p>
<p>线程可以通过调用 <code>pthread_cancel</code> 函数来请求取消同一进程中的其他线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号。</li>
</ul>
<p>在默认情况下，<code>pthread_cancel</code> 函数会使得由 <code>tid</code> 标识的线程的行为表现为如同调用了参数为 <code>PTHREAD_CANCELED</code> 的 <code>pthread_exit</code> 函数，但是，线程可以选择忽略取消或者控制如何被取消。</p>
<p><strong>注意 <code>pthread_cancel</code> 并不等待线程终止，它仅仅提出请求。</strong></p>
<p>线程可以安排它退出时需要调用的函数，这与进程在退出时可以用 <code>atexit</code> 函数安排退出是类似的。这样的函数称为线程清理处理程序（thread cleanup handler）。一个线程可以建立多个清理处理程序。处理程序记录在栈中，也就是说，它们的执行顺序与它们注册时相反。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*rtn)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span>;</span><br></pre></td></tr></table></figure>

<p>当线程执行以下动作时，清理函数 <code>rtn</code> 是由 <code>pthread_cleanup_push</code> 函数调度的，调用时只有一个参数 <code>arg</code>：</p>
<ul>
<li>调用 <code>pthread_exit</code> 时；</li>
<li>响应取消请求时；</li>
<li>用非零 <code>execute</code> 参数调用 <code>pthread_cleanup_pop</code> 时。</li>
</ul>
<p>如果 <code>execute</code> 参数设置为 0，清理函数将不被调用。不管发生上述哪种情况，<code>pthread_cleanup_pop</code> 都将删除上次 <code>pthread_cleanup_push</code> 调用建立的清理处理程序。<br>这些函数有一个限制，由于它们可以实现为宏，所以必须在与线程相同的作用域中以匹配对的形式使用。</p>
<p>例子，线程清理处理程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;cleanup: %s\n&quot;</span>, (<span class="type">char</span> *)arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thr_fn1</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread 1 start.\n&quot;</span>);</span><br><span class="line">	pthread_cleanup_push(cleanup, <span class="string">&quot;thread 1 first handler.&quot;</span>);</span><br><span class="line">	pthread_cleanup_push(cleanup, <span class="string">&quot;thread 1 second handler.&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread 1 push complete.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (arg)</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">void</span> *)<span class="number">1</span>;</span><br><span class="line">	pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">	pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> ((<span class="type">void</span> *)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thr_fn2</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread 2 start.\n&quot;</span>);</span><br><span class="line">	pthread_cleanup_push(cleanup, <span class="string">&quot;thread 2 first handler.&quot;</span>);</span><br><span class="line">	pthread_cleanup_push(cleanup, <span class="string">&quot;thread 2 second handler.&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread 2 push complete.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (arg)</span><br><span class="line">		pthread_exit((<span class="type">void</span> *)<span class="number">2</span>);</span><br><span class="line">	pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">	pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">	pthread_exit((<span class="type">void</span> *)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">	<span class="type">void</span> *tret;</span><br><span class="line"></span><br><span class="line">	err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, (<span class="type">void</span> *)<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;can&#x27;t create thread 1&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	err = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thr_fn2, (<span class="type">void</span> *)<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;can&#x27;t create thread 2&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	err = pthread_join(tid1, &amp;tret);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;can&#x27;t join with thread 1&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread 1 exit code %ld.\n&quot;</span>, (<span class="type">long</span>)tret);</span><br><span class="line">	err = pthread_join(tid2, &amp;tret);</span><br><span class="line">	<span class="keyword">if</span> (err != <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;can&#x27;t join with thread 2&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;thread 2 exit code %ld.\n&quot;</span>, (<span class="type">long</span>)tret);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gcc 04pthread_cleanup.c -lpthread</span><br><span class="line">$ ./a.out</span><br><span class="line">thread 1 start.</span><br><span class="line">thread 1 push complete.</span><br><span class="line">thread 2 start.</span><br><span class="line">thread 2 push complete.</span><br><span class="line">thread 1 <span class="built_in">exit</span> code 1.</span><br><span class="line">cleanup: thread 2 second handler.</span><br><span class="line">cleanup: thread 2 first handler.</span><br><span class="line">thread 2 <span class="built_in">exit</span> code 2.</span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出，两个线程都正确地启动和退出了，但是只有第二个线程的清理处理程序被调用了。因此，如果线程是通过从它的启动例程中返回而终止的话，它的清理处理程序就不会被调用。</p>
<p>进程和线程原语的比较。</p>
<table>
<thead>
<tr>
<th>进程原语</th>
<th>线程原语</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>fork</code></td>
<td><code>pthread_create</code></td>
<td>创建新的控制流</td>
</tr>
<tr>
<td><code>exit</code></td>
<td><code>pthread_exit</code></td>
<td>从现有的控制流中退出</td>
</tr>
<tr>
<td><code>waitpid</code></td>
<td><code>pthread_join</code></td>
<td>从控制流中得到退出状态</td>
</tr>
<tr>
<td><code>atexit</code></td>
<td><code>pthread_cancel_push</code></td>
<td>注册在退出控制流时调用的函数</td>
</tr>
<tr>
<td><code>getpid</code></td>
<td><code>pthread_self</code></td>
<td>获取控制流的 ID</td>
</tr>
<tr>
<td><code>abort</code></td>
<td><code>pthread_cancel</code></td>
<td>请求控制流的非正常退出</td>
</tr>
</tbody></table>
<p>在默认情况下，线程的终止状态会保存直到对该线程调用 <code>pthread_join</code>。如果线程已经被分离，线程的底层存储资源可以在线程终止时立即被收回。</p>
<p>可以调用 <code>pthread_detach</code> 分离线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号。</li>
</ul>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当多个控制线程共享相同的内存时，需要确保每个线程看到一致的数据视图。如果每个线程使用的变量都是其他线程不会读取和修改的，那么就不存在一致性问题。同样，如果变量是只读的，多个线程同时读取该变量也不会有一致性问题。但是，当一个线程可以修改的变量，其他线程也可以读取或者修改的时候，我们就需要对这些线程进行同步，确保它们在访问变量的存储内容时不会访问到无效的值。</p>
<p>两个或多个线程试图在同一时间修改同一变量时，也需要进行同步。</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>可以使用 <code>pthread</code> 的互斥接口来保护数据，确保同一时间只有一个线程访问数据。互斥量（mutex）从本质上说是一把锁，在访问共享资源前对互斥量进行设置（加锁），在访问完成后释放（解锁）互斥量。对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程都会被阻塞直到当前线程释放该互斥锁。如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变为运行的线程就可以对互斥量加锁，其他线程就会看到互斥量依然是锁着的，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。</p>
<p>互斥变量是用 <code>pthread_mutex_t</code> 数据类型表示的。在使用互斥变量以前，必须首先对它进行初始化，可以把它设置为常量 <code>PTHREAD_MUTEX_INITIALIZER</code>（只适用于静态分配的互斥量），也可以通过调用 <code>pthread_mutex_init</code> 函数进行初始化。如果动态分配互斥量，在释放内存前需要调用 <code>pthread_mutex_destroy</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>两个函数的返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号。</li>
</ul>
<p>要用默认的属性初始化互斥量，只需把 <code>attr</code> 设为 <code>NULL</code>。</p>
<p>对互斥量进行加锁，需要调用 <code>pthread_mutex_lock</code>。如果互斥量已经上锁，调用线程将阻塞直到互斥量被解锁。对互斥量解锁，需要调用 <code>pthread_mutex_unlock</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>

<p>所有函数的返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号。</li>
</ul>
<p>如果线程不希望被阻塞，它可以使用 <code>pthread_mutex_trylock</code> 尝试对互斥量进行加锁。如果调用 <code>pthread_mutex_trylock</code> 时互斥量处于未锁住状态，那么 <code>pthread_mutex_trylock</code> 将锁住互斥量，不会出现阻塞直接返回 0，否则 <code>pthread_mutex_trylock</code> 就会失败，不能锁住互斥量，返回 <code>EBUSY</code>。</p>
<p>例子，使用互斥量保护数据结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> f_count; <span class="comment">// 使用引用计数</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> f_lock;</span><br><span class="line">    <span class="type">int</span> f_id;</span><br><span class="line">    <span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> foo *<span class="title function_">foo_alloc</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> foo))) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        fp-&gt;f_count = <span class="number">1</span>; <span class="comment">// 引用计数初始化为 1</span></span><br><span class="line">        fp-&gt;f_id = id;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;fp-&gt;f_lock, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(fp);</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* ... continue initialization ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用该对象时，线程需要调用 foo_hold 对这个对象的引用计数加 1。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo_hold</span><span class="params">(<span class="keyword">struct</span> foo *fp)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">    fp-&gt;f_count++;</span><br><span class="line">    pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当对象使用完毕时，必须调用 foo_rele 释放引用。最后一个引用被释放时，</span></span><br><span class="line"><span class="comment">// 对象所占的内存空间就被释放。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo_rele</span><span class="params">(<span class="keyword">struct</span> foo *fp)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">    <span class="keyword">if</span> (--fp-&gt;f_count == <span class="number">0</span>)</span><br><span class="line">    &#123; <span class="comment">/* last reference */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">        pthread_mutex_destroy(&amp;fp-&gt;f_lock);</span><br><span class="line">        <span class="built_in">free</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个以上的线程需要访问动态分配的对象时，我们可以在对象中嵌入引用计数，确保在所有使用该对象的线程完成数据访问之前，该对象内存空间不会被释放。</p>
<p>在 <code>foo_alloc</code> 函数中将引用计数初始化为 1 时没必要加锁，因为在这个操作之前分配线程是唯一引用该对象的线程。</p>
<p>在使用该对象前，线程需要调用 <code>foo_hold</code> 对这个对象的引用计数加 1。当对象使用完毕时，必须调用 <code>foo_rele</code> 释放引用。最后一个引用被释放时，对象所占的内存空间就被释放。</p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>如果线程试图对同一个互斥量加锁两次，那么它自身就会陷入死锁状态，但是使用互斥量时，还有其他不太明显的方式也能产生死锁。例如，程序中使用一个以上的互斥量时，如果允许一个线程一直占有第一个互斥量，并且在试图锁住第二个互斥量时处于阻塞状态，但是拥有第二个互斥量的线程也在试图锁住第一个互斥量。因为两个线程都在相互请求另一个线程拥有的资源，所以这两个线程都无法向前运行，于是就产生死锁。</p>
<p>可以通过仔细控制互斥量加锁的顺序来避免死锁的发生。例如，假设需要对两个互斥量 A 和 B 同时加锁。如果所有线程总是在对互斥量 B 加锁之前锁住互斥量 A，那么使用这两个互斥量就不会产生死锁（当然在其他的资源上仍可能出现死锁）。类似地，如果所有的线程总是在锁住互斥量 A 之前锁住互斥量 B，那么也不会发生死锁。可能出现的死锁只会发生在一个线程试图锁住另一个线程以相反的顺序锁住的互斥量。</p>
<p>例子，两个互斥量的使用方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NHASH 29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH(id) (((unsigned long)id) % NHASH)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">fh</span>[<span class="title">NHASH</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> hashlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> f_count;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> f_lock;</span><br><span class="line">    <span class="type">int</span> f_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">f_next</span>;</span> <span class="comment">/* protected by hashlock */</span></span><br><span class="line">                        <span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> foo *<span class="title function_">foo_alloc</span><span class="params">(<span class="type">int</span> id)</span>&#123; <span class="comment">/* allocate the object */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">fp</span>;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> foo))) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        fp-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">        fp-&gt;f_id = id;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;fp-&gt;f_lock, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(fp);</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        idx = HASH(id);</span><br><span class="line">        <span class="comment">// 分配函数现在锁住了散列列表锁，把新的结构添加到了散列桶中，</span></span><br><span class="line">        <span class="comment">// 而且在对散列列表的锁解锁之前，先锁定了新结构中的互斥量。</span></span><br><span class="line">        pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">        fp-&gt;f_next = fh[idx];</span><br><span class="line">        fh[idx] = fp;</span><br><span class="line">        pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">        pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">        <span class="comment">/* ... continue initialization ... */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo_hold</span><span class="params">(<span class="keyword">struct</span> foo *fp)</span> <span class="comment">/* add a reference to the object */</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">    fp-&gt;f_count++;</span><br><span class="line">    pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> foo *<span class="title function_">foo_find</span><span class="params">(<span class="type">int</span> id)</span> <span class="comment">/* find an existing object */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">fp</span>;</span></span><br><span class="line">    <span class="comment">// 锁住散列列表锁，然后搜索被请求的结构</span></span><br><span class="line">    pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">    <span class="keyword">for</span> (fp = fh[HASH(id)]; fp != <span class="literal">NULL</span>; fp = fp-&gt;f_next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;f_id == id)&#123;</span><br><span class="line">            <span class="comment">// 如果找到了，就增加其引用计数并返回指向该结构的指针。</span></span><br><span class="line">            foo_hold(fp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">    <span class="keyword">return</span> (fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo_rele</span><span class="params">(<span class="keyword">struct</span> foo *fp)</span>&#123; <span class="comment">/* release a reference to the object */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">tfp</span>;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">    <span class="keyword">if</span> (fp-&gt;f_count == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果这是最后一个引用，就需要对这个结构互斥量进行解锁，</span></span><br><span class="line">        <span class="comment">// 因为我们需要从散列列表中删除这个结构，这样才可以获取散列列表锁，然后重新获取结构互斥量。</span></span><br><span class="line">        pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">        pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">        pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">        <span class="comment">// 需要重新检查条件，判断是否还需要释放这个结构。</span></span><br><span class="line">        <span class="keyword">if</span> (fp-&gt;f_count != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 另一个线程在我们为满足锁顺序而阻塞时发现了这个结构并对其引用计数加 1 的情况。</span></span><br><span class="line">            fp-&gt;f_count--;</span><br><span class="line">            pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">            pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* remove from list */</span></span><br><span class="line">        idx = HASH(fp-&gt;f_id);</span><br><span class="line">        tfp = fh[idx];</span><br><span class="line">        <span class="keyword">if</span> (tfp == fp)</span><br><span class="line">        &#123;</span><br><span class="line">            fh[idx] = fp-&gt;f_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (tfp-&gt;f_next != fp)</span><br><span class="line">                tfp = tfp-&gt;f_next;</span><br><span class="line">            tfp-&gt;f_next = fp-&gt;f_next;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">        pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">        pthread_mutex_destroy(&amp;fp-&gt;f_lock);</span><br><span class="line">        <span class="built_in">free</span>(fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        fp-&gt;f_count--;</span><br><span class="line">        pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用散列列表锁来保护结构引用计数，使事情大大简化。结构互斥量可以用于保护 <code>foo</code> 结构中的其他任何东西。</p>
<p>例子，简化的锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NHASH 29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH(id) (((unsigned long)id) % NHASH)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">fh</span>[<span class="title">NHASH</span>];</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> hashlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> f_count; <span class="comment">/* protected by hashlock */</span></span><br><span class="line">	<span class="type">pthread_mutex_t</span> f_lock;</span><br><span class="line">	<span class="type">int</span> f_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">f_next</span>;</span> <span class="comment">/* protected by hashlock */</span></span><br><span class="line">						<span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> foo *<span class="title function_">foo_alloc</span><span class="params">(<span class="type">int</span> id)</span>&#123; <span class="comment">/* allocate the object */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">fp</span>;</span></span><br><span class="line">	<span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((fp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> foo))) != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fp-&gt;f_count = <span class="number">1</span>;</span><br><span class="line">		fp-&gt;f_id = id;</span><br><span class="line">		<span class="keyword">if</span> (pthread_mutex_init(&amp;fp-&gt;f_lock, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">free</span>(fp);</span><br><span class="line">			<span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		idx = HASH(id);</span><br><span class="line">		pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">		fp-&gt;f_next = fh[idx];</span><br><span class="line">		fh[idx] = fp;</span><br><span class="line">		pthread_mutex_lock(&amp;fp-&gt;f_lock);</span><br><span class="line">		pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">		<span class="comment">/* ... continue initialization ... */</span></span><br><span class="line">		pthread_mutex_unlock(&amp;fp-&gt;f_lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo_hold</span><span class="params">(<span class="keyword">struct</span> foo *fp)</span> <span class="comment">/* add a reference to the object */</span></span><br><span class="line">&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">	fp-&gt;f_count++;</span><br><span class="line">	pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> foo *<span class="title function_">foo_find</span><span class="params">(<span class="type">int</span> id)</span> <span class="comment">/* find an existing object */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">	<span class="keyword">for</span> (fp = fh[HASH(id)]; fp != <span class="literal">NULL</span>; fp = fp-&gt;f_next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (fp-&gt;f_id == id)</span><br><span class="line">		&#123;</span><br><span class="line">			fp-&gt;f_count++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">	<span class="keyword">return</span> (fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo_rele</span><span class="params">(<span class="keyword">struct</span> foo *fp)</span> <span class="comment">/* release a reference to the object */</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">tfp</span>;</span></span><br><span class="line">	<span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;hashlock);</span><br><span class="line">	<span class="keyword">if</span> (--fp-&gt;f_count == <span class="number">0</span>)</span><br><span class="line">	&#123; <span class="comment">/* last reference, remove from list */</span></span><br><span class="line">		idx = HASH(fp-&gt;f_id);</span><br><span class="line">		tfp = fh[idx];</span><br><span class="line">		<span class="keyword">if</span> (tfp == fp)</span><br><span class="line">		&#123;</span><br><span class="line">			fh[idx] = fp-&gt;f_next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (tfp-&gt;f_next != fp)</span><br><span class="line">				tfp = tfp-&gt;f_next;</span><br><span class="line">			tfp-&gt;f_next = fp-&gt;f_next;</span><br><span class="line">		&#125;</span><br><span class="line">		pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">		pthread_mutex_destroy(&amp;fp-&gt;f_lock);</span><br><span class="line">		<span class="built_in">free</span>(fp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_unlock(&amp;hashlock);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种用途使用相同的锁时，围绕散列列表和引用计数的锁的排序问题就不存在了。多线程的软件设计涉及这两者之间的折中。如果锁的粒度太粗，就会出现很多线程阻塞等待相同的锁，这可能并不能改善并发性。如果锁的粒度太细，那么过多的锁开销会使系统性能受到影响，而且代码变得复杂。作为一个程序员，需要在满足锁需求的情况下，在代码复杂性和性能之间找到正确的平衡。</p>
<h3 id="函数-pthread-mutex-timedlock"><a href="#函数-pthread-mutex-timedlock" class="headerlink" title="函数 pthread_mutex_timedlock"></a>函数 pthread_mutex_timedlock</h3><p>当线程试图获取一个已加锁的互斥量时，<code>pthread_mutex_timedlock</code> 互斥量原语允许绑定线程阻塞时间。<code>pthread_mutex_timedlock</code> 函数与 <code>pthread_mutex_lock</code> 是基本等价的，但是在达到超时时间值时，<code>pthread_mutex_timedlock</code> 不会对互斥量进行加锁，而是返回错误码 <code>ETIMEDOUT</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_timedlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号</li>
</ul>
<p>超时指定愿意等待的绝对时间。这个超时时间是用 <code>timespec</code> 结构来表示的，它用秒和纳秒来描述时间。</p>
<p>例子，使用 <code>pthread_mutex_timedlock</code> 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tout</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tmp</span>;</span></span><br><span class="line">	<span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">	<span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;lock);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mutex is locked.\n&quot;</span>);</span><br><span class="line">	clock_gettime(CLOCK_REALTIME, &amp;tout);</span><br><span class="line">	tmp = localtime(&amp;tout.tv_sec);</span><br><span class="line">	strftime(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%r&quot;</span>, tmp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;current time is %s.\n&quot;</span>, buf);</span><br><span class="line">	tout.tv_sec += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	err = pthread_mutex_timedlock(&amp;lock, &amp;tout);</span><br><span class="line"></span><br><span class="line">	clock_gettime(CLOCK_REALTIME, &amp;tout);</span><br><span class="line">	tmp = localtime(&amp;tout.tv_sec);</span><br><span class="line">	strftime(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%r&quot;</span>, tmp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the time is now %s.\n&quot;</span>, buf);</span><br><span class="line">	<span class="keyword">if</span>(err == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;mutex locked again!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t lock mutex again: %s.\n&quot;</span>, strerror(err));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc 05pthread_mutex_timedlock.c -lpthread</span><br><span class="line">$ ./a.out</span><br><span class="line">mutex is locked</span><br><span class="line">current time is 09:44:09 AM</span><br><span class="line">the time is now 09:44:19 AM</span><br><span class="line">can<span class="string">&#x27;t lock mutex again: Connection timed out</span></span><br></pre></td></tr></table></figure>

<p>这个程序故意对它已有的互斥量进行加锁，目的是演示 <code>pthread_mutex_timedlock</code> 是如何工作的。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁（reader-writer lock）与互斥量类似，不过读写锁允许更高的并行性。互斥量要么是锁住状态，要么就是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁可以有 3 种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。</p>
<p>当读写锁是写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞。当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对此锁进行加锁的线程都会阻塞，直到所有的线程释放它们的读锁为止。虽然各操作系统对读写锁的实现各不相同，但当读写锁处于读模式锁住的状态，而这时有一个线程试图以写模式获取锁时，读写锁通常会阻塞随后的读模式锁请求。这样可以避免读模式锁长期占用，而等待的写模式锁请求一直得不到满足。</p>
<p>读写锁非常适合于对数据结构读的次数远大于写的情况。</p>
<p>读写锁也叫做共享互斥锁（shared-exclusivelock）。当读写锁是读模式锁住时，就可以说成是以共享模式锁住的。当它是写模式锁住的时候，就可以说成是以互斥模式锁住的。</p>
<p>与互斥量相比，读写锁在使用之前必须初始化，在释放它们底层的内存之前必须销毁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure>

<p>两个函数的返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号。</li>
</ul>
<p>读写锁通过调用 <code>pthread_rwlock_init</code> 进行初始化。如果希望读写锁有默认的属性，可以传一个 <code>NULL</code> 指针给 <code>attr</code> 。</p>
<p>Single UNIX Specification 在 XSI 扩展中定义了 <code>PTHREAD_RWLOCK_INITIALIZER</code> 常量。如果默认属性就足够的话，可以用它对静态分配的读写锁进行初始化。</p>
<p>在释放读写锁占用的内存之前，需要调用 <code>pthread_rwlock_destroy</code> 做清理工作。如果 <code>pthread_rwlock_init</code> 为读写锁分配了资源，<code>pthread_rwlock_destroy</code> 将释放这些资源。如果在调用 <code>pthread_rwlock_destroy</code> 之前就释放了读写锁占用的内存空间，那么分配给这个锁的资源就会丢失。</p>
<p>要在读模式下锁定读写锁，需要调用 <code>pthread_rwlock_rdlock</code>。要在写模式下锁定读写锁，需要调用 <code>pthread_rwlock_wrlock</code>。不管以何种方式锁住读写锁，都可以调用 <code>pthread_rwlock_unlock</code> 进行解锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure>

<p>所有函数的返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号</li>
</ul>
<p>各种实现可能会对共享模式下可获取的读写锁的次数进行限制，所以需要检查 <code>pthread_rwlock_rdlock</code> 的返回值。错误返回值的定义只是针对不正确使用读写锁的情况（如未经初始化的锁），或者试图获取已拥有的锁从而可能产生死锁的情况。但是需要注意，有些特定的实现可能会定义另外的错误返回。</p>
<p>Single UNIX Specification 还定义了读写锁原语的条件版本。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure>

<p>两个函数的返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号。</li>
</ul>
<p>可以获取锁时，这两个函数返回 0。否则，它们返回错误 <code>EBUSY</code>。</p>
<p>例子，使用读写锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> *<span class="title">j_next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> *<span class="title">j_prev</span>;</span></span><br><span class="line">    <span class="type">pthread_t</span> j_id; <span class="comment">/* tells which thread handles this job */</span></span><br><span class="line">                    <span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> *<span class="title">q_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> *<span class="title">q_tail</span>;</span></span><br><span class="line">    <span class="type">pthread_rwlock_t</span> q_lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initialize a queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">queue_init</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    qp-&gt;q_head = <span class="literal">NULL</span>;</span><br><span class="line">    qp-&gt;q_tail = <span class="literal">NULL</span>;</span><br><span class="line">    err = pthread_rwlock_init(&amp;qp-&gt;q_lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (err);</span><br><span class="line">    <span class="comment">/* ... continue initialization ... */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Insert a job at the head of the queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">job_insert</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp, <span class="keyword">struct</span> job *jp)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;qp-&gt;q_lock);</span><br><span class="line">    jp-&gt;j_next = qp-&gt;q_head;</span><br><span class="line">    jp-&gt;j_prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (qp-&gt;q_head != <span class="literal">NULL</span>)</span><br><span class="line">        qp-&gt;q_head-&gt;j_prev = jp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        qp-&gt;q_tail = jp; <span class="comment">/* list was empty */</span></span><br><span class="line">    qp-&gt;q_head = jp;</span><br><span class="line">    pthread_rwlock_unlock(&amp;qp-&gt;q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Append a job on the tail of the queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">job_append</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp, <span class="keyword">struct</span> job *jp)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;qp-&gt;q_lock);</span><br><span class="line">    jp-&gt;j_next = <span class="literal">NULL</span>;</span><br><span class="line">    jp-&gt;j_prev = qp-&gt;q_tail;</span><br><span class="line">    <span class="keyword">if</span> (qp-&gt;q_tail != <span class="literal">NULL</span>)</span><br><span class="line">        qp-&gt;q_tail-&gt;j_next = jp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        qp-&gt;q_head = jp; <span class="comment">/* list was empty */</span></span><br><span class="line">    qp-&gt;q_tail = jp;</span><br><span class="line">    pthread_rwlock_unlock(&amp;qp-&gt;q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Remove the given job from a queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">job_remove</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp, <span class="keyword">struct</span> job *jp)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;qp-&gt;q_lock);</span><br><span class="line">    <span class="keyword">if</span> (jp == qp-&gt;q_head)</span><br><span class="line">    &#123;</span><br><span class="line">        qp-&gt;q_head = jp-&gt;j_next;</span><br><span class="line">        <span class="keyword">if</span> (qp-&gt;q_tail == jp)</span><br><span class="line">            qp-&gt;q_tail = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            jp-&gt;j_next-&gt;j_prev = jp-&gt;j_prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (jp == qp-&gt;q_tail)</span><br><span class="line">    &#123;</span><br><span class="line">        qp-&gt;q_tail = jp-&gt;j_prev;</span><br><span class="line">        jp-&gt;j_prev-&gt;j_next = jp-&gt;j_next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        jp-&gt;j_prev-&gt;j_next = jp-&gt;j_next;</span><br><span class="line">        jp-&gt;j_next-&gt;j_prev = jp-&gt;j_prev;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_unlock(&amp;qp-&gt;q_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find a job for the given thread ID.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> job *<span class="title function_">job_find</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">queue</span> *qp, <span class="type">pthread_t</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> *<span class="title">jp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_rwlock_rdlock(&amp;qp-&gt;q_lock) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (jp = qp-&gt;q_head; jp != <span class="literal">NULL</span>; jp = jp-&gt;j_next)</span><br><span class="line">        <span class="keyword">if</span> (pthread_equal(jp-&gt;j_id, id))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_unlock(&amp;qp-&gt;q_lock);</span><br><span class="line">    <span class="keyword">return</span> (jp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，凡是需要向队列中增加作业或者从队列中删除作业的时候，都采用了写模式来锁住队列的读写锁。不管何时搜索队列，都需要获取读模式下的锁，允许所有的工作线程并发地搜索队列。在这种情况下，只有在线程搜索作业的频率远远高于增加或删除作业时，使用读写锁才可能改善性能。</p>
<h3 id="带有超时的读写锁"><a href="#带有超时的读写锁" class="headerlink" title="带有超时的读写锁"></a>带有超时的读写锁</h3><p>与互斥量一样，Single UNIX Specification 提供了带有超时的读写锁加锁函数，使应用程序在获取读写锁时避免陷入永久阻塞状态。这两个函数是 <code>pthread_rwlock_timedrdlock</code> 和 <code>pthread_rwlock_timedwrlock</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_timedrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_timedwrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span>;</span><br></pre></td></tr></table></figure>

<p>两个函数的返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号。</li>
</ul>
<p>这两个函数的行为与它们“不计时的”版本类似。<code>tsptr</code> 参数指向 <code>timespec</code> 结构，指定线程应该停止阻塞的时间。如果它们不能获取锁，那么超时到期时，这两个函数将返回 <code>ETIMEDOUT</code> 错误。与 <code>pthread_mutex_timedlock</code> 函数类似，超时指定的是绝对时间，而不是相对时间。</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。</p>
<p>条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种改变，因为互斥量必须在锁定以后才能计算条件。</p>
<p>在使用条件变量之前，必须先对它进行初始化。由 <code>pthread_cond_t</code> 数据类型表示的条件变量可以用两种方式进行初始化，可以把常量 <code>PTHREAD_COND_INITIALIZER</code> 赋给静态分配的条件变量，但是如果条件变量是动态分配的，则需要使用 <code>pthread_cond_init</code> 函数对它进行初始化。</p>
<p>在释放条件变量底层的内存空间之前，可以使用 <code>pthread_cond_destroy</code> 函数对条件变量进行反初始化（deinitialize）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure>

<p>两个函数的返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号。</li>
</ul>
<p>创建一个具有默认属性的条件变量，<code>pthread_cond_init</code> 函数的 <code>attr</code> 参数可以设置为 <code>NULL</code>。</p>
<p>我们使用 <code>pthread_cond_wait</code> 等待条件变量变为真。如果在给定的时间内条件不能满足，那么会生成一个返回错误码的变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">                    <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">                        <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> tsptr)</span>;</span><br></pre></td></tr></table></figure>

<p>两个函数的返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号。</li>
</ul>
<p>传递给 <code>pthread_cond_wait</code> 的互斥量对条件进行保护。调用者把锁住的互斥量传给函数，函数然后自动把调用线程放到等待条件的线程列表上，对互斥量解锁。这就关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道，这样线程就不会错过条件的任何变化。<code>pthread_cond_wait</code> 返回时，互斥量再次被锁住。</p>
<p><code>pthread_cond_timedwait</code> 函数的功能与 <code>pthread_cond_wait</code> 函数相似，只是多了一个超时，这个时间值是一个绝对数而不是相对数。</p>
<p>如果超时到期时条件还是没有出现，<code>pthread_cond_timewait</code> 将重新获取互斥量，然后返回错误 <code>ETIMEDOUT</code>。从 <code>pthread_cond_wait</code> 或者 <code>pthread_cond_timedwait</code> 调用成功返回时，线程需要重新计算条件，因为另一个线程可能已经在运行并改变了条件。</p>
<p>有两个函数可以用于通知线程条件已经满足。<code>pthread_cond_signal</code> 函数至少能唤醒一个等待该条件的线程，而 <code>pthread_cond_broadcast</code> 函数则能唤醒等待该条件的所有线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure>

<p>两个函数的返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号。</li>
</ul>
<p>在调用 <code>pthread_cond_signal</code> 或者 <code>pthread_cond_broadcast</code> 时，我们说这是在给线程或者条件发信号。必须注意，一定要在改变条件状态以后再给线程发信号。</p>
<p>例子，使用条件变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">m_next</span>;</span></span><br><span class="line">    <span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">workq</span>;</span></span><br><span class="line"><span class="comment">// 条件是工作队列的状态。</span></span><br><span class="line"><span class="type">pthread_cond_t</span> qready = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="comment">// 互斥量保护条件</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> qlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">process_msg</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;qlock);</span><br><span class="line">        <span class="comment">// 在 while 循环中判断条件。</span></span><br><span class="line">        <span class="keyword">while</span> (workq == <span class="literal">NULL</span>)</span><br><span class="line">            pthread_cond_wait(&amp;qready, &amp;qlock);</span><br><span class="line">        mp = workq;</span><br><span class="line">        workq = mp-&gt;m_next;</span><br><span class="line">        pthread_mutex_unlock(&amp;qlock);</span><br><span class="line">        <span class="comment">/* now process the message mp */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue_msg</span><span class="params">(<span class="keyword">struct</span> msg *mp)</span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;qlock);</span><br><span class="line">    mp-&gt;m_next = workq;</span><br><span class="line">    workq = mp;</span><br><span class="line">    pthread_mutex_unlock(&amp;qlock);</span><br><span class="line">    pthread_cond_signal(&amp;qready);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁与互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。自旋锁可用于以下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多的成本。</p>
<p>自旋锁通常作为底层原语用于实现其他类型的锁。根据它们所基于的系统体系结构，可以通过使用测试并设置指令有效地实现。当然这里说的有效也还是会导致 CPU 资源的浪费：当线程自旋等待锁变为可用时，CPU 不能做其他的事情。这也是自旋锁只能够被持有一小段时间的原因。</p>
<p>当自旋锁用在非抢占式内核中时是非常有用的：除了提供互斥机制以外，它们会阻塞中断，这样中断处理程序就不会让系统陷入死锁状态，因为它需要获取已被加锁的自旋锁（把中断想成是另一种抢占）。在这种类型的内核中，中断处理程序不能休眠，因此它们能用的同步原语只能是自旋锁。</p>
<p>自旋锁的接口与互斥量的接口类似，这使得它可以比较容易地从一个替换为另一个。可以用 <code>pthread_spin_init</code> 函数对自旋锁进行初始化。用 <code>pthread_spin_destroy</code> 函数进行自旋锁的反初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_init</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock, <span class="type">int</span> pshared)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_destroy</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure>

<p>两个函数的返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号。</li>
</ul>
<p>只有一个属性是自旋锁特有的，这个属性只在支持线程进程共享同步（Thread Process-Shared Synchronization）选项的平台上才用得到。<code>pshared</code> 参数表示进程共享属性，表明自旋锁是如何获取的。如果它设为 <code>PTHREAD_PROCESS_SHARED</code>，则自旋锁能被可以访问锁底层内存的线程所获取，即便那些线程属于不同的进程，情况也是如此。否则 <code>pshared</code> 参数设为 <code>PTHREAD_PROCESS_PRIVATE</code>，自旋锁就只能被初始化该锁的进程内部的线程所访问。</p>
<p>可以用 <code>pthread_spin_lock</code> 或 <code>pthread_spin_trylock</code> 对自旋锁进行加锁，前者在获取锁之前一直自旋，后者如果不能获取锁，就立即返回 <code>EBUSY</code> 错误。注意，<code>pthread_spin_trylock</code> 不能自旋。不管以何种方式加锁，自旋锁都可以调用 <code>pthread_spin_unlock</code> 函数解锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_lock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_trylock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_spin_unlock</span><span class="params">(<span class="type">pthread_spinlock_t</span> *lock)</span>;</span><br></pre></td></tr></table></figure>

<p>所有函数的返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号。</li>
</ul>
<p>注意，如果自旋锁当前在解锁状态的话，<code>pthread_spin_lock</code> 函数不要自旋就可以对它加锁。如果线程已经对它加锁了，结果就是未定义的。调用 <code>pthread_spin_lock</code> 会返回 <code>EDEADLK</code> 错误（或其他错误），或者调用可能会永久自旋。具体行为依赖于实际的实现。试图对没有加锁的自旋锁进行解锁，结果也是未定义的。</p>
<p>不管是 <code>pthread_spin_lock</code> 还是 <code>pthread_spin_trylock</code>，返回值为 0 的话就表示自旋锁被加锁。需要注意，不要调用在持有自旋锁情况下可能会进入休眠状态的函数。如果调用了这些函数，会浪费 CPU 资源，因为其他线程需要获取自旋锁需要等待的时间就延长了</p>
<h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>屏障（barrier）是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。我们已经看到一种屏障，<code>pthread_join</code> 函数就是一种屏障，允许一个线程等待，直到另一个线程退出。</p>
<p>但是屏障对象的概念更广，它们允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出。所有线程达到屏障后可以接着工作。</p>
<p>可以使用 <code>pthread_barrier_init</code> 函数对屏障进行初始化，用 <code>thread_barrier_destroy</code> 函数反初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrier_init</span><span class="params">(<span class="type">pthread_barrier_t</span> *<span class="keyword">restrict</span> barrier,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">pthread_barrierattr_t</span> *<span class="keyword">restrict</span> attr, <span class="type">unsigned</span> <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrier_destroy</span><span class="params">(<span class="type">pthread_barrier_t</span> *barrier)</span>;</span><br></pre></td></tr></table></figure>

<p>两个函数的返回值：</p>
<ul>
<li>若成功，返回 0；</li>
<li>否则，返回错误编号。</li>
</ul>
<p>初始化屏障时，可以使用 <code>count</code> 参数指定，在允许所有线程继续运行之前，必须到达屏障的线程数目。使用 <code>attr</code> 参数指定屏障对象的属性，设置 <code>attr</code> 为 <code>NULL</code>，用默认属性初始化屏障。如果使用 <code>pthread_barrier_init</code> 函数为屏障分配资源，那么在反初始化屏障时可以调用 <code>pthread_barrier_destroy</code> 函数释放相应的资源。</p>
<p>可以使用 <code>pthread_barrier_wait</code> 函数来表明，线程已完成工作，准备等所有其他线程赶上来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_barrier_wait</span><span class="params">(<span class="type">pthread_barrier_t</span> *barrier)</span>;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<ul>
<li>若成功，返回 0 或者 <code>PTHREAD_BARRIER_SERIAL_THREAD</code>；</li>
<li>否则，返回错误编号。</li>
</ul>
<p>调用 <code>pthread_barrier_wait</code> 的线程在屏障计数未满足条件时，会进入休眠状态。如果该线程是最后一个调用 <code>pthread_barrier_wait</code> 的线程，就满足了屏障计数，所有的线程都被唤醒。</p>
<p>对于一个任意线程，<code>pthread_barrier_wait</code> 函数返回了 <code>PTHREAD_BARRIER_SERIAL_THREAD</code>。剩下的线程看到的返回值是 0。这使得一个线程可以作为主线程，它可以工作在其他所有线程已完成的工作结果上。</p>
<p>一旦达到屏障计数值，而且线程处于非阻塞状态，屏障就可以被重用。但是除非在调用了 <code>pthread_barrier_destroy</code> 函数之后，又调用了 <code>pthread_barrier_init</code> 函数对计数用另外的数进行初始化，否则屏障计数不会改变。</p>
<p>例子，使用屏障。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTHR 8			<span class="comment">// 线程数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUMNUM 8000000L	<span class="comment">// 需要排序的数据数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TNUM (NUMNUM / NTHR)</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> random_nums[NUMNUM];</span><br><span class="line"><span class="type">long</span> sorted_nums[NUMNUM];</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_barrier_t</span> b;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">complong</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *arg1, <span class="type">const</span> <span class="type">void</span> *arg2)</span>&#123;</span><br><span class="line">	<span class="type">long</span> l1 = *(<span class="type">long</span> *)arg1;</span><br><span class="line">	<span class="type">long</span> l2 = *(<span class="type">long</span> *)arg2;</span><br><span class="line">	<span class="keyword">if</span>(l1 == l2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(l1 &lt; l2)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thr_fn</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">	<span class="type">long</span> idx = (<span class="type">long</span>)arg;</span><br><span class="line">	qsort(&amp;random_nums[idx], TNUM, <span class="keyword">sizeof</span>(<span class="type">long</span>), complong);</span><br><span class="line">	pthread_barrier_wait(&amp;b);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">long</span> idx[NTHR];</span><br><span class="line">	<span class="type">long</span> i, minidx, sidx, num;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NTHR; i++)</span><br><span class="line">		idx[i] = i * TNUM;</span><br><span class="line">	<span class="keyword">for</span>(sidx = <span class="number">0</span>; sidx &lt; NUMNUM; sidx++)&#123;</span><br><span class="line">		num = LONG_MAX;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NTHR; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>((idx[i] &lt; ((i+<span class="number">1</span>) * TNUM)) &amp;&amp; (random_nums[idx[i]] &lt; num))&#123;</span><br><span class="line">				num = random_nums[idx[i]];</span><br><span class="line">				minidx = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sorted_nums[sidx] = random_nums[idx[minidx]];</span><br><span class="line">		idx[minidx]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> startusec, endusec;</span><br><span class="line">	<span class="type">double</span> elapsed;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">	srandom(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMNUM; i++)</span><br><span class="line">		random_nums[i] = random();</span><br><span class="line">	gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_barrier_init(&amp;b, <span class="literal">NULL</span>, NTHR + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NTHR; i++)&#123;</span><br><span class="line">		<span class="comment">// 使用8个线程分解了800万个数的排序工作。每个线程用堆排序算法对100万个数进行排序</span></span><br><span class="line">		err = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_fn, (<span class="type">void</span> *)(i * TNUM));</span><br><span class="line">		<span class="keyword">if</span>(err != <span class="number">0</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot; can&#x27;t create thread&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_barrier_wait(&amp;b);</span><br><span class="line">	<span class="comment">// 主线程调用一个函数对这些结果进行合并。</span></span><br><span class="line">	merge();</span><br><span class="line">	gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	startusec = start.tv_sec * <span class="number">1000000</span> + start.tv_usec;</span><br><span class="line">	endusec = end.tv_sec * <span class="number">1000000</span> + end.tv_usec;</span><br><span class="line">	elapsed = (<span class="type">double</span>)(endusec - startusec) / <span class="number">1000000.0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d thread sort took %.4f seconds\n&quot;</span>, NTHR, elapsed);</span><br><span class="line">	<span class="comment">// for (i = 0; i &lt; NUMNUM; i++)</span></span><br><span class="line">	<span class="comment">// 	printf(&quot;%ld\n&quot;, sorted_nums[i]);</span></span><br><span class="line"></span><br><span class="line">	gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主线程调用 qsort 进行排序</span></span><br><span class="line">	qsort(&amp;random_nums, NUMNUM, <span class="keyword">sizeof</span>(<span class="type">long</span>), complong);</span><br><span class="line"></span><br><span class="line">	gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">	startusec = start.tv_sec * <span class="number">1000000</span> + start.tv_usec;</span><br><span class="line">	endusec = end.tv_sec * <span class="number">1000000</span> + end.tv_usec;</span><br><span class="line">	elapsed = (<span class="type">double</span>)(endusec - startusec) / <span class="number">1000000.0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1 thread sort took %.4f seconds\n&quot;</span>, elapsed);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> gcc 06pthread_barrier.c -lpthread</span><br><span class="line"> ./a.out</span><br><span class="line">8 thread <span class="built_in">sort</span> took 0.6863 seconds</span><br><span class="line">1 thread <span class="built_in">sort</span> took 0.5769 seconds</span><br></pre></td></tr></table></figure>

<p>在这个实例中，使用 8 个线程分解了 800 万个数的排序工作。每个线程用堆排序算法对 100 万个数进行排序。然后主线程调用一个函数对这些结果进行合并。根据运行结果，可以发现使用一个线程进行排序的速度反而更快，多线程并不一定会加快运行速度，还是要根据实际情况使用。</p>
<p>并不需要使用 <code>pthread_barrier_wait</code> 函数中的返回值 <code>PTHREAD_BARRIER_SERIAL_THREAD</code> 来决定哪个线程执行结果合并操作，因为我们使用了主线程来完成这个任务。这也是把屏障计数值设为工作线程数加 1 的原因，主线程也作为其中的一个候选线程。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux-%E7%BC%96%E7%A8%8B/" rel="tag"># linux 编程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/04/10/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B10-%E4%BF%A1%E5%8F%B7/" rel="prev" title="unix环境高级编程10-信号">
                  <i class="fa fa-chevron-left"></i> unix环境高级编程10-信号
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/04/10/unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B12-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/" rel="next" title="unix环境高级编程12-线程控制">
                  unix环境高级编程12-线程控制 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CKCat</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/CKCat" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
