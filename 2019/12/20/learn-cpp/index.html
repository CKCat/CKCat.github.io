<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/https:/github.com/ckcat.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://github.com/ckcat.png?size=32">
  <link rel="icon" type="image/png" sizes="16x16" href="https://github.com/ckcat.png?size=16">
  <link rel="mask-icon" href="https://github.com/ckcat.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ckcat.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="基础const、引用和函数默认参数的使用及注意事项 const 的作用 取代无参宏，增加类型检查功能。 对指针类型做一些限定。    const 主要是语法层面的限定，实际上可以通过内存修改 const 变量。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#define P">
<meta property="og:type" content="article">
<meta property="og:title" content="learn-cpp">
<meta property="og:url" content="https://ckcat.github.io/2019/12/20/learn-cpp/index.html">
<meta property="og:site_name" content="CKCat的博客">
<meta property="og:description" content="基础const、引用和函数默认参数的使用及注意事项 const 的作用 取代无参宏，增加类型检查功能。 对指针类型做一些限定。    const 主要是语法层面的限定，实际上可以通过内存修改 const 变量。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#define P">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-12-20T16:19:10.000Z">
<meta property="article:modified_time" content="2024-06-21T09:51:57.416Z">
<meta property="article:author" content="CKCat">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ckcat.github.io/2019/12/20/learn-cpp/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ckcat.github.io/2019/12/20/learn-cpp/","path":"2019/12/20/learn-cpp/","title":"learn-cpp"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>learn-cpp | CKCat的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">CKCat的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-gena-nav"><a href="https://ckcat.github.io/CKCat-gena-nav/" rel="section"><i class="fa fa-navicon fa-fw"></i>gena-nav</a></li><li class="menu-item menu-item-aibard"><a href="https://aibard123.com/?github" rel="section" target="_blank"><i class="fa fa-eye fa-fw"></i>aibard</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#const%E3%80%81%E5%BC%95%E7%94%A8%E5%92%8C%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.1.</span> <span class="nav-text">const、引用和函数默认参数的使用及注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94-inline"><span class="nav-number">1.2.1.</span> <span class="nav-text">内联 inline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">1.2.2.</span> <span class="nav-text">函数重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="nav-number">1.2.3.</span> <span class="nav-text">构造和析构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-%E5%92%8C-const"><span class="nav-number">1.3.</span> <span class="nav-text">static 和 const</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#namespace"><span class="nav-number">1.3.1.</span> <span class="nav-text">namespace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-number">1.3.2.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cosnt"><span class="nav-number">1.3.3.</span> <span class="nav-text">cosnt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#friend"><span class="nav-number">1.3.4.</span> <span class="nav-text">friend</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.3.5.</span> <span class="nav-text">运算符重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text">继承和虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">继承的基本知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">1.4.2.</span> <span class="nav-text">成员函数指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.</span> <span class="nav-text">虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E3%80%81%E9%9A%90%E8%97%8F%E5%92%8C%E8%A6%86%E7%9B%96"><span class="nav-number">1.5.1.</span> <span class="nav-text">重载、隐藏和覆盖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-number">1.5.2.</span> <span class="nav-text">虚函数表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E8%A1%A8%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.5.3.</span> <span class="nav-text">虚表函数的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.4.</span> <span class="nav-text">纯虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-number">1.5.5.</span> <span class="nav-text">普通多重继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">1.5.6.</span> <span class="nav-text">虚继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">1.6.</span> <span class="nav-text">异常</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c-11-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">c++11 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#auto-amp-decltype"><span class="nav-number">2.1.</span> <span class="nav-text">auto &amp; decltype</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC"><span class="nav-number">2.2.</span> <span class="nav-text">左值右值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.3.</span> <span class="nav-text">列表初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-function-amp-std-bind-amp-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.4.</span> <span class="nav-text">std::function &amp; std::bind &amp; lambda 表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="nav-number">2.5.</span> <span class="nav-text">模板的改进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">2.6.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">2.7.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84-for-%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.8.</span> <span class="nav-text">基于范围的 for 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.9.</span> <span class="nav-text">委托构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.10.</span> <span class="nav-text">继承构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nullptr"><span class="nav-number">2.11.</span> <span class="nav-text">nullptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-amp-override"><span class="nav-number">2.12.</span> <span class="nav-text">final &amp; override</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#default"><span class="nav-number">2.13.</span> <span class="nav-text">default</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#delete"><span class="nav-number">2.14.</span> <span class="nav-text">delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#explicit"><span class="nav-number">2.15.</span> <span class="nav-text">explicit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const"><span class="nav-number">2.16.</span> <span class="nav-text">const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constexpr"><span class="nav-number">2.17.</span> <span class="nav-text">constexpr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#enum-class"><span class="nav-number">2.18.</span> <span class="nav-text">enum class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93"><span class="nav-number">2.19.</span> <span class="nav-text">非受限联合体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sizeof"><span class="nav-number">2.20.</span> <span class="nav-text">sizeof</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#assertion"><span class="nav-number">2.21.</span> <span class="nav-text">assertion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">2.22.</span> <span class="nav-text">自定义字面量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="nav-number">2.23.</span> <span class="nav-text">内存对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#thread-local"><span class="nav-number">2.24.</span> <span class="nav-text">thread_local</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.25.</span> <span class="nav-text">基础数值类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%8A%9F%E8%83%BD"><span class="nav-number">2.26.</span> <span class="nav-text">随机数功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.27.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chrono"><span class="nav-number">2.28.</span> <span class="nav-text">chrono</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.29.</span> <span class="nav-text">新增数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E7%AE%97%E6%B3%95"><span class="nav-number">2.30.</span> <span class="nav-text">新增算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-14-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">C++14 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="nav-number">3.1.</span> <span class="nav-text">函数返回值类型推导</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda-%E5%8F%82%E6%95%B0-auto"><span class="nav-number">3.2.</span> <span class="nav-text">lambda 参数 auto</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF"><span class="nav-number">3.3.</span> <span class="nav-text">变量模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%AB%E5%90%8D%E6%A8%A1%E6%9D%BF"><span class="nav-number">3.4.</span> <span class="nav-text">别名模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deprecated-%E6%A0%87%E8%AE%B0"><span class="nav-number">3.5.</span> <span class="nav-text">[[deprecated]]标记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%8E%E6%95%B4%E5%BD%A2%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%86%E9%9A%94%E7%AC%A6"><span class="nav-number">3.6.</span> <span class="nav-text">二进制字面量与整形字面量分隔符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E4%B8%8B%E5%88%97%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">3.7.</span> <span class="nav-text">新增下列标准函数：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-17-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">C++17 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A8%E5%AF%BC"><span class="nav-number">4.1.</span> <span class="nav-text">构造函数模板推导</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A"><span class="nav-number">4.2.</span> <span class="nav-text">结构化绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#if-switch-%E8%AF%AD%E5%8F%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.3.</span> <span class="nav-text">if-switch 语句初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F"><span class="nav-number">4.4.</span> <span class="nav-text">内联变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.5.</span> <span class="nav-text">折叠表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constexpr-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.6.</span> <span class="nav-text">constexpr lambda 表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#namespace-%E5%B5%8C%E5%A5%97"><span class="nav-number">4.7.</span> <span class="nav-text">namespace 嵌套</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#has-include-%E9%A2%84%E5%A4%84%E7%90%86%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.8.</span> <span class="nav-text">__has_include 预处理表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8-this-%E6%8D%95%E8%8E%B7%E5%AF%B9%E8%B1%A1%E5%89%AF%E6%9C%AC"><span class="nav-number">4.9.</span> <span class="nav-text">在 lambda 表达式用 *this 捕获对象副本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E-Attribute"><span class="nav-number">4.10.</span> <span class="nav-text">新增 Attribute</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E4%B8%8B%E5%88%97%E6%A0%87%E5%87%86"><span class="nav-number">4.11.</span> <span class="nav-text">新增下列标准</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">5.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%90%8D%E7%A7%B0%E7%B2%89%E7%A2%8E%E4%BD%BF%E7%94%A8-C-filt-%E5%B7%A5%E5%85%B7%E6%81%A2%E5%A4%8D"><span class="nav-number">5.1.</span> <span class="nav-text">C++ 名称粉碎使用 C++filt 工具恢复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E7%BC%96%E8%AF%91%E5%B9%B3%E5%8F%B0%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">5.2.</span> <span class="nav-text">判断编译平台宏定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#error-C2027-use-of-undefined-type"><span class="nav-number">5.3.</span> <span class="nav-text">error C2027: use of undefined type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jupyter-notebook-for-C"><span class="nav-number">5.4.</span> <span class="nav-text">jupyter notebook for C++</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CKCat</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/CKCat" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;CKCat" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ckcatck@qq.com" title="E-Mail → mailto:ckcatck@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ckcat.github.io/2019/12/20/learn-cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CKCat">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CKCat的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="learn-cpp | CKCat的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          learn-cpp
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-20 16:19:10" itemprop="dateCreated datePublished" datetime="2019-12-20T16:19:10+00:00">2019-12-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-06-21 09:51:57" itemprop="dateModified" datetime="2024-06-21T09:51:57+00:00">2024-06-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="const、引用和函数默认参数的使用及注意事项"><a href="#const、引用和函数默认参数的使用及注意事项" class="headerlink" title="const、引用和函数默认参数的使用及注意事项"></a><code>const</code>、引用和函数默认参数的使用及注意事项</h2><ol>
<li><code>const</code> 的作用<ul>
<li>取代无参宏，增加类型检查功能。</li>
<li>对指针类型做一些限定。</li>
</ul>
</li>
</ol>
<p><code>const</code> 主要是语法层面的限定，实际上可以通过内存修改 <code>const</code> 变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PI: %f\r\n&quot;</span>, PI);   <span class="comment">// 3.140000</span></span><br><span class="line">    <span class="comment">// const 取代无参宏，方便调试，增加类型检查。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> CPI = <span class="number">3.14f</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPI: %f\r\n&quot;</span>, CPI);  <span class="comment">// 3.140000</span></span><br><span class="line">    *(<span class="type">float</span>*)&amp;CPI = <span class="number">2.14f</span>;</span><br><span class="line">    <span class="comment">// 编译中直接替换为常量了，所以修改了CPI的值输出也是3.140000。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPI: %f\r\n&quot;</span>, CPI);  <span class="comment">// 3.140000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 指针</span></span><br><span class="line">    <span class="comment">// const 在 * 前面，则指针指向的内容无法修改。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pbuffer = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    pbuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// pbuffer[0] = &#x27;H&#x27;;  这条语句会出错，表达式必须是可修改的左值。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 在 * 后面，则指针变量的值无法修改。</span></span><br><span class="line">    <span class="type">char</span> szBuffer[] = <span class="string">&quot;world&quot;</span>;  <span class="comment">// 等价于  char * const szBuffer = &quot;hello&quot;</span></span><br><span class="line">    <span class="type">char</span>* <span class="type">const</span> cbuffer = szBuffer;</span><br><span class="line">    <span class="comment">// cbuffer = NULL; 表达式必须是可修改的左值。</span></span><br><span class="line">    cbuffer[<span class="number">0</span>] = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 在 * 前后都有，则指向的内容和指针的值都无法修改。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> ccbuffer = szBuffer;</span><br><span class="line">    <span class="comment">// ccbuffer = NULL; 表达式必须是可修改的左值。</span></span><br><span class="line">    <span class="comment">// ccbuffer[0] = &#x27;h&#x27;;表达式必须是可修改的左值。</span></span><br><span class="line">    szBuffer[<span class="number">1</span>] = <span class="string">&#x27;O&#x27;</span>; <span class="comment">// 语法上不可修改，实际上可以通过内存修改</span></span><br><span class="line">    <span class="comment">// printf(&quot;pbuffer: %s\r\n&quot;, pbuffer);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cbuffer: %s\r\n&quot;</span>, cbuffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ccbuffer: %s\r\n&quot;</span>, ccbuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 const 和非 const 指针转换问题如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> TYPE * = TYPE *;    <span class="comment">// 正确</span></span><br><span class="line">TYPE* = <span class="type">const</span> TYPE*;      <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>引用注意事项<ul>
<li>引用必须初始化。</li>
<li>引用不能初始化为常量(存在特例)。</li>
<li>没有二级引用。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_point</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_ref</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 引用必须初始化</span></span><br><span class="line">    <span class="type">int</span>&amp; ref_a = a;</span><br><span class="line">    <span class="type">int</span>&amp; ref_b = b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ref_a = %d, ref_b= %d\r\n&quot;</span>, ref_a, ref_b);</span><br><span class="line">    <span class="built_in">swap_point</span>(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b= %d\r\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ref_a = %d, ref_b= %d\r\n&quot;</span>, ref_a, ref_b);</span><br><span class="line">    <span class="built_in">swap_ref</span>(ref_a, ref_b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b= %d\r\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ref_a = %d, ref_b= %d\r\n&quot;</span>, ref_a, ref_b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int&amp; const_value = 1;   // error C2440: &#x27;initializing&#x27;: cannot convert from &#x27;int&#x27; to &#x27;int &amp;&#x27;</span></span><br><span class="line">    <span class="comment">// int&amp;&amp; n = ref_a;        // error C2440: &#x27;initializing&#x27;: cannot convert from &#x27;int&#x27; to &#x27;int &amp;&amp;&#x27;</span></span><br><span class="line">    <span class="comment">// 下面相当于 int tmp = 2; const int &amp;c_ref = tmp;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; c_ref = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address: %p\r\n&quot;</span>, &amp;c_ref);  <span class="comment">// 这里可以发现输出的为栈地址。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用与指针无本质区别，只是语法上的区别，下列为 IDA 中反汇编后的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov     [ebp+a], 1</span><br><span class="line">mov     [ebp+b], 2</span><br><span class="line">lea     eax, [ebp+a]</span><br><span class="line">mov     [ebp+ref_a], eax</span><br><span class="line">lea     eax, [ebp+b]</span><br><span class="line">mov     [ebp+ref_b], eax</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>默认参数注意事项<ul>
<li>缺省参数只能放在最右边。</li>
<li>声明和实现不能同时定义缺省，只能写一个。</li>
<li>缺省参数通常放在声明文件中。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, sum);</span><br><span class="line">    sum = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol>
<li><code>class</code> 类默认 <code>private</code>；<code>struct</code> 类和 <code>union</code> 类默认公有，其中 <code>union</code> 类内存共享。</li>
<li>不同的对象，数据成员内存地址不一样。</li>
<li>调用成员函数时会隐藏传递 <code>this</code> 指针，默认会用寄存器（ECX）传递。</li>
<li>使用 <code>__stdcall</code> 方式的函数调用时， <code>this</code> 指针直接入栈传递。</li>
<li>类的声明一般定义在头文件中，实现在另外的 cpp 文件中。</li>
</ol>
<h3 id="内联-inline"><a href="#内联-inline" class="headerlink" title="内联 inline"></a>内联 inline</h3><p>在 C++中使用 inline 函数也是直接替换内容，而且有参数类型检查，就解决了宏的类型检查问题，可以在编译期间就避免类型不一致的错误。</p>
<p>内联的一些情况:</p>
<ul>
<li>debug 版不内联。</li>
<li>release 版才会内联，inline 告诉编译器需要内联，编译器会根据函数的复杂度来确定是否直接替换。</li>
<li>直接在类中定义并实现的函数默认内联。</li>
</ul>
<p><strong>类成员函数内联的定义和实现一般都是写在同一个文件中，主要是为了防止重复定义以及避免编译器在链接过程中直接替换函数时找不到函数定义。</strong></p>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CInline.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CInline</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CInline.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CInline.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CInline::add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CInline.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    CInline clinne;</span><br><span class="line">    <span class="type">int</span> sum = clinne.<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就会出现下列错误，将 <code>CInline::add</code> 的实现写到 <code>CInline.h</code> 中就可以编译通过了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error LNK2019: unresolved external symbol <span class="string">&quot;public: int __thiscall CInline::add(int,int)&quot;</span> (?add@CInline@@QAEHHH@Z) referenced <span class="keyword">in</span> <span class="keyword">function</span> _main</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>重载实现编译器期的多态。</p>
<p>重载的定义：函数名相同，参数个数不同 或 参数类型不同 或 参数顺序不同即可构成重载。</p>
<p>注意点：</p>
<ul>
<li>返回值不作参考，即返回值不同也不构成重载。</li>
<li><code>TYPE</code> 和 <code>const TPYE</code> 不构成重载，如 <code>add(int)</code> 和 <code>add(const int)</code> 不构成重载。</li>
<li><code>TYPE*</code> 和 <code>const TPYE*</code> 可以重载，如 <code>add(int*)</code> 和 <code>add(const int*)</code> 构成重载。</li>
<li>引用可以重载，如 <code>add(int)</code> 和 <code>add(int&amp;)</code> 构成重载。</li>
<li><code>typedef</code> 无效，如 <code>typedef int T;</code> <code>add(T)</code> 和 <code>add(int)</code> 不构成重载。</li>
</ul>
<h3 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h3><p>构造函数是一个特殊的成员函数，主要作用是初始化，申请资源；其注意点如下：</p>
<ul>
<li>不能显示调用，即使用者不能调用。</li>
<li>没有返回值。</li>
<li>可以重载。</li>
</ul>
<p>析构函数也是特殊的成员函数，主要作用是释放资源；其注意点如下：</p>
<ul>
<li>可以显示调用。</li>
<li>没有返回值。</li>
<li>不能有参数，所以不能重载。</li>
</ul>
<p>编译器一般会自动为一个类生成六个特殊的成员函数，</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>class C 对应的形式</th>
</tr>
</thead>
<tbody><tr>
<td>默认构造函数</td>
<td>C::C();</td>
</tr>
<tr>
<td>析构函数</td>
<td>C::~C();</td>
</tr>
<tr>
<td>复制构造函数</td>
<td>C::C (const C&amp;);</td>
</tr>
<tr>
<td>复制赋值运算符</td>
<td>C&amp; operator&#x3D; (const C&amp;);</td>
</tr>
<tr>
<td>移动构造函数（C++11）</td>
<td>C::C (C&amp;&amp;);</td>
</tr>
<tr>
<td>移动赋值运算符（C++11）</td>
<td>C&amp; operator&#x3D; (C&amp;&amp;);</td>
</tr>
</tbody></table>
<p>以上六个成员函数如果不用，最好用 <code>delete</code> 标记一下，避免出现非预期结果。</p>
<p>复制构造函数和复制赋值运算符默认情况下直接将对象进行整体复制，如果对象数据成员有指针变量时，就会复制指针变量而不是指针对应的数据，就造成了两个对象中的指针变量指向了同一个地址，与预期的结果是不一样的，还有一个问题就是析构函数会两次释放资源，造成错误。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Copy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Number;</span><br><span class="line">    <span class="type">char</span>* m_pszBuff;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Copy</span>(<span class="type">int</span> number, <span class="type">const</span> <span class="type">char</span>* szbuf = <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(number, szbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Copy</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pszBuff)&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_pszBuff;</span><br><span class="line">            m_pszBuff = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> number, <span class="type">const</span> <span class="type">char</span>* szbuf)</span> </span>&#123;</span><br><span class="line">        m_Number = number;</span><br><span class="line">        <span class="keyword">if</span> (szbuf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_pszBuff = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m_pszBuff = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(szbuf) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(m_pszBuff, szbuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function">Copy <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    Copy p2 = p1;</span><br><span class="line">    <span class="function">Copy <span class="title">p3</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1.m_Number address: %p, p1.m_pszBuff address: %p\r\n&quot;</span>, &amp;p1.m_Number, p1.m_pszBuff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2.m_Number address: %p, p2.m_pszBuff address: %p\r\n&quot;</span>, &amp;p2.m_Number, p2.m_pszBuff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p3.m_Number address: %p, p3.m_pszBuff address: %p\r\n&quot;</span>, &amp;p3.m_Number, p3.m_pszBuff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码运行后可以发现 m_pszBuff 的内存地址为同一个值，然后析构函数会多次释放内存导致错误。</p>
<p>函数参数尽量使用引用作为参数，应为如果使用对象作为参数，将会多执行一次拷贝构造和一次析构，导致性能损失。</p>
<p>一个类的成员包含另一个类的析构和构造函数调用情况：</p>
<ul>
<li>构造顺序：先根据定义的顺序构造成员对象，再构造自己。</li>
<li>析构顺序与析构顺序相反：先析构自己，再根据定义的顺序反向析构成员对象。</li>
</ul>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassA</span>(<span class="type">int</span> count = <span class="number">0</span>)&#123;</span><br><span class="line">        mCount = count;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ClassA() &quot;</span> &lt;&lt; mCount &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ClassA</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~ClassA() &quot;</span> &lt;&lt; mCount &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ClassA d1;</span><br><span class="line">    ClassA d2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassB</span>():<span class="built_in">d1</span>(<span class="number">1</span>), <span class="built_in">d2</span>(<span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ClassB() &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ClassB</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ClassB() &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ClassB b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassA() 1</span><br><span class="line">ClassA() 2</span><br><span class="line">ClassB()</span><br><span class="line">ClassB()</span><br><span class="line">~ClassA() 2</span><br><span class="line">~ClassA() 1</span><br></pre></td></tr></table></figure>

<h2 id="static-和-const"><a href="#static-和-const" class="headerlink" title="static 和 const"></a>static 和 const</h2><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><ul>
<li>命名空间也是为了解决访问权限和命名重复的问题。</li>
<li>当两个命名空间名是一样的就会合并为一个。</li>
<li>命名空间尽量确保唯一性。</li>
<li>可以嵌套使用类名空间，但是尽量不要这样使用。</li>
</ul>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Mystring&#123;</span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *strDestination, <span class="type">const</span> <span class="type">char</span> *strSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g_nCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_nCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> szText[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> g_nCount = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//strcpy(szText, &quot;hello&quot;);          //error，因为不知道用标准库函数还是用Mystring中的函数</span></span><br><span class="line">    Mystring::<span class="built_in">strcpy</span>(szText, <span class="string">&quot;hello&quot;</span>);  <span class="comment">//调用的是Mystring里面的strcpy</span></span><br><span class="line">    Mystring::g_nCount = <span class="number">1</span>;             <span class="comment">//调用的是Mystring里面的strcpy</span></span><br><span class="line">    ::<span class="built_in">strcpy</span>(szText, <span class="string">&quot;hello&quot;</span>);          <span class="comment">//调用的是全局strcpy, ::前面没有命名空间表示全局的</span></span><br><span class="line">    g_nCount = <span class="number">10</span>;                      <span class="comment">//调用的是main函数中的g_nCount</span></span><br><span class="line">    ::g_nCount = <span class="number">20</span>;                    <span class="comment">//调用全局的g_nCount</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol>
<li>静态成员变量</li>
</ol>
<ul>
<li>静态成员变量只限于类里面访问，并且不同的类可以定义相同的变量名，可以避免全局变量的权限范围过大以及命名空间问题。</li>
<li>静态成员变量和普通成员变量的定义方式是一样的，并且不占用对象空间。</li>
<li>静态数据成员使用前必须要先初始化，初始化方式：类名::static 数据成员名 &#x3D; 0;</li>
</ul>
<ol start="2">
<li>静态成员函数</li>
</ol>
<ul>
<li>静态成员函数出现的原因和静态成员函数出现的原因一样，也是因为权限和命名空间的问题。</li>
<li>静态成员函数中不含 this 指针，所以不能访问普通数据成员，只能访问静态数据成员。</li>
<li>调用方式：类名::静态成员函数名 或者 对象.静态成员函数名。</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTestStatic</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mNumber;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> mCount;    <span class="comment">//不占用对象的空间</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CTestStatic</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        mNumber = <span class="number">0</span>;</span><br><span class="line">        mCount++;         <span class="comment">//每个对象修改的都是同一个m_nCount</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CTestStatic() mCount = &quot;</span> &lt;&lt; mCount &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CTestStatic</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~CTestStatic() mCount = &quot;</span> &lt;&lt; mCount&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//因为静态成员函数没有传递this指针，不能访问普通数据成员</span></span><br><span class="line">        <span class="comment">//只能访问静态数据成员</span></span><br><span class="line">        <span class="keyword">return</span> mCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> CTestStatic::mCount = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;CTestStatic size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(CTestStatic) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    CTestStatic t1;</span><br><span class="line">    CTestStatic t2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mCount = &quot;</span> &lt;&lt; t1.<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mCount = &quot;</span> &lt;&lt; t2.<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mCount = &quot;</span> &lt;&lt; CTestStatic::<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cosnt"><a href="#cosnt" class="headerlink" title="cosnt"></a>cosnt</h3><ol>
<li><p>cosnt 数据成员<br>cosnt 数据成员的定义和普通 const 变量的定义是一样的，但是由于在类里面定义数据成员是不支持定义的同时初始化的，只能通过构造函数使用初始化表来初始化。</p>
</li>
<li><p>const 成员函数<br>cosnt 成员函数的使用方法在普通成员函数后面加上 const 即可，本质是改变了 this 指针的属性。主要是为了防止在对象调用成员函数是修改了数据成员，还有就是 const 对象只能调用 const 成员函数，如果没有 const 成员函数，const 对象什么事都干不了。</p>
</li>
</ol>
<h3 id="friend"><a href="#friend" class="headerlink" title="friend"></a>friend</h3><p>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。</p>
<p>在类定义中，使用 <code>friend</code> 关键字和非成员函数或其他类的名称，以允许其访问类的私有和受保护成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Retangle</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Retangle</span>() &#123; width = height = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">Retangle</span>(<span class="type">int</span> x, <span class="type">int</span> y) :<span class="built_in">width</span>(x), <span class="built_in">height</span>(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> width * height; &#125;</span><br><span class="line">    <span class="comment">// 友元函数可以访问 Retangle 私有和受保护的成员。</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Retangle <span class="title">duplicate</span><span class="params">(<span class="type">const</span> Retangle&amp; param)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">convert</span><span class="params">(Square a)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Test&amp; t)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="comment">// 友元类，其成员可以访问 Square 的私有或受保护成员。</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Retangle</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> side;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Square</span>(<span class="type">int</span> a) :<span class="built_in">side</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 友元类成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Retangle::fun</span><span class="params">(Test&amp; t)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Retangle <span class="title">duplicate</span><span class="params">(<span class="type">const</span> Retangle&amp; param)</span> </span>&#123;</span><br><span class="line">    Retangle res;</span><br><span class="line">    res.width = param.width;</span><br><span class="line">    res.height = param.height;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Retangle::convert</span><span class="params">(Square a)</span> </span>&#123;</span><br><span class="line">    width = a.side;</span><br><span class="line">    height = a.side;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Retangle::fun</span><span class="params">(Test&amp; t)</span> </span>&#123;</span><br><span class="line">    t.t = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  Rectangle rect;</span><br><span class="line">  <span class="function">Square <span class="title">sqr</span> <span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">  rect.<span class="built_in">convert</span>(sqr);</span><br><span class="line">  cout &lt;&lt; rect.<span class="built_in">area</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友元一般用作设计，因为友元后能访问私有成员，破坏封装性，不推荐使用。</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>操作符</th>
<th>成员函数</th>
<th>非成员函数</th>
</tr>
</thead>
<tbody><tr>
<td><code>@a</code></td>
<td><code>+</code> <code>-</code> <code>*</code> <code>&amp;</code> <code>!</code> <code>~</code> <code>++</code> <code>--</code></td>
<td><code>A::operator@()</code></td>
<td><code>operator@(A)</code></td>
</tr>
<tr>
<td><code>a@</code></td>
<td><code>++</code> <code>--</code></td>
<td><code>A::operator@(int)</code></td>
<td><code>operator@(A,int)</code></td>
</tr>
<tr>
<td><code>a@b</code></td>
<td><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> <code>^</code> <code>&amp;</code> <code>|</code> <code>&lt;</code> <code>&gt;</code> <code>==</code> <code>!=</code> <code>&lt;=</code> <code>&gt;=</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&amp;&amp;</code> <code>||</code> <code>,</code></td>
<td><code>A::operator@(B)</code></td>
<td><code>operator@(A,B)</code></td>
</tr>
<tr>
<td><code>a@b</code></td>
<td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>^=</code> <code>&amp;=</code> <code>| =</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>[]</code></td>
<td><code>A::operator@(B)</code></td>
<td>-</td>
</tr>
<tr>
<td><code>a(b,c...)</code></td>
<td><code>()</code></td>
<td><code>A::operator()(B,C...)</code></td>
<td>-</td>
</tr>
<tr>
<td><code>a-&gt;b</code></td>
<td><code>-&gt;</code></td>
<td><code>A::operator-&gt;()</code></td>
<td>-</td>
</tr>
<tr>
<td><code>(TYPE) a</code></td>
<td><code>TYPE</code></td>
<td><code>A::operator TYPE()</code></td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="继承和虚函数"><a href="#继承和虚函数" class="headerlink" title="继承和虚函数"></a>继承和虚函数</h2><h3 id="继承的基本知识"><a href="#继承的基本知识" class="headerlink" title="继承的基本知识"></a>继承的基本知识</h3><ul>
<li>构造函数的调用顺序：构造基类 &#x3D;&#x3D;&gt; 构造成员对象(按定义顺序) &#x3D;&#x3D;&gt; 自己构造</li>
<li>析构函数调用顺序：析构自己 &#x3D;&#x3D;&gt; 析构成员对象(按定义顺序反向) &#x3D;&#x3D;&gt; 析构基类</li>
</ul>
<p><strong>派生类可以在构造函数使用初始化列表指定基类的构造函数显示的调用。</strong></p>
<p>继承的内存布局：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基类数据成员</span><br><span class="line">派生类数据成员</span><br></pre></td></tr></table></figure>

<ul>
<li>派生类和基类的首地址指向同一块内存空间。</li>
<li>派生类指针转换成基类的指针是安全的，不可能越界访问。</li>
<li>基类指针转换成派生类指针是不安全的，可能会产生溢出。</li>
</ul>
<h3 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数指针的定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__cdecl *FUNTYPE)</span><span class="params">()</span></span>;  <span class="comment">//typedef 方便以后使用</span></span><br><span class="line"></span><br><span class="line">FUNTYPE pfnfun = fun;   <span class="comment">//指针函数的定义</span></span><br><span class="line"><span class="built_in">pfnfun</span>();   <span class="comment">//指针函数的是用 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数指针定义与使用</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(A::*CFUNTYPE)</span><span class="params">()</span></span>;</span><br><span class="line">CFUNTYPE cpfnFun = &amp;A::fun; <span class="comment">//成员函数指针的定义与赋值</span></span><br><span class="line"></span><br><span class="line">A theA;</span><br><span class="line">A *pA = &amp;theA;</span><br><span class="line">(theA.*cpfnFun)();  <span class="comment">//成员函数指针的调用</span></span><br><span class="line"></span><br><span class="line">pfnFun2 = A::fun2;</span><br><span class="line">(pA-&gt;*cpfnFun)();  <span class="comment">//成员函数指针的调用</span></span><br></pre></td></tr></table></figure>

<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数的定义就是在函数前加上关键字 <code>virtual</code>，虚函数的特性：运行时多态。</p>
<p>析构函数必须是虚函数，可以防止一些资源未被释放的问题。</p>
<h3 id="重载、隐藏和覆盖"><a href="#重载、隐藏和覆盖" class="headerlink" title="重载、隐藏和覆盖"></a>重载、隐藏和覆盖</h3><ol>
<li>重载：</li>
</ol>
<ul>
<li>作用域相同。</li>
<li>函数名相同，参数个数，参数类型，参数顺序不同构成重载。</li>
<li>返回值不做参考。</li>
</ul>
<ol start="2">
<li>覆盖：</li>
</ol>
<ul>
<li>不同作用域(基类和派生类)</li>
<li>函数名相同</li>
<li>参数个数，参数类型，参数顺序都要相同</li>
<li>返回值相同</li>
<li>基类函数是虚函数</li>
</ul>
<ol start="3">
<li>隐藏(除了覆盖就是隐藏)：</li>
</ol>
<ul>
<li>作用域不同(基类和派生类)。</li>
<li>函数名相同</li>
</ul>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><ul>
<li>在基类的构造函数中拷贝基类的虚表指针到对象的首地址。</li>
<li>在派生类的构造函数中拷贝派生类的虚表指针到对象首地址。<ul>
<li>有覆盖先覆盖</li>
<li>新增加的虚函数地址加在虚表后面</li>
</ul>
</li>
</ul>
<h3 id="虚表函数的特性"><a href="#虚表函数的特性" class="headerlink" title="虚表函数的特性"></a>虚表函数的特性</h3><ol>
<li>如果一个类至少有一个虚表函数，那么这个类就有一个虚表指针。</li>
<li>虚表存放在全局数据区，即没实例化对象虚表也存在。</li>
<li>相同的类，不同的对象共享虚表，即虚表指针指向同一个位置。</li>
<li>虚表指针存放在对象的首地址处。</li>
<li>虚表项存放成员函数指针(数组)，通常按虚函数的定义顺序排列。</li>
<li>虚表不一定以 NULL 结尾。</li>
<li>不同的类虚表不同。</li>
<li>构造时初始化虚表指针。</li>
</ol>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>写法 virtual fun() &#x3D; 0;</p>
<p>注意事项</p>
<ol>
<li>如果一个类至少有一个纯虚函数，那么这个类就是一个抽象类。</li>
<li>抽象类不能实例化对象。</li>
<li>如果派生类没有覆盖全部纯虚函数，那么派生类也是抽象类。</li>
</ol>
<p>在 VC6.0 中，纯虚析构函数必须实现。</p>
<p>显示调用析构函数，无多态性。</p>
<p>用途</p>
<ol>
<li>有些类很抽象，无法实现，例如(图形，动物)。</li>
<li>强制要求派生类实现虚函数。</li>
<li>给派生类规范了接口(常用)。</li>
</ol>
<h3 id="普通多重继承"><a href="#普通多重继承" class="headerlink" title="普通多重继承"></a>普通多重继承</h3><p>构造顺序</p>
<ol>
<li>先构造基类(按继承顺序)</li>
<li>对象成员构造函数(定义顺序)</li>
<li>最后执行自己构造函数</li>
</ol>
<p>析构顺序</p>
<ol>
<li>先执行自己的析构函数</li>
<li>再执行对象成员析构函数(按定义顺序反向执行)</li>
<li>最后执行基类的析构函数(按继承顺序反向执行)</li>
</ol>
<p>数据成员在内存中的结构</p>
<ol>
<li>基类数据成员(按继承顺序排列)</li>
<li>自己的数据成员</li>
</ol>
<p>多重继承中的基类的函数和数据成员有可能出现同名的情况，使用派生类实例化的对像调用同名函数或使用同名数据成员时，就会出现二义性，此时编译器不知道到底调用哪个基类的，就会报错。如果要调用同名函数或使用同名数据成员时，只要加上作用域就可以使用了。</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承后派生类多了一个指针变量，存放的是基类数据成员的偏移量表，这样的存储方式使得派生类中继承基类的数据成员只存一份，如果要访问直接通过偏移量表来访问就可以了。</p>
<p>构造顺序:</p>
<p>A. 构造基类(先虚基类，普通基类按继承顺序)</p>
<p>B. 对象成员构造</p>
<p>C. 构造自己</p>
<p>析构顺序:与构造顺序相反。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常处理程序是在 <code>try</code> 块的右大括号后立即使用 <code>catch</code> 关键字声明的。 <code>catch</code> 的语法类似于具有一个参数的常规函数 ​​。此参数的类型非常重要，因为会根据它检查 <code>throw</code> 表达式传递的参数类型，只有在它们匹配的情况下，异常才会被该处理程序捕获。</p>
<p><code>try catch</code> 可以嵌套处理。<br>也可以自定义自己的异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myexcepton</span>:<span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myexcepton</span>() &#123;&#125;;</span><br><span class="line">    ~<span class="built_in">myexcepton</span>() &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;my exception happened.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 嵌套</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 抛出自定义异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">myexcepton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">int</span> n)&#123;</span><br><span class="line">            <span class="keyword">throw</span>; <span class="comment">// 将异常转发给外部try catch.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e)&#123; <span class="comment">// exception将会捕获所有子类异常</span></span><br><span class="line">            cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">throw</span> <span class="number">3</span>; <span class="comment">// 抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> e)&#123; <span class="comment">// 捕获 int 类型的异常</span></span><br><span class="line">        cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">char</span> e) &#123; <span class="comment">// 捕获 char 类型的异常</span></span><br><span class="line">        cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;    <span class="comment">// 捕获其他的所有类型的异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="c-11-新特性"><a href="#c-11-新特性" class="headerlink" title="c++11 新特性"></a>c++11 新特性</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/sWEBZzm6qmW2-LEw6Rdz3Q">https://mp.weixin.qq.com/s/sWEBZzm6qmW2-LEw6Rdz3Q</a></p>
</blockquote>
<h2 id="auto-amp-decltype"><a href="#auto-amp-decltype" class="headerlink" title="auto &amp; decltype"></a>auto &amp; decltype</h2><p>关于 C++11 新特性，最先提到的肯定是类型推导，C++11 引入了 <code>auto</code> 和 <code>decltype</code> 关键字，使用他们可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。</p>
<ul>
<li><code>auto</code>：让编译器在编译器就推导出变量的类型，可以通过&#x3D;右边的类型推导出变量的类型。</li>
<li><code>decltype</code>：相对于 auto 用于推导变量类型，而 <code>decltype</code> 则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">10</span>; <span class="comment">// 10 是 int 型，可以自动推导出 a 是 int</span></span><br><span class="line"></span><br><span class="line">cont <span class="type">int</span> &amp;i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) b = <span class="number">2</span>; <span class="comment">// b 是 const int&amp;</span></span><br></pre></td></tr></table></figure>

<h2 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h2><p>众所周知 C++11 新增了右值引用，这里涉及到很多概念：</p>
<ul>
<li>左值：可以取地址并且有名字的东西就是左值。</li>
<li>右值：不能取地址的没有名字的东西就是右值。</li>
<li>纯右值：运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、<code>lambda</code> 表达式等都是纯右值。</li>
<li>将亡值：可以理解为即将要销毁的值。</li>
<li>左值引用：对左值进行引用的类型。</li>
<li>右值引用：对右值进行引用的类型。</li>
<li>移动语义：转移资源所有权，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用。</li>
<li>完美转发：可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参。</li>
<li>返回值优化：当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。</li>
</ul>
<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>在 C++11 中可以直接在变量名后面加上初始化列表来进行对象的初始化。</p>
<h2 id="std-function-amp-std-bind-amp-lambda-表达式"><a href="#std-function-amp-std-bind-amp-lambda-表达式" class="headerlink" title="std::function &amp; std::bind &amp; lambda 表达式"></a>std::function &amp; std::bind &amp; lambda 表达式</h2><p>c++11 新增了 std::function、std::bind、lambda 表达式等封装使函数调用更加方便。</p>
<h2 id="模板的改进"><a href="#模板的改进" class="headerlink" title="模板的改进"></a>模板的改进</h2><p>C++11 关于模板有一些细节的改进：</p>
<ul>
<li>模板的右尖括号</li>
<li>模板的别名</li>
<li>函数模板的默认模板参数</li>
</ul>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>c++11 关于并发引入了好多好东西，有：</p>
<ul>
<li><code>std::thread</code> 相关</li>
<li><code>std::mutex</code> 相关</li>
<li><code>std::lock</code> 相关</li>
<li><code>std::atomic</code> 相关</li>
<li><code>std::call_once</code> 相关</li>
<li><code>volatile</code> 相关</li>
<li><code>std::condition_variable</code> 相关</li>
<li><code>std::future</code> 相关</li>
<li><code>async</code> 相关</li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>c++11 引入了三种智能指针：</p>
<ul>
<li><code>std::shared_ptr</code></li>
<li><code>std::weak_ptr</code></li>
<li><code>std::unique_ptr</code></li>
</ul>
<h2 id="基于范围的-for-循环"><a href="#基于范围的-for-循环" class="headerlink" title="基于范围的 for 循环"></a>基于范围的 for 循环</h2><p>直接看代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = vec.<span class="built_in">begin</span>(); iter != vec.<span class="built_in">end</span>(); iter++) &#123; <span class="comment">// before c++11</span></span><br><span class="line">   cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : vec) &#123; <span class="comment">// c++11基于范围的for循环</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><p>委托构造函数允许在同一个类中一个构造函数调用另外一个构造函数，可以在变量初始化时简化操作，通过代码来感受下委托构造函数的妙处吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> a) &#123; a_ = a; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">A</span>(a) &#123; b_ = b; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">A</span>(a, b) &#123; c_ = c; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> a_;</span><br><span class="line">   <span class="type">int</span> b_;</span><br><span class="line">   <span class="type">int</span> c_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化变量是不是方便了许多。</p>
<h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>继承构造函数可以让派生类直接使用基类的构造函数，如果有一个派生类，我们希望派生类采用和基类一样的构造方式，可以直接使用基类的构造函数，而不是再重新写一遍构造函数，老规矩，看代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">   <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">   <span class="built_in">Base</span>(<span class="type">int</span> a) &#123; a_ = a; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">Base</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">Base</span>(a) &#123; b_ = b; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">Base</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) : <span class="built_in">Base</span>(a, b) &#123; c_ = c; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> a_;</span><br><span class="line">   <span class="type">int</span> b_;</span><br><span class="line">   <span class="type">int</span> c_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">   <span class="keyword">using</span> Base::Base;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="function">Derived <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要使用 <code>using Base::Base</code> 继承构造函数，就免去了很多重写代码的麻烦。</p>
<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p><code>nullptr</code> 是 c++11 用来表示空指针新引入的常量值，在 c++中如果表示空指针语义时建议使用 <code>nullptr</code> 而不要使用 <code>NULL</code>，因为 <code>NULL</code> 本质上是个 <code>int</code> 型的 0，其实不是个指针。举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;func ptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;func i&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">func</span>(<span class="literal">NULL</span>); <span class="comment">// 编译失败，会产生二义性</span></span><br><span class="line">   <span class="built_in">func</span>(<span class="literal">nullptr</span>); <span class="comment">// 输出func ptr</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="final-amp-override"><a href="#final-amp-override" class="headerlink" title="final &amp; override"></a>final &amp; override</h2><p>c++11 关于继承新增了两个关键字，<code>final</code> 用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载，<code>override</code> 用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了 <code>override</code> 但父类却没有这个虚函数，编译报错，使用 <code>override</code> 关键字可以避免开发者在重写基类函数时无意产生的错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;base&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 确保func被重写</span></span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">fu</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// error，基类没有fu()，不可以被重写</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> <span class="keyword">final</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;base&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123; <span class="comment">// 编译失败，final修饰的类不可以被继承</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p>c++11 引入 <code>default</code> 特性，多数时候用于声明构造函数为默认构造函数，如果类中有了自定义的构造函数，编译器就不会隐式生成默认构造函数，而通过 <code>default</code>，程序员只需在函数声明后加上<code>=default;</code>，就可将该函数声明为 <code>defaulted</code> 函数，编译器将为显式声明的 <code>defaulted</code> 函数自动生成函数体，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> i) &#123; a = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   A a;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>c++中，如果开发人员没有定义特殊成员函数，那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，例如拷贝构造函数或者拷贝赋值操作符，而我们有时候想禁止对象的拷贝与赋值，可以使用 <code>delete</code> 修饰，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">const</span> A&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">   A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> i) &#123; a = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   A a1;</span><br><span class="line">   A a2 = a1;  <span class="comment">// 错误，拷贝构造函数被禁用</span></span><br><span class="line">   A a3;</span><br><span class="line">   a3 = a1;  <span class="comment">// 错误，拷贝赋值操作符被禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>delele</code> 函数在 c++11 中很常用，<code>std::unique_ptr</code> 就是通过 <code>delete</code> 修饰来禁止对象的拷贝的。</p>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p><code>explicit</code> 专用于修饰构造函数，表示只能显式构造，不可以被隐式转换，根据代码看 <code>explicit</code> 的作用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">structA &#123;</span><br><span class="line"><span class="built_in">explicitA</span>(<span class="type">int</span> value)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">intmain</span>()&#123;</span><br><span class="line">A a = <span class="number">1</span>; <span class="comment">// error，不可以隐式转换</span></span><br><span class="line"><span class="function">A <span class="title">aa</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// ok</span></span><br><span class="line">return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>因为要讲后面的 <code>constexpr</code>，所以这里简单介绍下 <code>const</code>。</p>
<p><code>const</code> 字面意思为只读，可用于定义变量，表示变量是只读的，不可以更改，如果更改，编译期间就会报错。</p>
<p>主要用法如下：</p>
<ul>
<li>用于定义常量，<code>const</code> 的修饰的变量不可更改。</li>
<li>指针也可以使用 <code>const</code>，这里有个小技巧，从右向左读，即可知道 <code>const</code> 究竟修饰的是指针还是指针所指向的内容。</li>
<li>在函数参数中使用 <code>const</code>，一般会传递类对象时会传递一个 <code>const</code> 的引用或者指针，这样可以避免对象的拷贝，也可以防止对象被修改。</li>
<li><code>const</code> 修饰类的成员变量，表示是成员常量，不能被修改，可以在初始化列表中被赋值。</li>
<li>修饰类成员函数，表示在该函数内不可以修改该类的成员变量。</li>
<li>修饰类对象，类对象只能调用该对象的 <code>const</code> 成员函数。</li>
</ul>
<h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><p><code>constexpr</code> 是 c++11 新引入的关键字，用于编译时的常量和常量函数，这里直接介绍 <code>constexpr</code> 和 <code>const</code> 的区别：</p>
<p>两者都代表可读，<code>const</code> 只表示 read only 的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而 <code>constexpr</code> 修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，<code>constexpr</code> 可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。</p>
<h2 id="enum-class"><a href="#enum-class" class="headerlink" title="enum class"></a>enum class</h2><p>c++11 新增有作用域的枚举类型，不带作用域的枚举类型可以自动转换成整形，且不同的枚举可以相互比较；带作用域的枚举类型可以选择底层类型，默认是 <code>int</code>，可以改成 <code>char</code> 等别的类型。</p>
<p>我们平时编程过程中使用枚举，一定要使用有作用域的枚举取代传统的枚举。</p>
<h2 id="非受限联合体"><a href="#非受限联合体" class="headerlink" title="非受限联合体"></a>非受限联合体</h2><p>c++11 之前 <code>union</code> 中数据成员的类型不允许有非 POD 类型，而这个限制在 c++11 被取消，允许数据成员类型有非 POD 类型。</p>
<p>对于什么是 POD 类型，大家可以自行查下资料，大体上可以理解为对象可以直接 <code>memcpy</code> 的类型。</p>
<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>c++11 中 <code>sizeof</code> 可以用的类的数据成员上，想知道类中数据成员的大小在 c++11 中方便了许多，而不需要定义一个对象，在计算对象的成员大小。</p>
<h2 id="assertion"><a href="#assertion" class="headerlink" title="assertion"></a>assertion</h2><p>c++11 引入 <code>static_assert</code> 声明，用于在编译期间检查，如果第一个参数值为 <code>false</code>，则打印 <code>message</code>，编译失败。</p>
<h2 id="自定义字面量"><a href="#自定义字面量" class="headerlink" title="自定义字面量"></a>自定义字面量</h2><p>c++11 可以自定义字面量。</p>
<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>什么是内存对齐</p>
<p>理论上计算机对于任何变量的访问都可以从任意位置开始，然而实际上系统会对这些变量的存放地址有限制，通常将变量首地址设为某个数 N 的倍数，这就是内存对齐。</p>
<p>为什么要内存对齐</p>
<p>硬件平台限制，内存以字节为单位，不同硬件平台不一定支持任何内存地址的存取，一般可能以双字节、4 字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐。<br>提高 CPU 内存访问速度，一般处理器的内存存取粒度都是 N 的整数倍，假如访问 N 大小的数据，没有进行内存对齐，有可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次性把数据全部读取出来，提高效率。</p>
<h2 id="thread-local"><a href="#thread-local" class="headerlink" title="thread_local"></a>thread_local</h2><p>c++11 引入 <code>thread_local</code>，用 <code>thread_local</code> 修饰的变量具有 <code>thread</code> 周期，每一个线程都拥有并只拥有一个该变量的独立实例，一般用于需要保证线程安全的函数中。</p>
<h2 id="基础数值类型"><a href="#基础数值类型" class="headerlink" title="基础数值类型"></a>基础数值类型</h2><p>c++11 新增了几种数据类型：<code>long long</code>、<code>char16_t</code>、<code>char32_t</code> 等</p>
<h2 id="随机数功能"><a href="#随机数功能" class="headerlink" title="随机数功能"></a>随机数功能</h2><p>c++11 关于随机数功能则较之前丰富了很多，典型的可以选择概率分布类型。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>c++11 引入了 regex 库更好的支持正则表达式。</p>
<h2 id="chrono"><a href="#chrono" class="headerlink" title="chrono"></a>chrono</h2><p>c++11 关于时间引入了 <code>chrono</code> 库，源于 boost，功能强大，<code>chrono</code> 主要有三个点：</p>
<ul>
<li>duration: 表示一段时间，常见的单位有 s、ms 等</li>
<li>time_point: 表示一个具体时间点，如 2020 年 5 月 10 日 10 点 10 分 10 秒</li>
<li>clocks:时钟，chrono 里面提供了三种时钟：<ul>
<li>steady_clock: 稳定的时间间隔，表示相对时间，相对于系统开机启动的时间，无论系统时间如何被更改，后一次调用 now()肯定比前一次调用 now()的数值大，可用于计时。</li>
<li>system_clock: 表示当前的系统时钟，可以用于获取当前时间。</li>
<li>high_resolution_clock: 表示系统可用的最高精度的时钟。</li>
</ul>
</li>
</ul>
<h2 id="新增数据结构"><a href="#新增数据结构" class="headerlink" title="新增数据结构"></a>新增数据结构</h2><ul>
<li><code>std::forward_list</code>：单向链表，只可以前进，在特定场景下使用，相比于 std::list 节省了内存，提高了性能</li>
<li><code>std::unordered_set</code>：基于 hash 表实现的 set，内部不会排序，使用方法和 set 类似</li>
<li><code>std::unordered_map</code>：基于 hash 表实现的 map，内部不会排序，使用方法和 set 类似</li>
<li><code>std::array</code>：数组，在越界访问时抛出异常，建议使用 std::array 替代普通的数组</li>
<li><code>std::tuple</code>：元组类型，类似 pair，但比 pair 扩展性好</li>
</ul>
<h2 id="新增算法"><a href="#新增算法" class="headerlink" title="新增算法"></a>新增算法</h2><ul>
<li><code>all_of</code>：检测表达式是否对范围 <code>[first, last)</code> 中所有元素都返回 true，如果都满足，则返回 true</li>
<li><code>any_of</code>：检测表达式是否对范围 <code>[first, last)</code> 中至少一个元素返回 true，如果满足，则返回 true，否则返回 false，用法和上面一样</li>
<li><code>none_of</code>：检测表达式是否对范围 <code>[first, last)</code> 中所有元素都不返回 true，如果都不满足，则返回 true，否则返回 false，用法和上面一样</li>
<li><code>find_if_not</code>：找到第一个不符合要求的元素迭代器，和 find_if 相反</li>
<li><code>copy_if</code>：复制满足条件的元素</li>
<li><code>itoa</code>：对容器内的元素按序递增</li>
<li><code>minmax_element</code>：返回容器内最大元素和最小元素位置</li>
<li><code>is_sorted</code>、<code>is_sorted_until</code>：返回容器内元素是否已经排好序。</li>
</ul>
<h1 id="C-14-新特性"><a href="#C-14-新特性" class="headerlink" title="C++14 新特性"></a>C++14 新特性</h1><h2 id="函数返回值类型推导"><a href="#函数返回值类型推导" class="headerlink" title="函数返回值类型推导"></a>函数返回值类型推导</h2><p>C++14 对函数返回类型推导规则做了优化，返回值类型推导也可以用在模板中。</p>
<h2 id="lambda-参数-auto"><a href="#lambda-参数-auto" class="headerlink" title="lambda 参数 auto"></a>lambda 参数 auto</h2><h2 id="变量模板"><a href="#变量模板" class="headerlink" title="变量模板"></a>变量模板</h2><h2 id="别名模板"><a href="#别名模板" class="headerlink" title="别名模板"></a>别名模板</h2><h2 id="deprecated-标记"><a href="#deprecated-标记" class="headerlink" title="[[deprecated]]标记"></a><code>[[deprecated]]</code>标记</h2><p>C++14 中增加了 deprecated 标记，修饰类、变、函数等，当程序中使用到了被其修饰的代码时，编译时被产生警告，用户提示开发者该标记修饰的内容将来可能会被丢弃，尽量不要使用。</p>
<h2 id="二进制字面量与整形字面量分隔符"><a href="#二进制字面量与整形字面量分隔符" class="headerlink" title="二进制字面量与整形字面量分隔符"></a>二进制字面量与整形字面量分隔符</h2><h2 id="新增下列标准函数："><a href="#新增下列标准函数：" class="headerlink" title="新增下列标准函数："></a>新增下列标准函数：</h2><ul>
<li><code>std::make_unique</code></li>
<li><code>std::shared_timed_mutex</code> 与 <code>std::shared_lock</code></li>
<li><code>std::integer_sequence</code></li>
<li><code>std::exchange</code></li>
<li><code>std::quoted</code></li>
</ul>
<h1 id="C-17-新特性"><a href="#C-17-新特性" class="headerlink" title="C++17 新特性"></a>C++17 新特性</h1><h2 id="构造函数模板推导"><a href="#构造函数模板推导" class="headerlink" title="构造函数模板推导"></a>构造函数模板推导</h2><p>C++17 就不需要构造一个模板类对象需要指明类型，直接可以推导出类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">pair <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2.2</span>)</span></span>; <span class="comment">// c++17 自动推导</span></span><br><span class="line">vector v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// c++17</span></span><br></pre></td></tr></table></figure>

<h2 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h2><p>通过结构化绑定，对于 tuple、map 等类型，获取相应值会方便很多。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2.3f</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span>[i, f] = a;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; m = &#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;[i, s] : m) &#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="if-switch-语句初始化"><a href="#if-switch-语句初始化" class="headerlink" title="if-switch 语句初始化"></a>if-switch 语句初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if (init; condition)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="type">int</span> a = <span class="built_in">GetValue</span>()); a &lt; <span class="number">101</span>) &#123;</span><br><span class="line">   cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string str = <span class="string">&quot;Hi World&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> [pos, size] = <span class="built_in">pair</span>(str.<span class="built_in">find</span>(<span class="string">&quot;Hi&quot;</span>), str.<span class="built_in">size</span>()); pos != string::npos) &#123;</span><br><span class="line">   std::cout &lt;&lt; pos &lt;&lt; <span class="string">&quot; Hello, size is &quot;</span> &lt;&lt; size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种方式可以尽可能约束作用域，让代码更简洁，但是可读性略有下降。</p>
<h2 id="内联变量"><a href="#内联变量" class="headerlink" title="内联变量"></a>内联变量</h2><p>C++17 前只有内联函数，现在有了内联变量，我们印象中 C++类的静态成员变量在头文件中是不能初始化的，但是有了内联变量，就可以达到此目的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// header file</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="type">const</span> A::value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==========或者========</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h2><p>C++17 引入了折叠表达式使可变参数模板编程更方便：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Ts ... ts)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (ts + ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a &#123;<span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)&#125;; <span class="comment">// 15</span></span><br><span class="line">std::string a&#123;<span class="string">&quot;hello &quot;</span>&#125;;</span><br><span class="line">std::string b&#123;<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sum</span>(a, b) &lt;&lt; endl; <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<h2 id="constexpr-lambda-表达式"><a href="#constexpr-lambda-表达式" class="headerlink" title="constexpr lambda 表达式"></a>constexpr lambda 表达式</h2><p>C++17 前 lambda 表达式只能在运行时使用，C++17 引入了 constexpr lambda 表达式，可以用于在编译期进行计算。</p>
<h2 id="namespace-嵌套"><a href="#namespace-嵌套" class="headerlink" title="namespace 嵌套"></a>namespace 嵌套</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">   <span class="keyword">namespace</span> B &#123;</span><br><span class="line">       <span class="keyword">namespace</span> C &#123;</span><br><span class="line">           <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c++17，更方便更舒适</span></span><br><span class="line"><span class="keyword">namespace</span> A::B::C &#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="has-include-预处理表达式"><a href="#has-include-预处理表达式" class="headerlink" title="__has_include 预处理表达式"></a><code>__has_include</code> 预处理表达式</h2><p><code>__has_include</code> 预处理表达式可以判断是否有某个头文件，代码可能会在不同编译器下工作，不同编译器的可用头文件有可能不同，所以可以使用此来判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined __has_include</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&lt;charconv&gt;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> has_charconv 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;charconv&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">ConvertToInt</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> value&#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> has_charconv</span></span><br><span class="line">   <span class="type">const</span> <span class="keyword">auto</span> last = str.<span class="built_in">data</span>() + str.<span class="built_in">size</span>();</span><br><span class="line">   <span class="type">const</span> <span class="keyword">auto</span> res = std::<span class="built_in">from_chars</span>(str.<span class="built_in">data</span>(), last, value);</span><br><span class="line">   <span class="keyword">if</span> (res.ec == std::errc&#123;&#125; &amp;&amp; res.ptr == last) <span class="keyword">return</span> value;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">   <span class="comment">// alternative implementation...</span></span><br><span class="line">   其它方式实现</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在-lambda-表达式用-this-捕获对象副本"><a href="#在-lambda-表达式用-this-捕获对象副本" class="headerlink" title="在 lambda 表达式用 *this 捕获对象副本"></a>在 lambda 表达式用 <code>*this</code> 捕获对象副本</h2><p>正常情况下，lambda 表达式中访问类的对象成员变量需要捕获 this，但是这里捕获的是 this 指针，指向的是对象的引用，正常情况下可能没问题，但是如果多线程情况下，函数的作用域超过了对象的作用域，对象已经被析构了，还访问了成员变量，就会有问题。</p>
<p>所以 C++17 增加了新特性，捕获*this，不持有 this 指针，而是持有对象的拷贝，这样生命周期就与对象的生命周期不相关啦。</p>
<h2 id="新增-Attribute"><a href="#新增-Attribute" class="headerlink" title="新增 Attribute"></a>新增 Attribute</h2><p>我们可能平时在项目中见过 <code>__declspec__</code> , <code>__attribute__</code> , <code>#pragma</code> 指示符，使用它们来给编译器提供一些额外的信息，来产生一些优化或特定的代码，也可以给其它开发者一些提示信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">short</span> f[<span class="number">3</span>]; &#125; __attribute__((<span class="built_in">aligned</span>(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fatal</span><span class="params">()</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;</span><br></pre></td></tr></table></figure>

<p>在 C++11 和 C++14 中有更方便的方法：</p>
<ul>
<li><code>[[carries_dependency]]</code> 让编译期跳过不必要的内存栅栏指令</li>
<li><code>[[noreturn]]</code> 函数不会返回</li>
<li><code>[[deprecated]]</code> 函数将弃用的警告</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[noreturn]] <span class="function"><span class="type">void</span> <span class="title">terminate</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">[[<span class="built_in">deprecated</span>(<span class="string">&quot;use new func instead&quot;</span>)]] <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>[[fallthrough]]</code>：用在 switch 中提示可以直接落下去，不需要 break，让编译期忽略警告</li>
<li><code>[[nodiscard]]</code> ：表示修饰的内容不能被忽略，可用于修饰函数，标明返回值一定要被处理</li>
<li><code>[[maybe_unused]]</code> ：提示编译器修饰的内容可能暂时没有使用，避免产生警告</li>
</ul>
<h2 id="新增下列标准"><a href="#新增下列标准" class="headerlink" title="新增下列标准"></a>新增下列标准</h2><p><code>file_system</code><br><code>std::variant</code><br><code>std::optional</code><br><code>std::any</code><br><code>std::apply</code><br><code>std::make_from_tuple</code><br><code>as_const</code><br><code>std::string_view</code><br><code>std::shared_mutex</code></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="C-名称粉碎使用-C-filt-工具恢复"><a href="#C-名称粉碎使用-C-filt-工具恢复" class="headerlink" title="C++ 名称粉碎使用 C++filt 工具恢复"></a><code>C++</code> 名称粉碎使用 <code>C++filt</code> 工具恢复</h2><p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ c++filt _Z3addii</span><br><span class="line">add(int, int)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="判断编译平台宏定义"><a href="#判断编译平台宏定义" class="headerlink" title="判断编译平台宏定义"></a>判断编译平台宏定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">   <span class="comment">//define something for Windows (32-bit and 64-bit, this part is common)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">      <span class="comment">//define something for Windows (64-bit only)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="comment">//define something for Windows (32-bit only)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __APPLE__</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TargetConditionals.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">         <span class="comment">// iOS Simulator</span></span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> TARGET_OS_IPHONE</span></span><br><span class="line">        <span class="comment">// iOS device</span></span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> TARGET_OS_MAC</span></span><br><span class="line">        <span class="comment">// Other kinds of Mac OS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#   <span class="keyword">error</span> <span class="string">&quot;Unknown Apple platform&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __ANDROID__</span></span><br><span class="line">    <span class="comment">// android</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line">    <span class="comment">// linux</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __unix__ <span class="comment">// all unices not caught above</span></span></span><br><span class="line">    <span class="comment">// Unix</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_POSIX_VERSION)</span></span><br><span class="line">    <span class="comment">// POSIX</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">error</span> <span class="string">&quot;Unknown compiler&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="error-C2027-use-of-undefined-type"><a href="#error-C2027-use-of-undefined-type" class="headerlink" title="error C2027: use of undefined type"></a>error C2027: use of undefined type</h2><p>当遇到这种问题时， 将实现写到 cpp 文件中。</p>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># builder.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Burger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BurgerBuilder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">float</span> size;</span><br><span class="line">	<span class="type">bool</span> cheese = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> pepperoni = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> lettuce = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> tomato = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">BurgerBuilder</span>(<span class="type">float</span> size) : <span class="built_in">size</span>(size) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Burger* <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 将下列的实现代码写到 cpp 文件中，否则会报 error C2027: use of undefined type 错误。</span></span><br><span class="line">	<span class="comment">// &#123;</span></span><br><span class="line">	<span class="comment">// 	return new Burger(this);</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Burger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">float</span> size;</span><br><span class="line">	<span class="type">bool</span> cheese = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> pepperoni = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> lettuce = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> tomato = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Burger</span>(BurgerBuilder* builder) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;size = builder-&gt;size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cheese = builder-&gt;cheese;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pepperoni = builder-&gt;pepperoni;</span><br><span class="line">		<span class="keyword">this</span>-&gt;lettuce = builder-&gt;lettuce;</span><br><span class="line">		<span class="keyword">this</span>-&gt;tomato = builder-&gt;tomato;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// builder.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Builder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Burger* <span class="title">BurgerBuilder::build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Burger</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/33964994/error-c2027-use-of-undefined-type-how-to-declare-class">https://stackoverflow.com/questions/33964994/error-c2027-use-of-undefined-type-how-to-declare-class</a></p>
</blockquote>
<h2 id="jupyter-notebook-for-C"><a href="#jupyter-notebook-for-C" class="headerlink" title="jupyter notebook for C++"></a>jupyter notebook for C++</h2><p>这里可以使用 <a target="_blank" rel="noopener" href="https://github.com/jupyter-xeus/xeus-cling">xeus-cling</a> 搭建一个 Jupyter kernel 环境，方便边做笔记边测试。</p>
<p>首先安装 <a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">Miniconda</a> 并创建一个新的环境。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda create -n cling python=3.9</span><br></pre></td></tr></table></figure>

<p>然后安装<a target="_blank" rel="noopener" href="https://github.com/jupyter-xeus/xeus-cling">xeus-cling</a> 和 <a target="_blank" rel="noopener" href="https://jupyter.org/install">Jupyter Notebook</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ conda install jupyter notebook</span><br><span class="line">$ conda install xeus-cling -c conda-forge</span><br></pre></td></tr></table></figure>

<p>安装好了之后，运行 <code>jupyter kernelspec list</code> 将会出现下列内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ jupyter kernelspec list</span><br><span class="line">Available kernels:</span><br><span class="line">  python3    /home/ckcat/miniconda3/envs/cling/share/jupyter/kernels/python3</span><br><span class="line">  xcpp11     /home/ckcat/miniconda3/envs/cling/share/jupyter/kernels/xcpp11</span><br><span class="line">  xcpp14     /home/ckcat/miniconda3/envs/cling/share/jupyter/kernels/xcpp14</span><br><span class="line">  xcpp17     /home/ckcat/miniconda3/envs/cling/share/jupyter/kernels/xcpp17</span><br></pre></td></tr></table></figure>

<p>之后运行 <code>jupyter notebook --allow-root --ip=0.0.0.0 --port=2233</code> 命令即可。</p>
<ul>
<li><code>--ip=0.0.0.0</code> 作用是允许外部试用。</li>
<li><code>--port=2233</code> 表示运行的端口。</li>
</ul>
<p>后面就可以通过本地浏览器写笔记和代码。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/12/15/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/" rel="prev" title="MySQL的安装和配置">
                  <i class="fa fa-chevron-left"></i> MySQL的安装和配置
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/12/21/r2Frida%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/" rel="next" title="r2Frida环境配置及使用">
                  r2Frida环境配置及使用 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CKCat</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/CKCat" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
