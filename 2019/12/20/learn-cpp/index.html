<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"ckcat.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="基础const、引用和函数默认参数的使用及注意事项 const 的作用 取代无参宏，增加类型检查功能。 对指针类型做一些限定。    const 主要是语法层面的限定，实际上可以通过内存修改 const 变量。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#define P">
<meta property="og:type" content="article">
<meta property="og:title" content="learn-cpp">
<meta property="og:url" content="https://ckcat.github.io/2019/12/20/learn-cpp/index.html">
<meta property="og:site_name" content="CKCat的博客">
<meta property="og:description" content="基础const、引用和函数默认参数的使用及注意事项 const 的作用 取代无参宏，增加类型检查功能。 对指针类型做一些限定。    const 主要是语法层面的限定，实际上可以通过内存修改 const 变量。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#define P">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-12-20T16:19:10.000Z">
<meta property="article:modified_time" content="2023-10-12T11:47:49.879Z">
<meta property="article:author" content="CKCat">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://ckcat.github.io/2019/12/20/learn-cpp/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://ckcat.github.io/2019/12/20/learn-cpp/","path":"2019/12/20/learn-cpp/","title":"learn-cpp"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>learn-cpp | CKCat的博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">CKCat的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#const%E3%80%81%E5%BC%95%E7%94%A8%E5%92%8C%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.1.</span> <span class="nav-text">const、引用和函数默认参数的使用及注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94-inline"><span class="nav-number">1.2.1.</span> <span class="nav-text">内联 inline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">1.2.2.</span> <span class="nav-text">函数重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="nav-number">1.2.3.</span> <span class="nav-text">构造和析构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-%E5%92%8C-const"><span class="nav-number">1.3.</span> <span class="nav-text">static 和 const</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#namespace"><span class="nav-number">1.3.1.</span> <span class="nav-text">namespace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-number">1.3.2.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cosnt"><span class="nav-number">1.3.3.</span> <span class="nav-text">cosnt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#friend"><span class="nav-number">1.3.4.</span> <span class="nav-text">friend</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.3.5.</span> <span class="nav-text">运算符重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text">继承和虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">继承的基本知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">1.4.2.</span> <span class="nav-text">成员函数指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.</span> <span class="nav-text">虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E3%80%81%E9%9A%90%E8%97%8F%E5%92%8C%E8%A6%86%E7%9B%96"><span class="nav-number">1.5.1.</span> <span class="nav-text">重载、隐藏和覆盖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-number">1.5.2.</span> <span class="nav-text">虚函数表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E8%A1%A8%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.5.3.</span> <span class="nav-text">虚表函数的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.4.</span> <span class="nav-text">纯虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-number">1.5.5.</span> <span class="nav-text">普通多重继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">1.5.6.</span> <span class="nav-text">虚继承</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">2.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c-11-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">3.</span> <span class="nav-text">c++11 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#auto-amp-decltype"><span class="nav-number">3.1.</span> <span class="nav-text">auto &amp; decltype</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC"><span class="nav-number">3.2.</span> <span class="nav-text">左值右值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">4.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%90%8D%E7%A7%B0%E7%B2%89%E7%A2%8E%E4%BD%BF%E7%94%A8-C-filt-%E5%B7%A5%E5%85%B7%E6%81%A2%E5%A4%8D"><span class="nav-number">4.1.</span> <span class="nav-text">C++ 名称粉碎使用 C++filt 工具恢复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E7%BC%96%E8%AF%91%E5%B9%B3%E5%8F%B0%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">4.2.</span> <span class="nav-text">判断编译平台宏定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#error-C2027-use-of-undefined-type"><span class="nav-number">4.3.</span> <span class="nav-text">error C2027: use of undefined type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jupyter-notebook-for-C"><span class="nav-number">4.4.</span> <span class="nav-text">jupyter notebook for C++</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CKCat</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">119</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/CKCat" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;CKCat" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ckcatck@qq.com" title="E-Mail → mailto:ckcatck@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ckcat.github.io/2019/12/20/learn-cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CKCat">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CKCat的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="learn-cpp | CKCat的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          learn-cpp
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-20 16:19:10" itemprop="dateCreated datePublished" datetime="2019-12-20T16:19:10+00:00">2019-12-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-12 11:47:49" itemprop="dateModified" datetime="2023-10-12T11:47:49+00:00">2023-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="const、引用和函数默认参数的使用及注意事项"><a href="#const、引用和函数默认参数的使用及注意事项" class="headerlink" title="const、引用和函数默认参数的使用及注意事项"></a><code>const</code>、引用和函数默认参数的使用及注意事项</h2><ol>
<li><code>const</code> 的作用<ul>
<li>取代无参宏，增加类型检查功能。</li>
<li>对指针类型做一些限定。</li>
</ul>
</li>
</ol>
<p><code>const</code> 主要是语法层面的限定，实际上可以通过内存修改 <code>const</code> 变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14f</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PI: %f\r\n&quot;</span>, PI);   <span class="comment">// 3.140000</span></span><br><span class="line">    <span class="comment">// const 取代无参宏，方便调试，增加类型检查。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> CPI = <span class="number">3.14f</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPI: %f\r\n&quot;</span>, CPI);  <span class="comment">// 3.140000</span></span><br><span class="line">    *(<span class="type">float</span>*)&amp;CPI = <span class="number">2.14f</span>;</span><br><span class="line">    <span class="comment">// 编译中直接替换为常量了，所以修改了CPI的值输出也是3.140000。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CPI: %f\r\n&quot;</span>, CPI);  <span class="comment">// 3.140000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 指针</span></span><br><span class="line">    <span class="comment">// const 在 * 前面，则指针指向的内容无法修改。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* pbuffer = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    pbuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// pbuffer[0] = &#x27;H&#x27;;  这条语句会出错，表达式必须是可修改的左值。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 在 * 后面，则指针变量的值无法修改。</span></span><br><span class="line">    <span class="type">char</span> szBuffer[] = <span class="string">&quot;world&quot;</span>;  <span class="comment">// 等价于  char * const szBuffer = &quot;hello&quot;</span></span><br><span class="line">    <span class="type">char</span>* <span class="type">const</span> cbuffer = szBuffer;</span><br><span class="line">    <span class="comment">// cbuffer = NULL; 表达式必须是可修改的左值。</span></span><br><span class="line">    cbuffer[<span class="number">0</span>] = <span class="string">&#x27;W&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 在 * 前后都有，则指向的内容和指针的值都无法修改。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> ccbuffer = szBuffer;</span><br><span class="line">    <span class="comment">// ccbuffer = NULL; 表达式必须是可修改的左值。</span></span><br><span class="line">    <span class="comment">// ccbuffer[0] = &#x27;h&#x27;;表达式必须是可修改的左值。</span></span><br><span class="line">    szBuffer[<span class="number">1</span>] = <span class="string">&#x27;O&#x27;</span>; <span class="comment">// 语法上不可修改，实际上可以通过内存修改</span></span><br><span class="line">    <span class="comment">// printf(&quot;pbuffer: %s\r\n&quot;, pbuffer);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cbuffer: %s\r\n&quot;</span>, cbuffer);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ccbuffer: %s\r\n&quot;</span>, ccbuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 const 和非 const 指针转换问题如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> TYPE * = TYPE *;    <span class="comment">// 正确</span></span><br><span class="line">TYPE* = <span class="type">const</span> TYPE*;      <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>引用注意事项<ul>
<li>引用必须初始化。</li>
<li>引用不能初始化为常量(存在特例)。</li>
<li>没有二级引用。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_point</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_ref</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 引用必须初始化</span></span><br><span class="line">    <span class="type">int</span>&amp; ref_a = a;</span><br><span class="line">    <span class="type">int</span>&amp; ref_b = b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ref_a = %d, ref_b= %d\r\n&quot;</span>, ref_a, ref_b);</span><br><span class="line">    <span class="built_in">swap_point</span>(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b= %d\r\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ref_a = %d, ref_b= %d\r\n&quot;</span>, ref_a, ref_b);</span><br><span class="line">    <span class="built_in">swap_ref</span>(ref_a, ref_b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b= %d\r\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ref_a = %d, ref_b= %d\r\n&quot;</span>, ref_a, ref_b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int&amp; const_value = 1;   // error C2440: &#x27;initializing&#x27;: cannot convert from &#x27;int&#x27; to &#x27;int &amp;&#x27;</span></span><br><span class="line">    <span class="comment">// int&amp;&amp; n = ref_a;        // error C2440: &#x27;initializing&#x27;: cannot convert from &#x27;int&#x27; to &#x27;int &amp;&amp;&#x27;</span></span><br><span class="line">    <span class="comment">// 下面相当于 int tmp = 2; const int &amp;c_ref = tmp;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; c_ref = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address: %p\r\n&quot;</span>, &amp;c_ref);  <span class="comment">// 这里可以发现输出的为栈地址。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引用与指针无本质区别，只是语法上的区别，下列为 IDA 中反汇编后的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov     [ebp+a], 1</span><br><span class="line">mov     [ebp+b], 2</span><br><span class="line">lea     eax, [ebp+a]</span><br><span class="line">mov     [ebp+ref_a], eax</span><br><span class="line">lea     eax, [ebp+b]</span><br><span class="line">mov     [ebp+ref_b], eax</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>默认参数注意事项<ul>
<li>缺省参数只能放在最右边。</li>
<li>声明和实现不能同时定义缺省，只能写一个。</li>
<li>缺省参数通常放在声明文件中。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, sum);</span><br><span class="line">    sum = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol>
<li><code>class</code> 类默认 <code>private</code>；<code>struct</code> 类和 <code>union</code> 类默认公有，其中 <code>union</code> 类内存共享。</li>
<li>不同的对象，数据成员内存地址不一样。</li>
<li>调用成员函数时会隐藏传递 <code>this</code> 指针，默认会用寄存器（ECX）传递。</li>
<li>使用 <code>__stdcall</code> 方式的函数调用时， <code>this</code> 指针直接入栈传递。</li>
<li>类的声明一般定义在头文件中，实现在另外的 cpp 文件中。</li>
</ol>
<h3 id="内联-inline"><a href="#内联-inline" class="headerlink" title="内联 inline"></a>内联 inline</h3><p>在 C++中使用 inline 函数也是直接替换内容，而且有参数类型检查，就解决了宏的类型检查问题，可以在编译期间就避免类型不一致的错误。</p>
<p>内联的一些情况:</p>
<ul>
<li>debug 版不内联。</li>
<li>release 版才会内联，inline 告诉编译器需要内联，编译器会根据函数的复杂度来确定是否直接替换。</li>
<li>直接在类中定义并实现的函数默认内联。</li>
</ul>
<p><strong>类成员函数内联的定义和实现一般都是写在同一个文件中，主要是为了防止重复定义以及避免编译器在链接过程中直接替换函数时找不到函数定义。</strong></p>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CInline.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CInline</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CInline.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CInline.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CInline::add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CInline.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    CInline clinne;</span><br><span class="line">    <span class="type">int</span> sum = clinne.<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\r\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就会出现下列错误，将 <code>CInline::add</code> 的实现写到 <code>CInline.h</code> 中就可以编译通过了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error LNK2019: unresolved external symbol <span class="string">&quot;public: int __thiscall CInline::add(int,int)&quot;</span> (?add@CInline@@QAEHHH@Z) referenced <span class="keyword">in</span> <span class="keyword">function</span> _main</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>重载实现编译器期的多态。</p>
<p>重载的定义：函数名相同，参数个数不同 或 参数类型不同 或 参数顺序不同即可构成重载。</p>
<p>注意点：</p>
<ul>
<li>返回值不作参考，即返回值不同也不构成重载。</li>
<li><code>TYPE</code> 和 <code>const TPYE</code> 不构成重载，如 <code>add(int)</code> 和 <code>add(const int)</code> 不构成重载。</li>
<li><code>TYPE*</code> 和 <code>const TPYE*</code> 可以重载，如 <code>add(int*)</code> 和 <code>add(const int*)</code> 构成重载。</li>
<li>引用可以重载，如 <code>add(int)</code> 和 <code>add(int&amp;)</code> 构成重载。</li>
<li><code>typedef</code> 无效，如 <code>typedef int T;</code> <code>add(T)</code> 和 <code>add(int)</code> 不构成重载。</li>
</ul>
<h3 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h3><p>构造函数是一个特殊的成员函数，主要作用是初始化，申请资源；其注意点如下：</p>
<ul>
<li>不能显示调用，即使用者不能调用。</li>
<li>没有返回值。</li>
<li>可以重载。</li>
</ul>
<p>析构函数也是特殊的成员函数，主要作用是释放资源；其注意点如下：</p>
<ul>
<li>可以显示调用。</li>
<li>没有返回值。</li>
<li>不能有参数，所以不能重载。</li>
</ul>
<p>编译器一般会自动为一个类生成六个特殊的成员函数，</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>class C 对应的形式</th>
</tr>
</thead>
<tbody><tr>
<td>默认构造函数</td>
<td>C::C();</td>
</tr>
<tr>
<td>析构函数</td>
<td>C::~C();</td>
</tr>
<tr>
<td>复制构造函数</td>
<td>C::C (const C&amp;);</td>
</tr>
<tr>
<td>复制赋值运算符</td>
<td>C&amp; operator&#x3D; (const C&amp;);</td>
</tr>
<tr>
<td>移动构造函数（C++11）</td>
<td>C::C (C&amp;&amp;);</td>
</tr>
<tr>
<td>移动赋值运算符（C++11）</td>
<td>C&amp; operator&#x3D; (C&amp;&amp;);</td>
</tr>
</tbody></table>
<p>以上六个成员函数如果不用，最好用 <code>delete</code> 标记一下，避免出现非预期结果。</p>
<p>复制构造函数和复制赋值运算符默认情况下直接将对象进行整体复制，如果对象数据成员有指针变量时，就会复制指针变量而不是指针对应的数据，就造成了两个对象中的指针变量指向了同一个地址，与预期的结果是不一样的，还有一个问题就是析构函数会两次释放资源，造成错误。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Copy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Number;</span><br><span class="line">    <span class="type">char</span>* m_pszBuff;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Copy</span>(<span class="type">int</span> number, <span class="type">const</span> <span class="type">char</span>* szbuf = <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(number, szbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Copy</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pszBuff)&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_pszBuff;</span><br><span class="line">            m_pszBuff = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> number, <span class="type">const</span> <span class="type">char</span>* szbuf)</span> </span>&#123;</span><br><span class="line">        m_Number = number;</span><br><span class="line">        <span class="keyword">if</span> (szbuf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_pszBuff = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m_pszBuff = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(szbuf) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(m_pszBuff, szbuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function">Copy <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    Copy p2 = p1;</span><br><span class="line">    <span class="function">Copy <span class="title">p3</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1.m_Number address: %p, p1.m_pszBuff address: %p\r\n&quot;</span>, &amp;p1.m_Number, p1.m_pszBuff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2.m_Number address: %p, p2.m_pszBuff address: %p\r\n&quot;</span>, &amp;p2.m_Number, p2.m_pszBuff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p3.m_Number address: %p, p3.m_pszBuff address: %p\r\n&quot;</span>, &amp;p3.m_Number, p3.m_pszBuff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码运行后可以发现 m_pszBuff 的内存地址为同一个值，然后析构函数会多次释放内存导致错误。</p>
<p>函数参数尽量使用引用作为参数，应为如果使用对象作为参数，将会多执行一次拷贝构造和一次析构，导致性能损失。</p>
<p>一个类的成员包含另一个类的析构和构造函数调用情况：</p>
<ul>
<li>构造顺序：先根据定义的顺序构造成员对象，再构造自己。</li>
<li>析构顺序与析构顺序相反：先析构自己，再根据定义的顺序反向析构成员对象。</li>
</ul>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassA</span>(<span class="type">int</span> count = <span class="number">0</span>)&#123;</span><br><span class="line">        mCount = count;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ClassA() &quot;</span> &lt;&lt; mCount &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ClassA</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~ClassA() &quot;</span> &lt;&lt; mCount &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mCount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ClassA d1;</span><br><span class="line">    ClassA d2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassB</span>():<span class="built_in">d1</span>(<span class="number">1</span>), <span class="built_in">d2</span>(<span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ClassB() &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">ClassB</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ClassB() &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ClassB b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ClassA() 1</span><br><span class="line">ClassA() 2</span><br><span class="line">ClassB()</span><br><span class="line">ClassB()</span><br><span class="line">~ClassA() 2</span><br><span class="line">~ClassA() 1</span><br></pre></td></tr></table></figure>

<h2 id="static-和-const"><a href="#static-和-const" class="headerlink" title="static 和 const"></a>static 和 const</h2><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><ul>
<li>命名空间也是为了解决访问权限和命名重复的问题。</li>
<li>当两个命名空间名是一样的就会合并为一个。</li>
<li>命名空间尽量确保唯一性。</li>
<li>可以嵌套使用类名空间，但是尽量不要这样使用。</li>
</ul>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Mystring&#123;</span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *strDestination, <span class="type">const</span> <span class="type">char</span> *strSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> g_nCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_nCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> szText[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> g_nCount = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//strcpy(szText, &quot;hello&quot;);          //error，因为不知道用标准库函数还是用Mystring中的函数</span></span><br><span class="line">    Mystring::<span class="built_in">strcpy</span>(szText, <span class="string">&quot;hello&quot;</span>);  <span class="comment">//调用的是Mystring里面的strcpy</span></span><br><span class="line">    Mystring::g_nCount = <span class="number">1</span>;             <span class="comment">//调用的是Mystring里面的strcpy</span></span><br><span class="line">    ::<span class="built_in">strcpy</span>(szText, <span class="string">&quot;hello&quot;</span>);          <span class="comment">//调用的是全局strcpy, ::前面没有命名空间表示全局的</span></span><br><span class="line">    g_nCount = <span class="number">10</span>;                      <span class="comment">//调用的是main函数中的g_nCount</span></span><br><span class="line">    ::g_nCount = <span class="number">20</span>;                    <span class="comment">//调用全局的g_nCount</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ol>
<li>静态成员变量</li>
</ol>
<ul>
<li>静态成员变量只限于类里面访问，并且不同的类可以定义相同的变量名，可以避免全局变量的权限范围过大以及命名空间问题。</li>
<li>静态成员变量和普通成员变量的定义方式是一样的，并且不占用对象空间。</li>
<li>静态数据成员使用前必须要先初始化，初始化方式：类名::static 数据成员名 &#x3D; 0;</li>
</ul>
<ol start="2">
<li>静态成员函数</li>
</ol>
<ul>
<li>静态成员函数出现的原因和静态成员函数出现的原因一样，也是因为权限和命名空间的问题。</li>
<li>静态成员函数中不含 this 指针，所以不能访问普通数据成员，只能访问静态数据成员。</li>
<li>调用方式：类名::静态成员函数名 或者 对象.静态成员函数名。</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTestStatic</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mNumber;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> mCount;    <span class="comment">//不占用对象的空间</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CTestStatic</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        mNumber = <span class="number">0</span>;</span><br><span class="line">        mCount++;         <span class="comment">//每个对象修改的都是同一个m_nCount</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CTestStatic() mCount = &quot;</span> &lt;&lt; mCount &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">CTestStatic</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~CTestStatic() mCount = &quot;</span> &lt;&lt; mCount&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//因为静态成员函数没有传递this指针，不能访问普通数据成员</span></span><br><span class="line">        <span class="comment">//只能访问静态数据成员</span></span><br><span class="line">        <span class="keyword">return</span> mCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> CTestStatic::mCount = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;CTestStatic size: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(CTestStatic) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    CTestStatic t1;</span><br><span class="line">    CTestStatic t2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mCount = &quot;</span> &lt;&lt; t1.<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mCount = &quot;</span> &lt;&lt; t2.<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mCount = &quot;</span> &lt;&lt; CTestStatic::<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cosnt"><a href="#cosnt" class="headerlink" title="cosnt"></a>cosnt</h3><ol>
<li><p>cosnt 数据成员<br>cosnt 数据成员的定义和普通 const 变量的定义是一样的，但是由于在类里面定义数据成员是不支持定义的同时初始化的，只能通过构造函数使用初始化表来初始化。</p>
</li>
<li><p>const 成员函数<br>cosnt 成员函数的使用方法在普通成员函数后面加上 const 即可，本质是改变了 this 指针的属性。主要是为了防止在对象调用成员函数是修改了数据成员，还有就是 const 对象只能调用 const 成员函数，如果没有 const 成员函数，const 对象什么事都干不了。</p>
</li>
</ol>
<h3 id="friend"><a href="#friend" class="headerlink" title="friend"></a>friend</h3><p>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。</p>
<p>在类定义中，使用 <code>friend</code> 关键字和非成员函数或其他类的名称，以允许其访问类的私有和受保护成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Retangle</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Retangle</span>() &#123; width = height = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">Retangle</span>(<span class="type">int</span> x, <span class="type">int</span> y) :<span class="built_in">width</span>(x), <span class="built_in">height</span>(y) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> width * height; &#125;</span><br><span class="line">    <span class="comment">// 友元函数可以访问 Retangle 私有和受保护的成员。</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Retangle <span class="title">duplicate</span><span class="params">(<span class="type">const</span> Retangle&amp; param)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">convert</span><span class="params">(Square a)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Test&amp; t)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="comment">// 友元类，其成员可以访问 Square 的私有或受保护成员。</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Retangle</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> side;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Square</span>(<span class="type">int</span> a) :<span class="built_in">side</span>(a) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 友元类成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Retangle::fun</span><span class="params">(Test&amp; t)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Retangle <span class="title">duplicate</span><span class="params">(<span class="type">const</span> Retangle&amp; param)</span> </span>&#123;</span><br><span class="line">    Retangle res;</span><br><span class="line">    res.width = param.width;</span><br><span class="line">    res.height = param.height;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Retangle::convert</span><span class="params">(Square a)</span> </span>&#123;</span><br><span class="line">    width = a.side;</span><br><span class="line">    height = a.side;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Retangle::fun</span><span class="params">(Test&amp; t)</span> </span>&#123;</span><br><span class="line">    t.t = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  Rectangle rect;</span><br><span class="line">  <span class="function">Square <span class="title">sqr</span> <span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">  rect.<span class="built_in">convert</span>(sqr);</span><br><span class="line">  cout &lt;&lt; rect.<span class="built_in">area</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友元一般用作设计，因为友元后能访问私有成员，破坏封装性，不推荐使用。</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>操作符</th>
<th>成员函数</th>
<th>非成员函数</th>
</tr>
</thead>
<tbody><tr>
<td><code>@a</code></td>
<td><code>+</code> <code>-</code> <code>*</code> <code>&amp;</code> <code>!</code> <code>~</code> <code>++</code> <code>--</code></td>
<td><code>A::operator@()</code></td>
<td><code>operator@(A)</code></td>
</tr>
<tr>
<td><code>a@</code></td>
<td><code>++</code> <code>--</code></td>
<td><code>A::operator@(int)</code></td>
<td><code>operator@(A,int)</code></td>
</tr>
<tr>
<td><code>a@b</code></td>
<td><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> <code>^</code> <code>&amp;</code> <code>|</code> <code>&lt;</code> <code>&gt;</code> <code>==</code> <code>!=</code> <code>&lt;=</code> <code>&gt;=</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&amp;&amp;</code> <code>||</code> <code>,</code></td>
<td><code>A::operator@(B)</code></td>
<td><code>operator@(A,B)</code></td>
</tr>
<tr>
<td><code>a@b</code></td>
<td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>^=</code> <code>&amp;=</code> <code>| =</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>[]</code></td>
<td><code>A::operator@(B)</code></td>
<td>-</td>
</tr>
<tr>
<td><code>a(b,c...)</code></td>
<td><code>()</code></td>
<td><code>A::operator()(B,C...)</code></td>
<td>-</td>
</tr>
<tr>
<td><code>a-&gt;b</code></td>
<td><code>-&gt;</code></td>
<td><code>A::operator-&gt;()</code></td>
<td>-</td>
</tr>
<tr>
<td><code>(TYPE) a</code></td>
<td><code>TYPE</code></td>
<td><code>A::operator TYPE()</code></td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="继承和虚函数"><a href="#继承和虚函数" class="headerlink" title="继承和虚函数"></a>继承和虚函数</h2><h3 id="继承的基本知识"><a href="#继承的基本知识" class="headerlink" title="继承的基本知识"></a>继承的基本知识</h3><ul>
<li>构造函数的调用顺序：构造基类 &#x3D;&#x3D;&gt; 构造成员对象(按定义顺序) &#x3D;&#x3D;&gt; 自己构造</li>
<li>析构函数调用顺序：析构自己 &#x3D;&#x3D;&gt; 析构成员对象(按定义顺序反向) &#x3D;&#x3D;&gt; 析构基类</li>
</ul>
<p><strong>派生类可以在构造函数使用初始化列表指定基类的构造函数显示的调用。</strong></p>
<p>继承的内存布局：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基类数据成员</span><br><span class="line">派生类数据成员</span><br></pre></td></tr></table></figure>

<ul>
<li>派生类和基类的首地址指向同一块内存空间。</li>
<li>派生类指针转换成基类的指针是安全的，不可能越界访问。</li>
<li>基类指针转换成派生类指针是不安全的，可能会产生溢出。</li>
</ul>
<h3 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数指针的定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__cdecl *FUNTYPE)</span><span class="params">()</span></span>;  <span class="comment">//typedef 方便以后使用</span></span><br><span class="line"></span><br><span class="line">FUNTYPE pfnfun = fun;   <span class="comment">//指针函数的定义</span></span><br><span class="line"><span class="built_in">pfnfun</span>();   <span class="comment">//指针函数的是用 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数指针定义与使用</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(A::*CFUNTYPE)</span><span class="params">()</span></span>;</span><br><span class="line">CFUNTYPE cpfnFun = &amp;A::fun; <span class="comment">//成员函数指针的定义与赋值</span></span><br><span class="line"></span><br><span class="line">A theA;</span><br><span class="line">A *pA = &amp;theA;</span><br><span class="line">(theA.*cpfnFun)();  <span class="comment">//成员函数指针的调用</span></span><br><span class="line"></span><br><span class="line">pfnFun2 = A::fun2;</span><br><span class="line">(pA-&gt;*cpfnFun)();  <span class="comment">//成员函数指针的调用</span></span><br></pre></td></tr></table></figure>

<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数的定义就是在函数前加上关键字 <code>virtual</code>，虚函数的特性：运行时多态。</p>
<p>析构函数必须是虚函数，可以防止一些资源未被释放的问题。</p>
<h3 id="重载、隐藏和覆盖"><a href="#重载、隐藏和覆盖" class="headerlink" title="重载、隐藏和覆盖"></a>重载、隐藏和覆盖</h3><ol>
<li>重载：</li>
</ol>
<ul>
<li>作用域相同。</li>
<li>函数名相同，参数个数，参数类型，参数顺序不同构成重载。</li>
<li>返回值不做参考。</li>
</ul>
<ol start="2">
<li>覆盖：</li>
</ol>
<ul>
<li>不同作用域(基类和派生类)</li>
<li>函数名相同</li>
<li>参数个数，参数类型，参数顺序都要相同</li>
<li>返回值相同</li>
<li>基类函数是虚函数</li>
</ul>
<ol start="3">
<li>隐藏(除了覆盖就是隐藏)：</li>
</ol>
<ul>
<li>作用域不同(基类和派生类)。</li>
<li>函数名相同</li>
</ul>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><ul>
<li>在基类的构造函数中拷贝基类的虚表指针到对象的首地址。</li>
<li>在派生类的构造函数中拷贝派生类的虚表指针到对象首地址。<ul>
<li>有覆盖先覆盖</li>
<li>新增加的虚函数地址加在虚表后面</li>
</ul>
</li>
</ul>
<h3 id="虚表函数的特性"><a href="#虚表函数的特性" class="headerlink" title="虚表函数的特性"></a>虚表函数的特性</h3><ol>
<li>如果一个类至少有一个虚表函数，那么这个类就有一个虚表指针。</li>
<li>虚表存放在全局数据区，即没实例化对象虚表也存在。</li>
<li>相同的类，不同的对象共享虚表，即虚表指针指向同一个位置。</li>
<li>虚表指针存放在对象的首地址处。</li>
<li>虚表项存放成员函数指针(数组)，通常按虚函数的定义顺序排列。</li>
<li>虚表不一定以 NULL 结尾。</li>
<li>不同的类虚表不同。</li>
<li>构造时初始化虚表指针。</li>
</ol>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>写法 virtual fun() &#x3D; 0;</p>
<p>注意事项</p>
<ol>
<li>如果一个类至少有一个纯虚函数，那么这个类就是一个抽象类。</li>
<li>抽象类不能实例化对象。</li>
<li>如果派生类没有覆盖全部纯虚函数，那么派生类也是抽象类。</li>
</ol>
<p>在 VC6.0 中，纯虚析构函数必须实现。</p>
<p>显示调用析构函数，无多态性。</p>
<p>用途</p>
<ol>
<li>有些类很抽象，无法实现，例如(图形，动物)。</li>
<li>强制要求派生类实现虚函数。</li>
<li>给派生类规范了接口(常用)。</li>
</ol>
<h3 id="普通多重继承"><a href="#普通多重继承" class="headerlink" title="普通多重继承"></a>普通多重继承</h3><p>构造顺序</p>
<ol>
<li>先构造基类(按继承顺序)</li>
<li>对象成员构造函数(定义顺序)</li>
<li>最后执行自己构造函数</li>
</ol>
<p>析构顺序</p>
<ol>
<li>先执行自己的析构函数</li>
<li>再执行对象成员析构函数(按定义顺序反向执行)</li>
<li>最后执行基类的析构函数(按继承顺序反向执行)</li>
</ol>
<p>数据成员在内存中的结构</p>
<ol>
<li>基类数据成员(按继承顺序排列)</li>
<li>自己的数据成员</li>
</ol>
<p>多重继承中的基类的函数和数据成员有可能出现同名的情况，使用派生类实例化的对像调用同名函数或使用同名数据成员时，就会出现二义性，此时编译器不知道到底调用哪个基类的，就会报错。如果要调用同名函数或使用同名数据成员时，只要加上作用域就可以使用了。</p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>虚继承后派生类多了一个指针变量，存放的是基类数据成员的偏移量表，这样的存储方式使得派生类中继承基类的数据成员只存一份，如果要访问直接通过偏移量表来访问就可以了。</p>
<p>构造顺序:</p>
<p>A. 构造基类(先虚基类，普通基类按继承顺序)</p>
<p>B. 对象成员构造</p>
<p>C. 构造自己</p>
<p>析构顺序:与构造顺序相反。</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常处理程序是在 <code>try</code> 块的右大括号后立即使用 <code>catch</code> 关键字声明的。 <code>catch</code> 的语法类似于具有一个参数的常规函数 ​​。此参数的类型非常重要，因为会根据它检查 <code>throw</code> 表达式传递的参数类型，只有在它们匹配的情况下，异常才会被该处理程序捕获。</p>
<p><code>try catch</code> 可以嵌套处理。<br>也可以自定义自己的异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myexcepton</span>:<span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myexcepton</span>() &#123;&#125;;</span><br><span class="line">    ~<span class="built_in">myexcepton</span>() &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;my exception happened.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 嵌套</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 抛出自定义异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">myexcepton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">int</span> n)&#123;</span><br><span class="line">            <span class="keyword">throw</span>; <span class="comment">// 将异常转发给外部try catch.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e)&#123; <span class="comment">// exception将会捕获所有子类异常</span></span><br><span class="line">            cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">throw</span> <span class="number">3</span>; <span class="comment">// 抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> e)&#123; <span class="comment">// 捕获 int 类型的异常</span></span><br><span class="line">        cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">char</span> e) &#123; <span class="comment">// 捕获 char 类型的异常</span></span><br><span class="line">        cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)&#123;    <span class="comment">// 捕获其他的所有类型的异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="c-11-新特性"><a href="#c-11-新特性" class="headerlink" title="c++11 新特性"></a>c++11 新特性</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/sWEBZzm6qmW2-LEw6Rdz3Q">https://mp.weixin.qq.com/s/sWEBZzm6qmW2-LEw6Rdz3Q</a></p>
</blockquote>
<h2 id="auto-amp-decltype"><a href="#auto-amp-decltype" class="headerlink" title="auto &amp; decltype"></a>auto &amp; decltype</h2><p>关于 C++11 新特性，最先提到的肯定是类型推导，C++11 引入了 auto 和 decltype 关键字，使用他们可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。</p>
<p>auto：让编译器在编译器就推导出变量的类型，可以通过&#x3D;右边的类型推导出变量的类型。</p>
<p>auto 推导规则</p>
<p>在不声明为引用或指针时，auto 会忽略等号右边的引用类型和 cv 限定<br>在声明为引用或者指针时，auto 会保留等号右边的引用和 cv 属性<br>这里的 cv 是指 const 和 volatile</p>
<p>auto 的限制：</p>
<p>auto 的使用必须马上初始化，否则无法推导出类型<br>auto 在一行定义多个变量时，各个变量的推导不能产生二义性，否则编译失败<br>auto 不能用作函数参数<br>在类中 auto 不能用作非静态成员变量<br>auto 不能定义数组，可以定义指针<br>auto 无法推导出模板参数<br>decltype：相对于 auto 用于推导变量类型，而 decltype 则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。</p>
<p>decltype 推导规则</p>
<p>exp 是表达式，decltype(exp)和 exp 类型相同<br>exp 是函数调用，decltype(exp)和函数返回值类型相同<br>其它情况，若 exp 是左值，decltype(exp)是 exp 类型的左值引用</p>
<p>直接看代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// auto会忽略等号右边的引用类型和cv限定</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> *a = &amp;i; <span class="comment">// a是int*</span></span><br><span class="line"><span class="keyword">auto</span> &amp;b = i; <span class="comment">// b是int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> c = b; <span class="comment">// c是int，忽略了引用</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> d = i; <span class="comment">// d是const int</span></span><br><span class="line"><span class="keyword">auto</span> e = d; <span class="comment">// e是int</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; f = e; <span class="comment">// f是const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g = f; <span class="comment">// g是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// decltype会保留表达式的引用和cv属性</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func</span>()) i; <span class="comment">// i为int类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y; <span class="comment">// y是int类型</span></span><br><span class="line"><span class="keyword">decltype</span>(x + y) z; <span class="comment">// z是int类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) b = <span class="number">2</span>; <span class="comment">// b是const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// auto和decltype的配合使用</span></span><br><span class="line"><span class="comment">// 返回值后置类型语法解决了函数返回值类型依赖于参数但却难以确定返回值类型的问题。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>委托构造函数</p>
<h2 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h2><p>众所周知 C++11 新增了右值引用，这里涉及到很多概念：</p>
<p>左值：可以取地址并且有名字的东西就是左值。<br>右值：不能取地址的没有名字的东西就是右值。<br>纯右值：运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda 表达式等都是纯右值。<br>将亡值：可以理解为即将要销毁的值。<br>左值引用：对左值进行引用的类型。<br>右值引用：对右值进行引用的类型。<br>移动语义：转移资源所有权，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用。<br>完美转发：可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参。<br>返回值优化：当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。</p>
<p>这里的详细介绍请看：左值引用、右值引用、移动语义、完美转发，你知道的不知道的都在这里</p>
<p>列表初始化</p>
<p>在 C++11 中可以直接在变量名后面加上初始化列表来进行对象的初始化，详细介绍一定要看这篇文章：学会 C++11 列表初始化</p>
<p>std::function &amp; std::bind &amp; lambda 表达式</p>
<p>c++11 新增了 std::function、std::bind、lambda 表达式等封装使函数调用更加方便，详细介绍请看：搞定 c++11 新特性 std::function 和 lambda 表达式</p>
<p>模板的改进</p>
<p>C++11 关于模板有一些细节的改进：</p>
<p>模板的右尖括号<br>模板的别名<br>函数模板的默认模板参数</p>
<p>详细介绍请看：C++11 的模板改进</p>
<p>并发</p>
<p>c++11 关于并发引入了好多好东西，有：</p>
<p>std::thread 相关<br>std::mutex 相关<br>std::lock 相关<br>std::atomic 相关<br>std::call_once 相关<br>volatile 相关<br>std::condition_variable 相关<br>std::future 相关<br>async 相关</p>
<p>详细介绍请看：c++11 新特性之线程相关所有知识点</p>
<p>这里也使用 c++11 来实现的线程池和定时器，可以看：</p>
<p>C++线程池的实现之格式修订版</p>
<p>C++定时器的实现之格式修订版</p>
<p>智能指针</p>
<p>很多人谈到 c++，说它特别难，可能有一部分就是因为 c++的内存管理吧，不像 java 那样有虚拟机动态的管理内存，在程序运行过程中可能就会出现内存泄漏，然而这种问题其实都可以通过 c++11 引入的智能指针来解决，相反我还认为这种内存管理还是 c++语言的优势，因为尽在掌握。</p>
<p>c++11 引入了三种智能指针：</p>
<p>std::shared_ptr<br>std::weak_ptr<br>std::unique_ptr</p>
<p>详细介绍请看：c++11 新特性之智能指针</p>
<p>基于范围的 for 循环</p>
<p>直接看代码</p>
<p>vector<int> vec;</p>
<p>for (auto iter &#x3D; vec.begin(); iter !&#x3D; vec.end(); iter++) { &#x2F;&#x2F; before c++11<br>cout &lt;&lt; *iter &lt;&lt; endl;<br>}</p>
<p>for (int i : vec) { &#x2F;&#x2F; c++11 基于范围的 for 循环<br>cout &lt;&lt; “i” &lt;&lt; endl;<br>}<br>委托构造函数</p>
<p>委托构造函数允许在同一个类中一个构造函数调用另外一个构造函数，可以在变量初始化时简化操作，通过代码来感受下委托构造函数的妙处吧：</p>
<p>不使用委托构造函数：</p>
<p>structA {<br>A(){}<br>A(int a) { a_ &#x3D; a; }</p>
<p>A(int a, int b) { &#x2F;&#x2F; 好麻烦<br>a* &#x3D; a;<br>b* &#x3D; b;<br>}</p>
<p>A(int a, int b, int c) { &#x2F;&#x2F; 好麻烦<br>a* &#x3D; a;<br>b* &#x3D; b;<br>c_ &#x3D; c;<br>}</p>
<p>int a*;<br>int b*;<br>int c_;<br>};</p>
<p>使用委托构造函数：</p>
<p>structA {<br>A(){}<br>A(int a) { a_ &#x3D; a; }</p>
<p>A(int a, int b) : A(a) { b_ &#x3D; b; }</p>
<p>A(int a, int b, int c) : A(a, b) { c_ &#x3D; c; }</p>
<p>int a*;<br>int b*;<br>int c_;<br>};</p>
<p>初始化变量是不是方便了许多。</p>
<p>继承构造函数</p>
<p>继承构造函数可以让派生类直接使用基类的构造函数，如果有一个派生类，我们希望派生类采用和基类一样的构造方式，可以直接使用基类的构造函数，而不是再重新写一遍构造函数，老规矩，看代码：</p>
<p>不使用继承构造函数：</p>
<p>structBase {<br>Base() {}<br>Base(int a) { a_ &#x3D; a; }</p>
<p>Base(int a, int b) : Base(a) { b_ &#x3D; b; }</p>
<p>Base(int a, int b, int c) : Base(a, b) { c_ &#x3D; c; }</p>
<p>int a*;<br>int b*;<br>int c_;<br>};</p>
<p>structDerived : Base {<br>Derived() {}<br>Derived(int a) : Base(a) {} &#x2F;&#x2F; 好麻烦<br>Derived(int a, int b) : Base(a, b) {} &#x2F;&#x2F; 好麻烦<br>Derived(int a, int b, int c) : Base(a, b, c) {} &#x2F;&#x2F; 好麻烦<br>};<br>intmain(){<br>Derived a(1, 2, 3);<br>return0;<br>}</p>
<p>使用继承构造函数：</p>
<p>structBase {<br>Base() {}<br>Base(int a) { a_ &#x3D; a; }</p>
<p>Base(int a, int b) : Base(a) { b_ &#x3D; b; }</p>
<p>Base(int a, int b, int c) : Base(a, b) { c_ &#x3D; c; }</p>
<p>int a*;<br>int b*;<br>int c_;<br>};</p>
<p>structDerived : Base {<br>using Base::Base;<br>};</p>
<p>intmain(){<br>Derived a(1, 2, 3);<br>return0;<br>}</p>
<p>只需要使用 using Base::Base 继承构造函数，就免去了很多重写代码的麻烦。</p>
<p>nullptr</p>
<p>nullptr 是 c++11 用来表示空指针新引入的常量值，在 c++中如果表示空指针语义时建议使用 nullptr 而不要使用 NULL，因为 NULL 本质上是个 int 型的 0，其实不是个指针。举例：</p>
<p>voidfunc(void *ptr){<br>cout &lt;&lt; “func ptr” &lt;&lt; endl;<br>}</p>
<p>voidfunc(int i){<br>cout &lt;&lt; “func i” &lt;&lt; endl;<br>}</p>
<p>intmain(){<br>func(NULL); &#x2F;&#x2F; 编译失败，会产生二义性<br>func(nullptr); &#x2F;&#x2F; 输出 func ptr<br>return0;<br>}<br>final &amp; override</p>
<p>c++11 关于继承新增了两个关键字，final 用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载，override 用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了 override 但父类却没有这个虚函数，编译报错，使用 override 关键字可以避免开发者在重写基类函数时无意产生的错误。</p>
<p>示例代码 1：</p>
<p>structBase {<br>virtualvoidfunc(){<br>cout &lt;&lt; “base” &lt;&lt; endl;<br>}<br>};</p>
<p>structDerived :public Base{<br>voidfunc() override { &#x2F;&#x2F; 确保 func 被重写<br>cout &lt;&lt; “derived” &lt;&lt; endl;<br>}</p>
<p>voidfu() override { &#x2F;&#x2F; error，基类没有 fu()，不可以被重写<br>}<br>};</p>
<p>示例代码 2：</p>
<p>structBasefinal {<br>virtualvoidfunc(){<br>cout &lt;&lt; “base” &lt;&lt; endl;<br>}<br>};</p>
<p>structDerived :public Base{ &#x2F;&#x2F; 编译失败，final 修饰的类不可以被继承<br>voidfunc() override {<br>cout &lt;&lt; “derived” &lt;&lt; endl;<br>}</p>
<p>};<br>default</p>
<p>c++11 引入 default 特性，多数时候用于声明构造函数为默认构造函数，如果类中有了自定义的构造函数，编译器就不会隐式生成默认构造函数，如下代码：</p>
<p>structA {<br>int a;<br>A(int i) { a &#x3D; i; }<br>};</p>
<p>intmain(){<br>A a; &#x2F;&#x2F; 编译出错<br>return0;<br>}</p>
<p>上面代码编译出错，因为没有匹配的构造函数，因为编译器没有生成默认构造函数，而通过 default，程序员只需在函数声明后加上“&#x3D;default;”，就可将该函数声明为 defaulted 函数，编译器将为显式声明的 defaulted 函数自动生成函数体，如下：</p>
<p>structA {<br>A() &#x3D; default;<br>int a;<br>A(int i) { a &#x3D; i; }<br>};</p>
<p>intmain(){<br>A a;<br>return0;<br>}</p>
<p>编译通过。</p>
<p>delete</p>
<p>c++中，如果开发人员没有定义特殊成员函数，那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，例如拷贝构造函数或者拷贝赋值操作符，如下代码：</p>
<p>structA {<br>A() &#x3D; default;<br>int a;<br>A(int i) { a &#x3D; i; }<br>};</p>
<p>intmain(){<br>A a1;<br>A a2 &#x3D; a1; &#x2F;&#x2F; 正确，调用编译器隐式生成的默认拷贝构造函数<br>A a3;<br>a3 &#x3D; a1; &#x2F;&#x2F; 正确，调用编译器隐式生成的默认拷贝赋值操作符<br>}</p>
<p>而我们有时候想禁止对象的拷贝与赋值，可以使用 delete 修饰，如下：</p>
<p>structA {<br>A() &#x3D; default;<br>A(const A&amp;) &#x3D; delete;<br>A&amp; operator&#x3D;(const A&amp;) &#x3D; delete;<br>int a;<br>A(int i) { a &#x3D; i; }<br>};</p>
<p>intmain(){<br>A a1;<br>A a2 &#x3D; a1; &#x2F;&#x2F; 错误，拷贝构造函数被禁用<br>A a3;<br>a3 &#x3D; a1; &#x2F;&#x2F; 错误，拷贝赋值操作符被禁用<br>}</p>
<p>delele 函数在 c++11 中很常用，std::unique_ptr 就是通过 delete 修饰来禁止对象的拷贝的。</p>
<p>explicit</p>
<p>explicit 专用于修饰构造函数，表示只能显式构造，不可以被隐式转换，根据代码看 explicit 的作用：</p>
<p>不用 explicit：</p>
<p>structA {<br>A(int value) { &#x2F;&#x2F; 没有 explicit 关键字<br>cout &lt;&lt; “value” &lt;&lt; endl;<br>}<br>};</p>
<p>intmain(){<br>A a &#x3D; 1; &#x2F;&#x2F; 可以隐式转换<br>return0;<br>}</p>
<p>使用 explicit:</p>
<p>structA {<br>explicitA(int value){<br>cout &lt;&lt; “value” &lt;&lt; endl;<br>}<br>};</p>
<p>intmain(){<br>A a &#x3D; 1; &#x2F;&#x2F; error，不可以隐式转换<br>A aa(2); &#x2F;&#x2F; ok<br>return0;<br>}<br>const</p>
<p>因为要讲后面的 constexpr，所以这里简单介绍下 const。</p>
<p>const 字面意思为只读，可用于定义变量，表示变量是只读的，不可以更改，如果更改，编译期间就会报错。</p>
<p>主要用法如下：</p>
<p>用于定义常量，const 的修饰的变量不可更改。<br>constintvalue &#x3D; 5;<br>指针也可以使用 const，这里有个小技巧，从右向左读，即可知道 const 究竟修饰的是指针还是指针所指向的内容。<br>char <em>const ptr; &#x2F;&#x2F; 指针本身是常量<br>constchar</em> ptr; &#x2F;&#x2F; 指针指向的变量为常量<br>在函数参数中使用 const，一般会传递类对象时会传递一个 const 的引用或者指针，这样可以避免对象的拷贝，也可以防止对象被修改。<br>classA{};<br>voidfunc(const A&amp; a);<br>const 修饰类的成员变量，表示是成员常量，不能被修改，可以在初始化列表中被赋值。<br>classA {<br>constintvalue &#x3D; 5;<br>};<br>classB {<br>constintvalue;<br>B(int v) : value(v){}<br>};<br>修饰类成员函数，表示在该函数内不可以修改该类的成员变量。<br>classA{<br>voidfunc() const;<br>};<br>修饰类对象，类对象只能调用该对象的 const 成员函数。<br>classA {<br>voidfunc() const;<br>};<br>const A a;<br>a.func();<br>constexpr</p>
<p>constexpr 是 c++11 新引入的关键字，用于编译时的常量和常量函数，这里直接介绍 constexpr 和 const 的区别：</p>
<p>两者都代表可读，const 只表示 read only 的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而 constexpr 修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr 可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。如下代码：</p>
<p>#include<iostream><br>usingnamespacestd;</p>
<p>constexprintfunc(int i){<br>return i + 1;<br>}</p>
<p>intmain(){<br>int i &#x3D; 2;<br>func(i);&#x2F;&#x2F; 普通函数<br>func(2);&#x2F;&#x2F; 编译期间就会被计算出来<br>}<br>enum class</p>
<p>c++11 新增有作用域的枚举类型，看代码</p>
<p>不带作用域的枚举代码：</p>
<p>enum AColor {<br>kRed,<br>kGreen,<br>kBlue<br>};</p>
<p>enum BColor {<br>kWhite,<br>kBlack,<br>kYellow<br>};</p>
<p>intmain(){<br>if (kRed &#x3D;&#x3D; kWhite) {<br>cout &lt;&lt; “red &#x3D;&#x3D; white” &lt;&lt; endl;<br>}<br>return0;<br>}</p>
<p>如上代码，不带作用域的枚举类型可以自动转换成整形，且不同的枚举可以相互比较，代码中的红色居然可以和白色比较，这都是潜在的难以调试的 bug，而这种完全可以通过有作用域的枚举来规避。</p>
<p>有作用域的枚举代码：</p>
<p>enumclassAColor {<br>kRed,<br>kGreen,<br>kBlue<br>};</p>
<p>enumclassBColor {<br>kWhite,<br>kBlack,<br>kYellow<br>};</p>
<p>intmain(){<br>if (AColor::kRed &#x3D;&#x3D; BColor::kWhite) { &#x2F;&#x2F; 编译失败<br>cout &lt;&lt; “red &#x3D;&#x3D; white” &lt;&lt; endl;<br>}<br>return0;<br>}</p>
<p>使用带有作用域的枚举类型后，对不同的枚举进行比较会导致编译失败，消除潜在 bug，同时带作用域的枚举类型可以选择底层类型，默认是 int，可以改成 char 等别的类型。</p>
<p>enumclassAColor :char {<br>kRed,<br>kGreen,<br>kBlue<br>};</p>
<p>我们平时编程过程中使用枚举，一定要使用有作用域的枚举取代传统的枚举。</p>
<p>非受限联合体</p>
<p>c++11 之前 union 中数据成员的类型不允许有非 POD 类型，而这个限制在 c++11 被取消，允许数据成员类型有非 POD 类型，看代码：</p>
<p>structA {<br>int a;<br>int *b;<br>};</p>
<p>union U {<br>A a; &#x2F;&#x2F; 非 POD 类型 c++11 之前不可以这样定义联合体<br>int b;<br>};</p>
<p>对于什么是 POD 类型，大家可以自行查下资料，大体上可以理解为对象可以直接 memcpy 的类型。</p>
<p>sizeof</p>
<p>c++11 中 sizeof 可以用的类的数据成员上，看代码：</p>
<p>c++11 前：</p>
<p>structA {<br>int data[10];<br>int a;<br>};</p>
<p>intmain(){<br>A a;<br>cout &lt;&lt; “size “ &lt;&lt; sizeof(a.data) &lt;&lt; endl;<br>return0;<br>}</p>
<p>c++11 后：</p>
<p>structA {<br>int data[10];<br>int a;<br>};</p>
<p>intmain(){<br>cout &lt;&lt; “size “ &lt;&lt; sizeof(A::data) &lt;&lt; endl;<br>return0;<br>}</p>
<p>想知道类中数据成员的大小在 c++11 中是不是方便了许多，而不需要定义一个对象，在计算对象的成员大小。</p>
<p>assertion<br>static_assert(true&#x2F;false, message);</p>
<p>c++11 引入 static_assert 声明，用于在编译期间检查，如果第一个参数值为 false，则打印 message，编译失败。</p>
<p>自定义字面量</p>
<p>c++11 可以自定义字面量，我们平时 c++中都或多或少使用过 chrono 中的时间，例如：</p>
<p>std::this_thread::sleep_for(std::chrono::milliseconds(100)); &#x2F;&#x2F; 100ms<br>std::this_thread::sleep_for(std::chrono::seconds(100)); &#x2F;&#x2F; 100s</p>
<p>其实没必要这么麻烦，也可以这么写：</p>
<p>std::this_thread::sleep_for(100ms); &#x2F;&#x2F; c++14 里可以这么使用，这里只是举个自定义字面量使用的例子<br>std::this_thread::sleep_for(100s);</p>
<p>这就是自定义字面量的使用，示例如下：</p>
<p>structmytype {<br>unsignedlonglong value;<br>};<br>constexpr mytype operator”” _mytype ( unsignedlonglong n ) {<br>return mytype{n};<br>}<br>mytype mm &#x3D; 123_mytype;<br>cout &lt;&lt; mm.value &lt;&lt; endl;</p>
<p>关于自定义字面量，可以看下 chrono 的源代码，相信大家会有很大收获，需要源码分析 chrono 的话，可以留言给我。</p>
<p>内存对齐<br>什么是内存对齐</p>
<p>理论上计算机对于任何变量的访问都可以从任意位置开始，然而实际上系统会对这些变量的存放地址有限制，通常将变量首地址设为某个数 N 的倍数，这就是内存对齐。</p>
<p>为什么要内存对齐<br>硬件平台限制，内存以字节为单位，不同硬件平台不一定支持任何内存地址的存取，一般可能以双字节、4 字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐。<br>提高 CPU 内存访问速度，一般处理器的内存存取粒度都是 N 的整数倍，假如访问 N 大小的数据，没有进行内存对齐，有可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次性把数据全部读取出来，提高效率。</p>
<p>在 c++11 之前如果想创建内存对齐需要：</p>
<p>voidalign_cpp11_before()<br>{<br>staticchar data[sizeof(void *) + sizeof(A)];<br>constuintptr_t kAlign &#x3D; sizeof(void *) - 1;<br>char *align_ptr &#x3D;<br>reinterpret_cast&lt;char *&gt;(reinterpret_cast<uintptr_t>(data + kAlign) &amp; ~kAlign);<br>A *attr &#x3D; new (align_ptr) A;<br>}</p>
<p>c++11 关于内存对齐新增了一些函数：</p>
<p>voidalign_cpp11_after()<br>{<br>staticstd::aligned_storage&lt;sizeof(A),<br>alignof(A)&gt;::type data;<br>A *attr &#x3D; new (&amp;data) A;<br>}</p>
<p>还有：alignof()、std::alignment_of()、alignas()，关于内存对齐详情可以看这篇文章：内存对齐之格式修订版</p>
<p>thread_local</p>
<p>c++11 引入 thread_local，用 thread_local 修饰的变量具有 thread 周期，每一个线程都拥有并只拥有一个该变量的独立实例，一般用于需要保证线程安全的函数中。</p>
<p>#include<iostream><br>#include<thread></p>
<p>classA {<br>public:<br>A() {}<br>~A() {}</p>
<p>voidtest(conststd::string &amp;name){<br>thread_localint count &#x3D; 0;<br>++count;<br>std::cout &lt;&lt; name &lt;&lt; “: “ &lt;&lt; count &lt;&lt; std::endl;<br>}<br>};</p>
<p>voidfunc(conststd::string &amp;name){<br>A a1;<br>a1.test(name);<br>a1.test(name);<br>A a2;<br>a2.test(name);<br>a2.test(name);<br>}</p>
<p>intmain(){<br>std::thread(func, “thread1”).join();<br>std::thread(func, “thread2”).join();<br>return0;<br>}</p>
<p>输出：</p>
<p>thread1: 1<br>thread1: 2<br>thread1: 3<br>thread1: 4<br>thread2: 1<br>thread2: 2<br>thread2: 3<br>thread2: 4</p>
<p>验证上述说法，对于一个线程私有变量，一个线程拥有且只拥有一个该实例，类似于 static。</p>
<p>基础数值类型</p>
<p>c++11 新增了几种数据类型：long long、char16_t、char32_t 等</p>
<p>随机数功能</p>
<p>c++11 关于随机数功能则较之前丰富了很多，典型的可以选择概率分布类型，先看如下代码：</p>
<p>#include&lt;time.h&gt;</p>
<p>#include<iostream><br>#include<random></p>
<p>usingnamespacestd;</p>
<p>intmain(){<br>std::default_random_engine random(time(nullptr));</p>
<p>std::uniform_int_distribution<int> int_dis(0, 100); &#x2F;&#x2F; 整数均匀分布<br>std::uniform_real_distribution<float> real_dis(0.0, 1.0); &#x2F;&#x2F; 浮点数均匀分布</p>
<p>for (int i &#x3D; 0; i &lt; 10; ++i) {<br>cout &lt;&lt; int_dis(random) &lt;&lt; ‘ ‘;<br>}<br>cout &lt;&lt; endl;</p>
<p>for (int i &#x3D; 0; i &lt; 10; ++i) {<br>cout &lt;&lt; real_dis(random) &lt;&lt; ‘ ‘;<br>}<br>cout &lt;&lt; endl;</p>
<p>return0;<br>}</p>
<p>输出：</p>
<p>38 100 93 7 66 0 68 99 41 7<br>0.232202 0.617716 0.959241 0.970859 0.230406 0.430682 0.477359 0.971858 0.0171148 0.64863</p>
<p>代码中举例的是整数均匀分布和浮点数均匀分布，c++11 提供的概率分布类型还有好多，例如伯努利分布、正态分布等，具体可以见最后的参考资料。</p>
<p>正则表达式</p>
<p>c++11 引入了 regex 库更好的支持正则表达式，见代码：</p>
<p>#include<iostream><br>#include<iterator><br>#include<regex><br>#include<string></p>
<p>intmain(){<br>std::string s &#x3D; “I know, I’ll use2 regular expressions.”;<br>&#x2F;&#x2F; 忽略大小写<br>std::regex self_regex(“REGULAR EXPRESSIONS”, std::regex_constants::icase);<br>if (std::regex_search(s, self_regex)) {<br>std::cout &lt;&lt; “Text contains the phrase ‘regular expressions’\n”;<br>}</p>
<p>std::regex word_regex(“(\w+)”); &#x2F;&#x2F; 匹配字母数字等字符<br>auto words_begin &#x3D; std::sregex_iterator(s.begin(), s.end(), word_regex);<br>auto words_end &#x3D; std::sregex_iterator();</p>
<p>std::cout &lt;&lt; “Found “ &lt;&lt; std::distance(words_begin, words_end) &lt;&lt; “ words\n”;</p>
<p>constint N &#x3D; 6;<br>std::cout &lt;&lt; “Words longer than “ &lt;&lt; N &lt;&lt; “ characters:\n”;<br>for (std::sregex_iterator i &#x3D; words_begin; i !&#x3D; words_end; ++i) {<br>std::smatch match &#x3D; *i;<br>std::string match_str &#x3D; match.str();<br>if (match_str.size() &gt; N) {<br>std::cout &lt;&lt; “ “ &lt;&lt; match_str &lt;&lt; ‘\n’;<br>}<br>}</p>
<p>std::regex long_word_regex(“(\w{7,})”);<br>&#x2F;&#x2F; 超过 7 个字符的单词用[]包围<br>std::string new_s &#x3D; std::regex_replace(s, long_word_regex, “[$&amp;]”);<br>std::cout &lt;&lt; new_s &lt;&lt; ‘\n’;<br>}<br>chrono</p>
<p>c++11 关于时间引入了 chrono 库，源于 boost，功能强大，chrono 主要有三个点：</p>
<p>duration<br>time_point<br>clocks<br>duration</p>
<p>std::chrono::duration 表示一段时间，常见的单位有 s、ms 等，示例代码：</p>
<p>&#x2F;&#x2F; 拿休眠一段时间举例，这里表示休眠 100ms<br>std::this_thread::sleep_for(std::chrono::milliseconds(100));</p>
<p>sleep_for 里面其实就是 std::chrono::duration，表示一段时间，实际是这样：</p>
<p>typedef duration&lt;int64_t, milli&gt; milliseconds;<br>typedef duration<int64_t> seconds;</p>
<p>duration 具体模板如下：</p>
<p>1 template &lt;classRep, classPeriod&#x3D; ratio&lt;1&gt; &gt; classduration;</p>
<p>Rep 表示一种数值类型，用来表示 Period 的数量，比如 int、float、double，Period 是 ratio 类型，用来表示【用秒表示的时间单位】比如 second，常用的 duration&lt;Rep, Period&gt;已经定义好了，在 std::chrono::duration 下：</p>
<p>ratio&lt;3600, 1&gt;：hours<br>ratio&lt;60, 1&gt;：minutes<br>ratio&lt;1, 1&gt;：seconds<br>ratio&lt;1, 1000&gt;：microseconds<br>ratio&lt;1, 1000000&gt;：microseconds<br>ratio&lt;1, 1000000000&gt;：nanosecons</p>
<p>ratio 的具体模板如下：</p>
<p>template &lt;intmax_t N, intmax_t D &#x3D; 1&gt; class ratio;</p>
<p>N 代表分子，D 代表分母，所以 ratio 表示一个分数，我们可以自定义 Period，比如 ratio&lt;2, 1&gt;表示单位时间是 2 秒。</p>
<p>time_point</p>
<p>表示一个具体时间点，如 2020 年 5 月 10 日 10 点 10 分 10 秒，拿获取当前时间举例：</p>
<p>std::chrono::time_point<a href="std::chrono::high_resolution_clock">std::chrono::high_resolution_clock</a> Now() {<br>returnstd::chrono::high_resolution_clock::now();<br>}<br>&#x2F;&#x2F; std::chrono::high_resolution_clock 为高精度时钟，下面会提到</p>
<p>clocks</p>
<p>时钟，chrono 里面提供了三种时钟：</p>
<p>steady_clock<br>system_clock<br>high_resolution_clock<br>steady_clock</p>
<p>稳定的时间间隔，表示相对时间，相对于系统开机启动的时间，无论系统时间如何被更改，后一次调用 now()肯定比前一次调用 now()的数值大，可用于计时。</p>
<p>system_clock</p>
<p>表示当前的系统时钟，可以用于获取当前时间：</p>
<p>intmain(){<br>usingstd::chrono::system_clock;<br>system_clock::time_point today &#x3D; system_clock::now();</p>
<p>std::time_t tt &#x3D; system_clock::to_time_t(today);<br>std::cout &lt;&lt; “today is: “ &lt;&lt; ctime(&amp;tt);</p>
<p>return0;<br>}<br>&#x2F;&#x2F; today is: Sun May 10 09:48:36 2020</p>
<p>high_resolution_clock</p>
<p>high_resolution_clock 表示系统可用的最高精度的时钟，实际上就是 system_clock 或者 steady_clock 其中一种的定义，官方没有说明具体是哪个，不同系统可能不一样，我之前看 gcc chrono 源码中 high_resolution_clock 是 steady_clock 的 typedef。</p>
<p>更多关于 chrono 的介绍可以看下我之前的文章：RAII 妙用之计算函数耗时</p>
<p>新增数据结构<br>std::forward_list：单向链表，只可以前进，在特定场景下使用，相比于 std::list 节省了内存，提高了性能<br>std::forward_list<int> fl &#x3D; {1, 2, 3, 4, 5};<br>for (constauto &amp;elem : fl) {<br>cout &lt;&lt; elem;<br>}<br>std::unordered_set：基于 hash 表实现的 set，内部不会排序，使用方法和 set 类似<br>std::unordered_map：基于 hash 表实现的 map，内部不会排序，使用方法和 set 类似<br>std::array：数组，在越界访问时抛出异常，建议使用 std::array 替代普通的数组<br>std::tuple：元组类型，类似 pair，但比 pair 扩展性好<br>typedefstd::tuple&lt;int, double, int, double&gt; Mytuple;<br>Mytuple t(0, 1, 2, 3);<br>std::cout &lt;&lt; “0 “ &lt;&lt; std::get&lt;0&gt;(t);<br>std::cout &lt;&lt; “1 “ &lt;&lt; std::get&lt;1&gt;(t);<br>std::cout &lt;&lt; “2 “ &lt;&lt; std::get&lt;2&gt;(t);<br>std::cout &lt;&lt; “3 “ &lt;&lt; std::get&lt;3&gt;(t);</p>
<p>新增算法</p>
<p>all_of：检测表达式是否对范围[first, last)中所有元素都返回 true，如果都满足，则返回 true<br>std::vector<int> v(10, 2);<br>if (std::all_of(v.cbegin(), v.cend(), [](int i) { return i % 2 &#x3D;&#x3D; 0; })) {<br>std::cout &lt;&lt; “All numbers are even\n”;<br>}<br>any_of：检测表达式是否对范围[first, last)中至少一个元素返回 true，如果满足，则返回 true，否则返回 false，用法和上面一样<br>none_of：检测表达式是否对范围[first, last)中所有元素都不返回 true，如果都不满足，则返回 true，否则返回 false，用法和上面一样<br>find_if_not：找到第一个不符合要求的元素迭代器，和 find_if 相反<br>copy_if：复制满足条件的元素<br>itoa：对容器内的元素按序递增<br>std::vector<int> l(10);<br>std::iota(l.begin(), l.end(), 19); &#x2F;&#x2F; 19 为初始值<br>for (auto n : l) std::cout &lt;&lt; n &lt;&lt; ‘ ‘;<br>&#x2F;&#x2F; 19 20 21 22 23 24 25 26 27 28<br>minmax_element：返回容器内最大元素和最小元素位置<br>intmain(){<br>std::vector<int> v &#x3D; {3, 9, 1, 4, 2, 5, 9};</p>
<p>auto result &#x3D; std::minmax*element(v.begin(), v.end());<br>std::cout &lt;&lt; “min element at: “ &lt;&lt; *(result.first) &lt;&lt; ‘\n’;<br>std::cout &lt;&lt; “max element at: “ &lt;&lt; _(result.second) &lt;&lt; ‘\n’;<br>return0;<br>}<br>&#x2F;&#x2F; min element at: 1<br>&#x2F;&#x2F; max element at: 9<br>is_sorted、is_sorted_until：返回容器内元素是否已经排好序。</p>
<p>关于 c++11 的新特性基本上就是这些，相信各位看完一定会有所收获。</p>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/range-for">https://zh.cppreference.com/w/cpp/language/range-for</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5dcaa857e51d457f7675360b">https://juejin.im/post/5dcaa857e51d457f7675360b</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21930436">https://zhuanlan.zhihu.com/p/21930436</a><br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Nullptr">https://zh.wikipedia.org/wiki/Nullptr</a><br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Constexpr">https://zh.wikipedia.org/wiki/Constexpr</a><br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/enum">https://zh.cppreference.com/w/cpp/language/enum</a><br><a target="_blank" rel="noopener" href="https://kheresy.wordpress.com/2019/03/27/using-enum-class/">https://kheresy.wordpress.com/2019/03/27/using-enum-class/</a><br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/union">https://zh.cppreference.com/w/cpp/language/union</a><br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/7165.html">http://c.biancheng.net/view/7165.html</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/77585472">https://zhuanlan.zhihu.com/p/77585472</a><br><a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/random/">http://www.cplusplus.com/reference/random/</a><br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/regex">https://zh.cppreference.com/w/cpp/regex</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jwk000/p/3560086.html">https://www.cnblogs.com/jwk000/p/3560086.html</a><br><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/algorithm/all_any_none_of">https://zh.cppreference.com/w/cpp/algorithm/all_any_none_of</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="C-名称粉碎使用-C-filt-工具恢复"><a href="#C-名称粉碎使用-C-filt-工具恢复" class="headerlink" title="C++ 名称粉碎使用 C++filt 工具恢复"></a><code>C++</code> 名称粉碎使用 <code>C++filt</code> 工具恢复</h2><p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ c++filt _Z3addii</span><br><span class="line">add(int, int)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="判断编译平台宏定义"><a href="#判断编译平台宏定义" class="headerlink" title="判断编译平台宏定义"></a>判断编译平台宏定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">   <span class="comment">//define something for Windows (32-bit and 64-bit, this part is common)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">      <span class="comment">//define something for Windows (64-bit only)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="comment">//define something for Windows (32-bit only)</span></span><br><span class="line">   <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __APPLE__</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TargetConditionals.h&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">         <span class="comment">// iOS Simulator</span></span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> TARGET_OS_IPHONE</span></span><br><span class="line">        <span class="comment">// iOS device</span></span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> TARGET_OS_MAC</span></span><br><span class="line">        <span class="comment">// Other kinds of Mac OS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#   <span class="keyword">error</span> <span class="string">&quot;Unknown Apple platform&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __ANDROID__</span></span><br><span class="line">    <span class="comment">// android</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line">    <span class="comment">// linux</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __unix__ <span class="comment">// all unices not caught above</span></span></span><br><span class="line">    <span class="comment">// Unix</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_POSIX_VERSION)</span></span><br><span class="line">    <span class="comment">// POSIX</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="keyword">error</span> <span class="string">&quot;Unknown compiler&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="error-C2027-use-of-undefined-type"><a href="#error-C2027-use-of-undefined-type" class="headerlink" title="error C2027: use of undefined type"></a>error C2027: use of undefined type</h2><p>当遇到这种问题时， 将实现写到 cpp 文件中。</p>
<p>例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># builder.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Burger</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BurgerBuilder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">float</span> size;</span><br><span class="line">	<span class="type">bool</span> cheese = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> pepperoni = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> lettuce = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> tomato = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">BurgerBuilder</span>(<span class="type">float</span> size) : <span class="built_in">size</span>(size) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">Burger* <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 将下列的实现代码写到 cpp 文件中，否则会报 error C2027: use of undefined type 错误。</span></span><br><span class="line">	<span class="comment">// &#123;</span></span><br><span class="line">	<span class="comment">// 	return new Burger(this);</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Burger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">float</span> size;</span><br><span class="line">	<span class="type">bool</span> cheese = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> pepperoni = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> lettuce = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> tomato = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Burger</span>(BurgerBuilder* builder) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;size = builder-&gt;size;</span><br><span class="line">		<span class="keyword">this</span>-&gt;cheese = builder-&gt;cheese;</span><br><span class="line">		<span class="keyword">this</span>-&gt;pepperoni = builder-&gt;pepperoni;</span><br><span class="line">		<span class="keyword">this</span>-&gt;lettuce = builder-&gt;lettuce;</span><br><span class="line">		<span class="keyword">this</span>-&gt;tomato = builder-&gt;tomato;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// builder.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Builder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">Burger* <span class="title">BurgerBuilder::build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Burger</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/33964994/error-c2027-use-of-undefined-type-how-to-declare-class">https://stackoverflow.com/questions/33964994/error-c2027-use-of-undefined-type-how-to-declare-class</a></p>
</blockquote>
<h2 id="jupyter-notebook-for-C"><a href="#jupyter-notebook-for-C" class="headerlink" title="jupyter notebook for C++"></a>jupyter notebook for C++</h2><p>这里可以使用 <a target="_blank" rel="noopener" href="https://github.com/jupyter-xeus/xeus-cling">xeus-cling</a> 搭建一个 Jupyter kernel 环境，方便边做笔记边测试。</p>
<p>首先安装 <a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">Miniconda</a> 并创建一个新的环境。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ conda create -n cling python=3.9</span><br></pre></td></tr></table></figure>

<p>然后安装<a target="_blank" rel="noopener" href="https://github.com/jupyter-xeus/xeus-cling">xeus-cling</a> 和 <a target="_blank" rel="noopener" href="https://jupyter.org/install">Jupyter Notebook</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ conda install jupyter notebook</span><br><span class="line">$ conda install xeus-cling -c conda-forge</span><br></pre></td></tr></table></figure>

<p>安装好了之后，运行 <code>jupyter kernelspec list</code> 将会出现下列内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ jupyter kernelspec list</span><br><span class="line">Available kernels:</span><br><span class="line">  python3    /home/ckcat/miniconda3/envs/cling/share/jupyter/kernels/python3</span><br><span class="line">  xcpp11     /home/ckcat/miniconda3/envs/cling/share/jupyter/kernels/xcpp11</span><br><span class="line">  xcpp14     /home/ckcat/miniconda3/envs/cling/share/jupyter/kernels/xcpp14</span><br><span class="line">  xcpp17     /home/ckcat/miniconda3/envs/cling/share/jupyter/kernels/xcpp17</span><br></pre></td></tr></table></figure>

<p>之后运行 <code>jupyter notebook --allow-root --ip=0.0.0.0 --port=2233</code> 命令即可。</p>
<ul>
<li><code>--ip=0.0.0.0</code> 作用是允许外部试用。</li>
<li><code>--port=2233</code> 表示运行的端口。</li>
</ul>
<p>后面就可以通过本地浏览器写笔记和代码。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/12/15/MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/" rel="prev" title="MySQL的安装和配置">
                  <i class="fa fa-chevron-left"></i> MySQL的安装和配置
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/12/21/r2Frida%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/" rel="next" title="r2Frida环境配置及使用">
                  r2Frida环境配置及使用 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CKCat</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/CKCat" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
